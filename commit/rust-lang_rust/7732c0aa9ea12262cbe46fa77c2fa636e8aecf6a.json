{"sha": "7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MzJjMGFhOWVhMTIyNjJjYmU0NmZhNzdjMmZhNjM2ZThhZWNmNmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-11T12:52:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-11T12:52:42Z"}, "message": "Auto merge of #31487 - oli-obk:breaking_batch/ast/unop, r=Manishearth\n\nr? @Manishearth\n\nI just noticed they can't be rolled up (often modifying the same line(s) in imports). So once I reach the critical amount for them to be merged I'll create a PR that merges all of them.", "tree": {"sha": "8d0364921d0d70e6fdc67176297a1f1ee3e5070e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d0364921d0d70e6fdc67176297a1f1ee3e5070e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "html_url": "https://github.com/rust-lang/rust/commit/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5f8e0bfbeee2abc425f26a3ad36430f23010e69", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f8e0bfbeee2abc425f26a3ad36430f23010e69", "html_url": "https://github.com/rust-lang/rust/commit/f5f8e0bfbeee2abc425f26a3ad36430f23010e69"}, {"sha": "bafea3bf78e75c99958ef15fd3d06652cb63133c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bafea3bf78e75c99958ef15fd3d06652cb63133c", "html_url": "https://github.com/rust-lang/rust/commit/bafea3bf78e75c99958ef15fd3d06652cb63133c"}], "stats": {"total": 4767, "additions": 2352, "deletions": 2415}, "files": [{"sha": "cfd9d5bdaa75d11be74b88e9e209a9aab7b7a4b3", "filename": "src/librustc/front/check_attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Ffront%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Ffront%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcheck_attr.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -26,9 +26,9 @@ enum Target {\n impl Target {\n     fn from_item(item: &ast::Item) -> Target {\n         match item.node {\n-            ast::ItemFn(..) => Target::Fn,\n-            ast::ItemStruct(..) => Target::Struct,\n-            ast::ItemEnum(..) => Target::Enum,\n+            ast::ItemKind::Fn(..) => Target::Fn,\n+            ast::ItemKind::Struct(..) => Target::Struct,\n+            ast::ItemKind::Enum(..) => Target::Enum,\n             _ => Target::Other,\n         }\n     }"}, {"sha": "f398c465ffe6e72b587eb6def6ebb34af52933be", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -20,7 +20,7 @@ use middle::cstore::InlinedItem;\n use middle::cstore::InlinedItem as II;\n use middle::def_id::DefId;\n \n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID};\n use syntax::codemap::{Span, Spanned};\n use syntax::parse::token;\n@@ -512,7 +512,7 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn get_foreign_abi(&self, id: NodeId) -> abi::Abi {\n+    pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let parent = self.get_parent(id);\n         let abi = match self.find_entry(parent) {\n             Some(EntryItem(_, i)) => {\n@@ -522,7 +522,7 @@ impl<'ast> Map<'ast> {\n                 }\n             }\n             /// Wrong but OK, because the only inlined foreign items are intrinsics.\n-            Some(RootInlinedParent(_)) => Some(abi::RustIntrinsic),\n+            Some(RootInlinedParent(_)) => Some(Abi::RustIntrinsic),\n             _ => None\n         };\n         match abi {"}, {"sha": "5af184385d909f3c0949178b65672595ff583b47", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -374,7 +374,7 @@ pub fn gather_attr(attr: &ast::Attribute)\n \n     let meta = &attr.node.value;\n     let metas = match meta.node {\n-        ast::MetaList(_, ref metas) => metas,\n+        ast::MetaItemKind::List(_, ref metas) => metas,\n         _ => {\n             out.push(Err(meta.span));\n             return out;\n@@ -383,7 +383,7 @@ pub fn gather_attr(attr: &ast::Attribute)\n \n     for meta in metas {\n         out.push(match meta.node {\n-            ast::MetaWord(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n+            ast::MetaItemKind::Word(ref lint_name) => Ok((lint_name.clone(), level, meta.span)),\n             _ => Err(meta.span),\n         });\n     }"}, {"sha": "62b6279bb332947f7b6ffab0a7f7d309d82efb69", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -421,7 +421,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n \n fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n     let node = match value {\n-        &ConstVal::Bool(b) => ast::LitBool(b),\n+        &ConstVal::Bool(b) => ast::LitKind::Bool(b),\n         _ => unreachable!()\n     };\n     P(hir::Expr {"}, {"sha": "6650a06229adcd3ea4bb36e8b08b7999e932f97e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -545,34 +545,34 @@ pub enum UintTy { U8, U16, U32, U64 }\n \n impl IntTy {\n     pub fn from(tcx: &ty::ctxt, t: ast::IntTy) -> IntTy {\n-        let t = if let ast::TyIs = t {\n+        let t = if let ast::IntTy::Is = t {\n             tcx.sess.target.int_type\n         } else {\n             t\n         };\n         match t {\n-            ast::TyIs => unreachable!(),\n-            ast::TyI8  => IntTy::I8,\n-            ast::TyI16 => IntTy::I16,\n-            ast::TyI32 => IntTy::I32,\n-            ast::TyI64 => IntTy::I64,\n+            ast::IntTy::Is => unreachable!(),\n+            ast::IntTy::I8  => IntTy::I8,\n+            ast::IntTy::I16 => IntTy::I16,\n+            ast::IntTy::I32 => IntTy::I32,\n+            ast::IntTy::I64 => IntTy::I64,\n         }\n     }\n }\n \n impl UintTy {\n     pub fn from(tcx: &ty::ctxt, t: ast::UintTy) -> UintTy {\n-        let t = if let ast::TyUs = t {\n+        let t = if let ast::UintTy::Us = t {\n             tcx.sess.target.uint_type\n         } else {\n             t\n         };\n         match t {\n-            ast::TyUs => unreachable!(),\n-            ast::TyU8  => UintTy::U8,\n-            ast::TyU16 => UintTy::U16,\n-            ast::TyU32 => UintTy::U32,\n-            ast::TyU64 => UintTy::U64,\n+            ast::UintTy::Us => unreachable!(),\n+            ast::UintTy::U8  => UintTy::U8,\n+            ast::UintTy::U16 => UintTy::U16,\n+            ast::UintTy::U32 => UintTy::U32,\n+            ast::UintTy::U64 => UintTy::U64,\n         }\n     }\n }\n@@ -1289,65 +1289,63 @@ fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: ConstVal, ty: Ty) -> CastResult {\n \n     // Issue #23890: If isize/usize, then dispatch to appropriate target representation type\n     match (&ty.sty, tcx.sess.target.int_type, tcx.sess.target.uint_type) {\n-        (&ty::TyInt(ast::TyIs), ast::TyI32, _) => return convert_val!(i32, Int, i64),\n-        (&ty::TyInt(ast::TyIs), ast::TyI64, _) => return convert_val!(i64, Int, i64),\n-        (&ty::TyInt(ast::TyIs), _, _) => panic!(\"unexpected target.int_type\"),\n+        (&ty::TyInt(ast::IntTy::Is), ast::IntTy::I32, _) => return convert_val!(i32, Int, i64),\n+        (&ty::TyInt(ast::IntTy::Is), ast::IntTy::I64, _) => return convert_val!(i64, Int, i64),\n+        (&ty::TyInt(ast::IntTy::Is), _, _) => panic!(\"unexpected target.int_type\"),\n \n-        (&ty::TyUint(ast::TyUs), _, ast::TyU32) => return convert_val!(u32, Uint, u64),\n-        (&ty::TyUint(ast::TyUs), _, ast::TyU64) => return convert_val!(u64, Uint, u64),\n-        (&ty::TyUint(ast::TyUs), _, _) => panic!(\"unexpected target.uint_type\"),\n+        (&ty::TyUint(ast::UintTy::Us), _, ast::UintTy::U32) => return convert_val!(u32, Uint, u64),\n+        (&ty::TyUint(ast::UintTy::Us), _, ast::UintTy::U64) => return convert_val!(u64, Uint, u64),\n+        (&ty::TyUint(ast::UintTy::Us), _, _) => panic!(\"unexpected target.uint_type\"),\n \n         _ => {}\n     }\n \n     match ty.sty {\n-        ty::TyInt(ast::TyIs) => unreachable!(),\n-        ty::TyUint(ast::TyUs) => unreachable!(),\n+        ty::TyInt(ast::IntTy::Is) => unreachable!(),\n+        ty::TyUint(ast::UintTy::Us) => unreachable!(),\n \n-        ty::TyInt(ast::TyI8) => convert_val!(i8, Int, i64),\n-        ty::TyInt(ast::TyI16) => convert_val!(i16, Int, i64),\n-        ty::TyInt(ast::TyI32) => convert_val!(i32, Int, i64),\n-        ty::TyInt(ast::TyI64) => convert_val!(i64, Int, i64),\n+        ty::TyInt(ast::IntTy::I8) => convert_val!(i8, Int, i64),\n+        ty::TyInt(ast::IntTy::I16) => convert_val!(i16, Int, i64),\n+        ty::TyInt(ast::IntTy::I32) => convert_val!(i32, Int, i64),\n+        ty::TyInt(ast::IntTy::I64) => convert_val!(i64, Int, i64),\n \n-        ty::TyUint(ast::TyU8) => convert_val!(u8, Uint, u64),\n-        ty::TyUint(ast::TyU16) => convert_val!(u16, Uint, u64),\n-        ty::TyUint(ast::TyU32) => convert_val!(u32, Uint, u64),\n-        ty::TyUint(ast::TyU64) => convert_val!(u64, Uint, u64),\n+        ty::TyUint(ast::UintTy::U8) => convert_val!(u8, Uint, u64),\n+        ty::TyUint(ast::UintTy::U16) => convert_val!(u16, Uint, u64),\n+        ty::TyUint(ast::UintTy::U32) => convert_val!(u32, Uint, u64),\n+        ty::TyUint(ast::UintTy::U64) => convert_val!(u64, Uint, u64),\n \n-        ty::TyFloat(ast::TyF32) => convert_val!(f32, Float, f64),\n-        ty::TyFloat(ast::TyF64) => convert_val!(f64, Float, f64),\n+        ty::TyFloat(ast::FloatTy::F32) => convert_val!(f32, Float, f64),\n+        ty::TyFloat(ast::FloatTy::F64) => convert_val!(f64, Float, f64),\n         _ => Err(ErrKind::CannotCast),\n     }\n }\n \n fn lit_to_const(sess: &Session, span: Span, lit: &ast::Lit, ty_hint: Option<Ty>) -> ConstVal {\n     match lit.node {\n-        ast::LitStr(ref s, _) => Str((*s).clone()),\n-        ast::LitByteStr(ref data) => {\n+        ast::LitKind::Str(ref s, _) => Str((*s).clone()),\n+        ast::LitKind::ByteStr(ref data) => {\n             ByteStr(data.clone())\n         }\n-        ast::LitByte(n) => Uint(n as u64),\n-        ast::LitChar(n) => Uint(n as u64),\n-        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) => Int(n as i64),\n-        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => {\n+        ast::LitKind::Byte(n) => Uint(n as u64),\n+        ast::LitKind::Char(n) => Uint(n as u64),\n+        ast::LitKind::Int(n, ast::LitIntType::Signed(_)) => Int(n as i64),\n+        ast::LitKind::Int(n, ast::LitIntType::Unsuffixed) => {\n             match ty_hint.map(|ty| &ty.sty) {\n                 Some(&ty::TyUint(_)) => Uint(n),\n                 _ => Int(n as i64)\n             }\n         }\n-        ast::LitInt(n, ast::SignedIntLit(_, ast::Minus)) |\n-        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => Int(-(n as i64)),\n-        ast::LitInt(n, ast::UnsignedIntLit(_)) => Uint(n),\n-        ast::LitFloat(ref n, _) |\n-        ast::LitFloatUnsuffixed(ref n) => {\n+        ast::LitKind::Int(n, ast::LitIntType::Unsigned(_)) => Uint(n),\n+        ast::LitKind::Float(ref n, _) |\n+        ast::LitKind::FloatUnsuffixed(ref n) => {\n             if let Ok(x) = n.parse::<f64>() {\n                 Float(x)\n             } else {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n                 sess.span_bug(span, \"could not evaluate float literal (see issue #31407)\");\n             }\n         }\n-        ast::LitBool(b) => Bool(b)\n+        ast::LitKind::Bool(b) => Bool(b)\n     }\n }\n "}, {"sha": "a763677db066109b203bc4a0b7a4224d1d564139", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -17,7 +17,7 @@ use middle::ty::{self, Ty, TypeFoldable};\n \n use std::fmt;\n \n-use syntax::abi::RustIntrinsic;\n+use syntax::abi::Abi::RustIntrinsic;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc_front::intravisit::{self, Visitor, FnKind};"}, {"sha": "d34c3b742179c9555eccbefe37a50af89b5cb410", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -25,7 +25,7 @@ use session::config;\n use util::nodemap::NodeSet;\n \n use std::collections::HashSet;\n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use rustc_front::hir;\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // participate in linkage after this product is produced)\n             if let ast_map::NodeItem(item) = *node {\n                 if let hir::ItemFn(_, _, _, abi, _, _) = item.node {\n-                    if abi != abi::Rust {\n+                    if abi != Abi::Rust {\n                         self.reachable_symbols.insert(search_item);\n                     }\n                 }"}, {"sha": "29355e0684d96cafc59f95f185b85f84e80bbfbb", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -46,7 +46,7 @@ use middle::ty::relate::TypeRelation;\n use std::cell::RefCell;\n use std::fmt;\n use std::rc::Rc;\n-use syntax::abi;\n+use syntax::abi::Abi;\n use rustc_front::hir;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashMap;\n@@ -1288,7 +1288,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // provide an impl, but only for suitable `fn` pointers\n             ty::TyBareFn(_, &ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n-                abi: abi::Rust,\n+                abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: _,\n                     output: ty::FnConverging(_),"}, {"sha": "3a42e8e9bfaa6931853ee8c04a9dd14adf6b67f9", "filename": "src/librustc/middle/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -180,7 +180,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n             let result = match ty.sty {\n                 // usize and isize are ffi-unsafe\n-                ty::TyUint(ast::TyUs) | ty::TyInt(ast::TyIs) => {\n+                ty::TyUint(ast::UintTy::Us) | ty::TyInt(ast::IntTy::Is) => {\n                     TC::None\n                 }\n "}, {"sha": "1d071cd604db48d9b95675a848ebe3083cac329c", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -44,7 +44,7 @@ use std::borrow::Borrow;\n use std::cell::{Cell, RefCell, Ref};\n use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::parse::token::special_idents;\n@@ -192,18 +192,18 @@ impl<'tcx> CommonTypes<'tcx> {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n             err: mk(TyError),\n-            isize: mk(TyInt(ast::TyIs)),\n-            i8: mk(TyInt(ast::TyI8)),\n-            i16: mk(TyInt(ast::TyI16)),\n-            i32: mk(TyInt(ast::TyI32)),\n-            i64: mk(TyInt(ast::TyI64)),\n-            usize: mk(TyUint(ast::TyUs)),\n-            u8: mk(TyUint(ast::TyU8)),\n-            u16: mk(TyUint(ast::TyU16)),\n-            u32: mk(TyUint(ast::TyU32)),\n-            u64: mk(TyUint(ast::TyU64)),\n-            f32: mk(TyFloat(ast::TyF32)),\n-            f64: mk(TyFloat(ast::TyF64)),\n+            isize: mk(TyInt(ast::IntTy::Is)),\n+            i8: mk(TyInt(ast::IntTy::I8)),\n+            i16: mk(TyInt(ast::IntTy::I16)),\n+            i32: mk(TyInt(ast::IntTy::I32)),\n+            i64: mk(TyInt(ast::IntTy::I64)),\n+            usize: mk(TyUint(ast::UintTy::Us)),\n+            u8: mk(TyUint(ast::UintTy::U8)),\n+            u16: mk(TyUint(ast::UintTy::U16)),\n+            u32: mk(TyUint(ast::UintTy::U32)),\n+            u64: mk(TyUint(ast::UintTy::U64)),\n+            f32: mk(TyFloat(ast::FloatTy::F32)),\n+            f64: mk(TyFloat(ast::FloatTy::F64)),\n         }\n     }\n }\n@@ -840,28 +840,28 @@ impl<'tcx> ctxt<'tcx> {\n \n     pub fn mk_mach_int(&self, tm: ast::IntTy) -> Ty<'tcx> {\n         match tm {\n-            ast::TyIs   => self.types.isize,\n-            ast::TyI8   => self.types.i8,\n-            ast::TyI16  => self.types.i16,\n-            ast::TyI32  => self.types.i32,\n-            ast::TyI64  => self.types.i64,\n+            ast::IntTy::Is   => self.types.isize,\n+            ast::IntTy::I8   => self.types.i8,\n+            ast::IntTy::I16  => self.types.i16,\n+            ast::IntTy::I32  => self.types.i32,\n+            ast::IntTy::I64  => self.types.i64,\n         }\n     }\n \n     pub fn mk_mach_uint(&self, tm: ast::UintTy) -> Ty<'tcx> {\n         match tm {\n-            ast::TyUs   => self.types.usize,\n-            ast::TyU8   => self.types.u8,\n-            ast::TyU16  => self.types.u16,\n-            ast::TyU32  => self.types.u32,\n-            ast::TyU64  => self.types.u64,\n+            ast::UintTy::Us   => self.types.usize,\n+            ast::UintTy::U8   => self.types.u8,\n+            ast::UintTy::U16  => self.types.u16,\n+            ast::UintTy::U32  => self.types.u32,\n+            ast::UintTy::U64  => self.types.u64,\n         }\n     }\n \n     pub fn mk_mach_float(&self, tm: ast::FloatTy) -> Ty<'tcx> {\n         match tm {\n-            ast::TyF32  => self.types.f32,\n-            ast::TyF64  => self.types.f64,\n+            ast::FloatTy::F32  => self.types.f32,\n+            ast::FloatTy::F64  => self.types.f64,\n         }\n     }\n \n@@ -943,7 +943,7 @@ impl<'tcx> ctxt<'tcx> {\n         let input_args = input_tys.iter().cloned().collect();\n         self.mk_fn(Some(def_id), self.mk_bare_fn(BareFnTy {\n             unsafety: hir::Unsafety::Normal,\n-            abi: abi::Rust,\n+            abi: Abi::Rust,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: input_args,\n                 output: ty::FnConverging(output),"}, {"sha": "974b5c4bc6c2a4db0aebf93035bc4ebaf416a1d0", "filename": "src/librustc/middle/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -105,8 +105,8 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TypeAndMut<'tcx> {\n         } else {\n             let mutbl = a.mutbl;\n             let variance = match mutbl {\n-                ast::MutImmutable => ty::Covariant,\n-                ast::MutMutable => ty::Invariant,\n+                ast::Mutability::MutImmutable => ty::Covariant,\n+                ast::Mutability::MutMutable => ty::Invariant,\n             };\n             let ty = try!(relation.relate_with_variance(variance, &a.ty, &b.ty));\n             Ok(ty::TypeAndMut {ty: ty, mutbl: mutbl})"}, {"sha": "2a13c47895e0cbe678af5ee89fe9953de4d42614", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -977,7 +977,7 @@ impl<'tcx> TyS<'tcx> {\n     pub fn sequence_element_type(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => ty,\n-            TyStr => cx.mk_mach_uint(ast::TyU8),\n+            TyStr => cx.mk_mach_uint(ast::UintTy::U8),\n             _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n                                       self)),\n         }\n@@ -1068,7 +1068,7 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_uint(&self) -> bool {\n         match self.sty {\n-            TyInfer(IntVar(_)) | TyUint(ast::TyUs) => true,\n+            TyInfer(IntVar(_)) | TyUint(ast::UintTy::Us) => true,\n             _ => false\n         }\n     }\n@@ -1114,7 +1114,7 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn is_machine(&self) -> bool {\n         match self.sty {\n-            TyInt(ast::TyIs) | TyUint(ast::TyUs) => false,\n+            TyInt(ast::IntTy::Is) | TyUint(ast::UintTy::Us) => false,\n             TyInt(..) | TyUint(..) | TyFloat(..) => true,\n             _ => false\n         }"}, {"sha": "0b5c0d147cb5731952f7798abdcb2732dff7dd0c", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -44,48 +44,48 @@ pub trait IntTypeExt {\n impl IntTypeExt for attr::IntType {\n     fn to_ty<'tcx>(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n-            SignedInt(ast::TyI8)      => cx.types.i8,\n-            SignedInt(ast::TyI16)     => cx.types.i16,\n-            SignedInt(ast::TyI32)     => cx.types.i32,\n-            SignedInt(ast::TyI64)     => cx.types.i64,\n-            SignedInt(ast::TyIs)   => cx.types.isize,\n-            UnsignedInt(ast::TyU8)    => cx.types.u8,\n-            UnsignedInt(ast::TyU16)   => cx.types.u16,\n-            UnsignedInt(ast::TyU32)   => cx.types.u32,\n-            UnsignedInt(ast::TyU64)   => cx.types.u64,\n-            UnsignedInt(ast::TyUs) => cx.types.usize,\n+            SignedInt(ast::IntTy::I8)      => cx.types.i8,\n+            SignedInt(ast::IntTy::I16)     => cx.types.i16,\n+            SignedInt(ast::IntTy::I32)     => cx.types.i32,\n+            SignedInt(ast::IntTy::I64)     => cx.types.i64,\n+            SignedInt(ast::IntTy::Is)   => cx.types.isize,\n+            UnsignedInt(ast::UintTy::U8)    => cx.types.u8,\n+            UnsignedInt(ast::UintTy::U16)   => cx.types.u16,\n+            UnsignedInt(ast::UintTy::U32)   => cx.types.u32,\n+            UnsignedInt(ast::UintTy::U64)   => cx.types.u64,\n+            UnsignedInt(ast::UintTy::Us) => cx.types.usize,\n         }\n     }\n \n     fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n         match *self {\n-            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n-\n-            UnsignedInt(ast::TyUs) |\n-            SignedInt(ast::TyIs) => unreachable!(),\n+            SignedInt(ast::IntTy::I8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(ast::IntTy::I16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(ast::IntTy::I32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(ast::IntTy::I64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(ast::UintTy::U8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(ast::UintTy::U16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(ast::UintTy::U32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(ast::UintTy::U64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(ast::UintTy::Us) |\n+            SignedInt(ast::IntTy::Is) => unreachable!(),\n         }\n     }\n \n     fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n         match *self {\n-            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n-            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n-            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n-            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n-            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n-\n-            UnsignedInt(ast::TyUs) |\n-            SignedInt(ast::TyIs) => unreachable!(),\n+            SignedInt(ast::IntTy::I8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(ast::IntTy::I16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(ast::IntTy::I32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(ast::IntTy::I64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(ast::UintTy::U8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(ast::UintTy::U16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(ast::UintTy::U32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(ast::UintTy::U64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(ast::UintTy::Us) |\n+            SignedInt(ast::IntTy::Is) => unreachable!(),\n         }\n     }\n \n@@ -97,18 +97,18 @@ impl IntTypeExt for attr::IntType {\n             // SignedInt repr means we *want* to reinterpret the bits\n             // treating the highest bit of Disr as a sign-bit, so\n             // cast to i64 before range-checking.\n-            SignedInt(ast::TyI8)    => add1!((val as i64).to_i8()),\n-            SignedInt(ast::TyI16)   => add1!((val as i64).to_i16()),\n-            SignedInt(ast::TyI32)   => add1!((val as i64).to_i32()),\n-            SignedInt(ast::TyI64)   => add1!(Some(val as i64)),\n-\n-            UnsignedInt(ast::TyU8)  => add1!(val.to_u8()),\n-            UnsignedInt(ast::TyU16) => add1!(val.to_u16()),\n-            UnsignedInt(ast::TyU32) => add1!(val.to_u32()),\n-            UnsignedInt(ast::TyU64) => add1!(Some(val)),\n-\n-            UnsignedInt(ast::TyUs) |\n-            SignedInt(ast::TyIs) => unreachable!(),\n+            SignedInt(ast::IntTy::I8)    => add1!((val as i64).to_i8()),\n+            SignedInt(ast::IntTy::I16)   => add1!((val as i64).to_i16()),\n+            SignedInt(ast::IntTy::I32)   => add1!((val as i64).to_i32()),\n+            SignedInt(ast::IntTy::I64)   => add1!(Some(val as i64)),\n+\n+            UnsignedInt(ast::UintTy::U8)  => add1!(val.to_u8()),\n+            UnsignedInt(ast::UintTy::U16) => add1!(val.to_u16()),\n+            UnsignedInt(ast::UintTy::U32) => add1!(val.to_u32()),\n+            UnsignedInt(ast::UintTy::U64) => add1!(Some(val)),\n+\n+            UnsignedInt(ast::UintTy::Us) |\n+            SignedInt(ast::IntTy::Is) => unreachable!(),\n         }\n     }\n \n@@ -117,17 +117,17 @@ impl IntTypeExt for attr::IntType {\n     // full range from `i64::MIN` through `u64::MAX`.\n     fn disr_string(&self, val: Disr) -> String {\n         match *self {\n-            SignedInt(ast::TyI8)    => format!(\"{}\", val as i8 ),\n-            SignedInt(ast::TyI16)   => format!(\"{}\", val as i16),\n-            SignedInt(ast::TyI32)   => format!(\"{}\", val as i32),\n-            SignedInt(ast::TyI64)   => format!(\"{}\", val as i64),\n-            UnsignedInt(ast::TyU8)  => format!(\"{}\", val as u8 ),\n-            UnsignedInt(ast::TyU16) => format!(\"{}\", val as u16),\n-            UnsignedInt(ast::TyU32) => format!(\"{}\", val as u32),\n-            UnsignedInt(ast::TyU64) => format!(\"{}\", val as u64),\n-\n-            UnsignedInt(ast::TyUs) |\n-            SignedInt(ast::TyIs) => unreachable!(),\n+            SignedInt(ast::IntTy::I8)    => format!(\"{}\", val as i8 ),\n+            SignedInt(ast::IntTy::I16)   => format!(\"{}\", val as i16),\n+            SignedInt(ast::IntTy::I32)   => format!(\"{}\", val as i32),\n+            SignedInt(ast::IntTy::I64)   => format!(\"{}\", val as i64),\n+            UnsignedInt(ast::UintTy::U8)  => format!(\"{}\", val as u8 ),\n+            UnsignedInt(ast::UintTy::U16) => format!(\"{}\", val as u16),\n+            UnsignedInt(ast::UintTy::U32) => format!(\"{}\", val as u32),\n+            UnsignedInt(ast::UintTy::U64) => format!(\"{}\", val as u64),\n+\n+            UnsignedInt(ast::UintTy::Us) |\n+            SignedInt(ast::IntTy::Is) => unreachable!(),\n         }\n     }\n \n@@ -137,17 +137,17 @@ impl IntTypeExt for attr::IntType {\n         }\n         let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n         match *self {\n-            SignedInt(ast::TyI8)    => add1!(val as i8 ),\n-            SignedInt(ast::TyI16)   => add1!(val as i16),\n-            SignedInt(ast::TyI32)   => add1!(val as i32),\n-            SignedInt(ast::TyI64)   => add1!(val as i64),\n-            UnsignedInt(ast::TyU8)  => add1!(val as u8 ),\n-            UnsignedInt(ast::TyU16) => add1!(val as u16),\n-            UnsignedInt(ast::TyU32) => add1!(val as u32),\n-            UnsignedInt(ast::TyU64) => add1!(val as u64),\n-\n-            UnsignedInt(ast::TyUs) |\n-            SignedInt(ast::TyIs) => unreachable!(),\n+            SignedInt(ast::IntTy::I8)    => add1!(val as i8 ),\n+            SignedInt(ast::IntTy::I16)   => add1!(val as i16),\n+            SignedInt(ast::IntTy::I32)   => add1!(val as i32),\n+            SignedInt(ast::IntTy::I64)   => add1!(val as i64),\n+            UnsignedInt(ast::UintTy::U8)  => add1!(val as u8 ),\n+            UnsignedInt(ast::UintTy::U16) => add1!(val as u16),\n+            UnsignedInt(ast::UintTy::U32) => add1!(val as u32),\n+            UnsignedInt(ast::UintTy::U64) => add1!(val as u64),\n+\n+            UnsignedInt(ast::UintTy::Us) |\n+            SignedInt(ast::IntTy::Is) => unreachable!(),\n         }\n     }\n }\n@@ -279,14 +279,14 @@ impl<'tcx> ty::ctxt<'tcx> {\n             //\n             // NB. Historically `fn enum_variants` generate i64 here, while\n             // rustc_typeck::check would generate isize.\n-            _ => SignedInt(ast::TyIs),\n+            _ => SignedInt(ast::IntTy::Is),\n         };\n \n         let repr_type_ty = repr_type.to_ty(self);\n         let repr_type = match repr_type {\n-            SignedInt(ast::TyIs) =>\n+            SignedInt(ast::IntTy::Is) =>\n                 SignedInt(self.sess.target.int_type),\n-            UnsignedInt(ast::TyUs) =>\n+            UnsignedInt(ast::UintTy::Us) =>\n                 UnsignedInt(self.sess.target.uint_type),\n             other => other\n         };"}, {"sha": "20860b5a1e6f99d74a007478d718671ae7fb17d6", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -728,8 +728,8 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n     };\n \n     let (int_type, uint_type) = match &target.target_pointer_width[..] {\n-        \"32\" => (ast::TyI32, ast::TyU32),\n-        \"64\" => (ast::TyI64, ast::TyU64),\n+        \"32\" => (ast::IntTy::I32, ast::UintTy::U32),\n+        \"64\" => (ast::IntTy::I64, ast::UintTy::U64),\n         w    => panic!(sp.fatal(&format!(\"target specification was invalid: \\\n                                           unrecognized target-pointer-width {}\", w))),\n     };"}, {"sha": "a0939dc53dfcf23c3aaf301a56fc8cf59ce0084e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -20,7 +20,7 @@ use middle::ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use middle::ty::{self, Ty, TypeFoldable};\n \n use std::fmt;\n-use syntax::{abi};\n+use syntax::abi::Abi;\n use syntax::parse::token;\n use syntax::ast::CRATE_NODE_ID;\n use rustc_front::hir;\n@@ -814,7 +814,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     try!(write!(f, \"unsafe \"));\n                 }\n \n-                if bare_fn.abi != abi::Rust {\n+                if bare_fn.abi != Abi::Rust {\n                     try!(write!(f, \"extern {} \", bare_fn.abi));\n                 }\n "}, {"sha": "b29116309912aab334ed6542efc2a054b8e819a7", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -232,7 +232,7 @@ mod svh_visitor {\n         SawExprTup,\n         SawExprBinary(hir::BinOp_),\n         SawExprUnary(hir::UnOp),\n-        SawExprLit(ast::Lit_),\n+        SawExprLit(ast::LitKind),\n         SawExprCast,\n         SawExprType,\n         SawExprIf,"}, {"sha": "a6aef52caf6ed1b96cadc488c0a194b343086228", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -48,7 +48,7 @@\n use serialize::json::Json;\n use std::default::Default;\n use std::io::prelude::*;\n-use syntax::abi;\n+use syntax::abi::Abi;\n \n mod android_base;\n mod apple_base;\n@@ -262,13 +262,13 @@ impl Default for TargetOptions {\n \n impl Target {\n     /// Given a function ABI, turn \"System\" into the correct ABI for this target.\n-    pub fn adjust_abi(&self, abi: abi::Abi) -> abi::Abi {\n+    pub fn adjust_abi(&self, abi: Abi) -> Abi {\n         match abi {\n-            abi::System => {\n+            Abi::System => {\n                 if self.options.is_like_windows && self.arch == \"x86\" {\n-                    abi::Stdcall\n+                    Abi::Stdcall\n                 } else {\n-                    abi::C\n+                    Abi::C\n                 }\n             },\n             abi => abi"}, {"sha": "25cef24c50d5e02944c6c4e456f2bb195bbe0309", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -360,7 +360,7 @@ fn check_cfg(sopts: &config::Options,\n     let mut saw_invalid_predicate = false;\n     for item in sopts.cfg.iter() {\n         match item.node {\n-            ast::MetaList(ref pred, _) => {\n+            ast::MetaItemKind::List(ref pred, _) => {\n                 saw_invalid_predicate = true;\n                 emitter.emit(None,\n                              &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n@@ -560,18 +560,18 @@ impl RustcDefaultCalls {\n                 PrintRequest::Cfg => {\n                     for cfg in config::build_configuration(sess) {\n                         match cfg.node {\n-                            ast::MetaWord(ref word) => println!(\"{}\", word),\n-                            ast::MetaNameValue(ref name, ref value) => {\n+                            ast::MetaItemKind::Word(ref word) => println!(\"{}\", word),\n+                            ast::MetaItemKind::NameValue(ref name, ref value) => {\n                                 println!(\"{}=\\\"{}\\\"\", name, match value.node {\n-                                    ast::LitStr(ref s, _) => s,\n+                                    ast::LitKind::Str(ref s, _) => s,\n                                     _ => continue,\n                                 });\n                             }\n                             // Right now there are not and should not be any\n-                            // MetaList items in the configuration returned by\n+                            // MetaItemKind::List items in the configuration returned by\n                             // `build_configuration`.\n-                            ast::MetaList(..) => {\n-                                panic!(\"MetaList encountered in default cfg\")\n+                            ast::MetaItemKind::List(..) => {\n+                                panic!(\"MetaItemKind::List encountered in default cfg\")\n                             }\n                         }\n                     }"}, {"sha": "71f9d3c7e745840cf377e9dbcc0926384cbe9873", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -30,7 +30,7 @@ use rustc_borrowck::graphviz as borrowck_dot;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n \n-use syntax::ast;\n+use syntax::ast::{self, BlockCheckMode};\n use syntax::codemap;\n use syntax::fold::{self, Folder};\n use syntax::print::{pp, pprust};\n@@ -600,23 +600,23 @@ impl ReplaceBodyWithLoop {\n }\n \n impl fold::Folder for ReplaceBodyWithLoop {\n-    fn fold_item_underscore(&mut self, i: ast::Item_) -> ast::Item_ {\n+    fn fold_item_kind(&mut self, i: ast::ItemKind) -> ast::ItemKind {\n         match i {\n-            ast::ItemStatic(..) | ast::ItemConst(..) => {\n+            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n                 self.within_static_or_const = true;\n-                let ret = fold::noop_fold_item_underscore(i, self);\n+                let ret = fold::noop_fold_item_kind(i, self);\n                 self.within_static_or_const = false;\n                 return ret;\n             }\n             _ => {\n-                fold::noop_fold_item_underscore(i, self)\n+                fold::noop_fold_item_kind(i, self)\n             }\n         }\n     }\n \n     fn fold_trait_item(&mut self, i: P<ast::TraitItem>) -> SmallVector<P<ast::TraitItem>> {\n         match i.node {\n-            ast::ConstTraitItem(..) => {\n+            ast::TraitItemKind::Const(..) => {\n                 self.within_static_or_const = true;\n                 let ret = fold::noop_fold_trait_item(i, self);\n                 self.within_static_or_const = false;\n@@ -651,9 +651,9 @@ impl fold::Folder for ReplaceBodyWithLoop {\n \n         if !self.within_static_or_const {\n \n-            let empty_block = expr_to_block(ast::DefaultBlock, None);\n+            let empty_block = expr_to_block(BlockCheckMode::Default, None);\n             let loop_expr = P(ast::Expr {\n-                node: ast::ExprLoop(empty_block, None),\n+                node: ast::ExprKind::Loop(empty_block, None),\n                 id: ast::DUMMY_NODE_ID,\n                 span: codemap::DUMMY_SP,\n                 attrs: None,"}, {"sha": "3220295d9b88aca9f1d06eb3158b70b6ce6d6231", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -32,7 +32,8 @@ use rustc_metadata::cstore::CStore;\n use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n use std::rc::Rc;\n-use syntax::{abi, ast};\n+use syntax::ast;\n+use syntax::abi::Abi;\n use syntax::codemap::{MultiSpan, CodeMap, DUMMY_SP};\n use syntax::errors;\n use syntax::errors::emitter::Emitter;\n@@ -263,7 +264,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         self.infcx.tcx.mk_fn(None,\n                              self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n                                  unsafety: hir::Unsafety::Normal,\n-                                 abi: abi::Rust,\n+                                 abi: Abi::Rust,\n                                  sig: ty::Binder(ty::FnSig {\n                                      inputs: input_args,\n                                      output: ty::FnConverging(output_ty),"}, {"sha": "4e2729f3dab9d1c9e6811c0c7066b5b0c92eb29d", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -13,7 +13,7 @@\n \n use hir::*;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n-use syntax::ast::{MetaWord, MetaList, MetaNameValue};\n+use syntax::ast::MetaItemKind;\n use syntax::attr::ThinAttributesExt;\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n@@ -522,11 +522,11 @@ pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaIte\n     mi.map(|Spanned { node, span }| {\n         Spanned {\n             node: match node {\n-                MetaWord(id) => MetaWord(id),\n-                MetaList(id, mis) => {\n-                    MetaList(id, mis.move_map(|e| fld.fold_meta_item(e)))\n+                MetaItemKind::Word(id) => MetaItemKind::Word(id),\n+                MetaItemKind::List(id, mis) => {\n+                    MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_item(e)))\n                 }\n-                MetaNameValue(id, s) => MetaNameValue(id, s),\n+                MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s),\n             },\n             span: fld.new_span(span),\n         }"}, {"sha": "977f271c3014aa77148bf4aeb99f2f845c4b72ac", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 134, "deletions": 133, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -211,31 +211,31 @@ pub fn lower_view_path(lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::V\n             ViewPathList(ref path, ref path_list_idents) => {\n                 hir::ViewPathList(lower_path(lctx, path),\n                                   path_list_idents.iter()\n-                                                  .map(|path_list_ident| {\n-                                                      Spanned {\n-                                                          node: match path_list_ident.node {\n-                                                              PathListIdent { id, name, rename } =>\n-                                                                  hir::PathListIdent {\n-                                                                  id: id,\n-                                                                  name: name.name,\n-                                                                  rename: rename.map(|x| x.name),\n-                                                              },\n-                                                              PathListMod { id, rename } =>\n-                                                                  hir::PathListMod {\n-                                                                  id: id,\n-                                                                  rename: rename.map(|x| x.name),\n-                                                              },\n-                                                          },\n-                                                          span: path_list_ident.span,\n-                                                      }\n-                                                  })\n+                                                  .map(lower_path_list_item)\n                                                   .collect())\n             }\n         },\n         span: view_path.span,\n     })\n }\n \n+fn lower_path_list_item(path_list_ident: &PathListItem) -> hir::PathListItem {\n+    Spanned {\n+        node: match path_list_ident.node {\n+            PathListItemKind::Ident { id, name, rename } => hir::PathListIdent {\n+                id: id,\n+                name: name.name,\n+                rename: rename.map(|x| x.name),\n+            },\n+            PathListItemKind::Mod { id, rename } => hir::PathListMod {\n+                id: id,\n+                rename: rename.map(|x| x.name),\n+            },\n+        },\n+        span: path_list_ident.span,\n+    }\n+}\n+\n pub fn lower_arm(lctx: &LoweringContext, arm: &Arm) -> hir::Arm {\n     hir::Arm {\n         attrs: lower_attrs(lctx, &arm.attrs),\n@@ -247,11 +247,11 @@ pub fn lower_arm(lctx: &LoweringContext, arm: &Arm) -> hir::Arm {\n \n pub fn lower_decl(lctx: &LoweringContext, d: &Decl) -> P<hir::Decl> {\n     match d.node {\n-        DeclLocal(ref l) => P(Spanned {\n+        DeclKind::Local(ref l) => P(Spanned {\n             node: hir::DeclLocal(lower_local(lctx, l)),\n             span: d.span,\n         }),\n-        DeclItem(ref it) => P(Spanned {\n+        DeclKind::Item(ref it) => P(Spanned {\n             node: hir::DeclItem(lower_item_id(lctx, it)),\n             span: d.span,\n         }),\n@@ -268,28 +268,29 @@ pub fn lower_ty_binding(lctx: &LoweringContext, b: &TypeBinding) -> hir::TypeBin\n }\n \n pub fn lower_ty(lctx: &LoweringContext, t: &Ty) -> P<hir::Ty> {\n+    use syntax::ast::TyKind::*;\n     P(hir::Ty {\n         id: t.id,\n         node: match t.node {\n-            TyInfer => hir::TyInfer,\n-            TyVec(ref ty) => hir::TyVec(lower_ty(lctx, ty)),\n-            TyPtr(ref mt) => hir::TyPtr(lower_mt(lctx, mt)),\n-            TyRptr(ref region, ref mt) => {\n+            Infer => hir::TyInfer,\n+            Vec(ref ty) => hir::TyVec(lower_ty(lctx, ty)),\n+            Ptr(ref mt) => hir::TyPtr(lower_mt(lctx, mt)),\n+            Rptr(ref region, ref mt) => {\n                 hir::TyRptr(lower_opt_lifetime(lctx, region), lower_mt(lctx, mt))\n             }\n-            TyBareFn(ref f) => {\n+            BareFn(ref f) => {\n                 hir::TyBareFn(P(hir::BareFnTy {\n                     lifetimes: lower_lifetime_defs(lctx, &f.lifetimes),\n                     unsafety: lower_unsafety(lctx, f.unsafety),\n                     abi: f.abi,\n                     decl: lower_fn_decl(lctx, &f.decl),\n                 }))\n             }\n-            TyTup(ref tys) => hir::TyTup(tys.iter().map(|ty| lower_ty(lctx, ty)).collect()),\n-            TyParen(ref ty) => {\n+            Tup(ref tys) => hir::TyTup(tys.iter().map(|ty| lower_ty(lctx, ty)).collect()),\n+            Paren(ref ty) => {\n                 return lower_ty(lctx, ty);\n             }\n-            TyPath(ref qself, ref path) => {\n+            Path(ref qself, ref path) => {\n                 let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                     hir::QSelf {\n                         ty: lower_ty(lctx, ty),\n@@ -298,19 +299,19 @@ pub fn lower_ty(lctx: &LoweringContext, t: &Ty) -> P<hir::Ty> {\n                 });\n                 hir::TyPath(qself, lower_path(lctx, path))\n             }\n-            TyObjectSum(ref ty, ref bounds) => {\n+            ObjectSum(ref ty, ref bounds) => {\n                 hir::TyObjectSum(lower_ty(lctx, ty), lower_bounds(lctx, bounds))\n             }\n-            TyFixedLengthVec(ref ty, ref e) => {\n+            FixedLengthVec(ref ty, ref e) => {\n                 hir::TyFixedLengthVec(lower_ty(lctx, ty), lower_expr(lctx, e))\n             }\n-            TyTypeof(ref expr) => {\n+            Typeof(ref expr) => {\n                 hir::TyTypeof(lower_expr(lctx, expr))\n             }\n-            TyPolyTraitRef(ref bounds) => {\n+            PolyTraitRef(ref bounds) => {\n                 hir::TyPolyTraitRef(bounds.iter().map(|b| lower_ty_param_bound(lctx, b)).collect())\n             }\n-            TyMac(_) => panic!(\"TyMac should have been expanded by now.\"),\n+            Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n         },\n         span: t.span,\n     })\n@@ -408,26 +409,26 @@ pub fn lower_local(lctx: &LoweringContext, l: &Local) -> P<hir::Local> {\n }\n \n pub fn lower_explicit_self_underscore(lctx: &LoweringContext,\n-                                      es: &ExplicitSelf_)\n+                                      es: &SelfKind)\n                                       -> hir::ExplicitSelf_ {\n     match *es {\n-        SelfStatic => hir::SelfStatic,\n-        SelfValue(v) => hir::SelfValue(v.name),\n-        SelfRegion(ref lifetime, m, ident) => {\n+        SelfKind::Static => hir::SelfStatic,\n+        SelfKind::Value(v) => hir::SelfValue(v.name),\n+        SelfKind::Region(ref lifetime, m, ident) => {\n             hir::SelfRegion(lower_opt_lifetime(lctx, lifetime),\n                             lower_mutability(lctx, m),\n                             ident.name)\n         }\n-        SelfExplicit(ref typ, ident) => {\n+        SelfKind::Explicit(ref typ, ident) => {\n             hir::SelfExplicit(lower_ty(lctx, typ), ident.name)\n         }\n     }\n }\n \n pub fn lower_mutability(_lctx: &LoweringContext, m: Mutability) -> hir::Mutability {\n     match m {\n-        MutMutable => hir::MutMutable,\n-        MutImmutable => hir::MutImmutable,\n+        Mutability::Mutable => hir::MutMutable,\n+        Mutability::Immutable => hir::MutImmutable,\n     }\n }\n \n@@ -450,9 +451,9 @@ pub fn lower_fn_decl(lctx: &LoweringContext, decl: &FnDecl) -> P<hir::FnDecl> {\n     P(hir::FnDecl {\n         inputs: decl.inputs.iter().map(|x| lower_arg(lctx, x)).collect(),\n         output: match decl.output {\n-            Return(ref ty) => hir::Return(lower_ty(lctx, ty)),\n-            DefaultReturn(span) => hir::DefaultReturn(span),\n-            NoReturn(span) => hir::NoReturn(span),\n+            FunctionRetTy::Ty(ref ty) => hir::Return(lower_ty(lctx, ty)),\n+            FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n+            FunctionRetTy::None(span) => hir::NoReturn(span),\n         },\n         variadic: decl.variadic,\n     })\n@@ -653,34 +654,34 @@ pub fn lower_block(lctx: &LoweringContext, b: &Block) -> P<hir::Block> {\n     })\n }\n \n-pub fn lower_item_underscore(lctx: &LoweringContext, i: &Item_) -> hir::Item_ {\n+pub fn lower_item_kind(lctx: &LoweringContext, i: &ItemKind) -> hir::Item_ {\n     match *i {\n-        ItemExternCrate(string) => hir::ItemExternCrate(string),\n-        ItemUse(ref view_path) => {\n+        ItemKind::ExternCrate(string) => hir::ItemExternCrate(string),\n+        ItemKind::Use(ref view_path) => {\n             hir::ItemUse(lower_view_path(lctx, view_path))\n         }\n-        ItemStatic(ref t, m, ref e) => {\n+        ItemKind::Static(ref t, m, ref e) => {\n             hir::ItemStatic(lower_ty(lctx, t),\n                             lower_mutability(lctx, m),\n                             lower_expr(lctx, e))\n         }\n-        ItemConst(ref t, ref e) => {\n+        ItemKind::Const(ref t, ref e) => {\n             hir::ItemConst(lower_ty(lctx, t), lower_expr(lctx, e))\n         }\n-        ItemFn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n+        ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n             hir::ItemFn(lower_fn_decl(lctx, decl),\n                         lower_unsafety(lctx, unsafety),\n                         lower_constness(lctx, constness),\n                         abi,\n                         lower_generics(lctx, generics),\n                         lower_block(lctx, body))\n         }\n-        ItemMod(ref m) => hir::ItemMod(lower_mod(lctx, m)),\n-        ItemForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(lctx, nm)),\n-        ItemTy(ref t, ref generics) => {\n+        ItemKind::Mod(ref m) => hir::ItemMod(lower_mod(lctx, m)),\n+        ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(lower_foreign_mod(lctx, nm)),\n+        ItemKind::Ty(ref t, ref generics) => {\n             hir::ItemTy(lower_ty(lctx, t), lower_generics(lctx, generics))\n         }\n-        ItemEnum(ref enum_definition, ref generics) => {\n+        ItemKind::Enum(ref enum_definition, ref generics) => {\n             hir::ItemEnum(hir::EnumDef {\n                               variants: enum_definition.variants\n                                                        .iter()\n@@ -689,15 +690,15 @@ pub fn lower_item_underscore(lctx: &LoweringContext, i: &Item_) -> hir::Item_ {\n                           },\n                           lower_generics(lctx, generics))\n         }\n-        ItemStruct(ref struct_def, ref generics) => {\n+        ItemKind::Struct(ref struct_def, ref generics) => {\n             let struct_def = lower_variant_data(lctx, struct_def);\n             hir::ItemStruct(struct_def, lower_generics(lctx, generics))\n         }\n-        ItemDefaultImpl(unsafety, ref trait_ref) => {\n+        ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n             hir::ItemDefaultImpl(lower_unsafety(lctx, unsafety),\n                                  lower_trait_ref(lctx, trait_ref))\n         }\n-        ItemImpl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n+        ItemKind::Impl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n             let new_impl_items = impl_items.iter()\n                                            .map(|item| lower_impl_item(lctx, item))\n                                            .collect();\n@@ -709,15 +710,15 @@ pub fn lower_item_underscore(lctx: &LoweringContext, i: &Item_) -> hir::Item_ {\n                           lower_ty(lctx, ty),\n                           new_impl_items)\n         }\n-        ItemTrait(unsafety, ref generics, ref bounds, ref items) => {\n+        ItemKind::Trait(unsafety, ref generics, ref bounds, ref items) => {\n             let bounds = lower_bounds(lctx, bounds);\n             let items = items.iter().map(|item| lower_trait_item(lctx, item)).collect();\n             hir::ItemTrait(lower_unsafety(lctx, unsafety),\n                            lower_generics(lctx, generics),\n                            bounds,\n                            items)\n         }\n-        ItemMac(_) => panic!(\"Shouldn't still be around\"),\n+        ItemKind::Mac(_) => panic!(\"Shouldn't still be around\"),\n     }\n }\n \n@@ -727,15 +728,15 @@ pub fn lower_trait_item(lctx: &LoweringContext, i: &TraitItem) -> hir::TraitItem\n         name: i.ident.name,\n         attrs: lower_attrs(lctx, &i.attrs),\n         node: match i.node {\n-            ConstTraitItem(ref ty, ref default) => {\n+            TraitItemKind::Const(ref ty, ref default) => {\n                 hir::ConstTraitItem(lower_ty(lctx, ty),\n                                     default.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n-            MethodTraitItem(ref sig, ref body) => {\n+            TraitItemKind::Method(ref sig, ref body) => {\n                 hir::MethodTraitItem(lower_method_sig(lctx, sig),\n                                      body.as_ref().map(|x| lower_block(lctx, x)))\n             }\n-            TypeTraitItem(ref bounds, ref default) => {\n+            TraitItemKind::Type(ref bounds, ref default) => {\n                 hir::TypeTraitItem(lower_bounds(lctx, bounds),\n                                    default.as_ref().map(|x| lower_ty(lctx, x)))\n             }\n@@ -819,7 +820,7 @@ pub fn lower_item_id(_lctx: &LoweringContext, i: &Item) -> hir::ItemId {\n }\n \n pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n-    let node = lower_item_underscore(lctx, &i.node);\n+    let node = lower_item_kind(lctx, &i.node);\n \n     hir::Item {\n         id: i.id,\n@@ -837,10 +838,10 @@ pub fn lower_foreign_item(lctx: &LoweringContext, i: &ForeignItem) -> hir::Forei\n         name: i.ident.name,\n         attrs: lower_attrs(lctx, &i.attrs),\n         node: match i.node {\n-            ForeignItemFn(ref fdec, ref generics) => {\n+            ForeignItemKind::Fn(ref fdec, ref generics) => {\n                 hir::ForeignItemFn(lower_fn_decl(lctx, fdec), lower_generics(lctx, generics))\n             }\n-            ForeignItemStatic(ref t, m) => {\n+            ForeignItemKind::Static(ref t, m) => {\n                 hir::ForeignItemStatic(lower_ty(lctx, t), m)\n             }\n         },\n@@ -876,33 +877,33 @@ pub fn lower_constness(_lctx: &LoweringContext, c: Constness) -> hir::Constness\n \n pub fn lower_unop(_lctx: &LoweringContext, u: UnOp) -> hir::UnOp {\n     match u {\n-        UnDeref => hir::UnDeref,\n-        UnNot => hir::UnNot,\n-        UnNeg => hir::UnNeg,\n+        UnOp::Deref => hir::UnDeref,\n+        UnOp::Not => hir::UnNot,\n+        UnOp::Neg => hir::UnNeg,\n     }\n }\n \n pub fn lower_binop(_lctx: &LoweringContext, b: BinOp) -> hir::BinOp {\n     Spanned {\n         node: match b.node {\n-            BiAdd => hir::BiAdd,\n-            BiSub => hir::BiSub,\n-            BiMul => hir::BiMul,\n-            BiDiv => hir::BiDiv,\n-            BiRem => hir::BiRem,\n-            BiAnd => hir::BiAnd,\n-            BiOr => hir::BiOr,\n-            BiBitXor => hir::BiBitXor,\n-            BiBitAnd => hir::BiBitAnd,\n-            BiBitOr => hir::BiBitOr,\n-            BiShl => hir::BiShl,\n-            BiShr => hir::BiShr,\n-            BiEq => hir::BiEq,\n-            BiLt => hir::BiLt,\n-            BiLe => hir::BiLe,\n-            BiNe => hir::BiNe,\n-            BiGe => hir::BiGe,\n-            BiGt => hir::BiGt,\n+            BinOpKind::Add => hir::BiAdd,\n+            BinOpKind::Sub => hir::BiSub,\n+            BinOpKind::Mul => hir::BiMul,\n+            BinOpKind::Div => hir::BiDiv,\n+            BinOpKind::Rem => hir::BiRem,\n+            BinOpKind::And => hir::BiAnd,\n+            BinOpKind::Or => hir::BiOr,\n+            BinOpKind::BitXor => hir::BiBitXor,\n+            BinOpKind::BitAnd => hir::BiBitAnd,\n+            BinOpKind::BitOr => hir::BiBitOr,\n+            BinOpKind::Shl => hir::BiShl,\n+            BinOpKind::Shr => hir::BiShr,\n+            BinOpKind::Eq => hir::BiEq,\n+            BinOpKind::Lt => hir::BiLt,\n+            BinOpKind::Le => hir::BiLe,\n+            BinOpKind::Ne => hir::BiNe,\n+            BinOpKind::Ge => hir::BiGe,\n+            BinOpKind::Gt => hir::BiGt,\n         },\n         span: b.span,\n     }\n@@ -986,12 +987,12 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n             // }\n             //\n             // But for now there are type-inference issues doing that.\n-            ExprBox(ref e) => {\n+            ExprKind::Box(ref e) => {\n                 hir::ExprBox(lower_expr(lctx, e))\n             }\n \n             // Desugar ExprBox: `in (PLACE) EXPR`\n-            ExprInPlace(ref placer, ref value_expr) => {\n+            ExprKind::InPlace(ref placer, ref value_expr) => {\n                 // to:\n                 //\n                 // let p = PLACE;\n@@ -1099,57 +1100,57 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 });\n             }\n \n-            ExprVec(ref exprs) => {\n+            ExprKind::Vec(ref exprs) => {\n                 hir::ExprVec(exprs.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n-            ExprRepeat(ref expr, ref count) => {\n+            ExprKind::Repeat(ref expr, ref count) => {\n                 let expr = lower_expr(lctx, expr);\n                 let count = lower_expr(lctx, count);\n                 hir::ExprRepeat(expr, count)\n             }\n-            ExprTup(ref elts) => {\n+            ExprKind::Tup(ref elts) => {\n                 hir::ExprTup(elts.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n-            ExprCall(ref f, ref args) => {\n+            ExprKind::Call(ref f, ref args) => {\n                 let f = lower_expr(lctx, f);\n                 hir::ExprCall(f, args.iter().map(|x| lower_expr(lctx, x)).collect())\n             }\n-            ExprMethodCall(i, ref tps, ref args) => {\n+            ExprKind::MethodCall(i, ref tps, ref args) => {\n                 let tps = tps.iter().map(|x| lower_ty(lctx, x)).collect();\n                 let args = args.iter().map(|x| lower_expr(lctx, x)).collect();\n                 hir::ExprMethodCall(respan(i.span, i.node.name), tps, args)\n             }\n-            ExprBinary(binop, ref lhs, ref rhs) => {\n+            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = lower_binop(lctx, binop);\n                 let lhs = lower_expr(lctx, lhs);\n                 let rhs = lower_expr(lctx, rhs);\n                 hir::ExprBinary(binop, lhs, rhs)\n             }\n-            ExprUnary(op, ref ohs) => {\n+            ExprKind::Unary(op, ref ohs) => {\n                 let op = lower_unop(lctx, op);\n                 let ohs = lower_expr(lctx, ohs);\n                 hir::ExprUnary(op, ohs)\n             }\n-            ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n-            ExprCast(ref expr, ref ty) => {\n+            ExprKind::Lit(ref l) => hir::ExprLit(P((**l).clone())),\n+            ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = lower_expr(lctx, expr);\n                 hir::ExprCast(expr, lower_ty(lctx, ty))\n             }\n-            ExprType(ref expr, ref ty) => {\n+            ExprKind::Type(ref expr, ref ty) => {\n                 let expr = lower_expr(lctx, expr);\n                 hir::ExprType(expr, lower_ty(lctx, ty))\n             }\n-            ExprAddrOf(m, ref ohs) => {\n+            ExprKind::AddrOf(m, ref ohs) => {\n                 let m = lower_mutability(lctx, m);\n                 let ohs = lower_expr(lctx, ohs);\n                 hir::ExprAddrOf(m, ohs)\n             }\n             // More complicated than you might expect because the else branch\n             // might be `if let`.\n-            ExprIf(ref cond, ref blk, ref else_opt) => {\n+            ExprKind::If(ref cond, ref blk, ref else_opt) => {\n                 let else_opt = else_opt.as_ref().map(|els| {\n                     match els.node {\n-                        ExprIfLet(..) => {\n+                        ExprKind::IfLet(..) => {\n                             cache_ids(lctx, e.id, |lctx| {\n                                 // wrap the if-let expr in a block\n                                 let span = els.span;\n@@ -1171,47 +1172,47 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                 hir::ExprIf(lower_expr(lctx, cond), lower_block(lctx, blk), else_opt)\n             }\n-            ExprWhile(ref cond, ref body, opt_ident) => {\n+            ExprKind::While(ref cond, ref body, opt_ident) => {\n                 hir::ExprWhile(lower_expr(lctx, cond), lower_block(lctx, body),\n                                opt_ident.map(|ident| lower_ident(lctx, ident)))\n             }\n-            ExprLoop(ref body, opt_ident) => {\n+            ExprKind::Loop(ref body, opt_ident) => {\n                 hir::ExprLoop(lower_block(lctx, body),\n                               opt_ident.map(|ident| lower_ident(lctx, ident)))\n             }\n-            ExprMatch(ref expr, ref arms) => {\n+            ExprKind::Match(ref expr, ref arms) => {\n                 hir::ExprMatch(lower_expr(lctx, expr),\n                                arms.iter().map(|x| lower_arm(lctx, x)).collect(),\n                                hir::MatchSource::Normal)\n             }\n-            ExprClosure(capture_clause, ref decl, ref body) => {\n+            ExprKind::Closure(capture_clause, ref decl, ref body) => {\n                 hir::ExprClosure(lower_capture_clause(lctx, capture_clause),\n                                  lower_fn_decl(lctx, decl),\n                                  lower_block(lctx, body))\n             }\n-            ExprBlock(ref blk) => hir::ExprBlock(lower_block(lctx, blk)),\n-            ExprAssign(ref el, ref er) => {\n+            ExprKind::Block(ref blk) => hir::ExprBlock(lower_block(lctx, blk)),\n+            ExprKind::Assign(ref el, ref er) => {\n                 hir::ExprAssign(lower_expr(lctx, el), lower_expr(lctx, er))\n             }\n-            ExprAssignOp(op, ref el, ref er) => {\n+            ExprKind::AssignOp(op, ref el, ref er) => {\n                 hir::ExprAssignOp(lower_binop(lctx, op),\n                                   lower_expr(lctx, el),\n                                   lower_expr(lctx, er))\n             }\n-            ExprField(ref el, ident) => {\n+            ExprKind::Field(ref el, ident) => {\n                 hir::ExprField(lower_expr(lctx, el), respan(ident.span, ident.node.name))\n             }\n-            ExprTupField(ref el, ident) => {\n+            ExprKind::TupField(ref el, ident) => {\n                 hir::ExprTupField(lower_expr(lctx, el), ident)\n             }\n-            ExprIndex(ref el, ref er) => {\n+            ExprKind::Index(ref el, ref er) => {\n                 hir::ExprIndex(lower_expr(lctx, el), lower_expr(lctx, er))\n             }\n-            ExprRange(ref e1, ref e2) => {\n+            ExprKind::Range(ref e1, ref e2) => {\n                 hir::ExprRange(e1.as_ref().map(|x| lower_expr(lctx, x)),\n                                e2.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n-            ExprPath(ref qself, ref path) => {\n+            ExprKind::Path(ref qself, ref path) => {\n                 let hir_qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                     hir::QSelf {\n                         ty: lower_ty(lctx, ty),\n@@ -1220,14 +1221,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 });\n                 hir::ExprPath(hir_qself, lower_path_full(lctx, path, qself.is_none()))\n             }\n-            ExprBreak(opt_ident) => hir::ExprBreak(opt_ident.map(|sp_ident| {\n+            ExprKind::Break(opt_ident) => hir::ExprBreak(opt_ident.map(|sp_ident| {\n                 respan(sp_ident.span, lower_ident(lctx, sp_ident.node))\n             })),\n-            ExprAgain(opt_ident) => hir::ExprAgain(opt_ident.map(|sp_ident| {\n+            ExprKind::Again(opt_ident) => hir::ExprAgain(opt_ident.map(|sp_ident| {\n                 respan(sp_ident.span, lower_ident(lctx, sp_ident.node))\n             })),\n-            ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(lctx, x))),\n-            ExprInlineAsm(InlineAsm {\n+            ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(lctx, x))),\n+            ExprKind::InlineAsm(InlineAsm {\n                     ref inputs,\n                     ref outputs,\n                     ref asm,\n@@ -1259,12 +1260,12 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 dialect: dialect,\n                 expn_id: expn_id,\n             }),\n-            ExprStruct(ref path, ref fields, ref maybe_expr) => {\n+            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n                 hir::ExprStruct(lower_path(lctx, path),\n                                 fields.iter().map(|x| lower_field(lctx, x)).collect(),\n                                 maybe_expr.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n-            ExprParen(ref ex) => {\n+            ExprKind::Paren(ref ex) => {\n                 // merge attributes into the inner expression.\n                 return lower_expr(lctx, ex).map(|mut ex| {\n                     ex.attrs.update(|attrs| {\n@@ -1276,7 +1277,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n             // Desugar ExprIfLet\n             // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n-            ExprIfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n+            ExprKind::IfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n                 // to:\n                 //\n                 //   match <sub_expr> {\n@@ -1364,7 +1365,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n             // Desugar ExprWhileLet\n             // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-            ExprWhileLet(ref pat, ref sub_expr, ref body, opt_ident) => {\n+            ExprKind::WhileLet(ref pat, ref sub_expr, ref body, opt_ident) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -1410,7 +1411,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n             // Desugar ExprForLoop\n             // From: `[opt_ident]: for <pat> in <head> <body>`\n-            ExprForLoop(ref pat, ref head, ref body, opt_ident) => {\n+            ExprKind::ForLoop(ref pat, ref head, ref body, opt_ident) => {\n                 // to:\n                 //\n                 //   {\n@@ -1524,7 +1525,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 });\n             }\n \n-            ExprMac(_) => panic!(\"Shouldn't exist here\"),\n+            ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         },\n         span: e.span,\n         attrs: e.attrs.clone(),\n@@ -1533,46 +1534,46 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n pub fn lower_stmt(lctx: &LoweringContext, s: &Stmt) -> hir::Stmt {\n     match s.node {\n-        StmtDecl(ref d, id) => {\n+        StmtKind::Decl(ref d, id) => {\n             Spanned {\n                 node: hir::StmtDecl(lower_decl(lctx, d), id),\n                 span: s.span,\n             }\n         }\n-        StmtExpr(ref e, id) => {\n+        StmtKind::Expr(ref e, id) => {\n             Spanned {\n                 node: hir::StmtExpr(lower_expr(lctx, e), id),\n                 span: s.span,\n             }\n         }\n-        StmtSemi(ref e, id) => {\n+        StmtKind::Semi(ref e, id) => {\n             Spanned {\n                 node: hir::StmtSemi(lower_expr(lctx, e), id),\n                 span: s.span,\n             }\n         }\n-        StmtMac(..) => panic!(\"Shouldn't exist here\"),\n+        StmtKind::Mac(..) => panic!(\"Shouldn't exist here\"),\n     }\n }\n \n-pub fn lower_capture_clause(_lctx: &LoweringContext, c: CaptureClause) -> hir::CaptureClause {\n+pub fn lower_capture_clause(_lctx: &LoweringContext, c: CaptureBy) -> hir::CaptureClause {\n     match c {\n-        CaptureByValue => hir::CaptureByValue,\n-        CaptureByRef => hir::CaptureByRef,\n+        CaptureBy::Value => hir::CaptureByValue,\n+        CaptureBy::Ref => hir::CaptureByRef,\n     }\n }\n \n pub fn lower_visibility(_lctx: &LoweringContext, v: Visibility) -> hir::Visibility {\n     match v {\n-        Public => hir::Public,\n-        Inherited => hir::Inherited,\n+        Visibility::Public => hir::Public,\n+        Visibility::Inherited => hir::Inherited,\n     }\n }\n \n pub fn lower_block_check_mode(lctx: &LoweringContext, b: &BlockCheckMode) -> hir::BlockCheckMode {\n     match *b {\n-        DefaultBlock => hir::DefaultBlock,\n-        UnsafeBlock(u) => hir::UnsafeBlock(lower_unsafe_source(lctx, u)),\n+        BlockCheckMode::Default => hir::DefaultBlock,\n+        BlockCheckMode::Unsafe(u) => hir::UnsafeBlock(lower_unsafe_source(lctx, u)),\n     }\n }\n "}, {"sha": "cc43e3ae56eaf9871cc37add3d37a100de920e45", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -10,7 +10,7 @@\n \n pub use self::AnnNode::*;\n \n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{self, CodeMap, BytePos, Spanned};\n use syntax::errors;\n@@ -290,7 +290,7 @@ pub fn fun_to_string(decl: &hir::FnDecl,\n         try!(s.print_fn(decl,\n                         unsafety,\n                         constness,\n-                        abi::Rust,\n+                        Abi::Rust,\n                         Some(name),\n                         generics,\n                         opt_explicit_self,\n@@ -569,7 +569,7 @@ impl<'a> State<'a> {\n                 try!(self.print_fn(decl,\n                                    hir::Unsafety::Normal,\n                                    hir::Constness::NotConst,\n-                                   abi::Rust,\n+                                   Abi::Rust,\n                                    Some(item.name),\n                                    generics,\n                                    None,\n@@ -652,7 +652,7 @@ impl<'a> State<'a> {\n                 if let Some(p) = *optional_path {\n                     let val = p.as_str();\n                     if val.contains(\"-\") {\n-                        try!(self.print_string(&val, ast::CookedStr));\n+                        try!(self.print_string(&val, ast::StrStyle::Cooked));\n                     } else {\n                         try!(self.print_name(p));\n                     }\n@@ -1510,9 +1510,9 @@ impl<'a> State<'a> {\n                 try!(self.commasep(Inconsistent, &a.outputs, |s, out| {\n                     match out.constraint.slice_shift_char() {\n                         Some(('=', operand)) if out.is_rw => {\n-                            try!(s.print_string(&format!(\"+{}\", operand), ast::CookedStr))\n+                            try!(s.print_string(&format!(\"+{}\", operand), ast::StrStyle::Cooked))\n                         }\n-                        _ => try!(s.print_string(&out.constraint, ast::CookedStr)),\n+                        _ => try!(s.print_string(&out.constraint, ast::StrStyle::Cooked)),\n                     }\n                     try!(s.popen());\n                     try!(s.print_expr(&*out.expr));\n@@ -1523,7 +1523,7 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\":\"));\n \n                 try!(self.commasep(Inconsistent, &a.inputs, |s, &(ref co, ref o)| {\n-                    try!(s.print_string(&co, ast::CookedStr));\n+                    try!(s.print_string(&co, ast::StrStyle::Cooked));\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n                     try!(s.pclose());\n@@ -1533,7 +1533,7 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\":\"));\n \n                 try!(self.commasep(Inconsistent, &a.clobbers, |s, co| {\n-                    try!(s.print_string(&co, ast::CookedStr));\n+                    try!(s.print_string(&co, ast::StrStyle::Cooked));\n                     Ok(())\n                 }));\n \n@@ -1552,7 +1552,7 @@ impl<'a> State<'a> {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\":\"));\n                     try!(self.commasep(Inconsistent, &*options, |s, &co| {\n-                        try!(s.print_string(co, ast::CookedStr));\n+                        try!(s.print_string(co, ast::StrStyle::Cooked));\n                         Ok(())\n                     }));\n                 }\n@@ -1916,7 +1916,7 @@ impl<'a> State<'a> {\n                     decl: &hir::FnDecl,\n                     unsafety: hir::Unsafety,\n                     constness: hir::Constness,\n-                    abi: abi::Abi,\n+                    abi: Abi,\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n                     opt_explicit_self: Option<&hir::ExplicitSelf_>,\n@@ -2250,7 +2250,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ty_fn(&mut self,\n-                       abi: abi::Abi,\n+                       abi: Abi,\n                        unsafety: hir::Unsafety,\n                        decl: &hir::FnDecl,\n                        name: Option<ast::Name>,\n@@ -2331,10 +2331,10 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n-                                                  opt_abi: Option<abi::Abi>)\n+                                                  opt_abi: Option<Abi>)\n                                                   -> io::Result<()> {\n         match opt_abi {\n-            Some(abi::Rust) => Ok(()),\n+            Some(Abi::Rust) => Ok(()),\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n                 self.word_nbsp(&abi.to_string())\n@@ -2343,7 +2343,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_extern_opt_abi(&mut self, opt_abi: Option<abi::Abi>) -> io::Result<()> {\n+    pub fn print_extern_opt_abi(&mut self, opt_abi: Option<Abi>) -> io::Result<()> {\n         match opt_abi {\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n@@ -2356,7 +2356,7 @@ impl<'a> State<'a> {\n     pub fn print_fn_header_info(&mut self,\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n-                                abi: abi::Abi,\n+                                abi: Abi,\n                                 vis: hir::Visibility)\n                                 -> io::Result<()> {\n         try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n@@ -2367,7 +2367,7 @@ impl<'a> State<'a> {\n             hir::Constness::Const => try!(self.word_nbsp(\"const\")),\n         }\n \n-        if abi != abi::Rust {\n+        if abi != Abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n             try!(self.word_nbsp(&abi.to_string()));\n         }"}, {"sha": "ed16a11f5501a6a790abac5c86576f085ae919ea", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -73,7 +73,7 @@ impl LateLintPass for WhileTrue {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprWhile(ref cond, _, _) = e.node {\n             if let hir::ExprLit(ref lit) = cond.node {\n-                if let ast::LitBool(true) = lit.node {\n+                if let ast::LitKind::Bool(true) = lit.node {\n                     cx.span_lint(WHILE_TRUE, e.span,\n                                  \"denote infinite loops with loop { ... }\");\n                 }\n@@ -308,7 +308,7 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| {\n             match a.node.value.node {\n-                ast::MetaNameValue(ref name, _) if *name == \"doc\" => true,\n+                ast::MetaItemKind::NameValue(ref name, _) if *name == \"doc\" => true,\n                 _ => false\n             }\n         });\n@@ -1039,7 +1039,7 @@ impl LintPass for MutableTransmutes {\n \n impl LateLintPass for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n-        use syntax::abi::RustIntrinsic;\n+        use syntax::abi::Abi::RustIntrinsic;\n \n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior,\\\n                    consider instead using an UnsafeCell\";"}, {"sha": "9fe1aa15f4a0f3eb78bb620b5e8be07549a72b81", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -23,7 +23,8 @@ use lint::{LintPass, LateLintPass};\n use std::cmp;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n-use syntax::{abi, ast};\n+use syntax::ast;\n+use syntax::abi::Abi;\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n \n@@ -102,10 +103,10 @@ impl LateLintPass for TypeLimits {\n             hir::ExprUnary(hir::UnNeg, ref expr) => {\n                 if let hir::ExprLit(ref lit) = expr.node {\n                     match lit.node {\n-                        ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n+                        ast::LitKind::Int(_, ast::LitIntType::Unsigned(_)) => {\n                             forbid_unsigned_negation(cx, e.span);\n                         },\n-                        ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n+                        ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n                             if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n                                 forbid_unsigned_negation(cx, e.span);\n                             }\n@@ -138,7 +139,7 @@ impl LateLintPass for TypeLimits {\n \n                     if let Some(bits) = opt_ty_bits {\n                         let exceeding = if let hir::ExprLit(ref lit) = r.node {\n-                            if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n+                            if let ast::LitKind::Int(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n                             match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked, None) {\n@@ -158,9 +159,9 @@ impl LateLintPass for TypeLimits {\n                 match cx.tcx.node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                                let int_type = if let ast::TyIs = t {\n+                            ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n+                            ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n+                                let int_type = if let ast::IntTy::Is = t {\n                                     cx.sess().target.int_type\n                                 } else {\n                                     t\n@@ -181,15 +182,16 @@ impl LateLintPass for TypeLimits {\n                         };\n                     },\n                     ty::TyUint(t) => {\n-                        let uint_type = if let ast::TyUs = t {\n+                        let uint_type = if let ast::UintTy::Us = t {\n                             cx.sess().target.uint_type\n                         } else {\n                             t\n                         };\n                         let (min, max) = uint_ty_range(uint_type);\n                         let lit_val: u64 = match lit.node {\n-                            ast::LitByte(_v) => return,  // _v is u8, within range by definition\n-                            ast::LitInt(v, _) => v,\n+                            // _v is u8, within range by definition\n+                            ast::LitKind::Byte(_v) => return,\n+                            ast::LitKind::Int(v, _) => v,\n                             _ => panic!()\n                         };\n                         if lit_val < min || lit_val > max {\n@@ -200,8 +202,8 @@ impl LateLintPass for TypeLimits {\n                     ty::TyFloat(t) => {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n-                            ast::LitFloat(ref v, _) |\n-                            ast::LitFloatUnsuffixed(ref v) => {\n+                            ast::LitKind::Float(ref v, _) |\n+                            ast::LitKind::FloatUnsuffixed(ref v) => {\n                                 match v.parse() {\n                                     Ok(f) => f,\n                                     Err(_) => return\n@@ -246,48 +248,48 @@ impl LateLintPass for TypeLimits {\n         // warnings are consistent between 32- and 64-bit platforms\n         fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n             match int_ty {\n-                ast::TyIs => (i64::MIN,        i64::MAX),\n-                ast::TyI8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n-                ast::TyI16 =>   (i16::MIN as i64, i16::MAX as i64),\n-                ast::TyI32 =>   (i32::MIN as i64, i32::MAX as i64),\n-                ast::TyI64 =>   (i64::MIN,        i64::MAX)\n+                ast::IntTy::Is => (i64::MIN,        i64::MAX),\n+                ast::IntTy::I8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n+                ast::IntTy::I16 =>   (i16::MIN as i64, i16::MAX as i64),\n+                ast::IntTy::I32 =>   (i32::MIN as i64, i32::MAX as i64),\n+                ast::IntTy::I64 =>   (i64::MIN,        i64::MAX)\n             }\n         }\n \n         fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n             match uint_ty {\n-                ast::TyUs => (u64::MIN,         u64::MAX),\n-                ast::TyU8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n-                ast::TyU16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n-                ast::TyU32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n-                ast::TyU64 =>   (u64::MIN,         u64::MAX)\n+                ast::UintTy::Us => (u64::MIN,         u64::MAX),\n+                ast::UintTy::U8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n+                ast::UintTy::U16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n+                ast::UintTy::U32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n+                ast::UintTy::U64 =>   (u64::MIN,         u64::MAX)\n             }\n         }\n \n         fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n             match float_ty {\n-                ast::TyF32 => (f32::MIN as f64, f32::MAX as f64),\n-                ast::TyF64 => (f64::MIN,        f64::MAX)\n+                ast::FloatTy::F32 => (f32::MIN as f64, f32::MAX as f64),\n+                ast::FloatTy::F64 => (f64::MIN,        f64::MAX)\n             }\n         }\n \n         fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                ast::TyIs => int_ty_bits(target_int_ty, target_int_ty),\n-                ast::TyI8 => 8,\n-                ast::TyI16 => 16 as u64,\n-                ast::TyI32 => 32,\n-                ast::TyI64 => 64,\n+                ast::IntTy::Is => int_ty_bits(target_int_ty, target_int_ty),\n+                ast::IntTy::I8 => 8,\n+                ast::IntTy::I16 => 16 as u64,\n+                ast::IntTy::I32 => 32,\n+                ast::IntTy::I64 => 64,\n             }\n         }\n \n         fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                ast::TyUs => uint_ty_bits(target_uint_ty, target_uint_ty),\n-                ast::TyU8 => 8,\n-                ast::TyU16 => 16,\n-                ast::TyU32 => 32,\n-                ast::TyU64 => 64,\n+                ast::UintTy::Us => uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::UintTy::U8 => 8,\n+                ast::UintTy::U16 => 16,\n+                ast::UintTy::U32 => 32,\n+                ast::UintTy::U64 => 64,\n             }\n         }\n \n@@ -310,10 +312,8 @@ impl LateLintPass for TypeLimits {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n                         hir::ExprLit(ref li) => match li.node {\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => v as i64,\n-                            ast::LitInt(v, ast::SignedIntLit(_, ast::Minus)) |\n-                            ast::LitInt(v, ast::UnsuffixedIntLit(ast::Minus)) => -(v as i64),\n+                            ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n+                            ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i64,\n                             _ => return true\n                         },\n                         _ => panic!()\n@@ -324,7 +324,7 @@ impl LateLintPass for TypeLimits {\n                     let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n                     let lit_val: u64 = match lit.node {\n                         hir::ExprLit(ref li) => match li.node {\n-                            ast::LitInt(v, _) => v,\n+                            ast::LitKind::Int(v, _) => v,\n                             _ => return true\n                         },\n                         _ => panic!()\n@@ -558,10 +558,10 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::TyBareFn(None, bare_fn) => {\n                 match bare_fn.abi {\n-                    abi::Rust |\n-                    abi::RustIntrinsic |\n-                    abi::PlatformIntrinsic |\n-                    abi::RustCall => {\n+                    Abi::Rust |\n+                    Abi::RustIntrinsic |\n+                    Abi::PlatformIntrinsic |\n+                    Abi::RustCall => {\n                         return FfiUnsafe(\n                             \"found function pointer with Rust calling \\\n                              convention in foreign module; consider using an \\\n@@ -677,7 +677,7 @@ impl LateLintPass for ImproperCTypes {\n         }\n \n         if let hir::ItemForeignMod(ref nmod) = it.node {\n-            if nmod.abi != abi::RustIntrinsic && nmod.abi != abi::PlatformIntrinsic {\n+            if nmod.abi != Abi::RustIntrinsic && nmod.abi != Abi::PlatformIntrinsic {\n                 for ni in &nmod.items {\n                     match ni.node {\n                         hir::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),"}, {"sha": "f18b68a5b73d82c20c76dd2b924c63bf2b0a1704", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -293,7 +293,7 @@ pub struct UnusedParens;\n impl UnusedParens {\n     fn check_unused_parens_core(&self, cx: &EarlyContext, value: &ast::Expr, msg: &str,\n                                 struct_lit_needs_parens: bool) {\n-        if let ast::ExprParen(ref inner) = value.node {\n+        if let ast::ExprKind::Paren(ref inner) = value.node {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n@@ -308,26 +308,26 @@ impl UnusedParens {\n         /// y: 1 }) == foo` does not.\n         fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n             match value.node {\n-                ast::ExprStruct(..) => true,\n+                ast::ExprKind::Struct(..) => true,\n \n-                ast::ExprAssign(ref lhs, ref rhs) |\n-                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n-                ast::ExprBinary(_, ref lhs, ref rhs) => {\n+                ast::ExprKind::Assign(ref lhs, ref rhs) |\n+                ast::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n+                ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n                     // X { y: 1 } + X { y: 2 }\n                     contains_exterior_struct_lit(&**lhs) ||\n                         contains_exterior_struct_lit(&**rhs)\n                 }\n-                ast::ExprUnary(_, ref x) |\n-                ast::ExprCast(ref x, _) |\n-                ast::ExprType(ref x, _) |\n-                ast::ExprField(ref x, _) |\n-                ast::ExprTupField(ref x, _) |\n-                ast::ExprIndex(ref x, _) => {\n+                ast::ExprKind::Unary(_, ref x) |\n+                ast::ExprKind::Cast(ref x, _) |\n+                ast::ExprKind::Type(ref x, _) |\n+                ast::ExprKind::Field(ref x, _) |\n+                ast::ExprKind::TupField(ref x, _) |\n+                ast::ExprKind::Index(ref x, _) => {\n                     // &X { y: 1 }, X { y: 1 }.y\n                     contains_exterior_struct_lit(&**x)\n                 }\n \n-                ast::ExprMethodCall(_, _, ref exprs) => {\n+                ast::ExprKind::MethodCall(_, _, ref exprs) => {\n                     // X { y: 1 }.bar(...)\n                     contains_exterior_struct_lit(&*exprs[0])\n                 }\n@@ -346,26 +346,27 @@ impl LintPass for UnusedParens {\n \n impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext, e: &ast::Expr) {\n+        use syntax::ast::ExprKind::*;\n         let (value, msg, struct_lit_needs_parens) = match e.node {\n-            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n-            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprIfLet(_, ref cond, _, _) => (cond, \"`if let` head expression\", true),\n-            ast::ExprWhileLet(_, ref cond, _, _) => (cond, \"`while let` head expression\", true),\n-            ast::ExprForLoop(_, ref cond, _, _) => (cond, \"`for` head expression\", true),\n-            ast::ExprMatch(ref head, _) => (head, \"`match` head expression\", true),\n-            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n-            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n-            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n-            ast::ExprInPlace(_, ref value) => (value, \"emplacement value\", false),\n+            If(ref cond, _, _) => (cond, \"`if` condition\", true),\n+            While(ref cond, _, _) => (cond, \"`while` condition\", true),\n+            IfLet(_, ref cond, _, _) => (cond, \"`if let` head expression\", true),\n+            WhileLet(_, ref cond, _, _) => (cond, \"`while let` head expression\", true),\n+            ForLoop(_, ref cond, _, _) => (cond, \"`for` head expression\", true),\n+            Match(ref head, _) => (head, \"`match` head expression\", true),\n+            Ret(Some(ref value)) => (value, \"`return` value\", false),\n+            Assign(_, ref value) => (value, \"assigned value\", false),\n+            AssignOp(_, _, ref value) => (value, \"assigned value\", false),\n+            InPlace(_, ref value) => (value, \"emplacement value\", false),\n             _ => return\n         };\n         self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n         let (value, msg) = match s.node {\n-            ast::StmtDecl(ref decl, _) => match decl.node {\n-                ast::DeclLocal(ref local) => match local.init {\n+            ast::StmtKind::Decl(ref decl, _) => match decl.node {\n+                ast::DeclKind::Local(ref local) => match local.init {\n                     Some(ref value) => (value, \"assigned value\"),\n                     None => return\n                 },"}, {"sha": "52456251f962b18404d441c596589d1d31ae0a04", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -31,7 +31,7 @@ use std::rc::Rc;\n use std::fs;\n \n use syntax::ast;\n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::codemap::{self, Span, mk_sp, Pos};\n use syntax::parse;\n use syntax::attr;\n@@ -157,7 +157,7 @@ impl<'a> CrateReader<'a> {\n \n     fn extract_crate_info(&self, i: &ast::Item) -> Option<CrateInfo> {\n         match i.node {\n-            ast::ItemExternCrate(ref path_opt) => {\n+            ast::ItemKind::ExternCrate(ref path_opt) => {\n                 debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n                        i.ident, path_opt);\n                 let name = match *path_opt {\n@@ -784,7 +784,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n     }\n \n     fn process_foreign_mod(&mut self, i: &hir::Item, fm: &hir::ForeignMod) {\n-        if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic || fm.abi == abi::PlatformIntrinsic {\n+        if fm.abi == Abi::Rust || fm.abi == Abi::RustIntrinsic || fm.abi == Abi::PlatformIntrinsic {\n             return;\n         }\n "}, {"sha": "5ba9e566e0090b8b95a21610e78cb7e2edf6c37b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -51,7 +51,7 @@ use syntax::attr;\n use syntax::parse::token::{IdentInterner, special_idents};\n use syntax::parse::token;\n use syntax::ast;\n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::codemap::{self, Span, BytePos, NO_EXPANSION};\n use syntax::print::pprust;\n use syntax::ptr::P;\n@@ -1170,7 +1170,7 @@ fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n         let v = token::intern_and_get_ident(vd.as_str_slice());\n-        // FIXME (#623): Should be able to decode MetaNameValue variants,\n+        // FIXME (#623): Should be able to decode MetaItemKind::NameValue variants,\n         // but currently the encoder just drops them\n         attr::mk_name_value_item_str(n, v)\n     })).chain(reader::tagged_docs(md, tag_meta_item_list).map(|meta_item_doc| {\n@@ -1701,7 +1701,7 @@ pub fn is_extern_fn(cdata: Cmd, id: DefIndex, tcx: &ty::ctxt) -> bool {\n     if let Fn = item_family(item_doc) {\n         let ty::TypeScheme { generics, ty } = get_type(cdata, id, tcx);\n         generics.types.is_empty() && match ty.sty {\n-            ty::TyBareFn(_, fn_ty) => fn_ty.abi != abi::Rust,\n+            ty::TyBareFn(_, fn_ty) => fn_ty.abi != Abi::Rust,\n             _ => false,\n         }\n     } else {"}, {"sha": "6375f82b2c5ed878c745c8c808f8c7657d01b064", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -40,7 +40,7 @@ use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n use std::u32;\n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n use syntax::codemap::BytePos;\n use syntax::attr;\n@@ -1381,7 +1381,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                           nitem: &hir::ForeignItem,\n                                           index: &mut CrateIndex<'tcx>,\n                                           path: PathElems,\n-                                          abi: abi::Abi) {\n+                                          abi: Abi) {\n     let def_id = ecx.tcx.map.local_def_id(nitem.id);\n \n     index.record(def_id, rbml_w);\n@@ -1393,7 +1393,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_family(rbml_w, FN_FAMILY);\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_name(rbml_w, nitem.name);\n-        if abi == abi::RustIntrinsic || abi == abi::PlatformIntrinsic {\n+        if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n         encode_attributes(rbml_w, &*nitem.attrs);\n@@ -1541,14 +1541,14 @@ fn encode_item_index(rbml_w: &mut Encoder, index: IndexData) {\n \n fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n     match mi.node {\n-      ast::MetaWord(ref name) => {\n+      ast::MetaItemKind::Word(ref name) => {\n         rbml_w.start_tag(tag_meta_item_word);\n         rbml_w.wr_tagged_str(tag_meta_item_name, name);\n         rbml_w.end_tag();\n       }\n-      ast::MetaNameValue(ref name, ref value) => {\n+      ast::MetaItemKind::NameValue(ref name, ref value) => {\n         match value.node {\n-          ast::LitStr(ref value, _) => {\n+          ast::LitKind::Str(ref value, _) => {\n             rbml_w.start_tag(tag_meta_item_name_value);\n             rbml_w.wr_tagged_str(tag_meta_item_name, name);\n             rbml_w.wr_tagged_str(tag_meta_item_value, value);\n@@ -1557,7 +1557,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n           _ => {/* FIXME (#623): encode other variants */ }\n         }\n       }\n-      ast::MetaList(ref name, ref items) => {\n+      ast::MetaItemKind::List(ref name, ref items) => {\n         rbml_w.start_tag(tag_meta_item_list);\n         rbml_w.wr_tagged_str(tag_meta_item_name, name);\n         for inner_item in items {"}, {"sha": "102bcc10face13c51e98f17c2438b52f6c4c021e", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -56,7 +56,7 @@ pub fn read_macro_defs(sess: &Session, cstore: &CStore, krate: &ast::Crate)\n     // crate root, because `$crate` won't work properly. Identify these by\n     // spans, because the crate map isn't set up yet.\n     for item in &krate.module.items {\n-        if let ast::ItemExternCrate(_) = item.node {\n+        if let ast::ItemKind::ExternCrate(_) = item.node {\n             loader.span_whitelist.insert(item.span);\n         }\n     }\n@@ -73,7 +73,7 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         // We're only interested in `extern crate`.\n         match item.node {\n-            ast::ItemExternCrate(_) => {}\n+            ast::ItemKind::ExternCrate(_) => {}\n             _ => {\n                 visit::walk_item(self, item);\n                 return;\n@@ -95,7 +95,7 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n                     }\n                     if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n                         for attr in names {\n-                            if let ast::MetaWord(ref name) = attr.node {\n+                            if let ast::MetaItemKind::Word(ref name) = attr.node {\n                                 sel.insert(name.clone(), attr.span);\n                             } else {\n                                 span_err!(self.sess, attr.span, E0466, \"bad macro import\");\n@@ -113,7 +113,7 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n                     };\n \n                     for attr in names {\n-                        if let ast::MetaWord(ref name) = attr.node {\n+                        if let ast::MetaItemKind::Word(ref name) = attr.node {\n                             reexport.insert(name.clone(), attr.span);\n                         } else {\n                             call_bad_macro_reexport(self.sess, attr.span);"}, {"sha": "b41ff5977fef154fc76d482b8ff7b4f0862301d8", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -76,26 +76,26 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n         ty::TyChar => { write!(w, \"c\"); }\n         ty::TyInt(t) => {\n             match t {\n-                ast::TyIs => write!(w, \"is\"),\n-                ast::TyI8 => write!(w, \"MB\"),\n-                ast::TyI16 => write!(w, \"MW\"),\n-                ast::TyI32 => write!(w, \"ML\"),\n-                ast::TyI64 => write!(w, \"MD\")\n+                ast::IntTy::Is => write!(w, \"is\"),\n+                ast::IntTy::I8 => write!(w, \"MB\"),\n+                ast::IntTy::I16 => write!(w, \"MW\"),\n+                ast::IntTy::I32 => write!(w, \"ML\"),\n+                ast::IntTy::I64 => write!(w, \"MD\")\n             };\n         }\n         ty::TyUint(t) => {\n             match t {\n-                ast::TyUs => write!(w, \"us\"),\n-                ast::TyU8 => write!(w, \"Mb\"),\n-                ast::TyU16 => write!(w, \"Mw\"),\n-                ast::TyU32 => write!(w, \"Ml\"),\n-                ast::TyU64 => write!(w, \"Md\")\n+                ast::UintTy::Us => write!(w, \"us\"),\n+                ast::UintTy::U8 => write!(w, \"Mb\"),\n+                ast::UintTy::U16 => write!(w, \"Mw\"),\n+                ast::UintTy::U32 => write!(w, \"Ml\"),\n+                ast::UintTy::U64 => write!(w, \"Md\")\n             };\n         }\n         ty::TyFloat(t) => {\n             match t {\n-                ast::TyF32 => write!(w, \"Mf\"),\n-                ast::TyF64 => write!(w, \"MF\"),\n+                ast::FloatTy::F32 => write!(w, \"Mf\"),\n+                ast::FloatTy::F64 => write!(w, \"MF\"),\n             };\n         }\n         ty::TyEnum(def, substs) => {"}, {"sha": "edbc6424ccd90dcc64e45ffb062550ef5f623739", "filename": "src/librustc_passes/const_fn.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_passes%2Fconst_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_passes%2Fconst_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconst_fn.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'v> Visitor<'v> for CheckBlock<'a> {\n         CheckConstFn{ sess: self.sess}.visit_block(block);\n     }\n     fn visit_expr(&mut self, e: &'v ast::Expr) {\n-        if let ast::ExprClosure(..) = e.node {\n+        if let ast::ExprKind::Closure(..) = e.node {\n             CheckConstFn{ sess: self.sess}.visit_expr(e);\n         } else {\n             visit::walk_expr(self, e);\n@@ -57,17 +57,17 @@ fn check_block(sess: &Session, b: &ast::Block, kind: &'static str) {\n     // Check all statements in the block\n     for stmt in &b.stmts {\n         let span = match stmt.node {\n-            ast::StmtDecl(ref decl, _) => {\n+            ast::StmtKind::Decl(ref decl, _) => {\n                 match decl.node {\n-                    ast::DeclLocal(_) => decl.span,\n+                    ast::DeclKind::Local(_) => decl.span,\n \n                     // Item statements are allowed\n-                    ast::DeclItem(_) => continue,\n+                    ast::DeclKind::Item(_) => continue,\n                 }\n             }\n-            ast::StmtExpr(ref expr, _) => expr.span,\n-            ast::StmtSemi(ref semi, _) => semi.span,\n-            ast::StmtMac(..) => unreachable!(),\n+            ast::StmtKind::Expr(ref expr, _) => expr.span,\n+            ast::StmtKind::Semi(ref semi, _) => semi.span,\n+            ast::StmtKind::Mac(..) => unreachable!(),\n         };\n         span_err!(sess, span, E0016,\n                   \"blocks in {}s are limited to items and tail expressions\", kind);\n@@ -78,10 +78,10 @@ impl<'a, 'v> Visitor<'v> for CheckConstFn<'a> {\n     fn visit_item(&mut self, i: &'v ast::Item) {\n         visit::walk_item(self, i);\n         match i.node {\n-            ast::ItemConst(_, ref e) => {\n+            ast::ItemKind::Const(_, ref e) => {\n                 CheckBlock{ sess: self.sess, kind: \"constant\"}.visit_expr(e)\n             },\n-            ast::ItemStatic(_, _, ref e) => {\n+            ast::ItemKind::Static(_, _, ref e) => {\n                 CheckBlock{ sess: self.sess, kind: \"static\"}.visit_expr(e)\n             },\n             _ => {},\n@@ -105,7 +105,7 @@ impl<'a, 'v> Visitor<'v> for CheckConstFn<'a> {\n         for arg in &fd.inputs {\n             match arg.pat.node {\n                 ast::PatWild => {}\n-                ast::PatIdent(ast::BindingMode::ByValue(ast::MutImmutable), _, None) => {}\n+                ast::PatIdent(ast::BindingMode::ByValue(ast::Mutability::Immutable), _, None) => {}\n                 _ => {\n                     span_err!(self.sess, arg.pat.span, E0022,\n                               \"arguments of constant functions can only \\"}, {"sha": "90f92c25b05ea54d80d768782537336e236fc08a", "filename": "src/librustc_passes/no_asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_passes%2Fno_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_passes%2Fno_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fno_asm.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -32,8 +32,8 @@ struct CheckNoAsm<'a> {\n impl<'a, 'v> Visitor<'v> for CheckNoAsm<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprInlineAsm(_) => span_err!(self.sess, e.span, E0472,\n-                                               \"asm! is unsupported on this target\"),\n+            ast::ExprKind::InlineAsm(_) => span_err!(self.sess, e.span, E0472,\n+                                                     \"asm! is unsupported on this target\"),\n             _ => {},\n         }\n         visit::walk_expr(self, e)"}, {"sha": "a3082cb698a8e25ded48297a424e7f4af9c19aee", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -60,9 +60,8 @@ use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n-use syntax::ast;\n-use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, TyIs, TyI8, TyI16, TyI32, TyI64};\n-use syntax::ast::{TyUs, TyU8, TyU16, TyU32, TyU64, TyF64, TyF32};\n+use syntax::ast::{self, FloatTy};\n+use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, Pos};\n use syntax::errors::DiagnosticBuilder;\n@@ -1074,19 +1073,19 @@ impl PrimitiveTypeTable {\n \n         table.intern(\"bool\", TyBool);\n         table.intern(\"char\", TyChar);\n-        table.intern(\"f32\", TyFloat(TyF32));\n-        table.intern(\"f64\", TyFloat(TyF64));\n-        table.intern(\"isize\", TyInt(TyIs));\n-        table.intern(\"i8\", TyInt(TyI8));\n-        table.intern(\"i16\", TyInt(TyI16));\n-        table.intern(\"i32\", TyInt(TyI32));\n-        table.intern(\"i64\", TyInt(TyI64));\n+        table.intern(\"f32\", TyFloat(FloatTy::F32));\n+        table.intern(\"f64\", TyFloat(FloatTy::F64));\n+        table.intern(\"isize\", TyInt(IntTy::Is));\n+        table.intern(\"i8\", TyInt(IntTy::I8));\n+        table.intern(\"i16\", TyInt(IntTy::I16));\n+        table.intern(\"i32\", TyInt(IntTy::I32));\n+        table.intern(\"i64\", TyInt(IntTy::I64));\n         table.intern(\"str\", TyStr);\n-        table.intern(\"usize\", TyUint(TyUs));\n-        table.intern(\"u8\", TyUint(TyU8));\n-        table.intern(\"u16\", TyUint(TyU16));\n-        table.intern(\"u32\", TyUint(TyU32));\n-        table.intern(\"u64\", TyUint(TyU64));\n+        table.intern(\"usize\", TyUint(UintTy::Us));\n+        table.intern(\"u8\", TyUint(UintTy::U8));\n+        table.intern(\"u16\", TyUint(UintTy::U16));\n+        table.intern(\"u32\", TyUint(UintTy::U32));\n+        table.intern(\"u64\", TyUint(UintTy::U64));\n \n         table\n     }"}, {"sha": "34d806ab0a8a30f9c621ac92246aef75e9f1cc10", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -350,7 +350,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             self.visit_ty(&arg.ty);\n         }\n \n-        if let ast::Return(ref ret_ty) = sig.decl.output {\n+        if let ast::FunctionRetTy::Ty(ref ret_ty) = sig.decl.output {\n             self.visit_ty(ret_ty);\n         }\n \n@@ -429,7 +429,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             self.visit_ty(&arg.ty);\n         }\n \n-        if let ast::Return(ref ret_ty) = decl.output {\n+        if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n             self.visit_ty(&ret_ty);\n         }\n \n@@ -807,7 +807,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         self.visit_pat(&p);\n \n         for &(id, ref p, immut, _) in &collector.collected_paths {\n-            let value = if immut == ast::MutImmutable {\n+            let value = if immut == ast::Mutability::Immutable {\n                 value.to_string()\n             } else {\n                 \"<mutable>\".to_string()\n@@ -864,9 +864,10 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span, item.id);\n         match item.node {\n-            ast::ItemUse(ref use_item) => {\n+            Use(ref use_item) => {\n                 match use_item.node {\n                     ast::ViewPathSimple(ident, ref path) => {\n                         let sub_span = self.span.span_for_last_ident(path.span);\n@@ -927,7 +928,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                     ast::ViewPathList(ref path, ref list) => {\n                         for plid in list {\n                             match plid.node {\n-                                ast::PathListIdent { id, .. } => {\n+                                ast::PathListItemKind::Ident { id, .. } => {\n                                     match self.lookup_type_ref(id) {\n                                         Some(def_id) => match self.lookup_def_kind(id, plid.span) {\n                                             Some(kind) => {\n@@ -942,15 +943,15 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                         None => (),\n                                     }\n                                 }\n-                                ast::PathListMod { .. } => (),\n+                                ast::PathListItemKind::Mod { .. } => (),\n                             }\n                         }\n \n                         self.write_sub_paths(path, true);\n                     }\n                 }\n             }\n-            ast::ItemExternCrate(ref s) => {\n+            ExternCrate(ref s) => {\n                 let location = match *s {\n                     Some(s) => s.to_string(),\n                     None => item.ident.to_string(),\n@@ -968,28 +969,28 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                           &location,\n                                           self.cur_scope);\n             }\n-            ast::ItemFn(ref decl, _, _, _, ref ty_params, ref body) =>\n+            Fn(ref decl, _, _, _, ref ty_params, ref body) =>\n                 self.process_fn(item, &**decl, ty_params, &**body),\n-            ast::ItemStatic(ref typ, _, ref expr) =>\n+            Static(ref typ, _, ref expr) =>\n                 self.process_static_or_const_item(item, typ, expr),\n-            ast::ItemConst(ref typ, ref expr) =>\n+            Const(ref typ, ref expr) =>\n                 self.process_static_or_const_item(item, &typ, &expr),\n-            ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, def, ty_params),\n-            ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n-            ast::ItemImpl(_, _,\n+            Struct(ref def, ref ty_params) => self.process_struct(item, def, ty_params),\n+            Enum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n+            Impl(_, _,\n                           ref ty_params,\n                           ref trait_ref,\n                           ref typ,\n                           ref impl_items) => {\n                 self.process_impl(item, ty_params, trait_ref, &typ, impl_items)\n             }\n-            ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>\n+            Trait(_, ref generics, ref trait_refs, ref methods) =>\n                 self.process_trait(item, generics, trait_refs, methods),\n-            ast::ItemMod(ref m) => {\n+            Mod(ref m) => {\n                 self.process_mod(item);\n                 self.nest(item.id, |v| visit::walk_mod(v, m));\n             }\n-            ast::ItemTy(ref ty, ref ty_params) => {\n+            Ty(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let value = ty_to_string(&**ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n@@ -998,7 +999,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.visit_ty(&**ty);\n                 self.process_generic_params(ty_params, item.span, &qualname, item.id);\n             }\n-            ast::ItemMac(_) => (),\n+            Mac(_) => (),\n             _ => visit::walk_item(self, item),\n         }\n     }\n@@ -1019,22 +1020,22 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n         self.process_macro_use(trait_item.span, trait_item.id);\n         match trait_item.node {\n-            ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n+            ast::TraitItemKind::Const(ref ty, Some(ref expr)) => {\n                 self.process_const(trait_item.id,\n                                    trait_item.ident.name,\n                                    trait_item.span,\n                                    &*ty,\n                                    &*expr);\n             }\n-            ast::MethodTraitItem(ref sig, ref body) => {\n+            ast::TraitItemKind::Method(ref sig, ref body) => {\n                 self.process_method(sig,\n                                     body.as_ref().map(|x| &**x),\n                                     trait_item.id,\n                                     trait_item.ident.name,\n                                     trait_item.span);\n             }\n-            ast::ConstTraitItem(_, None) |\n-            ast::TypeTraitItem(..) => {}\n+            ast::TraitItemKind::Const(_, None) |\n+            ast::TraitItemKind::Type(..) => {}\n         }\n     }\n \n@@ -1063,7 +1064,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_ty(&mut self, t: &ast::Ty) {\n         self.process_macro_use(t.span, t.id);\n         match t.node {\n-            ast::TyPath(_, ref path) => {\n+            ast::TyKind::Path(_, ref path) => {\n                 match self.lookup_type_ref(t.id) {\n                     Some(id) => {\n                         let sub_span = self.span.sub_span_for_type_name(t.span);\n@@ -1083,23 +1084,23 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_expr(&mut self, ex: &ast::Expr) {\n         self.process_macro_use(ex.span, ex.id);\n         match ex.node {\n-            ast::ExprCall(ref _f, ref _args) => {\n+            ast::ExprKind::Call(ref _f, ref _args) => {\n                 // Don't need to do anything for function calls,\n                 // because just walking the callee path does what we want.\n                 visit::walk_expr(self, ex);\n             }\n-            ast::ExprPath(_, ref path) => {\n+            ast::ExprKind::Path(_, ref path) => {\n                 self.process_path(ex.id, path, None);\n                 visit::walk_expr(self, ex);\n             }\n-            ast::ExprStruct(ref path, ref fields, ref base) => {\n+            ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = lower_expr(self.save_ctxt.lcx, ex);\n                 let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n                 let def = self.tcx.resolve_expr(&hir_expr);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n-            ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n-            ast::ExprField(ref sub_ex, _) => {\n+            ast::ExprKind::MethodCall(_, _, ref args) => self.process_method_call(ex, args),\n+            ast::ExprKind::Field(ref sub_ex, _) => {\n                 self.visit_expr(&sub_ex);\n \n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n@@ -1111,7 +1112,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                      field_data.scope);\n                 }\n             }\n-            ast::ExprTupField(ref sub_ex, idx) => {\n+            ast::ExprKind::TupField(ref sub_ex, idx) => {\n                 self.visit_expr(&**sub_ex);\n \n                 let hir_node = lower_expr(self.save_ctxt.lcx, sub_ex);\n@@ -1131,7 +1132,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                                      ty)),\n                 }\n             }\n-            ast::ExprClosure(_, ref decl, ref body) => {\n+            ast::ExprKind::Closure(_, ref decl, ref body) => {\n                 let mut id = String::from(\"$\");\n                 id.push_str(&ex.id.to_string());\n                 self.process_formals(&decl.inputs, &id);\n@@ -1141,21 +1142,21 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                     self.visit_ty(&*arg.ty);\n                 }\n \n-                if let ast::Return(ref ret_ty) = decl.output {\n+                if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n                     self.visit_ty(&**ret_ty);\n                 }\n \n                 // walk the body\n                 self.nest(ex.id, |v| v.visit_block(&**body));\n             }\n-            ast::ExprForLoop(ref pattern, ref subexpression, ref block, _) |\n-            ast::ExprWhileLet(ref pattern, ref subexpression, ref block, _) => {\n+            ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n+            ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {\n                 let value = self.span.snippet(mk_sp(ex.span.lo, subexpression.span.hi));\n                 self.process_var_decl(pattern, value);\n                 visit::walk_expr(self, subexpression);\n                 visit::walk_block(self, block);\n             }\n-            ast::ExprIfLet(ref pattern, ref subexpression, ref block, ref opt_else) => {\n+            ast::ExprKind::IfLet(ref pattern, ref subexpression, ref block, ref opt_else) => {\n                 let value = self.span.snippet(mk_sp(ex.span.lo, subexpression.span.hi));\n                 self.process_var_decl(pattern, value);\n                 visit::walk_expr(self, subexpression);\n@@ -1199,7 +1200,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             let def = def_map.get(&id).unwrap().full_def();\n             match def {\n                 Def::Local(_, id) => {\n-                    let value = if immut == ast::MutImmutable {\n+                    let value = if immut == ast::Mutability::Immutable {\n                         self.span.snippet(p.span).to_string()\n                     } else {\n                         \"<mutable>\".to_string()"}, {"sha": "ff19640d645073579dad0de711c8d6195dec61bd", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -229,7 +229,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_item_data(&self, item: &ast::Item) -> Option<Data> {\n         match item.node {\n-            ast::ItemFn(..) => {\n+            ast::ItemKind::Fn(..) => {\n                 let name = self.tcx.map.path_to_string(item.id);\n                 let qualname = format!(\"::{}\", name);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n@@ -243,13 +243,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     scope: self.enclosing_scope(item.id),\n                 }))\n             }\n-            ast::ItemStatic(ref typ, mt, ref expr) => {\n+            ast::ItemKind::Static(ref typ, mt, ref expr) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n                 // If the variable is immutable, save the initialising expression.\n                 let (value, keyword) = match mt {\n-                    ast::MutMutable => (String::from(\"<mutable>\"), keywords::Mut),\n-                    ast::MutImmutable => (self.span_utils.snippet(expr.span), keywords::Static),\n+                    ast::Mutability::Mutable => (String::from(\"<mutable>\"), keywords::Mut),\n+                    ast::Mutability::Immutable => {\n+                        (self.span_utils.snippet(expr.span), keywords::Static)\n+                    },\n                 };\n \n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keyword);\n@@ -264,7 +266,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(&typ),\n                 }))\n             }\n-            ast::ItemConst(ref typ, ref expr) => {\n+            ast::ItemKind::Const(ref typ, ref expr) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Const);\n                 filter!(self.span_utils, sub_span, item.span, None);\n@@ -278,7 +280,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(&typ),\n                 }))\n             }\n-            ast::ItemMod(ref m) => {\n+            ast::ItemKind::Mod(ref m) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n \n                 let cm = self.tcx.sess.codemap();\n@@ -295,7 +297,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     filename: filename,\n                 }))\n             }\n-            ast::ItemEnum(..) => {\n+            ast::ItemKind::Enum(..) => {\n                 let enum_name = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let val = self.span_utils.snippet(item.span);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Enum);\n@@ -308,15 +310,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     scope: self.enclosing_scope(item.id),\n                 }))\n             }\n-            ast::ItemImpl(_, _, _, ref trait_ref, ref typ, _) => {\n+            ast::ItemKind::Impl(_, _, _, ref trait_ref, ref typ, _) => {\n                 let mut type_data = None;\n                 let sub_span;\n \n                 let parent = self.enclosing_scope(item.id);\n \n                 match typ.node {\n                     // Common case impl for a struct or something basic.\n-                    ast::TyPath(None, ref path) => {\n+                    ast::TyKind::Path(None, ref path) => {\n                         sub_span = self.span_utils.sub_span_for_type_name(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n                         type_data = self.lookup_ref_id(typ.id).map(|id| {\n@@ -487,7 +489,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             return None;\n         }\n         match expr.node {\n-            ast::ExprField(ref sub_ex, ident) => {\n+            ast::ExprKind::Field(ref sub_ex, ident) => {\n                 let hir_node = lowering::lower_expr(self.lcx, sub_ex);\n                 match self.tcx.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyStruct(def, _) => {\n@@ -507,7 +509,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ExprStruct(ref path, _, _) => {\n+            ast::ExprKind::Struct(ref path, _, _) => {\n                 let hir_node = lowering::lower_expr(self.lcx, expr);\n                 match self.tcx.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyStruct(def, _) => {\n@@ -527,7 +529,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ExprMethodCall(..) => {\n+            ast::ExprKind::MethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let method_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n                 let (def_id, decl_id) = match self.tcx.impl_or_trait_item(method_id).container() {\n@@ -544,7 +546,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     decl_id: decl_id,\n                 }))\n             }\n-            ast::ExprPath(_, ref path) => {\n+            ast::ExprKind::Path(_, ref path) => {\n                 self.get_path_data(expr.id, path)\n             }\n             _ => {\n@@ -758,12 +760,12 @@ impl<'v> Visitor<'v> for PathCollector {\n         match p.node {\n             ast::PatStruct(ref path, _, _) => {\n                 self.collected_paths.push((p.id, path.clone(),\n-                                           ast::MutMutable, recorder::TypeRef));\n+                                           ast::Mutability::Mutable, recorder::TypeRef));\n             }\n             ast::PatEnum(ref path, _) |\n             ast::PatQPath(_, ref path) => {\n                 self.collected_paths.push((p.id, path.clone(),\n-                                           ast::MutMutable, recorder::VarRef));\n+                                           ast::Mutability::Mutable, recorder::VarRef));\n             }\n             ast::PatIdent(bm, ref path1, _) => {\n                 debug!(\"PathCollector, visit ident in pat {}: {:?} {:?}\",\n@@ -774,7 +776,7 @@ impl<'v> Visitor<'v> for PathCollector {\n                     // Even if the ref is mut, you can't change the ref, only\n                     // the data pointed at, so showing the initialising expression\n                     // is still worthwhile.\n-                    ast::BindingMode::ByRef(_) => ast::MutImmutable,\n+                    ast::BindingMode::ByRef(_) => ast::Mutability::Immutable,\n                     ast::BindingMode::ByValue(mt) => mt,\n                 };\n                 // collect path for either visit_local or visit_arm"}, {"sha": "28731aa950b52f3d6bcd1cf6bc4cc18ee1cab813", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -921,7 +921,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 compare_str(cx, lhs_data, lhs_len, rhs_data, rhs_len, rhs_t, debug_loc)\n             }\n             ty::TyArray(ty, _) | ty::TySlice(ty) => match ty.sty {\n-                ty::TyUint(ast::TyU8) => {\n+                ty::TyUint(ast::UintTy::U8) => {\n                     // NOTE: cast &[u8] and &[u8; N] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n                     let pat_len = val_ty(rhs).element_type().array_length();"}, {"sha": "ba227d6c38b357750cccaeaf08cfa70c1d21cf4a", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -403,11 +403,11 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let ity = if use_align {\n                 // Use the overall alignment\n                 match align {\n-                    1 => attr::UnsignedInt(ast::TyU8),\n-                    2 => attr::UnsignedInt(ast::TyU16),\n-                    4 => attr::UnsignedInt(ast::TyU32),\n+                    1 => attr::UnsignedInt(ast::UintTy::U8),\n+                    2 => attr::UnsignedInt(ast::UintTy::U16),\n+                    4 => attr::UnsignedInt(ast::UintTy::U32),\n                     8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n-                        attr::UnsignedInt(ast::TyU64),\n+                        attr::UnsignedInt(ast::UintTy::U64),\n                     _ => min_ity // use min_ity as a fallback\n                 }\n             } else {\n@@ -599,12 +599,12 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n     #[allow(non_upper_case_globals)]\n     const choose_shortest: &'static [IntType] = &[\n-        attr::UnsignedInt(ast::TyU8), attr::SignedInt(ast::TyI8),\n-        attr::UnsignedInt(ast::TyU16), attr::SignedInt(ast::TyI16),\n-        attr::UnsignedInt(ast::TyU32), attr::SignedInt(ast::TyI32)];\n+        attr::UnsignedInt(ast::UintTy::U8), attr::SignedInt(ast::IntTy::I8),\n+        attr::UnsignedInt(ast::UintTy::U16), attr::SignedInt(ast::IntTy::I16),\n+        attr::UnsignedInt(ast::UintTy::U32), attr::SignedInt(ast::IntTy::I32)];\n     #[allow(non_upper_case_globals)]\n     const at_least_32: &'static [IntType] = &[\n-        attr::UnsignedInt(ast::TyU32), attr::SignedInt(ast::TyI32)];\n+        attr::UnsignedInt(ast::UintTy::U32), attr::SignedInt(ast::IntTy::I32)];\n \n     let attempts;\n     match hint {\n@@ -638,7 +638,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n     }\n-    return attr::UnsignedInt(ast::TyU64);\n+    return attr::UnsignedInt(ast::UintTy::U64);\n }\n \n pub fn ll_inttype(cx: &CrateContext, ity: IntType) -> Type {"}, {"sha": "6171d05fef098bfca0dda9457d629c6708d4484e", "filename": "src/librustc_trans/trans/assert_dep_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                 let mut id = None;\n                 for meta_item in attr.meta_item_list().unwrap_or_default() {\n                     match meta_item.node {\n-                        ast::MetaWord(ref s) if id.is_none() => id = Some(s.clone()),\n+                        ast::MetaItemKind::Word(ref s) if id.is_none() => id = Some(s.clone()),\n                         _ => {\n                             self.tcx.sess.span_err(\n                                 meta_item.span,\n@@ -113,9 +113,9 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                 let mut id = None;\n                 for meta_item in attr.meta_item_list().unwrap_or_default() {\n                     match meta_item.node {\n-                        ast::MetaWord(ref s) if dep_node_interned.is_none() =>\n+                        ast::MetaItemKind::Word(ref s) if dep_node_interned.is_none() =>\n                             dep_node_interned = Some(s.clone()),\n-                        ast::MetaWord(ref s) if id.is_none() =>\n+                        ast::MetaItemKind::Word(ref s) if id.is_none() =>\n                             id = Some(s.clone()),\n                         _ => {\n                             self.tcx.sess.span_err("}, {"sha": "be0c62f511fb86451c97743c84745ee73ce3a3d8", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -14,7 +14,7 @@ use llvm::{self, ValueRef, AttrHelper};\n use middle::ty;\n use middle::infer;\n use session::config::NoDebugInfo;\n-use syntax::abi;\n+use syntax::abi::Abi;\n pub use syntax::attr::InlineAttr;\n use syntax::ast;\n use rustc_front::hir;\n@@ -136,7 +136,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n             function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n-            (&function_type.sig, abi::RustCall, Some(self_type))\n+            (&function_type.sig, Abi::RustCall, Some(self_type))\n         }\n         _ => ccx.sess().bug(\"expected closure or function.\")\n     };\n@@ -151,7 +151,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n     // unpack the input ty's\n     let input_tys = match fn_type.sty {\n         ty::TyClosure(..) => {\n-            assert!(abi == abi::RustCall);\n+            assert!(abi == Abi::RustCall);\n \n             match fn_sig.inputs[0].sty {\n                 ty::TyTuple(ref inputs) => {\n@@ -162,7 +162,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n-        ty::TyBareFn(..) if abi == abi::RustCall => {\n+        ty::TyBareFn(..) if abi == Abi::RustCall => {\n             let mut inputs = vec![fn_sig.inputs[0]];\n \n             match fn_sig.inputs[1].sty {"}, {"sha": "c2d962b032f01d0fe70d8a35878c7b84a14f862d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -100,7 +100,7 @@ use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n use std::str;\n use std::{i8, i16, i32, i64};\n-use syntax::abi::{Rust, RustCall, RustIntrinsic, PlatformIntrinsic, Abi};\n+use syntax::abi::Abi;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::InternedString;\n use syntax::attr::AttrMetaMethods;\n@@ -816,12 +816,12 @@ pub fn llty_and_min_for_signed_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         ty::TyInt(t) => {\n             let llty = Type::int_from_ty(cx.ccx(), t);\n             let min = match t {\n-                ast::TyIs if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n-                ast::TyIs => i64::MIN as u64,\n-                ast::TyI8 => i8::MIN as u64,\n-                ast::TyI16 => i16::MIN as u64,\n-                ast::TyI32 => i32::MIN as u64,\n-                ast::TyI64 => i64::MIN as u64,\n+                ast::IntTy::Is if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n+                ast::IntTy::Is => i64::MIN as u64,\n+                ast::IntTy::I8 => i8::MIN as u64,\n+                ast::IntTy::I16 => i16::MIN as u64,\n+                ast::IntTy::I32 => i32::MIN as u64,\n+                ast::IntTy::I64 => i64::MIN as u64,\n             };\n             (llty, min)\n         }\n@@ -911,10 +911,10 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match t.sty {\n         ty::TyBareFn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n-                Rust | RustCall => {\n+                Abi::Rust | Abi::RustCall => {\n                     get_extern_rust_fn(ccx, t, &name[..], did)\n                 }\n-                RustIntrinsic | PlatformIntrinsic => {\n+                Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n@@ -2031,7 +2031,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n \n     let has_tupled_arg = match closure_env {\n-        closure::ClosureEnv::NotClosure => abi == RustCall,\n+        closure::ClosureEnv::NotClosure => abi == Abi::RustCall,\n         _ => false,\n     };\n \n@@ -2503,7 +2503,7 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                 for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n                     let llfn = get_item_val(ccx, item.id);\n                     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                    if abi != Rust {\n+                    if abi != Abi::Rust {\n                         foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                                 &**decl,\n                                                                 &**body,\n@@ -2607,12 +2607,12 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                          node_type: Ty<'tcx>)\n                          -> ValueRef {\n     if let ty::TyBareFn(_, ref f) = node_type.sty {\n-        if f.abi != Rust && f.abi != RustCall {\n+        if f.abi != Abi::Rust && f.abi != Abi::RustCall {\n             ccx.sess().span_bug(sp,\n                                 &format!(\"only the `{}` or `{}` calling conventions are valid \\\n                                           for this function; `{}` was specified\",\n-                                         Rust.name(),\n-                                         RustCall.name(),\n+                                         Abi::Rust.name(),\n+                                         Abi::RustCall.name(),\n                                          f.abi.name()));\n         }\n     } else {\n@@ -2790,7 +2790,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                 hir::ItemFn(_, _, _, abi, _, _) => {\n                     let sym = sym();\n-                    let llfn = if abi == Rust {\n+                    let llfn = if abi == Abi::Rust {\n                         register_fn(ccx, i.span, sym, i.id, ty)\n                     } else {\n                         foreign::register_rust_fn_with_foreign_abi(ccx, i.span, sym, i.id)\n@@ -2913,7 +2913,7 @@ fn register_method(ccx: &CrateContext,\n     let sym = exported_name(ccx, id, mty, &attrs);\n \n     if let ty::TyBareFn(_, ref f) = mty.sty {\n-        let llfn = if f.abi == Rust || f.abi == RustCall {\n+        let llfn = if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n             register_fn(ccx, span, sym, id, mty)\n         } else {\n             foreign::register_rust_fn_with_foreign_abi(ccx, span, sym, id)"}, {"sha": "29821384ae936fc26da71112e218f882d3c12791", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -55,7 +55,7 @@ use middle::ty::{self, Ty, TypeFoldable};\n use middle::ty::MethodCall;\n use rustc_front::hir;\n \n-use syntax::abi as synabi;\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::errors;\n use syntax::ptr::P;\n@@ -157,8 +157,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n                 }\n             }\n             Def::Fn(did) if match expr_ty.sty {\n-                ty::TyBareFn(_, ref f) => f.abi == synabi::RustIntrinsic ||\n-                                          f.abi == synabi::PlatformIntrinsic,\n+                ty::TyBareFn(_, ref f) => f.abi == Abi::RustIntrinsic ||\n+                                          f.abi == Abi::PlatformIntrinsic,\n                 _ => false\n             } => {\n                 let substs = common::node_id_substs(bcx.ccx(),\n@@ -294,7 +294,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         match bare_fn_ty.sty {\n             ty::TyBareFn(opt_def_id,\n                            &ty::BareFnTy { unsafety: hir::Unsafety::Normal,\n-                                           abi: synabi::Rust,\n+                                           abi: Abi::Rust,\n                                            ref sig }) => {\n                 (opt_def_id, sig)\n             }\n@@ -310,7 +310,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let tuple_fn_ty = tcx.mk_fn(opt_def_id,\n         tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: hir::Unsafety::Normal,\n-            abi: synabi::RustCall,\n+            abi: Abi::RustCall,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: vec![bare_fn_ty_maybe_ref,\n                              tuple_input_ty],\n@@ -622,7 +622,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             (d.llfn, Some(d.llself))\n         }\n         Intrinsic(node, substs) => {\n-            assert!(abi == synabi::RustIntrinsic || abi == synabi::PlatformIntrinsic);\n+            assert!(abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic);\n             assert!(dest.is_some());\n \n             let call_info = match debug_loc {\n@@ -652,9 +652,9 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n     // Intrinsics should not become actual functions.\n     // We trans them in place in `trans_intrinsic_call`\n-    assert!(abi != synabi::RustIntrinsic && abi != synabi::PlatformIntrinsic);\n+    assert!(abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic);\n \n-    let is_rust_fn = abi == synabi::Rust || abi == synabi::RustCall;\n+    let is_rust_fn = abi == Abi::Rust || abi == Abi::RustCall;\n \n     // Generate a location to store the result. If the user does\n     // not care about the result, just make a stack slot.\n@@ -936,7 +936,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                   llargs: &mut Vec<ValueRef>,\n                                   arg_cleanup_scope: cleanup::ScopeId,\n                                   ignore_self: bool,\n-                                  abi: synabi::Abi)\n+                                  abi: Abi)\n                                   -> Block<'blk, 'tcx> {\n     debug!(\"trans_args(abi={})\", abi);\n \n@@ -953,7 +953,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     // to cast her view of the arguments to the caller's view.\n     match args {\n         ArgExprs(arg_exprs) => {\n-            if abi == synabi::RustCall {\n+            if abi == Abi::RustCall {\n                 // This is only used for direct calls to the `call`,\n                 // `call_mut` or `call_once` functions.\n                 return trans_args_under_call_abi(cx,"}, {"sha": "7c978cb275e259e6290731f8c6d5b9030c30fc7a", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -30,7 +30,7 @@ use trans::Disr;\n use middle::ty;\n use session::config::FullDebugInfo;\n \n-use syntax::abi::RustCall;\n+use syntax::abi::Abi::RustCall;\n use syntax::ast;\n use syntax::attr::{ThinAttributes, ThinAttributesExt};\n "}, {"sha": "8a4adf7414017e46981eaa15193dd907815698e8", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -1220,18 +1220,18 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyBool              => output.push_str(\"bool\"),\n         ty::TyChar              => output.push_str(\"char\"),\n         ty::TyStr               => output.push_str(\"str\"),\n-        ty::TyInt(ast::TyIs)    => output.push_str(\"isize\"),\n-        ty::TyInt(ast::TyI8)    => output.push_str(\"i8\"),\n-        ty::TyInt(ast::TyI16)   => output.push_str(\"i16\"),\n-        ty::TyInt(ast::TyI32)   => output.push_str(\"i32\"),\n-        ty::TyInt(ast::TyI64)   => output.push_str(\"i64\"),\n-        ty::TyUint(ast::TyUs)   => output.push_str(\"usize\"),\n-        ty::TyUint(ast::TyU8)   => output.push_str(\"u8\"),\n-        ty::TyUint(ast::TyU16)  => output.push_str(\"u16\"),\n-        ty::TyUint(ast::TyU32)  => output.push_str(\"u32\"),\n-        ty::TyUint(ast::TyU64)  => output.push_str(\"u64\"),\n-        ty::TyFloat(ast::TyF32) => output.push_str(\"f32\"),\n-        ty::TyFloat(ast::TyF64) => output.push_str(\"f64\"),\n+        ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n+        ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n+        ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n+        ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n+        ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+        ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n+        ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n+        ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n+        ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n+        ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+        ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n+        ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n         ty::TyStruct(adt_def, substs) |\n         ty::TyEnum(adt_def, substs) => {\n             push_item_name(cx, adt_def.did, output);\n@@ -1294,7 +1294,7 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 output.push_str(\"unsafe \");\n             }\n \n-            if abi != ::syntax::abi::Rust {\n+            if abi != ::syntax::abi::Abi::Rust {\n                 output.push_str(\"extern \\\"\");\n                 output.push_str(abi.name());\n                 output.push_str(\"\\\" \");"}, {"sha": "e1cff76cb0fb3ae170dfa896540a4141d471e5c9", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -52,7 +52,7 @@ use rustc_front::hir;\n use std::ffi::{CStr, CString};\n use std::borrow::Cow;\n use libc::c_uint;\n-use syntax::ast;\n+use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::parse::token;\n use syntax::ptr::P;\n@@ -64,15 +64,15 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n     let _icx = push_ctxt(\"trans_lit\");\n     debug!(\"const_lit: {:?}\", lit);\n     match lit.node {\n-        ast::LitByte(b) => C_integral(Type::uint_from_ty(cx, ast::TyU8), b as u64, false),\n-        ast::LitChar(i) => C_integral(Type::char(cx), i as u64, false),\n-        ast::LitInt(i, ast::SignedIntLit(t, _)) => {\n+        LitKind::Byte(b) => C_integral(Type::uint_from_ty(cx, ast::UintTy::U8), b as u64, false),\n+        LitKind::Char(i) => C_integral(Type::char(cx), i as u64, false),\n+        LitKind::Int(i, ast::LitIntType::Signed(t)) => {\n             C_integral(Type::int_from_ty(cx, t), i, true)\n         }\n-        ast::LitInt(u, ast::UnsignedIntLit(t)) => {\n+        LitKind::Int(u, ast::LitIntType::Unsigned(t)) => {\n             C_integral(Type::uint_from_ty(cx, t), u, false)\n         }\n-        ast::LitInt(i, ast::UnsuffixedIntLit(_)) => {\n+        LitKind::Int(i, ast::LitIntType::Unsuffixed) => {\n             let lit_int_ty = cx.tcx().node_id_to_type(e.id);\n             match lit_int_ty.sty {\n                 ty::TyInt(t) => {\n@@ -87,10 +87,10 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n                                 lit_int_ty))\n             }\n         }\n-        ast::LitFloat(ref fs, t) => {\n+        LitKind::Float(ref fs, t) => {\n             C_floating(&fs, Type::float_from_ty(cx, t))\n         }\n-        ast::LitFloatUnsuffixed(ref fs) => {\n+        LitKind::FloatUnsuffixed(ref fs) => {\n             let lit_float_ty = cx.tcx().node_id_to_type(e.id);\n             match lit_float_ty.sty {\n                 ty::TyFloat(t) => {\n@@ -102,9 +102,9 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n                 }\n             }\n         }\n-        ast::LitBool(b) => C_bool(cx, b),\n-        ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitByteStr(ref data) => {\n+        LitKind::Bool(b) => C_bool(cx, b),\n+        LitKind::Str(ref s, _) => C_str_slice(cx, (*s).clone()),\n+        LitKind::ByteStr(ref data) => {\n             addr_of(cx, C_bytes(cx, &data[..]), 1, \"byte_str\")\n         }\n     }"}, {"sha": "702721157be51c21b3d9e7e162936020b3699211", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -48,7 +48,8 @@ use std::ptr;\n use std::rc::Rc;\n \n use syntax::codemap::{Span, Pos};\n-use syntax::{abi, ast, codemap};\n+use syntax::{ast, codemap};\n+use syntax::abi::Abi;\n use syntax::attr::IntType;\n use syntax::parse::token::{self, special_idents};\n \n@@ -455,7 +456,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ty::FnDiverging => diverging_type_metadata(cx)\n         });\n \n-        let inputs = &if abi == abi::RustCall {\n+        let inputs = &if abi == Abi::RustCall {\n             type_of::untuple_arguments(cx, &sig.inputs)\n         } else {\n             sig.inputs"}, {"sha": "f243b1e3bfaa426293e942b18a917319dbaafff0", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -106,7 +106,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 output.push_str(\"unsafe \");\n             }\n \n-            if abi != ::syntax::abi::Rust {\n+            if abi != ::syntax::abi::Abi::Rust {\n                 output.push_str(\"extern \\\"\");\n                 output.push_str(abi.name());\n                 output.push_str(\"\\\" \");"}, {"sha": "e581e19d4330e256b44ff2d613e4b6bad90af1d2", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -48,7 +48,7 @@ pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n     attributes.iter().any(|attr| {\n         let meta_item: &ast::MetaItem = &*attr.node.value;\n         match meta_item.node {\n-            ast::MetaWord(ref value) => &value[..] == \"no_debug\",\n+            ast::MetaItemKind::Word(ref value) => &value[..] == \"no_debug\",\n             _ => false\n         }\n     })"}, {"sha": "75b60be02f77814913b8293ccdff093de88b7346", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -22,7 +22,7 @@\n use llvm::{self, ValueRef};\n use middle::ty;\n use middle::infer;\n-use syntax::abi;\n+use syntax::abi::Abi;\n use trans::attributes;\n use trans::base;\n use trans::context::CrateContext;\n@@ -116,7 +116,7 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n             let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);\n             debug!(\"declare_rust_fn function_type={:?} self_type={:?}\",\n                    function_type, self_type);\n-            (&function_type.sig, abi::RustCall, Some(llenvironment_type))\n+            (&function_type.sig, Abi::RustCall, Some(llenvironment_type))\n         }\n         _ => ccx.sess().bug(\"expected closure or fn\")\n     };"}, {"sha": "e411ed346917976c16857232487b0094002ca2d5", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -1153,7 +1153,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         hir::ExprLit(ref lit) => {\n             match lit.node {\n-                ast::LitStr(ref s, _) => {\n+                ast::LitKind::Str(ref s, _) => {\n                     tvec::trans_lit_str(bcx, expr, (*s).clone(), dest)\n                 }\n                 _ => {\n@@ -2370,14 +2370,14 @@ impl OverflowOpViaIntrinsic {\n         use middle::ty::{TyInt, TyUint};\n \n         let new_sty = match ty.sty {\n-            TyInt(TyIs) => match &tcx.sess.target.target.target_pointer_width[..] {\n-                \"32\" => TyInt(TyI32),\n-                \"64\" => TyInt(TyI64),\n+            TyInt(Is) => match &tcx.sess.target.target.target_pointer_width[..] {\n+                \"32\" => TyInt(I32),\n+                \"64\" => TyInt(I64),\n                 _ => panic!(\"unsupported target word size\")\n             },\n-            TyUint(TyUs) => match &tcx.sess.target.target.target_pointer_width[..] {\n-                \"32\" => TyUint(TyU32),\n-                \"64\" => TyUint(TyU64),\n+            TyUint(Us) => match &tcx.sess.target.target.target_pointer_width[..] {\n+                \"32\" => TyUint(U32),\n+                \"64\" => TyUint(U64),\n                 _ => panic!(\"unsupported target word size\")\n             },\n             ref t @ TyUint(_) | ref t @ TyInt(_) => t.clone(),\n@@ -2387,41 +2387,41 @@ impl OverflowOpViaIntrinsic {\n \n         match *self {\n             OverflowOpViaIntrinsic::Add => match new_sty {\n-                TyInt(TyI8) => \"llvm.sadd.with.overflow.i8\",\n-                TyInt(TyI16) => \"llvm.sadd.with.overflow.i16\",\n-                TyInt(TyI32) => \"llvm.sadd.with.overflow.i32\",\n-                TyInt(TyI64) => \"llvm.sadd.with.overflow.i64\",\n+                TyInt(I8) => \"llvm.sadd.with.overflow.i8\",\n+                TyInt(I16) => \"llvm.sadd.with.overflow.i16\",\n+                TyInt(I32) => \"llvm.sadd.with.overflow.i32\",\n+                TyInt(I64) => \"llvm.sadd.with.overflow.i64\",\n \n-                TyUint(TyU8) => \"llvm.uadd.with.overflow.i8\",\n-                TyUint(TyU16) => \"llvm.uadd.with.overflow.i16\",\n-                TyUint(TyU32) => \"llvm.uadd.with.overflow.i32\",\n-                TyUint(TyU64) => \"llvm.uadd.with.overflow.i64\",\n+                TyUint(U8) => \"llvm.uadd.with.overflow.i8\",\n+                TyUint(U16) => \"llvm.uadd.with.overflow.i16\",\n+                TyUint(U32) => \"llvm.uadd.with.overflow.i32\",\n+                TyUint(U64) => \"llvm.uadd.with.overflow.i64\",\n \n                 _ => unreachable!(),\n             },\n             OverflowOpViaIntrinsic::Sub => match new_sty {\n-                TyInt(TyI8) => \"llvm.ssub.with.overflow.i8\",\n-                TyInt(TyI16) => \"llvm.ssub.with.overflow.i16\",\n-                TyInt(TyI32) => \"llvm.ssub.with.overflow.i32\",\n-                TyInt(TyI64) => \"llvm.ssub.with.overflow.i64\",\n+                TyInt(I8) => \"llvm.ssub.with.overflow.i8\",\n+                TyInt(I16) => \"llvm.ssub.with.overflow.i16\",\n+                TyInt(I32) => \"llvm.ssub.with.overflow.i32\",\n+                TyInt(I64) => \"llvm.ssub.with.overflow.i64\",\n \n-                TyUint(TyU8) => \"llvm.usub.with.overflow.i8\",\n-                TyUint(TyU16) => \"llvm.usub.with.overflow.i16\",\n-                TyUint(TyU32) => \"llvm.usub.with.overflow.i32\",\n-                TyUint(TyU64) => \"llvm.usub.with.overflow.i64\",\n+                TyUint(U8) => \"llvm.usub.with.overflow.i8\",\n+                TyUint(U16) => \"llvm.usub.with.overflow.i16\",\n+                TyUint(U32) => \"llvm.usub.with.overflow.i32\",\n+                TyUint(U64) => \"llvm.usub.with.overflow.i64\",\n \n                 _ => unreachable!(),\n             },\n             OverflowOpViaIntrinsic::Mul => match new_sty {\n-                TyInt(TyI8) => \"llvm.smul.with.overflow.i8\",\n-                TyInt(TyI16) => \"llvm.smul.with.overflow.i16\",\n-                TyInt(TyI32) => \"llvm.smul.with.overflow.i32\",\n-                TyInt(TyI64) => \"llvm.smul.with.overflow.i64\",\n-\n-                TyUint(TyU8) => \"llvm.umul.with.overflow.i8\",\n-                TyUint(TyU16) => \"llvm.umul.with.overflow.i16\",\n-                TyUint(TyU32) => \"llvm.umul.with.overflow.i32\",\n-                TyUint(TyU64) => \"llvm.umul.with.overflow.i64\",\n+                TyInt(I8) => \"llvm.smul.with.overflow.i8\",\n+                TyInt(I16) => \"llvm.smul.with.overflow.i16\",\n+                TyInt(I32) => \"llvm.smul.with.overflow.i32\",\n+                TyInt(I64) => \"llvm.smul.with.overflow.i64\",\n+\n+                TyUint(U8) => \"llvm.umul.with.overflow.i8\",\n+                TyUint(U16) => \"llvm.umul.with.overflow.i16\",\n+                TyUint(U32) => \"llvm.umul.with.overflow.i32\",\n+                TyUint(U64) => \"llvm.umul.with.overflow.i64\",\n \n                 _ => unreachable!(),\n             },"}, {"sha": "5a909888bd86d874a3bbcbe2d4d34607ac097cf3", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -34,9 +34,7 @@ use middle::subst::Substs;\n use std::cmp;\n use std::iter::once;\n use libc::c_uint;\n-use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n-use syntax::abi::{PlatformIntrinsic, RustIntrinsic, Rust, RustCall, Stdcall};\n-use syntax::abi::{Fastcall, Vectorcall, System};\n+use syntax::abi::Abi;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n@@ -80,6 +78,7 @@ struct LlvmSignature {\n \n pub fn llvm_calling_convention(ccx: &CrateContext,\n                                abi: Abi) -> CallConv {\n+    use syntax::abi::Abi::*;\n     match ccx.sess().target.target.adjust_abi(abi) {\n         RustIntrinsic => {\n             // Intrinsics are emitted at the call site\n@@ -488,7 +487,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &hir::ForeignMod) {\n \n         if let hir::ForeignItemFn(ref decl, _) = foreign_item.node {\n             match foreign_mod.abi {\n-                Rust | RustIntrinsic | PlatformIntrinsic => {}\n+                Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic => {}\n                 abi => {\n                     let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n                     match ty.sty {\n@@ -626,7 +625,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // normal Rust function. This will be the type of the wrappee fn.\n         match t.sty {\n             ty::TyBareFn(_, ref f) => {\n-                assert!(f.abi != Rust && f.abi != RustIntrinsic && f.abi != PlatformIntrinsic);\n+                assert!(f.abi != Abi::Rust);\n+                assert!(f.abi != Abi::RustIntrinsic);\n+                assert!(f.abi != Abi::PlatformIntrinsic);\n             }\n             _ => {\n                 ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {:?}, \\"}, {"sha": "018d4535d0cf15bec458b0949c2aebb343f77fe1", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -40,7 +40,7 @@ use trans::Disr;\n use middle::subst::Substs;\n use rustc::dep_graph::DepNode;\n use rustc_front::hir;\n-use syntax::abi::{self, RustIntrinsic};\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::parse::token;\n@@ -365,7 +365,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              &mut llargs,\n                              cleanup::CustomScope(cleanup_scope),\n                              false,\n-                             RustIntrinsic);\n+                             Abi::RustIntrinsic);\n \n     fcx.scopes.borrow_mut().last_mut().unwrap().drop_non_lifetime_clean();\n \n@@ -1261,7 +1261,7 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n     let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n-        abi: abi::Rust,\n+        abi: Abi::Rust,\n         sig: ty::Binder(ty::FnSig {\n             inputs: vec![i8p],\n             output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n@@ -1272,7 +1272,7 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     let output = ty::FnOutput::FnConverging(tcx.types.i32);\n     let try_fn_ty  = tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n-        abi: abi::Rust,\n+        abi: Abi::Rust,\n         sig: ty::Binder(ty::FnSig {\n             inputs: vec![fn_ty, i8p, i8p],\n             output: output,\n@@ -1350,7 +1350,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         // just do the same.\n         let filter_fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: hir::Unsafety::Unsafe,\n-            abi: abi::Rust,\n+            abi: Abi::Rust,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: vec![],\n                 output: output,\n@@ -1370,7 +1370,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         // those along.\n         let filter_fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: hir::Unsafety::Unsafe,\n-            abi: abi::Rust,\n+            abi: Abi::Rust,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: vec![i8p, i8p],\n                 output: output,\n@@ -1664,30 +1664,30 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n     use rustc::middle::ty::{TyInt, TyUint};\n     match *sty {\n         TyInt(t) => Some((match t {\n-            ast::TyIs => {\n+            ast::IntTy::Is => {\n                 match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n                     \"32\" => 32,\n                     \"64\" => 64,\n                     tws => panic!(\"Unsupported target word size for isize: {}\", tws),\n                 }\n             },\n-            ast::TyI8 => 8,\n-            ast::TyI16 => 16,\n-            ast::TyI32 => 32,\n-            ast::TyI64 => 64,\n+            ast::IntTy::I8 => 8,\n+            ast::IntTy::I16 => 16,\n+            ast::IntTy::I32 => 32,\n+            ast::IntTy::I64 => 64,\n         }, true)),\n         TyUint(t) => Some((match t {\n-            ast::TyUs => {\n+            ast::UintTy::Us => {\n                 match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n                     \"32\" => 32,\n                     \"64\" => 64,\n                     tws => panic!(\"Unsupported target word size for usize: {}\", tws),\n                 }\n             },\n-            ast::TyU8 => 8,\n-            ast::TyU16 => 16,\n-            ast::TyU32 => 32,\n-            ast::TyU64 => 64,\n+            ast::UintTy::U8 => 8,\n+            ast::UintTy::U16 => 16,\n+            ast::UintTy::U32 => 32,\n+            ast::UintTy::U64 => 64,\n         }, false)),\n         _ => None,\n     }"}, {"sha": "ab43861618d16f521f45f45843a4245ab3c93146", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -644,7 +644,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n                           -> &'tcx ty::BareFnTy<'tcx> {\n     let mut inputs = method_ty.sig.0.inputs.clone();\n-    inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(ast::TyI8));\n+    inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(ast::IntTy::I8));\n \n     tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: method_ty.unsafety,"}, {"sha": "cda62c238476e08f0c67fb565fea0078aafb30ee", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -29,7 +29,7 @@ use rustc::front::map as hir_map;\n \n use rustc_front::hir;\n \n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::errors;\n@@ -96,7 +96,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     if let hir_map::NodeForeignItem(_) = map_node {\n         let abi = ccx.tcx().map.get_foreign_abi(fn_node_id);\n-        if abi != abi::RustIntrinsic && abi != abi::PlatformIntrinsic {\n+        if abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic {\n             // Foreign externs don't have to be monomorphized.\n             return (get_item_val(ccx, fn_node_id), mono_ty, true);\n         }\n@@ -139,8 +139,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // This shouldn't need to option dance.\n     let mut hash_id = Some(hash_id);\n-    let mut mk_lldecl = |abi: abi::Abi| {\n-        let lldecl = if abi != abi::Rust {\n+    let mut mk_lldecl = |abi: Abi| {\n+        let lldecl = if abi != Abi::Rust {\n             foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s)\n         } else {\n             // FIXME(nagisa): perhaps needs a more fine grained selection? See\n@@ -181,7 +181,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   let d = mk_lldecl(abi);\n                   let needs_body = setup_lldecl(d, &i.attrs);\n                   if needs_body {\n-                      if abi != abi::Rust {\n+                      if abi != Abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n                               ccx, &**decl, &**body, &[], d, psubsts, fn_node_id,\n                               Some(&hash[..]));\n@@ -206,15 +206,15 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         hir_map::NodeVariant(v) => {\n             let variant = inlined_variant_def(ccx, fn_node_id);\n             assert_eq!(v.node.name, variant.name);\n-            let d = mk_lldecl(abi::Rust);\n+            let d = mk_lldecl(Abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n             trans_enum_variant(ccx, fn_node_id, Disr::from(variant.disr_val), psubsts, d);\n             d\n         }\n         hir_map::NodeImplItem(impl_item) => {\n             match impl_item.node {\n                 hir::ImplItemKind::Method(ref sig, ref body) => {\n-                    let d = mk_lldecl(abi::Rust);\n+                    let d = mk_lldecl(Abi::Rust);\n                     let needs_body = setup_lldecl(d, &impl_item.attrs);\n                     if needs_body {\n                         trans_fn(ccx,\n@@ -236,7 +236,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         hir_map::NodeTraitItem(trait_item) => {\n             match trait_item.node {\n                 hir::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    let d = mk_lldecl(abi::Rust);\n+                    let d = mk_lldecl(Abi::Rust);\n                     let needs_body = setup_lldecl(d, &trait_item.attrs);\n                     if needs_body {\n                         trans_fn(ccx,\n@@ -256,7 +256,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         hir_map::NodeStructCtor(struct_def) => {\n-            let d = mk_lldecl(abi::Rust);\n+            let d = mk_lldecl(Abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n             if struct_def.is_struct() {\n                 panic!(\"ast-mapped struct didn't have a ctor id\")"}, {"sha": "b3f783a974d9ba00ef2da070f99d5084c1ceaa8c", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -92,7 +92,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Handle the \"...\" case (returns a slice since strings are always unsized):\n     if let hir::ExprLit(ref lit) = content_expr.node {\n-        if let ast::LitStr(ref s, _) = lit.node {\n+        if let ast::LitKind::Str(ref s, _) = lit.node {\n             let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n             bcx = trans_lit_str(bcx,\n                                 content_expr,\n@@ -180,7 +180,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match content_expr.node {\n         hir::ExprLit(ref lit) => {\n             match lit.node {\n-                ast::LitStr(ref s, _) => {\n+                ast::LitKind::Str(ref s, _) => {\n                     match dest {\n                         Ignore => return bcx,\n                         SaveIn(lldest) => {\n@@ -276,7 +276,7 @@ fn elements_required(bcx: Block, content_expr: &hir::Expr) -> usize {\n     match content_expr.node {\n         hir::ExprLit(ref lit) => {\n             match lit.node {\n-                ast::LitStr(ref s, _) => s.len(),\n+                ast::LitKind::Str(ref s, _) => s.len(),\n                 _ => {\n                     bcx.tcx().sess.span_bug(content_expr.span,\n                                             \"unexpected evec content\")"}, {"sha": "17300f356c4349520d78b4406ca73466ab9cb057", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -127,28 +127,28 @@ impl Type {\n \n     pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::TyIs => ccx.int_type(),\n-            ast::TyI8 => Type::i8(ccx),\n-            ast::TyI16 => Type::i16(ccx),\n-            ast::TyI32 => Type::i32(ccx),\n-            ast::TyI64 => Type::i64(ccx)\n+            ast::IntTy::Is => ccx.int_type(),\n+            ast::IntTy::I8 => Type::i8(ccx),\n+            ast::IntTy::I16 => Type::i16(ccx),\n+            ast::IntTy::I32 => Type::i32(ccx),\n+            ast::IntTy::I64 => Type::i64(ccx)\n         }\n     }\n \n     pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::TyUs => ccx.int_type(),\n-            ast::TyU8 => Type::i8(ccx),\n-            ast::TyU16 => Type::i16(ccx),\n-            ast::TyU32 => Type::i32(ccx),\n-            ast::TyU64 => Type::i64(ccx)\n+            ast::UintTy::Us => ccx.int_type(),\n+            ast::UintTy::U8 => Type::i8(ccx),\n+            ast::UintTy::U16 => Type::i16(ccx),\n+            ast::UintTy::U32 => Type::i32(ccx),\n+            ast::UintTy::U64 => Type::i64(ccx)\n         }\n     }\n \n     pub fn float_from_ty(ccx: &CrateContext, t: ast::FloatTy) -> Type {\n         match t {\n-            ast::TyF32 => Type::f32(ccx),\n-            ast::TyF64 => Type::f64(ccx),\n+            ast::FloatTy::F32 => Type::f32(ccx),\n+            ast::FloatTy::F64 => Type::f64(ccx),\n         }\n     }\n "}, {"sha": "4b5a0b05512767a829a9fe03ebdf0f2f6f13c9e7", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -21,7 +21,7 @@ use middle::ty::{self, Ty, TypeFoldable};\n \n use trans::type_::Type;\n \n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::ast;\n \n // LLVM doesn't like objects that are too big. Issue #17913\n@@ -91,7 +91,7 @@ pub fn untuple_arguments<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  llenvironment_type: Option<Type>,\n                                  sig: &ty::FnSig<'tcx>,\n-                                 abi: abi::Abi)\n+                                 abi: Abi)\n                                  -> Type\n {\n     debug!(\"type_of_rust_fn(sig={:?},abi={:?})\",\n@@ -104,7 +104,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // First, munge the inputs, if this has the `rust-call` ABI.\n     let inputs_temp;\n-    let inputs = if abi == abi::RustCall {\n+    let inputs = if abi == Abi::RustCall {\n         inputs_temp = untuple_arguments(cx, &sig.inputs);\n         &inputs_temp\n     } else {\n@@ -156,7 +156,7 @@ pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>)\n         ty::TyBareFn(_, ref f) => {\n             // FIXME(#19925) once fn item types are\n             // zero-sized, we'll need to do something here\n-            if f.abi == abi::Rust || f.abi == abi::RustCall {\n+            if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n                 let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n                 let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n                 type_of_rust_fn(cx, None, &sig, f.abi)\n@@ -385,7 +385,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n                   let unsized_part = cx.tcx().struct_tail(ty);\n                   let info_ty = match unsized_part.sty {\n                       ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n-                          Type::uint_from_ty(cx, ast::TyUs)\n+                          Type::uint_from_ty(cx, ast::UintTy::Us)\n                       }\n                       ty::TyTrait(_) => Type::vtable_ptr(cx),\n                       _ => panic!(\"Unexpected type returned from \\"}, {"sha": "f0436eee420090712d2d8b400a9023a010163478", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -57,7 +57,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // They can denote both statically and dynamically sized byte arrays\n             let mut pat_ty = expr_ty;\n             if let hir::ExprLit(ref lt) = lt.node {\n-                if let ast::LitByteStr(_) = lt.node {\n+                if let ast::LitKind::ByteStr(_) = lt.node {\n                     let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n                     if let ty::TyRef(_, mt) = expected_ty.sty {\n                         if let ty::TySlice(_) = mt.ty.sty {"}, {"sha": "2ea0df280db216acd409130656059a103fd99502", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -248,7 +248,7 @@ impl<'tcx> CastCheck<'tcx> {\n             (_, Int(Bool)) => Err(CastError::CastToBool),\n \n             // * -> Char\n-            (Int(U(ast::TyU8)), Int(Char)) => Ok(CastKind::U8CharCast), // u8-char-cast\n+            (Int(U(ast::UintTy::U8)), Int(Char)) => Ok(CastKind::U8CharCast), // u8-char-cast\n             (_, Int(Char)) => Err(CastError::CastToChar),\n \n             // prim -> float,ptr"}, {"sha": "7fd35cf159ff91c91dd267751bca8d8edf799cdd", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -16,7 +16,7 @@ use astconv;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n-use syntax::abi;\n+use syntax::abi::Abi;\n use rustc_front::hir;\n \n pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n@@ -54,7 +54,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     let mut fn_ty = astconv::ty_of_closure(fcx,\n                                            hir::Unsafety::Normal,\n                                            decl,\n-                                           abi::RustCall,\n+                                           Abi::RustCall,\n                                            expected_sig);\n \n     // Create type variables (for now) to represent the transformed"}, {"sha": "ba6fa9aed3d9aaa987f773f0155416f9cd4601e0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -20,7 +20,7 @@ use middle::ty::fold::TypeFolder;\n use {CrateCtxt, require_same_types};\n \n use std::collections::{HashMap};\n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n@@ -30,7 +30,7 @@ use rustc_front::hir;\n \n fn equate_intrinsic_type<'a, 'tcx>(tcx: &ty::ctxt<'tcx>, it: &hir::ForeignItem,\n                                    n_tps: usize,\n-                                   abi: abi::Abi,\n+                                   abi: Abi,\n                                    inputs: Vec<ty::Ty<'tcx>>,\n                                    output: ty::FnOutput<'tcx>) {\n     let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n@@ -285,7 +285,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n                 let fn_ty = ty::BareFnTy {\n                     unsafety: hir::Unsafety::Normal,\n-                    abi: abi::Rust,\n+                    abi: Abi::Rust,\n                     sig: ty::Binder(FnSig {\n                         inputs: vec![mut_u8],\n                         output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n@@ -308,7 +308,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n         tcx,\n         it,\n         n_tps,\n-        abi::RustIntrinsic,\n+        Abi::RustIntrinsic,\n         inputs,\n         output\n         )\n@@ -398,7 +398,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n         tcx,\n         it,\n         n_tps,\n-        abi::PlatformIntrinsic,\n+        Abi::PlatformIntrinsic,\n         inputs,\n         ty::FnConverging(output)\n         )\n@@ -429,22 +429,22 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n         },\n         // (The width we pass to LLVM doesn't concern the type checker.)\n         Integer(signed, bits, _llvm_width) => match (signed, bits, &t.sty) {\n-            (true,  8,  &ty::TyInt(ast::IntTy::TyI8)) |\n-            (false, 8,  &ty::TyUint(ast::UintTy::TyU8)) |\n-            (true,  16, &ty::TyInt(ast::IntTy::TyI16)) |\n-            (false, 16, &ty::TyUint(ast::UintTy::TyU16)) |\n-            (true,  32, &ty::TyInt(ast::IntTy::TyI32)) |\n-            (false, 32, &ty::TyUint(ast::UintTy::TyU32)) |\n-            (true,  64, &ty::TyInt(ast::IntTy::TyI64)) |\n-            (false, 64, &ty::TyUint(ast::UintTy::TyU64)) => {},\n+            (true,  8,  &ty::TyInt(ast::IntTy::I8)) |\n+            (false, 8,  &ty::TyUint(ast::UintTy::U8)) |\n+            (true,  16, &ty::TyInt(ast::IntTy::I16)) |\n+            (false, 16, &ty::TyUint(ast::UintTy::U16)) |\n+            (true,  32, &ty::TyInt(ast::IntTy::I32)) |\n+            (false, 32, &ty::TyUint(ast::UintTy::U32)) |\n+            (true,  64, &ty::TyInt(ast::IntTy::I64)) |\n+            (false, 64, &ty::TyUint(ast::UintTy::U64)) => {},\n             _ => simple_error(&format!(\"`{}`\", t),\n                               &format!(\"`{}{n}`\",\n                                        if signed {\"i\"} else {\"u\"},\n                                        n = bits)),\n         },\n         Float(bits) => match (bits, &t.sty) {\n-            (32, &ty::TyFloat(ast::FloatTy::TyF32)) |\n-            (64, &ty::TyFloat(ast::FloatTy::TyF64)) => {},\n+            (32, &ty::TyFloat(ast::FloatTy::F32)) |\n+            (64, &ty::TyFloat(ast::FloatTy::F64)) => {},\n             _ => simple_error(&format!(\"`{}`\", t),\n                               &format!(\"`f{n}`\", n = bits)),\n         },"}, {"sha": "3cf182a0d8ff6ba941c45e0acc440ba804c07b23", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -317,51 +317,51 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 let lang_def_id = self.tcx().lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::TyI8) => {\n+            ty::TyInt(ast::IntTy::I8) => {\n                 let lang_def_id = self.tcx().lang_items.i8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::TyI16) => {\n+            ty::TyInt(ast::IntTy::I16) => {\n                 let lang_def_id = self.tcx().lang_items.i16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::TyI32) => {\n+            ty::TyInt(ast::IntTy::I32) => {\n                 let lang_def_id = self.tcx().lang_items.i32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::TyI64) => {\n+            ty::TyInt(ast::IntTy::I64) => {\n                 let lang_def_id = self.tcx().lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyInt(ast::TyIs) => {\n+            ty::TyInt(ast::IntTy::Is) => {\n                 let lang_def_id = self.tcx().lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::TyU8) => {\n+            ty::TyUint(ast::UintTy::U8) => {\n                 let lang_def_id = self.tcx().lang_items.u8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::TyU16) => {\n+            ty::TyUint(ast::UintTy::U16) => {\n                 let lang_def_id = self.tcx().lang_items.u16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::TyU32) => {\n+            ty::TyUint(ast::UintTy::U32) => {\n                 let lang_def_id = self.tcx().lang_items.u32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::TyU64) => {\n+            ty::TyUint(ast::UintTy::U64) => {\n                 let lang_def_id = self.tcx().lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyUint(ast::TyUs) => {\n+            ty::TyUint(ast::UintTy::Us) => {\n                 let lang_def_id = self.tcx().lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyFloat(ast::TyF32) => {\n+            ty::TyFloat(ast::FloatTy::F32) => {\n                 let lang_def_id = self.tcx().lang_items.f32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::TyFloat(ast::TyF64) => {\n+            ty::TyFloat(ast::FloatTy::F64) => {\n                 let lang_def_id = self.tcx().lang_items.f64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }"}, {"sha": "f61316f1dfe71b07db32ce8094d13fcbd2361069", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -115,7 +115,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use std::cell::{Cell, Ref, RefCell};\n use std::collections::{HashSet};\n use std::mem::replace;\n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n@@ -691,11 +691,11 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         check_bounds_are_used(ccx, &generics.ty_params, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n-        if m.abi == abi::RustIntrinsic {\n+        if m.abi == Abi::RustIntrinsic {\n             for item in &m.items {\n                 intrinsic::check_intrinsic_type(ccx, item);\n             }\n-        } else if m.abi == abi::PlatformIntrinsic {\n+        } else if m.abi == Abi::PlatformIntrinsic {\n             for item in &m.items {\n                 intrinsic::check_platform_intrinsic_type(ccx, item);\n             }\n@@ -2264,7 +2264,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // First, try built-in indexing.\n     match (adjusted_ty.builtin_index(), &index_ty.sty) {\n-        (Some(ty), &ty::TyUint(ast::TyUs)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n+        (Some(ty), &ty::TyUint(ast::UintTy::Us)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n             debug!(\"try_index_step: success, using built-in indexing\");\n             // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n             assert!(!unsize);\n@@ -2556,21 +2556,21 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n                                                     fcx.expr_ty(&**arg));\n             match arg_ty.sty {\n-                ty::TyFloat(ast::TyF32) => {\n+                ty::TyFloat(ast::FloatTy::F32) => {\n                     fcx.type_error_message(arg.span,\n                                            |t| {\n                         format!(\"can't pass an {} to variadic \\\n                                  function, cast to c_double\", t)\n                     }, arg_ty, None);\n                 }\n-                ty::TyInt(ast::TyI8) | ty::TyInt(ast::TyI16) | ty::TyBool => {\n+                ty::TyInt(ast::IntTy::I8) | ty::TyInt(ast::IntTy::I16) | ty::TyBool => {\n                     fcx.type_error_message(arg.span, |t| {\n                         format!(\"can't pass {} to variadic \\\n                                  function, cast to c_int\",\n                                        t)\n                     }, arg_ty, None);\n                 }\n-                ty::TyUint(ast::TyU8) | ty::TyUint(ast::TyU16) => {\n+                ty::TyUint(ast::UintTy::U8) | ty::TyUint(ast::UintTy::U16) => {\n                     fcx.type_error_message(arg.span, |t| {\n                         format!(\"can't pass {} to variadic \\\n                                  function, cast to c_uint\",\n@@ -2606,16 +2606,16 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        ast::LitStr(..) => tcx.mk_static_str(),\n-        ast::LitByteStr(ref v) => {\n+        ast::LitKind::Str(..) => tcx.mk_static_str(),\n+        ast::LitKind::ByteStr(ref v) => {\n             tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n                             tcx.mk_array(tcx.types.u8, v.len()))\n         }\n-        ast::LitByte(_) => tcx.types.u8,\n-        ast::LitChar(_) => tcx.types.char,\n-        ast::LitInt(_, ast::SignedIntLit(t, _)) => tcx.mk_mach_int(t),\n-        ast::LitInt(_, ast::UnsignedIntLit(t)) => tcx.mk_mach_uint(t),\n-        ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n+        ast::LitKind::Byte(_) => tcx.types.u8,\n+        ast::LitKind::Char(_) => tcx.types.char,\n+        ast::LitKind::Int(_, ast::LitIntType::Signed(t)) => tcx.mk_mach_int(t),\n+        ast::LitKind::Int(_, ast::LitIntType::Unsigned(t)) => tcx.mk_mach_uint(t),\n+        ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n             let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n                     ty::TyInt(_) | ty::TyUint(_) => Some(ty),\n@@ -2628,8 +2628,8 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             opt_ty.unwrap_or_else(\n                 || tcx.mk_int_var(fcx.infcx().next_int_var_id()))\n         }\n-        ast::LitFloat(_, t) => tcx.mk_mach_float(t),\n-        ast::LitFloatUnsuffixed(_) => {\n+        ast::LitKind::Float(_, t) => tcx.mk_mach_float(t),\n+        ast::LitKind::FloatUnsuffixed(_) => {\n             let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n                     ty::TyFloat(_) => Some(ty),\n@@ -2639,7 +2639,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             opt_ty.unwrap_or_else(\n                 || tcx.mk_float_var(fcx.infcx().next_float_var_id()))\n         }\n-        ast::LitBool(_) => tcx.types.bool\n+        ast::LitKind::Bool(_) => tcx.types.bool\n     }\n }\n \n@@ -4167,20 +4167,20 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                      disr: ty::Disr) -> bool {\n         fn uint_in_range(ccx: &CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n             match ty {\n-                ast::TyU8 => disr as u8 as Disr == disr,\n-                ast::TyU16 => disr as u16 as Disr == disr,\n-                ast::TyU32 => disr as u32 as Disr == disr,\n-                ast::TyU64 => disr as u64 as Disr == disr,\n-                ast::TyUs => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n+                ast::UintTy::U8 => disr as u8 as Disr == disr,\n+                ast::UintTy::U16 => disr as u16 as Disr == disr,\n+                ast::UintTy::U32 => disr as u32 as Disr == disr,\n+                ast::UintTy::U64 => disr as u64 as Disr == disr,\n+                ast::UintTy::Us => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n             }\n         }\n         fn int_in_range(ccx: &CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n             match ty {\n-                ast::TyI8 => disr as i8 as Disr == disr,\n-                ast::TyI16 => disr as i16 as Disr == disr,\n-                ast::TyI32 => disr as i32 as Disr == disr,\n-                ast::TyI64 => disr as i64 as Disr == disr,\n-                ast::TyIs => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n+                ast::IntTy::I8 => disr as i8 as Disr == disr,\n+                ast::IntTy::I16 => disr as i16 as Disr == disr,\n+                ast::IntTy::I32 => disr as i32 as Disr == disr,\n+                ast::IntTy::I64 => disr as i64 as Disr == disr,\n+                ast::IntTy::Is => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n             }\n         }\n         match ty {"}, {"sha": "9e966c283a0a5efddbd967849d290219a8f6043e", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -121,84 +121,84 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                                                   \"*mut T\",\n                                                   item.span);\n                     }\n-                    ty::TyInt(ast::TyI8) => {\n+                    ty::TyInt(ast::IntTy::I8) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i8_impl(),\n                                                   \"i8\",\n                                                   \"i8\",\n                                                   item.span);\n                     }\n-                    ty::TyInt(ast::TyI16) => {\n+                    ty::TyInt(ast::IntTy::I16) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i16_impl(),\n                                                   \"i16\",\n                                                   \"i16\",\n                                                   item.span);\n                     }\n-                    ty::TyInt(ast::TyI32) => {\n+                    ty::TyInt(ast::IntTy::I32) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i32_impl(),\n                                                   \"i32\",\n                                                   \"i32\",\n                                                   item.span);\n                     }\n-                    ty::TyInt(ast::TyI64) => {\n+                    ty::TyInt(ast::IntTy::I64) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.i64_impl(),\n                                                   \"i64\",\n                                                   \"i64\",\n                                                   item.span);\n                     }\n-                    ty::TyInt(ast::TyIs) => {\n+                    ty::TyInt(ast::IntTy::Is) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.isize_impl(),\n                                                   \"isize\",\n                                                   \"isize\",\n                                                   item.span);\n                     }\n-                    ty::TyUint(ast::TyU8) => {\n+                    ty::TyUint(ast::UintTy::U8) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u8_impl(),\n                                                   \"u8\",\n                                                   \"u8\",\n                                                   item.span);\n                     }\n-                    ty::TyUint(ast::TyU16) => {\n+                    ty::TyUint(ast::UintTy::U16) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u16_impl(),\n                                                   \"u16\",\n                                                   \"u16\",\n                                                   item.span);\n                     }\n-                    ty::TyUint(ast::TyU32) => {\n+                    ty::TyUint(ast::UintTy::U32) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u32_impl(),\n                                                   \"u32\",\n                                                   \"u32\",\n                                                   item.span);\n                     }\n-                    ty::TyUint(ast::TyU64) => {\n+                    ty::TyUint(ast::UintTy::U64) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.u64_impl(),\n                                                   \"u64\",\n                                                   \"u64\",\n                                                   item.span);\n                     }\n-                    ty::TyUint(ast::TyUs) => {\n+                    ty::TyUint(ast::UintTy::Us) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.usize_impl(),\n                                                   \"usize\",\n                                                   \"usize\",\n                                                   item.span);\n                     }\n-                    ty::TyFloat(ast::TyF32) => {\n+                    ty::TyFloat(ast::FloatTy::F32) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.f32_impl(),\n                                                   \"f32\",\n                                                   \"f32\",\n                                                   item.span);\n                     }\n-                    ty::TyFloat(ast::TyF64) => {\n+                    ty::TyFloat(ast::FloatTy::F64) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.f64_impl(),\n                                                   \"f64\","}, {"sha": "0c8ad5abe6f8ed71fbd2618313f26713c7bf15a2", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -111,7 +111,8 @@ use util::common::time;\n use rustc_front::hir;\n \n use syntax::codemap::Span;\n-use syntax::{ast, abi};\n+use syntax::ast;\n+use syntax::abi::Abi;\n \n use std::cell::RefCell;\n \n@@ -175,9 +176,9 @@ fn lookup_full_def(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) -> Def {\n \n fn require_c_abi_if_variadic(tcx: &ty::ctxt,\n                              decl: &hir::FnDecl,\n-                             abi: abi::Abi,\n+                             abi: Abi,\n                              span: Span) {\n-    if decl.variadic && abi != abi::C {\n+    if decl.variadic && abi != Abi::C {\n         span_err!(tcx.sess, span, E0045,\n                   \"variadic function must have C calling convention\");\n     }\n@@ -238,7 +239,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             let main_def_id = tcx.map.local_def_id(main_id);\n             let se_ty = tcx.mk_fn(Some(main_def_id), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n-                abi: abi::Rust,\n+                abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: Vec::new(),\n                     output: ty::FnConverging(tcx.mk_nil()),\n@@ -285,7 +286,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             let se_ty = tcx.mk_fn(Some(ccx.tcx.map.local_def_id(start_id)),\n                                   tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n-                abi: abi::Rust,\n+                abi: Abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: vec!(\n                         tcx.types.isize,"}, {"sha": "ca05806d8f95a181f7d242fb74e10e517c4a14d8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -25,7 +25,7 @@ pub use self::SelfTy::*;\n pub use self::FunctionRetTy::*;\n \n use syntax;\n-use syntax::abi;\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n@@ -451,11 +451,11 @@ pub enum Attribute {\n impl Clean<Attribute> for ast::MetaItem {\n     fn clean(&self, cx: &DocContext) -> Attribute {\n         match self.node {\n-            ast::MetaWord(ref s) => Word(s.to_string()),\n-            ast::MetaList(ref s, ref l) => {\n+            ast::MetaItemKind::Word(ref s) => Word(s.to_string()),\n+            ast::MetaItemKind::List(ref s, ref l) => {\n                 List(s.to_string(), l.clean(cx))\n             }\n-            ast::MetaNameValue(ref s, ref v) => {\n+            ast::MetaItemKind::NameValue(ref s, ref v) => {\n                 NameValue(s.to_string(), lit_to_string(v))\n             }\n         }\n@@ -993,7 +993,7 @@ pub struct Method {\n     pub unsafety: hir::Unsafety,\n     pub constness: hir::Constness,\n     pub decl: FnDecl,\n-    pub abi: abi::Abi\n+    pub abi: Abi,\n }\n \n impl Clean<Method> for hir::MethodSig {\n@@ -1028,7 +1028,7 @@ pub struct TyMethod {\n     pub decl: FnDecl,\n     pub generics: Generics,\n     pub self_: SelfTy,\n-    pub abi: abi::Abi\n+    pub abi: Abi,\n }\n \n impl Clean<TyMethod> for hir::MethodSig {\n@@ -1082,7 +1082,7 @@ pub struct Function {\n     pub generics: Generics,\n     pub unsafety: hir::Unsafety,\n     pub constness: hir::Constness,\n-    pub abi: abi::Abi,\n+    pub abi: Abi,\n }\n \n impl Clean<Item> for doctree::Function {\n@@ -1640,18 +1640,18 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n         match self.sty {\n             ty::TyBool => Primitive(Bool),\n             ty::TyChar => Primitive(Char),\n-            ty::TyInt(ast::TyIs) => Primitive(Isize),\n-            ty::TyInt(ast::TyI8) => Primitive(I8),\n-            ty::TyInt(ast::TyI16) => Primitive(I16),\n-            ty::TyInt(ast::TyI32) => Primitive(I32),\n-            ty::TyInt(ast::TyI64) => Primitive(I64),\n-            ty::TyUint(ast::TyUs) => Primitive(Usize),\n-            ty::TyUint(ast::TyU8) => Primitive(U8),\n-            ty::TyUint(ast::TyU16) => Primitive(U16),\n-            ty::TyUint(ast::TyU32) => Primitive(U32),\n-            ty::TyUint(ast::TyU64) => Primitive(U64),\n-            ty::TyFloat(ast::TyF32) => Primitive(F32),\n-            ty::TyFloat(ast::TyF64) => Primitive(F64),\n+            ty::TyInt(ast::IntTy::Is) => Primitive(Isize),\n+            ty::TyInt(ast::IntTy::I8) => Primitive(I8),\n+            ty::TyInt(ast::IntTy::I16) => Primitive(I16),\n+            ty::TyInt(ast::IntTy::I32) => Primitive(I32),\n+            ty::TyInt(ast::IntTy::I64) => Primitive(I64),\n+            ty::TyUint(ast::UintTy::Us) => Primitive(Usize),\n+            ty::TyUint(ast::UintTy::U8) => Primitive(U8),\n+            ty::TyUint(ast::UintTy::U16) => Primitive(U16),\n+            ty::TyUint(ast::UintTy::U32) => Primitive(U32),\n+            ty::TyUint(ast::UintTy::U64) => Primitive(U64),\n+            ty::TyFloat(ast::FloatTy::F32) => Primitive(F32),\n+            ty::TyFloat(ast::FloatTy::F64) => Primitive(F64),\n             ty::TyStr => Primitive(Str),\n             ty::TyBox(t) => {\n                 let box_did = cx.tcx_opt().and_then(|tcx| {\n@@ -2486,7 +2486,7 @@ impl Clean<Item> for hir::ForeignItem {\n                     decl: decl.clean(cx),\n                     generics: generics.clean(cx),\n                     unsafety: hir::Unsafety::Unsafe,\n-                    abi: abi::Rust,\n+                    abi: Abi::Rust,\n                     constness: hir::Constness::NotConst,\n                 })\n             }\n@@ -2531,21 +2531,21 @@ impl ToSource for syntax::codemap::Span {\n \n fn lit_to_string(lit: &ast::Lit) -> String {\n     match lit.node {\n-        ast::LitStr(ref st, _) => st.to_string(),\n-        ast::LitByteStr(ref data) => format!(\"{:?}\", data),\n-        ast::LitByte(b) => {\n+        ast::LitKind::Str(ref st, _) => st.to_string(),\n+        ast::LitKind::ByteStr(ref data) => format!(\"{:?}\", data),\n+        ast::LitKind::Byte(b) => {\n             let mut res = String::from(\"b'\");\n             for c in (b as char).escape_default() {\n                 res.push(c);\n             }\n             res.push('\\'');\n             res\n         },\n-        ast::LitChar(c) => format!(\"'{}'\", c),\n-        ast::LitInt(i, _t) => i.to_string(),\n-        ast::LitFloat(ref f, _t) => f.to_string(),\n-        ast::LitFloatUnsuffixed(ref f) => f.to_string(),\n-        ast::LitBool(b) => b.to_string(),\n+        ast::LitKind::Char(c) => format!(\"'{}'\", c),\n+        ast::LitKind::Int(i, _t) => i.to_string(),\n+        ast::LitKind::Float(ref f, _t) => f.to_string(),\n+        ast::LitKind::FloatUnsuffixed(ref f) => f.to_string(),\n+        ast::LitKind::Bool(b) => b.to_string(),\n     }\n }\n \n@@ -2619,18 +2619,18 @@ fn resolve_type(cx: &DocContext,\n             hir::TyStr => return Primitive(Str),\n             hir::TyBool => return Primitive(Bool),\n             hir::TyChar => return Primitive(Char),\n-            hir::TyInt(ast::TyIs) => return Primitive(Isize),\n-            hir::TyInt(ast::TyI8) => return Primitive(I8),\n-            hir::TyInt(ast::TyI16) => return Primitive(I16),\n-            hir::TyInt(ast::TyI32) => return Primitive(I32),\n-            hir::TyInt(ast::TyI64) => return Primitive(I64),\n-            hir::TyUint(ast::TyUs) => return Primitive(Usize),\n-            hir::TyUint(ast::TyU8) => return Primitive(U8),\n-            hir::TyUint(ast::TyU16) => return Primitive(U16),\n-            hir::TyUint(ast::TyU32) => return Primitive(U32),\n-            hir::TyUint(ast::TyU64) => return Primitive(U64),\n-            hir::TyFloat(ast::TyF32) => return Primitive(F32),\n-            hir::TyFloat(ast::TyF64) => return Primitive(F64),\n+            hir::TyInt(ast::IntTy::Is) => return Primitive(Isize),\n+            hir::TyInt(ast::IntTy::I8) => return Primitive(I8),\n+            hir::TyInt(ast::IntTy::I16) => return Primitive(I16),\n+            hir::TyInt(ast::IntTy::I32) => return Primitive(I32),\n+            hir::TyInt(ast::IntTy::I64) => return Primitive(I64),\n+            hir::TyUint(ast::UintTy::Us) => return Primitive(Usize),\n+            hir::TyUint(ast::UintTy::U8) => return Primitive(U8),\n+            hir::TyUint(ast::UintTy::U16) => return Primitive(U16),\n+            hir::TyUint(ast::UintTy::U32) => return Primitive(U32),\n+            hir::TyUint(ast::UintTy::U64) => return Primitive(U64),\n+            hir::TyFloat(ast::FloatTy::F32) => return Primitive(F32),\n+            hir::TyFloat(ast::FloatTy::F64) => return Primitive(F64),\n         },\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(special_idents::type_self.name.to_string());"}, {"sha": "c959e2108f5a7ce09869c2b1b6adc6bb7ce9f35e", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -8,27 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::Os::*;\n-pub use self::Abi::*;\n-pub use self::Architecture::*;\n-pub use self::AbiArchitecture::*;\n-\n use std::fmt;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[allow(non_camel_case_types)]\n pub enum Os {\n-    OsWindows,\n-    OsMacos,\n-    OsLinux,\n-    OsAndroid,\n-    OsFreebsd,\n-    OsiOS,\n-    OsDragonfly,\n-    OsBitrig,\n-    OsNetbsd,\n-    OsOpenbsd,\n-    OsNaCl,\n-    OsSolaris,\n+    Windows,\n+    Macos,\n+    Linux,\n+    Android,\n+    Freebsd,\n+    iOS,\n+    Dragonfly,\n+    Bitrig,\n+    Netbsd,\n+    Openbsd,\n+    NaCl,\n+    Solaris,\n }\n \n #[derive(PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Clone, Copy, Debug)]\n@@ -74,33 +70,33 @@ pub struct AbiData {\n #[derive(Copy, Clone)]\n pub enum AbiArchitecture {\n     /// Not a real ABI (e.g., intrinsic)\n-    RustArch,\n+    Rust,\n     /// An ABI that specifies cross-platform defaults (e.g., \"C\")\n-    AllArch,\n+    All,\n     /// Multiple architectures (bitset)\n     Archs(u32)\n }\n \n #[allow(non_upper_case_globals)]\n const AbiDatas: &'static [AbiData] = &[\n     // Platform-specific ABIs\n-    AbiData {abi: Cdecl, name: \"cdecl\" },\n-    AbiData {abi: Stdcall, name: \"stdcall\" },\n-    AbiData {abi: Fastcall, name: \"fastcall\" },\n-    AbiData {abi: Vectorcall, name: \"vectorcall\"},\n-    AbiData {abi: Aapcs, name: \"aapcs\" },\n-    AbiData {abi: Win64, name: \"win64\" },\n+    AbiData {abi: Abi::Cdecl, name: \"cdecl\" },\n+    AbiData {abi: Abi::Stdcall, name: \"stdcall\" },\n+    AbiData {abi: Abi::Fastcall, name: \"fastcall\" },\n+    AbiData {abi: Abi::Vectorcall, name: \"vectorcall\"},\n+    AbiData {abi: Abi::Aapcs, name: \"aapcs\" },\n+    AbiData {abi: Abi::Win64, name: \"win64\" },\n \n     // Cross-platform ABIs\n     //\n     // NB: Do not adjust this ordering without\n     // adjusting the indices below.\n-    AbiData {abi: Rust, name: \"Rust\" },\n-    AbiData {abi: C, name: \"C\" },\n-    AbiData {abi: System, name: \"system\" },\n-    AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\" },\n-    AbiData {abi: RustCall, name: \"rust-call\" },\n-    AbiData {abi: PlatformIntrinsic, name: \"platform-intrinsic\" }\n+    AbiData {abi: Abi::Rust, name: \"Rust\" },\n+    AbiData {abi: Abi::C, name: \"C\" },\n+    AbiData {abi: Abi::System, name: \"system\" },\n+    AbiData {abi: Abi::RustIntrinsic, name: \"rust-intrinsic\" },\n+    AbiData {abi: Abi::RustCall, name: \"rust-call\" },\n+    AbiData {abi: Abi::PlatformIntrinsic, name: \"platform-intrinsic\" }\n ];\n \n /// Returns the ABI with the given name (if any).\n@@ -137,18 +133,18 @@ impl fmt::Display for Abi {\n impl fmt::Display for Os {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            OsLinux => \"linux\".fmt(f),\n-            OsWindows => \"windows\".fmt(f),\n-            OsMacos => \"macos\".fmt(f),\n-            OsiOS => \"ios\".fmt(f),\n-            OsAndroid => \"android\".fmt(f),\n-            OsFreebsd => \"freebsd\".fmt(f),\n-            OsDragonfly => \"dragonfly\".fmt(f),\n-            OsBitrig => \"bitrig\".fmt(f),\n-            OsNetbsd => \"netbsd\".fmt(f),\n-            OsOpenbsd => \"openbsd\".fmt(f),\n-            OsNaCl => \"nacl\".fmt(f),\n-            OsSolaris => \"solaris\".fmt(f),\n+            Os::Linux => \"linux\".fmt(f),\n+            Os::Windows => \"windows\".fmt(f),\n+            Os::Macos => \"macos\".fmt(f),\n+            Os::iOS => \"ios\".fmt(f),\n+            Os::Android => \"android\".fmt(f),\n+            Os::Freebsd => \"freebsd\".fmt(f),\n+            Os::Dragonfly => \"dragonfly\".fmt(f),\n+            Os::Bitrig => \"bitrig\".fmt(f),\n+            Os::Netbsd => \"netbsd\".fmt(f),\n+            Os::Openbsd => \"openbsd\".fmt(f),\n+            Os::NaCl => \"nacl\".fmt(f),\n+            Os::Solaris => \"solaris\".fmt(f),\n         }\n     }\n }"}, {"sha": "bae6d780b5e5b5535e3bbd0cda5bff222b837e9c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 286, "deletions": 345, "changes": 631, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -10,38 +10,11 @@\n \n // The Rust abstract syntax tree.\n \n-pub use self::BinOp_::*;\n-pub use self::BlockCheckMode::*;\n-pub use self::CaptureClause::*;\n-pub use self::Decl_::*;\n-pub use self::ExplicitSelf_::*;\n-pub use self::Expr_::*;\n-pub use self::FloatTy::*;\n-pub use self::FunctionRetTy::*;\n-pub use self::ForeignItem_::*;\n-pub use self::IntTy::*;\n-pub use self::Item_::*;\n-pub use self::KleeneOp::*;\n-pub use self::Lit_::*;\n-pub use self::LitIntType::*;\n-pub use self::MacStmtStyle::*;\n-pub use self::MetaItem_::*;\n-pub use self::Mutability::*;\n pub use self::Pat_::*;\n-pub use self::PathListItem_::*;\n-pub use self::PrimTy::*;\n-pub use self::Sign::*;\n-pub use self::Stmt_::*;\n-pub use self::StrStyle::*;\n pub use self::StructFieldKind::*;\n-pub use self::TraitItem_::*;\n-pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n-pub use self::UintTy::*;\n-pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n-pub use self::Visibility::*;\n pub use self::PathParameters::*;\n \n use attr::ThinAttributes;\n@@ -497,31 +470,32 @@ pub struct Crate {\n     pub exported_macros: Vec<MacroDef>,\n }\n \n-pub type MetaItem = Spanned<MetaItem_>;\n+pub type MetaItem = Spanned<MetaItemKind>;\n \n #[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum MetaItem_ {\n-    MetaWord(InternedString),\n-    MetaList(InternedString, Vec<P<MetaItem>>),\n-    MetaNameValue(InternedString, Lit),\n+pub enum MetaItemKind {\n+    Word(InternedString),\n+    List(InternedString, Vec<P<MetaItem>>),\n+    NameValue(InternedString, Lit),\n }\n \n-// can't be derived because the MetaList requires an unordered comparison\n-impl PartialEq for MetaItem_ {\n-    fn eq(&self, other: &MetaItem_) -> bool {\n+// can't be derived because the MetaItemKind::List requires an unordered comparison\n+impl PartialEq for MetaItemKind {\n+    fn eq(&self, other: &MetaItemKind) -> bool {\n+        use self::MetaItemKind::*;\n         match *self {\n-            MetaWord(ref ns) => match *other {\n-                MetaWord(ref no) => (*ns) == (*no),\n+            Word(ref ns) => match *other {\n+                Word(ref no) => (*ns) == (*no),\n                 _ => false\n             },\n-            MetaNameValue(ref ns, ref vs) => match *other {\n-                MetaNameValue(ref no, ref vo) => {\n+            NameValue(ref ns, ref vs) => match *other {\n+                NameValue(ref no, ref vo) => {\n                     (*ns) == (*no) && vs.node == vo.node\n                 }\n                 _ => false\n             },\n-            MetaList(ref ns, ref miss) => match *other {\n-                MetaList(ref no, ref miso) => {\n+            List(ref ns, ref miss) => match *other {\n+                List(ref no, ref miso) => {\n                     ns == no &&\n                         miss.iter().all(|mi| miso.iter().any(|x| x.node == mi.node))\n                 }\n@@ -623,133 +597,135 @@ pub enum Pat_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum Mutability {\n-    MutMutable,\n-    MutImmutable,\n+    Mutable,\n+    Immutable,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum BinOp_ {\n+pub enum BinOpKind {\n     /// The `+` operator (addition)\n-    BiAdd,\n+    Add,\n     /// The `-` operator (subtraction)\n-    BiSub,\n+    Sub,\n     /// The `*` operator (multiplication)\n-    BiMul,\n+    Mul,\n     /// The `/` operator (division)\n-    BiDiv,\n+    Div,\n     /// The `%` operator (modulus)\n-    BiRem,\n+    Rem,\n     /// The `&&` operator (logical and)\n-    BiAnd,\n+    And,\n     /// The `||` operator (logical or)\n-    BiOr,\n+    Or,\n     /// The `^` operator (bitwise xor)\n-    BiBitXor,\n+    BitXor,\n     /// The `&` operator (bitwise and)\n-    BiBitAnd,\n+    BitAnd,\n     /// The `|` operator (bitwise or)\n-    BiBitOr,\n+    BitOr,\n     /// The `<<` operator (shift left)\n-    BiShl,\n+    Shl,\n     /// The `>>` operator (shift right)\n-    BiShr,\n+    Shr,\n     /// The `==` operator (equality)\n-    BiEq,\n+    Eq,\n     /// The `<` operator (less than)\n-    BiLt,\n+    Lt,\n     /// The `<=` operator (less than or equal to)\n-    BiLe,\n+    Le,\n     /// The `!=` operator (not equal to)\n-    BiNe,\n+    Ne,\n     /// The `>=` operator (greater than or equal to)\n-    BiGe,\n+    Ge,\n     /// The `>` operator (greater than)\n-    BiGt,\n+    Gt,\n }\n \n-impl BinOp_ {\n+impl BinOpKind {\n     pub fn to_string(&self) -> &'static str {\n+        use self::BinOpKind::*;\n         match *self {\n-            BiAdd => \"+\",\n-            BiSub => \"-\",\n-            BiMul => \"*\",\n-            BiDiv => \"/\",\n-            BiRem => \"%\",\n-            BiAnd => \"&&\",\n-            BiOr => \"||\",\n-            BiBitXor => \"^\",\n-            BiBitAnd => \"&\",\n-            BiBitOr => \"|\",\n-            BiShl => \"<<\",\n-            BiShr => \">>\",\n-            BiEq => \"==\",\n-            BiLt => \"<\",\n-            BiLe => \"<=\",\n-            BiNe => \"!=\",\n-            BiGe => \">=\",\n-            BiGt => \">\"\n+            Add => \"+\",\n+            Sub => \"-\",\n+            Mul => \"*\",\n+            Div => \"/\",\n+            Rem => \"%\",\n+            And => \"&&\",\n+            Or => \"||\",\n+            BitXor => \"^\",\n+            BitAnd => \"&\",\n+            BitOr => \"|\",\n+            Shl => \"<<\",\n+            Shr => \">>\",\n+            Eq => \"==\",\n+            Lt => \"<\",\n+            Le => \"<=\",\n+            Ne => \"!=\",\n+            Ge => \">=\",\n+            Gt => \">\",\n         }\n     }\n     pub fn lazy(&self) -> bool {\n         match *self {\n-            BiAnd | BiOr => true,\n+            BinOpKind::And | BinOpKind::Or => true,\n             _ => false\n         }\n     }\n \n     pub fn is_shift(&self) -> bool {\n         match *self {\n-            BiShl | BiShr => true,\n+            BinOpKind::Shl | BinOpKind::Shr => true,\n             _ => false\n         }\n     }\n     pub fn is_comparison(&self) -> bool {\n+        use self::BinOpKind::*;\n         match *self {\n-            BiEq | BiLt | BiLe | BiNe | BiGt | BiGe =>\n+            Eq | Lt | Le | Ne | Gt | Ge =>\n             true,\n-            BiAnd | BiOr | BiAdd | BiSub | BiMul | BiDiv | BiRem |\n-            BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr =>\n+            And | Or | Add | Sub | Mul | Div | Rem |\n+            BitXor | BitAnd | BitOr | Shl | Shr =>\n             false,\n         }\n     }\n     /// Returns `true` if the binary operator takes its arguments by value\n     pub fn is_by_value(&self) -> bool {\n-        !BinOp_::is_comparison(self)\n+        !self.is_comparison()\n     }\n }\n \n-pub type BinOp = Spanned<BinOp_>;\n+pub type BinOp = Spanned<BinOpKind>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum UnOp {\n     /// The `*` operator for dereferencing\n-    UnDeref,\n+    Deref,\n     /// The `!` operator for logical inversion\n-    UnNot,\n+    Not,\n     /// The `-` operator for negation\n-    UnNeg\n+    Neg,\n }\n \n impl UnOp {\n     /// Returns `true` if the unary operator takes its argument by value\n     pub fn is_by_value(u: UnOp) -> bool {\n         match u {\n-            UnNeg | UnNot => true,\n+            UnOp::Neg | UnOp::Not => true,\n             _ => false,\n         }\n     }\n \n     pub fn to_string(op: UnOp) -> &'static str {\n         match op {\n-            UnDeref => \"*\",\n-            UnNot => \"!\",\n-            UnNeg => \"-\",\n+            UnOp::Deref => \"*\",\n+            UnOp::Not => \"!\",\n+            UnOp::Neg => \"-\",\n         }\n     }\n }\n \n /// A statement\n-pub type Stmt = Spanned<Stmt_>;\n+pub type Stmt = Spanned<StmtKind>;\n \n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -762,36 +738,36 @@ impl fmt::Debug for Stmt {\n \n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n-pub enum Stmt_ {\n+pub enum StmtKind {\n     /// Could be an item or a local (let) binding:\n-    StmtDecl(P<Decl>, NodeId),\n+    Decl(P<Decl>, NodeId),\n \n     /// Expr without trailing semi-colon (must have unit type):\n-    StmtExpr(P<Expr>, NodeId),\n+    Expr(P<Expr>, NodeId),\n \n     /// Expr with trailing semi-colon (may have any type):\n-    StmtSemi(P<Expr>, NodeId),\n+    Semi(P<Expr>, NodeId),\n \n-    StmtMac(P<Mac>, MacStmtStyle, ThinAttributes),\n+    Mac(P<Mac>, MacStmtStyle, ThinAttributes),\n }\n \n-impl Stmt_ {\n+impl StmtKind {\n     pub fn id(&self) -> Option<NodeId> {\n         match *self {\n-            StmtDecl(_, id) => Some(id),\n-            StmtExpr(_, id) => Some(id),\n-            StmtSemi(_, id) => Some(id),\n-            StmtMac(..) => None,\n+            StmtKind::Decl(_, id) => Some(id),\n+            StmtKind::Expr(_, id) => Some(id),\n+            StmtKind::Semi(_, id) => Some(id),\n+            StmtKind::Mac(..) => None,\n         }\n     }\n \n     pub fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            StmtDecl(ref d, _) => d.attrs(),\n-            StmtExpr(ref e, _) |\n-            StmtSemi(ref e, _) => e.attrs(),\n-            StmtMac(_, _, Some(ref b)) => b,\n-            StmtMac(_, _, None) => &[],\n+            StmtKind::Decl(ref d, _) => d.attrs(),\n+            StmtKind::Expr(ref e, _) |\n+            StmtKind::Semi(ref e, _) => e.attrs(),\n+            StmtKind::Mac(_, _, Some(ref b)) => b,\n+            StmtKind::Mac(_, _, None) => &[],\n         }\n     }\n }\n@@ -800,13 +776,13 @@ impl Stmt_ {\n pub enum MacStmtStyle {\n     /// The macro statement had a trailing semicolon, e.g. `foo! { ... };`\n     /// `foo!(...);`, `foo![...];`\n-    MacStmtWithSemicolon,\n+    Semicolon,\n     /// The macro statement had braces; e.g. foo! { ... }\n-    MacStmtWithBraces,\n+    Braces,\n     /// The macro statement had parentheses or brackets and no semicolon; e.g.\n     /// `foo!(...)`. All of these will end up being converted into macro\n     /// expressions.\n-    MacStmtWithoutBraces,\n+    NoBraces,\n }\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n@@ -832,21 +808,21 @@ impl Local {\n     }\n }\n \n-pub type Decl = Spanned<Decl_>;\n+pub type Decl = Spanned<DeclKind>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Decl_ {\n+pub enum DeclKind {\n     /// A local (let) binding:\n-    DeclLocal(P<Local>),\n+    Local(P<Local>),\n     /// An item binding:\n-    DeclItem(P<Item>),\n+    Item(P<Item>),\n }\n \n impl Decl {\n     pub fn attrs(&self) -> &[Attribute] {\n         match self.node {\n-            DeclLocal(ref l) => l.attrs(),\n-            DeclItem(ref i) => i.attrs(),\n+            DeclKind::Local(ref l) => l.attrs(),\n+            DeclKind::Item(ref i) => i.attrs(),\n         }\n     }\n }\n@@ -871,8 +847,8 @@ pub type SpannedIdent = Spanned<Ident>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BlockCheckMode {\n-    DefaultBlock,\n-    UnsafeBlock(UnsafeSource),\n+    Default,\n+    Unsafe(UnsafeSource),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -885,7 +861,7 @@ pub enum UnsafeSource {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash,)]\n pub struct Expr {\n     pub id: NodeId,\n-    pub node: Expr_,\n+    pub node: ExprKind,\n     pub span: Span,\n     pub attrs: ThinAttributes\n }\n@@ -906,18 +882,18 @@ impl fmt::Debug for Expr {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Expr_ {\n+pub enum ExprKind {\n     /// A `box x` expression.\n-    ExprBox(P<Expr>),\n+    Box(P<Expr>),\n     /// First expr is the place; second expr is the value.\n-    ExprInPlace(P<Expr>, P<Expr>),\n+    InPlace(P<Expr>, P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    ExprVec(Vec<P<Expr>>),\n+    Vec(Vec<P<Expr>>),\n     /// A function call\n     ///\n     /// The first field resolves to the function itself,\n     /// and the second field is the list of arguments\n-    ExprCall(P<Expr>, Vec<P<Expr>>),\n+    Call(P<Expr>, Vec<P<Expr>>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n     ///\n     /// The `SpannedIdent` is the identifier for the method name.\n@@ -929,109 +905,109 @@ pub enum Expr_ {\n     /// and the remaining elements are the rest of the arguments.\n     ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n-    /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n-    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n+    /// `ExprKind::MethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n+    MethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n     /// A tuple (`(a, b, c ,d)`)\n-    ExprTup(Vec<P<Expr>>),\n+    Tup(Vec<P<Expr>>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n-    ExprBinary(BinOp, P<Expr>, P<Expr>),\n+    Binary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n-    ExprUnary(UnOp, P<Expr>),\n+    Unary(UnOp, P<Expr>),\n     /// A literal (For example: `1u8`, `\"foo\"`)\n-    ExprLit(P<Lit>),\n+    Lit(P<Lit>),\n     /// A cast (`foo as f64`)\n-    ExprCast(P<Expr>, P<Ty>),\n-    ExprType(P<Expr>, P<Ty>),\n+    Cast(P<Expr>, P<Ty>),\n+    Type(P<Expr>, P<Ty>),\n     /// An `if` block, with an optional else block\n     ///\n     /// `if expr { block } else { expr }`\n-    ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n+    If(P<Expr>, P<Block>, Option<P<Expr>>),\n     /// An `if let` expression with an optional else block\n     ///\n     /// `if let pat = expr { block } else { expr }`\n     ///\n     /// This is desugared to a `match` expression.\n-    ExprIfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n+    IfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n+    While(P<Expr>, P<Block>, Option<Ident>),\n     /// A while-let loop, with an optional label\n     ///\n     /// `'label: while let pat = expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    ExprWhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n+    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     /// A for loop, with an optional label\n     ///\n     /// `'label: for pat in expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    ExprForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n+    ForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Ident>),\n+    Loop(P<Block>, Option<Ident>),\n     /// A `match` block.\n-    ExprMatch(P<Expr>, Vec<Arm>),\n+    Match(P<Expr>, Vec<Arm>),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`)\n-    ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n+    Closure(CaptureBy, P<FnDecl>, P<Block>),\n     /// A block (`{ ... }`)\n-    ExprBlock(P<Block>),\n+    Block(P<Block>),\n \n     /// An assignment (`a = foo()`)\n-    ExprAssign(P<Expr>, P<Expr>),\n+    Assign(P<Expr>, P<Expr>),\n     /// An assignment with an operator\n     ///\n     /// For example, `a += 1`.\n-    ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n+    AssignOp(BinOp, P<Expr>, P<Expr>),\n     /// Access of a named struct field (`obj.foo`)\n-    ExprField(P<Expr>, SpannedIdent),\n+    Field(P<Expr>, SpannedIdent),\n     /// Access of an unnamed field of a struct or tuple-struct\n     ///\n     /// For example, `foo.0`.\n-    ExprTupField(P<Expr>, Spanned<usize>),\n+    TupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n-    ExprIndex(P<Expr>, P<Expr>),\n+    Index(P<Expr>, P<Expr>),\n     /// A range (`1..2`, `1..`, or `..2`)\n-    ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n+    Range(Option<P<Expr>>, Option<P<Expr>>),\n \n     /// Variable reference, possibly containing `::` and/or type\n     /// parameters, e.g. foo::bar::<baz>.\n     ///\n     /// Optionally \"qualified\",\n     /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n-    ExprPath(Option<QSelf>, Path),\n+    Path(Option<QSelf>, Path),\n \n     /// A referencing operation (`&a` or `&mut a`)\n-    ExprAddrOf(Mutability, P<Expr>),\n+    AddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<SpannedIdent>),\n+    Break(Option<SpannedIdent>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<SpannedIdent>),\n+    Again(Option<SpannedIdent>),\n     /// A `return`, with an optional value to be returned\n-    ExprRet(Option<P<Expr>>),\n+    Ret(Option<P<Expr>>),\n \n     /// Output of the `asm!()` macro\n-    ExprInlineAsm(InlineAsm),\n+    InlineAsm(InlineAsm),\n \n     /// A macro invocation; pre-expansion\n-    ExprMac(Mac),\n+    Mac(Mac),\n \n     /// A struct literal expression.\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(Path, Vec<Field>, Option<P<Expr>>),\n+    Struct(Path, Vec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n     /// For example, `[1u8; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n-    ExprRepeat(P<Expr>, P<Expr>),\n+    Repeat(P<Expr>, P<Expr>),\n \n     /// No-op: used solely so we can pretty-print faithfully\n-    ExprParen(P<Expr>)\n+    Paren(P<Expr>),\n }\n \n /// The explicit Self type in a \"qualified path\". The actual\n@@ -1054,10 +1030,11 @@ pub struct QSelf {\n     pub position: usize\n }\n \n+/// A capture clause\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum CaptureClause {\n-    CaptureByValue,\n-    CaptureByRef,\n+pub enum CaptureBy {\n+    Value,\n+    Ref,\n }\n \n /// A delimited sequence of token trees\n@@ -1267,73 +1244,48 @@ pub struct Mac_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum StrStyle {\n     /// A regular string, like `\"foo\"`\n-    CookedStr,\n+    Cooked,\n     /// A raw string, like `r##\"foo\"##`\n     ///\n     /// The uint is the number of `#` symbols used\n-    RawStr(usize)\n+    Raw(usize)\n }\n \n /// A literal\n-pub type Lit = Spanned<Lit_>;\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum Sign {\n-    Minus,\n-    Plus\n-}\n-\n-impl Sign {\n-    pub fn new<T: IntSign>(n: T) -> Sign {\n-        n.sign()\n-    }\n-}\n-\n-pub trait IntSign {\n-    fn sign(&self) -> Sign;\n-}\n-macro_rules! doit {\n-    ($($t:ident)*) => ($(impl IntSign for $t {\n-        #[allow(unused_comparisons)]\n-        fn sign(&self) -> Sign {\n-            if *self < 0 {Minus} else {Plus}\n-        }\n-    })*)\n-}\n-doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+pub type Lit = Spanned<LitKind>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum LitIntType {\n-    SignedIntLit(IntTy, Sign),\n-    UnsignedIntLit(UintTy),\n-    UnsuffixedIntLit(Sign)\n+    Signed(IntTy),\n+    Unsigned(UintTy),\n+    Unsuffixed,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Lit_ {\n+pub enum LitKind {\n     /// A string literal (`\"foo\"`)\n-    LitStr(InternedString, StrStyle),\n+    Str(InternedString, StrStyle),\n     /// A byte string (`b\"foo\"`)\n-    LitByteStr(Rc<Vec<u8>>),\n+    ByteStr(Rc<Vec<u8>>),\n     /// A byte char (`b'f'`)\n-    LitByte(u8),\n+    Byte(u8),\n     /// A character literal (`'a'`)\n-    LitChar(char),\n+    Char(char),\n     /// An integer literal (`1u8`)\n-    LitInt(u64, LitIntType),\n+    Int(u64, LitIntType),\n     /// A float literal (`1f64` or `1E10f64`)\n-    LitFloat(InternedString, FloatTy),\n+    Float(InternedString, FloatTy),\n     /// A float literal without a suffix (`1.0 or 1.0E10`)\n-    LitFloatUnsuffixed(InternedString),\n+    FloatUnsuffixed(InternedString),\n     /// A boolean literal\n-    LitBool(bool),\n+    Bool(bool),\n }\n \n-impl Lit_ {\n+impl LitKind {\n     /// Returns true if this literal is a string and false otherwise.\n     pub fn is_str(&self) -> bool {\n         match *self {\n-            LitStr(..) => true,\n+            LitKind::Str(..) => true,\n             _ => false,\n         }\n     }\n@@ -1368,15 +1320,15 @@ pub struct TraitItem {\n     pub id: NodeId,\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n-    pub node: TraitItem_,\n+    pub node: TraitItemKind,\n     pub span: Span,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum TraitItem_ {\n-    ConstTraitItem(P<Ty>, Option<P<Expr>>),\n-    MethodTraitItem(MethodSig, Option<P<Block>>),\n-    TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n+pub enum TraitItemKind {\n+    Const(P<Ty>, Option<P<Expr>>),\n+    Method(MethodSig, Option<P<Block>>),\n+    Type(TyParamBounds, Option<P<Ty>>),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1399,11 +1351,11 @@ pub enum ImplItemKind {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub enum IntTy {\n-    TyIs,\n-    TyI8,\n-    TyI16,\n-    TyI32,\n-    TyI64,\n+    Is,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n }\n \n impl fmt::Debug for IntTy {\n@@ -1421,11 +1373,11 @@ impl fmt::Display for IntTy {\n impl IntTy {\n     pub fn ty_to_string(&self) -> &'static str {\n         match *self {\n-            TyIs => \"isize\",\n-            TyI8 => \"i8\",\n-            TyI16 => \"i16\",\n-            TyI32 => \"i32\",\n-            TyI64 => \"i64\"\n+            IntTy::Is => \"isize\",\n+            IntTy::I8 => \"i8\",\n+            IntTy::I16 => \"i16\",\n+            IntTy::I32 => \"i32\",\n+            IntTy::I64 => \"i64\"\n         }\n     }\n \n@@ -1438,41 +1390,41 @@ impl IntTy {\n \n     pub fn ty_max(&self) -> u64 {\n         match *self {\n-            TyI8 => 0x80,\n-            TyI16 => 0x8000,\n-            TyIs | TyI32 => 0x80000000, // actually ni about TyIs\n-            TyI64 => 0x8000000000000000\n+            IntTy::I8 => 0x80,\n+            IntTy::I16 => 0x8000,\n+            IntTy::Is | IntTy::I32 => 0x80000000, // FIXME: actually ni about Is\n+            IntTy::I64 => 0x8000000000000000\n         }\n     }\n \n     pub fn bit_width(&self) -> Option<usize> {\n         Some(match *self {\n-            TyIs => return None,\n-            TyI8 => 8,\n-            TyI16 => 16,\n-            TyI32 => 32,\n-            TyI64 => 64,\n+            IntTy::Is => return None,\n+            IntTy::I8 => 8,\n+            IntTy::I16 => 16,\n+            IntTy::I32 => 32,\n+            IntTy::I64 => 64,\n         })\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub enum UintTy {\n-    TyUs,\n-    TyU8,\n-    TyU16,\n-    TyU32,\n-    TyU64,\n+    Us,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n }\n \n impl UintTy {\n     pub fn ty_to_string(&self) -> &'static str {\n         match *self {\n-            TyUs => \"usize\",\n-            TyU8 => \"u8\",\n-            TyU16 => \"u16\",\n-            TyU32 => \"u32\",\n-            TyU64 => \"u64\"\n+            UintTy::Us => \"usize\",\n+            UintTy::U8 => \"u8\",\n+            UintTy::U16 => \"u16\",\n+            UintTy::U32 => \"u32\",\n+            UintTy::U64 => \"u64\"\n         }\n     }\n \n@@ -1482,20 +1434,20 @@ impl UintTy {\n \n     pub fn ty_max(&self) -> u64 {\n         match *self {\n-            TyU8 => 0xff,\n-            TyU16 => 0xffff,\n-            TyUs | TyU32 => 0xffffffff, // actually ni about TyUs\n-            TyU64 => 0xffffffffffffffff\n+            UintTy::U8 => 0xff,\n+            UintTy::U16 => 0xffff,\n+            UintTy::Us | UintTy::U32 => 0xffffffff, // FIXME: actually ni about Us\n+            UintTy::U64 => 0xffffffffffffffff\n         }\n     }\n \n     pub fn bit_width(&self) -> Option<usize> {\n         Some(match *self {\n-            TyUs => return None,\n-            TyU8 => 8,\n-            TyU16 => 16,\n-            TyU32 => 32,\n-            TyU64 => 64,\n+            UintTy::Us => return None,\n+            UintTy::U8 => 8,\n+            UintTy::U16 => 16,\n+            UintTy::U32 => 32,\n+            UintTy::U64 => 64,\n         })\n     }\n }\n@@ -1514,8 +1466,8 @@ impl fmt::Display for UintTy {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub enum FloatTy {\n-    TyF32,\n-    TyF64,\n+    F32,\n+    F64,\n }\n \n impl fmt::Debug for FloatTy {\n@@ -1533,15 +1485,15 @@ impl fmt::Display for FloatTy {\n impl FloatTy {\n     pub fn ty_to_string(&self) -> &'static str {\n         match *self {\n-            TyF32 => \"f32\",\n-            TyF64 => \"f64\",\n+            FloatTy::F32 => \"f32\",\n+            FloatTy::F64 => \"f64\",\n         }\n     }\n \n     pub fn bit_width(&self) -> usize {\n         match *self {\n-            TyF32 => 32,\n-            TyF64 => 64,\n+            FloatTy::F32 => 32,\n+            FloatTy::F64 => 64,\n         }\n     }\n }\n@@ -1558,7 +1510,7 @@ pub struct TypeBinding {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Ty {\n     pub id: NodeId,\n-    pub node: Ty_,\n+    pub node: TyKind,\n     pub span: Span,\n }\n \n@@ -1568,17 +1520,6 @@ impl fmt::Debug for Ty {\n     }\n }\n \n-/// Not represented directly in the AST, referred to by name through a ty_path.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum PrimTy {\n-    TyInt(IntTy),\n-    TyUint(UintTy),\n-    TyFloat(FloatTy),\n-    TyStr,\n-    TyBool,\n-    TyChar\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n@@ -1589,36 +1530,36 @@ pub struct BareFnTy {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n /// The different kinds of types recognized by the compiler\n-pub enum Ty_ {\n-    TyVec(P<Ty>),\n+pub enum TyKind {\n+    Vec(P<Ty>),\n     /// A fixed length array (`[T; n]`)\n-    TyFixedLengthVec(P<Ty>, P<Expr>),\n+    FixedLengthVec(P<Ty>, P<Expr>),\n     /// A raw pointer (`*const T` or `*mut T`)\n-    TyPtr(MutTy),\n+    Ptr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n-    TyRptr(Option<Lifetime>, MutTy),\n+    Rptr(Option<Lifetime>, MutTy),\n     /// A bare function (e.g. `fn(usize) -> bool`)\n-    TyBareFn(P<BareFnTy>),\n+    BareFn(P<BareFnTy>),\n     /// A tuple (`(A, B, C, D,...)`)\n-    TyTup(Vec<P<Ty>> ),\n+    Tup(Vec<P<Ty>> ),\n     /// A path (`module::module::...::Type`), optionally\n     /// \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`.\n     ///\n     /// Type parameters are stored in the Path itself\n-    TyPath(Option<QSelf>, Path),\n+    Path(Option<QSelf>, Path),\n     /// Something like `A+B`. Note that `B` must always be a path.\n-    TyObjectSum(P<Ty>, TyParamBounds),\n+    ObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`\n-    TyPolyTraitRef(TyParamBounds),\n+    PolyTraitRef(TyParamBounds),\n     /// No-op; kept solely so that we can pretty-print faithfully\n-    TyParen(P<Ty>),\n+    Paren(P<Ty>),\n     /// Unused for now\n-    TyTypeof(P<Expr>),\n-    /// TyInfer means the type should be inferred instead of it having been\n+    Typeof(P<Expr>),\n+    /// TyKind::Infer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n-    TyInfer,\n+    Infer,\n     // A macro in the type position.\n-    TyMac(Mac)\n+    Mac(Mac),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1663,7 +1604,7 @@ impl Arg {\n             // HACK(eddyb) fake type for the self argument.\n             ty: P(Ty {\n                 id: DUMMY_NODE_ID,\n-                node: TyInfer,\n+                node: TyKind::Infer,\n                 span: DUMMY_SP,\n             }),\n             pat: P(Pat {\n@@ -1727,41 +1668,41 @@ impl fmt::Debug for ImplPolarity {\n pub enum FunctionRetTy {\n     /// Functions with return type `!`that always\n     /// raise an error or exit (i.e. never return to the caller)\n-    NoReturn(Span),\n+    None(Span),\n     /// Return type is not specified.\n     ///\n     /// Functions default to `()` and\n     /// closures default to inference. Span points to where return\n     /// type would be inserted.\n-    DefaultReturn(Span),\n+    Default(Span),\n     /// Everything else\n-    Return(P<Ty>),\n+    Ty(P<Ty>),\n }\n \n impl FunctionRetTy {\n     pub fn span(&self) -> Span {\n         match *self {\n-            NoReturn(span) => span,\n-            DefaultReturn(span) => span,\n-            Return(ref ty) => ty.span\n+            FunctionRetTy::None(span) => span,\n+            FunctionRetTy::Default(span) => span,\n+            FunctionRetTy::Ty(ref ty) => ty.span,\n         }\n     }\n }\n \n /// Represents the kind of 'self' associated with a method\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum ExplicitSelf_ {\n+pub enum SelfKind {\n     /// No self\n-    SelfStatic,\n+    Static,\n     /// `self`\n-    SelfValue(Ident),\n+    Value(Ident),\n     /// `&'lt self`, `&'lt mut self`\n-    SelfRegion(Option<Lifetime>, Mutability, Ident),\n+    Region(Option<Lifetime>, Mutability, Ident),\n     /// `self: TYPE`\n-    SelfExplicit(P<Ty>, Ident),\n+    Explicit(P<Ty>, Ident),\n }\n \n-pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n+pub type ExplicitSelf = Spanned<SelfKind>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mod {\n@@ -1795,42 +1736,42 @@ pub struct Variant_ {\n pub type Variant = Spanned<Variant_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum PathListItem_ {\n-    PathListIdent {\n+pub enum PathListItemKind {\n+    Ident {\n         name: Ident,\n         /// renamed in list, eg `use foo::{bar as baz};`\n         rename: Option<Ident>,\n         id: NodeId\n     },\n-    PathListMod {\n+    Mod {\n         /// renamed in list, eg `use foo::{self as baz};`\n         rename: Option<Ident>,\n         id: NodeId\n     }\n }\n \n-impl PathListItem_ {\n+impl PathListItemKind {\n     pub fn id(&self) -> NodeId {\n         match *self {\n-            PathListIdent { id, .. } | PathListMod { id, .. } => id\n+            PathListItemKind::Ident { id, .. } | PathListItemKind::Mod { id, .. } => id\n         }\n     }\n \n     pub fn name(&self) -> Option<Ident> {\n         match *self {\n-            PathListIdent { name, .. } => Some(name),\n-            PathListMod { .. } => None,\n+            PathListItemKind::Ident { name, .. } => Some(name),\n+            PathListItemKind::Mod { .. } => None,\n         }\n     }\n \n     pub fn rename(&self) -> Option<Ident> {\n         match *self {\n-            PathListIdent { rename, .. } | PathListMod { rename, .. } => rename\n+            PathListItemKind::Ident { rename, .. } | PathListItemKind::Mod { rename, .. } => rename\n         }\n     }\n }\n \n-pub type PathListItem = Spanned<PathListItem_>;\n+pub type PathListItem = Spanned<PathListItemKind>;\n \n pub type ViewPath = Spanned<ViewPath_>;\n \n@@ -1879,7 +1820,7 @@ pub struct Attribute_ {\n ///\n /// resolve maps each TraitRef's ref_id to its defining trait; that's all\n /// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n-/// If this impl is an ItemImpl, the impl_id is redundant (it could be the\n+/// If this impl is an ItemKind::Impl, the impl_id is redundant (it could be the\n /// same as the impl's node id).\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitRef {\n@@ -1907,8 +1848,8 @@ pub enum Visibility {\n impl Visibility {\n     pub fn inherit_from(&self, parent_visibility: Visibility) -> Visibility {\n         match *self {\n-            Inherited => parent_visibility,\n-            Public => *self\n+            Visibility::Inherited => parent_visibility,\n+            Visibility::Public => *self\n         }\n     }\n }\n@@ -2007,7 +1948,7 @@ pub struct Item {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n-    pub node: Item_,\n+    pub node: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n }\n@@ -2019,68 +1960,68 @@ impl Item {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Item_ {\n+pub enum ItemKind {\n     /// An`extern crate` item, with optional original crate name,\n     ///\n     /// e.g. `extern crate foo` or `extern crate foo_bar as foo`\n-    ItemExternCrate(Option<Name>),\n+    ExternCrate(Option<Name>),\n     /// A `use` or `pub use` item\n-    ItemUse(P<ViewPath>),\n+    Use(P<ViewPath>),\n \n     /// A `static` item\n-    ItemStatic(P<Ty>, Mutability, P<Expr>),\n+    Static(P<Ty>, Mutability, P<Expr>),\n     /// A `const` item\n-    ItemConst(P<Ty>, P<Expr>),\n+    Const(P<Ty>, P<Expr>),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Block>),\n+    Fn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Block>),\n     /// A module\n-    ItemMod(Mod),\n+    Mod(Mod),\n     /// An external module\n-    ItemForeignMod(ForeignMod),\n+    ForeignMod(ForeignMod),\n     /// A type alias, e.g. `type Foo = Bar<u8>`\n-    ItemTy(P<Ty>, Generics),\n+    Ty(P<Ty>, Generics),\n     /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n-    ItemEnum(EnumDef, Generics),\n+    Enum(EnumDef, Generics),\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n-    ItemStruct(VariantData, Generics),\n+    Struct(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    ItemTrait(Unsafety,\n+    Trait(Unsafety,\n               Generics,\n               TyParamBounds,\n               Vec<P<TraitItem>>),\n \n     // Default trait implementations\n     ///\n     // `impl Trait for .. {}`\n-    ItemDefaultImpl(Unsafety, TraitRef),\n+    DefaultImpl(Unsafety, TraitRef),\n     /// An implementation, eg `impl<A> Trait for Foo { .. }`\n-    ItemImpl(Unsafety,\n+    Impl(Unsafety,\n              ImplPolarity,\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n              Vec<P<ImplItem>>),\n     /// A macro invocation (which includes macro definition)\n-    ItemMac(Mac),\n+    Mac(Mac),\n }\n \n-impl Item_ {\n+impl ItemKind {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n-            ItemExternCrate(..) => \"extern crate\",\n-            ItemUse(..) => \"use\",\n-            ItemStatic(..) => \"static item\",\n-            ItemConst(..) => \"constant item\",\n-            ItemFn(..) => \"function\",\n-            ItemMod(..) => \"module\",\n-            ItemForeignMod(..) => \"foreign module\",\n-            ItemTy(..) => \"type alias\",\n-            ItemEnum(..) => \"enum\",\n-            ItemStruct(..) => \"struct\",\n-            ItemTrait(..) => \"trait\",\n-            ItemMac(..) |\n-            ItemImpl(..) |\n-            ItemDefaultImpl(..) => \"item\"\n+            ItemKind::ExternCrate(..) => \"extern crate\",\n+            ItemKind::Use(..) => \"use\",\n+            ItemKind::Static(..) => \"static item\",\n+            ItemKind::Const(..) => \"constant item\",\n+            ItemKind::Fn(..) => \"function\",\n+            ItemKind::Mod(..) => \"module\",\n+            ItemKind::ForeignMod(..) => \"foreign module\",\n+            ItemKind::Ty(..) => \"type alias\",\n+            ItemKind::Enum(..) => \"enum\",\n+            ItemKind::Struct(..) => \"struct\",\n+            ItemKind::Trait(..) => \"trait\",\n+            ItemKind::Mac(..) |\n+            ItemKind::Impl(..) |\n+            ItemKind::DefaultImpl(..) => \"item\"\n         }\n     }\n }\n@@ -2089,27 +2030,27 @@ impl Item_ {\n pub struct ForeignItem {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n-    pub node: ForeignItem_,\n+    pub node: ForeignItemKind,\n     pub id: NodeId,\n     pub span: Span,\n     pub vis: Visibility,\n }\n \n /// An item within an `extern` block\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum ForeignItem_ {\n+pub enum ForeignItemKind {\n     /// A foreign function\n-    ForeignItemFn(P<FnDecl>, Generics),\n+    Fn(P<FnDecl>, Generics),\n     /// A foreign static item (`static ext: u8`), with optional mutability\n     /// (the boolean is true when mutable)\n-    ForeignItemStatic(P<Ty>, bool),\n+    Static(P<Ty>, bool),\n }\n \n-impl ForeignItem_ {\n+impl ForeignItemKind {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n-            ForeignItemFn(..) => \"foreign function\",\n-            ForeignItemStatic(..) => \"foreign static item\"\n+            ForeignItemKind::Fn(..) => \"foreign function\",\n+            ForeignItemKind::Static(..) => \"foreign static item\"\n         }\n     }\n }"}, {"sha": "e22cdab97e8ed5ac119d2f8413ed049c2af673c9", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -27,7 +27,7 @@ pub fn path_name_i(idents: &[Ident]) -> String {\n }\n \n pub fn is_path(e: P<Expr>) -> bool {\n-    match e.node { ExprPath(..) => true, _ => false }\n+    match e.node { ExprKind::Path(..) => true, _ => false }\n }\n \n \n@@ -66,9 +66,10 @@ pub fn path_to_ident(path: &Path) -> Option<Ident> {\n }\n \n pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> P<Pat> {\n+    let spanned = codemap::Spanned{ span: s, node: i };\n     P(Pat {\n         id: id,\n-        node: PatIdent(BindingMode::ByValue(MutImmutable), codemap::Spanned{span:s, node:i}, None),\n+        node: PatIdent(BindingMode::ByValue(Mutability::Immutable), spanned, None),\n         span: s\n     })\n }\n@@ -173,7 +174,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n \n         self.operation.visit_id(item.id);\n         match item.node {\n-            ItemUse(ref view_path) => {\n+            ItemKind::Use(ref view_path) => {\n                 match view_path.node {\n                     ViewPathSimple(_, _) |\n                     ViewPathGlob(_) => {}"}, {"sha": "cc5f30e21849fd48c929bca10167abfc46abd907", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -15,8 +15,8 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n-use ast::{Stmt, StmtDecl, StmtExpr, StmtMac, StmtSemi, DeclItem, DeclLocal};\n+use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaItemKind};\n+use ast::{Stmt, StmtKind, DeclKind};\n use ast::{Expr, Item, Local, Decl};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n@@ -66,7 +66,7 @@ pub trait AttrMetaMethods {\n     /// `#[foo=\"bar\"]` and `#[foo(bar)]`\n     fn name(&self) -> InternedString;\n \n-    /// Gets the string value if self is a MetaNameValue variant\n+    /// Gets the string value if self is a MetaItemKind::NameValue variant\n     /// containing a string, otherwise None.\n     fn value_str(&self) -> Option<InternedString>;\n     /// Gets a list of inner meta items from a list MetaItem type.\n@@ -96,17 +96,17 @@ impl AttrMetaMethods for Attribute {\n impl AttrMetaMethods for MetaItem {\n     fn name(&self) -> InternedString {\n         match self.node {\n-            MetaWord(ref n) => (*n).clone(),\n-            MetaNameValue(ref n, _) => (*n).clone(),\n-            MetaList(ref n, _) => (*n).clone(),\n+            MetaItemKind::Word(ref n) => (*n).clone(),\n+            MetaItemKind::NameValue(ref n, _) => (*n).clone(),\n+            MetaItemKind::List(ref n, _) => (*n).clone(),\n         }\n     }\n \n     fn value_str(&self) -> Option<InternedString> {\n         match self.node {\n-            MetaNameValue(_, ref v) => {\n+            MetaItemKind::NameValue(_, ref v) => {\n                 match v.node {\n-                    ast::LitStr(ref s, _) => Some((*s).clone()),\n+                    ast::LitKind::Str(ref s, _) => Some((*s).clone()),\n                     _ => None,\n                 }\n             },\n@@ -116,7 +116,7 @@ impl AttrMetaMethods for MetaItem {\n \n     fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n         match self.node {\n-            MetaList(_, ref l) => Some(&l[..]),\n+            MetaItemKind::List(_, ref l) => Some(&l[..]),\n             _ => None\n         }\n     }\n@@ -173,21 +173,21 @@ impl AttributeMethods for Attribute {\n \n pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n                               -> P<MetaItem> {\n-    let value_lit = dummy_spanned(ast::LitStr(value, ast::CookedStr));\n+    let value_lit = dummy_spanned(ast::LitKind::Str(value, ast::StrStyle::Cooked));\n     mk_name_value_item(name, value_lit)\n }\n \n pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n                           -> P<MetaItem> {\n-    P(dummy_spanned(MetaNameValue(name, value)))\n+    P(dummy_spanned(MetaItemKind::NameValue(name, value)))\n }\n \n pub fn mk_list_item(name: InternedString, items: Vec<P<MetaItem>>) -> P<MetaItem> {\n-    P(dummy_spanned(MetaList(name, items)))\n+    P(dummy_spanned(MetaItemKind::List(name, items)))\n }\n \n pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n-    P(dummy_spanned(MetaWord(name)))\n+    P(dummy_spanned(MetaItemKind::Word(name)))\n }\n \n thread_local! { static NEXT_ATTR_ID: Cell<usize> = Cell::new(0) }\n@@ -225,12 +225,11 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n                            hi: BytePos)\n                            -> Attribute {\n     let style = doc_comment_style(&text);\n-    let lit = spanned(lo, hi, ast::LitStr(text, ast::CookedStr));\n+    let lit = spanned(lo, hi, ast::LitKind::Str(text, ast::StrStyle::Cooked));\n     let attr = Attribute_ {\n         id: id,\n         style: style,\n-        value: P(spanned(lo, hi, MetaNameValue(InternedString::new(\"doc\"),\n-                                               lit))),\n+        value: P(spanned(lo, hi, MetaItemKind::NameValue(InternedString::new(\"doc\"), lit))),\n         is_sugared_doc: true\n     };\n     spanned(lo, hi, attr)\n@@ -286,7 +285,7 @@ pub fn sort_meta_items(items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n     v.into_iter().map(|(_, m)| m.map(|Spanned {node, span}| {\n         Spanned {\n             node: match node {\n-                MetaList(n, mis) => MetaList(n, sort_meta_items(mis)),\n+                MetaItemKind::List(n, mis) => MetaItemKind::List(n, sort_meta_items(mis)),\n                 _ => node\n             },\n             span: span\n@@ -329,11 +328,11 @@ pub enum InlineAttr {\n pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n     attrs.iter().fold(InlineAttr::None, |ia,attr| {\n         match attr.node.value.node {\n-            MetaWord(ref n) if *n == \"inline\" => {\n+            MetaItemKind::Word(ref n) if *n == \"inline\" => {\n                 mark_used(attr);\n                 InlineAttr::Hint\n             }\n-            MetaList(ref n, ref items) if *n == \"inline\" => {\n+            MetaItemKind::List(ref n, ref items) if *n == \"inline\" => {\n                 mark_used(attr);\n                 if items.len() != 1 {\n                     diagnostic.map(|d|{ d.span_err(attr.span, \"expected one argument\"); });\n@@ -365,11 +364,11 @@ pub fn cfg_matches<T: CfgDiag>(cfgs: &[P<MetaItem>],\n                            cfg: &ast::MetaItem,\n                            diag: &mut T) -> bool {\n     match cfg.node {\n-        ast::MetaList(ref pred, ref mis) if &pred[..] == \"any\" =>\n+        ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"any\" =>\n             mis.iter().any(|mi| cfg_matches(cfgs, &**mi, diag)),\n-        ast::MetaList(ref pred, ref mis) if &pred[..] == \"all\" =>\n+        ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"all\" =>\n             mis.iter().all(|mi| cfg_matches(cfgs, &**mi, diag)),\n-        ast::MetaList(ref pred, ref mis) if &pred[..] == \"not\" => {\n+        ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n                 diag.emit_error(|diagnostic| {\n                     diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n@@ -378,14 +377,14 @@ pub fn cfg_matches<T: CfgDiag>(cfgs: &[P<MetaItem>],\n             }\n             !cfg_matches(cfgs, &*mis[0], diag)\n         }\n-        ast::MetaList(ref pred, _) => {\n+        ast::MetaItemKind::List(ref pred, _) => {\n             diag.emit_error(|diagnostic| {\n                 diagnostic.span_err(cfg.span,\n                     &format!(\"invalid predicate `{}`\", pred));\n             });\n             false\n         },\n-        ast::MetaWord(_) | ast::MetaNameValue(..) => {\n+        ast::MetaItemKind::Word(_) | ast::MetaItemKind::NameValue(..) => {\n             diag.flag_gated(|feature_gated_cfgs| {\n                 feature_gated_cfgs.extend(\n                     GatedCfg::gate(cfg).map(GatedCfgAttr::GatedCfg));\n@@ -707,11 +706,11 @@ pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n     match attr.node.value.node {\n-        ast::MetaList(ref s, ref items) if *s == \"repr\" => {\n+        ast::MetaItemKind::List(ref s, ref items) if *s == \"repr\" => {\n             mark_used(attr);\n             for item in items {\n                 match item.node {\n-                    ast::MetaWord(ref word) => {\n+                    ast::MetaItemKind::Word(ref word) => {\n                         let hint = match &word[..] {\n                             // Can't use \"extern\" because it's not a lexical identifier.\n                             \"C\" => Some(ReprExtern),\n@@ -746,16 +745,16 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n \n fn int_type_of_word(s: &str) -> Option<IntType> {\n     match s {\n-        \"i8\" => Some(SignedInt(ast::TyI8)),\n-        \"u8\" => Some(UnsignedInt(ast::TyU8)),\n-        \"i16\" => Some(SignedInt(ast::TyI16)),\n-        \"u16\" => Some(UnsignedInt(ast::TyU16)),\n-        \"i32\" => Some(SignedInt(ast::TyI32)),\n-        \"u32\" => Some(UnsignedInt(ast::TyU32)),\n-        \"i64\" => Some(SignedInt(ast::TyI64)),\n-        \"u64\" => Some(UnsignedInt(ast::TyU64)),\n-        \"isize\" => Some(SignedInt(ast::TyIs)),\n-        \"usize\" => Some(UnsignedInt(ast::TyUs)),\n+        \"i8\" => Some(SignedInt(ast::IntTy::I8)),\n+        \"u8\" => Some(UnsignedInt(ast::UintTy::U8)),\n+        \"i16\" => Some(SignedInt(ast::IntTy::I16)),\n+        \"u16\" => Some(UnsignedInt(ast::UintTy::U16)),\n+        \"i32\" => Some(SignedInt(ast::IntTy::I32)),\n+        \"u32\" => Some(UnsignedInt(ast::UintTy::U32)),\n+        \"i64\" => Some(SignedInt(ast::IntTy::I64)),\n+        \"u64\" => Some(UnsignedInt(ast::UintTy::U64)),\n+        \"isize\" => Some(SignedInt(ast::IntTy::Is)),\n+        \"usize\" => Some(UnsignedInt(ast::UintTy::Us)),\n         _ => None\n     }\n }\n@@ -797,11 +796,11 @@ impl IntType {\n     }\n     fn is_ffi_safe(self) -> bool {\n         match self {\n-            SignedInt(ast::TyI8) | UnsignedInt(ast::TyU8) |\n-            SignedInt(ast::TyI16) | UnsignedInt(ast::TyU16) |\n-            SignedInt(ast::TyI32) | UnsignedInt(ast::TyU32) |\n-            SignedInt(ast::TyI64) | UnsignedInt(ast::TyU64) => true,\n-            SignedInt(ast::TyIs) | UnsignedInt(ast::TyUs) => false\n+            SignedInt(ast::IntTy::I8) | UnsignedInt(ast::UintTy::U8) |\n+            SignedInt(ast::IntTy::I16) | UnsignedInt(ast::UintTy::U16) |\n+            SignedInt(ast::IntTy::I32) | UnsignedInt(ast::UintTy::U32) |\n+            SignedInt(ast::IntTy::I64) | UnsignedInt(ast::UintTy::U64) => true,\n+            SignedInt(ast::IntTy::Is) | UnsignedInt(ast::UintTy::Us) => false\n         }\n     }\n }\n@@ -933,8 +932,8 @@ impl WithAttrs for P<Decl> {\n             Spanned {\n                 span: span,\n                 node: match node {\n-                    DeclLocal(local) => DeclLocal(local.with_attrs(attrs)),\n-                    DeclItem(item) => DeclItem(item.with_attrs(attrs)),\n+                    DeclKind::Local(local) => DeclKind::Local(local.with_attrs(attrs)),\n+                    DeclKind::Item(item) => DeclKind::Item(item.with_attrs(attrs)),\n                 }\n             }\n         })\n@@ -947,12 +946,12 @@ impl WithAttrs for P<Stmt> {\n             Spanned {\n                 span: span,\n                 node: match node {\n-                    StmtDecl(decl, id) => StmtDecl(decl.with_attrs(attrs), id),\n-                    StmtExpr(expr, id) => StmtExpr(expr.with_attrs(attrs), id),\n-                    StmtSemi(expr, id) => StmtSemi(expr.with_attrs(attrs), id),\n-                    StmtMac(mac, style, mut ats) => {\n+                    StmtKind::Decl(decl, id) => StmtKind::Decl(decl.with_attrs(attrs), id),\n+                    StmtKind::Expr(expr, id) => StmtKind::Expr(expr.with_attrs(attrs), id),\n+                    StmtKind::Semi(expr, id) => StmtKind::Semi(expr.with_attrs(attrs), id),\n+                    StmtKind::Mac(mac, style, mut ats) => {\n                         ats.update(|a| a.append(attrs));\n-                        StmtMac(mac, style, ats)\n+                        StmtKind::Mac(mac, style, ats)\n                     }\n                 },\n             }"}, {"sha": "09408f68dfd039924d01f234bceeb7d98d98547f", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -52,8 +52,8 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         fold_foreign_mod(self, foreign_mod)\n     }\n-    fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n-        fold_item_underscore(self, item)\n+    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        fold_item_kind(self, item)\n     }\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         // If an expr is valid to cfg away it will have been removed by the\n@@ -129,26 +129,26 @@ fn fold_item<F>(cx: &mut Context<F>, item: P<ast::Item>) -> SmallVector<P<ast::I\n     }\n }\n \n-fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_ where\n+fn fold_item_kind<F>(cx: &mut Context<F>, item: ast::ItemKind) -> ast::ItemKind where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     let item = match item {\n-        ast::ItemImpl(u, o, a, b, c, impl_items) => {\n+        ast::ItemKind::Impl(u, o, a, b, c, impl_items) => {\n             let impl_items = impl_items.into_iter()\n                                        .filter(|ii| (cx.in_cfg)(&ii.attrs))\n                                        .collect();\n-            ast::ItemImpl(u, o, a, b, c, impl_items)\n+            ast::ItemKind::Impl(u, o, a, b, c, impl_items)\n         }\n-        ast::ItemTrait(u, a, b, methods) => {\n+        ast::ItemKind::Trait(u, a, b, methods) => {\n             let methods = methods.into_iter()\n                                  .filter(|ti| (cx.in_cfg)(&ti.attrs))\n                                  .collect();\n-            ast::ItemTrait(u, a, b, methods)\n+            ast::ItemKind::Trait(u, a, b, methods)\n         }\n-        ast::ItemStruct(def, generics) => {\n-            ast::ItemStruct(fold_struct(cx, def), generics)\n+        ast::ItemKind::Struct(def, generics) => {\n+            ast::ItemKind::Struct(fold_struct(cx, def), generics)\n         }\n-        ast::ItemEnum(def, generics) => {\n+        ast::ItemKind::Enum(def, generics) => {\n             let variants = def.variants.into_iter().filter_map(|v| {\n                 if !(cx.in_cfg)(&v.node.attrs) {\n                     None\n@@ -167,14 +167,14 @@ fn fold_item_underscore<F>(cx: &mut Context<F>, item: ast::Item_) -> ast::Item_\n                     }))\n                 }\n             });\n-            ast::ItemEnum(ast::EnumDef {\n+            ast::ItemKind::Enum(ast::EnumDef {\n                 variants: variants.collect(),\n             }, generics)\n         }\n         item => item,\n     };\n \n-    fold::noop_fold_item_underscore(item, cx)\n+    fold::noop_fold_item_kind(item, cx)\n }\n \n fn fold_struct<F>(cx: &mut Context<F>, vdata: ast::VariantData) -> ast::VariantData where\n@@ -212,8 +212,8 @@ fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n         fold::noop_fold_expr(ast::Expr {\n             id: id,\n             node: match node {\n-                ast::ExprMatch(m, arms) => {\n-                    ast::ExprMatch(m, arms.into_iter()\n+                ast::ExprKind::Match(m, arms) => {\n+                    ast::ExprKind::Match(m, arms.into_iter()\n                                         .filter(|a| (cx.in_cfg)(&a.attrs))\n                                         .collect())\n                 }\n@@ -270,7 +270,7 @@ fn in_cfg<T: CfgDiag>(cfg: &[P<ast::MetaItem>],\n                       diag: &mut T) -> bool {\n     attrs.iter().all(|attr| {\n         let mis = match attr.node.value.node {\n-            ast::MetaList(_, ref mis) if is_cfg(&attr) => mis,\n+            ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n             _ => return true\n         };\n \n@@ -372,8 +372,8 @@ impl<'v, 'a, 'b> visit::Visitor<'v> for StmtExprAttrFeatureVisitor<'a, 'b> {\n         let stmt_attrs = s.node.attrs();\n         if stmt_attrs.len() > 0 {\n             // attributes on items are fine\n-            if let ast::StmtDecl(ref decl, _) = s.node {\n-                if let ast::DeclItem(_) = decl.node {\n+            if let ast::StmtKind::Decl(ref decl, _) = s.node {\n+                if let ast::DeclKind::Item(_) = decl.node {\n                     visit::walk_stmt(self, s);\n                     return;\n                 }"}, {"sha": "43b4a201afc184fb3c401d35513e5dab137cdc9c", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -207,15 +207,15 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n         span,\n         ecx.ty_ident(span, ecx.ident_of(\"str\")),\n         Some(static_),\n-        ast::MutImmutable,\n+        ast::Mutability::Immutable,\n     );\n \n     let ty = ecx.ty(\n         span,\n-        ast::TyFixedLengthVec(\n+        ast::TyKind::FixedLengthVec(\n             ecx.ty(\n                 span,\n-                ast::TyTup(vec![ty_str.clone(), ty_str])\n+                ast::TyKind::Tup(vec![ty_str.clone(), ty_str])\n             ),\n             ecx.expr_usize(span, count),\n         ),\n@@ -226,11 +226,11 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n             ident: name.clone(),\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ItemConst(\n+            node: ast::ItemKind::Const(\n                 ty,\n                 expr,\n             ),\n-            vis: ast::Public,\n+            vis: ast::Visibility::Public,\n             span: span,\n         })\n     ]))"}, {"sha": "7014e576e2b8a36e2390e3da39262d03bf8c30a1", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use attr;\n-use ast::{Item, ItemFn};\n+use ast::{Item, ItemKind};\n \n pub enum EntryPointType {\n     None,\n@@ -23,7 +23,7 @@ pub enum EntryPointType {\n // them in sync.\n pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n     match item.node {\n-        ItemFn(..) => {\n+        ItemKind::Fn(..) => {\n             if attr::contains_name(&item.attrs, \"start\") {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {"}, {"sha": "381d952ea887499824193c4938ed8426400abed1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -120,7 +120,7 @@ impl<F> MultiItemDecorator for F\n     }\n }\n \n-// A more flexible ItemModifier (ItemModifier should go away, eventually, FIXME).\n+// A more flexible ItemKind::Modifier (ItemKind::Modifier should go away, eventually, FIXME).\n // meta_item is the annotation, item is the item being modified, parent_item\n // is the impl or trait item is declared in if item is part of such a thing.\n // FIXME Decorators should follow the same pattern too.\n@@ -205,7 +205,7 @@ macro_rules! make_stmts_default {\n     ($me:expr) => {\n         $me.make_expr().map(|e| {\n             SmallVector::one(P(codemap::respan(\n-                e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID))))\n+                e.span, ast::StmtKind::Expr(e, ast::DUMMY_NODE_ID))))\n         })\n     }\n }\n@@ -303,7 +303,7 @@ impl MacResult for MacEager {\n             return Some(p);\n         }\n         if let Some(e) = self.expr {\n-            if let ast::ExprLit(_) = e.node {\n+            if let ast::ExprKind::Lit(_) = e.node {\n                 return Some(P(ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     span: e.span,\n@@ -349,7 +349,7 @@ impl DummyResult {\n     pub fn raw_expr(sp: Span) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprLit(P(codemap::respan(sp, ast::LitBool(false)))),\n+            node: ast::ExprKind::Lit(P(codemap::respan(sp, ast::LitKind::Bool(false)))),\n             span: sp,\n             attrs: None,\n         })\n@@ -367,7 +367,7 @@ impl DummyResult {\n     pub fn raw_ty(sp: Span) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::TyInfer,\n+            node: ast::TyKind::Infer,\n             span: sp\n         })\n     }\n@@ -402,8 +402,8 @@ impl MacResult for DummyResult {\n     fn make_stmts(self: Box<DummyResult>) -> Option<SmallVector<P<ast::Stmt>>> {\n         Some(SmallVector::one(P(\n             codemap::respan(self.span,\n-                            ast::StmtExpr(DummyResult::raw_expr(self.span),\n-                                          ast::DUMMY_NODE_ID)))))\n+                            ast::StmtKind::Expr(DummyResult::raw_expr(self.span),\n+                                                ast::DUMMY_NODE_ID)))))\n     }\n }\n \n@@ -773,8 +773,8 @@ pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n-        ast::ExprLit(ref l) => match l.node {\n-            ast::LitStr(ref s, style) => return Some(((*s).clone(), style)),\n+        ast::ExprKind::Lit(ref l) => match l.node {\n+            ast::LitKind::Str(ref s, style) => return Some(((*s).clone(), style)),\n             _ => cx.span_err(l.span, err_msg)\n         },\n         _ => cx.span_err(expr.span, err_msg)"}, {"sha": "31d5521799e1b852b69d468256883a263d96fa8f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 92, "deletions": 79, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi;\n-use ast::{Ident, Generics, Expr};\n-use ast;\n+use abi::Abi;\n+use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp};\n use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n@@ -53,7 +52,7 @@ pub trait AstBuilder {\n     // types\n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;\n \n-    fn ty(&self, span: Span, ty: ast::Ty_) -> P<ast::Ty>;\n+    fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty>;\n     fn ty_path(&self, ast::Path) -> P<ast::Ty>;\n     fn ty_sum(&self, ast::Path, ast::TyParamBounds) -> P<ast::Ty>;\n     fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;\n@@ -109,13 +108,13 @@ pub trait AstBuilder {\n                  expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n \n     // expressions\n-    fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr>;\n+    fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr>;\n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n     fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr>;\n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n \n     fn expr_self(&self, span: Span) -> P<ast::Expr>;\n-    fn expr_binary(&self, sp: Span, op: ast::BinOp_,\n+    fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n                    lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr>;\n@@ -140,7 +139,7 @@ pub trait AstBuilder {\n     fn expr_struct_ident(&self, span: Span, id: ast::Ident,\n                          fields: Vec<ast::Field>) -> P<ast::Expr>;\n \n-    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr>;\n+    fn expr_lit(&self, sp: Span, lit: ast::LitKind) -> P<ast::Expr>;\n \n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr>;\n     fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr>;\n@@ -214,7 +213,7 @@ pub trait AstBuilder {\n \n     // items\n     fn item(&self, span: Span,\n-            name: Ident, attrs: Vec<ast::Attribute> , node: ast::Item_) -> P<ast::Item>;\n+            name: Ident, attrs: Vec<ast::Attribute> , node: ast::ItemKind) -> P<ast::Item>;\n \n     fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n     // FIXME unused self\n@@ -286,7 +285,7 @@ pub trait AstBuilder {\n     fn meta_name_value(&self,\n                        sp: Span,\n                        name: InternedString,\n-                       value: ast::Lit_)\n+                       value: ast::LitKind)\n                        -> P<ast::MetaItem>;\n \n     fn item_use(&self, sp: Span,\n@@ -386,7 +385,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         }\n     }\n \n-    fn ty(&self, span: Span, ty: ast::Ty_) -> P<ast::Ty> {\n+    fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n             span: span,\n@@ -395,12 +394,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn ty_path(&self, path: ast::Path) -> P<ast::Ty> {\n-        self.ty(path.span, ast::TyPath(None, path))\n+        self.ty(path.span, ast::TyKind::Path(None, path))\n     }\n \n     fn ty_sum(&self, path: ast::Path, bounds: ast::TyParamBounds) -> P<ast::Ty> {\n         self.ty(path.span,\n-                ast::TyObjectSum(self.ty_path(path),\n+                ast::TyKind::ObjectSum(self.ty_path(path),\n                                  bounds))\n     }\n \n@@ -418,7 +417,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                mutbl: ast::Mutability)\n         -> P<ast::Ty> {\n         self.ty(span,\n-                ast::TyRptr(lifetime, self.ty_mt(ty, mutbl)))\n+                ast::TyKind::Rptr(lifetime, self.ty_mt(ty, mutbl)))\n     }\n \n     fn ty_ptr(&self,\n@@ -427,7 +426,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n               mutbl: ast::Mutability)\n         -> P<ast::Ty> {\n         self.ty(span,\n-                ast::TyPtr(self.ty_mt(ty, mutbl)))\n+                ast::TyKind::Ptr(self.ty_mt(ty, mutbl)))\n     }\n \n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty> {\n@@ -441,7 +440,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n-        self.ty(span, ast::TyInfer)\n+        self.ty(span, ast::TyKind::Infer)\n     }\n \n     fn typaram(&self,\n@@ -507,13 +506,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn stmt_expr(&self, expr: P<ast::Expr>) -> P<ast::Stmt> {\n-        P(respan(expr.span, ast::StmtSemi(expr, ast::DUMMY_NODE_ID)))\n+        P(respan(expr.span, ast::StmtKind::Semi(expr, ast::DUMMY_NODE_ID)))\n     }\n \n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n                 ex: P<ast::Expr>) -> P<ast::Stmt> {\n         let pat = if mutbl {\n-            self.pat_ident_binding_mode(sp, ident, ast::BindingMode::ByValue(ast::MutMutable))\n+            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mutable);\n+            self.pat_ident_binding_mode(sp, ident, binding_mode)\n         } else {\n             self.pat_ident(sp, ident)\n         };\n@@ -525,8 +525,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             span: sp,\n             attrs: None,\n         });\n-        let decl = respan(sp, ast::DeclLocal(local));\n-        P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n+        let decl = respan(sp, ast::DeclKind::Local(local));\n+        P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n     fn stmt_let_typed(&self,\n@@ -537,7 +537,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                       ex: P<ast::Expr>)\n                       -> P<ast::Stmt> {\n         let pat = if mutbl {\n-            self.pat_ident_binding_mode(sp, ident, ast::BindingMode::ByValue(ast::MutMutable))\n+            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mutable);\n+            self.pat_ident_binding_mode(sp, ident, binding_mode)\n         } else {\n             self.pat_ident(sp, ident)\n         };\n@@ -549,8 +550,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             span: sp,\n             attrs: None,\n         });\n-        let decl = respan(sp, ast::DeclLocal(local));\n-        P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n+        let decl = respan(sp, ast::DeclKind::Local(local));\n+        P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n     fn block(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n@@ -559,8 +560,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> P<ast::Stmt> {\n-        let decl = respan(sp, ast::DeclItem(item));\n-        P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n+        let decl = respan(sp, ast::DeclKind::Item(item));\n+        P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n     }\n \n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n@@ -574,12 +575,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                stmts: stmts,\n                expr: expr,\n                id: ast::DUMMY_NODE_ID,\n-               rules: ast::DefaultBlock,\n+               rules: BlockCheckMode::Default,\n                span: span,\n             })\n     }\n \n-    fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr> {\n+    fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr> {\n         P(ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n@@ -589,12 +590,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr> {\n-        self.expr(path.span, ast::ExprPath(None, path))\n+        self.expr(path.span, ast::ExprKind::Path(None, path))\n     }\n \n     /// Constructs a QPath expression.\n     fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprPath(Some(qself), path))\n+        self.expr(span, ast::ExprKind::Path(Some(qself), path))\n     }\n \n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n@@ -604,16 +605,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_ident(span, special_idents::self_)\n     }\n \n-    fn expr_binary(&self, sp: Span, op: ast::BinOp_,\n+    fn expr_binary(&self, sp: Span, op: ast::BinOpKind,\n                    lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprBinary(Spanned { node: op, span: sp }, lhs, rhs))\n+        self.expr(sp, ast::ExprKind::Binary(Spanned { node: op, span: sp }, lhs, rhs))\n     }\n \n     fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr_unary(sp, ast::UnDeref, e)\n+        self.expr_unary(sp, UnOp::Deref, e)\n     }\n     fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprUnary(op, e))\n+        self.expr(sp, ast::ExprKind::Unary(op, e))\n     }\n \n     fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n@@ -624,7 +625,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         };\n \n         let id = Spanned { node: ident, span: field_span };\n-        self.expr(sp, ast::ExprField(expr, id))\n+        self.expr(sp, ast::ExprKind::Field(expr, id))\n     }\n     fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n         let field_span = Span {\n@@ -634,21 +635,21 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         };\n \n         let id = Spanned { node: idx, span: field_span };\n-        self.expr(sp, ast::ExprTupField(expr, id))\n+        self.expr(sp, ast::ExprKind::TupField(expr, id))\n     }\n     fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))\n+        self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Immutable, e))\n     }\n     fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprAddrOf(ast::MutMutable, e))\n+        self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Mutable, e))\n     }\n \n     fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprCall(expr, args))\n+        self.expr(span, ast::ExprKind::Call(expr, args))\n     }\n     fn expr_call_ident(&self, span: Span, id: ast::Ident,\n                        args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprCall(self.expr_ident(span, id), args))\n+        self.expr(span, ast::ExprKind::Call(self.expr_ident(span, id), args))\n     }\n     fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,\n                       args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n@@ -661,44 +662,50 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                         mut args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         let id = Spanned { node: ident, span: span };\n         args.insert(0, expr);\n-        self.expr(span, ast::ExprMethodCall(id, Vec::new(), args))\n+        self.expr(span, ast::ExprKind::MethodCall(id, Vec::new(), args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(b.span, ast::ExprBlock(b))\n+        self.expr(b.span, ast::ExprKind::Block(b))\n     }\n     fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field {\n         ast::Field { ident: respan(span, name), expr: e, span: span }\n     }\n     fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprStruct(path, fields, None))\n+        self.expr(span, ast::ExprKind::Struct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: Span,\n                          id: ast::Ident, fields: Vec<ast::Field>) -> P<ast::Expr> {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprLit(P(respan(sp, lit))))\n+    fn expr_lit(&self, sp: Span, lit: ast::LitKind) -> P<ast::Expr> {\n+        self.expr(sp, ast::ExprKind::Lit(P(respan(sp, lit))))\n     }\n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n-        self.expr_lit(span, ast::LitInt(i as u64, ast::UnsignedIntLit(ast::TyUs)))\n+        self.expr_lit(span, ast::LitKind::Int(i as u64, ast::LitIntType::Unsigned(ast::UintTy::Us)))\n     }\n     fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitInt(i as u64, ast::SignedIntLit(ast::TyIs,\n-                                                                  ast::Sign::new(i))))\n+        if i < 0 {\n+            let i = (-i) as u64;\n+            let lit_ty = ast::LitIntType::Signed(ast::IntTy::Is);\n+            let lit = self.expr_lit(sp, ast::LitKind::Int(i, lit_ty));\n+            self.expr_unary(sp, ast::UnOp::Neg, lit)\n+        } else {\n+            self.expr_lit(sp, ast::LitKind::Int(i as u64, ast::LitIntType::Signed(ast::IntTy::Is)))\n+        }\n     }\n     fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU32)))\n+        self.expr_lit(sp, ast::LitKind::Int(u as u64, ast::LitIntType::Unsigned(ast::UintTy::U32)))\n     }\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU8)))\n+        self.expr_lit(sp, ast::LitKind::Int(u as u64, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n     }\n     fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitBool(value))\n+        self.expr_lit(sp, ast::LitKind::Bool(value))\n     }\n \n     fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprVec(exprs))\n+        self.expr(sp, ast::ExprKind::Vec(exprs))\n     }\n     fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> {\n         self.expr_call_global(sp, self.std_path(&[\"vec\", \"Vec\", \"new\"]),\n@@ -708,11 +715,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n     fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitStr(s, ast::CookedStr))\n+        self.expr_lit(sp, ast::LitKind::Str(s, ast::StrStyle::Cooked))\n     }\n \n     fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprCast(expr, ty))\n+        self.expr(sp, ast::ExprKind::Cast(expr, ty))\n     }\n \n \n@@ -729,12 +736,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n \n     fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprBreak(None))\n+        self.expr(sp, ast::ExprKind::Break(None))\n     }\n \n \n     fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprTup(exprs))\n+        self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n \n     fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n@@ -786,7 +793,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let err_inner_expr = self.expr_call(sp, self.expr_path(err_path),\n                                             vec!(binding_expr.clone()));\n         // return Err(__try_var)\n-        let err_expr = self.expr(sp, ast::ExprRet(Some(err_inner_expr)));\n+        let err_expr = self.expr(sp, ast::ExprKind::Ret(Some(err_inner_expr)));\n \n         // Ok(__try_var) => __try_var\n         let ok_arm = self.arm(sp, vec!(ok_pat), binding_expr);\n@@ -808,7 +815,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat(span, ast::PatLit(expr))\n     }\n     fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat> {\n-        self.pat_ident_binding_mode(span, ident, ast::BindingMode::ByValue(ast::MutImmutable))\n+        let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Immutable);\n+        self.pat_ident_binding_mode(span, ident, binding_mode)\n     }\n \n     fn pat_ident_binding_mode(&self,\n@@ -869,29 +877,29 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n-        self.expr(span, ast::ExprMatch(arg, arms))\n+        self.expr(span, ast::ExprKind::Match(arg, arms))\n     }\n \n     fn expr_if(&self, span: Span, cond: P<ast::Expr>,\n                then: P<ast::Expr>, els: Option<P<ast::Expr>>) -> P<ast::Expr> {\n         let els = els.map(|x| self.expr_block(self.block_expr(x)));\n-        self.expr(span, ast::ExprIf(cond, self.block_expr(then), els))\n+        self.expr(span, ast::ExprKind::If(cond, self.block_expr(then), els))\n     }\n \n     fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprLoop(block, None))\n+        self.expr(span, ast::ExprKind::Loop(block, None))\n     }\n \n     fn lambda_fn_decl(&self, span: Span,\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprClosure(ast::CaptureByRef, fn_decl, blk))\n+        self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref, fn_decl, blk))\n     }\n     fn lambda(&self, span: Span, ids: Vec<ast::Ident>, blk: P<ast::Block>) -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n-        self.expr(span, ast::ExprClosure(ast::CaptureByRef, fn_decl, blk))\n+        self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref, fn_decl, blk))\n     }\n     fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr> {\n         self.lambda(span, Vec::new(), blk)\n@@ -940,21 +948,21 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn fn_decl(&self, inputs: Vec<ast::Arg>, output: P<ast::Ty>) -> P<ast::FnDecl> {\n         P(ast::FnDecl {\n             inputs: inputs,\n-            output: ast::Return(output),\n+            output: ast::FunctionRetTy::Ty(output),\n             variadic: false\n         })\n     }\n \n     fn item(&self, span: Span, name: Ident,\n-            attrs: Vec<ast::Attribute>, node: ast::Item_) -> P<ast::Item> {\n+            attrs: Vec<ast::Attribute>, node: ast::ItemKind) -> P<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n         P(ast::Item {\n             ident: name,\n             attrs: attrs,\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n-            vis: ast::Inherited,\n+            vis: ast::Visibility::Inherited,\n             span: span\n         })\n     }\n@@ -969,10 +977,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.item(span,\n                   name,\n                   Vec::new(),\n-                  ast::ItemFn(self.fn_decl(inputs, output),\n+                  ast::ItemKind::Fn(self.fn_decl(inputs, output),\n                               ast::Unsafety::Normal,\n                               ast::Constness::NotConst,\n-                              abi::Rust,\n+                              Abi::Rust,\n                               generics,\n                               body))\n     }\n@@ -997,7 +1005,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let fields: Vec<_> = tys.into_iter().map(|ty| {\n             Spanned { span: ty.span, node: ast::StructField_ {\n                 ty: ty,\n-                kind: ast::UnnamedField(ast::Inherited),\n+                kind: ast::UnnamedField(ast::Visibility::Inherited),\n                 attrs: Vec::new(),\n                 id: ast::DUMMY_NODE_ID,\n             }}\n@@ -1021,7 +1029,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_enum_poly(&self, span: Span, name: Ident,\n                       enum_definition: ast::EnumDef,\n                       generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemEnum(enum_definition, generics))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Enum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, span: Span, name: Ident,\n@@ -1042,7 +1050,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn item_struct_poly(&self, span: Span, name: Ident,\n         struct_def: ast::VariantData, generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemStruct(struct_def, generics))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Struct(struct_def, generics))\n     }\n \n     fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n@@ -1052,7 +1060,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             span,\n             name,\n             attrs,\n-            ast::ItemMod(ast::Mod {\n+            ast::ItemKind::Mod(ast::Mod {\n                 inner: inner_span,\n                 items: items,\n             })\n@@ -1066,7 +1074,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                    mutbl: ast::Mutability,\n                    expr: P<ast::Expr>)\n                    -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemStatic(ty, mutbl, expr))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Static(ty, mutbl, expr))\n     }\n \n     fn item_const(&self,\n@@ -1075,12 +1083,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                   ty: P<ast::Ty>,\n                   expr: P<ast::Expr>)\n                   -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemConst(ty, expr))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Const(ty, expr))\n     }\n \n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n                     generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Ty(ty, generics))\n     }\n \n     fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> {\n@@ -1097,21 +1105,21 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem> {\n-        P(respan(sp, ast::MetaWord(w)))\n+        P(respan(sp, ast::MetaItemKind::Word(w)))\n     }\n     fn meta_list(&self,\n                  sp: Span,\n                  name: InternedString,\n                  mis: Vec<P<ast::MetaItem>> )\n                  -> P<ast::MetaItem> {\n-        P(respan(sp, ast::MetaList(name, mis)))\n+        P(respan(sp, ast::MetaItemKind::List(name, mis)))\n     }\n     fn meta_name_value(&self,\n                        sp: Span,\n                        name: InternedString,\n-                       value: ast::Lit_)\n+                       value: ast::LitKind)\n                        -> P<ast::MetaItem> {\n-        P(respan(sp, ast::MetaNameValue(name, respan(sp, value))))\n+        P(respan(sp, ast::MetaItemKind::NameValue(name, respan(sp, value))))\n     }\n \n     fn item_use(&self, sp: Span,\n@@ -1120,7 +1128,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             ident: special_idents::invalid,\n             attrs: vec![],\n-            node: ast::ItemUse(vp),\n+            node: ast::ItemKind::Use(vp),\n             vis: vis,\n             span: sp\n         })\n@@ -1142,7 +1150,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n                      path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item> {\n         let imports = imports.iter().map(|id| {\n-            respan(sp, ast::PathListIdent { name: *id, rename: None, id: ast::DUMMY_NODE_ID })\n+            let item = ast::PathListItemKind::Ident {\n+                name: *id,\n+                rename: None,\n+                id: ast::DUMMY_NODE_ID,\n+            };\n+            respan(sp, item)\n         }).collect();\n \n         self.item_use(sp, vis,"}, {"sha": "c4bbe709f346f6dbe46c0c8ed430eeb1c43b117f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, DeclLocal, PatMac};\n+use ast::{Block, Crate, DeclKind, PatMac};\n use ast::{Local, Ident, Mac_, Name};\n-use ast::{ItemMac, MacStmtWithSemicolon, Mrk, Stmt, StmtDecl, StmtMac};\n-use ast::{StmtExpr, StmtSemi};\n+use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast::TokenTree;\n use ast;\n use ext::mtwt;\n@@ -42,7 +41,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n-        ast::ExprMac(mac) => {\n+        ast::ExprKind::Mac(mac) => {\n \n             // Assert that we drop any macro attributes on the floor here\n             drop(attrs);\n@@ -69,7 +68,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             })\n         }\n \n-        ast::ExprInPlace(placer, value_expr) => {\n+        ast::ExprKind::InPlace(placer, value_expr) => {\n             // Ensure feature-gate is enabled\n             feature_gate::check_for_placement_in(\n                 fld.cx.ecfg.features,\n@@ -78,18 +77,18 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let placer = fld.fold_expr(placer);\n             let value_expr = fld.fold_expr(value_expr);\n-            fld.cx.expr(span, ast::ExprInPlace(placer, value_expr))\n+            fld.cx.expr(span, ast::ExprKind::InPlace(placer, value_expr))\n                 .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprWhile(cond, body, opt_ident) => {\n+        ast::ExprKind::While(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprWhile(cond, body, opt_ident))\n+            fld.cx.expr(span, ast::ExprKind::While(cond, body, opt_ident))\n                 .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprWhileLet(pat, expr, body, opt_ident) => {\n+        ast::ExprKind::WhileLet(pat, expr, body, opt_ident) => {\n             let pat = fld.fold_pat(pat);\n             let expr = fld.fold_expr(expr);\n \n@@ -103,17 +102,17 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             });\n             assert!(rewritten_pats.len() == 1);\n \n-            fld.cx.expr(span, ast::ExprWhileLet(rewritten_pats.remove(0), expr, body, opt_ident))\n-                .with_attrs(fold_thin_attrs(attrs, fld))\n+            let wl = ast::ExprKind::WhileLet(rewritten_pats.remove(0), expr, body, opt_ident);\n+            fld.cx.expr(span, wl).with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprLoop(loop_block, opt_ident) => {\n+        ast::ExprKind::Loop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n+            fld.cx.expr(span, ast::ExprKind::Loop(loop_block, opt_ident))\n                 .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprForLoop(pat, head, body, opt_ident) => {\n+        ast::ExprKind::ForLoop(pat, head, body, opt_ident) => {\n             let pat = fld.fold_pat(pat);\n \n             // Hygienic renaming of the for loop body (for loop binds its pattern).\n@@ -127,11 +126,11 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             assert!(rewritten_pats.len() == 1);\n \n             let head = fld.fold_expr(head);\n-            fld.cx.expr(span, ast::ExprForLoop(rewritten_pats.remove(0), head, body, opt_ident))\n-                .with_attrs(fold_thin_attrs(attrs, fld))\n+            let fl = ast::ExprKind::ForLoop(rewritten_pats.remove(0), head, body, opt_ident);\n+            fld.cx.expr(span, fl).with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprIfLet(pat, sub_expr, body, else_opt) => {\n+        ast::ExprKind::IfLet(pat, sub_expr, body, else_opt) => {\n             let pat = fld.fold_pat(pat);\n \n             // Hygienic renaming of the body.\n@@ -146,14 +145,14 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n             let sub_expr = fld.fold_expr(sub_expr);\n-            fld.cx.expr(span, ast::ExprIfLet(rewritten_pats.remove(0), sub_expr, body, else_opt))\n-                .with_attrs(fold_thin_attrs(attrs, fld))\n+            let il = ast::ExprKind::IfLet(rewritten_pats.remove(0), sub_expr, body, else_opt);\n+            fld.cx.expr(span, il).with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n-        ast::ExprClosure(capture_clause, fn_decl, block) => {\n+        ast::ExprKind::Closure(capture_clause, fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n-            let new_node = ast::ExprClosure(capture_clause,\n+            let new_node = ast::ExprKind::Closure(capture_clause,\n                                             rewritten_fn_decl,\n                                             rewritten_block);\n             P(ast::Expr{id:id, node: new_node, span: fld.new_span(span),\n@@ -316,17 +315,17 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n         .into_iter().map(|i| i.expect_item()).collect()\n }\n \n-/// Expand item_underscore\n-fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Item_ {\n+/// Expand item_kind\n+fn expand_item_kind(item: ast::ItemKind, fld: &mut MacroExpander) -> ast::ItemKind {\n     match item {\n-        ast::ItemFn(decl, unsafety, constness, abi, generics, body) => {\n+        ast::ItemKind::Fn(decl, unsafety, constness, abi, generics, body) => {\n             let (rewritten_fn_decl, rewritten_body)\n                 = expand_and_rename_fn_decl_and_block(decl, body, fld);\n             let expanded_generics = fold::noop_fold_generics(generics,fld);\n-            ast::ItemFn(rewritten_fn_decl, unsafety, constness, abi,\n+            ast::ItemKind::Fn(rewritten_fn_decl, unsafety, constness, abi,\n                         expanded_generics, rewritten_body)\n         }\n-        _ => noop_fold_item_underscore(item, fld)\n+        _ => noop_fold_item_kind(item, fld)\n     }\n }\n \n@@ -349,7 +348,7 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n \n         if is_use {\n             match attr.node.value.node {\n-                ast::MetaWord(..) => (),\n+                ast::MetaItemKind::Word(..) => (),\n                 _ => fld.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\"),\n             }\n             return true;\n@@ -363,7 +362,7 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n pub fn expand_item_mac(it: P<ast::Item>,\n                        fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n     let (extname, path_span, tts, span, attrs, ident) = it.and_then(|it| match it.node {\n-        ItemMac(codemap::Spanned { node: Mac_ { path, tts, .. }, .. }) =>\n+        ItemKind::Mac(codemap::Spanned { node: Mac_ { path, tts, .. }, .. }) =>\n             (path.segments[0].identifier.name, path.span, tts, it.span, it.attrs, it.ident),\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     });\n@@ -507,7 +506,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n fn expand_stmt(stmt: P<Stmt>, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     let stmt = stmt.and_then(|stmt| stmt);\n     let (mac, style, attrs) = match stmt.node {\n-        StmtMac(mac, style, attrs) => (mac, style, attrs),\n+        StmtKind::Mac(mac, style, attrs) => (mac, style, attrs),\n         _ => return expand_non_macro_stmt(stmt, fld)\n     };\n \n@@ -534,12 +533,12 @@ fn expand_stmt(stmt: P<Stmt>, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n-    if style == MacStmtWithSemicolon {\n+    if style == MacStmtStyle::Semicolon {\n         if let Some(stmt) = fully_expanded.pop() {\n             let new_stmt = stmt.map(|Spanned {node, span}| {\n                 Spanned {\n                     node: match node {\n-                        StmtExpr(e, stmt_id) => StmtSemi(e, stmt_id),\n+                        StmtKind::Expr(e, stmt_id) => StmtKind::Semi(e, stmt_id),\n                         _ => node /* might already have a semi */\n                     },\n                     span: span\n@@ -558,11 +557,11 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                          -> SmallVector<P<Stmt>> {\n     // is it a let?\n     match node {\n-        StmtDecl(decl, node_id) => decl.and_then(|Spanned {node: decl, span}| match decl {\n-            DeclLocal(local) => {\n+        StmtKind::Decl(decl, node_id) => decl.and_then(|Spanned {node: decl, span}| match decl {\n+            DeclKind::Local(local) => {\n                 // take it apart:\n                 let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n-                    // expand the ty since TyFixedLengthVec contains an Expr\n+                    // expand the ty since TyKind::FixedLengthVec contains an Expr\n                     // and thus may have a macro use\n                     let expanded_ty = ty.map(|t| fld.fold_ty(t));\n                     // expand the pat (it might contain macro uses):\n@@ -596,8 +595,8 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                     }\n                 });\n                 SmallVector::one(P(Spanned {\n-                    node: StmtDecl(P(Spanned {\n-                            node: DeclLocal(rewritten_local),\n+                    node: StmtKind::Decl(P(Spanned {\n+                            node: DeclKind::Local(rewritten_local),\n                             span: span\n                         }),\n                         node_id),\n@@ -606,7 +605,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n             }\n             _ => {\n                 noop_fold_stmt(Spanned {\n-                    node: StmtDecl(P(Spanned {\n+                    node: StmtKind::Decl(P(Spanned {\n                             node: decl,\n                             span: span\n                         }),\n@@ -891,10 +890,10 @@ fn expand_annotatable(a: Annotatable,\n \n     let mut new_items: SmallVector<Annotatable> = match a {\n         Annotatable::Item(it) => match it.node {\n-            ast::ItemMac(..) => {\n+            ast::ItemKind::Mac(..) => {\n                 expand_item_mac(it, fld).into_iter().map(|i| Annotatable::Item(i)).collect()\n             }\n-            ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n+            ast::ItemKind::Mod(_) | ast::ItemKind::ForeignMod(_) => {\n                 let valid_ident =\n                     it.ident.name != parse::token::special_idents::invalid.name;\n \n@@ -920,14 +919,14 @@ fn expand_annotatable(a: Annotatable,\n         },\n \n         Annotatable::TraitItem(it) => match it.node {\n-            ast::MethodTraitItem(_, Some(_)) => SmallVector::one(it.map(|ti| ast::TraitItem {\n+            ast::TraitItemKind::Method(_, Some(_)) => SmallVector::one(it.map(|ti| ast::TraitItem {\n                 id: ti.id,\n                 ident: ti.ident,\n                 attrs: ti.attrs,\n                 node: match ti.node  {\n-                    ast::MethodTraitItem(sig, Some(body)) => {\n+                    ast::TraitItemKind::Method(sig, Some(body)) => {\n                         let (sig, body) = expand_and_rename_method(sig, body, fld);\n-                        ast::MethodTraitItem(sig, Some(body))\n+                        ast::TraitItemKind::Method(sig, Some(body))\n                     }\n                     _ => unreachable!()\n                 },\n@@ -1049,7 +1048,7 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n         }\n     }\n \n-    // Expansion may have added new ItemModifiers.\n+    // Expansion may have added new ItemKind::Modifiers.\n     expand_item_multi_modifier(it, fld)\n }\n \n@@ -1133,7 +1132,7 @@ fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n \n pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n     let t = match t.node.clone() {\n-        ast::Ty_::TyMac(mac) => {\n+        ast::TyKind::Mac(mac) => {\n             if fld.cx.ecfg.features.unwrap().type_macros {\n                 let expanded_ty = match expand_mac_invoc(mac, t.span,\n                                                          |r| r.make_ty(),\n@@ -1195,8 +1194,8 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_item(item, self)\n     }\n \n-    fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n-        expand_item_underscore(item, self)\n+    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        expand_item_kind(item, self)\n     }\n \n     fn fold_stmt(&mut self, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>> {\n@@ -1427,7 +1426,7 @@ mod tests {\n \n     impl<'v> Visitor<'v> for PathExprFinderContext {\n         fn visit_expr(&mut self, expr: &ast::Expr) {\n-            if let ast::ExprPath(None, ref p) = expr.node {\n+            if let ast::ExprKind::Path(None, ref p) = expr.node {\n                 self.path_accumulator.push(p.clone());\n             }\n             visit::walk_expr(self, expr);\n@@ -1694,7 +1693,7 @@ mod tests {\n             0)\n     }\n \n-    // closure arg hygiene (ExprClosure)\n+    // closure arg hygiene (ExprKind::Closure)\n     // expands to fn f(){(|x_1 : i32| {(x_2 + x_1)})(3);}\n     #[test]\n     fn closure_arg_hygiene(){"}, {"sha": "57db13470210023dacc848223b91c93a69cd365c", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -218,8 +218,8 @@ pub mod rt {\n \n     impl ToTokens for str {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let lit = ast::LitStr(\n-                token::intern_and_get_ident(self), ast::CookedStr);\n+            let lit = ast::LitKind::Str(\n+                token::intern_and_get_ident(self), ast::StrStyle::Cooked);\n             dummy_spanned(lit).to_tokens(cx)\n         }\n     }\n@@ -240,7 +240,7 @@ pub mod rt {\n             // FIXME: This is wrong\n             P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprLit(P(self.clone())),\n+                node: ast::ExprKind::Lit(P(self.clone())),\n                 span: DUMMY_SP,\n                 attrs: None,\n             }).to_tokens(cx)\n@@ -249,47 +249,65 @@ pub mod rt {\n \n     impl ToTokens for bool {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            dummy_spanned(ast::LitBool(*self)).to_tokens(cx)\n+            dummy_spanned(ast::LitKind::Bool(*self)).to_tokens(cx)\n         }\n     }\n \n     impl ToTokens for char {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            dummy_spanned(ast::LitChar(*self)).to_tokens(cx)\n+            dummy_spanned(ast::LitKind::Char(*self)).to_tokens(cx)\n         }\n     }\n \n     macro_rules! impl_to_tokens_int {\n         (signed, $t:ty, $tag:expr) => (\n             impl ToTokens for $t {\n                 fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-                    let lit = ast::LitInt(*self as u64, ast::SignedIntLit($tag,\n-                                                                          ast::Sign::new(*self)));\n-                    dummy_spanned(lit).to_tokens(cx)\n+                    let val = if *self < 0 {\n+                        -self\n+                    } else {\n+                        *self\n+                    };\n+                    let lit = ast::LitKind::Int(val as u64, ast::LitIntType::Signed($tag));\n+                    let lit = P(ast::Expr {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: ast::ExprKind::Lit(P(dummy_spanned(lit))),\n+                        span: DUMMY_SP,\n+                        attrs: None,\n+                    });\n+                    if *self >= 0 {\n+                        return lit.to_tokens(cx);\n+                    }\n+                    P(ast::Expr {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: ast::ExprKind::Unary(ast::UnOp::Neg, lit),\n+                        span: DUMMY_SP,\n+                        attrs: None,\n+                    }).to_tokens(cx)\n                 }\n             }\n         );\n         (unsigned, $t:ty, $tag:expr) => (\n             impl ToTokens for $t {\n                 fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-                    let lit = ast::LitInt(*self as u64, ast::UnsignedIntLit($tag));\n+                    let lit = ast::LitKind::Int(*self as u64, ast::LitIntType::Unsigned($tag));\n                     dummy_spanned(lit).to_tokens(cx)\n                 }\n             }\n         );\n     }\n \n-    impl_to_tokens_int! { signed, isize, ast::TyIs }\n-    impl_to_tokens_int! { signed, i8,  ast::TyI8 }\n-    impl_to_tokens_int! { signed, i16, ast::TyI16 }\n-    impl_to_tokens_int! { signed, i32, ast::TyI32 }\n-    impl_to_tokens_int! { signed, i64, ast::TyI64 }\n+    impl_to_tokens_int! { signed, isize, ast::IntTy::Is }\n+    impl_to_tokens_int! { signed, i8,  ast::IntTy::I8 }\n+    impl_to_tokens_int! { signed, i16, ast::IntTy::I16 }\n+    impl_to_tokens_int! { signed, i32, ast::IntTy::I32 }\n+    impl_to_tokens_int! { signed, i64, ast::IntTy::I64 }\n \n-    impl_to_tokens_int! { unsigned, usize, ast::TyUs }\n-    impl_to_tokens_int! { unsigned, u8,   ast::TyU8 }\n-    impl_to_tokens_int! { unsigned, u16,  ast::TyU16 }\n-    impl_to_tokens_int! { unsigned, u32,  ast::TyU32 }\n-    impl_to_tokens_int! { unsigned, u64,  ast::TyU64 }\n+    impl_to_tokens_int! { unsigned, usize, ast::UintTy::Us }\n+    impl_to_tokens_int! { unsigned, u8,   ast::UintTy::U8 }\n+    impl_to_tokens_int! { unsigned, u16,  ast::UintTy::U16 }\n+    impl_to_tokens_int! { unsigned, u32,  ast::UintTy::U32 }\n+    impl_to_tokens_int! { unsigned, u64,  ast::UintTy::U64 }\n \n     pub trait ExtParseUtils {\n         fn parse_item(&self, s: String) -> P<ast::Item>;\n@@ -524,11 +542,6 @@ fn mk_tt_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n     cx.expr_path(cx.path_global(sp, idents))\n }\n \n-fn mk_ast_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n-    let idents = vec!(id_ext(\"syntax\"), id_ext(\"ast\"), id_ext(name));\n-    cx.expr_path(cx.path_global(sp, idents))\n-}\n-\n fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n     let idents = vec!(id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"token\"), id_ext(name));\n     cx.expr_path(cx.path_global(sp, idents))\n@@ -761,9 +774,16 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<P<ast::S\n                 None => cx.expr_none(sp),\n             };\n             let e_op = match seq.op {\n-                ast::ZeroOrMore => mk_ast_path(cx, sp, \"ZeroOrMore\"),\n-                ast::OneOrMore => mk_ast_path(cx, sp, \"OneOrMore\"),\n+                ast::KleeneOp::ZeroOrMore => \"ZeroOrMore\",\n+                ast::KleeneOp::OneOrMore => \"OneOrMore\",\n             };\n+            let e_op_idents = vec![\n+                id_ext(\"syntax\"),\n+                id_ext(\"ast\"),\n+                id_ext(\"KleeneOp\"),\n+                id_ext(e_op),\n+            ];\n+            let e_op = cx.expr_path(cx.path_global(sp, e_op_idents));\n             let fields = vec![cx.field_imm(sp, id_ext(\"tts\"), e_tts),\n                               cx.field_imm(sp, id_ext(\"separator\"), e_separator),\n                               cx.field_imm(sp, id_ext(\"op\"), e_op),\n@@ -886,7 +906,7 @@ fn expand_wrapper(cx: &ExtCtxt,\n     let stmts = imports.iter().map(|path| {\n         // make item: `use ...;`\n         let path = path.iter().map(|s| s.to_string()).collect();\n-        cx.stmt_item(sp, cx.item_use_glob(sp, ast::Inherited, ids_ext(path)))\n+        cx.stmt_item(sp, cx.item_use_glob(sp, ast::Visibility::Inherited, ids_ext(path)))\n     }).chain(Some(stmt_let_ext_cx)).collect();\n \n     cx.expr_block(cx.block_all(sp, stmts, Some(expr)))"}, {"sha": "3e375e1798d8697be3536648f496d58cd1437d1e", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -187,7 +187,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             let filename = format!(\"{}\", file.display());\n             cx.codemap().new_filemap_and_lines(&filename, \"\");\n \n-            base::MacEager::expr(cx.expr_lit(sp, ast::LitByteStr(Rc::new(bytes))))\n+            base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Rc::new(bytes))))\n         }\n     }\n }"}, {"sha": "9c8ae9460e482b5c3019de85a96065706c47e160", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -374,7 +374,7 @@ pub fn parse(sess: &ParseSess,\n                 match ei.top_elts.get_tt(idx) {\n                     /* need to descend into sequence */\n                     TokenTree::Sequence(sp, seq) => {\n-                        if seq.op == ast::ZeroOrMore {\n+                        if seq.op == ast::KleeneOp::ZeroOrMore {\n                             let mut new_ei = ei.clone();\n                             new_ei.match_cur += seq.num_captures;\n                             new_ei.idx += 1;"}, {"sha": "1e9178a55c5add8512270709951a8451e33961a7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -248,7 +248,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n                            TokenTree::Token(DUMMY_SP, token::FatArrow),\n                            TokenTree::Token(DUMMY_SP, match_rhs_tok)],\n                        separator: Some(token::Semi),\n-                       op: ast::OneOrMore,\n+                       op: ast::KleeneOp::OneOrMore,\n                        num_captures: 2\n                    })),\n         //to phase into semicolon-termination instead of\n@@ -257,7 +257,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n                    Rc::new(ast::SequenceRepetition {\n                        tts: vec![TokenTree::Token(DUMMY_SP, token::Semi)],\n                        separator: None,\n-                       op: ast::ZeroOrMore,\n+                       op: ast::KleeneOp::ZeroOrMore,\n                        num_captures: 0\n                    })));\n "}, {"sha": "8d857fc8e4899087414d9cbfde75593cb7eb65da", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -81,7 +81,7 @@ pub fn new_tt_reader_with_doc_flag<'a>(sp_diag: &'a Handler,\n             forest: TokenTree::Sequence(DUMMY_SP, Rc::new(ast::SequenceRepetition {\n                 tts: src,\n                 // doesn't matter. This merely holds the root unzipping.\n-                separator: None, op: ast::ZeroOrMore, num_captures: 0\n+                separator: None, op: ast::KleeneOp::ZeroOrMore, num_captures: 0\n             })),\n             idx: 0,\n             dotdotdoted: false,\n@@ -257,7 +257,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                     }\n                     LisConstraint(len, _) => {\n                         if len == 0 {\n-                            if seq.op == ast::OneOrMore {\n+                            if seq.op == ast::KleeneOp::OneOrMore {\n                                 // FIXME #2887 blame invoker\n                                 panic!(r.sp_diag.span_fatal(sp.clone(),\n                                                      \"this must repeat at least once\"));"}, {"sha": "9bf1dd49db572ceb0f00f62f606571f604aeb18e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -815,11 +815,11 @@ impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n         // But we keep these checks as a pre-expansion check to catch\n         // uses in e.g. conditionalized code.\n \n-        if let ast::ExprBox(_) = e.node {\n+        if let ast::ExprKind::Box(_) = e.node {\n             self.context.gate_feature(\"box_syntax\", e.span, EXPLAIN_BOX_SYNTAX);\n         }\n \n-        if let ast::ExprInPlace(..) = e.node {\n+        if let ast::ExprKind::InPlace(..) = e.node {\n             self.context.gate_feature(\"placement_in_syntax\", e.span, EXPLAIN_PLACEMENT_IN);\n         }\n \n@@ -855,15 +855,15 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_item(&mut self, i: &ast::Item) {\n         match i.node {\n-            ast::ItemExternCrate(_) => {\n+            ast::ItemKind::ExternCrate(_) => {\n                 if attr::contains_name(&i.attrs[..], \"macro_reexport\") {\n                     self.gate_feature(\"macro_reexport\", i.span,\n                                       \"macros reexports are experimental \\\n                                        and possibly buggy\");\n                 }\n             }\n \n-            ast::ItemForeignMod(ref foreign_module) => {\n+            ast::ItemKind::ForeignMod(ref foreign_module) => {\n                 if attr::contains_name(&i.attrs[..], \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n                                       \"the `link_args` attribute is not portable \\\n@@ -888,7 +888,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemFn(..) => {\n+            ast::ItemKind::Fn(..) => {\n                 if attr::contains_name(&i.attrs[..], \"plugin_registrar\") {\n                     self.gate_feature(\"plugin_registrar\", i.span,\n                                       \"compiler plugins are experimental and possibly buggy\");\n@@ -907,7 +907,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemStruct(..) => {\n+            ast::ItemKind::Struct(..) => {\n                 if attr::contains_name(&i.attrs[..], \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n@@ -928,14 +928,14 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemDefaultImpl(..) => {\n+            ast::ItemKind::DefaultImpl(..) => {\n                 self.gate_feature(\"optin_builtin_traits\",\n                                   i.span,\n                                   \"default trait implementations are experimental \\\n                                    and possibly buggy\");\n             }\n \n-            ast::ItemImpl(_, polarity, _, _, _, _) => {\n+            ast::ItemKind::Impl(_, polarity, _, _, _, _) => {\n                 match polarity {\n                     ast::ImplPolarity::Negative => {\n                         self.gate_feature(\"optin_builtin_traits\",\n@@ -988,13 +988,13 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprBox(_) => {\n+            ast::ExprKind::Box(_) => {\n                 self.gate_feature(\"box_syntax\",\n                                   e.span,\n                                   \"box expression syntax is experimental; \\\n                                    you can call `Box::new` instead.\");\n             }\n-            ast::ExprType(..) => {\n+            ast::ExprKind::Type(..) => {\n                 self.gate_feature(\"type_ascription\", e.span,\n                                   \"type ascription is experimental\");\n             }\n@@ -1071,17 +1071,17 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n         match ti.node {\n-            ast::ConstTraitItem(..) => {\n+            ast::TraitItemKind::Const(..) => {\n                 self.gate_feature(\"associated_consts\",\n                                   ti.span,\n                                   \"associated constants are experimental\")\n             }\n-            ast::MethodTraitItem(ref sig, _) => {\n+            ast::TraitItemKind::Method(ref sig, _) => {\n                 if sig.constness == ast::Constness::Const {\n                     self.gate_feature(\"const_fn\", ti.span, \"const fn is unstable\");\n                 }\n             }\n-            ast::TypeTraitItem(_, Some(_)) => {\n+            ast::TraitItemKind::Type(_, Some(_)) => {\n                 self.gate_feature(\"associated_type_defaults\", ti.span,\n                                   \"associated type defaults are unstable\");\n             }\n@@ -1138,7 +1138,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n             Some(list) => {\n                 for mi in list {\n                     let name = match mi.node {\n-                        ast::MetaWord(ref word) => (*word).clone(),\n+                        ast::MetaItemKind::Word(ref word) => (*word).clone(),\n                         _ => {\n                             span_handler.span_err(mi.span,\n                                                   \"malformed feature, expected just \\"}, {"sha": "5ae24e6fb248242b4cd6f12081bc803d634cbb77", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 161, "deletions": 161, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -71,8 +71,8 @@ pub trait Folder : Sized {\n         noop_fold_struct_field(sf, self)\n     }\n \n-    fn fold_item_underscore(&mut self, i: Item_) -> Item_ {\n-        noop_fold_item_underscore(i, self)\n+    fn fold_item_kind(&mut self, i: ItemKind) -> ItemKind {\n+        noop_fold_item_kind(i, self)\n     }\n \n     fn fold_trait_item(&mut self, i: P<TraitItem>) -> SmallVector<P<TraitItem>> {\n@@ -184,8 +184,8 @@ pub trait Folder : Sized {\n         noop_fold_explicit_self(es, self)\n     }\n \n-    fn fold_explicit_self_underscore(&mut self, es: ExplicitSelf_) -> ExplicitSelf_ {\n-        noop_fold_explicit_self_underscore(es, self)\n+    fn fold_explicit_self_kind(&mut self, es: SelfKind) -> SelfKind {\n+        noop_fold_explicit_self_kind(es, self)\n     }\n \n     fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n@@ -316,14 +316,14 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n                              path_list_idents.move_map(|path_list_ident| {\n                                 Spanned {\n                                     node: match path_list_ident.node {\n-                                        PathListIdent { id, name, rename } =>\n-                                            PathListIdent {\n+                                        PathListItemKind::Ident { id, name, rename } =>\n+                                            PathListItemKind::Ident {\n                                                 id: fld.new_id(id),\n                                                 rename: rename,\n                                                 name: name\n                                             },\n-                                        PathListMod { id, rename } =>\n-                                            PathListMod {\n+                                        PathListItemKind::Mod { id, rename } =>\n+                                            PathListItemKind::Mod {\n                                                 id: fld.new_id(id),\n                                                 rename: rename\n                                             }\n@@ -356,12 +356,12 @@ pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T\n \n pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>> {\n     d.and_then(|Spanned {node, span}| match node {\n-        DeclLocal(l) => SmallVector::one(P(Spanned {\n-            node: DeclLocal(fld.fold_local(l)),\n+        DeclKind::Local(l) => SmallVector::one(P(Spanned {\n+            node: DeclKind::Local(fld.fold_local(l)),\n             span: fld.new_span(span)\n         })),\n-        DeclItem(it) => fld.fold_item(it).into_iter().map(|i| P(Spanned {\n-            node: DeclItem(i),\n+        DeclKind::Item(it) => fld.fold_item(it).into_iter().map(|i| P(Spanned {\n+            node: DeclKind::Item(i),\n             span: fld.new_span(span)\n         })).collect()\n     })\n@@ -380,46 +380,46 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     t.map(|Ty {id, node, span}| Ty {\n         id: fld.new_id(id),\n         node: match node {\n-            TyInfer => node,\n-            TyVec(ty) => TyVec(fld.fold_ty(ty)),\n-            TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n-            TyRptr(region, mt) => {\n-                TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n+            TyKind::Infer => node,\n+            TyKind::Vec(ty) => TyKind::Vec(fld.fold_ty(ty)),\n+            TyKind::Ptr(mt) => TyKind::Ptr(fld.fold_mt(mt)),\n+            TyKind::Rptr(region, mt) => {\n+                TyKind::Rptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n             }\n-            TyBareFn(f) => {\n-                TyBareFn(f.map(|BareFnTy {lifetimes, unsafety, abi, decl}| BareFnTy {\n+            TyKind::BareFn(f) => {\n+                TyKind::BareFn(f.map(|BareFnTy {lifetimes, unsafety, abi, decl}| BareFnTy {\n                     lifetimes: fld.fold_lifetime_defs(lifetimes),\n                     unsafety: unsafety,\n                     abi: abi,\n                     decl: fld.fold_fn_decl(decl)\n                 }))\n             }\n-            TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n-            TyParen(ty) => TyParen(fld.fold_ty(ty)),\n-            TyPath(qself, path) => {\n+            TyKind::Tup(tys) => TyKind::Tup(tys.move_map(|ty| fld.fold_ty(ty))),\n+            TyKind::Paren(ty) => TyKind::Paren(fld.fold_ty(ty)),\n+            TyKind::Path(qself, path) => {\n                 let qself = qself.map(|QSelf { ty, position }| {\n                     QSelf {\n                         ty: fld.fold_ty(ty),\n                         position: position\n                     }\n                 });\n-                TyPath(qself, fld.fold_path(path))\n+                TyKind::Path(qself, fld.fold_path(path))\n             }\n-            TyObjectSum(ty, bounds) => {\n-                TyObjectSum(fld.fold_ty(ty),\n+            TyKind::ObjectSum(ty, bounds) => {\n+                TyKind::ObjectSum(fld.fold_ty(ty),\n                             fld.fold_bounds(bounds))\n             }\n-            TyFixedLengthVec(ty, e) => {\n-                TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n+            TyKind::FixedLengthVec(ty, e) => {\n+                TyKind::FixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n             }\n-            TyTypeof(expr) => {\n-                TyTypeof(fld.fold_expr(expr))\n+            TyKind::Typeof(expr) => {\n+                TyKind::Typeof(fld.fold_expr(expr))\n             }\n-            TyPolyTraitRef(bounds) => {\n-                TyPolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n+            TyKind::PolyTraitRef(bounds) => {\n+                TyKind::PolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n             }\n-            TyMac(mac) => {\n-                TyMac(fld.fold_mac(mac))\n+            TyKind::Mac(mac) => {\n+                TyKind::Mac(fld.fold_mac(mac))\n             }\n         },\n         span: fld.new_span(span)\n@@ -520,23 +520,23 @@ pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attr\n     })\n }\n \n-pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_, fld: &mut T)\n-                                                     -> ExplicitSelf_ {\n+pub fn noop_fold_explicit_self_kind<T: Folder>(es: SelfKind, fld: &mut T)\n+                                                     -> SelfKind {\n     match es {\n-        SelfStatic | SelfValue(_) => es,\n-        SelfRegion(lifetime, m, ident) => {\n-            SelfRegion(fld.fold_opt_lifetime(lifetime), m, ident)\n+        SelfKind::Static | SelfKind::Value(_) => es,\n+        SelfKind::Region(lifetime, m, ident) => {\n+            SelfKind::Region(fld.fold_opt_lifetime(lifetime), m, ident)\n         }\n-        SelfExplicit(typ, ident) => {\n-            SelfExplicit(fld.fold_ty(typ), ident)\n+        SelfKind::Explicit(typ, ident) => {\n+            SelfKind::Explicit(fld.fold_ty(typ), ident)\n         }\n     }\n }\n \n pub fn noop_fold_explicit_self<T: Folder>(Spanned {span, node}: ExplicitSelf, fld: &mut T)\n                                           -> ExplicitSelf {\n     Spanned {\n-        node: fld.fold_explicit_self_underscore(node),\n+        node: fld.fold_explicit_self_kind(node),\n         span: fld.new_span(span)\n     }\n }\n@@ -556,11 +556,11 @@ pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n     mi.map(|Spanned {node, span}| Spanned {\n         node: match node {\n-            MetaWord(id) => MetaWord(id),\n-            MetaList(id, mis) => {\n-                MetaList(id, mis.move_map(|e| fld.fold_meta_item(e)))\n+            MetaItemKind::Word(id) => MetaItemKind::Word(id),\n+            MetaItemKind::List(id, mis) => {\n+                MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_item(e)))\n             }\n-            MetaNameValue(id, s) => MetaNameValue(id, s)\n+            MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s)\n         },\n         span: fld.new_span(span)\n     })\n@@ -685,9 +685,9 @@ pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n     decl.map(|FnDecl {inputs, output, variadic}| FnDecl {\n         inputs: inputs.move_map(|x| fld.fold_arg(x)),\n         output: match output {\n-            Return(ty) => Return(fld.fold_ty(ty)),\n-            DefaultReturn(span) => DefaultReturn(span),\n-            NoReturn(span) => NoReturn(span)\n+            FunctionRetTy::Ty(ty) => FunctionRetTy::Ty(fld.fold_ty(ty)),\n+            FunctionRetTy::Default(span) => FunctionRetTy::Default(span),\n+            FunctionRetTy::None(span) => FunctionRetTy::None(span),\n         },\n         variadic: variadic\n     })\n@@ -890,20 +890,20 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     })\n }\n \n-pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n+pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n     match i {\n-        ItemExternCrate(string) => ItemExternCrate(string),\n-        ItemUse(view_path) => {\n-            ItemUse(folder.fold_view_path(view_path))\n+        ItemKind::ExternCrate(string) => ItemKind::ExternCrate(string),\n+        ItemKind::Use(view_path) => {\n+            ItemKind::Use(folder.fold_view_path(view_path))\n         }\n-        ItemStatic(t, m, e) => {\n-            ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n+        ItemKind::Static(t, m, e) => {\n+            ItemKind::Static(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n-        ItemConst(t, e) => {\n-            ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n+        ItemKind::Const(t, e) => {\n+            ItemKind::Const(folder.fold_ty(t), folder.fold_expr(e))\n         }\n-        ItemFn(decl, unsafety, constness, abi, generics, body) => {\n-            ItemFn(\n+        ItemKind::Fn(decl, unsafety, constness, abi, generics, body) => {\n+            ItemKind::Fn(\n                 folder.fold_fn_decl(decl),\n                 unsafety,\n                 constness,\n@@ -912,26 +912,26 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                 folder.fold_block(body)\n             )\n         }\n-        ItemMod(m) => ItemMod(folder.fold_mod(m)),\n-        ItemForeignMod(nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n-        ItemTy(t, generics) => {\n-            ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n+        ItemKind::Mod(m) => ItemKind::Mod(folder.fold_mod(m)),\n+        ItemKind::ForeignMod(nm) => ItemKind::ForeignMod(folder.fold_foreign_mod(nm)),\n+        ItemKind::Ty(t, generics) => {\n+            ItemKind::Ty(folder.fold_ty(t), folder.fold_generics(generics))\n         }\n-        ItemEnum(enum_definition, generics) => {\n-            ItemEnum(\n+        ItemKind::Enum(enum_definition, generics) => {\n+            ItemKind::Enum(\n                 ast::EnumDef {\n                     variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n                 },\n                 folder.fold_generics(generics))\n         }\n-        ItemStruct(struct_def, generics) => {\n+        ItemKind::Struct(struct_def, generics) => {\n             let struct_def = folder.fold_variant_data(struct_def);\n-            ItemStruct(struct_def, folder.fold_generics(generics))\n+            ItemKind::Struct(struct_def, folder.fold_generics(generics))\n         }\n-        ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n+        ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n+            ItemKind::DefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n         }\n-        ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n+        ItemKind::Impl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n             let new_impl_items = impl_items.move_flat_map(|item| {\n                 folder.fold_impl_item(item)\n             });\n@@ -941,24 +941,24 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                     Some(folder.fold_trait_ref((*trait_ref).clone()))\n                 }\n             };\n-            ItemImpl(unsafety,\n+            ItemKind::Impl(unsafety,\n                      polarity,\n                      folder.fold_generics(generics),\n                      ifce,\n                      folder.fold_ty(ty),\n                      new_impl_items)\n         }\n-        ItemTrait(unsafety, generics, bounds, items) => {\n+        ItemKind::Trait(unsafety, generics, bounds, items) => {\n             let bounds = folder.fold_bounds(bounds);\n             let items = items.move_flat_map(|item| {\n                 folder.fold_trait_item(item)\n             });\n-            ItemTrait(unsafety,\n+            ItemKind::Trait(unsafety,\n                       folder.fold_generics(generics),\n                       bounds,\n                       items)\n         }\n-        ItemMac(m) => ItemMac(folder.fold_mac(m)),\n+        ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n     }\n }\n \n@@ -969,16 +969,16 @@ pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n         ident: folder.fold_ident(ident),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n-            ConstTraitItem(ty, default) => {\n-                ConstTraitItem(folder.fold_ty(ty),\n+            TraitItemKind::Const(ty, default) => {\n+                TraitItemKind::Const(folder.fold_ty(ty),\n                                default.map(|x| folder.fold_expr(x)))\n             }\n-            MethodTraitItem(sig, body) => {\n-                MethodTraitItem(noop_fold_method_sig(sig, folder),\n+            TraitItemKind::Method(sig, body) => {\n+                TraitItemKind::Method(noop_fold_method_sig(sig, folder),\n                                 body.map(|x| folder.fold_block(x)))\n             }\n-            TypeTraitItem(bounds, default) => {\n-                TypeTraitItem(folder.fold_bounds(bounds),\n+            TraitItemKind::Type(bounds, default) => {\n+                TraitItemKind::Type(folder.fold_bounds(bounds),\n                               default.map(|x| folder.fold_ty(x)))\n             }\n         },\n@@ -1023,9 +1023,9 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n         ident: token::special_idents::invalid,\n         attrs: attrs,\n         id: ast::DUMMY_NODE_ID,\n-        vis: ast::Public,\n+        vis: ast::Visibility::Public,\n         span: span,\n-        node: ast::ItemMod(module),\n+        node: ast::ItemKind::Mod(module),\n     })).into_iter();\n \n     let (module, attrs, span) = match items.next() {\n@@ -1034,7 +1034,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n                     \"a crate cannot expand to more than one item\");\n             item.and_then(|ast::Item { attrs, span, node, .. }| {\n                 match node {\n-                    ast::ItemMod(m) => (m, attrs, span),\n+                    ast::ItemKind::Mod(m) => (m, attrs, span),\n                     _ => panic!(\"fold converted a module to not a module\"),\n                 }\n             })\n@@ -1067,10 +1067,10 @@ pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<It\n pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n                                         folder: &mut T) -> Item {\n     let id = folder.new_id(id);\n-    let node = folder.fold_item_underscore(node);\n+    let node = folder.fold_item_kind(node);\n     let ident = match node {\n         // The node may have changed, recompute the \"pretty\" impl name.\n-        ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n+        ItemKind::Impl(_, _, _, ref maybe_trait, ref ty, _) => {\n             ast_util::impl_pretty_name(maybe_trait, Some(&**ty))\n         }\n         _ => ident\n@@ -1092,11 +1092,11 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n         ident: folder.fold_ident(ident),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n-            ForeignItemFn(fdec, generics) => {\n-                ForeignItemFn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n+            ForeignItemKind::Fn(fdec, generics) => {\n+                ForeignItemKind::Fn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n             }\n-            ForeignItemStatic(t, m) => {\n-                ForeignItemStatic(folder.fold_ty(t), m)\n+            ForeignItemKind::Static(t, m) => {\n+                ForeignItemKind::Static(folder.fold_ty(t), m)\n             }\n         },\n         vis: vis,\n@@ -1168,131 +1168,131 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n     Expr {\n         id: folder.new_id(id),\n         node: match node {\n-            ExprBox(e) => {\n-                ExprBox(folder.fold_expr(e))\n+            ExprKind::Box(e) => {\n+                ExprKind::Box(folder.fold_expr(e))\n             }\n-            ExprInPlace(p, e) => {\n-                ExprInPlace(folder.fold_expr(p), folder.fold_expr(e))\n+            ExprKind::InPlace(p, e) => {\n+                ExprKind::InPlace(folder.fold_expr(p), folder.fold_expr(e))\n             }\n-            ExprVec(exprs) => {\n-                ExprVec(folder.fold_exprs(exprs))\n+            ExprKind::Vec(exprs) => {\n+                ExprKind::Vec(folder.fold_exprs(exprs))\n             }\n-            ExprRepeat(expr, count) => {\n-                ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n+            ExprKind::Repeat(expr, count) => {\n+                ExprKind::Repeat(folder.fold_expr(expr), folder.fold_expr(count))\n             }\n-            ExprTup(exprs) => ExprTup(folder.fold_exprs(exprs)),\n-            ExprCall(f, args) => {\n-                ExprCall(folder.fold_expr(f),\n+            ExprKind::Tup(exprs) => ExprKind::Tup(folder.fold_exprs(exprs)),\n+            ExprKind::Call(f, args) => {\n+                ExprKind::Call(folder.fold_expr(f),\n                          folder.fold_exprs(args))\n             }\n-            ExprMethodCall(i, tps, args) => {\n-                ExprMethodCall(\n+            ExprKind::MethodCall(i, tps, args) => {\n+                ExprKind::MethodCall(\n                     respan(folder.new_span(i.span), folder.fold_ident(i.node)),\n                     tps.move_map(|x| folder.fold_ty(x)),\n                     folder.fold_exprs(args))\n             }\n-            ExprBinary(binop, lhs, rhs) => {\n-                ExprBinary(binop,\n+            ExprKind::Binary(binop, lhs, rhs) => {\n+                ExprKind::Binary(binop,\n                         folder.fold_expr(lhs),\n                         folder.fold_expr(rhs))\n             }\n-            ExprUnary(binop, ohs) => {\n-                ExprUnary(binop, folder.fold_expr(ohs))\n+            ExprKind::Unary(binop, ohs) => {\n+                ExprKind::Unary(binop, folder.fold_expr(ohs))\n             }\n-            ExprLit(l) => ExprLit(l),\n-            ExprCast(expr, ty) => {\n-                ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n+            ExprKind::Lit(l) => ExprKind::Lit(l),\n+            ExprKind::Cast(expr, ty) => {\n+                ExprKind::Cast(folder.fold_expr(expr), folder.fold_ty(ty))\n             }\n-            ExprType(expr, ty) => {\n-                ExprType(folder.fold_expr(expr), folder.fold_ty(ty))\n+            ExprKind::Type(expr, ty) => {\n+                ExprKind::Type(folder.fold_expr(expr), folder.fold_ty(ty))\n             }\n-            ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n-            ExprIf(cond, tr, fl) => {\n-                ExprIf(folder.fold_expr(cond),\n+            ExprKind::AddrOf(m, ohs) => ExprKind::AddrOf(m, folder.fold_expr(ohs)),\n+            ExprKind::If(cond, tr, fl) => {\n+                ExprKind::If(folder.fold_expr(cond),\n                        folder.fold_block(tr),\n                        fl.map(|x| folder.fold_expr(x)))\n             }\n-            ExprIfLet(pat, expr, tr, fl) => {\n-                ExprIfLet(folder.fold_pat(pat),\n+            ExprKind::IfLet(pat, expr, tr, fl) => {\n+                ExprKind::IfLet(folder.fold_pat(pat),\n                           folder.fold_expr(expr),\n                           folder.fold_block(tr),\n                           fl.map(|x| folder.fold_expr(x)))\n             }\n-            ExprWhile(cond, body, opt_ident) => {\n-                ExprWhile(folder.fold_expr(cond),\n+            ExprKind::While(cond, body, opt_ident) => {\n+                ExprKind::While(folder.fold_expr(cond),\n                           folder.fold_block(body),\n                           opt_ident.map(|i| folder.fold_ident(i)))\n             }\n-            ExprWhileLet(pat, expr, body, opt_ident) => {\n-                ExprWhileLet(folder.fold_pat(pat),\n+            ExprKind::WhileLet(pat, expr, body, opt_ident) => {\n+                ExprKind::WhileLet(folder.fold_pat(pat),\n                              folder.fold_expr(expr),\n                              folder.fold_block(body),\n                              opt_ident.map(|i| folder.fold_ident(i)))\n             }\n-            ExprForLoop(pat, iter, body, opt_ident) => {\n-                ExprForLoop(folder.fold_pat(pat),\n+            ExprKind::ForLoop(pat, iter, body, opt_ident) => {\n+                ExprKind::ForLoop(folder.fold_pat(pat),\n                             folder.fold_expr(iter),\n                             folder.fold_block(body),\n                             opt_ident.map(|i| folder.fold_ident(i)))\n             }\n-            ExprLoop(body, opt_ident) => {\n-                ExprLoop(folder.fold_block(body),\n+            ExprKind::Loop(body, opt_ident) => {\n+                ExprKind::Loop(folder.fold_block(body),\n                         opt_ident.map(|i| folder.fold_ident(i)))\n             }\n-            ExprMatch(expr, arms) => {\n-                ExprMatch(folder.fold_expr(expr),\n+            ExprKind::Match(expr, arms) => {\n+                ExprKind::Match(folder.fold_expr(expr),\n                           arms.move_map(|x| folder.fold_arm(x)))\n             }\n-            ExprClosure(capture_clause, decl, body) => {\n-                ExprClosure(capture_clause,\n+            ExprKind::Closure(capture_clause, decl, body) => {\n+                ExprKind::Closure(capture_clause,\n                             folder.fold_fn_decl(decl),\n                             folder.fold_block(body))\n             }\n-            ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n-            ExprAssign(el, er) => {\n-                ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n+            ExprKind::Block(blk) => ExprKind::Block(folder.fold_block(blk)),\n+            ExprKind::Assign(el, er) => {\n+                ExprKind::Assign(folder.fold_expr(el), folder.fold_expr(er))\n             }\n-            ExprAssignOp(op, el, er) => {\n-                ExprAssignOp(op,\n+            ExprKind::AssignOp(op, el, er) => {\n+                ExprKind::AssignOp(op,\n                             folder.fold_expr(el),\n                             folder.fold_expr(er))\n             }\n-            ExprField(el, ident) => {\n-                ExprField(folder.fold_expr(el),\n+            ExprKind::Field(el, ident) => {\n+                ExprKind::Field(folder.fold_expr(el),\n                           respan(folder.new_span(ident.span),\n                                  folder.fold_ident(ident.node)))\n             }\n-            ExprTupField(el, ident) => {\n-                ExprTupField(folder.fold_expr(el),\n+            ExprKind::TupField(el, ident) => {\n+                ExprKind::TupField(folder.fold_expr(el),\n                              respan(folder.new_span(ident.span),\n                                     folder.fold_usize(ident.node)))\n             }\n-            ExprIndex(el, er) => {\n-                ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n+            ExprKind::Index(el, er) => {\n+                ExprKind::Index(folder.fold_expr(el), folder.fold_expr(er))\n             }\n-            ExprRange(e1, e2) => {\n-                ExprRange(e1.map(|x| folder.fold_expr(x)),\n+            ExprKind::Range(e1, e2) => {\n+                ExprKind::Range(e1.map(|x| folder.fold_expr(x)),\n                           e2.map(|x| folder.fold_expr(x)))\n             }\n-            ExprPath(qself, path) => {\n+            ExprKind::Path(qself, path) => {\n                 let qself = qself.map(|QSelf { ty, position }| {\n                     QSelf {\n                         ty: folder.fold_ty(ty),\n                         position: position\n                     }\n                 });\n-                ExprPath(qself, folder.fold_path(path))\n+                ExprKind::Path(qself, folder.fold_path(path))\n             }\n-            ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|label|\n+            ExprKind::Break(opt_ident) => ExprKind::Break(opt_ident.map(|label|\n                 respan(folder.new_span(label.span),\n                        folder.fold_ident(label.node)))\n             ),\n-            ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|label|\n+            ExprKind::Again(opt_ident) => ExprKind::Again(opt_ident.map(|label|\n                 respan(folder.new_span(label.span),\n                        folder.fold_ident(label.node)))\n             ),\n-            ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n-            ExprInlineAsm(InlineAsm {\n+            ExprKind::Ret(e) => ExprKind::Ret(e.map(|x| folder.fold_expr(x))),\n+            ExprKind::InlineAsm(InlineAsm {\n                 inputs,\n                 outputs,\n                 asm,\n@@ -1302,7 +1302,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 alignstack,\n                 dialect,\n                 expn_id,\n-            }) => ExprInlineAsm(InlineAsm {\n+            }) => ExprKind::InlineAsm(InlineAsm {\n                 inputs: inputs.move_map(|(c, input)| {\n                     (c, folder.fold_expr(input))\n                 }),\n@@ -1322,13 +1322,13 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 dialect: dialect,\n                 expn_id: expn_id,\n             }),\n-            ExprMac(mac) => ExprMac(folder.fold_mac(mac)),\n-            ExprStruct(path, fields, maybe_expr) => {\n-                ExprStruct(folder.fold_path(path),\n+            ExprKind::Mac(mac) => ExprKind::Mac(folder.fold_mac(mac)),\n+            ExprKind::Struct(path, fields, maybe_expr) => {\n+                ExprKind::Struct(folder.fold_path(path),\n                         fields.move_map(|x| folder.fold_field(x)),\n                         maybe_expr.map(|x| folder.fold_expr(x)))\n             },\n-            ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n+            ExprKind::Paren(ex) => ExprKind::Paren(folder.fold_expr(ex))\n         },\n         span: folder.new_span(span),\n         attrs: attrs.map_thin_attrs(|v| fold_attrs(v, folder)),\n@@ -1347,39 +1347,39 @@ pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n                                  -> SmallVector<P<Stmt>> {\n     let span = folder.new_span(span);\n     match node {\n-        StmtDecl(d, id) => {\n+        StmtKind::Decl(d, id) => {\n             let id = folder.new_id(id);\n             folder.fold_decl(d).into_iter().map(|d| P(Spanned {\n-                node: StmtDecl(d, id),\n+                node: StmtKind::Decl(d, id),\n                 span: span\n             })).collect()\n         }\n-        StmtExpr(e, id) => {\n+        StmtKind::Expr(e, id) => {\n             let id = folder.new_id(id);\n             if let Some(e) = folder.fold_opt_expr(e) {\n                 SmallVector::one(P(Spanned {\n-                    node: StmtExpr(e, id),\n+                    node: StmtKind::Expr(e, id),\n                     span: span\n                 }))\n             } else {\n                 SmallVector::zero()\n             }\n         }\n-        StmtSemi(e, id) => {\n+        StmtKind::Semi(e, id) => {\n             let id = folder.new_id(id);\n             if let Some(e) = folder.fold_opt_expr(e) {\n                 SmallVector::one(P(Spanned {\n-                    node: StmtSemi(e, id),\n+                    node: StmtKind::Semi(e, id),\n                     span: span\n                 }))\n             } else {\n                 SmallVector::zero()\n             }\n         }\n-        StmtMac(mac, semi, attrs) => SmallVector::one(P(Spanned {\n-            node: StmtMac(mac.map(|m| folder.fold_mac(m)),\n-                          semi,\n-                          attrs.map_thin_attrs(|v| fold_attrs(v, folder))),\n+        StmtKind::Mac(mac, semi, attrs) => SmallVector::one(P(Spanned {\n+            node: StmtKind::Mac(mac.map(|m| folder.fold_mac(m)),\n+                                semi,\n+                                attrs.map_thin_attrs(|v| fold_attrs(v, folder))),\n             span: span\n         }))\n     }"}, {"sha": "505e543a3fba3c51a00e72f9fdb8542dacb53a55", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -175,23 +175,23 @@ impl<'a> Parser<'a> {\n                 // FIXME #623 Non-string meta items are not serialized correctly;\n                 // just forbid them for now\n                 match lit.node {\n-                    ast::LitStr(..) => {}\n+                    ast::LitKind::Str(..) => {}\n                     _ => {\n                         self.span_err(lit.span,\n                                       \"non-string literals are not allowed in meta-items\");\n                     }\n                 }\n                 let hi = self.span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaNameValue(name, lit))))\n+                Ok(P(spanned(lo, hi, ast::MetaItemKind::NameValue(name, lit))))\n             }\n             token::OpenDelim(token::Paren) => {\n                 let inner_items = try!(self.parse_meta_seq());\n                 let hi = self.span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaList(name, inner_items))))\n+                Ok(P(spanned(lo, hi, ast::MetaItemKind::List(name, inner_items))))\n             }\n             _ => {\n                 let hi = self.last_span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaWord(name))))\n+                Ok(P(spanned(lo, hi, ast::MetaItemKind::Word(name))))\n             }\n         }\n     }"}, {"sha": "89110f3160fc9343fe24acafd6b003bc243e0faf", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -12,7 +12,7 @@\n \n // Predicates on exprs and stmts that the pretty-printer and parser use\n \n-use ast;\n+use ast::{self, BlockCheckMode};\n \n /// Does this expression require a semicolon to be treated\n /// as a statement? The negation of this: 'can this expression\n@@ -23,38 +23,38 @@ use ast;\n /// isn't parsed as (if true {...} else {...} | x) | 5\n pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n     match e.node {\n-        ast::ExprIf(..) |\n-        ast::ExprIfLet(..) |\n-        ast::ExprMatch(..) |\n-        ast::ExprBlock(_) |\n-        ast::ExprWhile(..) |\n-        ast::ExprWhileLet(..) |\n-        ast::ExprLoop(..) |\n-        ast::ExprForLoop(..) => false,\n+        ast::ExprKind::If(..) |\n+        ast::ExprKind::IfLet(..) |\n+        ast::ExprKind::Match(..) |\n+        ast::ExprKind::Block(_) |\n+        ast::ExprKind::While(..) |\n+        ast::ExprKind::WhileLet(..) |\n+        ast::ExprKind::Loop(..) |\n+        ast::ExprKind::ForLoop(..) => false,\n         _ => true,\n     }\n }\n \n pub fn expr_is_simple_block(e: &ast::Expr) -> bool {\n     match e.node {\n-        ast::ExprBlock(ref block) => block.rules == ast::DefaultBlock,\n+        ast::ExprKind::Block(ref block) => block.rules == BlockCheckMode::Default,\n         _ => false,\n     }\n }\n \n /// this statement requires a semicolon after it.\n /// note that in one case (stmt_semi), we've already\n /// seen the semicolon, and thus don't need another.\n-pub fn stmt_ends_with_semi(stmt: &ast::Stmt_) -> bool {\n+pub fn stmt_ends_with_semi(stmt: &ast::StmtKind) -> bool {\n     match *stmt {\n-        ast::StmtDecl(ref d, _) => {\n+        ast::StmtKind::Decl(ref d, _) => {\n             match d.node {\n-                ast::DeclLocal(_) => true,\n-                ast::DeclItem(_) => false,\n+                ast::DeclKind::Local(_) => true,\n+                ast::DeclKind::Item(_) => false,\n             }\n         }\n-        ast::StmtExpr(ref e, _) => expr_requires_semi_to_be_stmt(e),\n-        ast::StmtSemi(..) => false,\n-        ast::StmtMac(..) => false,\n+        ast::StmtKind::Expr(ref e, _) => expr_requires_semi_to_be_stmt(e),\n+        ast::StmtKind::Semi(..) => false,\n+        ast::StmtKind::Mac(..) => false,\n     }\n }"}, {"sha": "f7060296f1a7b3f29ad7f2e6c8088de72fc36f42", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 40, "deletions": 48, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -449,11 +449,11 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n }\n \n fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n-                      sd: &Handler, sp: Span) -> ast::Lit_ {\n+                      sd: &Handler, sp: Span) -> ast::LitKind {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n     match suffix.as_ref().map(|s| &**s) {\n-        Some(\"f32\") => ast::LitFloat(data, ast::TyF32),\n-        Some(\"f64\") => ast::LitFloat(data, ast::TyF64),\n+        Some(\"f32\") => ast::LitKind::Float(data, ast::FloatTy::F32),\n+        Some(\"f64\") => ast::LitKind::Float(data, ast::FloatTy::F64),\n         Some(suf) => {\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n@@ -466,13 +466,13 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n                   .emit();\n             }\n \n-            ast::LitFloatUnsuffixed(data)\n+            ast::LitKind::FloatUnsuffixed(data)\n         }\n-        None => ast::LitFloatUnsuffixed(data)\n+        None => ast::LitKind::FloatUnsuffixed(data)\n     }\n }\n pub fn float_lit(s: &str, suffix: Option<InternedString>,\n-                 sd: &Handler, sp: Span) -> ast::Lit_ {\n+                 sd: &Handler, sp: Span) -> ast::LitKind {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -576,7 +576,7 @@ pub fn integer_lit(s: &str,\n                    suffix: Option<InternedString>,\n                    sd: &Handler,\n                    sp: Span)\n-                   -> ast::Lit_ {\n+                   -> ast::LitKind {\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -586,7 +586,7 @@ pub fn integer_lit(s: &str,\n \n     let mut base = 10;\n     let orig = s;\n-    let mut ty = ast::UnsuffixedIntLit(ast::Plus);\n+    let mut ty = ast::LitIntType::Unsuffixed;\n \n     if char_at(s, 0) == '0' && s.len() > 1 {\n         match char_at(s, 1) {\n@@ -618,16 +618,16 @@ pub fn integer_lit(s: &str,\n     if let Some(ref suf) = suffix {\n         if suf.is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n         ty = match &**suf {\n-            \"isize\" => ast::SignedIntLit(ast::TyIs, ast::Plus),\n-            \"i8\"  => ast::SignedIntLit(ast::TyI8, ast::Plus),\n-            \"i16\" => ast::SignedIntLit(ast::TyI16, ast::Plus),\n-            \"i32\" => ast::SignedIntLit(ast::TyI32, ast::Plus),\n-            \"i64\" => ast::SignedIntLit(ast::TyI64, ast::Plus),\n-            \"usize\" => ast::UnsignedIntLit(ast::TyUs),\n-            \"u8\"  => ast::UnsignedIntLit(ast::TyU8),\n-            \"u16\" => ast::UnsignedIntLit(ast::TyU16),\n-            \"u32\" => ast::UnsignedIntLit(ast::TyU32),\n-            \"u64\" => ast::UnsignedIntLit(ast::TyU64),\n+            \"isize\" => ast::LitIntType::Signed(ast::IntTy::Is),\n+            \"i8\"  => ast::LitIntType::Signed(ast::IntTy::I8),\n+            \"i16\" => ast::LitIntType::Signed(ast::IntTy::I16),\n+            \"i32\" => ast::LitIntType::Signed(ast::IntTy::I32),\n+            \"i64\" => ast::LitIntType::Signed(ast::IntTy::I64),\n+            \"usize\" => ast::LitIntType::Unsigned(ast::UintTy::Us),\n+            \"u8\"  => ast::LitIntType::Unsigned(ast::UintTy::U8),\n+            \"u16\" => ast::LitIntType::Unsigned(ast::UintTy::U16),\n+            \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n+            \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n             _ => {\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n@@ -651,9 +651,9 @@ pub fn integer_lit(s: &str,\n     debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n            string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n-    let res = match u64::from_str_radix(s, base).ok() {\n-        Some(r) => r,\n-        None => {\n+    match u64::from_str_radix(s, base) {\n+        Ok(r) => ast::LitKind::Int(r, ty),\n+        Err(_) => {\n             // small bases are lexed as if they were base 10, e.g, the string\n             // might be `0b10201`. This will cause the conversion above to fail,\n             // but these cases have errors in the lexer: we don't want to emit\n@@ -665,16 +665,8 @@ pub fn integer_lit(s: &str,\n             if !already_errored {\n                 sd.span_err(sp, \"int literal is too large\");\n             }\n-            0\n+            ast::LitKind::Int(0, ty)\n         }\n-    };\n-\n-    // adjust the sign\n-    let sign = ast::Sign::new(res);\n-    match ty {\n-        ast::SignedIntLit(t, _) => ast::LitInt(res, ast::SignedIntLit(t, sign)),\n-        ast::UnsuffixedIntLit(_) => ast::LitInt(res, ast::UnsuffixedIntLit(sign)),\n-        us@ast::UnsignedIntLit(_) => ast::LitInt(res, us)\n     }\n }\n \n@@ -684,7 +676,7 @@ mod tests {\n     use std::rc::Rc;\n     use codemap::{Span, BytePos, Pos, Spanned, NO_EXPANSION};\n     use ast::{self, TokenTree};\n-    use abi;\n+    use abi::Abi;\n     use attr::{first_attr_value_str_by_name, AttrMetaMethods};\n     use parse;\n     use parse::parser::Parser;\n@@ -703,7 +695,7 @@ mod tests {\n         assert!(string_to_expr(\"a\".to_string()) ==\n                    P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n-                    node: ast::ExprPath(None, ast::Path {\n+                    node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n                         segments: vec!(\n@@ -722,7 +714,7 @@ mod tests {\n         assert!(string_to_expr(\"::a::b\".to_string()) ==\n                    P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: ast::ExprPath(None, ast::Path {\n+                    node: ast::ExprKind::Path(None, ast::Path {\n                             span: sp(0, 6),\n                             global: true,\n                             segments: vec!(\n@@ -852,9 +844,9 @@ mod tests {\n         assert!(string_to_expr(\"return d\".to_string()) ==\n                    P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n-                    node:ast::ExprRet(Some(P(ast::Expr{\n+                    node:ast::ExprKind::Ret(Some(P(ast::Expr{\n                         id: ast::DUMMY_NODE_ID,\n-                        node:ast::ExprPath(None, ast::Path{\n+                        node:ast::ExprKind::Path(None, ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n                             segments: vec!(\n@@ -875,9 +867,9 @@ mod tests {\n     #[test] fn parse_stmt_1 () {\n         assert!(string_to_stmt(\"b;\".to_string()) ==\n                    Some(P(Spanned{\n-                       node: ast::StmtExpr(P(ast::Expr {\n+                       node: ast::StmtKind::Expr(P(ast::Expr {\n                            id: ast::DUMMY_NODE_ID,\n-                           node: ast::ExprPath(None, ast::Path {\n+                           node: ast::ExprKind::Path(None, ast::Path {\n                                span:sp(0,1),\n                                global:false,\n                                segments: vec!(\n@@ -904,7 +896,7 @@ mod tests {\n         assert!(panictry!(parser.parse_pat())\n                 == P(ast::Pat{\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::PatIdent(ast::BindingMode::ByValue(ast::MutImmutable),\n+                node: ast::PatIdent(ast::BindingMode::ByValue(ast::Mutability::Immutable),\n                                     Spanned{ span:sp(0, 1),\n                                              node: str_to_ident(\"b\")\n                     },\n@@ -921,10 +913,10 @@ mod tests {\n                       P(ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n-                            node: ast::ItemFn(P(ast::FnDecl {\n+                            node: ast::ItemKind::Fn(P(ast::FnDecl {\n                                 inputs: vec!(ast::Arg{\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                  node: ast::TyPath(None, ast::Path{\n+                                                  node: ast::TyKind::Path(None, ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n                                         segments: vec!(\n@@ -940,7 +932,7 @@ mod tests {\n                                     pat: P(ast::Pat {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: ast::PatIdent(\n-                                            ast::BindingMode::ByValue(ast::MutImmutable),\n+                                            ast::BindingMode::ByValue(ast::Mutability::Immutable),\n                                                 Spanned{\n                                                     span: sp(6,7),\n                                                     node: str_to_ident(\"b\")},\n@@ -950,12 +942,12 @@ mod tests {\n                                     }),\n                                         id: ast::DUMMY_NODE_ID\n                                     }),\n-                                output: ast::DefaultReturn(sp(15, 15)),\n+                                output: ast::FunctionRetTy::Default(sp(15, 15)),\n                                 variadic: false\n                             }),\n                                     ast::Unsafety::Normal,\n                                     ast::Constness::NotConst,\n-                                    abi::Rust,\n+                                    Abi::Rust,\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),\n                                         ty_params: P::empty(),\n@@ -966,9 +958,9 @@ mod tests {\n                                     },\n                                     P(ast::Block {\n                                         stmts: vec!(P(Spanned{\n-                                            node: ast::StmtSemi(P(ast::Expr{\n+                                            node: ast::StmtKind::Semi(P(ast::Expr{\n                                                 id: ast::DUMMY_NODE_ID,\n-                                                node: ast::ExprPath(None,\n+                                                node: ast::ExprKind::Path(None,\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,\n@@ -988,10 +980,10 @@ mod tests {\n                                             span: sp(17,19)})),\n                                         expr: None,\n                                         id: ast::DUMMY_NODE_ID,\n-                                        rules: ast::DefaultBlock, // no idea\n+                                        rules: ast::BlockCheckMode::Default, // no idea\n                                         span: sp(15,21),\n                                     })),\n-                            vis: ast::Inherited,\n+                            vis: ast::Visibility::Inherited,\n                             span: sp(0,21)})));\n     }\n \n@@ -1110,7 +1102,7 @@ mod tests {\n             \"foo!( fn main() { body } )\".to_string(), vec![], &sess);\n \n         let tts = match expr.node {\n-            ast::ExprMac(ref mac) => mac.node.tts.clone(),\n+            ast::ExprKind::Mac(ref mac) => mac.node.tts.clone(),\n             _ => panic!(\"not a macro\"),\n         };\n "}, {"sha": "e985bfd37b0751b6797959cb47275f63276df76a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 267, "deletions": 274, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -10,53 +10,40 @@\n \n pub use self::PathParsingMode::*;\n \n-use abi;\n+use abi::{self, Abi};\n use ast::BareFnTy;\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n-use ast::{Public, Unsafety};\n-use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindingMode};\n-use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, Block};\n-use ast::{BlockCheckMode, CaptureByRef, CaptureByValue, CaptureClause};\n-use ast::{Constness, ConstTraitItem, Crate, CrateConfig};\n-use ast::{Decl, DeclItem, DeclLocal, DefaultBlock, DefaultReturn};\n-use ast::{UnDeref, BiDiv, EMPTY_CTXT, EnumDef, ExplicitSelf};\n-use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n-use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n-use ast::{ExprBreak, ExprCall, ExprCast, ExprInPlace};\n-use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex};\n-use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n-use ast::{ExprMethodCall, ExprParen, ExprPath};\n-use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprType, ExprUnary};\n-use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n-use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, FunctionRetTy};\n-use ast::{Ident, Inherited, ImplItem, Item, Item_, ItemStatic};\n-use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n-use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy, ItemDefaultImpl};\n-use ast::{ItemExternCrate, ItemUse};\n-use ast::{Lit, Lit_};\n-use ast::{LitBool, LitChar, LitByte, LitByteStr};\n-use ast::{LitStr, LitInt, Local};\n-use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n-use ast::{MutImmutable, MutMutable, Mac_};\n-use ast::{MutTy, BiMul, Mutability};\n-use ast::{NamedField, UnNeg, NoReturn, UnNot};\n+use ast::Unsafety;\n+use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n+use ast::Block;\n+use ast::{BlockCheckMode, CaptureBy};\n+use ast::{Constness, Crate, CrateConfig};\n+use ast::{Decl, DeclKind};\n+use ast::{EMPTY_CTXT, EnumDef, ExplicitSelf};\n+use ast::{Expr, ExprKind};\n+use ast::{Field, FnDecl};\n+use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n+use ast::{Ident, ImplItem, Item, ItemKind};\n+use ast::{Lit, LitKind, UintTy};\n+use ast::Local;\n+use ast::MacStmtStyle;\n+use ast::Mac_;\n+use ast::{MutTy, Mutability};\n+use ast::NamedField;\n use ast::{Pat, PatBox, PatEnum, PatIdent, PatLit, PatQPath, PatMac, PatRange};\n use ast::{PatRegion, PatStruct, PatTup, PatVec, PatWild};\n use ast::{PolyTraitRef, QSelf};\n-use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n-use ast::{StmtExpr, StmtSemi, StmtMac, VariantData, StructField};\n-use ast::{BiSub, StrStyle};\n-use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n+use ast::{Stmt, StmtKind};\n+use ast::{VariantData, StructField};\n+use ast::StrStyle;\n+use ast::SelfKind;\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n-use ast::{Ty, Ty_, TypeBinding, TyMac};\n-use ast::{TyFixedLengthVec, TyBareFn, TyTypeof, TyInfer};\n-use ast::{TyParam, TyParamBounds, TyParen, TyPath, TyPtr};\n-use ast::{TyRptr, TyTup, TyU32, TyVec};\n-use ast::TypeTraitItem;\n-use ast::{UnnamedField, UnsafeBlock};\n+use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n+use ast::UnnamedField;\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n+use ast::{BinOpKind, UnOp};\n use ast;\n use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n@@ -89,7 +76,7 @@ bitflags! {\n     }\n }\n \n-type ItemInfo = (Ident, Item_, Option<Vec<Attribute> >);\n+type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute> >);\n \n /// How to parse a path. There are four different kinds of paths, all of which\n /// are parsed somewhat differently.\n@@ -139,7 +126,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprPath(None, pt), None))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Path(None, pt), None))\n                 }\n                 token::Interpolated(token::NtBlock(_)) => {\n                     // FIXME: The following avoids an issue with lexical borrowck scopes,\n@@ -149,7 +136,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprBlock(b), None))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprKind::Block(b), None))\n                 }\n                 _ => None\n             };\n@@ -507,7 +494,7 @@ impl<'a> Parser<'a> {\n     pub fn commit_expr(&mut self, e: &Expr, edible: &[token::Token],\n                        inedible: &[token::Token]) -> PResult<'a, ()> {\n         debug!(\"commit_expr {:?}\", e);\n-        if let ExprPath(..) = e.node {\n+        if let ExprKind::Path(..) = e.node {\n             // might be unit-struct construction; check for recoverableinput error.\n             let expected = edible.iter()\n                 .cloned()\n@@ -587,11 +574,11 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let node = if self.eat_keyword(keywords::SelfValue) {\n             let rename = try!(self.parse_rename());\n-            ast::PathListMod { id: ast::DUMMY_NODE_ID, rename: rename }\n+            ast::PathListItemKind::Mod { id: ast::DUMMY_NODE_ID, rename: rename }\n         } else {\n             let ident = try!(self.parse_ident());\n             let rename = try!(self.parse_rename());\n-            ast::PathListIdent { name: ident, rename: rename, id: ast::DUMMY_NODE_ID }\n+            ast::PathListItemKind::Ident { name: ident, rename: rename, id: ast::DUMMY_NODE_ID }\n         };\n         let hi = self.last_span.hi;\n         Ok(spanned(lo, hi, node))\n@@ -1063,7 +1050,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_for_in_type(&mut self) -> PResult<'a, Ty_> {\n+    pub fn parse_for_in_type(&mut self) -> PResult<'a, TyKind> {\n         /*\n         Parses whatever can come after a `for` keyword in a type.\n         The `for` has already been consumed.\n@@ -1102,16 +1089,17 @@ impl<'a> Parser<'a> {\n                 Some(TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)).into_iter()\n                 .chain(other_bounds.into_vec())\n                 .collect();\n-            Ok(ast::TyPolyTraitRef(all_bounds))\n+            Ok(ast::TyKind::PolyTraitRef(all_bounds))\n         }\n     }\n \n-    pub fn parse_ty_path(&mut self) -> PResult<'a, Ty_> {\n-        Ok(TyPath(None, try!(self.parse_path(LifetimeAndTypesWithoutColons))))\n+    pub fn parse_ty_path(&mut self) -> PResult<'a, TyKind> {\n+        Ok(TyKind::Path(None, try!(self.parse_path(LifetimeAndTypesWithoutColons))))\n     }\n \n-    /// parse a TyBareFn type:\n-    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> PResult<'a, Ty_> {\n+    /// parse a TyKind::BareFn type:\n+    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<ast::LifetimeDef>)\n+                            -> PResult<'a, TyKind> {\n         /*\n \n         [unsafe] [extern \"ABI\"] fn <'lt> (S) -> T\n@@ -1126,9 +1114,9 @@ impl<'a> Parser<'a> {\n \n         let unsafety = try!(self.parse_unsafety());\n         let abi = if self.eat_keyword(keywords::Extern) {\n-            try!(self.parse_opt_abi()).unwrap_or(abi::C)\n+            try!(self.parse_opt_abi()).unwrap_or(Abi::C)\n         } else {\n-            abi::Rust\n+            Abi::Rust\n         };\n \n         try!(self.expect_keyword(keywords::Fn));\n@@ -1139,7 +1127,7 @@ impl<'a> Parser<'a> {\n             output: ret_ty,\n             variadic: variadic\n         });\n-        Ok(TyBareFn(P(BareFnTy {\n+        Ok(TyKind::BareFn(P(BareFnTy {\n             abi: abi,\n             unsafety: unsafety,\n             lifetimes: lifetime_defs,\n@@ -1199,7 +1187,7 @@ impl<'a> Parser<'a> {\n             let (name, node) = if p.eat_keyword(keywords::Type) {\n                 let TyParam {ident, bounds, default, ..} = try!(p.parse_ty_param());\n                 try!(p.expect(&token::Semi));\n-                (ident, TypeTraitItem(bounds, default))\n+                (ident, TraitItemKind::Type(bounds, default))\n             } else if p.is_const_item() {\n                 try!(p.expect_keyword(keywords::Const));\n                 let ident = try!(p.parse_ident());\n@@ -1214,7 +1202,7 @@ impl<'a> Parser<'a> {\n                     try!(p.expect(&token::Semi));\n                     None\n                 };\n-                (ident, ConstTraitItem(ty, default))\n+                (ident, TraitItemKind::Const(ty, default))\n             } else {\n                 let (constness, unsafety, abi) = try!(p.parse_fn_front_matter());\n \n@@ -1258,7 +1246,7 @@ impl<'a> Parser<'a> {\n                                        token_str)[..]))\n                   }\n                 };\n-                (ident, ast::MethodTraitItem(sig, body))\n+                (ident, ast::TraitItemKind::Method(sig, body))\n             };\n \n             Ok(P(TraitItem {\n@@ -1282,13 +1270,13 @@ impl<'a> Parser<'a> {\n     pub fn parse_ret_ty(&mut self) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n             if self.eat(&token::Not) {\n-                Ok(NoReturn(self.last_span))\n+                Ok(FunctionRetTy::None(self.last_span))\n             } else {\n-                Ok(Return(try!(self.parse_ty())))\n+                Ok(FunctionRetTy::Ty(try!(self.parse_ty())))\n             }\n         } else {\n             let pos = self.span.lo;\n-            Ok(DefaultReturn(mk_sp(pos, pos)))\n+            Ok(FunctionRetTy::Default(mk_sp(pos, pos)))\n         }\n     }\n \n@@ -1313,7 +1301,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let sp = mk_sp(lo, self.last_span.hi);\n-        let sum = ast::TyObjectSum(lhs, bounds);\n+        let sum = ast::TyKind::ObjectSum(lhs, bounds);\n         Ok(P(Ty {id: ast::DUMMY_NODE_ID, node: sum, span: sp}))\n     }\n \n@@ -1344,14 +1332,14 @@ impl<'a> Parser<'a> {\n \n             try!(self.expect(&token::CloseDelim(token::Paren)));\n             if ts.len() == 1 && !last_comma {\n-                TyParen(ts.into_iter().nth(0).unwrap())\n+                TyKind::Paren(ts.into_iter().nth(0).unwrap())\n             } else {\n-                TyTup(ts)\n+                TyKind::Tup(ts)\n             }\n         } else if self.check(&token::BinOp(token::Star)) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n-            TyPtr(try!(self.parse_ptr()))\n+            TyKind::Ptr(try!(self.parse_ptr()))\n         } else if self.check(&token::OpenDelim(token::Bracket)) {\n             // VECTOR\n             try!(self.expect(&token::OpenDelim(token::Bracket)));\n@@ -1360,8 +1348,8 @@ impl<'a> Parser<'a> {\n             // Parse the `; e` in `[ i32; e ]`\n             // where `e` is a const expression\n             let t = match try!(self.maybe_parse_fixed_length_of_vec()) {\n-                None => TyVec(t),\n-                Some(suffix) => TyFixedLengthVec(t, suffix)\n+                None => TyKind::Vec(t),\n+                Some(suffix) => TyKind::FixedLengthVec(t, suffix)\n             };\n             try!(self.expect(&token::CloseDelim(token::Bracket)));\n             t\n@@ -1381,13 +1369,13 @@ impl<'a> Parser<'a> {\n             try!(self.expect(&token::OpenDelim(token::Paren)));\n             let e = try!(self.parse_expr());\n             try!(self.expect(&token::CloseDelim(token::Paren)));\n-            TyTypeof(e)\n+            TyKind::Typeof(e)\n         } else if self.eat_lt() {\n \n             let (qself, path) =\n                  try!(self.parse_qualified_path(NoTypesAllowed));\n \n-            TyPath(Some(qself), path)\n+            TyKind::Path(Some(qself), path)\n         } else if self.check(&token::ModSep) ||\n                   self.token.is_ident() ||\n                   self.token.is_path() {\n@@ -1400,14 +1388,14 @@ impl<'a> Parser<'a> {\n                                                      seq_sep_none(),\n                                                      |p| p.parse_token_tree()));\n                 let hi = self.span.hi;\n-                TyMac(spanned(lo, hi, Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT }))\n+                TyKind::Mac(spanned(lo, hi, Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT }))\n             } else {\n                 // NAMED TYPE\n-                TyPath(None, path)\n+                TyKind::Path(None, path)\n             }\n         } else if self.eat(&token::Underscore) {\n             // TYPE TO BE INFERRED\n-            TyInfer\n+            TyKind::Infer\n         } else {\n             let this_token_str = self.this_token_to_string();\n             let msg = format!(\"expected type, found `{}`\", this_token_str);\n@@ -1418,26 +1406,26 @@ impl<'a> Parser<'a> {\n         Ok(P(Ty {id: ast::DUMMY_NODE_ID, node: t, span: sp}))\n     }\n \n-    pub fn parse_borrowed_pointee(&mut self) -> PResult<'a, Ty_> {\n+    pub fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = try!(self.parse_opt_lifetime());\n \n         let mt = try!(self.parse_mt());\n-        return Ok(TyRptr(opt_lifetime, mt));\n+        return Ok(TyKind::Rptr(opt_lifetime, mt));\n     }\n \n     pub fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n         let mutbl = if self.eat_keyword(keywords::Mut) {\n-            MutMutable\n+            Mutability::Mutable\n         } else if self.eat_keyword(keywords::Const) {\n-            MutImmutable\n+            Mutability::Immutable\n         } else {\n             let span = self.last_span;\n             self.span_err(span,\n                           \"bare raw pointers are no longer allowed, you should \\\n                            likely use `*mut T`, but otherwise `*T` is now \\\n                            known as `*const T`\");\n-            MutImmutable\n+            Mutability::Immutable\n         };\n         let t = try!(self.parse_ty());\n         Ok(MutTy { ty: t, mutbl: mutbl })\n@@ -1503,7 +1491,7 @@ impl<'a> Parser<'a> {\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: TyInfer,\n+                node: TyKind::Infer,\n                 span: mk_sp(self.span.lo, self.span.hi),\n             })\n         };\n@@ -1524,18 +1512,18 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches token_lit = LIT_INTEGER | ...\n-    pub fn lit_from_token(&self, tok: &token::Token) -> PResult<'a, Lit_> {\n+    pub fn lit_from_token(&self, tok: &token::Token) -> PResult<'a, LitKind> {\n         match *tok {\n             token::Interpolated(token::NtExpr(ref v)) => {\n                 match v.node {\n-                    ExprLit(ref lit) => { Ok(lit.node.clone()) }\n+                    ExprKind::Lit(ref lit) => { Ok(lit.node.clone()) }\n                     _ => { return self.unexpected_last(tok); }\n                 }\n             }\n             token::Literal(lit, suf) => {\n                 let (suffix_illegal, out) = match lit {\n-                    token::Byte(i) => (true, LitByte(parse::byte_lit(&i.as_str()).0)),\n-                    token::Char(i) => (true, LitChar(parse::char_lit(&i.as_str()).0)),\n+                    token::Byte(i) => (true, LitKind::Byte(parse::byte_lit(&i.as_str()).0)),\n+                    token::Char(i) => (true, LitKind::Char(parse::char_lit(&i.as_str()).0)),\n \n                     // there are some valid suffixes for integer and\n                     // float literals, so all the handling is done\n@@ -1555,20 +1543,20 @@ impl<'a> Parser<'a> {\n \n                     token::Str_(s) => {\n                         (true,\n-                         LitStr(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n-                                ast::CookedStr))\n+                         LitKind::Str(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n+                                      ast::StrStyle::Cooked))\n                     }\n                     token::StrRaw(s, n) => {\n                         (true,\n-                         LitStr(\n+                         LitKind::Str(\n                             token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n-                            ast::RawStr(n)))\n+                            ast::StrStyle::Raw(n)))\n                     }\n                     token::ByteStr(i) =>\n-                        (true, LitByteStr(parse::byte_str_lit(&i.as_str()))),\n+                        (true, LitKind::ByteStr(parse::byte_str_lit(&i.as_str()))),\n                     token::ByteStrRaw(i, _) =>\n                         (true,\n-                         LitByteStr(Rc::new(i.to_string().into_bytes()))),\n+                         LitKind::ByteStr(Rc::new(i.to_string().into_bytes()))),\n                 };\n \n                 if suffix_illegal {\n@@ -1586,9 +1574,9 @@ impl<'a> Parser<'a> {\n     pub fn parse_lit(&mut self) -> PResult<'a, Lit> {\n         let lo = self.span.lo;\n         let lit = if self.eat_keyword(keywords::True) {\n-            LitBool(true)\n+            LitKind::Bool(true)\n         } else if self.eat_keyword(keywords::False) {\n-            LitBool(false)\n+            LitKind::Bool(false)\n         } else {\n             let token = self.bump_and_get();\n             let lit = try!(self.lit_from_token(&token));\n@@ -1604,11 +1592,11 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let literal = P(try!(self.parse_lit()));\n         let hi = self.last_span.hi;\n-        let expr = self.mk_expr(lo, hi, ExprLit(literal), None);\n+        let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), None);\n \n         if minus_present {\n             let minus_hi = self.last_span.hi;\n-            let unary = self.mk_unary(UnNeg, expr);\n+            let unary = self.mk_unary(UnOp::Neg, expr);\n             Ok(self.mk_expr(minus_lo, minus_hi, unary, None))\n         } else {\n             Ok(expr)\n@@ -1935,9 +1923,9 @@ impl<'a> Parser<'a> {\n     /// Parse mutability declaration (mut/const/imm)\n     pub fn parse_mutability(&mut self) -> PResult<'a, Mutability> {\n         if self.eat_keyword(keywords::Mut) {\n-            Ok(MutMutable)\n+            Ok(Mutability::Mutable)\n         } else {\n-            Ok(MutImmutable)\n+            Ok(Mutability::Immutable)\n         }\n     }\n \n@@ -1956,7 +1944,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos,\n-                   node: Expr_, attrs: ThinAttributes) -> P<Expr> {\n+                   node: ExprKind, attrs: ThinAttributes) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n@@ -1965,55 +1953,55 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: P<Expr>) -> ast::Expr_ {\n-        ExprUnary(unop, expr)\n+    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: P<Expr>) -> ast::ExprKind {\n+        ExprKind::Unary(unop, expr)\n     }\n \n-    pub fn mk_binary(&mut self, binop: ast::BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ast::Expr_ {\n-        ExprBinary(binop, lhs, rhs)\n+    pub fn mk_binary(&mut self, binop: ast::BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n+        ExprKind::Binary(binop, lhs, rhs)\n     }\n \n-    pub fn mk_call(&mut self, f: P<Expr>, args: Vec<P<Expr>>) -> ast::Expr_ {\n-        ExprCall(f, args)\n+    pub fn mk_call(&mut self, f: P<Expr>, args: Vec<P<Expr>>) -> ast::ExprKind {\n+        ExprKind::Call(f, args)\n     }\n \n     fn mk_method_call(&mut self,\n                       ident: ast::SpannedIdent,\n                       tps: Vec<P<Ty>>,\n                       args: Vec<P<Expr>>)\n-                      -> ast::Expr_ {\n-        ExprMethodCall(ident, tps, args)\n+                      -> ast::ExprKind {\n+        ExprKind::MethodCall(ident, tps, args)\n     }\n \n-    pub fn mk_index(&mut self, expr: P<Expr>, idx: P<Expr>) -> ast::Expr_ {\n-        ExprIndex(expr, idx)\n+    pub fn mk_index(&mut self, expr: P<Expr>, idx: P<Expr>) -> ast::ExprKind {\n+        ExprKind::Index(expr, idx)\n     }\n \n     pub fn mk_range(&mut self,\n                     start: Option<P<Expr>>,\n                     end: Option<P<Expr>>)\n-                    -> ast::Expr_ {\n-        ExprRange(start, end)\n+                    -> ast::ExprKind {\n+        ExprKind::Range(start, end)\n     }\n \n-    pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::Expr_ {\n-        ExprField(expr, ident)\n+    pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::ExprKind {\n+        ExprKind::Field(expr, ident)\n     }\n \n-    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<usize>) -> ast::Expr_ {\n-        ExprTupField(expr, idx)\n+    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<usize>) -> ast::ExprKind {\n+        ExprKind::TupField(expr, idx)\n     }\n \n     pub fn mk_assign_op(&mut self, binop: ast::BinOp,\n-                        lhs: P<Expr>, rhs: P<Expr>) -> ast::Expr_ {\n-        ExprAssignOp(binop, lhs, rhs)\n+                        lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n+        ExprKind::AssignOp(binop, lhs, rhs)\n     }\n \n     pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos,\n                        m: Mac_, attrs: ThinAttributes) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n+            node: ExprKind::Mac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n             attrs: attrs,\n         })\n@@ -2022,13 +2010,13 @@ impl<'a> Parser<'a> {\n     pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinAttributes) -> P<Expr> {\n         let span = &self.span;\n         let lv_lit = P(codemap::Spanned {\n-            node: LitInt(i as u64, ast::UnsignedIntLit(TyU32)),\n+            node: LitKind::Int(i as u64, ast::LitIntType::Unsigned(UintTy::U32)),\n             span: *span\n         });\n \n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ExprLit(lv_lit),\n+            node: ExprKind::Lit(lv_lit),\n             span: *span,\n             attrs: attrs,\n         })\n@@ -2065,7 +2053,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n-        let ex: Expr_;\n+        let ex: ExprKind;\n \n         // Note: when adding new syntax here, don't forget to adjust Token::can_begin_expr().\n         match self.token {\n@@ -2097,25 +2085,25 @@ impl<'a> Parser<'a> {\n \n                 hi = self.last_span.hi;\n                 return if es.len() == 1 && !trailing_comma {\n-                    Ok(self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap()), attrs))\n+                    Ok(self.mk_expr(lo, hi, ExprKind::Paren(es.into_iter().nth(0).unwrap()), attrs))\n                 } else {\n-                    Ok(self.mk_expr(lo, hi, ExprTup(es), attrs))\n+                    Ok(self.mk_expr(lo, hi, ExprKind::Tup(es), attrs))\n                 }\n             },\n             token::OpenDelim(token::Brace) => {\n-                return self.parse_block_expr(lo, DefaultBlock, attrs);\n+                return self.parse_block_expr(lo, BlockCheckMode::Default, attrs);\n             },\n             token::BinOp(token::Or) |  token::OrOr => {\n                 let lo = self.span.lo;\n-                return self.parse_lambda_expr(lo, CaptureByRef, attrs);\n+                return self.parse_lambda_expr(lo, CaptureBy::Ref, attrs);\n             },\n             token::Ident(id @ ast::Ident {\n                             name: token::SELF_KEYWORD_NAME,\n                             ctxt: _\n                          }, token::Plain) => {\n                 self.bump();\n                 let path = ast_util::ident_to_path(mk_sp(lo, hi), id);\n-                ex = ExprPath(None, path);\n+                ex = ExprKind::Path(None, path);\n                 hi = self.last_span.hi;\n             }\n             token::OpenDelim(token::Bracket) => {\n@@ -2128,7 +2116,7 @@ impl<'a> Parser<'a> {\n                 if self.check(&token::CloseDelim(token::Bracket)) {\n                     // Empty vector.\n                     self.bump();\n-                    ex = ExprVec(Vec::new());\n+                    ex = ExprKind::Vec(Vec::new());\n                 } else {\n                     // Nonempty vector.\n                     let first_expr = try!(self.parse_expr());\n@@ -2137,7 +2125,7 @@ impl<'a> Parser<'a> {\n                         self.bump();\n                         let count = try!(self.parse_expr());\n                         try!(self.expect(&token::CloseDelim(token::Bracket)));\n-                        ex = ExprRepeat(first_expr, count);\n+                        ex = ExprKind::Repeat(first_expr, count);\n                     } else if self.check(&token::Comma) {\n                         // Vector with two or more elements.\n                         self.bump();\n@@ -2148,11 +2136,11 @@ impl<'a> Parser<'a> {\n                                 ));\n                         let mut exprs = vec!(first_expr);\n                         exprs.extend(remaining_exprs);\n-                        ex = ExprVec(exprs);\n+                        ex = ExprKind::Vec(exprs);\n                     } else {\n                         // Vector with one element.\n                         try!(self.expect(&token::CloseDelim(token::Bracket)));\n-                        ex = ExprVec(vec!(first_expr));\n+                        ex = ExprKind::Vec(vec!(first_expr));\n                     }\n                 }\n                 hi = self.last_span.hi;\n@@ -2162,11 +2150,11 @@ impl<'a> Parser<'a> {\n                     let (qself, path) =\n                         try!(self.parse_qualified_path(LifetimeAndTypesWithColons));\n                     hi = path.span.hi;\n-                    return Ok(self.mk_expr(lo, hi, ExprPath(Some(qself), path), attrs));\n+                    return Ok(self.mk_expr(lo, hi, ExprKind::Path(Some(qself), path), attrs));\n                 }\n                 if self.eat_keyword(keywords::Move) {\n                     let lo = self.last_span.lo;\n-                    return self.parse_lambda_expr(lo, CaptureByValue, attrs);\n+                    return self.parse_lambda_expr(lo, CaptureBy::Value, attrs);\n                 }\n                 if self.eat_keyword(keywords::If) {\n                     return self.parse_if_expr(attrs);\n@@ -2201,14 +2189,14 @@ impl<'a> Parser<'a> {\n                 }\n                 if self.eat_keyword(keywords::Continue) {\n                     let ex = if self.token.is_lifetime() {\n-                        let ex = ExprAgain(Some(Spanned{\n+                        let ex = ExprKind::Again(Some(Spanned{\n                             node: self.get_lifetime(),\n                             span: self.span\n                         }));\n                         self.bump();\n                         ex\n                     } else {\n-                        ExprAgain(None)\n+                        ExprKind::Again(None)\n                     };\n                     let hi = self.last_span.hi;\n                     return Ok(self.mk_expr(lo, hi, ex, attrs));\n@@ -2219,26 +2207,26 @@ impl<'a> Parser<'a> {\n                 if self.eat_keyword(keywords::Unsafe) {\n                     return self.parse_block_expr(\n                         lo,\n-                        UnsafeBlock(ast::UserProvided),\n+                        BlockCheckMode::Unsafe(ast::UserProvided),\n                         attrs);\n                 }\n                 if self.eat_keyword(keywords::Return) {\n                     if self.token.can_begin_expr() {\n                         let e = try!(self.parse_expr());\n                         hi = e.span.hi;\n-                        ex = ExprRet(Some(e));\n+                        ex = ExprKind::Ret(Some(e));\n                     } else {\n-                        ex = ExprRet(None);\n+                        ex = ExprKind::Ret(None);\n                     }\n                 } else if self.eat_keyword(keywords::Break) {\n                     if self.token.is_lifetime() {\n-                        ex = ExprBreak(Some(Spanned {\n+                        ex = ExprKind::Break(Some(Spanned {\n                             node: self.get_lifetime(),\n                             span: self.span\n                         }));\n                         self.bump();\n                     } else {\n-                        ex = ExprBreak(None);\n+                        ex = ExprKind::Break(None);\n                     }\n                     hi = self.last_span.hi;\n                 } else if self.token.is_keyword(keywords::Let) {\n@@ -2301,18 +2289,18 @@ impl<'a> Parser<'a> {\n \n                             hi = self.span.hi;\n                             try!(self.expect(&token::CloseDelim(token::Brace)));\n-                            ex = ExprStruct(pth, fields, base);\n+                            ex = ExprKind::Struct(pth, fields, base);\n                             return Ok(self.mk_expr(lo, hi, ex, attrs));\n                         }\n                     }\n \n                     hi = pth.span.hi;\n-                    ex = ExprPath(None, pth);\n+                    ex = ExprKind::Path(None, pth);\n                 } else {\n                     // other literal expression\n                     let lit = try!(self.parse_lit());\n                     hi = lit.span.hi;\n-                    ex = ExprLit(P(lit));\n+                    ex = ExprKind::Lit(P(lit));\n                 }\n             }\n         }\n@@ -2342,7 +2330,7 @@ impl<'a> Parser<'a> {\n         let attrs = outer_attrs.append(inner_attrs);\n \n         let blk = try!(self.parse_block_tail(lo, blk_mode));\n-        return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk), attrs));\n+        return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), attrs));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n@@ -2369,7 +2357,7 @@ impl<'a> Parser<'a> {\n             expr.map(|mut expr| {\n                 expr.attrs.update(|a| a.prepend(attrs));\n                 match expr.node {\n-                    ExprIf(..) | ExprIfLet(..) => {\n+                    ExprKind::If(..) | ExprKind::IfLet(..) => {\n                         if !expr.attrs.as_attr_slice().is_empty() {\n                             // Just point to the first attribute in there...\n                             let span = expr.attrs.as_attr_slice()[0].span;\n@@ -2610,11 +2598,11 @@ impl<'a> Parser<'a> {\n             match parser.token {\n                 token::BinOp(token::Star) => {\n                     parser.bump();\n-                    Ok(Some(ast::ZeroOrMore))\n+                    Ok(Some(ast::KleeneOp::ZeroOrMore))\n                 },\n                 token::BinOp(token::Plus) => {\n                     parser.bump();\n-                    Ok(Some(ast::OneOrMore))\n+                    Ok(Some(ast::KleeneOp::OneOrMore))\n                 },\n                 _ => Ok(None)\n             }\n@@ -2740,29 +2728,29 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = try!(self.interpolated_or_expr_span(e));\n                 hi = span.hi;\n-                self.mk_unary(UnNot, e)\n+                self.mk_unary(UnOp::Not, e)\n             }\n             token::BinOp(token::Minus) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = try!(self.interpolated_or_expr_span(e));\n                 hi = span.hi;\n-                self.mk_unary(UnNeg, e)\n+                self.mk_unary(UnOp::Neg, e)\n             }\n             token::BinOp(token::Star) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = try!(self.interpolated_or_expr_span(e));\n                 hi = span.hi;\n-                self.mk_unary(UnDeref, e)\n+                self.mk_unary(UnOp::Deref, e)\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n                 try!(self.expect_and());\n                 let m = try!(self.parse_mutability());\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = try!(self.interpolated_or_expr_span(e));\n                 hi = span.hi;\n-                ExprAddrOf(m, e)\n+                ExprKind::AddrOf(m, e)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 self.bump();\n@@ -2773,16 +2761,16 @@ impl<'a> Parser<'a> {\n                 let blk = try!(self.parse_block());\n                 let span = blk.span;\n                 hi = span.hi;\n-                let blk_expr = self.mk_expr(span.lo, span.hi, ExprBlock(blk),\n+                let blk_expr = self.mk_expr(span.lo, span.hi, ExprKind::Block(blk),\n                                             None);\n-                ExprInPlace(place, blk_expr)\n+                ExprKind::InPlace(place, blk_expr)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = try!(self.interpolated_or_expr_span(e));\n                 hi = span.hi;\n-                ExprBox(e)\n+                ExprKind::Box(e)\n             }\n             _ => return self.parse_dot_or_call_expr(Some(attrs))\n         };\n@@ -2849,12 +2837,12 @@ impl<'a> Parser<'a> {\n             if op == AssocOp::As {\n                 let rhs = try!(self.parse_ty());\n                 lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n-                                   ExprCast(lhs, rhs), None);\n+                                   ExprKind::Cast(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = try!(self.parse_ty());\n                 lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n-                                   ExprType(lhs, rhs), None);\n+                                   ExprKind::Type(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::DotDot {\n                     // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n@@ -2920,21 +2908,21 @@ impl<'a> Parser<'a> {\n                     self.mk_expr(lhs_span.lo, rhs_span.hi, binary, None)\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprAssign(lhs, rhs), None),\n+                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprKind::Assign(lhs, rhs), None),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprInPlace(lhs, rhs), None),\n+                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprKind::InPlace(lhs, rhs), None),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n-                        token::Plus =>    BiAdd,\n-                        token::Minus =>   BiSub,\n-                        token::Star =>    BiMul,\n-                        token::Slash =>   BiDiv,\n-                        token::Percent => BiRem,\n-                        token::Caret =>   BiBitXor,\n-                        token::And =>     BiBitAnd,\n-                        token::Or =>      BiBitOr,\n-                        token::Shl =>     BiShl,\n-                        token::Shr =>     BiShr\n+                        token::Plus =>    BinOpKind::Add,\n+                        token::Minus =>   BinOpKind::Sub,\n+                        token::Star =>    BinOpKind::Mul,\n+                        token::Slash =>   BinOpKind::Div,\n+                        token::Percent => BinOpKind::Rem,\n+                        token::Caret =>   BinOpKind::BitXor,\n+                        token::And =>     BinOpKind::BitAnd,\n+                        token::Or =>      BinOpKind::BitOr,\n+                        token::Shl =>     BinOpKind::Shl,\n+                        token::Shr =>     BinOpKind::Shr,\n                     };\n                     let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n@@ -2956,12 +2944,12 @@ impl<'a> Parser<'a> {\n     fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: &AssocOp) {\n         debug_assert!(outer_op.is_comparison());\n         match lhs.node {\n-            ExprBinary(op, _, _) if op.node.is_comparison() => {\n+            ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n                 let op_span = mk_sp(op.span.lo, self.span.hi);\n                 let mut err = self.diagnostic().struct_span_err(op_span,\n                     \"chained comparison operators require parentheses\");\n-                if op.node == BiLt && *outer_op == AssocOp::Greater {\n+                if op.node == BinOpKind::Lt && *outer_op == AssocOp::Greater {\n                     err.fileline_help(op_span,\n                         \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n                 }\n@@ -3023,7 +3011,7 @@ impl<'a> Parser<'a> {\n             hi = elexpr.span.hi;\n             els = Some(elexpr);\n         }\n-        Ok(self.mk_expr(lo, hi, ExprIf(cond, thn, els), attrs))\n+        Ok(self.mk_expr(lo, hi, ExprKind::If(cond, thn, els), attrs))\n     }\n \n     /// Parse an 'if let' expression ('if' token already eaten)\n@@ -3041,18 +3029,18 @@ impl<'a> Parser<'a> {\n         } else {\n             (thn.span.hi, None)\n         };\n-        Ok(self.mk_expr(lo, hi, ExprIfLet(pat, expr, thn, els), attrs))\n+        Ok(self.mk_expr(lo, hi, ExprKind::IfLet(pat, expr, thn, els), attrs))\n     }\n \n     // `|args| expr`\n     pub fn parse_lambda_expr(&mut self, lo: BytePos,\n-                             capture_clause: CaptureClause,\n+                             capture_clause: CaptureBy,\n                              attrs: ThinAttributes)\n                              -> PResult<'a, P<Expr>>\n     {\n         let decl = try!(self.parse_fn_block_decl());\n         let body = match decl.output {\n-            DefaultReturn(_) => {\n+            FunctionRetTy::Default(_) => {\n                 // If no explicit return type is given, parse any\n                 // expr and wrap it up in a dummy block:\n                 let body_expr = try!(self.parse_expr());\n@@ -3061,7 +3049,7 @@ impl<'a> Parser<'a> {\n                     stmts: vec![],\n                     span: body_expr.span,\n                     expr: Some(body_expr),\n-                    rules: DefaultBlock,\n+                    rules: BlockCheckMode::Default,\n                 })\n             }\n             _ => {\n@@ -3074,7 +3062,7 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(\n             lo,\n             body.span.hi,\n-            ExprClosure(capture_clause, decl, body), attrs))\n+            ExprKind::Closure(capture_clause, decl, body), attrs))\n     }\n \n     // `else` token already eaten\n@@ -3083,7 +3071,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_expr(None);\n         } else {\n             let blk = try!(self.parse_block());\n-            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk), None));\n+            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), None));\n         }\n     }\n \n@@ -3102,7 +3090,7 @@ impl<'a> Parser<'a> {\n         let hi = self.last_span.hi;\n \n         Ok(self.mk_expr(span_lo, hi,\n-                        ExprForLoop(pat, expr, loop_block, opt_ident),\n+                        ExprKind::ForLoop(pat, expr, loop_block, opt_ident),\n                         attrs))\n     }\n \n@@ -3117,7 +3105,7 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n         let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprWhile(cond, body, opt_ident),\n+        return Ok(self.mk_expr(span_lo, hi, ExprKind::While(cond, body, opt_ident),\n                                attrs));\n     }\n \n@@ -3132,7 +3120,7 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n         let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprWhileLet(pat, expr, body, opt_ident), attrs));\n+        return Ok(self.mk_expr(span_lo, hi, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n@@ -3142,7 +3130,7 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n         let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n-        Ok(self.mk_expr(span_lo, hi, ExprLoop(body, opt_ident), attrs))\n+        Ok(self.mk_expr(span_lo, hi, ExprKind::Loop(body, opt_ident), attrs))\n     }\n \n     // `match` token already eaten\n@@ -3166,7 +3154,7 @@ impl<'a> Parser<'a> {\n         }\n         let hi = self.span.hi;\n         self.bump();\n-        return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms), attrs));\n+        return Ok(self.mk_expr(lo, hi, ExprKind::Match(discriminant, arms), attrs));\n     }\n \n     pub fn parse_arm(&mut self) -> PResult<'a, Arm> {\n@@ -3361,10 +3349,10 @@ impl<'a> Parser<'a> {\n                 hi = self.last_span.hi;\n \n                 let bind_type = match (is_ref, is_mut) {\n-                    (true, true) => BindingMode::ByRef(MutMutable),\n-                    (true, false) => BindingMode::ByRef(MutImmutable),\n-                    (false, true) => BindingMode::ByValue(MutMutable),\n-                    (false, false) => BindingMode::ByValue(MutImmutable),\n+                    (true, true) => BindingMode::ByRef(Mutability::Mutable),\n+                    (true, false) => BindingMode::ByRef(Mutability::Immutable),\n+                    (false, true) => BindingMode::ByValue(Mutability::Mutable),\n+                    (false, false) => BindingMode::ByValue(Mutability::Immutable),\n                 };\n                 let fieldpath = codemap::Spanned{span:self.last_span, node:fieldname};\n                 let fieldpat = P(ast::Pat{\n@@ -3406,7 +3394,7 @@ impl<'a> Parser<'a> {\n                 (None, try!(self.parse_path(LifetimeAndTypesWithColons)))\n             };\n             let hi = self.last_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprPath(qself, path), None))\n+            Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), None))\n         } else {\n             self.parse_pat_literal_maybe_minus()\n         }\n@@ -3459,7 +3447,7 @@ impl<'a> Parser<'a> {\n             // At this point, token != _, &, &&, (, [\n             if self.eat_keyword(keywords::Mut) {\n                 // Parse mut ident @ pat\n-                pat = try!(self.parse_pat_ident(BindingMode::ByValue(MutMutable)));\n+                pat = try!(self.parse_pat_ident(BindingMode::ByValue(Mutability::Mutable)));\n             } else if self.eat_keyword(keywords::Ref) {\n                 // Parse ref ident @ pat / ref mut ident @ pat\n                 let mutbl = try!(self.parse_mutability());\n@@ -3492,7 +3480,8 @@ impl<'a> Parser<'a> {\n                         // Parse ident @ pat\n                         // This can give false positives and parse nullary enums,\n                         // they are dealt with later in resolve\n-                        pat = try!(self.parse_pat_ident(BindingMode::ByValue(MutImmutable)));\n+                        let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n+                        pat = try!(self.parse_pat_ident(binding_mode));\n                     }\n                 } else {\n                     let (qself, path) = if self.eat_lt() {\n@@ -3508,7 +3497,7 @@ impl<'a> Parser<'a> {\n                       token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n-                        let begin = self.mk_expr(lo, hi, ExprPath(qself, path), None);\n+                        let begin = self.mk_expr(lo, hi, ExprKind::Path(qself, path), None);\n                         self.bump();\n                         let end = try!(self.parse_pat_range_end());\n                         pat = PatRange(begin, end);\n@@ -3635,15 +3624,15 @@ impl<'a> Parser<'a> {\n     fn parse_let(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Decl>> {\n         let lo = self.span.lo;\n         let local = try!(self.parse_local(attrs));\n-        Ok(P(spanned(lo, self.last_span.hi, DeclLocal(local))))\n+        Ok(P(spanned(lo, self.last_span.hi, DeclKind::Local(local))))\n     }\n \n     /// Parse a structure field\n     fn parse_name_and_ty(&mut self, pr: Visibility,\n                          attrs: Vec<Attribute> ) -> PResult<'a, StructField> {\n         let lo = match pr {\n-            Inherited => self.span.lo,\n-            Public => self.last_span.lo,\n+            Visibility::Inherited => self.span.lo,\n+            Visibility::Public => self.last_span.lo,\n         };\n         if !self.token.is_plain_ident() {\n             return Err(self.fatal(\"expected ident\"));\n@@ -3686,7 +3675,7 @@ impl<'a> Parser<'a> {\n             try!(self.expect_keyword(keywords::Let));\n             let decl = try!(self.parse_let(attrs.into_thin_attrs()));\n             let hi = decl.span.hi;\n-            let stmt = StmtDecl(decl, ast::DUMMY_NODE_ID);\n+            let stmt = StmtKind::Decl(decl, ast::DUMMY_NODE_ID);\n             spanned(lo, hi, stmt)\n         } else if self.token.is_ident()\n             && !self.token.is_any_keyword()\n@@ -3732,23 +3721,20 @@ impl<'a> Parser<'a> {\n             let hi = self.last_span.hi;\n \n             let style = if delim == token::Brace {\n-                MacStmtWithBraces\n+                MacStmtStyle::Braces\n             } else {\n-                MacStmtWithoutBraces\n+                MacStmtStyle::NoBraces\n             };\n \n             if id.name == token::special_idents::invalid.name {\n-                let stmt = StmtMac(P(spanned(lo,\n-                                             hi,\n-                                             Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n-                                   style,\n-                                   attrs.into_thin_attrs());\n+                let mac = P(spanned(lo, hi, Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n+                let stmt = StmtKind::Mac(mac, style, attrs.into_thin_attrs());\n                 spanned(lo, hi, stmt)\n             } else {\n                 // if it has a special ident, it's definitely an item\n                 //\n                 // Require a semicolon or braces.\n-                if style != MacStmtWithBraces {\n+                if style != MacStmtStyle::Braces {\n                     if !self.eat(&token::Semi) {\n                         let last_span = self.last_span;\n                         self.span_err(last_span,\n@@ -3757,22 +3743,22 @@ impl<'a> Parser<'a> {\n                                        followed by a semicolon\");\n                     }\n                 }\n-                spanned(lo, hi, StmtDecl(\n-                    P(spanned(lo, hi, DeclItem(\n+                spanned(lo, hi, StmtKind::Decl(\n+                    P(spanned(lo, hi, DeclKind::Item(\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n-                            ItemMac(spanned(lo, hi,\n+                            ItemKind::Mac(spanned(lo, hi,\n                                             Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n-                            Inherited, attrs)))),\n+                            Visibility::Inherited, attrs)))),\n                     ast::DUMMY_NODE_ID))\n             }\n         } else {\n             // FIXME: Bad copy of attrs\n             match try!(self.parse_item_(attrs.clone(), false, true)) {\n                 Some(i) => {\n                     let hi = i.span.hi;\n-                    let decl = P(spanned(lo, hi, DeclItem(i)));\n-                    spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID))\n+                    let decl = P(spanned(lo, hi, DeclKind::Item(i)));\n+                    spanned(lo, hi, StmtKind::Decl(decl, ast::DUMMY_NODE_ID))\n                 }\n                 None => {\n                     let unused_attrs = |attrs: &[_], s: &mut Self| {\n@@ -3798,7 +3784,7 @@ impl<'a> Parser<'a> {\n                     let e = try!(self.parse_expr_res(\n                         Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into_thin_attrs())));\n                     let hi = e.span.hi;\n-                    let stmt = StmtExpr(e, ast::DUMMY_NODE_ID);\n+                    let stmt = StmtKind::Expr(e, ast::DUMMY_NODE_ID);\n                     spanned(lo, hi, stmt)\n                 }\n             }\n@@ -3825,7 +3811,7 @@ impl<'a> Parser<'a> {\n                                  \"place this code inside a block\"));\n         }\n \n-        self.parse_block_tail(lo, DefaultBlock)\n+        self.parse_block_tail(lo, BlockCheckMode::Default)\n     }\n \n     /// Parse a block. Inner attrs are allowed.\n@@ -3835,7 +3821,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n         Ok((try!(self.parse_inner_attributes()),\n-         try!(self.parse_block_tail(lo, DefaultBlock))))\n+         try!(self.parse_block_tail(lo, BlockCheckMode::Default))))\n     }\n \n     /// Parse the rest of a block expression or function body\n@@ -3852,16 +3838,16 @@ impl<'a> Parser<'a> {\n                 continue;\n             };\n             match node {\n-                StmtExpr(e, _) => {\n+                StmtKind::Expr(e, _) => {\n                     try!(self.handle_expression_like_statement(e, span, &mut stmts, &mut expr));\n                 }\n-                StmtMac(mac, MacStmtWithoutBraces, attrs) => {\n+                StmtKind::Mac(mac, MacStmtStyle::NoBraces, attrs) => {\n                     // statement macro without braces; might be an\n                     // expr depending on whether a semicolon follows\n                     match self.token {\n                         token::Semi => {\n                             stmts.push(P(Spanned {\n-                                node: StmtMac(mac, MacStmtWithSemicolon, attrs),\n+                                node: StmtKind::Mac(mac, MacStmtStyle::Semicolon, attrs),\n                                 span: mk_sp(span.lo, self.span.hi),\n                             }));\n                             self.bump();\n@@ -3881,12 +3867,12 @@ impl<'a> Parser<'a> {\n                         }\n                     }\n                 }\n-                StmtMac(m, style, attrs) => {\n+                StmtKind::Mac(m, style, attrs) => {\n                     // statement macro; might be an expr\n                     match self.token {\n                         token::Semi => {\n                             stmts.push(P(Spanned {\n-                                node: StmtMac(m, MacStmtWithSemicolon, attrs),\n+                                node: StmtKind::Mac(m, MacStmtStyle::Semicolon, attrs),\n                                 span: mk_sp(span.lo, self.span.hi),\n                             }));\n                             self.bump();\n@@ -3900,7 +3886,7 @@ impl<'a> Parser<'a> {\n                         }\n                         _ => {\n                             stmts.push(P(Spanned {\n-                                node: StmtMac(m, style, attrs),\n+                                node: StmtKind::Mac(m, style, attrs),\n                                 span: span\n                             }));\n                         }\n@@ -3952,14 +3938,14 @@ impl<'a> Parser<'a> {\n                     expn_id: span.expn_id,\n                 };\n                 stmts.push(P(Spanned {\n-                    node: StmtSemi(e, ast::DUMMY_NODE_ID),\n+                    node: StmtKind::Semi(e, ast::DUMMY_NODE_ID),\n                     span: span_with_semi,\n                 }));\n             }\n             token::CloseDelim(token::Brace) => *last_block_expr = Some(e),\n             _ => {\n                 stmts.push(P(Spanned {\n-                    node: StmtExpr(e, ast::DUMMY_NODE_ID),\n+                    node: StmtKind::Expr(e, ast::DUMMY_NODE_ID),\n                     span: span\n                 }));\n             }\n@@ -4410,7 +4396,7 @@ impl<'a> Parser<'a> {\n         F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n     {\n         fn maybe_parse_borrowed_explicit_self<'b>(this: &mut Parser<'b>)\n-                                                  -> PResult<'b,  ast::ExplicitSelf_> {\n+                                                  -> PResult<'b, ast::SelfKind> {\n             // The following things are possible to see here:\n             //\n             //     fn(&mut self)\n@@ -4422,26 +4408,27 @@ impl<'a> Parser<'a> {\n \n             if this.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                 this.bump();\n-                Ok(SelfRegion(None, MutImmutable, try!(this.expect_self_ident())))\n+                Ok(SelfKind::Region(None, Mutability::Immutable, try!(this.expect_self_ident())))\n             } else if this.look_ahead(1, |t| t.is_mutability()) &&\n                       this.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n                 this.bump();\n                 let mutability = try!(this.parse_mutability());\n-                Ok(SelfRegion(None, mutability, try!(this.expect_self_ident())))\n+                Ok(SelfKind::Region(None, mutability, try!(this.expect_self_ident())))\n             } else if this.look_ahead(1, |t| t.is_lifetime()) &&\n                       this.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n                 this.bump();\n                 let lifetime = try!(this.parse_lifetime());\n-                Ok(SelfRegion(Some(lifetime), MutImmutable, try!(this.expect_self_ident())))\n+                let ident = try!(this.expect_self_ident());\n+                Ok(SelfKind::Region(Some(lifetime), Mutability::Immutable, ident))\n             } else if this.look_ahead(1, |t| t.is_lifetime()) &&\n                       this.look_ahead(2, |t| t.is_mutability()) &&\n                       this.look_ahead(3, |t| t.is_keyword(keywords::SelfValue)) {\n                 this.bump();\n                 let lifetime = try!(this.parse_lifetime());\n                 let mutability = try!(this.parse_mutability());\n-                Ok(SelfRegion(Some(lifetime), mutability, try!(this.expect_self_ident())))\n+                Ok(SelfKind::Region(Some(lifetime), mutability, try!(this.expect_self_ident())))\n             } else {\n-                Ok(SelfStatic)\n+                Ok(SelfKind::Static)\n             }\n         }\n \n@@ -4453,7 +4440,7 @@ impl<'a> Parser<'a> {\n         let mut self_ident_lo = self.span.lo;\n         let mut self_ident_hi = self.span.hi;\n \n-        let mut mutbl_self = MutImmutable;\n+        let mut mutbl_self = Mutability::Immutable;\n         let explicit_self = match self.token {\n             token::BinOp(token::And) => {\n                 let eself = try!(maybe_parse_borrowed_explicit_self(self));\n@@ -4468,15 +4455,15 @@ impl<'a> Parser<'a> {\n                 let _mutability = if self.token.is_mutability() {\n                     try!(self.parse_mutability())\n                 } else {\n-                    MutImmutable\n+                    Mutability::Immutable\n                 };\n                 if self.is_self_ident() {\n                     let span = self.span;\n                     self.span_err(span, \"cannot pass self by raw pointer\");\n                     self.bump();\n                 }\n                 // error case, making bogus self ident:\n-                SelfValue(special_idents::self_)\n+                SelfKind::Value(special_idents::self_)\n             }\n             token::Ident(..) => {\n                 if self.is_self_ident() {\n@@ -4485,9 +4472,9 @@ impl<'a> Parser<'a> {\n                     // Determine whether this is the fully explicit form, `self:\n                     // TYPE`.\n                     if self.eat(&token::Colon) {\n-                        SelfExplicit(try!(self.parse_ty_sum()), self_ident)\n+                        SelfKind::Explicit(try!(self.parse_ty_sum()), self_ident)\n                     } else {\n-                        SelfValue(self_ident)\n+                        SelfKind::Value(self_ident)\n                     }\n                 } else if self.token.is_mutability() &&\n                         self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n@@ -4497,15 +4484,15 @@ impl<'a> Parser<'a> {\n                     // Determine whether this is the fully explicit form,\n                     // `self: TYPE`.\n                     if self.eat(&token::Colon) {\n-                        SelfExplicit(try!(self.parse_ty_sum()), self_ident)\n+                        SelfKind::Explicit(try!(self.parse_ty_sum()), self_ident)\n                     } else {\n-                        SelfValue(self_ident)\n+                        SelfKind::Value(self_ident)\n                     }\n                 } else {\n-                    SelfStatic\n+                    SelfKind::Static\n                 }\n             }\n-            _ => SelfStatic,\n+            _ => SelfKind::Static,\n         };\n \n         let explicit_self_sp = mk_sp(self_ident_lo, self_ident_hi);\n@@ -4541,14 +4528,14 @@ impl<'a> Parser<'a> {\n         }\n \n         let fn_inputs = match explicit_self {\n-            SelfStatic =>  {\n+            SelfKind::Static =>  {\n                 let sep = seq_sep_trailing_allowed(token::Comma);\n                 try!(self.parse_seq_to_before_end(&token::CloseDelim(token::Paren),\n                                                   sep, parse_arg_fn))\n             }\n-            SelfValue(id) => parse_remaining_arguments!(id),\n-            SelfRegion(_,_,id) => parse_remaining_arguments!(id),\n-            SelfExplicit(_,id) => parse_remaining_arguments!(id),\n+            SelfKind::Value(id) => parse_remaining_arguments!(id),\n+            SelfKind::Region(_,_,id) => parse_remaining_arguments!(id),\n+            SelfKind::Explicit(_,id) => parse_remaining_arguments!(id),\n         };\n \n \n@@ -4601,7 +4588,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n-               node: Item_, vis: Visibility,\n+               node: ItemKind, vis: Visibility,\n                attrs: Vec<Attribute>) -> P<Item> {\n         P(Item {\n             ident: ident,\n@@ -4623,7 +4610,7 @@ impl<'a> Parser<'a> {\n         let decl = try!(self.parse_fn_decl(false));\n         generics.where_clause = try!(self.parse_where_clause());\n         let (inner_attrs, body) = try!(self.parse_inner_attrs_and_block());\n-        Ok((ident, ItemFn(decl, unsafety, constness, abi, generics, body), Some(inner_attrs)))\n+        Ok((ident, ItemKind::Fn(decl, unsafety, constness, abi, generics, body), Some(inner_attrs)))\n     }\n \n     /// true if we are looking at `const ID`, false for things like `const fn` etc\n@@ -4646,12 +4633,12 @@ impl<'a> Parser<'a> {\n         let is_const_fn = self.eat_keyword(keywords::Const);\n         let unsafety = try!(self.parse_unsafety());\n         let (constness, unsafety, abi) = if is_const_fn {\n-            (Constness::Const, unsafety, abi::Rust)\n+            (Constness::Const, unsafety, Abi::Rust)\n         } else {\n             let abi = if self.eat_keyword(keywords::Extern) {\n-                try!(self.parse_opt_abi()).unwrap_or(abi::C)\n+                try!(self.parse_opt_abi()).unwrap_or(Abi::C)\n             } else {\n-                abi::Rust\n+                Abi::Rust\n             };\n             (Constness::NotConst, unsafety, abi)\n         };\n@@ -4699,7 +4686,7 @@ impl<'a> Parser<'a> {\n \n     fn complain_if_pub_macro(&mut self, visa: Visibility, span: Span) {\n         match visa {\n-            Public => {\n+            Visibility::Public => {\n                 let is_macro_rules: bool = match self.token {\n                     token::Ident(sid, _) => sid.name == intern(\"macro_rules\"),\n                     _ => false,\n@@ -4717,7 +4704,7 @@ impl<'a> Parser<'a> {\n                                      .emit();\n                 }\n             }\n-            Inherited => (),\n+            Visibility::Inherited => (),\n         }\n     }\n \n@@ -4783,7 +4770,7 @@ impl<'a> Parser<'a> {\n         tps.where_clause = try!(self.parse_where_clause());\n \n         let meths = try!(self.parse_trait_items());\n-        Ok((ident, ItemTrait(unsafety, tps, bounds, meths), None))\n+        Ok((ident, ItemKind::Trait(unsafety, tps, bounds, meths), None))\n     }\n \n     /// Parses items implementations variants\n@@ -4814,7 +4801,7 @@ impl<'a> Parser<'a> {\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             match ty.node {\n-                TyPath(None, ref path) => {\n+                TyKind::Path(None, ref path) => {\n                     Some(TraitRef {\n                         path: (*path).clone(),\n                         ref_id: ty.id,\n@@ -4846,7 +4833,7 @@ impl<'a> Parser<'a> {\n             try!(self.expect(&token::OpenDelim(token::Brace)));\n             try!(self.expect(&token::CloseDelim(token::Brace)));\n             Ok((ast_util::impl_pretty_name(&opt_trait, None),\n-             ItemDefaultImpl(unsafety, opt_trait.unwrap()), None))\n+             ItemKind::DefaultImpl(unsafety, opt_trait.unwrap()), None))\n         } else {\n             if opt_trait.is_some() {\n                 ty = try!(self.parse_ty_sum());\n@@ -4862,7 +4849,7 @@ impl<'a> Parser<'a> {\n             }\n \n             Ok((ast_util::impl_pretty_name(&opt_trait, Some(&*ty)),\n-             ItemImpl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n+             ItemKind::Impl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n              Some(attrs)))\n         }\n     }\n@@ -4947,7 +4934,7 @@ impl<'a> Parser<'a> {\n                                             name, found `{}`\", token_str)))\n         };\n \n-        Ok((class_name, ItemStruct(vdata, generics), None))\n+        Ok((class_name, ItemKind::Struct(vdata, generics), None))\n     }\n \n     pub fn parse_record_struct_body(&mut self,\n@@ -4987,7 +4974,7 @@ impl<'a> Parser<'a> {\n                         if parse_pub == ParsePub::Yes {\n                             try!(p.parse_visibility())\n                         } else {\n-                            Inherited\n+                            Visibility::Inherited\n                         }\n                     ),\n                     id: ast::DUMMY_NODE_ID,\n@@ -5033,16 +5020,16 @@ impl<'a> Parser<'a> {\n                 let span = self.last_span;\n                 self.span_err(span, \"`pub` is not allowed here\");\n             }\n-            return self.parse_single_struct_field(Public, attrs);\n+            return self.parse_single_struct_field(Visibility::Public, attrs);\n         }\n \n-        return self.parse_single_struct_field(Inherited, attrs);\n+        return self.parse_single_struct_field(Visibility::Inherited, attrs);\n     }\n \n     /// Parse visibility: PUB or nothing\n     fn parse_visibility(&mut self) -> PResult<'a, Visibility> {\n-        if self.eat_keyword(keywords::Pub) { Ok(Public) }\n-        else { Ok(Inherited) }\n+        if self.eat_keyword(keywords::Pub) { Ok(Visibility::Public) }\n+        else { Ok(Visibility::Inherited) }\n     }\n \n     /// Given a termination token, parse all of the items in a module\n@@ -5077,8 +5064,8 @@ impl<'a> Parser<'a> {\n         let e = try!(self.parse_expr());\n         try!(self.commit_expr_expecting(&*e, token::Semi));\n         let item = match m {\n-            Some(m) => ItemStatic(ty, m, e),\n-            None => ItemConst(ty, e),\n+            Some(m) => ItemKind::Static(ty, m, e),\n+            None => ItemKind::Const(ty, e),\n         };\n         Ok((id, item, None))\n     }\n@@ -5102,7 +5089,7 @@ impl<'a> Parser<'a> {\n             let m = try!(self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo));\n             self.owns_directory = old_owns_directory;\n             self.pop_mod_path();\n-            Ok((id, ItemMod(m), Some(attrs)))\n+            Ok((id, ItemKind::Mod(m), Some(attrs)))\n         }\n     }\n \n@@ -5208,7 +5195,7 @@ impl<'a> Parser<'a> {\n                     id: ast::Ident,\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n-                    -> PResult<'a, (ast::Item_, Vec<ast::Attribute> )> {\n+                    -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n         let ModulePathSuccess { path, owns_directory } = try!(self.submod_path(id,\n                                                                                outer_attrs,\n                                                                                id_sp));\n@@ -5223,7 +5210,7 @@ impl<'a> Parser<'a> {\n                               path: PathBuf,\n                               owns_directory: bool,\n                               name: String,\n-                              id_sp: Span) -> PResult<'a, (ast::Item_, Vec<ast::Attribute> )> {\n+                              id_sp: Span) -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         match included_mod_stack.iter().position(|p| *p == path) {\n             Some(i) => {\n@@ -5251,7 +5238,7 @@ impl<'a> Parser<'a> {\n         let mod_attrs = try!(p0.parse_inner_attributes());\n         let m0 = try!(p0.parse_mod_items(&token::Eof, mod_inner_lo));\n         self.sess.included_mod_stack.borrow_mut().pop();\n-        Ok((ast::ItemMod(m0), mod_attrs))\n+        Ok((ast::ItemKind::Mod(m0), mod_attrs))\n     }\n \n     /// Parse a function declaration from a foreign module\n@@ -5267,7 +5254,7 @@ impl<'a> Parser<'a> {\n         Ok(P(ast::ForeignItem {\n             ident: ident,\n             attrs: attrs,\n-            node: ForeignItemFn(decl, generics),\n+            node: ForeignItemKind::Fn(decl, generics),\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n             vis: vis\n@@ -5288,7 +5275,7 @@ impl<'a> Parser<'a> {\n         Ok(P(ForeignItem {\n             ident: ident,\n             attrs: attrs,\n-            node: ForeignItemStatic(ty, mutbl),\n+            node: ForeignItemKind::Static(ty, mutbl),\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n             vis: vis\n@@ -5317,7 +5304,7 @@ impl<'a> Parser<'a> {\n \n         let last_span = self.last_span;\n \n-        if visibility == ast::Public {\n+        if visibility == ast::Visibility::Public {\n             self.span_warn(mk_sp(lo, last_span.hi),\n                            \"`pub extern crate` does not work as expected and should not be used. \\\n                             Likely to become an error. Prefer `extern crate` and `pub use`.\");\n@@ -5326,7 +5313,7 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_item(lo,\n                         last_span.hi,\n                         ident,\n-                        ItemExternCrate(maybe_path),\n+                        ItemKind::ExternCrate(maybe_path),\n                         visibility,\n                         attrs))\n     }\n@@ -5349,7 +5336,7 @@ impl<'a> Parser<'a> {\n                               -> PResult<'a, P<Item>> {\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n \n-        let abi = opt_abi.unwrap_or(abi::C);\n+        let abi = opt_abi.unwrap_or(Abi::C);\n \n         attrs.extend(try!(self.parse_inner_attributes()));\n \n@@ -5367,7 +5354,7 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_item(lo,\n                      last_span.hi,\n                      special_idents::invalid,\n-                     ItemForeignMod(m),\n+                     ItemKind::ForeignMod(m),\n                      visibility,\n                      attrs))\n     }\n@@ -5380,7 +5367,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect(&token::Eq));\n         let ty = try!(self.parse_ty_sum());\n         try!(self.expect(&token::Semi));\n-        Ok((ident, ItemTy(ty, tps), None))\n+        Ok((ident, ItemKind::Ty(ty, tps), None))\n     }\n \n     /// Parse the part of an \"enum\" decl following the '{'\n@@ -5441,7 +5428,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n \n         let enum_definition = try!(self.parse_enum_def(&generics));\n-        Ok((id, ItemEnum(enum_definition, generics), None))\n+        Ok((id, ItemKind::Enum(enum_definition, generics), None))\n     }\n \n     /// Parses a string as an ABI spec on an extern type or module. Consumes\n@@ -5499,7 +5486,7 @@ impl<'a> Parser<'a> {\n \n         if self.eat_keyword(keywords::Use) {\n             // USE ITEM\n-            let item_ = ItemUse(try!(self.parse_view_path()));\n+            let item_ = ItemKind::Use(try!(self.parse_view_path()));\n             try!(self.expect(&token::Semi));\n \n             let last_span = self.last_span;\n@@ -5521,7 +5508,7 @@ impl<'a> Parser<'a> {\n \n             if self.eat_keyword(keywords::Fn) {\n                 // EXTERN FUNCTION ITEM\n-                let abi = opt_abi.unwrap_or(abi::C);\n+                let abi = opt_abi.unwrap_or(Abi::C);\n                 let (ident, item_, extra_attrs) =\n                     try!(self.parse_item_fn(Unsafety::Normal, Constness::NotConst, abi));\n                 let last_span = self.last_span;\n@@ -5541,7 +5528,11 @@ impl<'a> Parser<'a> {\n \n         if self.eat_keyword(keywords::Static) {\n             // STATIC ITEM\n-            let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n+            let m = if self.eat_keyword(keywords::Mut) {\n+                Mutability::Mutable\n+            } else {\n+                Mutability::Immutable\n+            };\n             let (ident, item_, extra_attrs) = try!(self.parse_item_const(Some(m)));\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n@@ -5564,7 +5555,7 @@ impl<'a> Parser<'a> {\n                 };\n                 self.bump();\n                 let (ident, item_, extra_attrs) =\n-                    try!(self.parse_item_fn(unsafety, Constness::Const, abi::Rust));\n+                    try!(self.parse_item_fn(unsafety, Constness::Const, Abi::Rust));\n                 let last_span = self.last_span;\n                 let item = self.mk_item(lo,\n                                         last_span.hi,\n@@ -5629,7 +5620,7 @@ impl<'a> Parser<'a> {\n             // FUNCTION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) =\n-                try!(self.parse_item_fn(Unsafety::Normal, Constness::NotConst, abi::Rust));\n+                try!(self.parse_item_fn(Unsafety::Normal, Constness::NotConst, Abi::Rust));\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -5644,9 +5635,9 @@ impl<'a> Parser<'a> {\n             // UNSAFE FUNCTION ITEM\n             self.bump();\n             let abi = if self.eat_keyword(keywords::Extern) {\n-                try!(self.parse_opt_abi()).unwrap_or(abi::C)\n+                try!(self.parse_opt_abi()).unwrap_or(Abi::C)\n             } else {\n-                abi::Rust\n+                Abi::Rust\n             };\n             try!(self.expect_keyword(keywords::Fn));\n             let (ident, item_, extra_attrs) =\n@@ -5815,7 +5806,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            let item_ = ItemMac(m);\n+            let item_ = ItemKind::Mac(m);\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -5828,8 +5819,8 @@ impl<'a> Parser<'a> {\n \n         // FAILURE TO PARSE ITEM\n         match visibility {\n-            Inherited => {}\n-            Public => {\n+            Visibility::Inherited => {}\n+            Visibility::Public => {\n                 let last_span = self.last_span;\n                 return Err(self.span_fatal(last_span, \"unmatched visibility `pub`\"));\n             }\n@@ -5975,10 +5966,12 @@ impl<'a> Parser<'a> {\n                                          Option<ast::Name>)> {\n         let ret = match self.token {\n             token::Literal(token::Str_(s), suf) => {\n-                (self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)), ast::CookedStr, suf)\n+                let s = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n+                (s, ast::StrStyle::Cooked, suf)\n             }\n             token::Literal(token::StrRaw(s, n), suf) => {\n-                (self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)), ast::RawStr(n), suf)\n+                let s = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n+                (s, ast::StrStyle::Raw(n), suf)\n             }\n             _ => return None\n         };"}, {"sha": "7d1b78b632f65eb3f477d7ec29656bc3a43b1830", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -15,7 +15,7 @@ pub use self::IdentStyle::*;\n pub use self::Lit::*;\n pub use self::Token::*;\n \n-use ast;\n+use ast::{self, BinOpKind};\n use ext::mtwt;\n use ptr::P;\n use util::interner::{RcStr, StrInterner};\n@@ -264,26 +264,26 @@ impl Token {\n     }\n \n     /// Maps a token to its corresponding binary operator.\n-    pub fn to_binop(&self) -> Option<ast::BinOp_> {\n+    pub fn to_binop(&self) -> Option<BinOpKind> {\n         match *self {\n-            BinOp(Star)     => Some(ast::BiMul),\n-            BinOp(Slash)    => Some(ast::BiDiv),\n-            BinOp(Percent)  => Some(ast::BiRem),\n-            BinOp(Plus)     => Some(ast::BiAdd),\n-            BinOp(Minus)    => Some(ast::BiSub),\n-            BinOp(Shl)      => Some(ast::BiShl),\n-            BinOp(Shr)      => Some(ast::BiShr),\n-            BinOp(And)      => Some(ast::BiBitAnd),\n-            BinOp(Caret)    => Some(ast::BiBitXor),\n-            BinOp(Or)       => Some(ast::BiBitOr),\n-            Lt              => Some(ast::BiLt),\n-            Le              => Some(ast::BiLe),\n-            Ge              => Some(ast::BiGe),\n-            Gt              => Some(ast::BiGt),\n-            EqEq            => Some(ast::BiEq),\n-            Ne              => Some(ast::BiNe),\n-            AndAnd          => Some(ast::BiAnd),\n-            OrOr            => Some(ast::BiOr),\n+            BinOp(Star)     => Some(BinOpKind::Mul),\n+            BinOp(Slash)    => Some(BinOpKind::Div),\n+            BinOp(Percent)  => Some(BinOpKind::Rem),\n+            BinOp(Plus)     => Some(BinOpKind::Add),\n+            BinOp(Minus)    => Some(BinOpKind::Sub),\n+            BinOp(Shl)      => Some(BinOpKind::Shl),\n+            BinOp(Shr)      => Some(BinOpKind::Shr),\n+            BinOp(And)      => Some(BinOpKind::BitAnd),\n+            BinOp(Caret)    => Some(BinOpKind::BitXor),\n+            BinOp(Or)       => Some(BinOpKind::BitOr),\n+            Lt              => Some(BinOpKind::Lt),\n+            Le              => Some(BinOpKind::Le),\n+            Ge              => Some(BinOpKind::Ge),\n+            Gt              => Some(BinOpKind::Gt),\n+            EqEq            => Some(BinOpKind::Eq),\n+            Ne              => Some(BinOpKind::Ne),\n+            AndAnd          => Some(BinOpKind::And),\n+            OrOr            => Some(BinOpKind::Or),\n             _               => None,\n         }\n     }"}, {"sha": "ab218971a51ee406302f6741fa210c22d55775bd", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 173, "deletions": 189, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -10,8 +10,8 @@\n \n pub use self::AnnNode::*;\n \n-use abi;\n-use ast::{self, TokenTree};\n+use abi::{self, Abi};\n+use ast::{self, TokenTree, BlockCheckMode};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n use attr::ThinAttributesExt;\n@@ -382,13 +382,13 @@ pub fn fun_to_string(decl: &ast::FnDecl,\n                      unsafety: ast::Unsafety,\n                      constness: ast::Constness,\n                      name: ast::Ident,\n-                     opt_explicit_self: Option<&ast::ExplicitSelf_>,\n+                     opt_explicit_self: Option<&ast::SelfKind>,\n                      generics: &ast::Generics)\n                      -> String {\n     to_string(|s| {\n         try!(s.head(\"\"));\n-        try!(s.print_fn(decl, unsafety, constness, abi::Rust, Some(name),\n-                        generics, opt_explicit_self, ast::Inherited));\n+        try!(s.print_fn(decl, unsafety, constness, Abi::Rust, Some(name),\n+                        generics, opt_explicit_self, ast::Visibility::Inherited));\n         try!(s.end()); // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -416,8 +416,8 @@ pub fn lit_to_string(l: &ast::Lit) -> String {\n     to_string(|s| s.print_literal(l))\n }\n \n-pub fn explicit_self_to_string(explicit_self: &ast::ExplicitSelf_) -> String {\n-    to_string(|s| s.print_explicit_self(explicit_self, ast::MutImmutable).map(|_| {}))\n+pub fn explicit_self_to_string(explicit_self: &ast::SelfKind) -> String {\n+    to_string(|s| s.print_explicit_self(explicit_self, ast::Mutability::Immutable).map(|_| {}))\n }\n \n pub fn variant_to_string(var: &ast::Variant) -> String {\n@@ -434,17 +434,17 @@ pub fn mac_to_string(arg: &ast::Mac) -> String {\n \n pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n     match vis {\n-        ast::Public => format!(\"pub {}\", s),\n-        ast::Inherited => s.to_string()\n+        ast::Visibility::Public => format!(\"pub {}\", s),\n+        ast::Visibility::Inherited => s.to_string()\n     }\n }\n \n fn needs_parentheses(expr: &ast::Expr) -> bool {\n     match expr.node {\n-        ast::ExprAssign(..) | ast::ExprBinary(..) |\n-        ast::ExprClosure(..) |\n-        ast::ExprAssignOp(..) | ast::ExprCast(..) |\n-        ast::ExprInPlace(..) | ast::ExprType(..) => true,\n+        ast::ExprKind::Assign(..) | ast::ExprKind::Binary(..) |\n+        ast::ExprKind::Closure(..) |\n+        ast::ExprKind::AssignOp(..) | ast::ExprKind::Cast(..) |\n+        ast::ExprKind::InPlace(..) | ast::ExprKind::Type(..) => true,\n         _ => false,\n     }\n }\n@@ -630,53 +630,45 @@ pub trait PrintState<'a> {\n             _ => ()\n         }\n         match lit.node {\n-            ast::LitStr(ref st, style) => self.print_string(&st, style),\n-            ast::LitByte(byte) => {\n+            ast::LitKind::Str(ref st, style) => self.print_string(&st, style),\n+            ast::LitKind::Byte(byte) => {\n                 let mut res = String::from(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n                 res.push('\\'');\n                 word(self.writer(), &res[..])\n             }\n-            ast::LitChar(ch) => {\n+            ast::LitKind::Char(ch) => {\n                 let mut res = String::from(\"'\");\n                 res.extend(ch.escape_default());\n                 res.push('\\'');\n                 word(self.writer(), &res[..])\n             }\n-            ast::LitInt(i, t) => {\n+            ast::LitKind::Int(i, t) => {\n                 match t {\n-                    ast::SignedIntLit(st, ast::Plus) => {\n+                    ast::LitIntType::Signed(st) => {\n                         word(self.writer(),\n                              &st.val_to_string(i as i64))\n                     }\n-                    ast::SignedIntLit(st, ast::Minus) => {\n-                        let istr = st.val_to_string(-(i as i64));\n-                        word(self.writer(),\n-                             &format!(\"-{}\", istr))\n-                    }\n-                    ast::UnsignedIntLit(ut) => {\n+                    ast::LitIntType::Unsigned(ut) => {\n                         word(self.writer(), &ut.val_to_string(i))\n                     }\n-                    ast::UnsuffixedIntLit(ast::Plus) => {\n+                    ast::LitIntType::Unsuffixed => {\n                         word(self.writer(), &format!(\"{}\", i))\n                     }\n-                    ast::UnsuffixedIntLit(ast::Minus) => {\n-                        word(self.writer(), &format!(\"-{}\", i))\n-                    }\n                 }\n             }\n-            ast::LitFloat(ref f, t) => {\n+            ast::LitKind::Float(ref f, t) => {\n                 word(self.writer(),\n                      &format!(\n                          \"{}{}\",\n                          &f,\n                          t.ty_to_string()))\n             }\n-            ast::LitFloatUnsuffixed(ref f) => word(self.writer(), &f[..]),\n-            ast::LitBool(val) => {\n+            ast::LitKind::FloatUnsuffixed(ref f) => word(self.writer(), &f[..]),\n+            ast::LitKind::Bool(val) => {\n                 if val { word(self.writer(), \"true\") } else { word(self.writer(), \"false\") }\n             }\n-            ast::LitByteStr(ref v) => {\n+            ast::LitKind::ByteStr(ref v) => {\n                 let mut escaped: String = String::new();\n                 for &ch in v.iter() {\n                     escaped.extend(ascii::escape_default(ch)\n@@ -690,10 +682,10 @@ pub trait PrintState<'a> {\n     fn print_string(&mut self, st: &str,\n                     style: ast::StrStyle) -> io::Result<()> {\n         let st = match style {\n-            ast::CookedStr => {\n+            ast::StrStyle::Cooked => {\n                 (format!(\"\\\"{}\\\"\", st.escape_default()))\n             }\n-            ast::RawStr(n) => {\n+            ast::StrStyle::Raw(n) => {\n                 (format!(\"r{delim}\\\"{string}\\\"{delim}\",\n                          delim=repeat(\"#\", n),\n                          string=st))\n@@ -774,15 +766,15 @@ pub trait PrintState<'a> {\n     fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n         try!(self.ibox(INDENT_UNIT));\n         match item.node {\n-            ast::MetaWord(ref name) => {\n+            ast::MetaItemKind::Word(ref name) => {\n                 try!(word(self.writer(), &name));\n             }\n-            ast::MetaNameValue(ref name, ref value) => {\n+            ast::MetaItemKind::NameValue(ref name, ref value) => {\n                 try!(self.word_space(&name[..]));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_literal(value));\n             }\n-            ast::MetaList(ref name, ref items) => {\n+            ast::MetaItemKind::List(ref name, ref items) => {\n                 try!(word(self.writer(), &name));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n@@ -965,25 +957,25 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ty.span.lo));\n         try!(self.ibox(0));\n         match ty.node {\n-            ast::TyVec(ref ty) => {\n+            ast::TyKind::Vec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_type(&**ty));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::TyPtr(ref mt) => {\n+            ast::TyKind::Ptr(ref mt) => {\n                 try!(word(&mut self.s, \"*\"));\n                 match mt.mutbl {\n-                    ast::MutMutable => try!(self.word_nbsp(\"mut\")),\n-                    ast::MutImmutable => try!(self.word_nbsp(\"const\")),\n+                    ast::Mutability::Mutable => try!(self.word_nbsp(\"mut\")),\n+                    ast::Mutability::Immutable => try!(self.word_nbsp(\"const\")),\n                 }\n                 try!(self.print_type(&*mt.ty));\n             }\n-            ast::TyRptr(ref lifetime, ref mt) => {\n+            ast::TyKind::Rptr(ref lifetime, ref mt) => {\n                 try!(word(&mut self.s, \"&\"));\n                 try!(self.print_opt_lifetime(lifetime));\n                 try!(self.print_mt(mt));\n             }\n-            ast::TyTup(ref elts) => {\n+            ast::TyKind::Tup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent, &elts[..],\n                                    |s, ty| s.print_type(&**ty)));\n@@ -992,12 +984,12 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.pclose());\n             }\n-            ast::TyParen(ref typ) => {\n+            ast::TyKind::Paren(ref typ) => {\n                 try!(self.popen());\n                 try!(self.print_type(&**typ));\n                 try!(self.pclose());\n             }\n-            ast::TyBareFn(ref f) => {\n+            ast::TyKind::BareFn(ref f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n                     ty_params: P::empty(),\n@@ -1013,35 +1005,35 @@ impl<'a> State<'a> {\n                                       &generics,\n                                       None));\n             }\n-            ast::TyPath(None, ref path) => {\n+            ast::TyKind::Path(None, ref path) => {\n                 try!(self.print_path(path, false, 0));\n             }\n-            ast::TyPath(Some(ref qself), ref path) => {\n+            ast::TyKind::Path(Some(ref qself), ref path) => {\n                 try!(self.print_qpath(path, qself, false))\n             }\n-            ast::TyObjectSum(ref ty, ref bounds) => {\n+            ast::TyKind::ObjectSum(ref ty, ref bounds) => {\n                 try!(self.print_type(&**ty));\n                 try!(self.print_bounds(\"+\", &bounds[..]));\n             }\n-            ast::TyPolyTraitRef(ref bounds) => {\n+            ast::TyKind::PolyTraitRef(ref bounds) => {\n                 try!(self.print_bounds(\"\", &bounds[..]));\n             }\n-            ast::TyFixedLengthVec(ref ty, ref v) => {\n+            ast::TyKind::FixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_type(&**ty));\n                 try!(word(&mut self.s, \"; \"));\n                 try!(self.print_expr(&**v));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::TyTypeof(ref e) => {\n+            ast::TyKind::Typeof(ref e) => {\n                 try!(word(&mut self.s, \"typeof(\"));\n                 try!(self.print_expr(&**e));\n                 try!(word(&mut self.s, \")\"));\n             }\n-            ast::TyInfer => {\n+            ast::TyKind::Infer => {\n                 try!(word(&mut self.s, \"_\"));\n             }\n-            ast::TyMac(ref m) => {\n+            ast::TyKind::Mac(ref m) => {\n                 try!(self.print_mac(m, token::Paren));\n             }\n         }\n@@ -1054,17 +1046,17 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(item.span.lo));\n         try!(self.print_outer_attributes(&item.attrs));\n         match item.node {\n-            ast::ForeignItemFn(ref decl, ref generics) => {\n+            ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_fn(decl, ast::Unsafety::Normal,\n                                    ast::Constness::NotConst,\n-                                   abi::Rust, Some(item.ident),\n+                                   Abi::Rust, Some(item.ident),\n                                    generics, None, item.vis));\n                 try!(self.end()); // end head-ibox\n                 try!(word(&mut self.s, \";\"));\n                 self.end() // end the outer fn box\n             }\n-            ast::ForeignItemStatic(ref t, m) => {\n+            ast::ForeignItemKind::Static(ref t, m) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"static\")));\n                 if m {\n@@ -1125,13 +1117,13 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(&item.attrs));\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n-            ast::ItemExternCrate(ref optional_path) => {\n+            ast::ItemKind::ExternCrate(ref optional_path) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"extern crate\")));\n                 if let Some(p) = *optional_path {\n                     let val = p.as_str();\n                     if val.contains(\"-\") {\n-                        try!(self.print_string(&val, ast::CookedStr));\n+                        try!(self.print_string(&val, ast::StrStyle::Cooked));\n                     } else {\n                         try!(self.print_name(p));\n                     }\n@@ -1144,18 +1136,18 @@ impl<'a> State<'a> {\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n             }\n-            ast::ItemUse(ref vp) => {\n+            ast::ItemKind::Use(ref vp) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"use\")));\n                 try!(self.print_view_path(&**vp));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n             }\n-            ast::ItemStatic(ref ty, m, ref expr) => {\n+            ast::ItemKind::Static(ref ty, m, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"static\")));\n-                if m == ast::MutMutable {\n+                if m == ast::Mutability::Mutable {\n                     try!(self.word_space(\"mut\"));\n                 }\n                 try!(self.print_ident(item.ident));\n@@ -1169,7 +1161,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n-            ast::ItemConst(ref ty, ref expr) => {\n+            ast::ItemKind::Const(ref ty, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"const\")));\n                 try!(self.print_ident(item.ident));\n@@ -1183,7 +1175,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n-            ast::ItemFn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n+            ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_fn(\n                     decl,\n@@ -1198,7 +1190,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.print_block_with_attrs(&**body, &item.attrs));\n             }\n-            ast::ItemMod(ref _mod) => {\n+            ast::ItemKind::Mod(ref _mod) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"mod\")));\n                 try!(self.print_ident(item.ident));\n@@ -1207,14 +1199,14 @@ impl<'a> State<'a> {\n                 try!(self.print_mod(_mod, &item.attrs));\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemForeignMod(ref nmod) => {\n+            ast::ItemKind::ForeignMod(ref nmod) => {\n                 try!(self.head(\"extern\"));\n                 try!(self.word_nbsp(&nmod.abi.to_string()));\n                 try!(self.bopen());\n                 try!(self.print_foreign_mod(nmod, &item.attrs));\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTy(ref ty, ref params) => {\n+            ast::ItemKind::Ty(ref ty, ref params) => {\n                 try!(self.ibox(INDENT_UNIT));\n                 try!(self.ibox(0));\n                 try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")));\n@@ -1229,7 +1221,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }\n-            ast::ItemEnum(ref enum_definition, ref params) => {\n+            ast::ItemKind::Enum(ref enum_definition, ref params) => {\n                 try!(self.print_enum_def(\n                     enum_definition,\n                     params,\n@@ -1238,12 +1230,12 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n             }\n-            ast::ItemStruct(ref struct_def, ref generics) => {\n+            ast::ItemKind::Struct(ref struct_def, ref generics) => {\n                 try!(self.head(&visibility_qualified(item.vis,\"struct\")));\n                 try!(self.print_struct(&struct_def, generics, item.ident, item.span, true));\n             }\n \n-            ast::ItemDefaultImpl(unsafety, ref trait_ref) => {\n+            ast::ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_unsafety(unsafety));\n@@ -1255,7 +1247,7 @@ impl<'a> State<'a> {\n                 try!(self.bopen());\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemImpl(unsafety,\n+            ast::ItemKind::Impl(unsafety,\n                           polarity,\n                           ref generics,\n                           ref opt_trait,\n@@ -1298,7 +1290,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTrait(unsafety, ref generics, ref bounds, ref trait_items) => {\n+            ast::ItemKind::Trait(unsafety, ref generics, ref bounds, ref trait_items) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_unsafety(unsafety));\n@@ -1324,7 +1316,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemMac(codemap::Spanned { ref node, .. }) => {\n+            ast::ItemKind::Mac(codemap::Spanned { ref node, .. }) => {\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_path(&node.path, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n@@ -1396,8 +1388,8 @@ impl<'a> State<'a> {\n \n     pub fn print_visibility(&mut self, vis: ast::Visibility) -> io::Result<()> {\n         match vis {\n-            ast::Public => self.word_nbsp(\"pub\"),\n-            ast::Inherited => Ok(())\n+            ast::Visibility::Public => self.word_nbsp(\"pub\"),\n+            ast::Visibility::Inherited => Ok(())\n         }\n     }\n \n@@ -1497,8 +1489,8 @@ impl<'a> State<'a> {\n                     None => {},\n                 }\n                 match seq.op {\n-                    ast::ZeroOrMore => word(&mut self.s, \"*\"),\n-                    ast::OneOrMore => word(&mut self.s, \"+\"),\n+                    ast::KleeneOp::ZeroOrMore => word(&mut self.s, \"*\"),\n+                    ast::KleeneOp::OneOrMore => word(&mut self.s, \"+\"),\n                 }\n             }\n         }\n@@ -1560,24 +1552,24 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ti.span.lo));\n         try!(self.print_outer_attributes(&ti.attrs));\n         match ti.node {\n-            ast::ConstTraitItem(ref ty, ref default) => {\n+            ast::TraitItemKind::Const(ref ty, ref default) => {\n                 try!(self.print_associated_const(ti.ident, &ty,\n                                                  default.as_ref().map(|expr| &**expr),\n-                                                 ast::Inherited));\n+                                                 ast::Visibility::Inherited));\n             }\n-            ast::MethodTraitItem(ref sig, ref body) => {\n+            ast::TraitItemKind::Method(ref sig, ref body) => {\n                 if body.is_some() {\n                     try!(self.head(\"\"));\n                 }\n-                try!(self.print_method_sig(ti.ident, sig, ast::Inherited));\n+                try!(self.print_method_sig(ti.ident, sig, ast::Visibility::Inherited));\n                 if let Some(ref body) = *body {\n                     try!(self.nbsp());\n                     try!(self.print_block_with_attrs(body, &ti.attrs));\n                 } else {\n                     try!(word(&mut self.s, \";\"));\n                 }\n             }\n-            ast::TypeTraitItem(ref bounds, ref default) => {\n+            ast::TraitItemKind::Type(ref bounds, ref default) => {\n                 try!(self.print_associated_type(ti.ident, Some(bounds),\n                                                 default.as_ref().map(|ty| &**ty)));\n             }\n@@ -1604,7 +1596,7 @@ impl<'a> State<'a> {\n                 try!(self.print_associated_type(ii.ident, None, Some(ty)));\n             }\n             ast::ImplItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n-                // code copied from ItemMac:\n+                // code copied from ItemKind::Mac:\n                 try!(self.print_path(&node.path, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.cbox(INDENT_UNIT));\n@@ -1621,28 +1613,28 @@ impl<'a> State<'a> {\n     pub fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n-            ast::StmtDecl(ref decl, _) => {\n+            ast::StmtKind::Decl(ref decl, _) => {\n                 try!(self.print_decl(&**decl));\n             }\n-            ast::StmtExpr(ref expr, _) => {\n+            ast::StmtKind::Expr(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.print_expr_outer_attr_style(&**expr, false));\n             }\n-            ast::StmtSemi(ref expr, _) => {\n+            ast::StmtKind::Semi(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.print_expr_outer_attr_style(&**expr, false));\n                 try!(word(&mut self.s, \";\"));\n             }\n-            ast::StmtMac(ref mac, style, ref attrs) => {\n+            ast::StmtKind::Mac(ref mac, style, ref attrs) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.print_outer_attributes(attrs.as_attr_slice()));\n                 let delim = match style {\n-                    ast::MacStmtWithBraces => token::Brace,\n+                    ast::MacStmtStyle::Braces => token::Brace,\n                     _ => token::Paren\n                 };\n                 try!(self.print_mac(&**mac, delim));\n                 match style {\n-                    ast::MacStmtWithBraces => {}\n+                    ast::MacStmtStyle::Braces => {}\n                     _ => try!(word(&mut self.s, \";\")),\n                 }\n             }\n@@ -1684,8 +1676,8 @@ impl<'a> State<'a> {\n                                       attrs: &[ast::Attribute],\n                                       close_box: bool) -> io::Result<()> {\n         match blk.rules {\n-            ast::UnsafeBlock(..) => try!(self.word_space(\"unsafe\")),\n-            ast::DefaultBlock => ()\n+            BlockCheckMode::Unsafe(..) => try!(self.word_space(\"unsafe\")),\n+            BlockCheckMode::Default => ()\n         }\n         try!(self.maybe_print_comment(blk.span.lo));\n         try!(self.ann.pre(self, NodeBlock(blk)));\n@@ -1713,7 +1705,7 @@ impl<'a> State<'a> {\n             Some(_else) => {\n                 match _else.node {\n                     // \"another else-if\"\n-                    ast::ExprIf(ref i, ref then, ref e) => {\n+                    ast::ExprKind::If(ref i, ref then, ref e) => {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if \"));\n@@ -1723,7 +1715,7 @@ impl<'a> State<'a> {\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"another else-if-let\"\n-                    ast::ExprIfLet(ref pat, ref expr, ref then, ref e) => {\n+                    ast::ExprKind::IfLet(ref pat, ref expr, ref then, ref e) => {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if let \"));\n@@ -1736,7 +1728,7 @@ impl<'a> State<'a> {\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n-                    ast::ExprBlock(ref b) => {\n+                    ast::ExprKind::Block(ref b) => {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else \"));\n@@ -1803,7 +1795,7 @@ impl<'a> State<'a> {\n     pub fn check_expr_bin_needs_paren(&mut self, sub_expr: &ast::Expr,\n                                       binop: ast::BinOp) -> bool {\n         match sub_expr.node {\n-            ast::ExprBinary(ref sub_op, _, _) => {\n+            ast::ExprKind::Binary(ref sub_op, _, _) => {\n                 if AssocOp::from_ast_binop(sub_op.node).precedence() <\n                     AssocOp::from_ast_binop(binop.node).precedence() {\n                     true\n@@ -1985,45 +1977,45 @@ impl<'a> State<'a> {\n         try!(self.ibox(INDENT_UNIT));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n-            ast::ExprBox(ref expr) => {\n+            ast::ExprKind::Box(ref expr) => {\n                 try!(self.word_space(\"box\"));\n                 try!(self.print_expr(expr));\n             }\n-            ast::ExprInPlace(ref place, ref expr) => {\n+            ast::ExprKind::InPlace(ref place, ref expr) => {\n                 try!(self.print_expr_in_place(place, expr));\n             }\n-            ast::ExprVec(ref exprs) => {\n+            ast::ExprKind::Vec(ref exprs) => {\n                 try!(self.print_expr_vec(&exprs[..], attrs));\n             }\n-            ast::ExprRepeat(ref element, ref count) => {\n+            ast::ExprKind::Repeat(ref element, ref count) => {\n                 try!(self.print_expr_repeat(&**element, &**count, attrs));\n             }\n-            ast::ExprStruct(ref path, ref fields, ref wth) => {\n+            ast::ExprKind::Struct(ref path, ref fields, ref wth) => {\n                 try!(self.print_expr_struct(path, &fields[..], wth, attrs));\n             }\n-            ast::ExprTup(ref exprs) => {\n+            ast::ExprKind::Tup(ref exprs) => {\n                 try!(self.print_expr_tup(&exprs[..], attrs));\n             }\n-            ast::ExprCall(ref func, ref args) => {\n+            ast::ExprKind::Call(ref func, ref args) => {\n                 try!(self.print_expr_call(&**func, &args[..]));\n             }\n-            ast::ExprMethodCall(ident, ref tys, ref args) => {\n+            ast::ExprKind::MethodCall(ident, ref tys, ref args) => {\n                 try!(self.print_expr_method_call(ident, &tys[..], &args[..]));\n             }\n-            ast::ExprBinary(op, ref lhs, ref rhs) => {\n+            ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr_binary(op, &**lhs, &**rhs));\n             }\n-            ast::ExprUnary(op, ref expr) => {\n+            ast::ExprKind::Unary(op, ref expr) => {\n                 try!(self.print_expr_unary(op, &**expr));\n             }\n-            ast::ExprAddrOf(m, ref expr) => {\n+            ast::ExprKind::AddrOf(m, ref expr) => {\n                 try!(self.print_expr_addr_of(m, &**expr));\n             }\n-            ast::ExprLit(ref lit) => {\n+            ast::ExprKind::Lit(ref lit) => {\n                 try!(self.print_literal(&**lit));\n             }\n-            ast::ExprCast(ref expr, ref ty) => {\n-                if let ast::ExprCast(..) = expr.node {\n+            ast::ExprKind::Cast(ref expr, ref ty) => {\n+                if let ast::ExprKind::Cast(..) = expr.node {\n                     try!(self.print_expr(&**expr));\n                 } else {\n                     try!(self.print_expr_maybe_paren(&**expr));\n@@ -2032,18 +2024,18 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"as\"));\n                 try!(self.print_type(&**ty));\n             }\n-            ast::ExprType(ref expr, ref ty) => {\n+            ast::ExprKind::Type(ref expr, ref ty) => {\n                 try!(self.print_expr(&**expr));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n             }\n-            ast::ExprIf(ref test, ref blk, ref elseopt) => {\n+            ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e)));\n             }\n-            ast::ExprIfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n+            ast::ExprKind::IfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n                 try!(self.print_if_let(&**pat, &**expr, &** blk, elseopt.as_ref().map(|e| &**e)));\n             }\n-            ast::ExprWhile(ref test, ref blk, opt_ident) => {\n+            ast::ExprKind::While(ref test, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n@@ -2053,7 +2045,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n-            ast::ExprWhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n+            ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n@@ -2066,7 +2058,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n-            ast::ExprForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n+            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n@@ -2079,7 +2071,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n-            ast::ExprLoop(ref blk, opt_ident) => {\n+            ast::ExprKind::Loop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n@@ -2088,7 +2080,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n-            ast::ExprMatch(ref expr, ref arms) => {\n+            ast::ExprKind::Match(ref expr, ref arms) => {\n                 try!(self.cbox(INDENT_UNIT));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));\n@@ -2101,14 +2093,14 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose_(expr.span, INDENT_UNIT));\n             }\n-            ast::ExprClosure(capture_clause, ref decl, ref body) => {\n+            ast::ExprKind::Closure(capture_clause, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n \n                 try!(self.print_fn_block_args(&**decl));\n                 try!(space(&mut self.s));\n \n                 let default_return = match decl.output {\n-                    ast::DefaultReturn(..) => true,\n+                    ast::FunctionRetTy::Default(..) => true,\n                     _ => false\n                 };\n \n@@ -2118,7 +2110,7 @@ impl<'a> State<'a> {\n                     // we extract the block, so as not to create another set of boxes\n                     let i_expr = body.expr.as_ref().unwrap();\n                     match i_expr.node {\n-                        ast::ExprBlock(ref blk) => {\n+                        ast::ExprKind::Block(ref blk) => {\n                             try!(self.print_block_unclosed_with_attrs(\n                                 &**blk,\n                                 i_expr.attrs.as_attr_slice()));\n@@ -2135,43 +2127,43 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 try!(self.ibox(0));\n             }\n-            ast::ExprBlock(ref blk) => {\n+            ast::ExprKind::Block(ref blk) => {\n                 // containing cbox, will be closed by print-block at }\n                 try!(self.cbox(INDENT_UNIT));\n                 // head-box, will be closed by print-block after {\n                 try!(self.ibox(0));\n                 try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n-            ast::ExprAssign(ref lhs, ref rhs) => {\n+            ast::ExprKind::Assign(ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n+            ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, op.node.to_string()));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprField(ref expr, id) => {\n+            ast::ExprKind::Field(ref expr, id) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(id.node));\n             }\n-            ast::ExprTupField(ref expr, id) => {\n+            ast::ExprKind::TupField(ref expr, id) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_usize(id.node));\n             }\n-            ast::ExprIndex(ref expr, ref index) => {\n+            ast::ExprKind::Index(ref expr, ref index) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_expr(&**index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::ExprRange(ref start, ref end) => {\n+            ast::ExprKind::Range(ref start, ref end) => {\n                 if let &Some(ref e) = start {\n                     try!(self.print_expr(&**e));\n                 }\n@@ -2180,29 +2172,29 @@ impl<'a> State<'a> {\n                     try!(self.print_expr(&**e));\n                 }\n             }\n-            ast::ExprPath(None, ref path) => {\n+            ast::ExprKind::Path(None, ref path) => {\n                 try!(self.print_path(path, true, 0))\n             }\n-            ast::ExprPath(Some(ref qself), ref path) => {\n+            ast::ExprKind::Path(Some(ref qself), ref path) => {\n                 try!(self.print_qpath(path, qself, true))\n             }\n-            ast::ExprBreak(opt_ident) => {\n+            ast::ExprKind::Break(opt_ident) => {\n                 try!(word(&mut self.s, \"break\"));\n                 try!(space(&mut self.s));\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident.node));\n                     try!(space(&mut self.s));\n                 }\n             }\n-            ast::ExprAgain(opt_ident) => {\n+            ast::ExprKind::Again(opt_ident) => {\n                 try!(word(&mut self.s, \"continue\"));\n                 try!(space(&mut self.s));\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident.node));\n                     try!(space(&mut self.s))\n                 }\n             }\n-            ast::ExprRet(ref result) => {\n+            ast::ExprKind::Ret(ref result) => {\n                 try!(word(&mut self.s, \"return\"));\n                 match *result {\n                     Some(ref expr) => {\n@@ -2212,7 +2204,7 @@ impl<'a> State<'a> {\n                     _ => ()\n                 }\n             }\n-            ast::ExprInlineAsm(ref a) => {\n+            ast::ExprKind::InlineAsm(ref a) => {\n                 try!(word(&mut self.s, \"asm!\"));\n                 try!(self.popen());\n                 try!(self.print_string(&a.asm, a.asm_str_style));\n@@ -2223,9 +2215,9 @@ impl<'a> State<'a> {\n                     match out.constraint.slice_shift_char() {\n                         Some(('=', operand)) if out.is_rw => {\n                             try!(s.print_string(&format!(\"+{}\", operand),\n-                                                ast::CookedStr))\n+                                                ast::StrStyle::Cooked))\n                         }\n-                        _ => try!(s.print_string(&out.constraint, ast::CookedStr))\n+                        _ => try!(s.print_string(&out.constraint, ast::StrStyle::Cooked))\n                     }\n                     try!(s.popen());\n                     try!(s.print_expr(&*out.expr));\n@@ -2237,7 +2229,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.inputs,\n                                    |s, &(ref co, ref o)| {\n-                    try!(s.print_string(&co, ast::CookedStr));\n+                    try!(s.print_string(&co, ast::StrStyle::Cooked));\n                     try!(s.popen());\n                     try!(s.print_expr(&**o));\n                     try!(s.pclose());\n@@ -2248,7 +2240,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.clobbers,\n                                    |s, co| {\n-                    try!(s.print_string(&co, ast::CookedStr));\n+                    try!(s.print_string(&co, ast::StrStyle::Cooked));\n                     Ok(())\n                 }));\n \n@@ -2268,15 +2260,15 @@ impl<'a> State<'a> {\n                     try!(self.word_space(\":\"));\n                     try!(self.commasep(Inconsistent, &*options,\n                                        |s, &co| {\n-                        try!(s.print_string(co, ast::CookedStr));\n+                        try!(s.print_string(co, ast::StrStyle::Cooked));\n                         Ok(())\n                     }));\n                 }\n \n                 try!(self.pclose());\n             }\n-            ast::ExprMac(ref m) => try!(self.print_mac(m, token::Paren)),\n-            ast::ExprParen(ref e) => {\n+            ast::ExprKind::Mac(ref m) => try!(self.print_mac(m, token::Paren)),\n+            ast::ExprKind::Paren(ref e) => {\n                 try!(self.popen());\n                 try!(self.print_inner_attributes_inline(attrs));\n                 try!(self.print_expr(&**e));\n@@ -2299,7 +2291,7 @@ impl<'a> State<'a> {\n     pub fn print_decl(&mut self, decl: &ast::Decl) -> io::Result<()> {\n         try!(self.maybe_print_comment(decl.span.lo));\n         match decl.node {\n-            ast::DeclLocal(ref loc) => {\n+            ast::DeclKind::Local(ref loc) => {\n                 try!(self.print_outer_attributes(loc.attrs.as_attr_slice()));\n                 try!(self.space_if_not_bol());\n                 try!(self.ibox(INDENT_UNIT));\n@@ -2315,7 +2307,7 @@ impl<'a> State<'a> {\n                 }\n                 self.end()\n             }\n-            ast::DeclItem(ref item) => self.print_item(&**item)\n+            ast::DeclKind::Item(ref item) => self.print_item(&**item)\n         }\n     }\n \n@@ -2472,8 +2464,8 @@ impl<'a> State<'a> {\n                         try!(self.word_nbsp(\"ref\"));\n                         try!(self.print_mutability(mutbl));\n                     }\n-                    ast::BindingMode::ByValue(ast::MutImmutable) => {}\n-                    ast::BindingMode::ByValue(ast::MutMutable) => {\n+                    ast::BindingMode::ByValue(ast::Mutability::Immutable) => {}\n+                    ast::BindingMode::ByValue(ast::Mutability::Mutable) => {\n                         try!(self.word_nbsp(\"mut\"));\n                     }\n                 }\n@@ -2542,7 +2534,7 @@ impl<'a> State<'a> {\n             }\n             ast::PatRegion(ref inner, mutbl) => {\n                 try!(word(&mut self.s, \"&\"));\n-                if mutbl == ast::MutMutable {\n+                if mutbl == ast::Mutability::Mutable {\n                     try!(word(&mut self.s, \"mut \"));\n                 }\n                 try!(self.print_pat(&**inner));\n@@ -2605,12 +2597,12 @@ impl<'a> State<'a> {\n         try!(self.word_space(\"=>\"));\n \n         match arm.body.node {\n-            ast::ExprBlock(ref blk) => {\n+            ast::ExprKind::Block(ref blk) => {\n                 // the block will close the pattern's ibox\n                 try!(self.print_block_unclosed_indent(&**blk, INDENT_UNIT));\n \n                 // If it is a user-provided unsafe block, print a comma after it\n-                if let ast::UnsafeBlock(ast::UserProvided) = blk.rules {\n+                if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n                     try!(word(&mut self.s, \",\"));\n                 }\n             }\n@@ -2625,21 +2617,21 @@ impl<'a> State<'a> {\n \n     // Returns whether it printed anything\n     fn print_explicit_self(&mut self,\n-                           explicit_self: &ast::ExplicitSelf_,\n+                           explicit_self: &ast::SelfKind,\n                            mutbl: ast::Mutability) -> io::Result<bool> {\n         try!(self.print_mutability(mutbl));\n         match *explicit_self {\n-            ast::SelfStatic => { return Ok(false); }\n-            ast::SelfValue(_) => {\n+            ast::SelfKind::Static => { return Ok(false); }\n+            ast::SelfKind::Value(_) => {\n                 try!(word(&mut self.s, \"self\"));\n             }\n-            ast::SelfRegion(ref lt, m, _) => {\n+            ast::SelfKind::Region(ref lt, m, _) => {\n                 try!(word(&mut self.s, \"&\"));\n                 try!(self.print_opt_lifetime(lt));\n                 try!(self.print_mutability(m));\n                 try!(word(&mut self.s, \"self\"));\n             }\n-            ast::SelfExplicit(ref typ, _) => {\n+            ast::SelfKind::Explicit(ref typ, _) => {\n                 try!(word(&mut self.s, \"self\"));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**typ));\n@@ -2655,7 +2647,7 @@ impl<'a> State<'a> {\n                     abi: abi::Abi,\n                     name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n-                    opt_explicit_self: Option<&ast::ExplicitSelf_>,\n+                    opt_explicit_self: Option<&ast::SelfKind>,\n                     vis: ast::Visibility) -> io::Result<()> {\n         try!(self.print_fn_header_info(unsafety, constness, abi, vis));\n \n@@ -2669,18 +2661,18 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_args(&mut self, decl: &ast::FnDecl,\n-                         opt_explicit_self: Option<&ast::ExplicitSelf_>,\n+                         opt_explicit_self: Option<&ast::SelfKind>,\n                          is_closure: bool) -> io::Result<()> {\n         // It is unfortunate to duplicate the commasep logic, but we want the\n         // self type and the args all in the same box.\n         try!(self.rbox(0, Inconsistent));\n         let mut first = true;\n         if let Some(explicit_self) = opt_explicit_self {\n             let m = match *explicit_self {\n-                ast::SelfStatic => ast::MutImmutable,\n+                ast::SelfKind::Static => ast::Mutability::Immutable,\n                 _ => match decl.inputs[0].pat.node {\n                     ast::PatIdent(ast::BindingMode::ByValue(m), _, _) => m,\n-                    _ => ast::MutImmutable\n+                    _ => ast::Mutability::Immutable\n                 }\n             };\n             first = !try!(self.print_explicit_self(explicit_self, m));\n@@ -2702,7 +2694,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl,\n-                                 opt_explicit_self: Option<&ast::ExplicitSelf_>)\n+                                 opt_explicit_self: Option<&ast::SelfKind>)\n         -> io::Result<()> {\n         try!(self.popen());\n         try!(self.print_fn_args(decl, opt_explicit_self, false));\n@@ -2722,30 +2714,30 @@ impl<'a> State<'a> {\n         try!(self.print_fn_args(decl, None, true));\n         try!(word(&mut self.s, \"|\"));\n \n-        if let ast::DefaultReturn(..) = decl.output {\n+        if let ast::FunctionRetTy::Default(..) = decl.output {\n             return Ok(());\n         }\n \n         try!(self.space_if_not_bol());\n         try!(self.word_space(\"->\"));\n         match decl.output {\n-            ast::Return(ref ty) => {\n+            ast::FunctionRetTy::Ty(ref ty) => {\n                 try!(self.print_type(&**ty));\n                 self.maybe_print_comment(ty.span.lo)\n             }\n-            ast::DefaultReturn(..) => unreachable!(),\n-            ast::NoReturn(span) => {\n+            ast::FunctionRetTy::Default(..) => unreachable!(),\n+            ast::FunctionRetTy::None(span) => {\n                 try!(self.word_nbsp(\"!\"));\n                 self.maybe_print_comment(span.lo)\n             }\n         }\n     }\n \n-    pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureClause)\n+    pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy)\n                                 -> io::Result<()> {\n         match capture_clause {\n-            ast::CaptureByValue => self.word_space(\"move\"),\n-            ast::CaptureByRef => Ok(()),\n+            ast::CaptureBy::Value => self.word_space(\"move\"),\n+            ast::CaptureBy::Ref => Ok(()),\n         }\n     }\n \n@@ -2926,7 +2918,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.commasep(Inconsistent, &idents[..], |s, w| {\n                     match w.node {\n-                        ast::PathListIdent { name, rename, .. } => {\n+                        ast::PathListItemKind::Ident { name, rename, .. } => {\n                             try!(s.print_ident(name));\n                             if let Some(ident) = rename {\n                                 try!(space(&mut s.s));\n@@ -2935,7 +2927,7 @@ impl<'a> State<'a> {\n                             }\n                             Ok(())\n                         },\n-                        ast::PathListMod { rename, .. } => {\n+                        ast::PathListItemKind::Mod { rename, .. } => {\n                             try!(word(&mut s.s, \"self\"));\n                             if let Some(ident) = rename {\n                                 try!(space(&mut s.s));\n@@ -2954,8 +2946,8 @@ impl<'a> State<'a> {\n     pub fn print_mutability(&mut self,\n                             mutbl: ast::Mutability) -> io::Result<()> {\n         match mutbl {\n-            ast::MutMutable => self.word_nbsp(\"mut\"),\n-            ast::MutImmutable => Ok(()),\n+            ast::Mutability::Mutable => self.word_nbsp(\"mut\"),\n+            ast::Mutability::Immutable => Ok(()),\n         }\n     }\n \n@@ -2967,7 +2959,7 @@ impl<'a> State<'a> {\n     pub fn print_arg(&mut self, input: &ast::Arg, is_closure: bool) -> io::Result<()> {\n         try!(self.ibox(INDENT_UNIT));\n         match input.ty.node {\n-            ast::TyInfer if is_closure => try!(self.print_pat(&*input.pat)),\n+            ast::TyKind::Infer if is_closure => try!(self.print_pat(&*input.pat)),\n             _ => {\n                 match input.pat.node {\n                     ast::PatIdent(_, ref path1, _) if\n@@ -2988,24 +2980,24 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_output(&mut self, decl: &ast::FnDecl) -> io::Result<()> {\n-        if let ast::DefaultReturn(..) = decl.output {\n+        if let ast::FunctionRetTy::Default(..) = decl.output {\n             return Ok(());\n         }\n \n         try!(self.space_if_not_bol());\n         try!(self.ibox(INDENT_UNIT));\n         try!(self.word_space(\"->\"));\n         match decl.output {\n-            ast::NoReturn(_) =>\n+            ast::FunctionRetTy::None(_) =>\n                 try!(self.word_nbsp(\"!\")),\n-            ast::DefaultReturn(..) => unreachable!(),\n-            ast::Return(ref ty) =>\n+            ast::FunctionRetTy::Default(..) => unreachable!(),\n+            ast::FunctionRetTy::Ty(ref ty) =>\n                 try!(self.print_type(&**ty))\n         }\n         try!(self.end());\n \n         match decl.output {\n-            ast::Return(ref output) => self.maybe_print_comment(output.span.lo),\n+            ast::FunctionRetTy::Ty(ref output) => self.maybe_print_comment(output.span.lo),\n             _ => Ok(())\n         }\n     }\n@@ -3016,7 +3008,7 @@ impl<'a> State<'a> {\n                        decl: &ast::FnDecl,\n                        name: Option<ast::Ident>,\n                        generics: &ast::Generics,\n-                       opt_explicit_self: Option<&ast::ExplicitSelf_>)\n+                       opt_explicit_self: Option<&ast::SelfKind>)\n                        -> io::Result<()> {\n         try!(self.ibox(INDENT_UNIT));\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n@@ -3038,7 +3030,7 @@ impl<'a> State<'a> {\n                            name,\n                            &generics,\n                            opt_explicit_self,\n-                           ast::Inherited));\n+                           ast::Visibility::Inherited));\n         self.end()\n     }\n \n@@ -3086,10 +3078,10 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n-                                                  opt_abi: Option<abi::Abi>)\n+                                                  opt_abi: Option<Abi>)\n         -> io::Result<()> {\n         match opt_abi {\n-            Some(abi::Rust) => Ok(()),\n+            Some(Abi::Rust) => Ok(()),\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n                 self.word_nbsp(&abi.to_string())\n@@ -3099,7 +3091,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_extern_opt_abi(&mut self,\n-                                opt_abi: Option<abi::Abi>) -> io::Result<()> {\n+                                opt_abi: Option<Abi>) -> io::Result<()> {\n         match opt_abi {\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n@@ -3112,7 +3104,7 @@ impl<'a> State<'a> {\n     pub fn print_fn_header_info(&mut self,\n                                 unsafety: ast::Unsafety,\n                                 constness: ast::Constness,\n-                                abi: abi::Abi,\n+                                abi: Abi,\n                                 vis: ast::Visibility) -> io::Result<()> {\n         try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n \n@@ -3123,7 +3115,7 @@ impl<'a> State<'a> {\n \n         try!(self.print_unsafety(unsafety));\n \n-        if abi != abi::Rust {\n+        if abi != Abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n             try!(self.word_nbsp(&abi.to_string()));\n         }\n@@ -3155,7 +3147,7 @@ mod tests {\n \n         let decl = ast::FnDecl {\n             inputs: Vec::new(),\n-            output: ast::DefaultReturn(codemap::DUMMY_SP),\n+            output: ast::FunctionRetTy::Default(codemap::DUMMY_SP),\n             variadic: false\n         };\n         let generics = ast::Generics::default();\n@@ -3181,12 +3173,4 @@ mod tests {\n         let varstr = variant_to_string(&var);\n         assert_eq!(varstr, \"principal_skinner\");\n     }\n-\n-    #[test]\n-    fn test_signed_int_to_string() {\n-        let pos_int = ast::LitInt(42, ast::SignedIntLit(ast::TyI32, ast::Plus));\n-        let neg_int = ast::LitInt((!42 + 1) as u64, ast::SignedIntLit(ast::TyI32, ast::Minus));\n-        assert_eq!(format!(\"-{}\", lit_to_string(&codemap::dummy_spanned(pos_int))),\n-                   lit_to_string(&codemap::dummy_spanned(neg_int)));\n-    }\n }"}, {"sha": "6190cf734643597241f33724b8d7e7197cd6a85b", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -17,7 +17,7 @@\n //!\n //! * **Identity**: sharing AST nodes is problematic for the various analysis\n //!   passes (e.g. one may be able to bypass the borrow checker with a shared\n-//!   `ExprAddrOf` node taking a mutable borrow). The only reason `@T` in the\n+//!   `ExprKind::AddrOf` node taking a mutable borrow). The only reason `@T` in the\n //!   AST hasn't caused issues is because of inefficient folding passes which\n //!   would always deduplicate any such shared nodes. Even if the AST were to\n //!   switch to an arena, this would still hold, i.e. it couldn't use `&'a T`,"}, {"sha": "9049b21d8b4bbc511cc4fb71772754dde6e70180", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -89,8 +89,8 @@ impl fold::Folder for CrateInjector {\n             attrs: vec!(\n                 attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_word_item(\n                         InternedString::new(\"macro_use\")))),\n-            node: ast::ItemExternCrate(Some(self.crate_name)),\n-            vis: ast::Inherited,\n+            node: ast::ItemKind::ExternCrate(Some(self.crate_name)),\n+            vis: ast::Visibility::Inherited,\n             span: DUMMY_SP\n         }));\n \n@@ -149,20 +149,20 @@ impl fold::Folder for PreludeInjector {\n         mod_.items.insert(0, P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n             ident: special_idents::invalid,\n-            node: ast::ItemUse(vp),\n+            node: ast::ItemKind::Use(vp),\n             attrs: vec![ast::Attribute {\n                 span: self.span,\n                 node: ast::Attribute_ {\n                     id: attr::mk_attr_id(),\n                     style: ast::AttrStyle::Outer,\n                     value: P(ast::MetaItem {\n                         span: self.span,\n-                        node: ast::MetaWord(special_idents::prelude_import.name.as_str()),\n+                        node: ast::MetaItemKind::Word(special_idents::prelude_import.name.as_str()),\n                     }),\n                     is_sugared_doc: false,\n                 },\n             }],\n-            vis: ast::Inherited,\n+            vis: ast::Visibility::Inherited,\n             span: self.span,\n         }));\n "}, {"sha": "6b4f94641906197e6a563004e060b47dd85cb0f5", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -125,7 +125,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n         let i = if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n-                ast::ItemFn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n+                ast::ItemKind::Fn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n                     panic!(diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\"));\n                 }\n@@ -147,7 +147,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     // the module (note that the tests are re-exported and must\n                     // be made public themselves to avoid privacy errors).\n                     i.map(|mut i| {\n-                        i.vis = ast::Public;\n+                        i.vis = ast::Visibility::Public;\n                         i\n                     })\n                 }\n@@ -159,7 +159,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n         let res = match i.node {\n-            ast::ItemMod(..) => fold::noop_fold_item(i, self),\n+            ast::ItemKind::Mod(..) => fold::noop_fold_item(i, self),\n             _ => SmallVector::one(i),\n         };\n         if ident.name != token::special_idents::invalid.name {\n@@ -245,11 +245,11 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n     let super_ = token::str_to_ident(\"super\");\n \n     let items = tests.into_iter().map(|r| {\n-        cx.ext_cx.item_use_simple(DUMMY_SP, ast::Public,\n+        cx.ext_cx.item_use_simple(DUMMY_SP, ast::Visibility::Public,\n                                   cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n     }).chain(tested_submods.into_iter().map(|(r, sym)| {\n         let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n-        cx.ext_cx.item_use_simple_(DUMMY_SP, ast::Public, r, path)\n+        cx.ext_cx.item_use_simple_(DUMMY_SP, ast::Visibility::Public, r, path)\n     }));\n \n     let reexport_mod = ast::Mod {\n@@ -262,8 +262,8 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n         ident: sym.clone(),\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ItemMod(reexport_mod),\n-        vis: ast::Public,\n+        node: ast::ItemKind::Mod(reexport_mod),\n+        vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n     });\n \n@@ -355,10 +355,10 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n \n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n         match i.node {\n-          ast::ItemFn(ref decl, _, _, _, ref generics, _) => {\n+          ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n             let no_output = match decl.output {\n-                ast::DefaultReturn(..) => true,\n-                ast::Return(ref t) if t.node == ast::TyTup(vec![]) => true,\n+                ast::FunctionRetTy::Default(..) => true,\n+                ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n                 _ => false\n             };\n             if decl.inputs.is_empty()\n@@ -391,11 +391,11 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n \n     fn has_test_signature(i: &ast::Item) -> bool {\n         match i.node {\n-            ast::ItemFn(ref decl, _, _, _, ref generics, _) => {\n+            ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n                 let no_output = match decl.output {\n-                    ast::DefaultReturn(..) => true,\n-                    ast::Return(ref t) if t.node == ast::TyTup(vec![]) => true,\n+                    ast::FunctionRetTy::Default(..) => true,\n+                    ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n                     _ => false\n                 };\n                 let tparm_cnt = generics.ty_params.len();\n@@ -453,12 +453,12 @@ mod __test {\n fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n     let id_test = token::str_to_ident(\"test\");\n     let (vi, vis, ident) = if cx.is_test_crate {\n-        (ast::ItemUse(\n+        (ast::ItemKind::Use(\n             P(nospan(ast::ViewPathSimple(id_test,\n                                          path_node(vec!(id_test)))))),\n-         ast::Public, token::special_idents::invalid)\n+         ast::Visibility::Public, token::special_idents::invalid)\n     } else {\n-        (ast::ItemExternCrate(None), ast::Inherited, id_test)\n+        (ast::ItemKind::ExternCrate(None), ast::Visibility::Inherited, id_test)\n     };\n     P(ast::Item {\n         id: ast::DUMMY_NODE_ID,\n@@ -494,18 +494,18 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let main_meta = ecx.meta_word(sp, token::intern_and_get_ident(\"main\"));\n     let main_attr = ecx.attribute(sp, main_meta);\n     // pub fn main() { ... }\n-    let main_ret_ty = ecx.ty(sp, ast::TyTup(vec![]));\n+    let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n     let main_body = ecx.block_all(sp, vec![call_test_main], None);\n-    let main = ast::ItemFn(ecx.fn_decl(vec![], main_ret_ty),\n+    let main = ast::ItemKind::Fn(ecx.fn_decl(vec![], main_ret_ty),\n                            ast::Unsafety::Normal,\n                            ast::Constness::NotConst,\n-                           ::abi::Rust, ast::Generics::default(), main_body);\n+                           ::abi::Abi::Rust, ast::Generics::default(), main_body);\n     let main = P(ast::Item {\n         ident: token::str_to_ident(\"main\"),\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n-        vis: ast::Public,\n+        vis: ast::Visibility::Public,\n         span: sp\n     });\n \n@@ -527,15 +527,15 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         inner: DUMMY_SP,\n         items: vec![import, mainfn, tests],\n     };\n-    let item_ = ast::ItemMod(testmod);\n+    let item_ = ast::ItemKind::Mod(testmod);\n \n     let mod_ident = token::gensym_ident(\"__test\");\n     let item = P(ast::Item {\n         id: ast::DUMMY_NODE_ID,\n         ident: mod_ident,\n         attrs: vec![],\n         node: item_,\n-        vis: ast::Public,\n+        vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n     });\n     let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n@@ -550,8 +550,8 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n             id: ast::DUMMY_NODE_ID,\n             ident: token::special_idents::invalid,\n             attrs: vec![],\n-            node: ast::ItemUse(P(use_path)),\n-            vis: ast::Inherited,\n+            node: ast::ItemKind::Use(P(use_path)),\n+            vis: ast::Visibility::Inherited,\n             span: DUMMY_SP\n         })\n     });\n@@ -591,9 +591,9 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n     let static_lt = ecx.lifetime(sp, token::special_idents::static_lifetime.name);\n     // &'static [self::test::TestDescAndFn]\n     let static_type = ecx.ty_rptr(sp,\n-                                  ecx.ty(sp, ast::TyVec(struct_type)),\n+                                  ecx.ty(sp, ast::TyKind::Vec(struct_type)),\n                                   Some(static_lt),\n-                                  ast::MutImmutable);\n+                                  ast::Mutability::Immutable);\n     // static TESTS: $static_type = &[...];\n     ecx.item_const(sp,\n                    ecx.ident_of(\"TESTS\"),\n@@ -613,10 +613,10 @@ fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n \n     P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprAddrOf(ast::MutImmutable,\n+        node: ast::ExprKind::AddrOf(ast::Mutability::Immutable,\n             P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprVec(cx.testfns.iter().map(|test| {\n+                node: ast::ExprKind::Vec(cx.testfns.iter().map(|test| {\n                     mk_test_desc_and_fn_rec(cx, test)\n                 }).collect()),\n                 span: DUMMY_SP,"}, {"sha": "6fb81bb6a768421d89397ac8d652125619f5ba27", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n use parse::token::{Token, BinOpToken, keywords};\n-use ast;\n+use ast::BinOpKind;\n \n /// Associative operator with precedence.\n ///\n@@ -108,28 +108,28 @@ impl AssocOp {\n         }\n     }\n \n-    /// Create a new AssocOp from ast::BinOp_.\n-    pub fn from_ast_binop(op: ast::BinOp_) -> Self {\n+    /// Create a new AssocOp from ast::BinOpKind.\n+    pub fn from_ast_binop(op: BinOpKind) -> Self {\n         use self::AssocOp::*;\n         match op {\n-            ast::BiLt => Less,\n-            ast::BiGt => Greater,\n-            ast::BiLe => LessEqual,\n-            ast::BiGe => GreaterEqual,\n-            ast::BiEq => Equal,\n-            ast::BiNe => NotEqual,\n-            ast::BiMul => Multiply,\n-            ast::BiDiv => Divide,\n-            ast::BiRem => Modulus,\n-            ast::BiAdd => Add,\n-            ast::BiSub => Subtract,\n-            ast::BiShl => ShiftLeft,\n-            ast::BiShr => ShiftRight,\n-            ast::BiBitAnd => BitAnd,\n-            ast::BiBitXor => BitXor,\n-            ast::BiBitOr => BitOr,\n-            ast::BiAnd => LAnd,\n-            ast::BiOr => LOr\n+            BinOpKind::Lt => Less,\n+            BinOpKind::Gt => Greater,\n+            BinOpKind::Le => LessEqual,\n+            BinOpKind::Ge => GreaterEqual,\n+            BinOpKind::Eq => Equal,\n+            BinOpKind::Ne => NotEqual,\n+            BinOpKind::Mul => Multiply,\n+            BinOpKind::Div => Divide,\n+            BinOpKind::Rem => Modulus,\n+            BinOpKind::Add => Add,\n+            BinOpKind::Sub => Subtract,\n+            BinOpKind::Shl => ShiftLeft,\n+            BinOpKind::Shr => ShiftRight,\n+            BinOpKind::BitAnd => BitAnd,\n+            BinOpKind::BitXor => BitXor,\n+            BinOpKind::BitOr => BitOr,\n+            BinOpKind::And => LAnd,\n+            BinOpKind::Or => LOr\n         }\n     }\n \n@@ -185,27 +185,27 @@ impl AssocOp {\n         }\n     }\n \n-    pub fn to_ast_binop(&self) -> Option<ast::BinOp_> {\n+    pub fn to_ast_binop(&self) -> Option<BinOpKind> {\n         use self::AssocOp::*;\n         match *self {\n-            Less => Some(ast::BiLt),\n-            Greater => Some(ast::BiGt),\n-            LessEqual => Some(ast::BiLe),\n-            GreaterEqual => Some(ast::BiGe),\n-            Equal => Some(ast::BiEq),\n-            NotEqual => Some(ast::BiNe),\n-            Multiply => Some(ast::BiMul),\n-            Divide => Some(ast::BiDiv),\n-            Modulus => Some(ast::BiRem),\n-            Add => Some(ast::BiAdd),\n-            Subtract => Some(ast::BiSub),\n-            ShiftLeft => Some(ast::BiShl),\n-            ShiftRight => Some(ast::BiShr),\n-            BitAnd => Some(ast::BiBitAnd),\n-            BitXor => Some(ast::BiBitXor),\n-            BitOr => Some(ast::BiBitOr),\n-            LAnd => Some(ast::BiAnd),\n-            LOr => Some(ast::BiOr),\n+            Less => Some(BinOpKind::Lt),\n+            Greater => Some(BinOpKind::Gt),\n+            LessEqual => Some(BinOpKind::Le),\n+            GreaterEqual => Some(BinOpKind::Ge),\n+            Equal => Some(BinOpKind::Eq),\n+            NotEqual => Some(BinOpKind::Ne),\n+            Multiply => Some(BinOpKind::Mul),\n+            Divide => Some(BinOpKind::Div),\n+            Modulus => Some(BinOpKind::Rem),\n+            Add => Some(BinOpKind::Add),\n+            Subtract => Some(BinOpKind::Sub),\n+            ShiftLeft => Some(BinOpKind::Shl),\n+            ShiftRight => Some(BinOpKind::Shr),\n+            BitAnd => Some(BinOpKind::BitAnd),\n+            BitXor => Some(BinOpKind::BitXor),\n+            BitOr => Some(BinOpKind::BitOr),\n+            LAnd => Some(BinOpKind::And),\n+            LOr => Some(BinOpKind::Or),\n             Inplace | Assign | AssignOp(_) | As | DotDot | Colon => None\n         }\n     }"}, {"sha": "66ac370c149f8c63e2f0b4cba1b5e7e39d41e0b4", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -196,15 +196,15 @@ pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n                                               explicit_self: &'v ExplicitSelf) {\n     match explicit_self.node {\n-        SelfStatic => {},\n-        SelfValue(ident) => {\n+        SelfKind::Static => {},\n+        SelfKind::Value(ident) => {\n             visitor.visit_ident(explicit_self.span, ident)\n         }\n-        SelfRegion(ref opt_lifetime, _, ident) => {\n+        SelfKind::Region(ref opt_lifetime, _, ident) => {\n             visitor.visit_ident(explicit_self.span, ident);\n             walk_list!(visitor, visit_lifetime, opt_lifetime);\n         }\n-        SelfExplicit(ref typ, ident) => {\n+        SelfKind::Explicit(ref typ, ident) => {\n             visitor.visit_ident(explicit_self.span, ident);\n             visitor.visit_ty(typ)\n         }\n@@ -230,10 +230,10 @@ pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n-        ItemExternCrate(opt_name) => {\n+        ItemKind::ExternCrate(opt_name) => {\n             walk_opt_name(visitor, item.span, opt_name)\n         }\n-        ItemUse(ref vp) => {\n+        ItemKind::Use(ref vp) => {\n             match vp.node {\n                 ViewPathSimple(ident, ref path) => {\n                     visitor.visit_ident(vp.span, ident);\n@@ -253,37 +253,37 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                 }\n             }\n         }\n-        ItemStatic(ref typ, _, ref expr) |\n-        ItemConst(ref typ, ref expr) => {\n+        ItemKind::Static(ref typ, _, ref expr) |\n+        ItemKind::Const(ref typ, ref expr) => {\n             visitor.visit_ty(typ);\n             visitor.visit_expr(expr);\n         }\n-        ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n+        ItemKind::Fn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n             visitor.visit_fn(FnKind::ItemFn(item.ident, generics, unsafety,\n                                             constness, abi, item.vis),\n                              declaration,\n                              body,\n                              item.span,\n                              item.id)\n         }\n-        ItemMod(ref module) => {\n+        ItemKind::Mod(ref module) => {\n             visitor.visit_mod(module, item.span, item.id)\n         }\n-        ItemForeignMod(ref foreign_module) => {\n+        ItemKind::ForeignMod(ref foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n-        ItemTy(ref typ, ref type_parameters) => {\n+        ItemKind::Ty(ref typ, ref type_parameters) => {\n             visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n-        ItemEnum(ref enum_definition, ref type_parameters) => {\n+        ItemKind::Enum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n             visitor.visit_enum_def(enum_definition, type_parameters, item.id, item.span)\n         }\n-        ItemDefaultImpl(_, ref trait_ref) => {\n+        ItemKind::DefaultImpl(_, ref trait_ref) => {\n             visitor.visit_trait_ref(trait_ref)\n         }\n-        ItemImpl(_, _,\n+        ItemKind::Impl(_, _,\n                  ref type_parameters,\n                  ref opt_trait_reference,\n                  ref typ,\n@@ -293,17 +293,17 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_impl_item, impl_items);\n         }\n-        ItemStruct(ref struct_definition, ref generics) => {\n+        ItemKind::Struct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_variant_data(struct_definition, item.ident,\n                                      generics, item.id, item.span);\n         }\n-        ItemTrait(_, ref generics, ref bounds, ref methods) => {\n+        ItemKind::Trait(_, ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item, methods);\n         }\n-        ItemMac(ref mac) => visitor.visit_mac(mac),\n+        ItemKind::Mac(ref mac) => visitor.visit_mac(mac),\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }\n@@ -328,45 +328,45 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     match typ.node {\n-        TyVec(ref ty) | TyParen(ref ty) => {\n+        TyKind::Vec(ref ty) | TyKind::Paren(ref ty) => {\n             visitor.visit_ty(ty)\n         }\n-        TyPtr(ref mutable_type) => {\n+        TyKind::Ptr(ref mutable_type) => {\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyRptr(ref opt_lifetime, ref mutable_type) => {\n+        TyKind::Rptr(ref opt_lifetime, ref mutable_type) => {\n             walk_list!(visitor, visit_lifetime, opt_lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyTup(ref tuple_element_types) => {\n+        TyKind::Tup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n-        TyBareFn(ref function_declaration) => {\n+        TyKind::BareFn(ref function_declaration) => {\n             walk_fn_decl(visitor, &function_declaration.decl);\n             walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n         }\n-        TyPath(ref maybe_qself, ref path) => {\n+        TyKind::Path(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, typ.id);\n         }\n-        TyObjectSum(ref ty, ref bounds) => {\n+        TyKind::ObjectSum(ref ty, ref bounds) => {\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n-        TyFixedLengthVec(ref ty, ref expression) => {\n+        TyKind::FixedLengthVec(ref ty, ref expression) => {\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expression)\n         }\n-        TyPolyTraitRef(ref bounds) => {\n+        TyKind::PolyTraitRef(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n-        TyTypeof(ref expression) => {\n+        TyKind::Typeof(ref expression) => {\n             visitor.visit_expr(expression)\n         }\n-        TyInfer => {}\n-        TyMac(ref mac) => {\n+        TyKind::Infer => {}\n+        TyKind::Mac(ref mac) => {\n             visitor.visit_mac(mac)\n         }\n     }\n@@ -467,11 +467,11 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n     visitor.visit_ident(foreign_item.span, foreign_item.ident);\n \n     match foreign_item.node {\n-        ForeignItemFn(ref function_declaration, ref generics) => {\n+        ForeignItemKind::Fn(ref function_declaration, ref generics) => {\n             walk_fn_decl(visitor, function_declaration);\n             visitor.visit_generics(generics)\n         }\n-        ForeignItemStatic(ref typ, _) => visitor.visit_ty(typ),\n+        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n     }\n \n     walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n@@ -524,7 +524,7 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n }\n \n pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n-    if let Return(ref output_ty) = *ret_ty {\n+    if let FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n         visitor.visit_ty(output_ty)\n     }\n }\n@@ -565,20 +565,20 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n     visitor.visit_ident(trait_item.span, trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     match trait_item.node {\n-        ConstTraitItem(ref ty, ref default) => {\n+        TraitItemKind::Const(ref ty, ref default) => {\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, default);\n         }\n-        MethodTraitItem(ref sig, None) => {\n+        TraitItemKind::Method(ref sig, None) => {\n             visitor.visit_explicit_self(&sig.explicit_self);\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, &sig.decl);\n         }\n-        MethodTraitItem(ref sig, Some(ref body)) => {\n+        TraitItemKind::Method(ref sig, Some(ref body)) => {\n             visitor.visit_fn(FnKind::Method(trait_item.ident, sig, None), &sig.decl,\n                              body, trait_item.span, trait_item.id);\n         }\n-        TypeTraitItem(ref bounds, ref default) => {\n+        TraitItemKind::Type(ref bounds, ref default) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n@@ -625,11 +625,11 @@ pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n     match statement.node {\n-        StmtDecl(ref declaration, _) => visitor.visit_decl(declaration),\n-        StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n+        StmtKind::Decl(ref declaration, _) => visitor.visit_decl(declaration),\n+        StmtKind::Expr(ref expression, _) | StmtKind::Semi(ref expression, _) => {\n             visitor.visit_expr(expression)\n         }\n-        StmtMac(ref mac, _, ref attrs) => {\n+        StmtKind::Mac(ref mac, _, ref attrs) => {\n             visitor.visit_mac(mac);\n             for attr in attrs.as_attr_slice() {\n                 visitor.visit_attribute(attr);\n@@ -640,8 +640,8 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n \n pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n     match declaration.node {\n-        DeclLocal(ref local) => visitor.visit_local(local),\n-        DeclItem(ref item) => visitor.visit_item(item),\n+        DeclKind::Local(ref local) => visitor.visit_local(local),\n+        DeclKind::Item(ref item) => visitor.visit_item(item),\n     }\n }\n \n@@ -651,138 +651,138 @@ pub fn walk_mac<'v, V: Visitor<'v>>(_: &mut V, _: &'v Mac) {\n \n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     match expression.node {\n-        ExprBox(ref subexpression) => {\n+        ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprInPlace(ref place, ref subexpression) => {\n+        ExprKind::InPlace(ref place, ref subexpression) => {\n             visitor.visit_expr(place);\n             visitor.visit_expr(subexpression)\n         }\n-        ExprVec(ref subexpressions) => {\n+        ExprKind::Vec(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprRepeat(ref element, ref count) => {\n+        ExprKind::Repeat(ref element, ref count) => {\n             visitor.visit_expr(element);\n             visitor.visit_expr(count)\n         }\n-        ExprStruct(ref path, ref fields, ref optional_base) => {\n+        ExprKind::Struct(ref path, ref fields, ref optional_base) => {\n             visitor.visit_path(path, expression.id);\n             for field in fields {\n                 visitor.visit_ident(field.ident.span, field.ident.node);\n                 visitor.visit_expr(&field.expr)\n             }\n             walk_list!(visitor, visit_expr, optional_base);\n         }\n-        ExprTup(ref subexpressions) => {\n+        ExprKind::Tup(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprCall(ref callee_expression, ref arguments) => {\n+        ExprKind::Call(ref callee_expression, ref arguments) => {\n             walk_list!(visitor, visit_expr, arguments);\n             visitor.visit_expr(callee_expression)\n         }\n-        ExprMethodCall(ref ident, ref types, ref arguments) => {\n+        ExprKind::MethodCall(ref ident, ref types, ref arguments) => {\n             visitor.visit_ident(ident.span, ident.node);\n             walk_list!(visitor, visit_expr, arguments);\n             walk_list!(visitor, visit_ty, types);\n         }\n-        ExprBinary(_, ref left_expression, ref right_expression) => {\n+        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprLit(_) => {}\n-        ExprCast(ref subexpression, ref typ) | ExprType(ref subexpression, ref typ) => {\n+        ExprKind::Lit(_) => {}\n+        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprIf(ref head_expression, ref if_block, ref optional_else) => {\n+        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n             visitor.visit_expr(head_expression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, opt_ident) => {\n+        ExprKind::While(ref subexpression, ref block, opt_ident) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n             walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprIfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n+        ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhileLet(ref pattern, ref subexpression, ref block, opt_ident) => {\n+        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, opt_ident) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n             walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprForLoop(ref pattern, ref subexpression, ref block, opt_ident) => {\n+        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, opt_ident) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n             walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprLoop(ref block, opt_ident) => {\n+        ExprKind::Loop(ref block, opt_ident) => {\n             visitor.visit_block(block);\n             walk_opt_ident(visitor, expression.span, opt_ident)\n         }\n-        ExprMatch(ref subexpression, ref arms) => {\n+        ExprKind::Match(ref subexpression, ref arms) => {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprClosure(_, ref function_declaration, ref body) => {\n+        ExprKind::Closure(_, ref function_declaration, ref body) => {\n             visitor.visit_fn(FnKind::Closure,\n                              function_declaration,\n                              body,\n                              expression.span,\n                              expression.id)\n         }\n-        ExprBlock(ref block) => visitor.visit_block(block),\n-        ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n+        ExprKind::Block(ref block) => visitor.visit_block(block),\n+        ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n             visitor.visit_expr(right_hand_expression);\n             visitor.visit_expr(left_hand_expression)\n         }\n-        ExprAssignOp(_, ref left_expression, ref right_expression) => {\n+        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(right_expression);\n             visitor.visit_expr(left_expression)\n         }\n-        ExprField(ref subexpression, ref ident) => {\n+        ExprKind::Field(ref subexpression, ref ident) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ident(ident.span, ident.node);\n         }\n-        ExprTupField(ref subexpression, _) => {\n+        ExprKind::TupField(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprIndex(ref main_expression, ref index_expression) => {\n+        ExprKind::Index(ref main_expression, ref index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprRange(ref start, ref end) => {\n+        ExprKind::Range(ref start, ref end) => {\n             walk_list!(visitor, visit_expr, start);\n             walk_list!(visitor, visit_expr, end);\n         }\n-        ExprPath(ref maybe_qself, ref path) => {\n+        ExprKind::Path(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n                 visitor.visit_ty(&qself.ty);\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprBreak(ref opt_sp_ident) | ExprAgain(ref opt_sp_ident) => {\n+        ExprKind::Break(ref opt_sp_ident) | ExprKind::Again(ref opt_sp_ident) => {\n             for sp_ident in opt_sp_ident {\n                 visitor.visit_ident(sp_ident.span, sp_ident.node);\n             }\n         }\n-        ExprRet(ref optional_expression) => {\n+        ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprMac(ref mac) => visitor.visit_mac(mac),\n-        ExprParen(ref subexpression) => {\n+        ExprKind::Mac(ref mac) => visitor.visit_mac(mac),\n+        ExprKind::Paren(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprInlineAsm(ref ia) => {\n+        ExprKind::InlineAsm(ref ia) => {\n             for &(_, ref input) in &ia.inputs {\n                 visitor.visit_expr(&input)\n             }"}, {"sha": "b9ba1f107ad7aefa8867eb59e13d0d8a1111831f", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -247,7 +247,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprInlineAsm(ast::InlineAsm {\n+        node: ast::ExprKind::InlineAsm(ast::InlineAsm {\n             asm: token::intern_and_get_ident(&asm),\n             asm_str_style: asm_str_style.unwrap(),\n             outputs: outputs,"}, {"sha": "db731adf7943bbca07c4cdc62a28a437eadde021", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -27,30 +27,26 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n     let mut accumulator = String::new();\n     for e in es {\n         match e.node {\n-            ast::ExprLit(ref lit) => {\n+            ast::ExprKind::Lit(ref lit) => {\n                 match lit.node {\n-                    ast::LitStr(ref s, _) |\n-                    ast::LitFloat(ref s, _) |\n-                    ast::LitFloatUnsuffixed(ref s) => {\n+                    ast::LitKind::Str(ref s, _) |\n+                    ast::LitKind::Float(ref s, _) |\n+                    ast::LitKind::FloatUnsuffixed(ref s) => {\n                         accumulator.push_str(&s);\n                     }\n-                    ast::LitChar(c) => {\n+                    ast::LitKind::Char(c) => {\n                         accumulator.push(c);\n                     }\n-                    ast::LitInt(i, ast::UnsignedIntLit(_)) |\n-                    ast::LitInt(i, ast::SignedIntLit(_, ast::Plus)) |\n-                    ast::LitInt(i, ast::UnsuffixedIntLit(ast::Plus)) => {\n+                    ast::LitKind::Int(i, ast::LitIntType::Unsigned(_)) |\n+                    ast::LitKind::Int(i, ast::LitIntType::Signed(_)) |\n+                    ast::LitKind::Int(i, ast::LitIntType::Unsuffixed) => {\n                         accumulator.push_str(&format!(\"{}\", i));\n                     }\n-                    ast::LitInt(i, ast::SignedIntLit(_, ast::Minus)) |\n-                    ast::LitInt(i, ast::UnsuffixedIntLit(ast::Minus)) => {\n-                        accumulator.push_str(&format!(\"-{}\", i));\n-                    }\n-                    ast::LitBool(b) => {\n+                    ast::LitKind::Bool(b) => {\n                         accumulator.push_str(&format!(\"{}\", b));\n                     }\n-                    ast::LitByte(..) |\n-                    ast::LitByteStr(..) => {\n+                    ast::LitKind::Byte(..) |\n+                    ast::LitKind::ByteStr(..) => {\n                         cx.span_err(e.span, \"cannot concatenate a byte string literal\");\n                     }\n                 }"}, {"sha": "85453f6dfcbc8baceb1fecbc32530465e909c61a", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -54,7 +54,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n \n     let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprPath(None,\n+        node: ast::ExprKind::Path(None,\n             ast::Path {\n                  span: sp,\n                  global: false,"}, {"sha": "2fa847ee430d8746408e7e64ca3bb4ae39fdca68", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -11,8 +11,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast;\n-use syntax::ast::{MetaItem, Expr};\n+use syntax::ast::{MetaItem, Expr, BinOpKind, self};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -116,7 +115,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n \n             let assign = cx.stmt_let(span, false, test_id, new);\n \n-            let cond = cx.expr_binary(span, ast::BiEq,\n+            let cond = cx.expr_binary(span, BinOpKind::Eq,\n                                       cx.expr_ident(span, test_id),\n                                       cx.expr_path(equals_path.clone()));\n             let if_ = cx.expr_if(span,"}, {"sha": "0150a073b07d0bdf816f90ce0be0770a9d41b0b5", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -11,7 +11,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, self};\n+use syntax::ast::{MetaItem, Expr, BinOpKind};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -35,9 +35,9 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n                 };\n \n-                let eq = cx.expr_binary(span, ast::BiEq, self_f, other_f.clone());\n+                let eq = cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone());\n \n-                cx.expr_binary(span, ast::BiAnd, subexpr, eq)\n+                cx.expr_binary(span, BinOpKind::And, subexpr, eq)\n             },\n             cx.expr_bool(span, true),\n             Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n@@ -52,9 +52,9 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n                 };\n \n-                let eq = cx.expr_binary(span, ast::BiNe, self_f, other_f.clone());\n+                let eq = cx.expr_binary(span, BinOpKind::Ne, self_f, other_f.clone());\n \n-                cx.expr_binary(span, ast::BiOr, subexpr, eq)\n+                cx.expr_binary(span, BinOpKind::Or, subexpr, eq)\n             },\n             cx.expr_bool(span, false),\n             Box::new(|cx, span, _, _| cx.expr_bool(span, true)),"}, {"sha": "e857f7d52f912af544ad254f2ca207b512c55ab5", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -13,8 +13,7 @@ pub use self::OrderingOp::*;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast;\n-use syntax::ast::{MetaItem, Expr};\n+use syntax::ast::{MetaItem, Expr, BinOpKind, self};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -161,7 +160,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n \n             let assign = cx.stmt_let(span, false, test_id, new);\n \n-            let cond = cx.expr_binary(span, ast::BiEq,\n+            let cond = cx.expr_binary(span, BinOpKind::Eq,\n                                       cx.expr_ident(span, test_id),\n                                       equals_expr.clone());\n             let if_ = cx.expr_if(span,\n@@ -183,7 +182,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n /// Strict inequality.\n fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n          span: Span, substr: &Substructure) -> P<Expr> {\n-    let op = if less {ast::BiLt} else {ast::BiGt};\n+    let op = if less { BinOpKind::Lt } else { BinOpKind::Gt };\n     cs_fold(\n         false, // need foldr,\n         |cx, span, subexpr, self_f, other_fs| {\n@@ -211,11 +210,11 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n \n             let cmp = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n \n-            let not_cmp = cx.expr_unary(span, ast::UnNot,\n+            let not_cmp = cx.expr_unary(span, ast::UnOp::Not,\n                                         cx.expr_binary(span, op, other_f.clone(), self_f));\n \n-            let and = cx.expr_binary(span, ast::BiAnd, not_cmp, subexpr);\n-            cx.expr_binary(span, ast::BiOr, cmp, and)\n+            let and = cx.expr_binary(span, BinOpKind::And, not_cmp, subexpr);\n+            cx.expr_binary(span, BinOpKind::Or, cmp, and)\n         },\n         cx.expr_bool(span, equal),\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {"}, {"sha": "858066cb62603fff6c0658d8743be312a12b8647", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -27,7 +27,7 @@ pub fn expand_deriving_debug(cx: &mut ExtCtxt,\n {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(Box::new(Literal(path_std!(cx, core::fmt::Formatter))),\n-                   Borrowed(None, ast::MutMutable));\n+                   Borrowed(None, ast::Mutability::Mutable));\n \n     let trait_def = TraitDef {\n         span: span,\n@@ -71,8 +71,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n     // We want to make sure we have the expn_id set so that we can use unstable methods\n     let span = Span { expn_id: cx.backtrace(), .. span };\n-    let name = cx.expr_lit(span, ast::Lit_::LitStr(ident.name.as_str(),\n-                                                   ast::StrStyle::CookedStr));\n+    let name = cx.expr_lit(span, ast::LitKind::Str(ident.name.as_str(), ast::StrStyle::Cooked));\n     let builder = token::str_to_ident(\"builder\");\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n@@ -112,9 +111,9 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                 stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n-                    let name = cx.expr_lit(field.span, ast::Lit_::LitStr(\n+                    let name = cx.expr_lit(field.span, ast::LitKind::Str(\n                             field.name.unwrap().name.as_str(),\n-                            ast::StrStyle::CookedStr));\n+                            ast::StrStyle::Cooked));\n \n                     // Use double indirection to make sure this works for unsized types\n                     let field = cx.expr_addr_of(field.span, field.self_.clone());\n@@ -151,6 +150,6 @@ fn stmt_let_undescore(cx: &mut ExtCtxt,\n         span: sp,\n         attrs: None,\n     });\n-    let decl = respan(sp, ast::DeclLocal(local));\n-    P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n+    let decl = respan(sp, ast::DeclKind::Local(local));\n+    P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))\n }"}, {"sha": "092f8548966dabcbf7201f42380f84581a60f757", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -14,7 +14,7 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast;\n-use syntax::ast::{MetaItem, Expr, MutMutable};\n+use syntax::ast::{MetaItem, Expr, Mutability};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -72,7 +72,7 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                 },\n                 explicit_self: None,\n                 args: vec!(Ptr(Box::new(Literal(Path::new_local(\"__D\"))),\n-                            Borrowed(None, MutMutable))),\n+                            Borrowed(None, Mutability::Mutable))),\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,"}, {"sha": "614a6381962384a2a7d5570f4dc43949a9a18feb", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -91,7 +91,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, ExprRet, MutMutable};\n+use syntax::ast::{MetaItem, Expr, ExprKind, Mutability};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt,Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -148,7 +148,7 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                 },\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec!(Ptr(Box::new(Literal(Path::new_local(\"__S\"))),\n-                            Borrowed(None, MutMutable))),\n+                            Borrowed(None, Mutability::Mutable))),\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,\n@@ -208,16 +208,15 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 let call = if i != last {\n                     cx.expr_try(span, call)\n                 } else {\n-                    cx.expr(span, ExprRet(Some(call)))\n+                    cx.expr(span, ExprKind::Ret(Some(call)))\n                 };\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n             // unit structs have no fields and need to return Ok()\n             if stmts.is_empty() {\n-                let ret_ok = cx.expr(trait_span,\n-                                     ExprRet(Some(cx.expr_ok(trait_span,\n-                                                             cx.expr_tuple(trait_span, vec![])))));\n+                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, vec![]));\n+                let ret_ok = cx.expr(trait_span, ExprKind::Ret(Some(ok)));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n \n@@ -254,14 +253,13 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                     let call = if i != last {\n                         cx.expr_try(span, call)\n                     } else {\n-                        cx.expr(span, ExprRet(Some(call)))\n+                        cx.expr(span, ExprKind::Ret(Some(call)))\n                     };\n                     stmts.push(cx.stmt_expr(call));\n                 }\n             } else {\n-                let ret_ok = cx.expr(trait_span,\n-                                     ExprRet(Some(cx.expr_ok(trait_span,\n-                                                             cx.expr_tuple(trait_span, vec![])))));\n+                let ok = cx.expr_ok(trait_span, cx.expr_tuple(trait_span, vec![]));\n+                let ret_ok = cx.expr(trait_span, ExprKind::Ret(Some(ok)));\n                 stmts.push(cx.stmt_expr(ret_ok));\n             }\n "}, {"sha": "1e4babfac1e5660551bc2160ae579ddb6c80e3f4", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -193,9 +193,7 @@ use std::collections::HashSet;\n use std::vec;\n \n use syntax::abi::Abi;\n-use syntax::abi;\n-use syntax::ast;\n-use syntax::ast::{EnumDef, Expr, Ident, Generics, VariantData};\n+use syntax::ast::{EnumDef, Expr, Ident, Generics, VariantData, BinOpKind, self};\n use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n@@ -356,7 +354,7 @@ fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name]) -> Vec<P<ast\n     impl<'a> visit::Visitor<'a> for Visitor<'a> {\n         fn visit_ty(&mut self, ty: &'a ast::Ty) {\n             match ty.node {\n-                ast::TyPath(_, ref path) if !path.global => {\n+                ast::TyKind::Path(_, ref path) if !path.global => {\n                     match path.segments.first() {\n                         Some(segment) => {\n                             if self.ty_param_names.contains(&segment.identifier.name) {\n@@ -393,13 +391,13 @@ impl<'a> TraitDef<'a> {\n         match *item {\n             Annotatable::Item(ref item) => {\n                 let newitem = match item.node {\n-                    ast::ItemStruct(ref struct_def, ref generics) => {\n+                    ast::ItemKind::Struct(ref struct_def, ref generics) => {\n                         self.expand_struct_def(cx,\n                                                &struct_def,\n                                                item.ident,\n                                                generics)\n                     }\n-                    ast::ItemEnum(ref enum_def, ref generics) => {\n+                    ast::ItemKind::Enum(ref enum_def, ref generics) => {\n                         self.expand_enum_def(cx,\n                                              enum_def,\n                                              &item.attrs,\n@@ -477,7 +475,7 @@ impl<'a> TraitDef<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.span,\n                 ident: ident,\n-                vis: ast::Inherited,\n+                vis: ast::Visibility::Inherited,\n                 attrs: Vec::new(),\n                 node: ast::ImplItemKind::Type(type_def.to_ty(cx,\n                     self.span,\n@@ -559,7 +557,7 @@ impl<'a> TraitDef<'a> {\n \n                 for ty in tys {\n                     // if we have already handled this type, skip it\n-                    if let ast::TyPath(_, ref p) = ty.node {\n+                    if let ast::TyKind::Path(_, ref p) = ty.node {\n                         if p.segments.len() == 1\n                             && ty_param_names.contains(&p.segments[0].identifier.name)\n                             || processed_field_types.contains(&p.segments) {\n@@ -639,12 +637,12 @@ impl<'a> TraitDef<'a> {\n             self.span,\n             ident,\n             a,\n-            ast::ItemImpl(unsafety,\n-                          ast::ImplPolarity::Positive,\n-                          trait_generics,\n-                          opt_trait_ref,\n-                          self_type,\n-                          methods.into_iter().chain(associated_types).collect()))\n+            ast::ItemKind::Impl(unsafety,\n+                                ast::ImplPolarity::Positive,\n+                                trait_generics,\n+                                opt_trait_ref,\n+                                self_type,\n+                                methods.into_iter().chain(associated_types).collect()))\n     }\n \n     fn expand_struct_def(&self,\n@@ -682,7 +680,7 @@ impl<'a> TraitDef<'a> {\n                                      self,\n                                      type_ident,\n                                      generics,\n-                                     abi::Rust,\n+                                     Abi::Rust,\n                                      explicit_self,\n                                      tys,\n                                      body)\n@@ -731,7 +729,7 @@ impl<'a> TraitDef<'a> {\n                                      self,\n                                      type_ident,\n                                      generics,\n-                                     abi::Rust,\n+                                     Abi::Rust,\n                                      explicit_self,\n                                      tys,\n                                      body)\n@@ -750,17 +748,17 @@ fn find_repr_type_name(diagnostic: &Handler,\n                 attr::ReprAny | attr::ReprPacked | attr::ReprSimd => continue,\n                 attr::ReprExtern => \"i32\",\n \n-                attr::ReprInt(_, attr::SignedInt(ast::TyIs)) => \"isize\",\n-                attr::ReprInt(_, attr::SignedInt(ast::TyI8)) => \"i8\",\n-                attr::ReprInt(_, attr::SignedInt(ast::TyI16)) => \"i16\",\n-                attr::ReprInt(_, attr::SignedInt(ast::TyI32)) => \"i32\",\n-                attr::ReprInt(_, attr::SignedInt(ast::TyI64)) => \"i64\",\n-\n-                attr::ReprInt(_, attr::UnsignedInt(ast::TyUs)) => \"usize\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::TyU8)) => \"u8\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::TyU16)) => \"u16\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::TyU32)) => \"u32\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::TyU64)) => \"u64\",\n+                attr::ReprInt(_, attr::SignedInt(ast::IntTy::Is)) => \"isize\",\n+                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I8)) => \"i8\",\n+                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I16)) => \"i16\",\n+                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I32)) => \"i32\",\n+                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I64)) => \"i64\",\n+\n+                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::Us)) => \"usize\",\n+                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U8)) => \"u8\",\n+                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U16)) => \"u16\",\n+                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U32)) => \"u32\",\n+                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U64)) => \"u64\",\n             }\n         }\n     }\n@@ -823,7 +821,7 @@ impl<'a> MethodDef<'a> {\n \n                 explicit_self\n             }\n-            None => codemap::respan(trait_.span, ast::SelfStatic),\n+            None => codemap::respan(trait_.span, ast::SelfKind::Static),\n         };\n \n         for (i, ty) in self.args.iter().enumerate() {\n@@ -864,9 +862,11 @@ impl<'a> MethodDef<'a> {\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n         let self_arg = match explicit_self.node {\n-            ast::SelfStatic => None,\n+            ast::SelfKind::Static => None,\n             // creating fresh self id\n-            _ => Some(ast::Arg::new_self(trait_.span, ast::MutImmutable, special_idents::self_))\n+            _ => Some(ast::Arg::new_self(trait_.span,\n+                                         ast::Mutability::Immutable,\n+                                         special_idents::self_))\n         };\n         let args = {\n             let args = arg_types.into_iter().map(|(name, ty)| {\n@@ -892,7 +892,7 @@ impl<'a> MethodDef<'a> {\n             id: ast::DUMMY_NODE_ID,\n             attrs: self.attributes.clone(),\n             span: trait_.span,\n-            vis: ast::Inherited,\n+            vis: ast::Visibility::Inherited,\n             ident: method_ident,\n             node: ast::ImplItemKind::Method(ast::MethodSig {\n                 generics: fn_generics,\n@@ -944,7 +944,7 @@ impl<'a> MethodDef<'a> {\n                                              struct_def,\n                                              &format!(\"__self_{}\",\n                                                      i),\n-                                             ast::MutImmutable);\n+                                             ast::Mutability::Immutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n         }\n@@ -1137,11 +1137,12 @@ impl<'a> MethodDef<'a> {\n         let mut match_arms: Vec<ast::Arm> = variants.iter().enumerate()\n             .map(|(index, variant)| {\n                 let mk_self_pat = |cx: &mut ExtCtxt, self_arg_name: &str| {\n-                    let (p, idents) = trait_.create_enum_variant_pattern(cx, type_ident,\n-                                                                         &**variant,\n-                                                                         self_arg_name,\n-                                                                         ast::MutImmutable);\n-                    (cx.pat(sp, ast::PatRegion(p, ast::MutImmutable)), idents)\n+                    let (p, idents) = trait_.create_enum_variant_pattern(\n+                        cx, type_ident,\n+                        &**variant,\n+                        self_arg_name,\n+                        ast::Mutability::Immutable);\n+                    (cx.pat(sp, ast::PatRegion(p, ast::Mutability::Immutable)), idents)\n                 };\n \n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n@@ -1267,7 +1268,7 @@ impl<'a> MethodDef<'a> {\n                     stmts: vec![],\n                     expr: Some(call),\n                     id: ast::DUMMY_NODE_ID,\n-                    rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+                    rules: ast::BlockCheckMode::Unsafe(ast::CompilerGenerated),\n                     span: sp }));\n \n                 let target_ty = cx.ty_ident(sp, cx.ident_of(target_type_name));\n@@ -1279,8 +1280,9 @@ impl<'a> MethodDef<'a> {\n                     Some(first) => {\n                         let first_expr = cx.expr_ident(sp, first);\n                         let id = cx.expr_ident(sp, ident);\n-                        let test = cx.expr_binary(sp, ast::BiEq, first_expr, id);\n-                        discriminant_test = cx.expr_binary(sp, ast::BiAnd, discriminant_test, test)\n+                        let test = cx.expr_binary(sp, BinOpKind::Eq, first_expr, id);\n+                        discriminant_test = cx.expr_binary(sp, BinOpKind::And,\n+                                                           discriminant_test, test)\n                     }\n                     None => {\n                         first_ident = Some(ident);\n@@ -1302,7 +1304,7 @@ impl<'a> MethodDef<'a> {\n                 stmts: vec![],\n                 expr: Some(call),\n                 id: ast::DUMMY_NODE_ID,\n-                rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+                rules: ast::BlockCheckMode::Unsafe(ast::CompilerGenerated),\n                 span: sp }));\n             match_arms.push(cx.arm(sp, vec![cx.pat_wild(sp)], unreachable));\n \n@@ -1312,7 +1314,7 @@ impl<'a> MethodDef<'a> {\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n-            let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n+            let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n \n             //Lastly we create an expression which branches on all discriminants being equal\n             //  if discriminant_test {\n@@ -1390,7 +1392,7 @@ impl<'a> MethodDef<'a> {\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n-            let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n+            let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n             cx.expr_match(sp, match_arg, match_arms)\n         }\n     }\n@@ -1510,8 +1512,8 @@ impl<'a> TraitDef<'a> {\n             };\n             let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n             paths.push(codemap::Spanned{span: sp, node: ident});\n-            let val = cx.expr(\n-                sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)))));\n+            let val = cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)));\n+            let val = cx.expr(sp, ast::ExprKind::Paren(val));\n             ident_expr.push((sp, opt_id, val, &struct_field.node.attrs[..]));\n         }\n "}, {"sha": "a924cc0695377f8bc02d9257c93a649926c48aea", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -98,7 +98,7 @@ pub enum Ty<'a> {\n }\n \n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n-    Borrowed(None, ast::MutImmutable)\n+    Borrowed(None, ast::Mutability::Immutable)\n }\n pub fn borrowed<'r>(ty: Box<Ty<'r>>) -> Ty<'r> {\n     Ptr(ty, borrowed_ptrty())\n@@ -153,7 +153,7 @@ impl<'a> Ty<'a> {\n                 cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n             }\n             Tuple(ref fields) => {\n-                let ty = ast::TyTup(fields.iter()\n+                let ty = ast::TyKind::Tup(fields.iter()\n                     .map(|f| f.to_ty(cx, span, self_ty, self_generics))\n                     .collect());\n                 cx.ty(span, ty)\n@@ -264,15 +264,15 @@ pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::SelfValue(special_idents::self_)))\n+            (self_path, respan(span, ast::SelfKind::Value(special_idents::self_)))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n-                        ast::SelfRegion(lt, mutbl, special_idents::self_)\n+                        ast::SelfKind::Region(lt, mutbl, special_idents::self_)\n                     }\n                     Raw(_) => cx.span_bug(span, \"attempted to use *self in deriving definition\")\n                 });"}, {"sha": "371ba732b48965aac9905e83aa3ee1016b560043", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -11,7 +11,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, MutMutable};\n+use syntax::ast::{MetaItem, Expr, Mutability};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -43,7 +43,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                                   vec![path_std!(cx, core::hash::Hasher)])],\n                 },\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(Box::new(Literal(arg)), Borrowed(None, MutMutable))),\n+                args: vec!(Ptr(Box::new(Literal(arg)), Borrowed(None, Mutability::Mutable))),\n                 ret_ty: nil_ty(),\n                 attributes: vec![],\n                 is_unsafe: false,"}, {"sha": "4e2142f1fb482a963da3426f8432c031ea07214a", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -13,7 +13,7 @@\n //! FIXME (#2810): hygiene. Search for \"__\" strings (in other files too). We also assume \"extra\" is\n //! the standard library, and \"std\" is the core library.\n \n-use syntax::ast::{MetaItem, MetaWord};\n+use syntax::ast::{MetaItem, MetaItemKind};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{ExtCtxt, SyntaxEnv, Annotatable};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n@@ -94,7 +94,7 @@ fn expand_derive(cx: &mut ExtCtxt,\n \n             for titem in traits.iter().rev() {\n                 let tname = match titem.node {\n-                    MetaWord(ref tname) => tname,\n+                    MetaItemKind::Word(ref tname) => tname,\n                     _ => {\n                         cx.span_err(titem.span, \"malformed `derive` entry\");\n                         continue;"}, {"sha": "63ec9cac07317d9f0a3eb8766b0ff7c42123f534", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -42,7 +42,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n                                                    Some(cx.lifetime(sp,\n                                                         cx.ident_of(\n                                                             \"'static\").name)),\n-                                                   ast::MutImmutable)),\n+                                                   ast::Mutability::Immutable)),\n                                    Vec::new()))\n       }\n       Ok(s) => {"}, {"sha": "4e24eb9f6d7a33283d6e015e7d0e7c8524af7885", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -409,7 +409,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 }\n \n                 // Translate the format\n-                let fill = self.ecx.expr_lit(sp, ast::LitChar(fill));\n+                let fill = self.ecx.expr_lit(sp, ast::LitKind::Char(fill));\n                 let align = |name| {\n                     let mut p = Context::rtpath(self.ecx, \"Alignment\");\n                     p.push(self.ecx.ident_of(name));\n@@ -448,20 +448,20 @@ impl<'a, 'b> Context<'a, 'b> {\n                     -> P<ast::Expr> {\n         let sp = piece_ty.span;\n         let ty = ecx.ty_rptr(sp,\n-            ecx.ty(sp, ast::TyVec(piece_ty)),\n+            ecx.ty(sp, ast::TyKind::Vec(piece_ty)),\n             Some(ecx.lifetime(sp, special_idents::static_lifetime.name)),\n-            ast::MutImmutable);\n+            ast::Mutability::Immutable);\n         let slice = ecx.expr_vec_slice(sp, pieces);\n         // static instead of const to speed up codegen by not requiring this to be inlined\n-        let st = ast::ItemStatic(ty, ast::MutImmutable, slice);\n+        let st = ast::ItemKind::Static(ty, ast::Mutability::Immutable, slice);\n \n         let name = ecx.ident_of(name);\n         let item = ecx.item(sp, name, vec![], st);\n-        let decl = respan(sp, ast::DeclItem(item));\n+        let decl = respan(sp, ast::DeclKind::Item(item));\n \n         // Wrap the declaration in a block so that it forms a single expression.\n         ecx.expr_block(ecx.block(sp,\n-            vec![P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))],\n+            vec![P(respan(sp, ast::StmtKind::Decl(P(decl), ast::DUMMY_NODE_ID)))],\n             Some(ecx.expr_ident(sp, name))))\n     }\n \n@@ -480,7 +480,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.fmtsp,\n                 self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n                 Some(static_lifetime),\n-                ast::MutImmutable);\n+                ast::Mutability::Immutable);\n         let pieces = Context::static_array(self.ecx,\n                                            \"__STATIC_FMTSTR\",\n                                            piece_ty,\n@@ -559,7 +559,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         // as series of let's; the first approach does.\n         let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n         let arm = self.ecx.arm(self.fmtsp, vec!(pat), args_array);\n-        let head = self.ecx.expr(self.fmtsp, ast::ExprTup(heads));\n+        let head = self.ecx.expr(self.fmtsp, ast::ExprKind::Tup(heads));\n         let result = self.ecx.expr_match(self.fmtsp, head, vec!(arm));\n \n         let args_slice = self.ecx.expr_addr_of(self.fmtsp, result);"}, {"sha": "5f0ef4de491e0c5a5a2b89dc91b4524e05611da1", "filename": "src/test/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -62,7 +62,7 @@ fn expand(cx: &mut ExtCtxt,\n                     let zero = cx.expr_isize(span, 0);\n                     cs_fold(false,\n                             |cx, span, subexpr, field, _| {\n-                                cx.expr_binary(span, ast::BiAdd, subexpr,\n+                                cx.expr_binary(span, ast::BinOpKind::Add, subexpr,\n                                     cx.expr_method_call(span, field,\n                                         token::str_to_ident(\"total_sum\"), vec![]))\n                             },"}, {"sha": "ba216289fd4c012c1e72e4ccebade88f22817bcd", "filename": "src/test/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -81,7 +81,7 @@ fn totalsum_substructure(cx: &mut ExtCtxt, trait_span: Span,\n         if item.attrs.iter().find(|a| a.check_name(\"ignore\")).is_some() {\n             acc\n         } else {\n-            cx.expr_binary(item.span, ast::BiAdd, acc,\n+            cx.expr_binary(item.span, ast::BinOpKind::Add, acc,\n                            cx.expr_method_call(item.span,\n                                                item.self_.clone(),\n                                                substr.method_ident,"}, {"sha": "c4cfa36542f9c65aa4ea76de6cd0ab15f644e9e7", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=7732c0aa9ea12262cbe46fa77c2fa636e8aecf6a", "patch": "@@ -16,7 +16,7 @@ extern crate syntax;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::ast::{self, TokenTree, Item, MetaItem, ImplItem, TraitItem};\n+use syntax::ast::{self, TokenTree, Item, MetaItem, ImplItem, TraitItem, ItemKind};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::parse::{self, token};\n@@ -73,7 +73,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n         Annotatable::ImplItem(it) => {\n             quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n                 match i.node {\n-                    ast::ItemImpl(_, _, _, _, _, mut items) => {\n+                    ItemKind::Impl(_, _, _, _, _, mut items) => {\n                         Annotatable::ImplItem(items.pop().expect(\"impl method not found\"))\n                     }\n                     _ => unreachable!(\"impl parsed to something other than impl\")\n@@ -83,7 +83,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n         Annotatable::TraitItem(it) => {\n             quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n                 match i.node {\n-                    ast::ItemTrait(_, _, _, mut items) => {\n+                    ItemKind::Trait(_, _, _, mut items) => {\n                         Annotatable::TraitItem(items.pop().expect(\"trait method not found\"))\n                     }\n                     _ => unreachable!(\"trait parsed to something other than trait\")\n@@ -101,8 +101,8 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n                     push: &mut FnMut(Annotatable))\n {\n     let copy_name = match mi.node {\n-        ast::MetaItem_::MetaList(_, ref xs) => {\n-            if let ast::MetaItem_::MetaWord(ref w) = xs[0].node {\n+        ast::MetaItemKind::List(_, ref xs) => {\n+            if let ast::MetaItemKind::Word(ref w) = xs[0].node {\n                 token::str_to_ident(&w)\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");"}]}