{"sha": "1c8b245928c3f2463b45fbddd862a0a70882d087", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjOGIyNDU5MjhjM2YyNDYzYjQ1ZmJkZGQ4NjJhMGE3MDg4MmQwODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-13T14:30:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-13T14:30:14Z"}, "message": "Auto merge of #32229 - Manishearth:rollup, r=Manishearth\n\nRollup of 4 pull requests\n\n- Successful merges: #32164, #32179, #32212, #32218\n- Failed merges:", "tree": {"sha": "5cd83be65b2dd53bd0b7331720912a4d4086e138", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cd83be65b2dd53bd0b7331720912a4d4086e138"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c8b245928c3f2463b45fbddd862a0a70882d087", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c8b245928c3f2463b45fbddd862a0a70882d087", "html_url": "https://github.com/rust-lang/rust/commit/1c8b245928c3f2463b45fbddd862a0a70882d087", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c8b245928c3f2463b45fbddd862a0a70882d087/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c21644ad162c69da7c883812be3e473c4e64c257", "url": "https://api.github.com/repos/rust-lang/rust/commits/c21644ad162c69da7c883812be3e473c4e64c257", "html_url": "https://github.com/rust-lang/rust/commit/c21644ad162c69da7c883812be3e473c4e64c257"}, {"sha": "2e21ff1a9d8d85d47461837eb2f12edb92a1b422", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e21ff1a9d8d85d47461837eb2f12edb92a1b422", "html_url": "https://github.com/rust-lang/rust/commit/2e21ff1a9d8d85d47461837eb2f12edb92a1b422"}], "stats": {"total": 64, "additions": 53, "deletions": 11}, "files": [{"sha": "ca83f2226c048e05986d65089a3035e096a3fadb", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=1c8b245928c3f2463b45fbddd862a0a70882d087", "patch": "@@ -501,7 +501,7 @@ Cargo checks to see if any of your project\u2019s files have been modified, and onl\n rebuilds your project if they\u2019ve changed since the last time you built it.\n \n With simple projects, Cargo doesn't bring a whole lot over just using `rustc`,\n-but it will become useful in future. This is especially true when you start\n+but it will become useful in the future. This is especially true when you start\n using crates; these are synonymous with a \u2018library\u2019 or \u2018package\u2019 in other\n programming languages. For complex projects composed of multiple crates, it\u2019s\n much easier to let Cargo coordinate the build. Using Cargo, you can run `cargo"}, {"sha": "52d0dd888efef1edf3a9c461b5e19111c4415fbf", "filename": "src/doc/book/if.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Fdoc%2Fbook%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Fdoc%2Fbook%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fif.md?ref=1c8b245928c3f2463b45fbddd862a0a70882d087", "patch": "@@ -4,7 +4,7 @@ Rust\u2019s take on `if` is not particularly complex, but it\u2019s much more like the\n `if` you\u2019ll find in a dynamically typed language than in a more traditional\n systems language. So let\u2019s talk about it, to make sure you grasp the nuances.\n \n-`if` is a specific form of a more general concept, the \u2018branch\u2019. The name comes\n+`if` is a specific form of a more general concept, the \u2018branch\u2019, whose name comes\n from a branch in a tree: a decision point, where depending on a choice,\n multiple paths can be taken.\n "}, {"sha": "5ed1f3de06249910ccde51c35a73dd91254e63d7", "filename": "src/doc/book/strings.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Fdoc%2Fbook%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Fdoc%2Fbook%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fstrings.md?ref=1c8b245928c3f2463b45fbddd862a0a70882d087", "patch": "@@ -44,7 +44,7 @@ let s = \"foo\\\n assert_eq!(\"foobar\", s);\n ```\n \n-Rust has more than only `&str`s though. A `String`, is a heap-allocated string.\n+Rust has more than only `&str`s though. A `String` is a heap-allocated string.\n This string is growable, and is also guaranteed to be UTF-8. `String`s are\n commonly created by converting from a string slice using the `to_string`\n method.\n@@ -89,7 +89,7 @@ Viewing a `String` as a `&str` is cheap, but converting the `&str` to a\n \n ## Indexing\n \n-Because strings are valid UTF-8, strings do not support indexing:\n+Because strings are valid UTF-8, they do not support indexing:\n \n ```rust,ignore\n let s = \"hello\";"}, {"sha": "e671dd73431e6db82bed16a51bc99bc6107ce428", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=1c8b245928c3f2463b45fbddd862a0a70882d087", "patch": "@@ -1120,11 +1120,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                         .map(|method| resolve_ty(method.ty)))\n     }\n \n+    pub fn errors_since_creation(&self) -> bool {\n+        self.tcx.sess.err_count() - self.err_count_on_creation != 0\n+    }\n+\n     pub fn node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types.get(&id) {\n             Some(&t) => t,\n             // FIXME\n-            None if self.tcx.sess.err_count() - self.err_count_on_creation != 0 =>\n+            None if self.errors_since_creation() =>\n                 self.tcx.types.err,\n             None => {\n                 self.tcx.sess.bug(\n@@ -1147,7 +1151,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                              free_regions: &FreeRegionMap,\n                                              subject_node_id: ast::NodeId) {\n         let errors = self.region_vars.resolve_regions(free_regions, subject_node_id);\n-        self.report_region_errors(&errors); // see error_reporting.rs\n+        if !self.errors_since_creation() {\n+            // As a heuristic, just skip reporting region errors\n+            // altogether if other errors have been reported while\n+            // this infcx was in use.  This is totally hokey but\n+            // otherwise we have a hard time separating legit region\n+            // errors from silly ones.\n+            self.report_region_errors(&errors); // see error_reporting.rs\n+        }\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {"}, {"sha": "dba0bcf19be1362b908f2fc6a38b75fd899c8b75", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=1c8b245928c3f2463b45fbddd862a0a70882d087", "patch": "@@ -1095,6 +1095,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n     }\n \n+    if cg.codegen_units < 1 {\n+        early_error(error_format, \"Value for codegen units must be a positive nonzero integer\");\n+    }\n+\n     let cg = cg;\n \n     let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::from(&m));"}, {"sha": "f7621b0131ad45d919bae6619518b18de8984e6c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1c8b245928c3f2463b45fbddd862a0a70882d087", "patch": "@@ -927,7 +927,7 @@ pub enum ExprKind {\n     Binary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n     Unary(UnOp, P<Expr>),\n-    /// A literal (For example: `1u8`, `\"foo\"`)\n+    /// A literal (For example: `1`, `\"foo\"`)\n     Lit(P<Lit>),\n     /// A cast (`foo as f64`)\n     Cast(P<Expr>, P<Ty>),\n@@ -1016,7 +1016,7 @@ pub enum ExprKind {\n \n     /// An array literal constructed from one repeated element.\n     ///\n-    /// For example, `[1u8; 5]`. The first expression is the element\n+    /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n     Repeat(P<Expr>, P<Expr>),\n \n@@ -1288,7 +1288,7 @@ pub enum LitKind {\n     Byte(u8),\n     /// A character literal (`'a'`)\n     Char(char),\n-    /// An integer literal (`1u8`)\n+    /// An integer literal (`1`)\n     Int(u64, LitIntType),\n     /// A float literal (`1f64` or `1E10f64`)\n     Float(InternedString, FloatTy),"}, {"sha": "c1d922ea665b11d3b15fa04b0cb09f1d915b46ea", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=1c8b245928c3f2463b45fbddd862a0a70882d087", "patch": "@@ -168,8 +168,8 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n     let n: usize = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n     let token = vec![Token::Eof; n];\n-    let size = vec![0_isize; n];\n-    let scan_stack = vec![0_usize; n];\n+    let size = vec![0; n];\n+    let scan_stack = vec![0; n];\n     Printer {\n         out: out,\n         buf_len: n,"}, {"sha": "88d4aef6d9ddc0a873310ff8503125657763c55c", "filename": "src/test/compile-fail/issue-30580.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Ftest%2Fcompile-fail%2Fissue-30580.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c8b245928c3f2463b45fbddd862a0a70882d087/src%2Ftest%2Fcompile-fail%2Fissue-30580.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30580.rs?ref=1c8b245928c3f2463b45fbddd862a0a70882d087", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not see uninformative region-related errors\n+// when we get some basic type-checking failure. See #30580.\n+\n+pub struct Foo { a: u32 }\n+pub struct Pass<'a, 'tcx: 'a>(&'a mut &'a (), &'a &'tcx ());\n+\n+impl<'a, 'tcx> Pass<'a, 'tcx>\n+{\n+    pub fn tcx(&self) -> &'a &'tcx () { self.1 }\n+    fn lol(&mut self, b: &Foo)\n+    {\n+        b.c; //~ ERROR no field with that name was found\n+        self.tcx();\n+    }\n+}\n+\n+fn main() {}"}]}