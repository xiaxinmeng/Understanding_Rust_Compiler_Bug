{"sha": "a9d002c8a53be53aab6c754b011fb699e2f51aa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZDAwMmM4YTUzYmU1M2FhYjZjNzU0YjAxMWZiNjk5ZTJmNTFhYTA=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-04-05T03:59:46Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-04-05T03:59:46Z"}, "message": "Merge branch 'master' into clippy_dev_toolchain", "tree": {"sha": "42047f71906ae120ee36427353c6e44e7b10445e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42047f71906ae120ee36427353c6e44e7b10445e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9d002c8a53be53aab6c754b011fb699e2f51aa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9d002c8a53be53aab6c754b011fb699e2f51aa0", "html_url": "https://github.com/rust-lang/rust/commit/a9d002c8a53be53aab6c754b011fb699e2f51aa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9d002c8a53be53aab6c754b011fb699e2f51aa0/comments", "author": null, "committer": null, "parents": [{"sha": "ecc5c0a57d21ed0b926fd1a8528fd25325bc7d0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc5c0a57d21ed0b926fd1a8528fd25325bc7d0f", "html_url": "https://github.com/rust-lang/rust/commit/ecc5c0a57d21ed0b926fd1a8528fd25325bc7d0f"}, {"sha": "17e04ac751411a16d305aaf8d47a900675ad93f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/17e04ac751411a16d305aaf8d47a900675ad93f5", "html_url": "https://github.com/rust-lang/rust/commit/17e04ac751411a16d305aaf8d47a900675ad93f5"}], "stats": {"total": 1075, "additions": 701, "deletions": 374}, "files": [{"sha": "3d36e52d2df81c2682da0c8d245a352d1625c805", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -47,7 +47,8 @@ rustc_tools_util = { version = \"0.1.1\", path = \"rustc_tools_util\"}\n [dev-dependencies]\n clippy_dev = { version = \"0.0.1\", path = \"clippy_dev\" }\n cargo_metadata = \"0.7.1\"\n-compiletest_rs = \"0.3.19\"\n+compiletest_rs = { version = \"=0.3.19\", features = [\"tmp\", \"stable\"] }\n+libtest = \"0.0.1\"\n lazy_static = \"1.0\"\n serde_derive = \"1.0\"\n clippy-mini-macro-test = { version = \"0.2\", path = \"mini-macro\" }"}, {"sha": "c054a00894e75ebcafe2d77cd91747236bf2ba50", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 83, "deletions": 77, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use semver::Version;\n-use syntax::ast::{AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n+use syntax::ast::{AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use syntax::source_map::Span;\n \n declare_clippy_lint! {\n@@ -208,22 +208,24 @@ impl LintPass for AttrPass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     fn check_attribute(&mut self, cx: &LateContext<'a, 'tcx>, attr: &'tcx Attribute) {\n         if let Some(items) = &attr.meta_item_list() {\n-            match &*attr.name().as_str() {\n-                \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                    check_clippy_lint_names(cx, items);\n-                },\n-                _ => {},\n-            }\n-            if items.is_empty() || attr.name() != \"deprecated\" {\n-                return;\n-            }\n-            for item in items {\n-                if_chain! {\n-                    if let NestedMetaItemKind::MetaItem(mi) = &item.node;\n-                    if let MetaItemKind::NameValue(lit) = &mi.node;\n-                    if mi.name() == \"since\";\n-                    then {\n-                        check_semver(cx, item.span, lit);\n+            if let Some(ident) = attr.ident() {\n+                match &*ident.as_str() {\n+                    \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+                        check_clippy_lint_names(cx, items);\n+                    },\n+                    _ => {},\n+                }\n+                if items.is_empty() || !attr.check_name(\"deprecated\") {\n+                    return;\n+                }\n+                for item in items {\n+                    if_chain! {\n+                        if let NestedMetaItem::MetaItem(mi) = &item;\n+                        if let MetaItemKind::NameValue(lit) = &mi.node;\n+                        if mi.check_name(\"since\");\n+                        then {\n+                            check_semver(cx, item.span(), lit);\n+                        }\n                     }\n                 }\n             }\n@@ -236,55 +238,57 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n         }\n         match item.node {\n             ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n-                let skip_unused_imports = item.attrs.iter().any(|attr| attr.name() == \"macro_use\");\n+                let skip_unused_imports = item.attrs.iter().any(|attr| attr.check_name(\"macro_use\"));\n \n                 for attr in &item.attrs {\n                     if let Some(lint_list) = &attr.meta_item_list() {\n-                        match &*attr.name().as_str() {\n-                            \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                                // whitelist `unused_imports` and `deprecated` for `use` items\n-                                // and `unused_imports` for `extern crate` items with `macro_use`\n-                                for lint in lint_list {\n-                                    match item.node {\n-                                        ItemKind::Use(..) => {\n-                                            if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n-                                                return;\n-                                            }\n-                                        },\n-                                        ItemKind::ExternCrate(..) => {\n-                                            if is_word(lint, \"unused_imports\") && skip_unused_imports {\n-                                                return;\n-                                            }\n-                                            if is_word(lint, \"unused_extern_crates\") {\n-                                                return;\n-                                            }\n-                                        },\n-                                        _ => {},\n-                                    }\n-                                }\n-                                let line_span = last_line_of_span(cx, attr.span);\n-\n-                                if let Some(mut sugg) = snippet_opt(cx, line_span) {\n-                                    if sugg.contains(\"#[\") {\n-                                        span_lint_and_then(\n-                                            cx,\n-                                            USELESS_ATTRIBUTE,\n-                                            line_span,\n-                                            \"useless lint attribute\",\n-                                            |db| {\n-                                                sugg = sugg.replacen(\"#[\", \"#![\", 1);\n-                                                db.span_suggestion(\n-                                                    line_span,\n-                                                    \"if you just forgot a `!`, use\",\n-                                                    sugg,\n-                                                    Applicability::MachineApplicable,\n-                                                );\n+                        if let Some(ident) = attr.ident() {\n+                            match &*ident.as_str() {\n+                                \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+                                    // whitelist `unused_imports` and `deprecated` for `use` items\n+                                    // and `unused_imports` for `extern crate` items with `macro_use`\n+                                    for lint in lint_list {\n+                                        match item.node {\n+                                            ItemKind::Use(..) => {\n+                                                if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n+                                                    return;\n+                                                }\n+                                            },\n+                                            ItemKind::ExternCrate(..) => {\n+                                                if is_word(lint, \"unused_imports\") && skip_unused_imports {\n+                                                    return;\n+                                                }\n+                                                if is_word(lint, \"unused_extern_crates\") {\n+                                                    return;\n+                                                }\n                                             },\n-                                        );\n+                                            _ => {},\n+                                        }\n                                     }\n-                                }\n-                            },\n-                            _ => {},\n+                                    let line_span = last_line_of_span(cx, attr.span);\n+\n+                                    if let Some(mut sugg) = snippet_opt(cx, line_span) {\n+                                        if sugg.contains(\"#[\") {\n+                                            span_lint_and_then(\n+                                                cx,\n+                                                USELESS_ATTRIBUTE,\n+                                                line_span,\n+                                                \"useless lint attribute\",\n+                                                |db| {\n+                                                    sugg = sugg.replacen(\"#[\", \"#![\", 1);\n+                                                    db.span_suggestion(\n+                                                        line_span,\n+                                                        \"if you just forgot a `!`, use\",\n+                                                        sugg,\n+                                                        Applicability::MachineApplicable,\n+                                                    );\n+                                                },\n+                                            );\n+                                        }\n+                                    }\n+                                },\n+                                _ => {},\n+                            }\n                         }\n                     }\n                 }\n@@ -311,10 +315,11 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n     let lint_store = cx.lints();\n     for lint in items {\n         if_chain! {\n-            if let Some(word) = lint.word();\n-            if let Some(tool_name) = word.is_scoped();\n+            if let Some(meta_item) = lint.meta_item();\n+            if meta_item.path.segments.len() > 1;\n+            if let tool_name = meta_item.path.segments[0].ident;\n             if tool_name.as_str() == \"clippy\";\n-            let name = word.name();\n+            let name = meta_item.path.segments.last().unwrap().ident.name;\n             if let CheckLintNameResult::Tool(Err((None, _))) = lint_store.check_lint_name(\n                 &name.as_str(),\n                 Some(tool_name.as_str()),\n@@ -323,7 +328,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n                 span_lint_and_then(\n                     cx,\n                     UNKNOWN_CLIPPY_LINTS,\n-                    lint.span,\n+                    lint.span(),\n                     &format!(\"unknown clippy lint: clippy::{}\", name),\n                     |db| {\n                         if name.as_str().chars().any(char::is_uppercase) {\n@@ -337,7 +342,7 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n                                 CheckLintNameResult::NoLint(None) => (),\n                                 _ => {\n                                     db.span_suggestion(\n-                                        lint.span,\n+                                        lint.span(),\n                                         \"lowercase the lint name\",\n                                         name_lower,\n                                         Applicability::MaybeIncorrect,\n@@ -352,22 +357,22 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n     }\n }\n \n-fn is_relevant_item(tcx: TyCtxt<'_, '_, '_>, item: &Item) -> bool {\n+fn is_relevant_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &Item) -> bool {\n     if let ItemKind::Fn(_, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir().body(eid).value)\n     } else {\n         true\n     }\n }\n \n-fn is_relevant_impl(tcx: TyCtxt<'_, '_, '_>, item: &ImplItem) -> bool {\n+fn is_relevant_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &ImplItem) -> bool {\n     match item.node {\n         ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir().body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(tcx: TyCtxt<'_, '_, '_>, item: &TraitItem) -> bool {\n+fn is_relevant_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n@@ -377,7 +382,7 @@ fn is_relevant_trait(tcx: TyCtxt<'_, '_, '_>, item: &TraitItem) -> bool {\n     }\n }\n \n-fn is_relevant_block(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n+fn is_relevant_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n         match &stmt.node {\n             StmtKind::Local(_) => true,\n@@ -389,7 +394,7 @@ fn is_relevant_block(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, blo\n     }\n }\n \n-fn is_relevant_expr(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n+fn is_relevant_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n     match &expr.node {\n         ExprKind::Block(block, _) => is_relevant_block(tcx, tables, block),\n         ExprKind::Ret(Some(e)) => is_relevant_expr(tcx, tables, e),\n@@ -443,7 +448,7 @@ fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attrib\n         }\n \n         if let Some(values) = attr.meta_item_list() {\n-            if values.len() != 1 || attr.name() != \"inline\" {\n+            if values.len() != 1 || !attr.check_name(\"inline\") {\n                 continue;\n             }\n             if is_word(&values[0], \"always\") {\n@@ -476,8 +481,8 @@ fn check_semver(cx: &LateContext<'_, '_>, span: Span, lit: &Lit) {\n }\n \n fn is_word(nmi: &NestedMetaItem, expected: &str) -> bool {\n-    if let NestedMetaItemKind::MetaItem(mi) = &nmi.node {\n-        mi.is_word() && mi.name() == expected\n+    if let NestedMetaItem::MetaItem(mi) = &nmi {\n+        mi.is_word() && mi.check_name(expected)\n     } else {\n         false\n     }\n@@ -514,15 +519,16 @@ impl EarlyLintPass for CfgAttrPass {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &Attribute) {\n         if_chain! {\n             // check cfg_attr\n-            if attr.name() == \"cfg_attr\";\n+            if attr.check_name(\"cfg_attr\");\n             if let Some(items) = attr.meta_item_list();\n             if items.len() == 2;\n             // check for `rustfmt`\n             if let Some(feature_item) = items[0].meta_item();\n-            if feature_item.name() == \"rustfmt\";\n+            if feature_item.check_name(\"rustfmt\");\n             // check for `rustfmt_skip` and `rustfmt::skip`\n             if let Some(skip_item) = &items[1].meta_item();\n-            if skip_item.name() == \"rustfmt_skip\" || skip_item.name() == \"skip\";\n+            if skip_item.check_name(\"rustfmt_skip\") ||\n+                skip_item.path.segments.last().expect(\"empty path in attribute\").ident.name == \"skip\";\n             // Only lint outer attributes, because custom inner attributes are unstable\n             // Tracking issue: https://github.com/rust-lang/rust/issues/54726\n             if let AttrStyle::Outer = attr.style;"}, {"sha": "61bfc78b3de8e6f63b55e46f3ce4d24c6c7c6f25", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -117,7 +117,7 @@ impl Hash for Constant {\n }\n \n impl Constant {\n-    pub fn partial_cmp(tcx: TyCtxt<'_, '_, '_>, cmp_type: ty::Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n+    pub fn partial_cmp(tcx: TyCtxt<'_, '_, '_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n             (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n@@ -268,7 +268,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     #[allow(clippy::cast_possible_wrap)]\n-    fn constant_not(&self, o: &Constant, ty: ty::Ty<'_>) -> Option<Constant> {\n+    fn constant_not(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n         use self::Constant::*;\n         match *o {\n             Bool(b) => Some(Bool(!b)),\n@@ -284,7 +284,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n-    fn constant_negate(&self, o: &Constant, ty: ty::Ty<'_>) -> Option<Constant> {\n+    fn constant_negate(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n         use self::Constant::*;\n         match *o {\n             Int(value) => {"}, {"sha": "413645a091ffc82f046a1aef35bde653b1f4169e", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -152,7 +152,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>,\n                 spans.extend_from_slice(&current_spans);\n                 doc.push_str(&current);\n             }\n-        } else if attr.name() == \"doc\" {\n+        } else if attr.check_name(\"doc\") {\n             // ignore mix of sugared and non-sugared doc\n             return;\n         }"}, {"sha": "afdf27376d8047898981de388fac65b3751cd132", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -39,9 +39,10 @@ impl LintPass for EnumGlobUse {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n     fn check_mod(&mut self, cx: &LateContext<'a, 'tcx>, m: &'tcx Mod, _: Span, _: HirId) {\n+        let map = cx.tcx.hir();\n         // only check top level `use` statements\n         for item in &m.item_ids {\n-            self.lint_item(cx, cx.tcx.hir().expect_item(item.id));\n+            self.lint_item(cx, map.expect_item(map.hir_to_node_id(item.id)));\n         }\n     }\n }"}, {"sha": "425f1e67147725966b0777b4eac80df95bf32525", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -1,7 +1,7 @@\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n \n@@ -129,54 +129,54 @@ fn get_ufcs_type_name(\n     method_def_id: def_id::DefId,\n     self_arg: &Expr,\n ) -> std::option::Option<String> {\n-    let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0].sty;\n-    let actual_type_of_self = &cx.tables.node_type(self_arg.hir_id).sty;\n+    let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n+    let actual_type_of_self = &cx.tables.node_type(self_arg.hir_id);\n \n     if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n-        if match_borrow_depth(expected_type_of_self, actual_type_of_self) {\n-            return Some(cx.tcx.item_path_str(trait_id));\n+        if match_borrow_depth(expected_type_of_self, &actual_type_of_self) {\n+            return Some(cx.tcx.def_path_str(trait_id));\n         }\n     }\n \n     cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n         //a type may implicitly implement other type's methods (e.g. Deref)\n-        if match_types(expected_type_of_self, actual_type_of_self) {\n+        if match_types(expected_type_of_self, &actual_type_of_self) {\n             return Some(get_type_name(cx, &actual_type_of_self));\n         }\n         None\n     })\n }\n \n-fn match_borrow_depth(lhs: &ty::TyKind<'_>, rhs: &ty::TyKind<'_>) -> bool {\n-    match (lhs, rhs) {\n-        (ty::Ref(_, t1, _), ty::Ref(_, t2, _)) => match_borrow_depth(&t1.sty, &t2.sty),\n+fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n+    match (&lhs.sty, &rhs.sty) {\n+        (ty::Ref(_, t1, _), ty::Ref(_, t2, _)) => match_borrow_depth(&t1, &t2),\n         (l, r) => match (l, r) {\n             (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => false,\n             (_, _) => true,\n         },\n     }\n }\n \n-fn match_types(lhs: &ty::TyKind<'_>, rhs: &ty::TyKind<'_>) -> bool {\n-    match (lhs, rhs) {\n+fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n+    match (&lhs.sty, &rhs.sty) {\n         (ty::Bool, ty::Bool)\n         | (ty::Char, ty::Char)\n         | (ty::Int(_), ty::Int(_))\n         | (ty::Uint(_), ty::Uint(_))\n         | (ty::Str, ty::Str) => true,\n         (ty::Ref(_, t1, _), ty::Ref(_, t2, _))\n         | (ty::Array(t1, _), ty::Array(t2, _))\n-        | (ty::Slice(t1), ty::Slice(t2)) => match_types(&t1.sty, &t2.sty),\n+        | (ty::Slice(t1), ty::Slice(t2)) => match_types(t1, t2),\n         (ty::Adt(def1, _), ty::Adt(def2, _)) => def1 == def2,\n         (_, _) => false,\n     }\n }\n \n-fn get_type_name(cx: &LateContext<'_, '_>, kind: &ty::TyKind<'_>) -> String {\n-    match kind {\n-        ty::Adt(t, _) => cx.tcx.item_path_str(t.did),\n-        ty::Ref(_, r, _) => get_type_name(cx, &r.sty),\n-        _ => kind.to_string(),\n+fn get_type_name(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> String {\n+    match ty.sty {\n+        ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n+        ty::Ref(_, r, _) => get_type_name(cx, &r),\n+        _ => ty.to_string(),\n     }\n }\n "}, {"sha": "bed5964fb32f11171c30afb4a92e14d3162999d9", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -3,7 +3,7 @@ use crate::utils::{is_expn_of, match_def_path, method_chain_args, span_lint_and_\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use syntax_pos::Span;\n \n@@ -132,7 +132,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     }\n }\n \n-fn match_type(tcx: ty::TyCtxt<'_, '_, '_>, ty: ty::Ty<'_>, path: &[&str]) -> bool {\n+fn match_type<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::Adt(adt, _) => match_def_path(tcx, adt.did, path),\n         _ => false,"}, {"sha": "4313d040474a96d3c699e407015fb2bb3b0dea36", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -256,8 +256,7 @@ impl<'a, 'tcx> Functions {\n         hir_id: hir::HirId,\n     ) {\n         let expr = &body.value;\n-        let node_id = cx.tcx.hir().hir_to_node_id(hir_id);\n-        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(node_id) {\n+        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(hir_id) {\n             let raw_ptrs = iter_input_pats(decl, body)\n                 .zip(decl.inputs.iter())\n                 .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))"}, {"sha": "3e13d0073fe8b631bf99fed3dcec8d433ff2154d", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n fn check_attrs(cx: &LateContext<'_, '_>, name: Name, attrs: &[Attribute]) {\n     for attr in attrs {\n-        if attr.name() != \"inline\" {\n+        if !attr.check_name(\"inline\") {\n             continue;\n         }\n "}, {"sha": "177c85adde583a4c19435f6390f42533750a0a24", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -148,9 +148,7 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n         }\n     }\n \n-    let trait_node_id = cx.tcx.hir().hir_to_node_id(visited_trait.hir_id);\n-\n-    if cx.access_levels.is_exported(trait_node_id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n+    if cx.access_levels.is_exported(visited_trait.hir_id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n         let mut current_and_super_traits = FxHashSet::default();\n         let visited_trait_def_id = cx.tcx.hir().local_def_id_from_hir_id(visited_trait.hir_id);\n         fill_trait_set(visited_trait_def_id, &mut current_and_super_traits, cx);\n@@ -193,10 +191,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n     }\n \n     let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n-        if cx\n-            .access_levels\n-            .is_exported(cx.tcx.hir().hir_to_node_id(is_empty.id.hir_id))\n-        {\n+        if cx.access_levels.is_exported(is_empty.id.hir_id) {\n             return;\n         } else {\n             \"a private\"\n@@ -206,7 +201,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n     };\n \n     if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n-        if cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(i.id.hir_id)) {\n+        if cx.access_levels.is_exported(i.id.hir_id) {\n             let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             let ty = cx.tcx.type_of(def_id);\n "}, {"sha": "bf98aa7e2b580b1e1fdb6ac1b8d13744600ac8b2", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -1,10 +1,10 @@\n // error-pattern:cargo-clippy\n \n #![feature(box_syntax)]\n+#![feature(never_type)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n-#![feature(range_contains)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![recursion_limit = \"256\"]\n #![warn(rust_2018_idioms, trivial_casts, trivial_numeric_casts)]"}, {"sha": "cd717e586e71732e6a10fa58791d9febb08fce40", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -356,7 +356,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                 self.collect_anonymous_lifetimes(path, ty);\n             },\n             TyKind::Def(item, _) => {\n-                if let ItemKind::Existential(ref exist_ty) = self.cx.tcx.hir().expect_item(item.id).node {\n+                let map = self.cx.tcx.hir();\n+                if let ItemKind::Existential(ref exist_ty) = map.expect_item(map.hir_to_node_id(item.id)).node {\n                     for bound in &exist_ty.bounds {\n                         if let GenericBound::Outlives(_) = *bound {\n                             self.record(&None);"}, {"sha": "22c336b8c47829e90121691655aaa017a43fe634", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -3,7 +3,7 @@ use crate::utils::{in_macro, iter_input_pats, match_type, method_chain_args, sni\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax::source_map::Span;\n@@ -87,7 +87,7 @@ impl LintPass for Pass {\n     }\n }\n \n-fn is_unit_type(ty: ty::Ty<'_>) -> bool {\n+fn is_unit_type(ty: Ty<'_>) -> bool {\n     match ty.sty {\n         ty::Tuple(slice) => slice.is_empty(),\n         ty::Never => true,"}, {"sha": "34cb2422e1c5e4f10744c79a4bad1e86d6d487e6", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -516,11 +516,11 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n             for pat in &arm.pats {\n                 if let PatKind::Path(ref path) = pat.deref().node {\n                     if let QPath::Resolved(_, p) = path {\n-                        missing_variants.retain(|e| e.did != p.def.def_id());\n+                        missing_variants.retain(|e| e.ctor_def_id != Some(p.def.def_id()));\n                     }\n                 } else if let PatKind::TupleStruct(ref path, ..) = pat.deref().node {\n                     if let QPath::Resolved(_, p) = path {\n-                        missing_variants.retain(|e| e.did != p.def.def_id());\n+                        missing_variants.retain(|e| e.ctor_def_id != Some(p.def.def_id()));\n                     }\n                 }\n             }\n@@ -539,7 +539,7 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n                     String::new()\n                 };\n                 // This path assumes that the enum type is imported into scope.\n-                format!(\"{}{}{}\", ident_str, cx.tcx.item_path_str(v.did), suffix)\n+                format!(\"{}{}{}\", ident_str, cx.tcx.def_path_str(v.def_id), suffix)\n             })\n             .collect();\n "}, {"sha": "858184d7ea16c673bcb5382b841f969b6ccd4c1b", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -918,8 +918,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n             if let hir::ItemKind::Impl(_, _, _, _, None, ref self_ty, _) = item.node;\n             then {\n-                let node_id = cx.tcx.hir().hir_to_node_id(implitem.hir_id);\n-                if cx.access_levels.is_exported(node_id) {\n+                if cx.access_levels.is_exported(implitem.hir_id) {\n                 // check missing trait implementations\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                         if name == method_name &&\n@@ -2196,7 +2195,7 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_re\n \n fn ty_has_iter_method(\n     cx: &LateContext<'_, '_>,\n-    self_ref_ty: ty::Ty<'_>,\n+    self_ref_ty: Ty<'_>,\n ) -> Option<(&'static Lint, &'static str, &'static str)> {\n     if let Some(ty_name) = has_iter_method(cx, self_ref_ty) {\n         let lint = match ty_name {\n@@ -2217,7 +2216,7 @@ fn ty_has_iter_method(\n     }\n }\n \n-fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: ty::Ty<'_>, method_span: Span) {\n+fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: Ty<'_>, method_span: Span) {\n     if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n         return;\n     }"}, {"sha": "721cfd870201b97011c2777c31b30f61ddf6b81f", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -6,11 +6,12 @@\n //\n \n use crate::utils::{in_macro, span_lint};\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n-use syntax::ast;\n+use syntax::ast::{self, MetaItem, MetaItemKind};\n use syntax::attr;\n use syntax::source_map::Span;\n \n@@ -52,6 +53,20 @@ impl MissingDoc {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n+    fn has_include(meta: Option<MetaItem>) -> bool {\n+        if_chain! {\n+            if let Some(meta) = meta;\n+            if let MetaItemKind::List(list) = meta.node;\n+            if let Some(meta) = list.get(0);\n+            if let Some(name) = meta.ident();\n+            then {\n+                name.as_str() == \"include\"\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_, '_>,\n@@ -74,7 +89,9 @@ impl MissingDoc {\n             return;\n         }\n \n-        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n+        let has_doc = attrs\n+            .iter()\n+            .any(|a| a.check_name(\"doc\") && (a.is_value_str() || Self::has_include(a.meta())));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "c6b1b7eaf517a4669379d056e3b75d4a45bff25d", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -59,7 +59,7 @@ declare_clippy_lint! {\n pub struct MissingInline;\n \n fn check_missing_inline_attrs(cx: &LateContext<'_, '_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n-    let has_inline = attrs.iter().any(|a| a.name() == \"inline\");\n+    let has_inline = attrs.iter().any(|a| a.check_name(\"inline\"));\n     if !has_inline {\n         span_lint(\n             cx,\n@@ -95,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(it.hir_id)) {\n+        if !cx.access_levels.is_exported(it.hir_id) {\n             return;\n         }\n         match it.node {\n@@ -146,8 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n         }\n \n         // If the item being implemented is not exported, then we don't need #[inline]\n-        let node_id = cx.tcx.hir().hir_to_node_id(impl_item.hir_id);\n-        if !cx.access_levels.is_exported(node_id) {\n+        if !cx.access_levels.is_exported(impl_item.hir_id) {\n             return;\n         }\n \n@@ -163,12 +162,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n         };\n \n         if let Some(trait_def_id) = trait_def_id {\n-            if let Some(n) = cx.tcx.hir().as_local_node_id(trait_def_id) {\n-                if !cx.access_levels.is_exported(n) {\n-                    // If a trait is being implemented for an item, and the\n-                    // trait is not exported, we don't need #[inline]\n-                    return;\n-                }\n+            if cx.tcx.hir().as_local_node_id(trait_def_id).is_some() && !cx.access_levels.is_exported(impl_item.hir_id)\n+            {\n+                // If a trait is being implemented for an item, and the\n+                // trait is not exported, we don't need #[inline]\n+                return;\n             }\n         }\n "}, {"sha": "2300456d4c381778310dc09a436ae698a13f8b80", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -324,7 +324,7 @@ fn requires_exact_signature(attrs: &[Attribute]) -> bool {\n     attrs.iter().any(|attr| {\n         [\"proc_macro\", \"proc_macro_attribute\", \"proc_macro_derive\"]\n             .iter()\n-            .any(|&allow| attr.name() == allow)\n+            .any(|&allow| attr.check_name(allow))\n     })\n }\n "}, {"sha": "3bf0c22c322c58b0987ddbce86e85e2f66a11c57", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -111,7 +111,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                     if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         let name = impl_item.ident.name;\n                         let id = impl_item.hir_id;\n-                        let node_id = cx.tcx.hir().hir_to_node_id(id);\n                         if sig.header.constness == hir::Constness::Const {\n                             // can't be implemented by default\n                             return;\n@@ -129,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                             // impl of `Default`\n                             return;\n                         }\n-                        if sig.decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(node_id) {\n+                        if sig.decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n                             let self_did = cx.tcx.hir().local_def_id_from_hir_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_did);\n                             if_chain! {"}, {"sha": "74a9b353ea97a516c6db31b877676a9c60572bdb", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -72,7 +72,7 @@ fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n             if let ExprKind::Path(ref qpath) = callee.node {\n                 let def = cx.tables.qpath_def(qpath, callee.hir_id);\n                 match def {\n-                    Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..) => {\n+                    Def::Struct(..) | Def::Variant(..) | Def::Ctor(..) => {\n                         !has_drop(cx, cx.tables.expr_ty(expr)) && args.iter().all(|arg| has_no_effect(cx, arg))\n                     },\n                     _ => false,\n@@ -166,9 +166,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<Vec\n             if let ExprKind::Path(ref qpath) = callee.node {\n                 let def = cx.tables.qpath_def(qpath, callee.hir_id);\n                 match def {\n-                    Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..)\n-                        if !has_drop(cx, cx.tables.expr_ty(expr)) =>\n-                    {\n+                    Def::Struct(..) | Def::Variant(..) | Def::Ctor(..) if !has_drop(cx, cx.tables.expr_ty(expr)) => {\n                         Some(args.iter().collect())\n                     },\n                     _ => None,"}, {"sha": "8b7b6b6c42c639a21c274ea200bf596604d3e81a", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -8,7 +8,7 @@ use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n use rustc::ty::adjustment::Adjust;\n-use rustc::ty::{self, TypeFlags};\n+use rustc::ty::{Ty, TypeFlags};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use rustc_typeck::hir_ty_to_ty;\n@@ -108,7 +108,7 @@ impl Source {\n     }\n }\n \n-fn verify_ty_bound<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, source: Source) {\n+fn verify_ty_bound<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>, source: Source) {\n     if ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP) || is_copy(cx, ty) {\n         // An `UnsafeCell` is `!Copy`, and an `UnsafeCell` is also the only type which\n         // is `!Freeze`, thus if our type is `Copy` we can be sure it must be `Freeze`"}, {"sha": "5c64cd1c15c7905d09979adb99517da54531a737", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -128,7 +128,7 @@ impl Pass {\n             },\n             ExprKind::Ret(Some(ref expr)) => Self::expression_returns_none(cx, expr),\n             ExprKind::Path(ref qp) => {\n-                if let Def::VariantCtor(def_id, _) = cx.tables.qpath_def(qp, expression.hir_id) {\n+                if let Def::Ctor(def_id, def::CtorOf::Variant, _) = cx.tables.qpath_def(qp, expression.hir_id) {\n                     return match_def_path(cx.tcx, def_id, &OPTION_NONE);\n                 }\n "}, {"sha": "84c9509844fcaf2f79f2545cad6a7c2f0d2cd92d", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -157,25 +157,30 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }) = higher::range(cx, expr);\n             if let Some(y) = y_plus_one(end);\n             then {\n+                let span = expr.span\n+                    .ctxt()\n+                    .outer()\n+                    .expn_info()\n+                    .map_or(expr.span, |info| info.call_site);\n                 span_lint_and_then(\n                     cx,\n                     RANGE_PLUS_ONE,\n-                    expr.span,\n+                    span,\n                     \"an inclusive range would be more readable\",\n                     |db| {\n                         let start = start.map_or(String::new(), |x| Sugg::hir(cx, x, \"x\").to_string());\n                         let end = Sugg::hir(cx, y, \"y\");\n-                        if let Some(is_wrapped) = &snippet_opt(cx, expr.span) {\n+                        if let Some(is_wrapped) = &snippet_opt(cx, span) {\n                             if is_wrapped.starts_with('(') && is_wrapped.ends_with(')') {\n                                 db.span_suggestion(\n-                                    expr.span,\n+                                    span,\n                                     \"use\",\n                                     format!(\"({}..={})\", start, end),\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             } else {\n                                 db.span_suggestion(\n-                                    expr.span,\n+                                    span,\n                                     \"use\",\n                                     format!(\"{}..={}\", start, end),\n                                     Applicability::MachineApplicable, // snippet"}, {"sha": "c764e0ceb837e5b7164160df0e6cc1dac7107f31", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -12,7 +12,7 @@ use rustc::mir::{\n     visit::{MutatingUseContext, PlaceContext, Visitor},\n     TerminatorKind,\n };\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use std::convert::TryFrom;\n@@ -225,7 +225,7 @@ fn is_call_with_ref_arg<'tcx>(\n     cx: &LateContext<'_, 'tcx>,\n     mir: &'tcx mir::Mir<'tcx>,\n     kind: &'tcx mir::TerminatorKind<'tcx>,\n-) -> Option<(def_id::DefId, mir::Local, ty::Ty<'tcx>, Option<&'tcx mir::Place<'tcx>>)> {\n+) -> Option<(def_id::DefId, mir::Local, Ty<'tcx>, Option<&'tcx mir::Place<'tcx>>)> {\n     if_chain! {\n         if let TerminatorKind::Call { func, args, destination, .. } = kind;\n         if args.len() == 1;\n@@ -299,7 +299,7 @@ fn base_local_and_movability<'tcx>(\n                 place = &proj.base;\n                 deref = deref || matches!(proj.elem, mir::ProjectionElem::Deref);\n                 if !field && matches!(proj.elem, mir::ProjectionElem::Field(..)) {\n-                    field = has_drop(cx, place.ty(&mir.local_decls, cx.tcx).to_ty(cx.tcx));\n+                    field = has_drop(cx, place.ty(&mir.local_decls, cx.tcx).ty);\n                 }\n             },\n             _ => return None,"}, {"sha": "3995d9f2819c225a54ee839b346240deda6688f6", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -263,7 +263,7 @@ impl EarlyLintPass for ReturnPass {\n }\n \n fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.name() == \"cfg\"\n+    attr.meta_item_list().is_some() && attr.check_name(\"cfg\")\n }\n \n // get the def site"}, {"sha": "e4eb1bb0b7406bd739f8b6c9b0fdac5a7b6531a5", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -347,7 +347,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     |db| {\n                                         let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n                                         let arg = if let ty::Int(_) = from_ty.sty {\n-                                            arg.as_ty(ty::Uint(ast::UintTy::U32))\n+                                            arg.as_ty(ast::UintTy::U32)\n                                         } else {\n                                             arg\n                                         };"}, {"sha": "e0f19a146541e5fb545ea8e0fffda1cf72968a1b", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n                     return;\n                 }\n                 for a in attrs {\n-                    if a.meta_item_list().is_some() && a.name() == \"proc_macro_derive\" {\n+                    if a.meta_item_list().is_some() && a.check_name(\"proc_macro_derive\") {\n                         return;\n                     }\n                 }"}, {"sha": "95609d3f302961bd9fc2ac90dccd7a1613a4db45", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -10,6 +10,7 @@ use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisito\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::ty::layout::LayoutOf;\n+use rustc::ty::print::Printer;\n use rustc::ty::{self, InferTy, Ty, TyCtxt, TypeckTables};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n@@ -24,7 +25,7 @@ use crate::utils::paths;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro, int_bits, last_path_segment,\n     match_def_path, match_path, multispan_sugg, same_tys, sext, snippet, snippet_opt, snippet_with_applicability,\n-    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext, AbsolutePathBuffer,\n+    span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext, AbsolutePathPrinter,\n };\n \n /// Handles all the linting of funky types\n@@ -1135,15 +1136,14 @@ impl LintPass for CastPass {\n \n // Check if the given type is either `core::ffi::c_void` or\n // one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'_>) -> bool {\n+fn is_c_void<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'_>) -> bool {\n     if let ty::Adt(adt, _) = ty.sty {\n-        let mut apb = AbsolutePathBuffer { names: vec![] };\n-        tcx.push_item_path(&mut apb, adt.did, false);\n+        let names = AbsolutePathPrinter { tcx }.print_def_path(adt.did, &[]).unwrap();\n \n-        if apb.names.is_empty() {\n+        if names.is_empty() {\n             return false;\n         }\n-        if apb.names[0] == \"libc\" || apb.names[0] == \"core\" && *apb.names.last().unwrap() == \"c_void\" {\n+        if names[0] == \"libc\" || names[0] == \"core\" && *names.last().unwrap() == \"c_void\" {\n             return true;\n         }\n     }\n@@ -1533,7 +1533,7 @@ impl LintPass for CharLitAsU8 {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        use syntax::ast::{LitKind, UintTy};\n+        use syntax::ast::LitKind;\n \n         if let ExprKind::Cast(ref e, _) = expr.node {\n             if let ExprKind::Lit(ref l) = e.node {\n@@ -1818,7 +1818,6 @@ impl Ord for FullInt {\n \n fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n     use std::*;\n-    use syntax::ast::{IntTy, UintTy};\n \n     if let ExprKind::Cast(ref cast_exp, _) = expr.node {\n         let pre_cast_ty = cx.tables.expr_ty(cast_exp);\n@@ -2075,7 +2074,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(item.hir_id)) {\n+        if !cx.access_levels.is_exported(item.hir_id) {\n             return;\n         }\n "}, {"sha": "d3b011a3bd983fbba296d2f153f40f2df26c109e", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -4,6 +4,7 @@ use rustc::hir::intravisit::{walk_item, walk_path, walk_ty, NestedVisitorMap, Vi\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::ty;\n+use rustc::ty::DefIdTree;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use syntax_pos::symbol::keywords::SelfUpper;\n@@ -232,8 +233,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n         if path.segments.last().expect(SEGMENTS_MSG).ident.name != SelfUpper.name() {\n             if self.item_path.def == path.def {\n                 span_use_self_lint(self.cx, path);\n-            } else if let Def::StructCtor(ctor_did, CtorKind::Fn) = path.def {\n-                if self.item_path.def.opt_def_id() == self.cx.tcx.parent_def_id(ctor_did) {\n+            } else if let Def::Ctor(ctor_did, def::CtorOf::Struct, CtorKind::Fn) = path.def {\n+                if self.item_path.def.opt_def_id() == self.cx.tcx.parent(ctor_did) {\n                     span_use_self_lint(self.cx, path);\n                 }\n             }"}, {"sha": "2c96d9a8b5aa58fc9e6986516268e752070bf4e6", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -11,11 +11,9 @@ use syntax::{ast, source_map};\n use toml;\n \n /// Gets the configuration file from arguments.\n-pub fn file_from_args(\n-    args: &[source_map::Spanned<ast::NestedMetaItemKind>],\n-) -> Result<Option<path::PathBuf>, (&'static str, source_map::Span)> {\n-    for arg in args.iter().filter_map(syntax::source_map::Spanned::meta_item) {\n-        if arg.name() == \"conf_file\" {\n+pub fn file_from_args(args: &[ast::NestedMetaItem]) -> Result<Option<path::PathBuf>, (&'static str, source_map::Span)> {\n+    for arg in args.iter().filter_map(syntax::ast::NestedMetaItem::meta_item) {\n+        if arg.check_name(\"conf_file\") {\n             return match arg.node {\n                 ast::MetaItemKind::Word | ast::MetaItemKind::List(_) => {\n                     Err((\"`conf_file` must be a named value\", arg.span))"}, {"sha": "3590b7ae9eea0ec698085c3b2e5846d8286f79f5", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 105, "deletions": 23, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -24,8 +24,10 @@ use if_chain::if_chain;\n use matches::matches;\n use rustc::hir;\n use rustc::hir::def::Def;\n+use rustc::hir::def_id::CrateNum;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n+use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n use rustc::hir::Node;\n use rustc::hir::*;\n use rustc::lint::{LateContext, Level, Lint, LintContext};\n@@ -41,8 +43,7 @@ use rustc_errors::Applicability;\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::source_map::{Span, DUMMY_SP};\n-use syntax::symbol;\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::{keywords, LocalInternedString, Symbol};\n \n use crate::reexport::*;\n \n@@ -97,19 +98,102 @@ pub fn in_macro(span: Span) -> bool {\n /// Used to store the absolute path to a type.\n ///\n /// See `match_def_path` for usage.\n-#[derive(Debug)]\n-pub struct AbsolutePathBuffer {\n-    pub names: Vec<symbol::LocalInternedString>,\n+pub struct AbsolutePathPrinter<'a, 'tcx> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n-    fn root_mode(&self) -> &ty::item_path::RootMode {\n-        const ABSOLUTE: &ty::item_path::RootMode = &ty::item_path::RootMode::Absolute;\n-        ABSOLUTE\n+use rustc::ty::print::Printer;\n+\n+#[allow(clippy::diverging_sub_expression)]\n+impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+    type Error = !;\n+\n+    type Path = Vec<LocalInternedString>;\n+    type Region = ();\n+    type Type = ();\n+    type DynExistential = ();\n+\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn print_region(self, _region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n+        Ok(())\n+    }\n+\n+    fn print_type(self, _ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n+        Ok(())\n+    }\n+\n+    fn print_dyn_existential(\n+        self,\n+        _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        Ok(())\n+    }\n+\n+    fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n+        Ok(vec![self.tcx.original_crate_name(cnum).as_str()])\n+    }\n+\n+    fn path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        if trait_ref.is_none() {\n+            if let ty::Adt(def, substs) = self_ty.sty {\n+                return self.print_def_path(def.did, substs);\n+            }\n+        }\n+\n+        // This shouldn't ever be needed, but just in case:\n+        Ok(vec![match trait_ref {\n+            Some(trait_ref) => Symbol::intern(&format!(\"{:?}\", trait_ref)).as_str(),\n+            None => Symbol::intern(&format!(\"<{}>\", self_ty)).as_str(),\n+        }])\n+    }\n+\n+    fn path_append_impl(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let mut path = print_prefix(self)?;\n+\n+        // This shouldn't ever be needed, but just in case:\n+        path.push(match trait_ref {\n+            Some(trait_ref) => Symbol::intern(&format!(\"<impl {} for {}>\", trait_ref, self_ty)).as_str(),\n+            None => Symbol::intern(&format!(\"<impl {}>\", self_ty)).as_str(),\n+        });\n+\n+        Ok(path)\n     }\n \n-    fn push(&mut self, text: &str) {\n-        self.names.push(symbol::Symbol::intern(text).as_str());\n+    fn path_append(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let mut path = print_prefix(self)?;\n+\n+        // Skip `::{{constructor}}` on tuple/unit structs.\n+        if let DefPathData::Ctor = disambiguated_data.data {\n+            return Ok(path);\n+        }\n+\n+        path.push(disambiguated_data.data.as_interned_str().as_str());\n+        Ok(path)\n+    }\n+\n+    fn path_generic_args(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _args: &[Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        print_prefix(self)\n     }\n }\n \n@@ -121,12 +205,10 @@ impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n /// ```\n ///\n /// See also the `paths` module.\n-pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) -> bool {\n-    let mut apb = AbsolutePathBuffer { names: vec![] };\n-\n-    tcx.push_item_path(&mut apb, def_id, false);\n+pub fn match_def_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, path: &[&str]) -> bool {\n+    let names = get_def_path(tcx, def_id);\n \n-    apb.names.len() == path.len() && apb.names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n+    names.len() == path.len() && names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n }\n \n /// Gets the absolute path of `def_id` as a vector of `&str`.\n@@ -138,12 +220,12 @@ pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) ->\n ///     // The given `def_id` is that of an `Option` type\n /// };\n /// ```\n-pub fn get_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Vec<&'static str> {\n-    let mut apb = AbsolutePathBuffer { names: vec![] };\n-    tcx.push_item_path(&mut apb, def_id, false);\n-    apb.names\n+pub fn get_def_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Vec<&'static str> {\n+    AbsolutePathPrinter { tcx }\n+        .print_def_path(def_id, &[])\n+        .unwrap()\n         .iter()\n-        .map(syntax_pos::symbol::LocalInternedString::get)\n+        .map(LocalInternedString::get)\n         .collect()\n }\n \n@@ -787,7 +869,7 @@ pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n     fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> bool {\n         matches!(\n             cx.tables.qpath_def(qpath, id),\n-            def::Def::Variant(..) | def::Def::VariantCtor(..)\n+            def::Def::Variant(..) | def::Def::Ctor(_, def::CtorOf::Variant, _)\n         )\n     }\n \n@@ -1010,7 +1092,7 @@ pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: HirId)\n }\n \n /// Returns true if ty has `iter` or `iter_mut` methods\n-pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: ty::Ty<'_>) -> Option<&'static str> {\n+pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n     // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n     // exists and has the desired signature. Unfortunately FnCtxt is not exported\n     // so we can't use its `lookup_method` method."}, {"sha": "9b8b2372c53bc38d8a1feb675fa0ab43871f13fa", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -59,6 +59,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             then {\n                 // report the error around the `vec!` not inside `<std macros>:`\n                 let span = arg.span\n+                    .ctxt()\n+                    .outer()\n+                    .expn_info()\n+                    .map(|info| info.call_site)\n+                    .expect(\"unable to get call_site\")\n                     .ctxt()\n                     .outer()\n                     .expn_info()"}, {"sha": "a45551dbf9c523a03aeb18967c3be3d17451581f", "filename": "doc/adding_lints.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -115,7 +115,7 @@ where all the lint code is. We are going to call the file\n `clippy_lints/src/foo_functions.rs` and import some initial things we need:\n \n ```rust\n-use rustc::lint::{LintArray, LintPass};\n+use rustc::lint::{LintArray, LintPass, EarlyLintPass};\n use rustc::{declare_tool_lint, lint_array};\n ```\n \n@@ -161,6 +161,8 @@ impl LintPass for FooFunctionsPass {\n         \"FooFunctions\"\n     }\n }\n+\n+impl EarlyLintPass for FooFunctionsPass {}\n ```\n \n Don't worry about the `name` method here. As long as it includes the name of the"}, {"sha": "834d11861c0d58540e9420c82f64a41f379f1399", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -93,7 +93,7 @@ impl rustc_driver::Callbacks for ClippyCallbacks {\n             ls.register_early_pass(Some(sess), true, false, pass);\n         }\n         for pass in late_lint_passes {\n-            ls.register_late_pass(Some(sess), true, pass);\n+            ls.register_late_pass(Some(sess), true, false, false, pass);\n         }\n \n         for (name, (to, deprecated_name)) in lint_groups {"}, {"sha": "1a53b9659082e1755186a733d8ddb7a0cc24b2bc", "filename": "tests/compile-test.rs", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -1,7 +1,7 @@\n #![feature(test)]\n \n use compiletest_rs as compiletest;\n-extern crate test;\n+use libtest::TestDescAndFn;\n \n use std::env::{set_var, var};\n use std::ffi::OsStr;\n@@ -74,15 +74,12 @@ fn run_mode(mode: &str, dir: PathBuf) {\n     compiletest::run_tests(&cfg);\n }\n \n-fn run_ui_toml_tests(config: &compiletest::Config, mut tests: Vec<test::TestDescAndFn>) -> Result<bool, io::Error> {\n+#[warn(clippy::identity_conversion)]\n+fn run_ui_toml_tests(config: &compiletest::Config, mut tests: Vec<TestDescAndFn>) -> Result<bool, io::Error> {\n     let mut result = true;\n     let opts = compiletest::test_opts(config);\n     for dir in fs::read_dir(&config.src_base)? {\n-        let dir = dir?;\n-        if !dir.file_type()?.is_dir() {\n-            continue;\n-        }\n-        let dir_path = dir.path();\n+        let dir_path = dir.unwrap().path();\n         set_var(\"CARGO_MANIFEST_DIR\", &dir_path);\n         for file in fs::read_dir(&dir_path)? {\n             let file = file?;\n@@ -101,9 +98,25 @@ fn run_ui_toml_tests(config: &compiletest::Config, mut tests: Vec<test::TestDesc\n             let test_name = compiletest::make_test_name(&config, &paths);\n             let index = tests\n                 .iter()\n-                .position(|test| test.desc.name == test_name)\n+                .position(|test| test.desc.name.to_string() == test_name.to_string())\n                 .expect(\"The test should be in there\");\n-            result &= test::run_tests_console(&opts, vec![tests.swap_remove(index)])?;\n+            let opts = libtest::TestOpts {\n+                list: opts.list,\n+                filter: opts.filter.clone(),\n+                filter_exact: opts.filter_exact,\n+                exclude_should_panic: Default::default(),\n+                run_ignored: libtest::RunIgnored::No,\n+                run_tests: opts.run_tests,\n+                bench_benchmarks: opts.bench_benchmarks,\n+                logfile: opts.logfile.clone(),\n+                nocapture: opts.nocapture,\n+                color: libtest::ColorConfig::AutoColor,\n+                format: libtest::OutputFormat::Pretty,\n+                test_threads: opts.test_threads,\n+                skip: opts.skip.clone(),\n+                options: libtest::Options::new(),\n+            };\n+            result &= libtest::run_tests_console(&opts, vec![tests.swap_remove(index)])?;\n         }\n     }\n     Ok(result)\n@@ -114,6 +127,22 @@ fn run_ui_toml() {\n     let config = config(\"ui\", path);\n     let tests = compiletest::make_tests(&config);\n \n+    let tests = tests\n+        .into_iter()\n+        .map(|test| {\n+            libtest::TestDescAndFn {\n+                desc: libtest::TestDesc {\n+                    name: libtest::TestName::DynTestName(test.desc.name.to_string()),\n+                    ignore: test.desc.ignore,\n+                    allow_fail: test.desc.allow_fail,\n+                    should_panic: libtest::ShouldPanic::No,\n+                },\n+                // oli obk giving up\n+                testfn: unsafe { std::mem::transmute(test.testfn) },\n+            }\n+        })\n+        .collect();\n+\n     let res = run_ui_toml_tests(&config, tests);\n     match res {\n         Ok(true) => {},"}, {"sha": "c1ad236148405e61f33455ae24492f991f60f7dc", "filename": "tests/ui/for_loop.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Ffor_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Ffor_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.stderr?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -198,83 +198,83 @@ error: it is more concise to loop over references to containers instead of using\n   --> $DIR/for_loop.rs:170:15\n    |\n LL |     for _v in vec.iter() {}\n-   |               ^^^^^^^^^^ help: to write this more concisely, try: `&vec`\n+   |               ^^^^^^^^^^\n    |\n    = note: `-D clippy::explicit-iter-loop` implied by `-D warnings`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:172:15\n    |\n LL |     for _v in vec.iter_mut() {}\n-   |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&mut vec`\n+   |               ^^^^^^^^^^^^^^\n \n error: it is more concise to loop over containers instead of using explicit iteration methods`\n   --> $DIR/for_loop.rs:175:15\n    |\n LL |     for _v in out_vec.into_iter() {}\n-   |               ^^^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `out_vec`\n+   |               ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::explicit-into-iter-loop` implied by `-D warnings`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:178:15\n    |\n LL |     for _v in array.into_iter() {}\n-   |               ^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `&array`\n+   |               ^^^^^^^^^^^^^^^^^\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:183:15\n    |\n LL |     for _v in [1, 2, 3].iter() {}\n-   |               ^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[1, 2, 3]`\n+   |               ^^^^^^^^^^^^^^^^\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:187:15\n    |\n LL |     for _v in [0; 32].iter() {}\n-   |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[0; 32]`\n+   |               ^^^^^^^^^^^^^^\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:192:15\n    |\n LL |     for _v in ll.iter() {}\n-   |               ^^^^^^^^^ help: to write this more concisely, try: `&ll`\n+   |               ^^^^^^^^^\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:195:15\n    |\n LL |     for _v in vd.iter() {}\n-   |               ^^^^^^^^^ help: to write this more concisely, try: `&vd`\n+   |               ^^^^^^^^^\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:198:15\n    |\n LL |     for _v in bh.iter() {}\n-   |               ^^^^^^^^^ help: to write this more concisely, try: `&bh`\n+   |               ^^^^^^^^^\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:201:15\n    |\n LL |     for _v in hm.iter() {}\n-   |               ^^^^^^^^^ help: to write this more concisely, try: `&hm`\n+   |               ^^^^^^^^^\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:204:15\n    |\n LL |     for _v in bt.iter() {}\n-   |               ^^^^^^^^^ help: to write this more concisely, try: `&bt`\n+   |               ^^^^^^^^^\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:207:15\n    |\n LL |     for _v in hs.iter() {}\n-   |               ^^^^^^^^^ help: to write this more concisely, try: `&hs`\n+   |               ^^^^^^^^^\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n   --> $DIR/for_loop.rs:210:15\n    |\n LL |     for _v in bs.iter() {}\n-   |               ^^^^^^^^^ help: to write this more concisely, try: `&bs`\n+   |               ^^^^^^^^^\n \n error: you are iterating over `Iterator::next()` which is an Option; this will compile but is probably not what you want\n   --> $DIR/for_loop.rs:212:15"}, {"sha": "659fd56f9a9d9bf7ae237dd06a98caa5c78427b7", "filename": "tests/ui/into_iter_on_ref.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Finto_iter_on_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Finto_iter_on_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finto_iter_on_ref.fixed?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     for _ in &[1, 2, 3] {}\n     for _ in vec![X, X] {}\n     for _ in &vec![X, X] {}\n-    for _ in [1, 2, 3].iter() {} //~ ERROR equivalent to .iter()\n+    for _ in [1, 2, 3].into_iter() {} //~ ERROR equivalent to .iter()\n \n     let _ = [1, 2, 3].iter(); //~ ERROR equivalent to .iter()\n     let _ = vec![1, 2, 3].into_iter();"}, {"sha": "c3e5c85618b8a3c0fb2d8d45128d68e73fe3e2b2", "filename": "tests/ui/into_iter_on_ref.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Finto_iter_on_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Finto_iter_on_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finto_iter_on_ref.stderr?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -1,21 +1,15 @@\n error: this .into_iter() call is equivalent to .iter() and will not move the array\n-  --> $DIR/into_iter_on_ref.rs:13:24\n+  --> $DIR/into_iter_on_ref.rs:15:23\n    |\n-LL |     for _ in [1, 2, 3].into_iter() {} //~ ERROR equivalent to .iter()\n-   |                        ^^^^^^^^^ help: call directly: `iter`\n+LL |     let _ = [1, 2, 3].into_iter(); //~ ERROR equivalent to .iter()\n+   |                       ^^^^^^^^^ help: call directly: `iter`\n    |\n note: lint level defined here\n   --> $DIR/into_iter_on_ref.rs:4:9\n    |\n LL | #![deny(clippy::into_iter_on_array)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: this .into_iter() call is equivalent to .iter() and will not move the array\n-  --> $DIR/into_iter_on_ref.rs:15:23\n-   |\n-LL |     let _ = [1, 2, 3].into_iter(); //~ ERROR equivalent to .iter()\n-   |                       ^^^^^^^^^ help: call directly: `iter`\n-\n error: this .into_iter() call is equivalent to .iter() and will not move the Vec\n   --> $DIR/into_iter_on_ref.rs:17:30\n    |\n@@ -174,5 +168,5 @@ error: this .into_iter() call is equivalent to .iter() and will not move the Pat\n LL |     let _ = std::path::PathBuf::from(\"12/34\").into_iter(); //~ ERROR equivalent to .iter()\n    |                                               ^^^^^^^^^ help: call directly: `iter`\n \n-error: aborting due to 28 previous errors\n+error: aborting due to 27 previous errors\n "}, {"sha": "5f3f95bab98057a9d366ed4343afdf27f3e10dea", "filename": "tests/ui/literals.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fliterals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fliterals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fliterals.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -37,27 +37,9 @@ fn main() {\n     let ok16 = 0xFE_BAFE_ABAB_ABCD;\n     let ok17 = 0x123_4567_8901_usize;\n \n-    let fail9 = 0xabcdef;\n-    let fail10 = 0xBAFEBAFE;\n-    let fail11 = 0xabcdeff;\n-    let fail12 = 0xabcabcabcabcabcabc;\n     let fail13 = 0x1_23456_78901_usize;\n \n-    let fail14 = 2_32;\n-    let fail15 = 4_64;\n-    let fail16 = 7_8;\n-    let fail17 = 23_16;\n-    let ok18 = 23_128;\n     let fail19 = 12_3456_21;\n-    let fail20 = 2__8;\n-    let fail21 = 4___16;\n     let fail22 = 3__4___23;\n     let fail23 = 3__16___23;\n-\n-    let fail24 = 12.34_64;\n-    let fail25 = 1E2_32;\n-    let fail26 = 43E7_64;\n-    let fail27 = 243E17_32;\n-    let fail28 = 241251235E723_64;\n-    let fail29 = 42279.911_32;\n }"}, {"sha": "22692160d73ad16fc386c5cb955c8e0b864ad003", "filename": "tests/ui/literals.stderr", "status": "modified", "additions": 5, "deletions": 105, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fliterals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fliterals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fliterals.stderr?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -86,133 +86,33 @@ help: if you mean to use an octal constant, use `0o`\n LL |     let fail8 = 0o123;\n    |                 ^^^^^\n \n-error: long literal lacking separators\n-  --> $DIR/literals.rs:40:17\n-   |\n-LL |     let fail9 = 0xabcdef;\n-   |                 ^^^^^^^^ help: consider: `0x00ab_cdef`\n-   |\n-   = note: `-D clippy::unreadable-literal` implied by `-D warnings`\n-\n-error: long literal lacking separators\n-  --> $DIR/literals.rs:41:18\n-   |\n-LL |     let fail10 = 0xBAFEBAFE;\n-   |                  ^^^^^^^^^^ help: consider: `0xBAFE_BAFE`\n-\n-error: long literal lacking separators\n-  --> $DIR/literals.rs:42:18\n-   |\n-LL |     let fail11 = 0xabcdeff;\n-   |                  ^^^^^^^^^ help: consider: `0x0abc_deff`\n-\n-error: long literal lacking separators\n-  --> $DIR/literals.rs:43:18\n-   |\n-LL |     let fail12 = 0xabcabcabcabcabcabc;\n-   |                  ^^^^^^^^^^^^^^^^^^^^ help: consider: `0x00ab_cabc_abca_bcab_cabc`\n-\n error: digit groups should be smaller\n-  --> $DIR/literals.rs:44:18\n+  --> $DIR/literals.rs:40:18\n    |\n LL |     let fail13 = 0x1_23456_78901_usize;\n    |                  ^^^^^^^^^^^^^^^^^^^^^ help: consider: `0x0123_4567_8901_usize`\n    |\n    = note: `-D clippy::large-digit-groups` implied by `-D warnings`\n \n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:46:18\n-   |\n-LL |     let fail14 = 2_32;\n-   |                  ^^^^ help: did you mean to write: `2_i32`\n-   |\n-   = note: #[deny(clippy::mistyped_literal_suffixes)] on by default\n-\n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:47:18\n-   |\n-LL |     let fail15 = 4_64;\n-   |                  ^^^^ help: did you mean to write: `4_i64`\n-\n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:48:18\n-   |\n-LL |     let fail16 = 7_8;\n-   |                  ^^^ help: did you mean to write: `7_i8`\n-\n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:49:18\n-   |\n-LL |     let fail17 = 23_16;\n-   |                  ^^^^^ help: did you mean to write: `23_i16`\n-\n error: digits grouped inconsistently by underscores\n-  --> $DIR/literals.rs:51:18\n+  --> $DIR/literals.rs:42:18\n    |\n LL |     let fail19 = 12_3456_21;\n    |                  ^^^^^^^^^^ help: consider: `12_345_621`\n    |\n    = note: `-D clippy::inconsistent-digit-grouping` implied by `-D warnings`\n \n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:52:18\n-   |\n-LL |     let fail20 = 2__8;\n-   |                  ^^^^ help: did you mean to write: `2_i8`\n-\n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:53:18\n-   |\n-LL |     let fail21 = 4___16;\n-   |                  ^^^^^^ help: did you mean to write: `4_i16`\n-\n error: digits grouped inconsistently by underscores\n-  --> $DIR/literals.rs:54:18\n+  --> $DIR/literals.rs:43:18\n    |\n LL |     let fail22 = 3__4___23;\n    |                  ^^^^^^^^^ help: consider: `3_423`\n \n error: digits grouped inconsistently by underscores\n-  --> $DIR/literals.rs:55:18\n+  --> $DIR/literals.rs:44:18\n    |\n LL |     let fail23 = 3__16___23;\n    |                  ^^^^^^^^^^ help: consider: `31_623`\n \n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:57:18\n-   |\n-LL |     let fail24 = 12.34_64;\n-   |                  ^^^^^^^^ help: did you mean to write: `12.34_f64`\n-\n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:58:18\n-   |\n-LL |     let fail25 = 1E2_32;\n-   |                  ^^^^^^ help: did you mean to write: `1E2_f32`\n-\n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:59:18\n-   |\n-LL |     let fail26 = 43E7_64;\n-   |                  ^^^^^^^ help: did you mean to write: `43E7_f64`\n-\n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:60:18\n-   |\n-LL |     let fail27 = 243E17_32;\n-   |                  ^^^^^^^^^ help: did you mean to write: `243E17_f32`\n-\n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:61:18\n-   |\n-LL |     let fail28 = 241251235E723_64;\n-   |                  ^^^^^^^^^^^^^^^^ help: did you mean to write: `241_251_235E723_f64`\n-\n-error: mistyped literal suffix\n-  --> $DIR/literals.rs:62:18\n-   |\n-LL |     let fail29 = 42279.911_32;\n-   |                  ^^^^^^^^^^^^ help: did you mean to write: `42_279.911_f32`\n-\n-error: aborting due to 31 previous errors\n+error: aborting due to 15 previous errors\n "}, {"sha": "51fd57df8df1da962322d50dc6edcf85726e9661", "filename": "tests/ui/missing-doc-crate-missing.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmissing-doc-crate-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmissing-doc-crate-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing-doc-crate-missing.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -0,0 +1,3 @@\n+#![warn(clippy::missing_docs_in_private_items)]\n+\n+fn main() {}"}, {"sha": "da46f9886366c821f2f5feb90555f90e728be166", "filename": "tests/ui/missing-doc-crate-missing.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmissing-doc-crate-missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmissing-doc-crate-missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing-doc-crate-missing.stderr?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -0,0 +1,12 @@\n+error: missing documentation for crate\n+  --> $DIR/missing-doc-crate-missing.rs:1:1\n+   |\n+LL | / #![warn(clippy::missing_docs_in_private_items)]\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n+   |\n+   = note: `-D clippy::missing-docs-in-private-items` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "04711f864886b06aab41b07bef741e9a2e84271d", "filename": "tests/ui/missing-doc-crate.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmissing-doc-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmissing-doc-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing-doc-crate.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -0,0 +1,5 @@\n+#![warn(clippy::missing_docs_in_private_items)]\n+#![feature(external_doc)]\n+#![doc(include = \"../../README.md\")]\n+\n+fn main() {}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/missing-doc-crate.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmissing-doc-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmissing-doc-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing-doc-crate.stderr?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0"}, {"sha": "531e44a781c254ac4aece6bee2f7d3ae0662bb97", "filename": "tests/ui/mistyped_literal_suffix.fixed", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmistyped_literal_suffix.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmistyped_literal_suffix.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.fixed?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+#![allow(dead_code, unused_variables, clippy::excessive_precision)]\n+\n+fn main() {\n+    let fail14 = 2_i32;\n+    let fail15 = 4_i64;\n+    let fail16 = 7_i8; //\n+    let fail17 = 23_i16; //\n+    let ok18 = 23_128;\n+\n+    let fail20 = 2_i8; //\n+    let fail21 = 4_i16; //\n+\n+    let fail24 = 12.34_f64;\n+    let fail25 = 1E2_f32;\n+    let fail26 = 43E7_f64;\n+    let fail27 = 243E17_f32;\n+    #[allow(overflowing_literals)]\n+    let fail28 = 241_251_235E723_f64;\n+    let fail29 = 42_279.911_f32;\n+}"}, {"sha": "d67c842b4af49d6ca436e3ade09345b1aa5c7ab5", "filename": "tests/ui/mistyped_literal_suffix.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmistyped_literal_suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmistyped_literal_suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+#![allow(dead_code, unused_variables, clippy::excessive_precision)]\n+\n+fn main() {\n+    let fail14 = 2_32;\n+    let fail15 = 4_64;\n+    let fail16 = 7_8; //\n+    let fail17 = 23_16; //\n+    let ok18 = 23_128;\n+\n+    let fail20 = 2__8; //\n+    let fail21 = 4___16; //\n+\n+    let fail24 = 12.34_64;\n+    let fail25 = 1E2_32;\n+    let fail26 = 43E7_64;\n+    let fail27 = 243E17_32;\n+    #[allow(overflowing_literals)]\n+    let fail28 = 241251235E723_64;\n+    let fail29 = 42279.911_32;\n+}"}, {"sha": "c3fed6ae8fdc93d2ea33e351266e82116f55b905", "filename": "tests/ui/mistyped_literal_suffix.stderr", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmistyped_literal_suffix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fmistyped_literal_suffix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.stderr?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -0,0 +1,76 @@\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:6:18\n+   |\n+LL |     let fail14 = 2_32;\n+   |                  ^^^^ help: did you mean to write: `2_i32`\n+   |\n+   = note: #[deny(clippy::mistyped_literal_suffixes)] on by default\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:7:18\n+   |\n+LL |     let fail15 = 4_64;\n+   |                  ^^^^ help: did you mean to write: `4_i64`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:8:18\n+   |\n+LL |     let fail16 = 7_8; //\n+   |                  ^^^ help: did you mean to write: `7_i8`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:9:18\n+   |\n+LL |     let fail17 = 23_16; //\n+   |                  ^^^^^ help: did you mean to write: `23_i16`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:12:18\n+   |\n+LL |     let fail20 = 2__8; //\n+   |                  ^^^^ help: did you mean to write: `2_i8`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:13:18\n+   |\n+LL |     let fail21 = 4___16; //\n+   |                  ^^^^^^ help: did you mean to write: `4_i16`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:15:18\n+   |\n+LL |     let fail24 = 12.34_64;\n+   |                  ^^^^^^^^ help: did you mean to write: `12.34_f64`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:16:18\n+   |\n+LL |     let fail25 = 1E2_32;\n+   |                  ^^^^^^ help: did you mean to write: `1E2_f32`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:17:18\n+   |\n+LL |     let fail26 = 43E7_64;\n+   |                  ^^^^^^^ help: did you mean to write: `43E7_f64`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:18:18\n+   |\n+LL |     let fail27 = 243E17_32;\n+   |                  ^^^^^^^^^ help: did you mean to write: `243E17_f32`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:20:18\n+   |\n+LL |     let fail28 = 241251235E723_64;\n+   |                  ^^^^^^^^^^^^^^^^ help: did you mean to write: `241_251_235E723_f64`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:21:18\n+   |\n+LL |     let fail29 = 42279.911_32;\n+   |                  ^^^^^^^^^^^^ help: did you mean to write: `42_279.911_f32`\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "f031dd105c25445568c5a729f2bbf6e28156f2e9", "filename": "tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -95,7 +95,7 @@ impl<T: Serialize, U> S<T, U> {\n         s.len() + t.capacity()\n     }\n \n-    fn bar(_t: T // Ok, since `&T: Serialize` too\n+    fn bar(_t: T, // Ok, since `&T: Serialize` too\n     ) {\n     }\n "}, {"sha": "1fc93b9c3a8b5972910d1204c14121605f3720e5", "filename": "tests/ui/unreadable_literal.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Funreadable_literal.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Funreadable_literal.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funreadable_literal.fixed?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -17,4 +17,9 @@ fn main() {\n     let bad = (0b11_0110_i64, 0x0123_4567_8901_usize, 123_456_f32, 1.234_567_f32);\n     let good_sci = 1.1234e1;\n     let bad_sci = 1.123_456e1;\n+\n+    let fail9 = 0x00ab_cdef;\n+    let fail10: u32 = 0xBAFE_BAFE;\n+    let fail11 = 0x0abc_deff;\n+    let fail12: i128 = 0x00ab_cabc_abca_bcab_cabc;\n }"}, {"sha": "ef0ef2b9b9e5216e7cccda3dd5f63ac5a57ef618", "filename": "tests/ui/unreadable_literal.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Funreadable_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Funreadable_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funreadable_literal.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -17,4 +17,9 @@ fn main() {\n     let bad = (0b110110_i64, 0x12345678901_usize, 123456_f32, 1.234567_f32);\n     let good_sci = 1.1234e1;\n     let bad_sci = 1.123456e1;\n+\n+    let fail9 = 0xabcdef;\n+    let fail10: u32 = 0xBAFEBAFE;\n+    let fail11 = 0xabcdeff;\n+    let fail12: i128 = 0xabcabcabcabcabcabc;\n }"}, {"sha": "2ece537828751ff13a3988548504668b810079d7", "filename": "tests/ui/unreadable_literal.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Funreadable_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Funreadable_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funreadable_literal.stderr?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -30,5 +30,29 @@ error: long literal lacking separators\n LL |     let bad_sci = 1.123456e1;\n    |                   ^^^^^^^^^^ help: consider: `1.123_456e1`\n \n-error: aborting due to 5 previous errors\n+error: long literal lacking separators\n+  --> $DIR/unreadable_literal.rs:21:17\n+   |\n+LL |     let fail9 = 0xabcdef;\n+   |                 ^^^^^^^^ help: consider: `0x00ab_cdef`\n+\n+error: long literal lacking separators\n+  --> $DIR/unreadable_literal.rs:22:23\n+   |\n+LL |     let fail10: u32 = 0xBAFEBAFE;\n+   |                       ^^^^^^^^^^ help: consider: `0xBAFE_BAFE`\n+\n+error: long literal lacking separators\n+  --> $DIR/unreadable_literal.rs:23:18\n+   |\n+LL |     let fail11 = 0xabcdeff;\n+   |                  ^^^^^^^^^ help: consider: `0x0abc_deff`\n+\n+error: long literal lacking separators\n+  --> $DIR/unreadable_literal.rs:24:24\n+   |\n+LL |     let fail12: i128 = 0xabcabcabcabcabcabc;\n+   |                        ^^^^^^^^^^^^^^^^^^^^ help: consider: `0x00ab_cabc_abca_bcab_cabc`\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "68af85030ab2ed8e08f4924809a26270dc13d0c2", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -239,6 +239,7 @@ mod nesting {\n     struct Foo {}\n     impl Foo {\n         fn foo() {\n+            #[allow(unused_imports)]\n             use self::Foo; // Can't use Self here\n             struct Bar {\n                 foo: Foo, // Foo != Self"}, {"sha": "7a6d415528ad569b4241ef37d52b2310c6bee0b7", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -239,6 +239,7 @@ mod nesting {\n     struct Foo {}\n     impl Foo {\n         fn foo() {\n+            #[allow(unused_imports)]\n             use self::Foo; // Can't use Self here\n             struct Bar {\n                 foo: Foo, // Foo != Self"}, {"sha": "bf1f41fd64ede87bd15c2e69e6b085e52ff66f03", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -151,43 +151,43 @@ LL |         use_self_expand!(); // Should lint in local macros\n    |         ------------------- in this macro invocation\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:260:21\n+  --> $DIR/use_self.rs:261:21\n    |\n LL |         fn baz() -> Foo {\n    |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:261:13\n+  --> $DIR/use_self.rs:262:13\n    |\n LL |             Foo {}\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:248:29\n+  --> $DIR/use_self.rs:249:29\n    |\n LL |                 fn bar() -> Bar {\n    |                             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:249:21\n+  --> $DIR/use_self.rs:250:21\n    |\n LL |                     Bar { foo: Foo {} }\n    |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:303:13\n+  --> $DIR/use_self.rs:304:13\n    |\n LL |             nested::A::fun_1();\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:304:13\n+  --> $DIR/use_self.rs:305:13\n    |\n LL |             nested::A::A;\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:306:13\n+  --> $DIR/use_self.rs:307:13\n    |\n LL |             nested::A {};\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`"}, {"sha": "c6fce5df210d3c4f73c75f61174ee726258c9959", "filename": "tests/ui/useless_asref.fixed", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuseless_asref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuseless_asref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.fixed?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -0,0 +1,136 @@\n+// run-rustfix\n+\n+#![deny(clippy::useless_asref)]\n+#![allow(clippy::trivially_copy_pass_by_ref)]\n+\n+use std::fmt::Debug;\n+\n+struct FakeAsRef;\n+\n+#[allow(clippy::should_implement_trait)]\n+impl FakeAsRef {\n+    fn as_ref(&self) -> &Self {\n+        self\n+    }\n+}\n+\n+struct MoreRef;\n+\n+impl<'a, 'b, 'c> AsRef<&'a &'b &'c MoreRef> for MoreRef {\n+    fn as_ref(&self) -> &&'a &'b &'c MoreRef {\n+        &&&&MoreRef\n+    }\n+}\n+\n+fn foo_rstr(x: &str) {\n+    println!(\"{:?}\", x);\n+}\n+fn foo_rslice(x: &[i32]) {\n+    println!(\"{:?}\", x);\n+}\n+fn foo_mrslice(x: &mut [i32]) {\n+    println!(\"{:?}\", x);\n+}\n+fn foo_rrrrmr(_: &&&&MoreRef) {\n+    println!(\"so many refs\");\n+}\n+\n+fn not_ok() {\n+    let rstr: &str = \"hello\";\n+    let mut mrslice: &mut [i32] = &mut [1, 2, 3];\n+\n+    {\n+        let rslice: &[i32] = &*mrslice;\n+        foo_rstr(rstr);\n+        foo_rstr(rstr);\n+        foo_rslice(rslice);\n+        foo_rslice(rslice);\n+    }\n+    {\n+        foo_mrslice(mrslice);\n+        foo_mrslice(mrslice);\n+        foo_rslice(mrslice);\n+        foo_rslice(mrslice);\n+    }\n+\n+    {\n+        let rrrrrstr = &&&&rstr;\n+        let rrrrrslice = &&&&&*mrslice;\n+        foo_rslice(rrrrrslice);\n+        foo_rslice(rrrrrslice);\n+        foo_rstr(rrrrrstr);\n+        foo_rstr(rrrrrstr);\n+    }\n+    {\n+        let mrrrrrslice = &mut &mut &mut &mut mrslice;\n+        foo_mrslice(mrrrrrslice);\n+        foo_mrslice(mrrrrrslice);\n+        foo_rslice(mrrrrrslice);\n+        foo_rslice(mrrrrrslice);\n+    }\n+    #[allow(unused_parens, clippy::double_parens)]\n+    foo_rrrrmr((&&&&MoreRef));\n+\n+    generic_not_ok(mrslice);\n+    generic_ok(mrslice);\n+}\n+\n+fn ok() {\n+    let string = \"hello\".to_owned();\n+    let mut arr = [1, 2, 3];\n+    let mut vec = vec![1, 2, 3];\n+\n+    {\n+        foo_rstr(string.as_ref());\n+        foo_rslice(arr.as_ref());\n+        foo_rslice(vec.as_ref());\n+    }\n+    {\n+        foo_mrslice(arr.as_mut());\n+        foo_mrslice(vec.as_mut());\n+    }\n+\n+    {\n+        let rrrrstring = &&&&string;\n+        let rrrrarr = &&&&arr;\n+        let rrrrvec = &&&&vec;\n+        foo_rstr(rrrrstring.as_ref());\n+        foo_rslice(rrrrarr.as_ref());\n+        foo_rslice(rrrrvec.as_ref());\n+    }\n+    {\n+        let mrrrrarr = &mut &mut &mut &mut arr;\n+        let mrrrrvec = &mut &mut &mut &mut vec;\n+        foo_mrslice(mrrrrarr.as_mut());\n+        foo_mrslice(mrrrrvec.as_mut());\n+    }\n+    FakeAsRef.as_ref();\n+    foo_rrrrmr(MoreRef.as_ref());\n+\n+    generic_not_ok(arr.as_mut());\n+    generic_ok(&mut arr);\n+}\n+\n+fn foo_mrt<T: Debug + ?Sized>(t: &mut T) {\n+    println!(\"{:?}\", t);\n+}\n+fn foo_rt<T: Debug + ?Sized>(t: &T) {\n+    println!(\"{:?}\", t);\n+}\n+\n+fn generic_not_ok<T: AsMut<T> + AsRef<T> + Debug + ?Sized>(mrt: &mut T) {\n+    foo_mrt(mrt);\n+    foo_mrt(mrt);\n+    foo_rt(mrt);\n+    foo_rt(mrt);\n+}\n+\n+fn generic_ok<U: AsMut<T> + AsRef<T> + ?Sized, T: Debug + ?Sized>(mru: &mut U) {\n+    foo_mrt(mru.as_mut());\n+    foo_rt(mru.as_ref());\n+}\n+\n+fn main() {\n+    not_ok();\n+    ok();\n+}"}, {"sha": "1d23760bd1480e4672633da850473c4910db243d", "filename": "tests/ui/useless_asref.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.rs?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -1,5 +1,8 @@\n+// run-rustfix\n+\n #![deny(clippy::useless_asref)]\n #![allow(clippy::trivially_copy_pass_by_ref)]\n+\n use std::fmt::Debug;\n \n struct FakeAsRef;\n@@ -65,6 +68,7 @@ fn not_ok() {\n         foo_rslice(mrrrrrslice.as_ref());\n         foo_rslice(mrrrrrslice);\n     }\n+    #[allow(unused_parens, clippy::double_parens)]\n     foo_rrrrmr((&&&&MoreRef).as_ref());\n \n     generic_not_ok(mrslice);"}, {"sha": "dd0613fc767136ee04854ff9b6f47635d1e9ecb4", "filename": "tests/ui/useless_asref.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuseless_asref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9d002c8a53be53aab6c754b011fb699e2f51aa0/tests%2Fui%2Fuseless_asref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.stderr?ref=a9d002c8a53be53aab6c754b011fb699e2f51aa0", "patch": "@@ -1,71 +1,71 @@\n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:41:18\n+  --> $DIR/useless_asref.rs:44:18\n    |\n LL |         foo_rstr(rstr.as_ref());\n    |                  ^^^^^^^^^^^^^ help: try this: `rstr`\n    |\n note: lint level defined here\n-  --> $DIR/useless_asref.rs:1:9\n+  --> $DIR/useless_asref.rs:3:9\n    |\n LL | #![deny(clippy::useless_asref)]\n    |         ^^^^^^^^^^^^^^^^^^^^^\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:43:20\n+  --> $DIR/useless_asref.rs:46:20\n    |\n LL |         foo_rslice(rslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^ help: try this: `rslice`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:47:21\n+  --> $DIR/useless_asref.rs:50:21\n    |\n LL |         foo_mrslice(mrslice.as_mut());\n    |                     ^^^^^^^^^^^^^^^^ help: try this: `mrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:49:20\n+  --> $DIR/useless_asref.rs:52:20\n    |\n LL |         foo_rslice(mrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^ help: try this: `mrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:56:20\n+  --> $DIR/useless_asref.rs:59:20\n    |\n LL |         foo_rslice(rrrrrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^^^^ help: try this: `rrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:58:18\n+  --> $DIR/useless_asref.rs:61:18\n    |\n LL |         foo_rstr(rrrrrstr.as_ref());\n    |                  ^^^^^^^^^^^^^^^^^ help: try this: `rrrrrstr`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:63:21\n+  --> $DIR/useless_asref.rs:66:21\n    |\n LL |         foo_mrslice(mrrrrrslice.as_mut());\n    |                     ^^^^^^^^^^^^^^^^^^^^ help: try this: `mrrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:65:20\n+  --> $DIR/useless_asref.rs:68:20\n    |\n LL |         foo_rslice(mrrrrrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^^^^^ help: try this: `mrrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:68:16\n+  --> $DIR/useless_asref.rs:72:16\n    |\n LL |     foo_rrrrmr((&&&&MoreRef).as_ref());\n    |                ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(&&&&MoreRef)`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:118:13\n+  --> $DIR/useless_asref.rs:122:13\n    |\n LL |     foo_mrt(mrt.as_mut());\n    |             ^^^^^^^^^^^^ help: try this: `mrt`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:120:12\n+  --> $DIR/useless_asref.rs:124:12\n    |\n LL |     foo_rt(mrt.as_ref());\n    |            ^^^^^^^^^^^^ help: try this: `mrt`"}]}