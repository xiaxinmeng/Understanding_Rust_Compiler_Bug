{"sha": "91cf28428e7db791e248ef44e7dc55cd20429158", "node_id": "C_kwDOAAsO6NoAKDkxY2YyODQyOGU3ZGI3OTFlMjQ4ZWY0NGU3ZGM1NWNkMjA0MjkxNTg", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-08-16T22:46:17Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-02-28T23:57:14Z"}, "message": "Move the cast_float_to_int fallback code to GCC\n\nNow that we require at least LLVM 13, that codegen backend is always\nusing its intrinsic `fptosi.sat` and `fptoui.sat` conversions, so it\ndoesn't need the manual implementation. However, the GCC backend still\nneeds it, so we can move all of that code down there.", "tree": {"sha": "aa5567f6937bcd97ba42fffb7ad02ad4c373c19b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa5567f6937bcd97ba42fffb7ad02ad4c373c19b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91cf28428e7db791e248ef44e7dc55cd20429158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91cf28428e7db791e248ef44e7dc55cd20429158", "html_url": "https://github.com/rust-lang/rust/commit/91cf28428e7db791e248ef44e7dc55cd20429158", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91cf28428e7db791e248ef44e7dc55cd20429158/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80b1c8dab5eb64826692051c963ff9c57baced76", "url": "https://api.github.com/repos/rust-lang/rust/commits/80b1c8dab5eb64826692051c963ff9c57baced76", "html_url": "https://github.com/rust-lang/rust/commit/80b1c8dab5eb64826692051c963ff9c57baced76"}], "stats": {"total": 175, "additions": 170, "deletions": 5}, "files": [{"sha": "a560539d6e1e5e5c5f35da7bb90f5c4da2f37d93", "filename": "src/builder.rs", "status": "modified", "additions": 169, "deletions": 5, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/91cf28428e7db791e248ef44e7dc55cd20429158/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91cf28428e7db791e248ef44e7dc55cd20429158/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=91cf28428e7db791e248ef44e7dc55cd20429158", "patch": "@@ -15,8 +15,11 @@ use gccjit::{\n     Type,\n     UnaryOp,\n };\n+use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_codegen_ssa::MemFlags;\n-use rustc_codegen_ssa::common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n+use rustc_codegen_ssa::common::{\n+    AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope, TypeKind,\n+};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n@@ -31,6 +34,7 @@ use rustc_codegen_ssa::traits::{\n     StaticBuilderMethods,\n };\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::bug;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n@@ -1403,12 +1407,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         val\n     }\n \n-    fn fptoui_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n-        None\n+    fn fptoui_sat(&mut self, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.fptoint_sat(false, val, dest_ty)\n     }\n \n-    fn fptosi_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n-        None\n+    fn fptosi_sat(&mut self, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.fptoint_sat(true, val, dest_ty)\n     }\n \n     fn instrprof_increment(&mut self, _fn_name: RValue<'gcc>, _hash: RValue<'gcc>, _num_counters: RValue<'gcc>, _index: RValue<'gcc>) {\n@@ -1417,6 +1421,166 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    fn fptoint_sat(&mut self, signed: bool, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        let src_ty = self.cx.val_ty(val);\n+        let (float_ty, int_ty) = if self.cx.type_kind(src_ty) == TypeKind::Vector {\n+            assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n+            (self.cx.element_type(src_ty), self.cx.element_type(dest_ty))\n+        } else {\n+            (src_ty, dest_ty)\n+        };\n+\n+        // FIXME(jistone): the following was originally the fallback SSA implementation, before LLVM 13\n+        // added native `fptosi.sat` and `fptoui.sat` conversions, but it was used by GCC as well.\n+        // Now that LLVM always relies on its own, the code has been moved to GCC, but the comments are\n+        // still LLVM-specific. This should be updated, and use better GCC specifics if possible.\n+\n+        let int_width = self.cx.int_width(int_ty);\n+        let float_width = self.cx.float_width(float_ty);\n+        // LLVM's fpto[su]i returns undef when the input val is infinite, NaN, or does not fit into the\n+        // destination integer type after rounding towards zero. This `undef` value can cause UB in\n+        // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n+        // Semantically, the mathematical value of the input is rounded towards zero to the next\n+        // mathematical integer, and then the result is clamped into the range of the destination\n+        // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n+        // the destination integer type. NaN is mapped to 0.\n+        //\n+        // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n+        // a value representable in int_ty.\n+        // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n+        // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n+        // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n+        // representable. Note that this only works if float_ty's exponent range is sufficiently large.\n+        // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n+        // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n+        // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n+        // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n+        // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n+        let int_max = |signed: bool, int_width: u64| -> u128 {\n+            let shift_amount = 128 - int_width;\n+            if signed { i128::MAX as u128 >> shift_amount } else { u128::MAX >> shift_amount }\n+        };\n+        let int_min = |signed: bool, int_width: u64| -> i128 {\n+            if signed { i128::MIN >> (128 - int_width) } else { 0 }\n+        };\n+\n+        let compute_clamp_bounds_single = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Single::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Single::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        let compute_clamp_bounds_double = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Double::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Double::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        // To implement saturation, we perform the following steps:\n+        //\n+        // 1. Cast val to an integer with fpto[su]i. This may result in undef.\n+        // 2. Compare val to f_min and f_max, and use the comparison results to select:\n+        //  a) int_ty::MIN if val < f_min or val is NaN\n+        //  b) int_ty::MAX if val > f_max\n+        //  c) the result of fpto[su]i otherwise\n+        // 3. If val is NaN, return 0.0, otherwise return the result of step 2.\n+        //\n+        // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n+        // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n+        // undef does not introduce any non-determinism either.\n+        // More importantly, the above procedure correctly implements saturating conversion.\n+        // Proof (sketch):\n+        // If val is NaN, 0 is returned by definition.\n+        // Otherwise, val is finite or infinite and thus can be compared with f_min and f_max.\n+        // This yields three cases to consider:\n+        // (1) if val in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n+        //     saturating conversion for inputs in that range.\n+        // (2) if val > f_max, then val is larger than int_ty::MAX. This holds even if f_max is rounded\n+        //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n+        //     than int_ty::MAX. Because val is larger than int_ty::MAX, the return value of int_ty::MAX\n+        //     is correct.\n+        // (3) if val < f_min, then val is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n+        //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n+        // QED.\n+\n+        let float_bits_to_llval = |bx: &mut Self, bits| {\n+            let bits_llval = match float_width {\n+                32 => bx.cx().const_u32(bits as u32),\n+                64 => bx.cx().const_u64(bits as u64),\n+                n => bug!(\"unsupported float width {}\", n),\n+            };\n+            bx.bitcast(bits_llval, float_ty)\n+        };\n+        let (f_min, f_max) = match float_width {\n+            32 => compute_clamp_bounds_single(signed, int_width),\n+            64 => compute_clamp_bounds_double(signed, int_width),\n+            n => bug!(\"unsupported float width {}\", n),\n+        };\n+        let f_min = float_bits_to_llval(self, f_min);\n+        let f_max = float_bits_to_llval(self, f_max);\n+        let int_max = self.cx.const_uint_big(int_ty, int_max(signed, int_width));\n+        let int_min = self.cx.const_uint_big(int_ty, int_min(signed, int_width) as u128);\n+        let zero = self.cx.const_uint(int_ty, 0);\n+\n+        // If we're working with vectors, constants must be \"splatted\": the constant is duplicated\n+        // into each lane of the vector.  The algorithm stays the same, we are just using the\n+        // same constant across all lanes.\n+        let maybe_splat = |bx: &mut Self, val| {\n+            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n+                bx.vector_splat(bx.vector_length(dest_ty), val)\n+            } else {\n+                val\n+            }\n+        };\n+        let f_min = maybe_splat(self, f_min);\n+        let f_max = maybe_splat(self, f_max);\n+        let int_max = maybe_splat(self, int_max);\n+        let int_min = maybe_splat(self, int_min);\n+        let zero = maybe_splat(self, zero);\n+\n+        // Step 1 ...\n+        let fptosui_result = if signed { self.fptosi(val, dest_ty) } else { self.fptoui(val, dest_ty) };\n+        let less_or_nan = self.fcmp(RealPredicate::RealULT, val, f_min);\n+        let greater = self.fcmp(RealPredicate::RealOGT, val, f_max);\n+\n+        // Step 2: We use two comparisons and two selects, with %s1 being the\n+        // result:\n+        //     %less_or_nan = fcmp ult %val, %f_min\n+        //     %greater = fcmp olt %val, %f_max\n+        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+        //     %s1 = select %greater, int_ty::MAX, %s0\n+        // Note that %less_or_nan uses an *unordered* comparison. This\n+        // comparison is true if the operands are not comparable (i.e., if val is\n+        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n+        // val is NaN.\n+        //\n+        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n+        // comparison and a negation, and the negation can be merged into the\n+        // select. Therefore, it not necessarily any more expensive than an\n+        // ordered (\"normal\") comparison. Whether these optimizations will be\n+        // performed is ultimately up to the backend, but at least x86 does\n+        // perform them.\n+        let s0 = self.select(less_or_nan, int_min, fptosui_result);\n+        let s1 = self.select(greater, int_max, s0);\n+\n+        // Step 3: NaN replacement.\n+        // For unsigned types, the above step already yielded int_ty::MIN == 0 if val is NaN.\n+        // Therefore we only need to execute this step for signed integer types.\n+        if signed {\n+            // LLVM has no isNaN predicate, so we use (val == val) instead\n+            let cmp = self.fcmp(RealPredicate::RealOEQ, val, val);\n+            self.select(cmp, s1, zero)\n+        } else {\n+            s1\n+        }\n+    }\n+\n     #[cfg(feature=\"master\")]\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n         let struct_type = mask.get_type().is_struct().expect(\"mask should be of struct type\");"}, {"sha": "36aa071fd0f8eac18c3444467475a6cd0afa49cc", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91cf28428e7db791e248ef44e7dc55cd20429158/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91cf28428e7db791e248ef44e7dc55cd20429158/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=91cf28428e7db791e248ef44e7dc55cd20429158", "patch": "@@ -19,6 +19,7 @@\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n \n+extern crate rustc_apfloat;\n extern crate rustc_ast;\n extern crate rustc_attr;\n extern crate rustc_codegen_ssa;"}]}