{"sha": "89a11564cc6f247bfb744f1587bc44e0ce1bb9cf", "node_id": "C_kwDOAAsO6NoAKDg5YTExNTY0Y2M2ZjI0N2JmYjc0NGYxNTg3YmM0NGUwY2UxYmI5Y2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-28T08:59:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-28T08:59:21Z"}, "message": "Auto merge of #7847 - mikerite:fix-7829, r=flip1995\n\nFix false positive in `match_overlapping_arm`\n\nFixes #7829\n\nchangelog: Fix false positive in [`match_overlapping_arm`].", "tree": {"sha": "17157ac31d5fddf1adc71708207981b970169883", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17157ac31d5fddf1adc71708207981b970169883"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf", "html_url": "https://github.com/rust-lang/rust/commit/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed71addee723b43e671d97dfbbcc398060d25386", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed71addee723b43e671d97dfbbcc398060d25386", "html_url": "https://github.com/rust-lang/rust/commit/ed71addee723b43e671d97dfbbcc398060d25386"}, {"sha": "1ede540b2135ce56546cb5f28fbf5c000646363f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ede540b2135ce56546cb5f28fbf5c000646363f", "html_url": "https://github.com/rust-lang/rust/commit/1ede540b2135ce56546cb5f28fbf5c000646363f"}], "stats": {"total": 194, "additions": 92, "deletions": 102}, "files": [{"sha": "82438d85c7a3a353128134b0736e587c4dc9d5f1", "filename": "clippy_lints/src/invalid_upcast_comparisons.rs", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs?ref=89a11564cc6f247bfb744f1587bc44e0ce1bb9cf", "patch": "@@ -1,17 +1,15 @@\n-use std::cmp::Ordering;\n-\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, IntTy, UintTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n \n+use clippy_utils::comparisons;\n use clippy_utils::comparisons::Rel;\n-use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::consts::{constant_full_int, FullInt};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::source::snippet;\n-use clippy_utils::{comparisons, sext};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -39,53 +37,6 @@ declare_clippy_lint! {\n \n declare_lint_pass!(InvalidUpcastComparisons => [INVALID_UPCAST_COMPARISONS]);\n \n-#[derive(Copy, Clone, Debug, Eq)]\n-enum FullInt {\n-    S(i128),\n-    U(u128),\n-}\n-\n-impl FullInt {\n-    #[allow(clippy::cast_sign_loss)]\n-    #[must_use]\n-    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n-        if s < 0 {\n-            Ordering::Less\n-        } else if u > (i128::MAX as u128) {\n-            Ordering::Greater\n-        } else {\n-            (s as u128).cmp(&u)\n-        }\n-    }\n-}\n-\n-impl PartialEq for FullInt {\n-    #[must_use]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other).expect(\"`partial_cmp` only returns `Some(_)`\") == Ordering::Equal\n-    }\n-}\n-\n-impl PartialOrd for FullInt {\n-    #[must_use]\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(match (self, other) {\n-            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n-            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n-            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n-            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n-        })\n-    }\n-}\n-\n-impl Ord for FullInt {\n-    #[must_use]\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.partial_cmp(other)\n-            .expect(\"`partial_cmp` for FullInt can never return `None`\")\n-    }\n-}\n-\n fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n     if let ExprKind::Cast(cast_exp, _) = expr.kind {\n         let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n@@ -118,19 +69,6 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) ->\n     }\n }\n \n-fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n-    let val = constant(cx, cx.typeck_results(), expr)?.0;\n-    if let Constant::Int(const_int) = val {\n-        match *cx.typeck_results().expr_ty(expr).kind() {\n-            ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n-            ty::Uint(_) => Some(FullInt::U(const_int)),\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n fn err_upcast_comparison(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, always: bool) {\n     if let ExprKind::Cast(cast_val, _) = expr.kind {\n         span_lint(\n@@ -156,7 +94,7 @@ fn upcast_comparison_bounds_err<'tcx>(\n     invert: bool,\n ) {\n     if let Some((lb, ub)) = lhs_bounds {\n-        if let Some(norm_rhs_val) = node_as_const_fullint(cx, rhs) {\n+        if let Some(norm_rhs_val) = constant_full_int(cx, cx.typeck_results(), rhs) {\n             if rel == Rel::Eq || rel == Rel::Ne {\n                 if norm_rhs_val < lb || norm_rhs_val > ub {\n                     err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);"}, {"sha": "f1289a36e77702435734ad242286dc106f60bd15", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=89a11564cc6f247bfb744f1587bc44e0ce1bb9cf", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::consts::{constant, miri_to_const, Constant};\n+use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n@@ -930,9 +930,8 @@ fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n     if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n         let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n-        let type_ranges = type_ranges(&ranges);\n-        if !type_ranges.is_empty() {\n-            if let Some((start, end)) = overlapping(&type_ranges) {\n+        if !ranges.is_empty() {\n+            if let Some((start, end)) = overlapping(&ranges) {\n                 span_lint_and_note(\n                     cx,\n                     MATCH_OVERLAPPING_ARM,\n@@ -1601,7 +1600,7 @@ fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'\n }\n \n /// Gets all arms that are unbounded `PatRange`s.\n-fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<Constant>> {\n+fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n     arms.iter()\n         .filter_map(|arm| {\n             if let Arm { pat, guard: None, .. } = *arm {\n@@ -1614,21 +1613,25 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                         Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n                         None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n                     };\n-                    let rhs = match range_end {\n-                        RangeEnd::Included => Bound::Included(rhs),\n-                        RangeEnd::Excluded => Bound::Excluded(rhs),\n+\n+                    let lhs_val = lhs.int_value(cx, ty)?;\n+                    let rhs_val = rhs.int_value(cx, ty)?;\n+\n+                    let rhs_bound = match range_end {\n+                        RangeEnd::Included => Bound::Included(rhs_val),\n+                        RangeEnd::Excluded => Bound::Excluded(rhs_val),\n                     };\n                     return Some(SpannedRange {\n                         span: pat.span,\n-                        node: (lhs, rhs),\n+                        node: (lhs_val, rhs_bound),\n                     });\n                 }\n \n                 if let PatKind::Lit(value) = pat.kind {\n-                    let value = constant(cx, cx.typeck_results(), value)?.0;\n+                    let value = constant_full_int(cx, cx.typeck_results(), value)?;\n                     return Some(SpannedRange {\n                         span: pat.span,\n-                        node: (value.clone(), Bound::Included(value)),\n+                        node: (value, Bound::Included(value)),\n                     });\n                 }\n             }\n@@ -1643,32 +1646,6 @@ pub struct SpannedRange<T> {\n     pub node: (T, Bound<T>),\n }\n \n-type TypedRanges = Vec<SpannedRange<u128>>;\n-\n-/// Gets all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway\n-/// and other types than\n-/// `Uint` and `Int` probably don't make sense.\n-fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n-    ranges\n-        .iter()\n-        .filter_map(|range| match range.node {\n-            (Constant::Int(start), Bound::Included(Constant::Int(end))) => Some(SpannedRange {\n-                span: range.span,\n-                node: (start, Bound::Included(end)),\n-            }),\n-            (Constant::Int(start), Bound::Excluded(Constant::Int(end))) => Some(SpannedRange {\n-                span: range.span,\n-                node: (start, Bound::Excluded(end)),\n-            }),\n-            (Constant::Int(start), Bound::Unbounded) => Some(SpannedRange {\n-                span: range.span,\n-                node: (start, Bound::Unbounded),\n-            }),\n-            _ => None,\n-        })\n-        .collect()\n-}\n-\n // Checks if arm has the form `None => None`\n fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))"}, {"sha": "3e5d74a66f4e8200fcbee161cc9bd3a1705fbe05", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=89a11564cc6f247bfb744f1587bc44e0ce1bb9cf", "patch": "@@ -155,6 +155,19 @@ impl Constant {\n             _ => None,\n         }\n     }\n+\n+    /// Returns the integer value or `None` if `self` or `val_type` is not integer type.\n+    pub fn int_value(&self, cx: &LateContext<'_>, val_type: Ty<'_>) -> Option<FullInt> {\n+        if let Constant::Int(const_int) = *self {\n+            match *val_type.kind() {\n+                ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n+                ty::Uint(_) => Some(FullInt::U(const_int)),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// Parses a `LitKind` to a `Constant`.\n@@ -202,6 +215,61 @@ pub fn constant_simple<'tcx>(\n     constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n+pub fn constant_full_int(\n+    lcx: &LateContext<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n+    e: &Expr<'_>,\n+) -> Option<FullInt> {\n+    constant_simple(lcx, typeck_results, e)?.int_value(lcx, typeck_results.expr_ty(e))\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq)]\n+pub enum FullInt {\n+    S(i128),\n+    U(u128),\n+}\n+\n+impl FullInt {\n+    #[allow(clippy::cast_sign_loss)]\n+    #[must_use]\n+    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n+        if s < 0 {\n+            Ordering::Less\n+        } else if u > (i128::MAX as u128) {\n+            Ordering::Greater\n+        } else {\n+            (s as u128).cmp(&u)\n+        }\n+    }\n+}\n+\n+impl PartialEq for FullInt {\n+    #[must_use]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other).expect(\"`partial_cmp` only returns `Some(_)`\") == Ordering::Equal\n+    }\n+}\n+\n+impl PartialOrd for FullInt {\n+    #[must_use]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(match (self, other) {\n+            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n+            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n+            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n+            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n+        })\n+    }\n+}\n+\n+impl Ord for FullInt {\n+    #[must_use]\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other)\n+            .expect(\"`partial_cmp` for FullInt can never return `None`\")\n+    }\n+}\n+\n /// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n pub fn constant_context<'a, 'tcx>(\n     lcx: &'a LateContext<'tcx>,"}, {"sha": "845986a4eadabeee40414a90d26162cbb4ba5007", "filename": "tests/ui/match_overlapping_arm.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf/tests%2Fui%2Fmatch_overlapping_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a11564cc6f247bfb744f1587bc44e0ce1bb9cf/tests%2Fui%2Fmatch_overlapping_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_overlapping_arm.rs?ref=89a11564cc6f247bfb744f1587bc44e0ce1bb9cf", "patch": "@@ -100,6 +100,13 @@ fn overlapping() {\n         _ => (),\n     }\n \n+    // Issue #7829\n+    match 0 {\n+        -1..=1 => (),\n+        -2..=2 => (),\n+        _ => (),\n+    }\n+\n     if let None = Some(42) {\n         // nothing\n     } else if let None = Some(42) {"}]}