{"sha": "ee20ebadafc9b2e4995015097e376c0a866d84af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMjBlYmFkYWZjOWIyZTQ5OTUwMTUwOTdlMzc2YzBhODY2ZDg0YWY=", "commit": {"author": {"name": "Daniel Smith", "email": "daniel.smith@datadoghq.com", "date": "2020-10-13T17:15:45Z"}, "committer": {"name": "Daniel Smith", "email": "daniel.smith@datadoghq.com", "date": "2020-10-21T15:04:26Z"}, "message": "Move refcell lint into shared module", "tree": {"sha": "65552fc3c9315db578a4e3c050d187b2c5d2ac22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65552fc3c9315db578a4e3c050d187b2c5d2ac22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee20ebadafc9b2e4995015097e376c0a866d84af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee20ebadafc9b2e4995015097e376c0a866d84af", "html_url": "https://github.com/rust-lang/rust/commit/ee20ebadafc9b2e4995015097e376c0a866d84af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee20ebadafc9b2e4995015097e376c0a866d84af/comments", "author": null, "committer": null, "parents": [{"sha": "3ed69cdb13e5953467f9d849d7ad480479ca01d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ed69cdb13e5953467f9d849d7ad480479ca01d6", "html_url": "https://github.com/rust-lang/rust/commit/3ed69cdb13e5953467f9d849d7ad480479ca01d6"}], "stats": {"total": 568, "additions": 276, "deletions": 292}, "files": [{"sha": "2000bdae363fde90d591daeba2c530c23677f36b", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ee20ebadafc9b2e4995015097e376c0a866d84af/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee20ebadafc9b2e4995015097e376c0a866d84af/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=ee20ebadafc9b2e4995015097e376c0a866d84af", "patch": "@@ -60,12 +60,12 @@ impl LateLintPass<'_> for AwaitHoldingLock {\n             };\n             let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n             let typeck_results = cx.tcx.typeck(def_id);\n-            check_interior_types(cx, &typeck_results.generator_interior_types, body.value.span);\n+            check_interior_types_lock(cx, &typeck_results.generator_interior_types, body.value.span);\n         }\n     }\n }\n \n-fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n+fn check_interior_types_lock(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n     for ty_cause in ty_causes {\n         if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n             if is_mutex_guard(cx, adt.did) {\n@@ -90,3 +90,79 @@ fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)\n }\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to await while holding a\n+    /// `RefCell` `Ref` or `RefMut`.\n+    ///\n+    /// **Why is this bad?** `RefCell` refs only check for exclusive mutable access\n+    /// at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n+    /// risks panics from a mutable ref shared while other refs are outstanding.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// use std::cell::RefCell;\n+    ///\n+    /// async fn foo(x: &RefCell<u32>) {\n+    ///   let b = x.borrow_mut()();\n+    ///   *ref += 1;\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// use std::cell::RefCell;\n+    ///\n+    /// async fn foo(x: &RefCell<u32>) {\n+    ///   {\n+    ///     let b = x.borrow_mut();\n+    ///     *ref += 1;\n+    ///   }\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    pub AWAIT_HOLDING_REFCELL_REF,\n+    pedantic,\n+    \"Inside an async function, holding a RefCell ref while calling await\"\n+}\n+\n+declare_lint_pass!(AwaitHoldingRefCellRef => [AWAIT_HOLDING_REFCELL_REF]);\n+\n+impl LateLintPass<'_> for AwaitHoldingRefCellRef {\n+    fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n+        use AsyncGeneratorKind::{Block, Closure, Fn};\n+        if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n+            let body_id = BodyId {\n+                hir_id: body.value.hir_id,\n+            };\n+            let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n+            let typeck_results = cx.tcx.typeck(def_id);\n+            check_interior_types_refcell(cx, &typeck_results.generator_interior_types, body.value.span);\n+        }\n+    }\n+}\n+\n+fn check_interior_types_refcell(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n+    for ty_cause in ty_causes {\n+        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n+            if is_refcell_ref(cx, adt.did) {\n+                span_lint_and_note(\n+                        cx,\n+                        AWAIT_HOLDING_REFCELL_REF,\n+                        ty_cause.span,\n+                        \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\",\n+                        ty_cause.scope_span.or(Some(span)),\n+                        \"these are all the await points this ref is held through\",\n+                    );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_refcell_ref(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+    match_def_path(cx, def_id, &paths::REFCELL_REF) || match_def_path(cx, def_id, &paths::REFCELL_REFMUT)\n+}"}, {"sha": "9a75911acbea857f38a5bf883644d763fac884d9", "filename": "clippy_lints/src/await_holding_refcell_ref.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3ed69cdb13e5953467f9d849d7ad480479ca01d6/clippy_lints%2Fsrc%2Fawait_holding_refcell_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed69cdb13e5953467f9d849d7ad480479ca01d6/clippy_lints%2Fsrc%2Fawait_holding_refcell_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_refcell_ref.rs?ref=3ed69cdb13e5953467f9d849d7ad480479ca01d6", "patch": "@@ -1,83 +0,0 @@\n-use crate::utils::{match_def_path, paths, span_lint_and_note};\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::GeneratorInteriorTypeCause;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for calls to await while holding a\n-    /// `RefCell` `Ref` or `RefMut`.\n-    ///\n-    /// **Why is this bad?** `RefCell` refs only check for exclusive mutable access\n-    /// at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n-    /// risks panics from a mutable ref shared while other refs are outstanding.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust,ignore\n-    /// use std::cell::RefCell;\n-    ///\n-    /// async fn foo(x: &RefCell<u32>) {\n-    ///   let b = x.borrow_mut()();\n-    ///   *ref += 1;\n-    ///   bar.await;\n-    /// }\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// use std::cell::RefCell;\n-    ///\n-    /// async fn foo(x: &RefCell<u32>) {\n-    ///   {\n-    ///     let b = x.borrow_mut();\n-    ///     *ref += 1;\n-    ///   }\n-    ///   bar.await;\n-    /// }\n-    /// ```\n-    pub AWAIT_HOLDING_REFCELL_REF,\n-    pedantic,\n-    \"Inside an async function, holding a RefCell ref while calling await\"\n-}\n-\n-declare_lint_pass!(AwaitHoldingRefCellRef => [AWAIT_HOLDING_REFCELL_REF]);\n-\n-impl LateLintPass<'_> for AwaitHoldingRefCellRef {\n-    fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n-        use AsyncGeneratorKind::{Block, Closure, Fn};\n-        if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n-            let body_id = BodyId {\n-                hir_id: body.value.hir_id,\n-            };\n-            let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n-            let typeck_results = cx.tcx.typeck(def_id);\n-            check_interior_types(cx, &typeck_results.generator_interior_types, body.value.span);\n-        }\n-    }\n-}\n-\n-fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n-    for ty_cause in ty_causes {\n-        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n-            if is_refcell_ref(cx, adt.did) {\n-                span_lint_and_note(\n-                    cx,\n-                    AWAIT_HOLDING_REFCELL_REF,\n-                    ty_cause.span,\n-                    \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\",\n-                    ty_cause.scope_span.or(Some(span)),\n-                    \"these are all the await points this ref is held through\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_refcell_ref(cx: &LateContext<'_>, def_id: DefId) -> bool {\n-    match_def_path(cx, def_id, &paths::REFCELL_REF) || match_def_path(cx, def_id, &paths::REFCELL_REFMUT)\n-}"}, {"sha": "0c5baf96970c599cd842cdf59767f05fa85200cf", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee20ebadafc9b2e4995015097e376c0a866d84af/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee20ebadafc9b2e4995015097e376c0a866d84af/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ee20ebadafc9b2e4995015097e376c0a866d84af", "patch": "@@ -161,7 +161,6 @@ mod async_yields_async;\n mod atomic_ordering;\n mod attrs;\n mod await_holding_invalid;\n-mod await_holding_refcell_ref;\n mod bit_mask;\n mod blacklisted_name;\n mod blocks_in_if_conditions;\n@@ -511,7 +510,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &attrs::UNKNOWN_CLIPPY_LINTS,\n         &attrs::USELESS_ATTRIBUTE,\n         &await_holding_invalid::AWAIT_HOLDING_LOCK,\n-        &await_holding_refcell_ref::AWAIT_HOLDING_REFCELL_REF,\n+        &await_holding_invalid::AWAIT_HOLDING_REFCELL_REF,\n         &bit_mask::BAD_BIT_MASK,\n         &bit_mask::INEFFECTIVE_BIT_MASK,\n         &bit_mask::VERBOSE_BIT_MASK,\n@@ -908,7 +907,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n \n     store.register_late_pass(|| box await_holding_invalid::AwaitHoldingLock);\n-    store.register_late_pass(|| box await_holding_refcell_ref::AwaitHoldingRefCellRef);\n+    store.register_late_pass(|| box await_holding_invalid::AwaitHoldingRefCellRef);\n     store.register_late_pass(|| box serde_api::SerdeAPI);\n     store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n     store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n@@ -1192,7 +1191,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n         LintId::of(&attrs::INLINE_ALWAYS),\n         LintId::of(&await_holding_invalid::AWAIT_HOLDING_LOCK),\n-        LintId::of(&await_holding_refcell_ref::AWAIT_HOLDING_REFCELL_REF),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::MATCH_SAME_ARMS),"}, {"sha": "c955f37b83a39328db5b2566db6d706d6f2f364c", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee20ebadafc9b2e4995015097e376c0a866d84af/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee20ebadafc9b2e4995015097e376c0a866d84af/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=ee20ebadafc9b2e4995015097e376c0a866d84af", "patch": "@@ -72,7 +72,7 @@ vec![\n         group: \"pedantic\",\n         desc: \"Inside an async function, holding a RefCell ref while calling await\",\n         deprecation: None,\n-        module: \"await_holding_refcell_ref\",\n+        module: \"await_holding_invalid\",\n     },\n     Lint {\n         name: \"bad_bit_mask\","}, {"sha": "45aa3e64292e2daf095b9ddce724175fda04461d", "filename": "tests/ui/await_holding_invalid.rs", "status": "modified", "additions": 92, "deletions": 12, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ee20ebadafc9b2e4995015097e376c0a866d84af/tests%2Fui%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee20ebadafc9b2e4995015097e376c0a866d84af/tests%2Fui%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_invalid.rs?ref=ee20ebadafc9b2e4995015097e376c0a866d84af", "patch": "@@ -1,14 +1,15 @@\n // edition:2018\n-#![warn(clippy::await_holding_lock)]\n+#![warn(clippy::await_holding_lock, clippy::await_holding_refcell_ref)]\n \n+use std::cell::RefCell;\n use std::sync::Mutex;\n \n-async fn bad(x: &Mutex<u32>) -> u32 {\n+async fn bad_lock(x: &Mutex<u32>) -> u32 {\n     let guard = x.lock().unwrap();\n     baz().await\n }\n \n-async fn good(x: &Mutex<u32>) -> u32 {\n+async fn good_lock(x: &Mutex<u32>) -> u32 {\n     {\n         let guard = x.lock().unwrap();\n         let y = *guard + 1;\n@@ -22,7 +23,7 @@ async fn baz() -> u32 {\n     42\n }\n \n-async fn also_bad(x: &Mutex<u32>) -> u32 {\n+async fn also_bad_lock(x: &Mutex<u32>) -> u32 {\n     let first = baz().await;\n \n     let guard = x.lock().unwrap();\n@@ -34,7 +35,7 @@ async fn also_bad(x: &Mutex<u32>) -> u32 {\n     first + second + third\n }\n \n-async fn not_good(x: &Mutex<u32>) -> u32 {\n+async fn not_good_lock(x: &Mutex<u32>) -> u32 {\n     let first = baz().await;\n \n     let second = {\n@@ -48,18 +49,97 @@ async fn not_good(x: &Mutex<u32>) -> u32 {\n }\n \n #[allow(clippy::manual_async_fn)]\n-fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+fn block_bad_lock(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n     async move {\n         let guard = x.lock().unwrap();\n         baz().await\n     }\n }\n \n+async fn bad_refcell(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow();\n+    baz().await\n+}\n+\n+async fn bad_mut_refcell(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow_mut();\n+    baz().await\n+}\n+\n+async fn good_refcell(x: &RefCell<u32>) -> u32 {\n+    {\n+        let b = x.borrow_mut();\n+        let y = *b + 1;\n+    }\n+    baz().await;\n+    let b = x.borrow_mut();\n+    47\n+}\n+\n+async fn also_bad_refcell(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn less_bad_refcell(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    drop(b);\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn not_good_refcell(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let second = {\n+        let b = x.borrow_mut();\n+        baz().await\n+    };\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+#[allow(clippy::manual_async_fn)]\n+fn block_bad_refcell(x: &RefCell<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+    async move {\n+        let b = x.borrow_mut();\n+        baz().await\n+    }\n+}\n+\n fn main() {\n-    let m = Mutex::new(100);\n-    good(&m);\n-    bad(&m);\n-    also_bad(&m);\n-    not_good(&m);\n-    block_bad(&m);\n+    {\n+        let m = Mutex::new(100);\n+        good_lock(&m);\n+        bad_lock(&m);\n+        also_bad_lock(&m);\n+        not_good_lock(&m);\n+        block_bad_lock(&m);\n+    }\n+    {\n+        let rc = RefCell::new(100);\n+        good_refcell(&rc);\n+        bad_refcell(&rc);\n+        bad_mut_refcell(&rc);\n+        also_bad_refcell(&rc);\n+        less_bad_refcell(&rc);\n+        not_good_refcell(&rc);\n+        block_bad_refcell(&rc);\n+    }\n }"}, {"sha": "c8d49820c0209cad978d7da87615cda52cd665b6", "filename": "tests/ui/await_holding_invalid.stderr", "status": "modified", "additions": 102, "deletions": 9, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ee20ebadafc9b2e4995015097e376c0a866d84af/tests%2Fui%2Fawait_holding_invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee20ebadafc9b2e4995015097e376c0a866d84af/tests%2Fui%2Fawait_holding_invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_invalid.stderr?ref=ee20ebadafc9b2e4995015097e376c0a866d84af", "patch": "@@ -1,26 +1,26 @@\n error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:7:9\n+  --> $DIR/await_holding_invalid.rs:8:9\n    |\n LL |     let guard = x.lock().unwrap();\n    |         ^^^^^\n    |\n    = note: `-D clippy::await-holding-lock` implied by `-D warnings`\n note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_invalid.rs:7:5\n+  --> $DIR/await_holding_invalid.rs:8:5\n    |\n LL | /     let guard = x.lock().unwrap();\n LL | |     baz().await\n LL | | }\n    | |_^\n \n error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:28:9\n+  --> $DIR/await_holding_invalid.rs:29:9\n    |\n LL |     let guard = x.lock().unwrap();\n    |         ^^^^^\n    |\n note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_invalid.rs:28:5\n+  --> $DIR/await_holding_invalid.rs:29:5\n    |\n LL | /     let guard = x.lock().unwrap();\n LL | |\n@@ -32,32 +32,125 @@ LL | | }\n    | |_^\n \n error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:41:13\n+  --> $DIR/await_holding_invalid.rs:42:13\n    |\n LL |         let guard = x.lock().unwrap();\n    |             ^^^^^\n    |\n note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_invalid.rs:41:9\n+  --> $DIR/await_holding_invalid.rs:42:9\n    |\n LL | /         let guard = x.lock().unwrap();\n LL | |         baz().await\n LL | |     };\n    | |_____^\n \n error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n-  --> $DIR/await_holding_invalid.rs:53:13\n+  --> $DIR/await_holding_invalid.rs:54:13\n    |\n LL |         let guard = x.lock().unwrap();\n    |             ^^^^^\n    |\n note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_invalid.rs:53:9\n+  --> $DIR/await_holding_invalid.rs:54:9\n    |\n LL | /         let guard = x.lock().unwrap();\n LL | |         baz().await\n LL | |     }\n    | |_____^\n \n-error: aborting due to 4 previous errors\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_invalid.rs:60:9\n+   |\n+LL |     let b = x.borrow();\n+   |         ^\n+   |\n+   = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_invalid.rs:60:5\n+   |\n+LL | /     let b = x.borrow();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_invalid.rs:65:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_invalid.rs:65:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_invalid.rs:82:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_invalid.rs:82:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_invalid.rs:94:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_invalid.rs:94:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_invalid.rs:109:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_invalid.rs:109:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     };\n+   | |_____^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_invalid.rs:121:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_invalid.rs:121:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "88841597bb60bf5bc8a8bff346fdfc9391a40cfe", "filename": "tests/ui/await_holding_refcell_ref.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3ed69cdb13e5953467f9d849d7ad480479ca01d6/tests%2Fui%2Fawait_holding_refcell_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ed69cdb13e5953467f9d849d7ad480479ca01d6/tests%2Fui%2Fawait_holding_refcell_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.rs?ref=3ed69cdb13e5953467f9d849d7ad480479ca01d6", "patch": "@@ -1,86 +0,0 @@\n-// edition:2018\n-#![warn(clippy::await_holding_refcell_ref)]\n-\n-use std::cell::RefCell;\n-\n-async fn bad(x: &RefCell<u32>) -> u32 {\n-    let b = x.borrow();\n-    baz().await\n-}\n-\n-async fn bad_mut(x: &RefCell<u32>) -> u32 {\n-    let b = x.borrow_mut();\n-    baz().await\n-}\n-\n-async fn good(x: &RefCell<u32>) -> u32 {\n-    {\n-        let b = x.borrow_mut();\n-        let y = *b + 1;\n-    }\n-    baz().await;\n-    let b = x.borrow_mut();\n-    47\n-}\n-\n-async fn baz() -> u32 {\n-    42\n-}\n-\n-async fn also_bad(x: &RefCell<u32>) -> u32 {\n-    let first = baz().await;\n-\n-    let b = x.borrow_mut();\n-\n-    let second = baz().await;\n-\n-    let third = baz().await;\n-\n-    first + second + third\n-}\n-\n-async fn less_bad(x: &RefCell<u32>) -> u32 {\n-    let first = baz().await;\n-\n-    let b = x.borrow_mut();\n-\n-    let second = baz().await;\n-\n-    drop(b);\n-\n-    let third = baz().await;\n-\n-    first + second + third\n-}\n-\n-async fn not_good(x: &RefCell<u32>) -> u32 {\n-    let first = baz().await;\n-\n-    let second = {\n-        let b = x.borrow_mut();\n-        baz().await\n-    };\n-\n-    let third = baz().await;\n-\n-    first + second + third\n-}\n-\n-#[allow(clippy::manual_async_fn)]\n-fn block_bad(x: &RefCell<u32>) -> impl std::future::Future<Output = u32> + '_ {\n-    async move {\n-        let b = x.borrow_mut();\n-        baz().await\n-    }\n-}\n-\n-fn main() {\n-    let rc = RefCell::new(100);\n-    good(&rc);\n-    bad(&rc);\n-    bad_mut(&rc);\n-    also_bad(&rc);\n-    less_bad(&rc);\n-    not_good(&rc);\n-    block_bad(&rc);\n-}"}, {"sha": "b504f0454913634969cb11a6ced5b3fc5e9fb2f9", "filename": "tests/ui/await_holding_refcell_ref.stderr", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3ed69cdb13e5953467f9d849d7ad480479ca01d6/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ed69cdb13e5953467f9d849d7ad480479ca01d6/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.stderr?ref=3ed69cdb13e5953467f9d849d7ad480479ca01d6", "patch": "@@ -1,95 +0,0 @@\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_refcell_ref.rs:7:9\n-   |\n-LL |     let b = x.borrow();\n-   |         ^\n-   |\n-   = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_refcell_ref.rs:7:5\n-   |\n-LL | /     let b = x.borrow();\n-LL | |     baz().await\n-LL | | }\n-   | |_^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_refcell_ref.rs:12:9\n-   |\n-LL |     let b = x.borrow_mut();\n-   |         ^\n-   |\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_refcell_ref.rs:12:5\n-   |\n-LL | /     let b = x.borrow_mut();\n-LL | |     baz().await\n-LL | | }\n-   | |_^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_refcell_ref.rs:33:9\n-   |\n-LL |     let b = x.borrow_mut();\n-   |         ^\n-   |\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_refcell_ref.rs:33:5\n-   |\n-LL | /     let b = x.borrow_mut();\n-LL | |\n-LL | |     let second = baz().await;\n-LL | |\n-...  |\n-LL | |     first + second + third\n-LL | | }\n-   | |_^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_refcell_ref.rs:45:9\n-   |\n-LL |     let b = x.borrow_mut();\n-   |         ^\n-   |\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_refcell_ref.rs:45:5\n-   |\n-LL | /     let b = x.borrow_mut();\n-LL | |\n-LL | |     let second = baz().await;\n-LL | |\n-...  |\n-LL | |     first + second + third\n-LL | | }\n-   | |_^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_refcell_ref.rs:60:13\n-   |\n-LL |         let b = x.borrow_mut();\n-   |             ^\n-   |\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_refcell_ref.rs:60:9\n-   |\n-LL | /         let b = x.borrow_mut();\n-LL | |         baz().await\n-LL | |     };\n-   | |_____^\n-\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n-  --> $DIR/await_holding_refcell_ref.rs:72:13\n-   |\n-LL |         let b = x.borrow_mut();\n-   |             ^\n-   |\n-note: these are all the await points this ref is held through\n-  --> $DIR/await_holding_refcell_ref.rs:72:9\n-   |\n-LL | /         let b = x.borrow_mut();\n-LL | |         baz().await\n-LL | |     }\n-   | |_____^\n-\n-error: aborting due to 6 previous errors\n-"}]}