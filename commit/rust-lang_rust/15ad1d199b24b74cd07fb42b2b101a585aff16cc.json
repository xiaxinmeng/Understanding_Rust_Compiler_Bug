{"sha": "15ad1d199b24b74cd07fb42b2b101a585aff16cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1YWQxZDE5OWIyNGI3NGNkMDdmYjQyYjJiMTAxYTU4NWFmZjE2Y2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-29T21:10:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-29T21:10:36Z"}, "message": "Auto merge of #30088 - sourcefrog:doc-casts, r=steveklabnik\n\nBased on the description in https://github.com/rust-lang/rust/blob/219eca11b044de3644b3e9101124513c1a842b09/src/librustc_typeck/check/cast.rs#L11 and https://doc.rust-lang.org/nightly/nomicon/casts.html", "tree": {"sha": "f9b98b5ed18ea7040b328100dc89698d10b7442c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9b98b5ed18ea7040b328100dc89698d10b7442c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ad1d199b24b74cd07fb42b2b101a585aff16cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ad1d199b24b74cd07fb42b2b101a585aff16cc", "html_url": "https://github.com/rust-lang/rust/commit/15ad1d199b24b74cd07fb42b2b101a585aff16cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ad1d199b24b74cd07fb42b2b101a585aff16cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4867df4a23d88c4aaeb99bc96f891511eb24cee0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4867df4a23d88c4aaeb99bc96f891511eb24cee0", "html_url": "https://github.com/rust-lang/rust/commit/4867df4a23d88c4aaeb99bc96f891511eb24cee0"}, {"sha": "797d5433c973dadbfe5f9dfbd4de7d0930338847", "url": "https://api.github.com/repos/rust-lang/rust/commits/797d5433c973dadbfe5f9dfbd4de7d0930338847", "html_url": "https://github.com/rust-lang/rust/commit/797d5433c973dadbfe5f9dfbd4de7d0930338847"}], "stats": {"total": 118, "additions": 113, "deletions": 5}, "files": [{"sha": "e2b114b7e54b468adcbcf0195578cd7a89301754", "filename": "src/doc/book/casting-between-types.md", "status": "modified", "additions": 113, "deletions": 5, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/15ad1d199b24b74cd07fb42b2b101a585aff16cc/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/15ad1d199b24b74cd07fb42b2b101a585aff16cc/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcasting-between-types.md?ref=15ad1d199b24b74cd07fb42b2b101a585aff16cc", "patch": "@@ -5,17 +5,127 @@ different types between each other. The first, `as`, is for safe casts.\n In contrast, `transmute` allows for arbitrary casting, and is one of the\n most dangerous features of Rust!\n \n+# Coercion\n+\n+Coercion between types is implicit and has no syntax of its own, but can\n+be spelled out with [`as`](#explicit-coercions).\n+\n+Coercion occurs in `let`, `const`, and `static` statements; in\n+function call arguments; in field values in struct initialization; and in a\n+function result.\n+\n+The main cases of coercion are:\n+\n+ * `&mut T` to `&T`\n+\n+ * `*mut T` to `*const T`\n+\n+ * `&T` to `*const T`\n+\n+ * `&mut T` to `*mut T`\n+ \n+ * A custom coercion using [`Deref`](deref-coercions.md)\n+ \n+ \n # `as`\n \n-The `as` keyword does basic casting:\n+The `as` keyword does safe casting:\n \n ```rust\n let x: i32 = 5;\n \n let y = x as i64;\n ```\n \n-It only allows certain kinds of casting, however:\n+There are three major categories of safe cast: explicit coercions, casts\n+between numeric types, and pointer casts.\n+\n+Casting is not transitive: even if `e as U1 as U2` is a valid\n+expression, `e as U2` is not necessarily so (in fact it will only be valid if\n+`U1` coerces to `U2`).\n+\n+\n+## Explicit coercions\n+\n+A cast `e as U` is valid if `e` has type `T` and `T` *coerces* to `U`.\n+\n+For example:\n+\n+```rust\n+let a = \"hello\";\n+let b = a as String;\n+```\n+\n+## Numeric casts\n+\n+A cast `e as U` is also valid in any of the following cases:\n+\n+ * `e` has type `T` and `T` and `U` are any numeric types; *numeric-cast*\n+ * `e` is a C-like enum (with no data attached to the variants),\n+    and `U` is an integer type; *enum-cast*\n+ * `e` has type `bool` or `char` and `U` is an integer type; *prim-int-cast*\n+ * `e` has type `u8` and `U` is `char`; *u8-char-cast*\n+ \n+For example\n+\n+```rust\n+let one = true as u8;\n+let at_sign = 64 as char;\n+```\n+\n+The semantics of numeric casts are:\n+\n+* Casting between two integers of the same size (e.g. i32 -> u32) is a no-op\n+* Casting from a larger integer to a smaller integer (e.g. u32 -> u8) will\n+  truncate\n+* Casting from a smaller integer to a larger integer (e.g. u8 -> u32) will\n+    * zero-extend if the source is unsigned\n+    * sign-extend if the source is signed\n+* Casting from a float to an integer will round the float towards zero\n+    * **[NOTE: currently this will cause Undefined Behavior if the rounded\n+      value cannot be represented by the target integer type][float-int]**.\n+      This includes Inf and NaN. This is a bug and will be fixed.\n+* Casting from an integer to float will produce the floating point\n+  representation of the integer, rounded if necessary (rounding strategy\n+  unspecified)\n+* Casting from an f32 to an f64 is perfect and lossless\n+* Casting from an f64 to an f32 will produce the closest possible value\n+  (rounding strategy unspecified)\n+    * **[NOTE: currently this will cause Undefined Behavior if the value\n+      is finite but larger or smaller than the largest or smallest finite\n+      value representable by f32][float-float]**. This is a bug and will\n+      be fixed.\n+\n+[float-int]: https://github.com/rust-lang/rust/issues/10184\n+[float-float]: https://github.com/rust-lang/rust/issues/15536\n+ \n+## Pointer casts\n+ \n+Perhaps surprisingly, it is safe to cast pointers to and from integers, and\n+to cast between pointers to different types subject to some constraints. It\n+is only unsafe to dereference the pointer.\n+\n+`e as U` is a valid pointer cast in any of the following cases:\n+\n+* `e` has type `*T`, `U` has type `*U_0`, and either `U_0: Sized` or\n+  `unsize_kind(T) == unsize_kind(U_0)`; a *ptr-ptr-cast*\n+  \n+* `e` has type `*T` and `U` is a numeric type, while `T: Sized`; *ptr-addr-cast*\n+\n+* `e` is an integer and `U` is `*U_0`, while `U_0: Sized`; *addr-ptr-cast*\n+\n+* `e` has type `&[T; n]` and `U` is `*const T`; *array-ptr-cast*\n+\n+* `e` is a function pointer type and `U` has type `*T`,\n+  while `T: Sized`; *fptr-ptr-cast*\n+\n+* `e` is a function pointer type and `U` is an integer; *fptr-addr-cast*\n+\n+\n+# `transmute`\n+\n+`as` only allows safe casting, and will for example reject an attempt to\n+cast four bytes into a `u32`:\n \n ```rust,ignore\n let a = [0u8, 0u8, 0u8, 0u8];\n@@ -31,13 +141,11 @@ let b = a as u32; // four eights makes 32\n         ^~~~~~~~\n ```\n \n-It\u2019s a \u2018non-scalar cast\u2019 because we have multiple values here: the four\n+This is a \u2018non-scalar cast\u2019 because we have multiple values here: the four\n elements of the array. These kinds of casts are very dangerous, because they\n make assumptions about the way that multiple underlying structures are\n implemented. For this, we need something more dangerous.\n \n-# `transmute`\n-\n The `transmute` function is provided by a [compiler intrinsic][intrinsics], and\n what it does is very simple, but very scary. It tells Rust to treat a value of\n one type as though it were another type. It does this regardless of the"}]}