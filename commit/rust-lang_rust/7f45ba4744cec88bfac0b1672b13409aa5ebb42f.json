{"sha": "7f45ba4744cec88bfac0b1672b13409aa5ebb42f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNDViYTQ3NDRjZWM4OGJmYWMwYjE2NzJiMTM0MDlhYTVlYmI0MmY=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-05-17T18:07:24Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-05-17T21:34:41Z"}, "message": "Move inference-related fields/methods from fn_ctxt to infer_ctxt.", "tree": {"sha": "fd475af188fc898eca99197334fd5042864b8ab9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd475af188fc898eca99197334fd5042864b8ab9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f45ba4744cec88bfac0b1672b13409aa5ebb42f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f45ba4744cec88bfac0b1672b13409aa5ebb42f", "html_url": "https://github.com/rust-lang/rust/commit/7f45ba4744cec88bfac0b1672b13409aa5ebb42f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "251a0a38d7471723b770282c61f001346b03b745", "url": "https://api.github.com/repos/rust-lang/rust/commits/251a0a38d7471723b770282c61f001346b03b745", "html_url": "https://github.com/rust-lang/rust/commit/251a0a38d7471723b770282c61f001346b03b745"}], "stats": {"total": 128, "additions": 68, "deletions": 60}, "files": [{"sha": "a1b16471b1db7b7665cd2e4023bd0f75470600ad", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=7f45ba4744cec88bfac0b1672b13409aa5ebb42f", "patch": "@@ -53,6 +53,7 @@ import middle::ty;\n import middle::ty::{arg, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_public_fields};\n import middle::ty::{ty_vid, region_vid, vid};\n+import middle::typeck::infer::{ty_and_region_var_methods};\n import util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n                      bound_region_to_str, vstore_to_str};\n import std::smallintmap;\n@@ -68,6 +69,7 @@ import std::list;\n import list::{list, nil, cons};\n \n export check_crate;\n+export infer;\n export method_map;\n export method_origin, serialize_method_origin, deserialize_method_origin;\n export vtable_map;"}, {"sha": "069fc7fab7d94bc726579b1649241275bdb2461a", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 21, "deletions": 52, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=7f45ba4744cec88bfac0b1672b13409aa5ebb42f", "patch": "@@ -86,8 +86,6 @@ type fn_ctxt =\n      proto: ast::proto,\n      infcx: infer::infer_ctxt,\n      locals: hashmap<ast::node_id, ty_vid>,\n-     ty_var_counter: @mut uint,\n-     region_var_counter: @mut uint,\n \n      mut blocks: [ast::node_id], // stack of blocks in scope, may be empty\n      in_scope_regions: isr_alist,\n@@ -181,13 +179,11 @@ fn check_fn(ccx: @crate_ctxt,\n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n     let fcx: @fn_ctxt = {\n-        let {infcx, locals, tvc, rvc, purity,\n-             node_types, node_type_substs} = alt old_fcx {\n+        let {infcx, locals, purity, node_types, node_type_substs} =\n+        alt old_fcx {\n           none {\n             {infcx: infer::new_infer_ctxt(tcx),\n              locals: int_hash(),\n-             tvc: @mut 0u,\n-             rvc: @mut 0u,\n              purity: decl.purity,\n              node_types: smallintmap::mk(),\n              node_type_substs: map::int_hash()}\n@@ -196,8 +192,6 @@ fn check_fn(ccx: @crate_ctxt,\n             assert decl.purity == ast::impure_fn;\n             {infcx: fcx.infcx,\n              locals: fcx.locals,\n-             tvc: fcx.ty_var_counter,\n-             rvc: fcx.region_var_counter,\n              purity: fcx.purity,\n              node_types: fcx.node_types,\n              node_type_substs: fcx.node_type_substs}\n@@ -219,8 +213,6 @@ fn check_fn(ccx: @crate_ctxt,\n           proto: proto,\n           infcx: infcx,\n           locals: locals,\n-          ty_var_counter: tvc,\n-          region_var_counter: rvc,\n           mut blocks: [],\n           in_scope_regions: isr,\n           node_types: node_types,\n@@ -265,7 +257,7 @@ fn check_fn(ccx: @crate_ctxt,\n         let tcx = fcx.ccx.tcx;\n \n         let assign = fn@(nid: ast::node_id, ty_opt: option<ty::t>) {\n-            let var_id = fcx.next_ty_var_id();\n+            let var_id = fcx.infcx.next_ty_var_id();\n             fcx.locals.insert(nid, var_id);\n             alt ty_opt {\n               none {/* nothing to do */ }\n@@ -429,13 +421,13 @@ impl of ast_conv for @fn_ctxt {\n     }\n \n     fn ty_infer(_span: span) -> ty::t {\n-        self.next_ty_var()\n+        self.infcx.next_ty_var()\n     }\n }\n \n impl of region_scope for @fn_ctxt {\n     fn anon_region() -> result<ty::region, str> {\n-        result::ok(self.next_region_var())\n+        result::ok(self.infcx.next_region_var())\n     }\n     fn named_region(id: str) -> result<ty::region, str> {\n         empty_rscope.named_region(id).chain_err { |_e|\n@@ -522,25 +514,6 @@ impl methods for @fn_ctxt {\n     fn opt_node_ty_substs(id: ast::node_id) -> option<ty::substs> {\n         self.node_type_substs.find(id)\n     }\n-    fn next_ty_var_id() -> ty_vid {\n-        let id = *self.ty_var_counter;\n-        *self.ty_var_counter += 1u;\n-        ret ty_vid(id);\n-    }\n-    fn next_ty_var() -> ty::t {\n-        ty::mk_var(self.ccx.tcx, self.next_ty_var_id())\n-    }\n-    fn next_ty_vars(n: uint) -> [ty::t] {\n-        vec::from_fn(n) {|_i| self.next_ty_var() }\n-    }\n-    fn next_region_var_id() -> region_vid {\n-        let id = *self.region_var_counter;\n-        *self.region_var_counter += 1u;\n-        ret region_vid(id);\n-    }\n-    fn next_region_var() -> ty::region {\n-        ret ty::re_var(self.next_region_var_id());\n-    }\n \n     fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n                                err: ty::type_err) {\n@@ -691,7 +664,7 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n                rp: rp,\n                raw_ty: ty::mk_class(tcx, local_def(class_id),\n                       {self_r: alt rp {\n-                          ast::rp_self { some(fcx.next_region_var()) }\n+                          ast::rp_self { some(fcx.infcx.next_region_var()) }\n                           ast::rp_none { none }},\n                        self_ty: none,\n                        tps: ty::ty_params_to_tys(tcx, ts)})}\n@@ -708,9 +681,9 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n \n     let self_r = alt rp {\n       ast::rp_none { none }\n-      ast::rp_self { some(fcx.next_region_var()) }\n+      ast::rp_self { some(fcx.infcx.next_region_var()) }\n     };\n-    let tps = fcx.next_ty_vars(n_tps);\n+    let tps = fcx.infcx.next_ty_vars(n_tps);\n \n     let substs = {self_r: self_r, self_ty: none, tps: tps};\n     let substd_ty = ty::subst(tcx, substs, raw_ty);\n@@ -772,7 +745,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              } else {\n                                  \"s were\"\n                              }]);\n-                fcx.next_ty_vars(supplied_arg_count)\n+                fcx.infcx.next_ty_vars(supplied_arg_count)\n             }\n           }\n \n@@ -875,7 +848,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let (if_t, if_bot) =\n             alt elsopt {\n               some(els) {\n-                let if_t = fcx.next_ty_var();\n+                let if_t = fcx.infcx.next_ty_var();\n                 let thn_bot = check_block(fcx, thn);\n                 let thn_t = fcx.node_ty(thn.node.id);\n                 demand::suptype(fcx, thn.span, if_t, thn_t);\n@@ -938,7 +911,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             // result [ML T] where TL <: T and TR <: T.  In other words, the\n             // result type is (generally) the LUB of (TL, TR) and takes the\n             // mutability from the LHS.\n-            let t_var = fcx.next_ty_var();\n+            let t_var = fcx.infcx.next_ty_var();\n             let const_vec_t = ty::mk_vec(tcx, {ty: t_var,\n                                                mutbl: ast::m_const});\n             demand::suptype(fcx, lhs.span, const_vec_t, lhs_t);\n@@ -960,7 +933,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n \n           (_, _) if ty::is_binopable(tcx, lhs_t, op) {\n-            let tvar = fcx.next_ty_var();\n+            let tvar = fcx.infcx.next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n             let rhs_bot = check_expr_with(fcx, rhs, tvar);\n             let rhs_t = alt op {\n@@ -1087,7 +1060,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n           ast::expr_vec(args, mutbl) {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vec::len(args), vst);\n-            let t: ty::t = fcx.next_ty_var();\n+            let t: ty::t = fcx.infcx.next_ty_var();\n             for args.each {|e| bot |= check_expr_with(fcx, e, t); }\n             ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n           }\n@@ -1117,7 +1090,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_binary(ast::gt, lhs, rhs) |\n       ast::expr_binary(ast::ge, lhs, rhs) {\n         let tcx = fcx.ccx.tcx;\n-        let tvar = fcx.next_ty_var();\n+        let tvar = fcx.infcx.next_ty_var();\n         bot |= check_expr_with(fcx, lhs, tvar);\n         bot |= check_expr_with(fcx, rhs, tvar);\n         fcx.write_ty(id, ty::mk_bool(tcx));\n@@ -1463,7 +1436,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, t_1);\n       }\n       ast::expr_vec(args, mutbl) {\n-        let t: ty::t = fcx.next_ty_var();\n+        let t: ty::t = fcx.infcx.next_ty_var();\n         for args.each {|e| bot |= check_expr_with(fcx, e, t); }\n         let typ = ty::mk_vec(tcx, {ty: t, mutbl: mutbl});\n         fcx.write_ty(id, typ);\n@@ -1608,7 +1581,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                field, ty_to_str(tcx, t_err)];\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n-                fcx.write_ty(id, fcx.next_ty_var());\n+                fcx.write_ty(id, fcx.infcx.next_ty_var());\n               }\n             }\n         }\n@@ -1836,8 +1809,6 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n           proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash(),\n-          ty_var_counter: @mut 0u,\n-          region_var_counter: @mut 0u,\n           mut blocks: [],\n           in_scope_regions: @nil,\n           node_types: smallintmap::mk(),\n@@ -1878,8 +1849,6 @@ fn check_enum_variants(ccx: @crate_ctxt,\n           proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash(),\n-          ty_var_counter: @mut 0u,\n-          region_var_counter: @mut 0u,\n           mut blocks: [],\n           in_scope_regions: @nil,\n           node_types: smallintmap::mk(),\n@@ -2148,24 +2117,24 @@ fn instantiate_path(fcx: @fn_ctxt,\n     // For now, there is no way to explicitly specify the region bound.\n     // This will have to change eventually.\n     let self_r = alt tpt.rp {\n-      ast::rp_self { some(fcx.next_region_var()) }\n+      ast::rp_self { some(fcx.infcx.next_region_var()) }\n       ast::rp_none { none }\n     };\n \n     let tps = if ty_substs_len == 0u {\n-        fcx.next_ty_vars(ty_param_count)\n+        fcx.infcx.next_ty_vars(ty_param_count)\n     } else if ty_param_count == 0u {\n         fcx.ccx.tcx.sess.span_err\n             (sp, \"this item does not take type parameters\");\n-        fcx.next_ty_vars(ty_param_count)\n+        fcx.infcx.next_ty_vars(ty_param_count)\n     } else if ty_substs_len > ty_param_count {\n         fcx.ccx.tcx.sess.span_err\n             (sp, \"too many type parameters provided for this item\");\n-        fcx.next_ty_vars(ty_param_count)\n+        fcx.infcx.next_ty_vars(ty_param_count)\n     } else if ty_substs_len < ty_param_count {\n         fcx.ccx.tcx.sess.span_err\n             (sp, \"not enough type parameters provided for this item\");\n-        fcx.next_ty_vars(ty_param_count)\n+        fcx.infcx.next_ty_vars(ty_param_count)\n     } else {\n         pth.types.map { |aty| fcx.to_ty(aty) }\n     };"}, {"sha": "dc43214d669fad0c10b58a406d5a2f46231d6849", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=7f45ba4744cec88bfac0b1672b13409aa5ebb42f", "patch": "@@ -1,11 +1,13 @@\n+import middle::typeck::infer::{ty_and_region_var_methods};\n+\n fn check_alt(fcx: @fn_ctxt,\n              expr: @ast::expr,\n              discrim: @ast::expr,\n              arms: [ast::arm]) -> bool {\n     let tcx = fcx.ccx.tcx;\n     let mut bot = false;\n \n-    let pattern_ty = fcx.next_ty_var();\n+    let pattern_ty = fcx.infcx.next_ty_var();\n     bot = check_expr_with(fcx, discrim, pattern_ty);\n \n     // Typecheck the patterns first, so that we get types for all the\n@@ -22,7 +24,7 @@ fn check_alt(fcx: @fn_ctxt,\n         for arm.pats.each {|p| check_pat(pcx, p, pattern_ty);}\n     }\n     // Now typecheck the blocks.\n-    let mut result_ty = fcx.next_ty_var();\n+    let mut result_ty = fcx.infcx.next_ty_var();\n     let mut arm_non_bot = false;\n     for arms.each {|arm|\n         alt arm.guard {"}, {"sha": "27bbe5f91678a4ce57cec4eedb5dc77ffa3d4220", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=7f45ba4744cec88bfac0b1672b13409aa5ebb42f", "patch": "@@ -1,6 +1,7 @@\n /* Code to handle method lookups (which can be quite complex) */\n \n import regionmanip::universally_quantify_regions;\n+import middle::typeck::infer::{ty_and_region_var_methods};\n \n enum lookup = {\n     fcx: @fn_ctxt,\n@@ -266,18 +267,18 @@ impl methods for lookup {\n         let n_tps_supplied = self.supplied_tps.len();\n         let m_substs = {\n             if n_tps_supplied == 0u {\n-                self.fcx.next_ty_vars(n_tps_m)\n+                self.fcx.infcx.next_ty_vars(n_tps_m)\n             } else if n_tps_m == 0u {\n                 tcx.sess.span_err(\n                     self.expr.span,\n                     \"this method does not take type parameters\");\n-                self.fcx.next_ty_vars(n_tps_m)\n+                self.fcx.infcx.next_ty_vars(n_tps_m)\n             } else if n_tps_supplied != n_tps_m {\n                 tcx.sess.span_err(\n                     self.expr.span,\n                     \"incorrect number of type \\\n                      parameters given for this method\");\n-                self.fcx.next_ty_vars(n_tps_m)\n+                self.fcx.infcx.next_ty_vars(n_tps_m)\n             } else {\n                 self.supplied_tps\n             }"}, {"sha": "8f8472ec5b499fb134e6ddfed7c3bed3aa2b2405", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=7f45ba4744cec88bfac0b1672b13409aa5ebb42f", "patch": "@@ -1,3 +1,5 @@\n+import middle::typeck::infer::{ty_and_region_var_methods};\n+\n // Helper functions related to manipulating region types.\n \n // Helper for the other universally_quantify_*() routines.  Extracts the bound\n@@ -13,7 +15,7 @@ fn universally_quantify_from_sty(fcx: @fn_ctxt,\n     indent {||\n         let tcx = fcx.tcx();\n         let isr = collect_bound_regions_in_tys(tcx, @nil, bound_tys) { |br|\n-            let rvar = fcx.next_region_var();\n+            let rvar = fcx.infcx.next_region_var();\n             #debug[\"Bound region %s maps to %s\",\n                    bound_region_to_str(fcx.ccx.tcx, br),\n                    region_to_str(fcx.ccx.tcx, rvar)];"}, {"sha": "c9fbad28bbd3040c55511a93f1439274ea8dc27f", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f45ba4744cec88bfac0b1672b13409aa5ebb42f/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=7f45ba4744cec88bfac0b1672b13409aa5ebb42f", "patch": "@@ -165,6 +165,7 @@ export mk_assignty;\n export resolve_shallow;\n export resolve_deep;\n export resolve_deep_var;\n+export ty_and_region_var_methods;\n export compare_tys;\n export fixup_err, fixup_err_to_str;\n \n@@ -195,6 +196,10 @@ enum infer_ctxt = @{\n     tcx: ty::ctxt,\n     vb: vals_and_bindings<ty::ty_vid, ty::t>,\n     rb: vals_and_bindings<ty::region_vid, ty::region>,\n+\n+    // For keeping track of existing type/region variables.\n+    ty_var_counter: @mut uint,\n+    region_var_counter: @mut uint,\n };\n \n enum fixup_err {\n@@ -219,8 +224,9 @@ type fres<T> = result::result<T, fixup_err>;\n fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n     infer_ctxt(@{tcx: tcx,\n                  vb: {vals: smallintmap::mk(), mut bindings: []},\n-                 rb: {vals: smallintmap::mk(), mut bindings: []}})\n-}\n+                 rb: {vals: smallintmap::mk(), mut bindings: []},\n+                 ty_var_counter: @mut 0u,\n+                 region_var_counter: @mut 0u})}\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     #debug[\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n@@ -423,6 +429,32 @@ impl methods for infer_ctxt {\n     }\n }\n \n+impl ty_and_region_var_methods for infer_ctxt {\n+    fn next_ty_var_id() -> ty_vid {\n+        let id = *self.ty_var_counter;\n+        *self.ty_var_counter += 1u;\n+        ret ty_vid(id);\n+    }\n+\n+    fn next_ty_var() -> ty::t {\n+        ty::mk_var(self.tcx, self.next_ty_var_id())\n+    }\n+\n+    fn next_ty_vars(n: uint) -> [ty::t] {\n+        vec::from_fn(n) {|_i| self.next_ty_var() }\n+    }\n+\n+    fn next_region_var_id() -> region_vid {\n+        let id = *self.region_var_counter;\n+        *self.region_var_counter += 1u;\n+        ret region_vid(id);\n+    }\n+\n+    fn next_region_var() -> ty::region {\n+        ret ty::re_var(self.next_region_var_id());\n+    }\n+}\n+\n impl unify_methods for infer_ctxt {\n \n     fn set<V:copy vid, T:copy to_str>("}]}