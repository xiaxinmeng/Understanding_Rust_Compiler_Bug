{"sha": "9d34c706b2e8d311bea0d25d5c2db340b38ffd42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMzRjNzA2YjJlOGQzMTFiZWEwZDI1ZDVjMmRiMzQwYjM4ZmZkNDI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-18T23:49:55Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-18T23:49:55Z"}, "message": "rustc: Move ty::impl_traits over to a multiple-traits-per-impl world", "tree": {"sha": "77f6e25f9bfcdb49dfb8152c6c03a684f0005064", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77f6e25f9bfcdb49dfb8152c6c03a684f0005064"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d34c706b2e8d311bea0d25d5c2db340b38ffd42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d34c706b2e8d311bea0d25d5c2db340b38ffd42", "html_url": "https://github.com/rust-lang/rust/commit/9d34c706b2e8d311bea0d25d5c2db340b38ffd42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d34c706b2e8d311bea0d25d5c2db340b38ffd42/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c583def25728793f3a20c9ec9d41e5039c04387", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c583def25728793f3a20c9ec9d41e5039c04387", "html_url": "https://github.com/rust-lang/rust/commit/3c583def25728793f3a20c9ec9d41e5039c04387"}], "stats": {"total": 117, "additions": 64, "deletions": 53}, "files": [{"sha": "7bbb43a14f908cad4ec311cc7f2e1b0f6ab63dc6", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d34c706b2e8d311bea0d25d5c2db340b38ffd42/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d34c706b2e8d311bea0d25d5c2db340b38ffd42/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=9d34c706b2e8d311bea0d25d5c2db340b38ffd42", "patch": "@@ -3263,7 +3263,7 @@ class Resolver {\n                      visitor: ResolveVisitor) {\n \n         // Add a type into the def map. This is needed to prevent an ICE in\n-        // ty::impl_trait.\n+        // ty::impl_traits.\n \n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = (*type_parameters).len();"}, {"sha": "e27e6d14ec94ffb4fd9e9afc3b9e2c6f7cbb5def", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d34c706b2e8d311bea0d25d5c2db340b38ffd42/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d34c706b2e8d311bea0d25d5c2db340b38ffd42/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=9d34c706b2e8d311bea0d25d5c2db340b38ffd42", "patch": "@@ -253,10 +253,12 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n                     vtables: typeck::vtable_res) -> ValueRef {\n     let _icx = ccx.insn_ctxt(~\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n+\n+    // XXX: This should support multiple traits.\n     let ifce_id = expect(ccx.sess,\n-                         ty::ty_to_def_id(option::get(ty::impl_trait(tcx,\n-                                                             impl_id))),\n+                         ty::ty_to_def_id(ty::impl_traits(tcx, impl_id)[0]),\n                          || ~\"make_impl_vtable: non-trait-type implemented\");\n+\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n     make_vtable(ccx, vec::map(*ty::trait_methods(tcx, ifce_id), |im| {\n         let fty = ty::subst_tps(tcx, substs, ty::mk_fn(tcx, im.fty));"}, {"sha": "381d78bbd6bbbc6e033abe22388a7c77d8dad543", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9d34c706b2e8d311bea0d25d5c2db340b38ffd42/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d34c706b2e8d311bea0d25d5c2db340b38ffd42/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=9d34c706b2e8d311bea0d25d5c2db340b38ffd42", "patch": "@@ -65,7 +65,7 @@ export subst, subst_tps, substs_is_noop, substs_to_str, substs;\n export t;\n export new_ty_hash;\n export enum_variants, substd_enum_variants, enum_is_univariant;\n-export trait_methods, store_trait_methods, impl_trait;\n+export trait_methods, store_trait_methods, impl_traits;\n export enum_variant_with_id;\n export ty_dtor;\n export ty_param_bounds_and_ty;\n@@ -2474,38 +2474,48 @@ fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n     result\n }\n \n-// XXX: Needs to return an array of traits.\n-fn impl_trait(cx: ctxt, id: ast::def_id) -> option<t> {\n+fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n     if id.crate == ast::local_crate {\n-        #debug(\"(impl_trait) searching for trait impl %?\", id);\n+        #debug(\"(impl_traits) searching for trait impl %?\", id);\n         alt cx.items.find(id.node) {\n            some(ast_map::node_item(@{\n-                    node: ast::item_impl(_, traits, _, _),\n-                    _},\n-                _)) if traits.len() >= 1 {\n-              some(node_id_to_type(cx, traits[0].ref_id))\n+                        node: ast::item_impl(_, trait_refs, _, _),\n+                        _},\n+                    _)) {\n+\n+                do vec::map(trait_refs) |trait_ref| {\n+                    node_id_to_type(cx, trait_ref.ref_id)\n+                }\n            }\n            some(ast_map::node_item(@{node: ast::item_class(*),\n                            _},_)) {\n              alt cx.def_map.find(id.node) {\n                some(def_ty(trait_id)) {\n                    // XXX: Doesn't work cross-crate.\n-                   #debug(\"(impl_trait) found trait id %?\", trait_id);\n-                   some(node_id_to_type(cx, trait_id.node))\n+                   #debug(\"(impl_traits) found trait id %?\", trait_id);\n+                   ~[node_id_to_type(cx, trait_id.node)]\n                }\n                some(x) {\n-                 cx.sess.bug(#fmt(\"impl_trait: trait ref is in trait map \\\n+                 cx.sess.bug(#fmt(\"impl_traits: trait ref is in trait map \\\n                                    but is bound to %?\", x));\n                }\n                none {\n-                 none\n+                 ~[]\n                }\n              }\n            }\n-           _ { none }\n+           _ { ~[] }\n         }\n     } else {\n-        csearch::get_impl_trait(cx, id)\n+        // XXX: csearch::get_impl_trait should return a vector.\n+        alt csearch::get_impl_trait(cx, id) {\n+            none {\n+                ~[]\n+            }\n+            some(trait_ref) {\n+                ~[trait_ref]\n+            }\n+        }\n     }\n }\n "}, {"sha": "389723c4c8096ec9ad0746ab30e5b4a2aab09364", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9d34c706b2e8d311bea0d25d5c2db340b38ffd42/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d34c706b2e8d311bea0d25d5c2db340b38ffd42/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9d34c706b2e8d311bea0d25d5c2db340b38ffd42", "patch": "@@ -119,44 +119,41 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n             for vec::each(*impls) |im| {\n                 // im = one specific impl\n                 // find the trait that im implements (if any)\n-                let of_ty = alt ty::impl_trait(tcx, im.did) {\n-                  some(of_ty) { of_ty }\n-                  _ { again; }\n-                };\n-\n-                // it must have the same id as the expected one\n-                alt ty::get(of_ty).struct {\n-                  ty::ty_trait(id, _) if id != trait_id { again; }\n-                  _ { /* ok */ }\n-                }\n+                for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n+                    // it must have the same id as the expected one\n+                    alt ty::get(of_ty).struct {\n+                      ty::ty_trait(id, _) if id != trait_id { again; }\n+                      _ { /* ok */ }\n+                    }\n \n-                // check whether the type unifies with the type\n-                // that the impl is for, and continue if not\n-                let {substs: substs, ty: for_ty} =\n-                    impl_self_ty(fcx, im.did);\n-                let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n-                alt fcx.mk_subty(ty, for_ty) {\n-                  result::err(_) { again; }\n-                  result::ok(()) { }\n-                }\n+                    // check whether the type unifies with the type\n+                    // that the impl is for, and continue if not\n+                    let {substs: substs, ty: for_ty} =\n+                        impl_self_ty(fcx, im.did);\n+                    let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n+                    alt fcx.mk_subty(ty, for_ty) {\n+                      result::err(_) { again; }\n+                      result::ok(()) { }\n+                    }\n \n-                // check that desired trait type unifies\n-                #debug(\"(checking vtable) @2 relating trait ty %s to \\\n-                        of_ty %s\",\n-                       fcx.infcx.ty_to_str(trait_ty),\n-                       fcx.infcx.ty_to_str(of_ty));\n-                let of_ty = ty::subst(tcx, substs, of_ty);\n-                relate_trait_tys(fcx, sp, trait_ty, of_ty);\n+                    // check that desired trait type unifies\n+                    #debug(\"(checking vtable) @2 relating trait ty %s to \\\n+                            of_ty %s\",\n+                           fcx.infcx.ty_to_str(trait_ty),\n+                           fcx.infcx.ty_to_str(of_ty));\n+                    let of_ty = ty::subst(tcx, substs, of_ty);\n+                    relate_trait_tys(fcx, sp, trait_ty, of_ty);\n \n-                // recursively process the bounds\n-                let trait_tps = trait_substs.tps;\n-                let substs_f = fixup_substs(fcx, sp, trait_id, substs);\n-                connect_trait_tps(fcx, sp, substs_f.tps,\n-                                  trait_tps, im.did);\n-                let subres = lookup_vtables(fcx, isc, sp,\n-                                            im_bs, substs_f, false);\n-                vec::push(found,\n-                          vtable_static(im.did, substs_f.tps, subres));\n+                    // recursively process the bounds\n+                    let trait_tps = trait_substs.tps;\n+                    let substs_f = fixup_substs(fcx, sp, trait_id, substs);\n+                    connect_trait_tps(fcx, sp, substs_f.tps,\n+                                      trait_tps, im.did);\n+                    let subres = lookup_vtables(fcx, isc, sp,\n+                                                im_bs, substs_f, false);\n+                    vec::push(found,\n+                              vtable_static(im.did, substs_f.tps, subres));\n+                }\n             }\n \n             alt found.len() {\n@@ -195,7 +192,9 @@ fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n fn connect_trait_tps(fcx: @fn_ctxt, sp: span, impl_tys: ~[ty::t],\n                      trait_tys: ~[ty::t], impl_did: ast::def_id) {\n     let tcx = fcx.ccx.tcx;\n-    let ity = option::get(ty::impl_trait(tcx, impl_did));\n+\n+    // XXX: This should work for multiple traits.\n+    let ity = ty::impl_traits(tcx, impl_did)[0];\n     let trait_ty = ty::subst_tps(tcx, impl_tys, ity);\n     #debug(\"(connect trait tps) trait type is %?, impl did is %?\",\n            ty::get(trait_ty).struct, impl_did);"}]}