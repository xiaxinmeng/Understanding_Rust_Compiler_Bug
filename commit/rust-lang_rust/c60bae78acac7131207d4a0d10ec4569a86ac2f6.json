{"sha": "c60bae78acac7131207d4a0d10ec4569a86ac2f6", "node_id": "C_kwDOAAsO6NoAKGM2MGJhZTc4YWNhYzcxMzEyMDdkNGEwZDEwZWM0NTY5YTg2YWMyZjY", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-02-17T10:33:32Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-02-26T05:28:51Z"}, "message": "suggest a float literal when dividing a floating-point type by {integer}\n\nfix a message\n\nimplement a rustfix-applicable suggestion\n\nimplement `suggest_floating_point_literal`\n\nadd `ObligationCauseCode::BinOp`\n\nremove duplicate code\n\nfix function names in uitests\n\nuse `Diagnostic` instead of `DiagnosticBuilder`", "tree": {"sha": "27d46f8f2b7b584b490fad9c09eeca1a55694f62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27d46f8f2b7b584b490fad9c09eeca1a55694f62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c60bae78acac7131207d4a0d10ec4569a86ac2f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c60bae78acac7131207d4a0d10ec4569a86ac2f6", "html_url": "https://github.com/rust-lang/rust/commit/c60bae78acac7131207d4a0d10ec4569a86ac2f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c60bae78acac7131207d4a0d10ec4569a86ac2f6/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12b71ed4c5dfc693769497d9642d4ef38b9fffd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/12b71ed4c5dfc693769497d9642d4ef38b9fffd3", "html_url": "https://github.com/rust-lang/rust/commit/12b71ed4c5dfc693769497d9642d4ef38b9fffd3"}], "stats": {"total": 561, "additions": 543, "deletions": 18}, "files": [{"sha": "45610fa77d35e0b368a9a5d6bc54172b7c1cc892", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -368,6 +368,11 @@ pub enum ObligationCauseCode<'tcx> {\n \n     /// From `match_impl`. The cause for us having to match an impl, and the DefId we are matching against.\n     MatchImpl(ObligationCause<'tcx>, DefId),\n+\n+    BinOp {\n+        rhs_span: Option<Span>,\n+        is_lit: bool,\n+    },\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking."}, {"sha": "f5beb83729f9714d5c36aeb3e9b063e4d0358fe1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -501,6 +501,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             err.span_label(enclosing_scope_span, s.as_str());\n                         }\n \n+                        self.suggest_floating_point_literal(&obligation, &mut err, &trait_ref);\n                         self.suggest_dereferences(&obligation, &mut err, trait_predicate);\n                         self.suggest_fn_call(&obligation, &mut err, trait_predicate);\n                         self.suggest_remove_reference(&obligation, &mut err, trait_predicate);"}, {"sha": "96c24a5ac4c85eb77be3de0397860f69cb8ffb24", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -174,6 +174,13 @@ pub trait InferCtxtExt<'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         span: Span,\n     );\n+\n+    fn suggest_floating_point_literal(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut Diagnostic,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    );\n }\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, String) {\n@@ -1910,8 +1917,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::AwaitableExpr(_)\n             | ObligationCauseCode::ForLoopIterator\n             | ObligationCauseCode::QuestionMark\n+            | ObligationCauseCode::CheckAssociatedTypeBounds { .. }\n             | ObligationCauseCode::LetElse\n-            | ObligationCauseCode::CheckAssociatedTypeBounds { .. } => {}\n+            | ObligationCauseCode::BinOp { .. } => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }\n@@ -2497,6 +2505,32 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn suggest_floating_point_literal(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut Diagnostic,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) {\n+        let rhs_span = match obligation.cause.code() {\n+            ObligationCauseCode::BinOp { rhs_span: Some(span), is_lit } if *is_lit => span,\n+            _ => return,\n+        };\n+        match (\n+            trait_ref.skip_binder().self_ty().kind(),\n+            trait_ref.skip_binder().substs.type_at(1).kind(),\n+        ) {\n+            (ty::Float(_), ty::Infer(InferTy::IntVar(_))) => {\n+                err.span_suggestion_verbose(\n+                    rhs_span.shrink_to_hi(),\n+                    \"consider using a floating-point literal by writing it with `.0`\",\n+                    String::from(\".0\"),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n }\n \n /// Collect all the returned expressions within the input expression."}, {"sha": "5cb1fe8cd94ee97b23569f67995af738c4bc6ce1", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -438,6 +438,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n+    pub(in super::super) fn normalize_op_associated_types_in_as_infer_ok<T>(\n+        &self,\n+        span: Span,\n+        value: T,\n+        opt_input_expr: Option<&hir::Expr<'_>>,\n+    ) -> InferOk<'tcx, T>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.inh.partially_normalize_associated_types_in(\n+            ObligationCause::new(\n+                span,\n+                self.body_id,\n+                traits::BinOp {\n+                    rhs_span: opt_input_expr.map(|expr| expr.span),\n+                    is_lit: opt_input_expr\n+                        .map_or(false, |expr| matches!(expr.kind, ExprKind::Lit(_))),\n+                },\n+            ),\n+            self.param_env,\n+            value,\n+        )\n+    }\n+\n     pub fn require_type_meets(\n         &self,\n         ty: Ty<'tcx>,"}, {"sha": "7bb84581a82de6e654214bbb0c0b48f46f755cfb", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 119, "deletions": 9, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -333,15 +333,57 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n+    pub(super) fn obligation_for_op_method(\n+        &self,\n+        span: Span,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        opt_input_type: Option<Ty<'tcx>>,\n+        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n+    ) -> (traits::Obligation<'tcx, ty::Predicate<'tcx>>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>)\n+    {\n+        // Construct a trait-reference `self_ty : Trait<input_tys>`\n+        let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime | GenericParamDefKind::Const { .. } => {}\n+                GenericParamDefKind::Type { .. } => {\n+                    if param.index == 0 {\n+                        return self_ty.into();\n+                    } else if let Some(input_type) = opt_input_type {\n+                        return input_type.into();\n+                    }\n+                }\n+            }\n+            self.var_for_def(span, param)\n+        });\n+\n+        let trait_ref = ty::TraitRef::new(trait_def_id, substs);\n+\n+        // Construct an obligation\n+        let poly_trait_ref = ty::Binder::dummy(trait_ref);\n+        (\n+            traits::Obligation::new(\n+                traits::ObligationCause::new(\n+                    span,\n+                    self.body_id,\n+                    traits::BinOp {\n+                        rhs_span: opt_input_expr.map(|expr| expr.span),\n+                        is_lit: opt_input_expr\n+                            .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                    },\n+                ),\n+                self.param_env,\n+                poly_trait_ref.without_const().to_predicate(self.tcx),\n+            ),\n+            substs,\n+        )\n+    }\n+\n     /// `lookup_method_in_trait` is used for overloaded operators.\n     /// It does a very narrow slice of what the normal probe/confirm path does.\n     /// In particular, it doesn't really do any probing: it simply constructs\n     /// an obligation for a particular trait with the given self type and checks\n     /// whether that trait is implemented.\n-    //\n-    // FIXME(#18741): it seems likely that we can consolidate some of this\n-    // code with the other method-lookup code. In particular, the second half\n-    // of this method is basically the same as confirmation.\n     #[instrument(level = \"debug\", skip(self, span, opt_input_types))]\n     pub(super) fn lookup_method_in_trait(\n         &self,\n@@ -358,7 +400,57 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (obligation, substs) =\n             self.obligation_for_method(span, trait_def_id, self_ty, opt_input_types);\n+        self.construct_obligation_for_trait(\n+            span,\n+            m_name,\n+            trait_def_id,\n+            obligation,\n+            substs,\n+            None,\n+            false,\n+        )\n+    }\n \n+    pub(super) fn lookup_op_method_in_trait(\n+        &self,\n+        span: Span,\n+        m_name: Ident,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        opt_input_type: Option<Ty<'tcx>>,\n+        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        let (obligation, substs) = self.obligation_for_op_method(\n+            span,\n+            trait_def_id,\n+            self_ty,\n+            opt_input_type,\n+            opt_input_expr,\n+        );\n+        self.construct_obligation_for_trait(\n+            span,\n+            m_name,\n+            trait_def_id,\n+            obligation,\n+            substs,\n+            opt_input_expr,\n+            true,\n+        )\n+    }\n+\n+    // FIXME(#18741): it seems likely that we can consolidate some of this\n+    // code with the other method-lookup code. In particular, the second half\n+    // of this method is basically the same as confirmation.\n+    fn construct_obligation_for_trait(\n+        &self,\n+        span: Span,\n+        m_name: Ident,\n+        trait_def_id: DefId,\n+        obligation: traits::PredicateObligation<'tcx>,\n+        substs: &'tcx ty::List<ty::subst::GenericArg<'tcx>>,\n+        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        is_op: bool,\n+    ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(?obligation);\n \n         // Now we want to know if this can be matched\n@@ -395,8 +487,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig).0;\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n \n-        let InferOk { value, obligations: o } =\n-            self.normalize_associated_types_in_as_infer_ok(span, fn_sig);\n+        let InferOk { value, obligations: o } = if is_op {\n+            self.normalize_op_associated_types_in_as_infer_ok(span, fn_sig, opt_input_expr)\n+        } else {\n+            self.normalize_associated_types_in_as_infer_ok(span, fn_sig)\n+        };\n         let fn_sig = {\n             obligations.extend(o);\n             value\n@@ -412,16 +507,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // any late-bound regions appearing in its bounds.\n         let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n \n-        let InferOk { value, obligations: o } =\n-            self.normalize_associated_types_in_as_infer_ok(span, bounds);\n+        let InferOk { value, obligations: o } = if is_op {\n+            self.normalize_op_associated_types_in_as_infer_ok(span, bounds, opt_input_expr)\n+        } else {\n+            self.normalize_associated_types_in_as_infer_ok(span, bounds)\n+        };\n         let bounds = {\n             obligations.extend(o);\n             value\n         };\n \n         assert!(!bounds.has_escaping_bound_vars());\n \n-        let cause = traits::ObligationCause::misc(span, self.body_id);\n+        let cause = if is_op {\n+            ObligationCause::new(\n+                span,\n+                self.body_id,\n+                traits::BinOp {\n+                    rhs_span: opt_input_expr.map(|expr| expr.span),\n+                    is_lit: opt_input_expr\n+                        .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                },\n+            )\n+        } else {\n+            traits::ObligationCause::misc(span, self.body_id)\n+        };\n         obligations.extend(traits::predicates_for_generics(cause.clone(), self.param_env, bounds));\n \n         // Also add an obligation for the method type being well-formed."}, {"sha": "cd77e6d0384d88226d7e1207ba9dc7cc6ed32b64", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -201,7 +201,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             span: rhs_expr.span,\n         });\n \n-        let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n+        let result = self.lookup_op_method(\n+            lhs_ty,\n+            Some(rhs_ty_var),\n+            Some(rhs_expr),\n+            Op::Binary(op, is_assign),\n+        );\n \n         // see `NB` above\n         let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var, Some(lhs_expr));\n@@ -382,6 +387,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 lhs_expr.span,\n                                 lhs_ty,\n                                 rhs_ty,\n+                                rhs_expr,\n                                 op,\n                                 is_assign,\n                             );\n@@ -390,6 +396,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 rhs_expr.span,\n                                 rhs_ty,\n                                 lhs_ty,\n+                                lhs_expr,\n                                 op,\n                                 is_assign,\n                             );\n@@ -400,7 +407,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n                 if let Ref(_, rty, _) = lhs_ty.kind() {\n                     if self.infcx.type_is_copy_modulo_regions(self.param_env, *rty, lhs_expr.span)\n-                        && self.lookup_op_method(*rty, &[rhs_ty], Op::Binary(op, is_assign)).is_ok()\n+                        && self\n+                            .lookup_op_method(\n+                                *rty,\n+                                Some(rhs_ty),\n+                                Some(rhs_expr),\n+                                Op::Binary(op, is_assign),\n+                            )\n+                            .is_ok()\n                     {\n                         if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n                             let msg = &format!(\n@@ -443,7 +457,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let needs_bound = self\n                                 .lookup_op_method(\n                                     eraser.fold_ty(lhs_ty),\n-                                    &[eraser.fold_ty(rhs_ty)],\n+                                    Some(eraser.fold_ty(rhs_ty)),\n+                                    Some(rhs_expr),\n                                     Op::Binary(op, is_assign),\n                                 )\n                                 .is_ok();\n@@ -487,6 +502,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         ty: Ty<'tcx>,\n         other_ty: Ty<'tcx>,\n+        other_expr: &'tcx hir::Expr<'tcx>,\n         op: hir::BinOp,\n         is_assign: IsAssign,\n     ) -> bool /* did we suggest to call a function because of missing parentheses? */ {\n@@ -513,7 +529,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n             if self\n-                .lookup_op_method(fn_sig.output(), &[other_ty], Op::Binary(op, is_assign))\n+                .lookup_op_method(\n+                    fn_sig.output(),\n+                    Some(other_ty),\n+                    Some(other_expr),\n+                    Op::Binary(op, is_assign),\n+                )\n                 .is_ok()\n             {\n                 let (variable_snippet, applicability) = if !fn_sig.inputs().is_empty() {\n@@ -631,7 +652,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         op: hir::UnOp,\n     ) -> Ty<'tcx> {\n         assert!(op.is_by_value());\n-        match self.lookup_op_method(operand_ty, &[], Op::Unary(op, ex.span)) {\n+        match self.lookup_op_method(operand_ty, None, None, Op::Unary(op, ex.span)) {\n             Ok(method) => {\n                 self.write_method_call(ex.hir_id, method);\n                 method.sig.output()\n@@ -705,7 +726,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn lookup_op_method(\n         &self,\n         lhs_ty: Ty<'tcx>,\n-        other_tys: &[Ty<'tcx>],\n+        other_ty: Option<Ty<'tcx>>,\n+        other_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         op: Op,\n     ) -> Result<MethodCallee<'tcx>, Vec<FulfillmentError<'tcx>>> {\n         let lang = self.tcx.lang_items();\n@@ -791,7 +813,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let opname = Ident::with_dummy_span(opname);\n         let method = trait_did.and_then(|trait_did| {\n-            self.lookup_method_in_trait(span, opname, trait_did, lhs_ty, Some(other_tys))\n+            self.lookup_op_method_in_trait(span, opname, trait_did, lhs_ty, other_ty, other_ty_expr)\n         });\n \n         match (method, trait_did) {\n@@ -803,7 +825,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (None, None) => Err(vec![]),\n             (None, Some(trait_did)) => {\n                 let (obligation, _) =\n-                    self.obligation_for_method(span, trait_did, lhs_ty, Some(other_tys));\n+                    self.obligation_for_op_method(span, trait_did, lhs_ty, other_ty, other_ty_expr);\n                 let mut fulfill = <dyn TraitEngine<'_>>::new(self.tcx);\n                 fulfill.register_predicate_obligation(self, obligation);\n                 Err(fulfill.select_where_possible(&self.infcx))"}, {"sha": "69731bfe7ee7da40e9510613b8518baedfc148d7", "filename": "src/test/ui/issues/issue-24352.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fissues%2Fissue-24352.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fissues%2Fissue-24352.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24352.stderr?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -5,6 +5,10 @@ LL |     1.0f64 - 1\n    |            ^ no implementation for `f64 - {integer}`\n    |\n    = help: the trait `Sub<{integer}>` is not implemented for `f64`\n+help: consider using a floating-point literal by writing it with `.0`\n+   |\n+LL |     1.0f64 - 1.0\n+   |               ++\n \n error: aborting due to previous error\n "}, {"sha": "513d02db988ed2c0f1d3f5005705a53e57f4436e", "filename": "src/test/ui/numbers-arithmetic/not-suggest-float-literal.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnot-suggest-float-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnot-suggest-float-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnot-suggest-float-literal.rs?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -0,0 +1,53 @@\n+fn add_float_to_integer(x: u8) -> f32 {\n+    x + 100.0 //~ ERROR cannot add `{float}` to `u8`\n+}\n+\n+fn add_str_to_float(x: f64) -> f64 {\n+    x + \"foo\" //~ ERROR cannot add `&str` to `f64`\n+}\n+\n+fn add_lvar_to_float(x: f64) -> f64 {\n+    let y = 3;\n+    x + y //~ ERROR cannot add `{integer}` to `f64`\n+}\n+\n+fn subtract_float_from_integer(x: u8) -> f32 {\n+    x - 100.0 //~ ERROR cannot subtract `{float}` from `u8`\n+}\n+\n+fn subtract_str_from_f64(x: f64) -> f64 {\n+    x - \"foo\" //~ ERROR cannot subtract `&str` from `f64`\n+}\n+\n+fn subtract_lvar_from_f64(x: f64) -> f64 {\n+    let y = 3;\n+    x - y //~ ERROR cannot subtract `{integer}` from `f64`\n+}\n+\n+fn multiply_integer_by_float(x: u8) -> f32 {\n+    x * 100.0 //~ ERROR cannot multiply `u8` by `{float}`\n+}\n+\n+fn multiply_f64_by_str(x: f64) -> f64 {\n+    x * \"foo\" //~ ERROR cannot multiply `f64` by `&str`\n+}\n+\n+fn multiply_f64_by_lvar(x: f64) -> f64 {\n+    let y = 3;\n+    x * y //~ ERROR cannot multiply `f64` by `{integer}`\n+}\n+\n+fn divide_integer_by_float(x: u8) -> u8 {\n+    x / 100.0 //~ ERROR cannot divide `u8` by `{float}`\n+}\n+\n+fn divide_f64_by_str(x: f64) -> f64 {\n+    x / \"foo\" //~ ERROR cannot divide `f64` by `&str`\n+}\n+\n+fn divide_f64_by_lvar(x: f64) -> f64 {\n+    let y = 3;\n+    x / y //~ ERROR cannot divide `f64` by `{integer}`\n+}\n+\n+fn main() {}"}, {"sha": "ce9a08a15897a13c5c130a038e8f0782cfe2c385", "filename": "src/test/ui/numbers-arithmetic/not-suggest-float-literal.stderr", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnot-suggest-float-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnot-suggest-float-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnot-suggest-float-literal.stderr?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -0,0 +1,99 @@\n+error[E0277]: cannot add `{float}` to `u8`\n+  --> $DIR/not-suggest-float-literal.rs:2:7\n+   |\n+LL |     x + 100.0\n+   |       ^ no implementation for `u8 + {float}`\n+   |\n+   = help: the trait `Add<{float}>` is not implemented for `u8`\n+\n+error[E0277]: cannot add `&str` to `f64`\n+  --> $DIR/not-suggest-float-literal.rs:6:7\n+   |\n+LL |     x + \"foo\"\n+   |       ^ no implementation for `f64 + &str`\n+   |\n+   = help: the trait `Add<&str>` is not implemented for `f64`\n+\n+error[E0277]: cannot add `{integer}` to `f64`\n+  --> $DIR/not-suggest-float-literal.rs:11:7\n+   |\n+LL |     x + y\n+   |       ^ no implementation for `f64 + {integer}`\n+   |\n+   = help: the trait `Add<{integer}>` is not implemented for `f64`\n+\n+error[E0277]: cannot subtract `{float}` from `u8`\n+  --> $DIR/not-suggest-float-literal.rs:15:7\n+   |\n+LL |     x - 100.0\n+   |       ^ no implementation for `u8 - {float}`\n+   |\n+   = help: the trait `Sub<{float}>` is not implemented for `u8`\n+\n+error[E0277]: cannot subtract `&str` from `f64`\n+  --> $DIR/not-suggest-float-literal.rs:19:7\n+   |\n+LL |     x - \"foo\"\n+   |       ^ no implementation for `f64 - &str`\n+   |\n+   = help: the trait `Sub<&str>` is not implemented for `f64`\n+\n+error[E0277]: cannot subtract `{integer}` from `f64`\n+  --> $DIR/not-suggest-float-literal.rs:24:7\n+   |\n+LL |     x - y\n+   |       ^ no implementation for `f64 - {integer}`\n+   |\n+   = help: the trait `Sub<{integer}>` is not implemented for `f64`\n+\n+error[E0277]: cannot multiply `u8` by `{float}`\n+  --> $DIR/not-suggest-float-literal.rs:28:7\n+   |\n+LL |     x * 100.0\n+   |       ^ no implementation for `u8 * {float}`\n+   |\n+   = help: the trait `Mul<{float}>` is not implemented for `u8`\n+\n+error[E0277]: cannot multiply `f64` by `&str`\n+  --> $DIR/not-suggest-float-literal.rs:32:7\n+   |\n+LL |     x * \"foo\"\n+   |       ^ no implementation for `f64 * &str`\n+   |\n+   = help: the trait `Mul<&str>` is not implemented for `f64`\n+\n+error[E0277]: cannot multiply `f64` by `{integer}`\n+  --> $DIR/not-suggest-float-literal.rs:37:7\n+   |\n+LL |     x * y\n+   |       ^ no implementation for `f64 * {integer}`\n+   |\n+   = help: the trait `Mul<{integer}>` is not implemented for `f64`\n+\n+error[E0277]: cannot divide `u8` by `{float}`\n+  --> $DIR/not-suggest-float-literal.rs:41:7\n+   |\n+LL |     x / 100.0\n+   |       ^ no implementation for `u8 / {float}`\n+   |\n+   = help: the trait `Div<{float}>` is not implemented for `u8`\n+\n+error[E0277]: cannot divide `f64` by `&str`\n+  --> $DIR/not-suggest-float-literal.rs:45:7\n+   |\n+LL |     x / \"foo\"\n+   |       ^ no implementation for `f64 / &str`\n+   |\n+   = help: the trait `Div<&str>` is not implemented for `f64`\n+\n+error[E0277]: cannot divide `f64` by `{integer}`\n+  --> $DIR/not-suggest-float-literal.rs:50:7\n+   |\n+LL |     x / y\n+   |       ^ no implementation for `f64 / {integer}`\n+   |\n+   = help: the trait `Div<{integer}>` is not implemented for `f64`\n+\n+error: aborting due to 12 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9278262a6ffeeb96e309d03e640cb6339cb6be27", "filename": "src/test/ui/numbers-arithmetic/suggest-float-literal.fixed", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.fixed?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -0,0 +1,37 @@\n+// run-rustfix\n+\n+#![allow(dead_code)]\n+\n+fn add_integer_to_f32(x: f32) -> f32 {\n+    x + 100.0 //~ ERROR cannot add `{integer}` to `f32`\n+}\n+\n+fn add_integer_to_f64(x: f64) -> f64 {\n+    x + 100.0 //~ ERROR cannot add `{integer}` to `f64`\n+}\n+\n+fn subtract_integer_from_f32(x: f32) -> f32 {\n+    x - 100.0 //~ ERROR cannot subtract `{integer}` from `f32`\n+}\n+\n+fn subtract_integer_from_f64(x: f64) -> f64 {\n+    x - 100.0 //~ ERROR cannot subtract `{integer}` from `f64`\n+}\n+\n+fn multiply_f32_by_integer(x: f32) -> f32 {\n+    x * 100.0 //~ ERROR cannot multiply `f32` by `{integer}`\n+}\n+\n+fn multiply_f64_by_integer(x: f64) -> f64 {\n+    x * 100.0 //~ ERROR cannot multiply `f64` by `{integer}`\n+}\n+\n+fn divide_f32_by_integer(x: f32) -> f32 {\n+    x / 100.0 //~ ERROR cannot divide `f32` by `{integer}`\n+}\n+\n+fn divide_f64_by_integer(x: f64) -> f64 {\n+    x / 100.0 //~ ERROR cannot divide `f64` by `{integer}`\n+}\n+\n+fn main() {}"}, {"sha": "59e67f8d33e0008b61aa72520c189b24fc5fd29f", "filename": "src/test/ui/numbers-arithmetic/suggest-float-literal.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.rs?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -0,0 +1,37 @@\n+// run-rustfix\n+\n+#![allow(dead_code)]\n+\n+fn add_integer_to_f32(x: f32) -> f32 {\n+    x + 100 //~ ERROR cannot add `{integer}` to `f32`\n+}\n+\n+fn add_integer_to_f64(x: f64) -> f64 {\n+    x + 100 //~ ERROR cannot add `{integer}` to `f64`\n+}\n+\n+fn subtract_integer_from_f32(x: f32) -> f32 {\n+    x - 100 //~ ERROR cannot subtract `{integer}` from `f32`\n+}\n+\n+fn subtract_integer_from_f64(x: f64) -> f64 {\n+    x - 100 //~ ERROR cannot subtract `{integer}` from `f64`\n+}\n+\n+fn multiply_f32_by_integer(x: f32) -> f32 {\n+    x * 100 //~ ERROR cannot multiply `f32` by `{integer}`\n+}\n+\n+fn multiply_f64_by_integer(x: f64) -> f64 {\n+    x * 100 //~ ERROR cannot multiply `f64` by `{integer}`\n+}\n+\n+fn divide_f32_by_integer(x: f32) -> f32 {\n+    x / 100 //~ ERROR cannot divide `f32` by `{integer}`\n+}\n+\n+fn divide_f64_by_integer(x: f64) -> f64 {\n+    x / 100 //~ ERROR cannot divide `f64` by `{integer}`\n+}\n+\n+fn main() {}"}, {"sha": "eb0be785061e6dcd48d653a6fba1b3cfe7853e43", "filename": "src/test/ui/numbers-arithmetic/suggest-float-literal.stderr", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c60bae78acac7131207d4a0d10ec4569a86ac2f6/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.stderr?ref=c60bae78acac7131207d4a0d10ec4569a86ac2f6", "patch": "@@ -0,0 +1,99 @@\n+error[E0277]: cannot add `{integer}` to `f32`\n+  --> $DIR/suggest-float-literal.rs:6:7\n+   |\n+LL |     x + 100\n+   |       ^ no implementation for `f32 + {integer}`\n+   |\n+   = help: the trait `Add<{integer}>` is not implemented for `f32`\n+help: consider using a floating-point literal by writing it with `.0`\n+   |\n+LL |     x + 100.0\n+   |            ++\n+\n+error[E0277]: cannot add `{integer}` to `f64`\n+  --> $DIR/suggest-float-literal.rs:10:7\n+   |\n+LL |     x + 100\n+   |       ^ no implementation for `f64 + {integer}`\n+   |\n+   = help: the trait `Add<{integer}>` is not implemented for `f64`\n+help: consider using a floating-point literal by writing it with `.0`\n+   |\n+LL |     x + 100.0\n+   |            ++\n+\n+error[E0277]: cannot subtract `{integer}` from `f32`\n+  --> $DIR/suggest-float-literal.rs:14:7\n+   |\n+LL |     x - 100\n+   |       ^ no implementation for `f32 - {integer}`\n+   |\n+   = help: the trait `Sub<{integer}>` is not implemented for `f32`\n+help: consider using a floating-point literal by writing it with `.0`\n+   |\n+LL |     x - 100.0\n+   |            ++\n+\n+error[E0277]: cannot subtract `{integer}` from `f64`\n+  --> $DIR/suggest-float-literal.rs:18:7\n+   |\n+LL |     x - 100\n+   |       ^ no implementation for `f64 - {integer}`\n+   |\n+   = help: the trait `Sub<{integer}>` is not implemented for `f64`\n+help: consider using a floating-point literal by writing it with `.0`\n+   |\n+LL |     x - 100.0\n+   |            ++\n+\n+error[E0277]: cannot multiply `f32` by `{integer}`\n+  --> $DIR/suggest-float-literal.rs:22:7\n+   |\n+LL |     x * 100\n+   |       ^ no implementation for `f32 * {integer}`\n+   |\n+   = help: the trait `Mul<{integer}>` is not implemented for `f32`\n+help: consider using a floating-point literal by writing it with `.0`\n+   |\n+LL |     x * 100.0\n+   |            ++\n+\n+error[E0277]: cannot multiply `f64` by `{integer}`\n+  --> $DIR/suggest-float-literal.rs:26:7\n+   |\n+LL |     x * 100\n+   |       ^ no implementation for `f64 * {integer}`\n+   |\n+   = help: the trait `Mul<{integer}>` is not implemented for `f64`\n+help: consider using a floating-point literal by writing it with `.0`\n+   |\n+LL |     x * 100.0\n+   |            ++\n+\n+error[E0277]: cannot divide `f32` by `{integer}`\n+  --> $DIR/suggest-float-literal.rs:30:7\n+   |\n+LL |     x / 100\n+   |       ^ no implementation for `f32 / {integer}`\n+   |\n+   = help: the trait `Div<{integer}>` is not implemented for `f32`\n+help: consider using a floating-point literal by writing it with `.0`\n+   |\n+LL |     x / 100.0\n+   |            ++\n+\n+error[E0277]: cannot divide `f64` by `{integer}`\n+  --> $DIR/suggest-float-literal.rs:34:7\n+   |\n+LL |     x / 100\n+   |       ^ no implementation for `f64 / {integer}`\n+   |\n+   = help: the trait `Div<{integer}>` is not implemented for `f64`\n+help: consider using a floating-point literal by writing it with `.0`\n+   |\n+LL |     x / 100.0\n+   |            ++\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}