{"sha": "719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxOWE0NzUwYmE3ZDRjNmUzNWY2YTJkMDU3OWFiOWZiNzlkYmYxZjM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-12T21:48:13Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-12T21:48:18Z"}, "message": "Add some monomorphizing instrumentation, simplify types before emitting glue.", "tree": {"sha": "92bfb74d14d82481b421c0e8b384dd0efeeda61e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92bfb74d14d82481b421c0e8b384dd0efeeda61e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3", "html_url": "https://github.com/rust-lang/rust/commit/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ce2ee12beea76727fe2ced87748c31725ce4e98", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ce2ee12beea76727fe2ced87748c31725ce4e98", "html_url": "https://github.com/rust-lang/rust/commit/4ce2ee12beea76727fe2ced87748c31725ce4e98"}], "stats": {"total": 139, "additions": 135, "deletions": 4}, "files": [{"sha": "6b89549e73c275085929a5fc64d52e2bb266e008", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3", "patch": "@@ -1554,6 +1554,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  id: ast::node_id,\n                  maybe_load_env: fn(fn_ctxt),\n                  finish: fn(block)) {\n+    ccx.stats.n_closures += 1;\n     let _icx = ccx.insn_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n@@ -1619,6 +1620,7 @@ fn trans_fn(ccx: @crate_ctxt,\n     let start = if do_time { time::get_time() }\n                 else { {sec: 0i64, nsec: 0i32} };\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n+    ccx.stats.n_fns += 1;\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n                   param_substs, id,\n                   |fcx| {\n@@ -2651,6 +2653,10 @@ fn trans_crate(sess: session::session,\n                mut n_glues_created: 0u,\n                mut n_null_glues: 0u,\n                mut n_real_glues: 0u,\n+               mut n_fns: 0u,\n+               mut n_monos: 0u,\n+               mut n_inlines: 0u,\n+               mut n_closures: 0u,\n                llvm_insn_ctxt: @mut ~[],\n                llvm_insns: str_hash(),\n                fn_times: @mut ~[]},\n@@ -2704,13 +2710,20 @@ fn trans_crate(sess: session::session,\n         io::println(fmt!(\"n_null_glues: %u\", ccx.stats.n_null_glues));\n         io::println(fmt!(\"n_real_glues: %u\", ccx.stats.n_real_glues));\n \n+        io::println(fmt!(\"n_fns: %u\", ccx.stats.n_fns));\n+        io::println(fmt!(\"n_monos: %u\", ccx.stats.n_monos));\n+        io::println(fmt!(\"n_inlines: %u\", ccx.stats.n_inlines));\n+        io::println(fmt!(\"n_closures: %u\", ccx.stats.n_closures));\n+\n         // FIXME (#2280): this temporary shouldn't be\n         // necessary, but seems to be, for borrowing.\n+        /*\n         let times = copy *ccx.stats.fn_times;\n         for vec::each(times) |timing| {\n             io::println(fmt!(\"time: %s took %d ms\", timing.ident,\n                              timing.time));\n         }\n+        */\n     }\n \n     if ccx.sess.count_llvm_insns() {"}, {"sha": "0708d9f21a6810eac40310e41e3cab24ac537d6f", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3", "patch": "@@ -89,6 +89,10 @@ type stats =\n      mut n_glues_created: uint,\n      mut n_null_glues: uint,\n      mut n_real_glues: uint,\n+     mut n_fns: uint,\n+     mut n_monos: uint,\n+     mut n_inlines: uint,\n+     mut n_closures: uint,\n      llvm_insn_ctxt: @mut ~[~str],\n      llvm_insns: HashMap<~str, uint>,\n      fn_times: @mut ~[{ident: ~str, time: int}]};"}, {"sha": "fce38badf9a189913b30ce943d12afcceb5fcdd1", "filename": "src/rustc/middle/trans/glue.rs", "status": "modified", "additions": 97, "deletions": 1, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3", "patch": "@@ -121,10 +121,103 @@ fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_visit_glue, static_ti);\n }\n \n+fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n+\n+    if (field == abi::tydesc_field_take_glue ||\n+        field == abi::tydesc_field_drop_glue ||\n+        field == abi::tydesc_field_free_glue) &&\n+        ! ty::type_needs_drop(tcx, t) {\n+          return ty::mk_u32(tcx);\n+    }\n+\n+    if field == abi::tydesc_field_take_glue {\n+        match ty::get(t).sty {\n+          ty::ty_unboxed_vec(*) => { return ty::mk_u32(tcx); }\n+          _ => ()\n+        }\n+    }\n+\n+    if field == abi::tydesc_field_take_glue &&\n+        ty::type_is_boxed(t) {\n+          return ty::mk_imm_box(tcx, ty::mk_u32(tcx));\n+    }\n+\n+    if field == abi::tydesc_field_free_glue {\n+        match ty::get(t).sty {\n+          ty::ty_fn(*) |\n+          ty::ty_box(*) |\n+          ty::ty_opaque_box |\n+          ty::ty_uniq(*) |\n+          ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n+          ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) |\n+          ty::ty_opaque_closure_ptr(*) => (),\n+          _ => { return ty::mk_u32(tcx); }\n+        }\n+    }\n+\n+    if (field == abi::tydesc_field_free_glue ||\n+        field == abi::tydesc_field_drop_glue) {\n+        match ty::get(t).sty {\n+          ty::ty_box(mt) |\n+          ty::ty_evec(mt, ty::vstore_box)\n+          if ! ty::type_needs_drop(tcx, mt.ty) =>\n+          return ty::mk_imm_box(tcx, ty::mk_u32(tcx)),\n+\n+          ty::ty_uniq(mt) |\n+          ty::ty_evec(mt, ty::vstore_uniq)\n+          if ! ty::type_needs_drop(tcx, mt.ty) =>\n+          return ty::mk_imm_uniq(tcx, ty::mk_u32(tcx)),\n+\n+          _ => ()\n+        }\n+    }\n+\n+    return t;\n+}\n+\n+pure fn cast_glue(ccx: @crate_ctxt, ti: @tydesc_info, v: ValueRef)\n+    -> ValueRef {\n+    unchecked {\n+        let llfnty = type_of_glue_fn(ccx, ti.ty);\n+        llvm::LLVMConstPointerCast(v, T_ptr(llfnty))\n+    }\n+}\n+\n+fn lazily_emit_simplified_tydesc_glue(ccx: @crate_ctxt, field: uint,\n+                                      ti: @tydesc_info) -> bool {\n+    let _icx = ccx.insn_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n+    let simpl = simplified_glue_type(ccx.tcx, field, ti.ty);\n+    if simpl != ti.ty {\n+        let simpl_ti = base::get_tydesc(ccx, simpl);\n+        lazily_emit_tydesc_glue(ccx, field, simpl_ti);\n+        if field == abi::tydesc_field_take_glue {\n+            ti.take_glue =\n+                simpl_ti.take_glue.map(|v| cast_glue(ccx, ti, v));\n+        } else if field == abi::tydesc_field_drop_glue {\n+            ti.drop_glue =\n+                simpl_ti.drop_glue.map(|v| cast_glue(ccx, ti, v));\n+        } else if field == abi::tydesc_field_free_glue {\n+            ti.free_glue =\n+                simpl_ti.free_glue.map(|v| cast_glue(ccx, ti, v));\n+        } else if field == abi::tydesc_field_visit_glue {\n+            ti.visit_glue =\n+                simpl_ti.visit_glue.map(|v| cast_glue(ccx, ti, v));\n+        }\n+        return true;\n+    }\n+    return false;\n+}\n+\n+\n fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n                            ti: @tydesc_info) {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n     let llfnty = type_of_glue_fn(ccx, ti.ty);\n+\n+    if lazily_emit_simplified_tydesc_glue(ccx, field, ti) {\n+        return;\n+    }\n+\n     if field == abi::tydesc_field_take_glue {\n         match ti.take_glue {\n           Some(_) => (),\n@@ -502,7 +595,9 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     //XXX this triggers duplicate LLVM symbols\n     let name = if false /*ccx.sess.opts.debuginfo*/ {\n         mangle_internal_name_by_type_only(ccx, t, ~\"tydesc\")\n-    } else { mangle_internal_name_by_seq(ccx, ~\"tydesc\") };\n+    } else {\n+        mangle_internal_name_by_seq(ccx, ~\"tydesc\")\n+    };\n     note_unique_llvm_symbol(ccx, name);\n     log(debug, fmt!(\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name));\n     let gvar = str::as_c_str(name, |buf| {\n@@ -535,6 +630,7 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n     } else {\n         fn_nm = mangle_internal_name_by_seq(ccx, (~\"glue_\" + name));\n     }\n+    debug!(\"%s is for type %s\", fn_nm, ty_to_str(ccx.tcx, t));\n     note_unique_llvm_symbol(ccx, fn_nm);\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(llfn, t);"}, {"sha": "08e9cde6ac53f3c140cd946bd337566c9745b337", "filename": "src/rustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs?ref=719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3", "patch": "@@ -30,6 +30,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n           }\n           csearch::found(ast::ii_item(item)) => {\n             ccx.external.insert(fn_id, Some(item.id));\n+            ccx.stats.n_inlines += 1;\n             trans_item(ccx, *item);\n             local_def(item.id)\n           }\n@@ -64,6 +65,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n                with a non-item parent\");\n           }\n           csearch::found(ast::ii_method(impl_did, mth)) => {\n+            ccx.stats.n_inlines += 1;\n             ccx.external.insert(fn_id, Some(mth.id));\n             let {bounds: impl_bnds, region_param: _, ty: impl_ty} =\n                 ty::lookup_item_type(ccx.tcx, impl_did);"}, {"sha": "243b0b96fa30615e6d15f7a330e4d64e3f2ad3aa", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3", "patch": "@@ -97,6 +97,8 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     let mono_ty = ty::subst_tps(ccx.tcx, substs, llitem_ty);\n     let llfty = type_of_fn_from_ty(ccx, mono_ty);\n \n+    ccx.stats.n_monos += 1;\n+\n     let depth = option::get_default(ccx.monomorphizing.find(fn_id), 0u);\n     // Random cut-off -- code that needs to instantiate the same function\n     // recursively more than ten times can probably safely be assumed to be"}, {"sha": "f66e609cd70adf0ee7fd6f34d7fa3c164b75b1f9", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=719a4750ba7d4c6e35f6a2d0579ab9fb79dbf1f3", "patch": "@@ -1546,6 +1546,7 @@ fn type_is_immediate(ty: t) -> bool {\n         type_is_unique(ty) || type_is_region_ptr(ty);\n }\n \n+\n fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     match cx.needs_drop_cache.find(ty) {\n       Some(result) => return result,\n@@ -1557,8 +1558,22 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       // scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) | ty_rptr(_, _) |\n-      ty_estr(vstore_fixed(_)) | ty_estr(vstore_slice(_)) |\n-      ty_evec(_, vstore_slice(_)) => false,\n+      ty_estr(vstore_fixed(_)) |\n+      ty_estr(vstore_slice(_)) |\n+      ty_evec(_, vstore_slice(_)) |\n+      ty_self => false,\n+\n+      ty_box(_) | ty_uniq(_) |\n+      ty_opaque_box | ty_opaque_closure_ptr(*) |\n+      ty_estr(vstore_uniq) |\n+      ty_estr(vstore_box) |\n+      ty_evec(_, vstore_uniq) |\n+      ty_evec(_, vstore_box) => true,\n+\n+      ty_trait(*) => true,\n+\n+      ty_param(*) | ty_infer(*) => true,\n+\n       ty_evec(mt, vstore_fixed(_)) => type_needs_drop(cx, mt.ty),\n       ty_unboxed_vec(mt) => type_needs_drop(cx, mt.ty),\n       ty_rec(flds) => {\n@@ -1598,7 +1613,6 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n           _ => true\n         }\n       }\n-      _ => true\n     };\n \n     cx.needs_drop_cache.insert(ty, result);"}]}