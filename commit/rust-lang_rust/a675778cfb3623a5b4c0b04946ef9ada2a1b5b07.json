{"sha": "a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NzU3NzhjZmIzNjIzYTViNGMwYjA0OTQ2ZWY5YWRhMmExYjViMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-25T08:54:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-25T08:54:27Z"}, "message": "Auto merge of #6029 - Daniel-B-Smith:refcell_ref_await, r=flip1995\n\nAdd lint for holding RefCell Ref across an await\n\nFixes #6008\n\nThis introduces the lint await_holding_refcell_ref. For async functions, we iterate\nover all types in generator_interior_types and look for `core::cell::Ref` or `core::cell::RefMut`. If we find one then we emit a lint.\n\nHeavily cribs from: https://github.com/rust-lang/rust-clippy/pull/5439\n\nchangelog: introduce the await_holding_refcell_ref lint", "tree": {"sha": "2a594e36ce0565c071f6245424798410d6089764", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a594e36ce0565c071f6245424798410d6089764"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "html_url": "https://github.com/rust-lang/rust/commit/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b06856eae0fade6e2eaaaad7ab289069ddb6f037", "url": "https://api.github.com/repos/rust-lang/rust/commits/b06856eae0fade6e2eaaaad7ab289069ddb6f037", "html_url": "https://github.com/rust-lang/rust/commit/b06856eae0fade6e2eaaaad7ab289069ddb6f037"}, {"sha": "4d3322525d9b65ce4c6fc183bc1cd3cfc9477300", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300", "html_url": "https://github.com/rust-lang/rust/commit/4d3322525d9b65ce4c6fc183bc1cd3cfc9477300"}], "stats": {"total": 266, "additions": 257, "deletions": 9}, "files": [{"sha": "1d995cc9701b2cb845471c126cd6c0badcc7c660", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "patch": "@@ -1632,6 +1632,7 @@ Released 2018-09-13\n [`assign_ops`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_ops\n [`async_yields_async`]: https://rust-lang.github.io/rust-clippy/master/index.html#async_yields_async\n [`await_holding_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_lock\n+[`await_holding_refcell_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_refcell_ref\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n [`bind_instead_of_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#bind_instead_of_map\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name"}, {"sha": "fcebb54c6c217840d3b5a2b7faa8f1249dc72a29", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "renamed", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "patch": "@@ -45,13 +45,52 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub AWAIT_HOLDING_LOCK,\n-    pedantic,\n+    correctness,\n     \"Inside an async function, holding a MutexGuard while calling await\"\n }\n \n-declare_lint_pass!(AwaitHoldingLock => [AWAIT_HOLDING_LOCK]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to await while holding a\n+    /// `RefCell` `Ref` or `RefMut`.\n+    ///\n+    /// **Why is this bad?** `RefCell` refs only check for exclusive mutable access\n+    /// at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n+    /// risks panics from a mutable ref shared while other refs are outstanding.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// use std::cell::RefCell;\n+    ///\n+    /// async fn foo(x: &RefCell<u32>) {\n+    ///   let b = x.borrow_mut()();\n+    ///   *ref += 1;\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// use std::cell::RefCell;\n+    ///\n+    /// async fn foo(x: &RefCell<u32>) {\n+    ///   {\n+    ///     let b = x.borrow_mut();\n+    ///     *ref += 1;\n+    ///   }\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    pub AWAIT_HOLDING_REFCELL_REF,\n+    correctness,\n+    \"Inside an async function, holding a RefCell ref while calling await\"\n+}\n \n-impl LateLintPass<'_> for AwaitHoldingLock {\n+declare_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF]);\n+\n+impl LateLintPass<'_> for AwaitHolding {\n     fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n         use AsyncGeneratorKind::{Block, Closure, Fn};\n         if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n@@ -78,6 +117,16 @@ fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorType\n                     \"these are all the await points this lock is held through\",\n                 );\n             }\n+            if is_refcell_ref(cx, adt.did) {\n+                span_lint_and_note(\n+                        cx,\n+                        AWAIT_HOLDING_REFCELL_REF,\n+                        ty_cause.span,\n+                        \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\",\n+                        ty_cause.scope_span.or(Some(span)),\n+                        \"these are all the await points this ref is held through\",\n+                    );\n+            }\n         }\n     }\n }\n@@ -90,3 +139,7 @@ fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)\n }\n+\n+fn is_refcell_ref(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+    match_def_path(cx, def_id, &paths::REFCELL_REF) || match_def_path(cx, def_id, &paths::REFCELL_REFMUT)\n+}", "previous_filename": "clippy_lints/src/await_holding_lock.rs"}, {"sha": "8d53b9799f0e949996822d5fd2b7a77e9103afa5", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "patch": "@@ -160,7 +160,7 @@ mod assign_ops;\n mod async_yields_async;\n mod atomic_ordering;\n mod attrs;\n-mod await_holding_lock;\n+mod await_holding_invalid;\n mod bit_mask;\n mod blacklisted_name;\n mod blocks_in_if_conditions;\n@@ -509,7 +509,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &attrs::MISMATCHED_TARGET_OS,\n         &attrs::UNKNOWN_CLIPPY_LINTS,\n         &attrs::USELESS_ATTRIBUTE,\n-        &await_holding_lock::AWAIT_HOLDING_LOCK,\n+        &await_holding_invalid::AWAIT_HOLDING_LOCK,\n+        &await_holding_invalid::AWAIT_HOLDING_REFCELL_REF,\n         &bit_mask::BAD_BIT_MASK,\n         &bit_mask::INEFFECTIVE_BIT_MASK,\n         &bit_mask::VERBOSE_BIT_MASK,\n@@ -906,7 +907,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n \n-    store.register_late_pass(|| box await_holding_lock::AwaitHoldingLock);\n+    store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n     store.register_late_pass(|| box serde_api::SerdeAPI);\n     store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n     store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n@@ -1190,7 +1191,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n         LintId::of(&attrs::INLINE_ALWAYS),\n-        LintId::of(&await_holding_lock::AWAIT_HOLDING_LOCK),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::MATCH_SAME_ARMS),\n@@ -1290,6 +1290,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::MISMATCHED_TARGET_OS),\n         LintId::of(&attrs::UNKNOWN_CLIPPY_LINTS),\n         LintId::of(&attrs::USELESS_ATTRIBUTE),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_LOCK),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n         LintId::of(&bit_mask::BAD_BIT_MASK),\n         LintId::of(&bit_mask::INEFFECTIVE_BIT_MASK),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n@@ -1736,6 +1738,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::DEPRECATED_SEMVER),\n         LintId::of(&attrs::MISMATCHED_TARGET_OS),\n         LintId::of(&attrs::USELESS_ATTRIBUTE),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_LOCK),\n+        LintId::of(&await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n         LintId::of(&bit_mask::BAD_BIT_MASK),\n         LintId::of(&bit_mask::INEFFECTIVE_BIT_MASK),\n         LintId::of(&booleans::LOGIC_BUG),"}, {"sha": "cd9b92efe58373bf7996d0fdd8d9b63233289089", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "patch": "@@ -93,6 +93,8 @@ pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n+pub const REFCELL_REF: [&str; 3] = [\"core\", \"cell\", \"Ref\"];\n+pub const REFCELL_REFMUT: [&str; 3] = [\"core\", \"cell\", \"RefMut\"];\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];"}, {"sha": "98ad994ea7b0e428c08c3c2592b7274185f7f6af", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "patch": "@@ -62,10 +62,17 @@ vec![\n     },\n     Lint {\n         name: \"await_holding_lock\",\n-        group: \"pedantic\",\n+        group: \"correctness\",\n         desc: \"Inside an async function, holding a MutexGuard while calling await\",\n         deprecation: None,\n-        module: \"await_holding_lock\",\n+        module: \"await_holding_invalid\",\n+    },\n+    Lint {\n+        name: \"await_holding_refcell_ref\",\n+        group: \"correctness\",\n+        desc: \"Inside an async function, holding a RefCell ref while calling await\",\n+        deprecation: None,\n+        module: \"await_holding_invalid\",\n     },\n     Lint {\n         name: \"bad_bit_mask\","}, {"sha": "88841597bb60bf5bc8a8bff346fdfc9391a40cfe", "filename": "tests/ui/await_holding_refcell_ref.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/tests%2Fui%2Fawait_holding_refcell_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/tests%2Fui%2Fawait_holding_refcell_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.rs?ref=a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "patch": "@@ -0,0 +1,86 @@\n+// edition:2018\n+#![warn(clippy::await_holding_refcell_ref)]\n+\n+use std::cell::RefCell;\n+\n+async fn bad(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow();\n+    baz().await\n+}\n+\n+async fn bad_mut(x: &RefCell<u32>) -> u32 {\n+    let b = x.borrow_mut();\n+    baz().await\n+}\n+\n+async fn good(x: &RefCell<u32>) -> u32 {\n+    {\n+        let b = x.borrow_mut();\n+        let y = *b + 1;\n+    }\n+    baz().await;\n+    let b = x.borrow_mut();\n+    47\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+async fn also_bad(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn less_bad(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let b = x.borrow_mut();\n+\n+    let second = baz().await;\n+\n+    drop(b);\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn not_good(x: &RefCell<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let second = {\n+        let b = x.borrow_mut();\n+        baz().await\n+    };\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+#[allow(clippy::manual_async_fn)]\n+fn block_bad(x: &RefCell<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+    async move {\n+        let b = x.borrow_mut();\n+        baz().await\n+    }\n+}\n+\n+fn main() {\n+    let rc = RefCell::new(100);\n+    good(&rc);\n+    bad(&rc);\n+    bad_mut(&rc);\n+    also_bad(&rc);\n+    less_bad(&rc);\n+    not_good(&rc);\n+    block_bad(&rc);\n+}"}, {"sha": "b504f0454913634969cb11a6ced5b3fc5e9fb2f9", "filename": "tests/ui/await_holding_refcell_ref.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a675778cfb3623a5b4c0b04946ef9ada2a1b5b07/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.stderr?ref=a675778cfb3623a5b4c0b04946ef9ada2a1b5b07", "patch": "@@ -0,0 +1,95 @@\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:7:9\n+   |\n+LL |     let b = x.borrow();\n+   |         ^\n+   |\n+   = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:7:5\n+   |\n+LL | /     let b = x.borrow();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:12:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:12:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:33:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:33:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:45:9\n+   |\n+LL |     let b = x.borrow_mut();\n+   |         ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:45:5\n+   |\n+LL | /     let b = x.borrow_mut();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:60:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:60:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     };\n+   | |_____^\n+\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+  --> $DIR/await_holding_refcell_ref.rs:72:13\n+   |\n+LL |         let b = x.borrow_mut();\n+   |             ^\n+   |\n+note: these are all the await points this ref is held through\n+  --> $DIR/await_holding_refcell_ref.rs:72:9\n+   |\n+LL | /         let b = x.borrow_mut();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 6 previous errors\n+"}]}