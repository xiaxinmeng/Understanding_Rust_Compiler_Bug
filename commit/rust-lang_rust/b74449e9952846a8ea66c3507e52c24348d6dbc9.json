{"sha": "b74449e9952846a8ea66c3507e52c24348d6dbc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NDQ0OWU5OTUyODQ2YThlYTY2YzM1MDdlNTJjMjQzNDhkNmRiYzk=", "commit": {"author": {"name": "Sergey Parilin", "email": "Sergey.Parilin@fxdd.com", "date": "2019-04-02T14:55:14Z"}, "committer": {"name": "Sergey Parilin", "email": "Sergey.Parilin@fxdd.com", "date": "2019-04-02T14:55:14Z"}, "message": "Merge remote-tracking branch 'upstream/master' into issue961_profiling", "tree": {"sha": "00bb1101334b0bf1b189a2e6451cb28e0af959a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00bb1101334b0bf1b189a2e6451cb28e0af959a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b74449e9952846a8ea66c3507e52c24348d6dbc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b74449e9952846a8ea66c3507e52c24348d6dbc9", "html_url": "https://github.com/rust-lang/rust/commit/b74449e9952846a8ea66c3507e52c24348d6dbc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b74449e9952846a8ea66c3507e52c24348d6dbc9/comments", "author": null, "committer": null, "parents": [{"sha": "9b73f809596e955216dde24fcf921d6985a1a767", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b73f809596e955216dde24fcf921d6985a1a767", "html_url": "https://github.com/rust-lang/rust/commit/9b73f809596e955216dde24fcf921d6985a1a767"}, {"sha": "849d7428aa6b733d452b2ebc55ec322d96345f49", "url": "https://api.github.com/repos/rust-lang/rust/commits/849d7428aa6b733d452b2ebc55ec322d96345f49", "html_url": "https://github.com/rust-lang/rust/commit/849d7428aa6b733d452b2ebc55ec322d96345f49"}], "stats": {"total": 3123, "additions": 1943, "deletions": 1180}, "files": [{"sha": "6699771635bb81adbfc9992c0ecfe7242bacef35", "filename": "Cargo.lock", "status": "modified", "additions": 46, "deletions": 67, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -76,15 +76,15 @@ dependencies = [\n \n [[package]]\n name = \"bit-set\"\n-version = \"0.5.0\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"bit-vec 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bit-vec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"bit-vec\"\n-version = \"0.5.0\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -118,7 +118,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.7.3\"\n+version = \"0.7.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -359,11 +359,11 @@ dependencies = [\n \n [[package]]\n name = \"flexi_logger\"\n-version = \"0.11.1\"\n+version = \"0.11.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -443,6 +443,11 @@ name = \"glob\"\n version = \"0.2.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"glob\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"heck\"\n version = \"0.3.1\"\n@@ -503,7 +508,7 @@ dependencies = [\n \n [[package]]\n name = \"insta\"\n-version = \"0.7.1\"\n+version = \"0.7.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -518,7 +523,7 @@ dependencies = [\n  \"serde 1.0.89 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_yaml 0.8.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"uuid 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"uuid 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -589,9 +594,6 @@ dependencies = [\n name = \"lazy_static\"\n version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"spin 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"lazycell\"\n@@ -605,7 +607,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"linked-hash-map\"\n-version = \"0.5.1\"\n+version = \"0.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -855,10 +857,10 @@ dependencies = [\n \n [[package]]\n name = \"proptest\"\n-version = \"0.9.1\"\n+version = \"0.9.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"bit-set 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bit-set 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -911,7 +913,7 @@ dependencies = [\n  \"ra_hir 0.1.0\",\n  \"ra_project_model 0.1.0\",\n  \"ra_syntax 0.1.0\",\n- \"ra_vfs 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_vfs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n@@ -922,14 +924,13 @@ version = \"0.1.0\"\n dependencies = [\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.11.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.11.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"indicatif 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_batch 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_hir 0.1.0\",\n  \"ra_ide_api 0.1.0\",\n- \"ra_ide_api_light 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"tools 0.1.0\",\n@@ -944,7 +945,7 @@ dependencies = [\n  \"ra_syntax 0.1.0\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"salsa 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"salsa 0.11.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n \n@@ -962,8 +963,8 @@ version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.11.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"insta 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.11.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"insta 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -983,19 +984,18 @@ name = \"ra_ide_api\"\n version = \"0.1.0\"\n dependencies = [\n  \"fst 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"insta 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"insta 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jemalloc-ctl 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jemallocator 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proptest 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proptest 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_assists 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_fmt 0.1.0\",\n  \"ra_hir 0.1.0\",\n- \"ra_ide_api_light 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n  \"rayon 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1006,30 +1006,14 @@ dependencies = [\n  \"unicase 2.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"ra_ide_api_light\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"insta 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"proptest 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ra_fmt 0.1.0\",\n- \"ra_syntax 0.1.0\",\n- \"ra_text_edit 0.1.0\",\n- \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"superslice 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"test_utils 0.1.0\",\n-]\n-\n [[package]]\n name = \"ra_lsp_server\"\n version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.11.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.11.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gen_lsp_server 0.1.0\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lsp-types 0.56.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1040,7 +1024,7 @@ dependencies = [\n  \"ra_project_model 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"ra_vfs 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_vfs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.89 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1080,7 +1064,7 @@ dependencies = [\n name = \"ra_project_model\"\n version = \"0.1.0\"\n dependencies = [\n- \"cargo_metadata 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo_metadata 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n@@ -1115,7 +1099,7 @@ dependencies = [\n name = \"ra_text_edit\"\n version = \"0.1.0\"\n dependencies = [\n- \"proptest 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proptest 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"text_unit 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1129,7 +1113,7 @@ dependencies = [\n \n [[package]]\n name = \"ra_vfs\"\n-version = \"0.2.0\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1361,7 +1345,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"salsa\"\n-version = \"0.10.0\"\n+version = \"0.11.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1370,13 +1354,13 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"salsa-macros 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"salsa-macros 0.11.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smallvec 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"salsa-macros\"\n-version = \"0.10.0\"\n+version = \"0.11.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1446,7 +1430,7 @@ version = \"0.8.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"linked-hash-map 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"linked-hash-map 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.89 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"yaml-rust 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1488,11 +1472,6 @@ dependencies = [\n  \"serde 1.0.89 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"spin\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"stable_deref_trait\"\n version = \"1.1.1\"\n@@ -1786,7 +1765,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"uuid\"\n-version = \"0.7.2\"\n+version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1864,7 +1843,7 @@ name = \"yaml-rust\"\n version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"linked-hash-map 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"linked-hash-map 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [metadata]\n@@ -1877,14 +1856,14 @@ dependencies = [\n \"checksum backtrace 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cd5a90e2b463010cd0e0ce9a11d4a9d5d58d9f41d4a6ba3dcaf9e68b466e88b4\"\n \"checksum backtrace-sys 0.1.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"797c830ac25ccc92a7f8a7b9862bde440715531514594a6154e3d4a54dd769b6\"\n \"checksum base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0b25d992356d2eb0ed82172f5248873db5560c4721f564b13cb5193bda5e668e\"\n-\"checksum bit-set 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6f1efcc46c18245a69c38fcc5cc650f16d3a59d034f3106e9ed63748f695730a\"\n-\"checksum bit-vec 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4440d5cb623bb7390ae27fec0bb6c61111969860f8e3ae198bfa0663645e67cf\"\n+\"checksum bit-set 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e84c238982c4b1e1ee668d136c510c67a13465279c0cb367ea6baf6310620a80\"\n+\"checksum bit-vec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f59bbe95d4e52a6398ec21238d31577f2b28a9d86807f06ca59d191d8440d0bb\"\n \"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\"\n \"checksum bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"228047a76f468627ca71776ecdebd732a3423081fcf5125585bcd7c49886ce12\"\n \"checksum block-buffer 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a076c298b9ecdb530ed9d967e74a6027d6a7478924520acddcddc24c1c8ab3ab\"\n \"checksum byte-tools 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40\"\n \"checksum byteorder 1.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a019b10a2a7cdeb292db131fc8113e57ea2a908f6e7894b0c3c671893b65dbeb\"\n-\"checksum cargo_metadata 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc796c7161c220089dfc7159e13324979181532850a237576b8fb907dd087c0d\"\n+\"checksum cargo_metadata 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"178d62b240c34223f265a4c1e275e37d62da163d421fc8d7f7e3ee340f803c57\"\n \"checksum cc 1.0.31 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c9ce8bb087aacff865633f0bd5aeaed910fe2fe55b55f4739527f2e023a2e53d\"\n \"checksum cfg-if 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11d43355396e872eefb45ce6342e4374ed7bc2b3a502d1b28e36d6e23c05d1f4\"\n \"checksum chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"45912881121cb26fad7c38c17ba7daa18764771836b34fab7d3fbd93ed633878\"\n@@ -1913,7 +1892,7 @@ dependencies = [\n \"checksum failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n \"checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \"checksum filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a2df5c1a8c4be27e7707789dc42ae65976e60b394afd293d1419ab915833e646\"\n-\"checksum flexi_logger 0.11.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4a7878fc9e06c948c6f9cddf571758e0c44786a509e646a094ef13ade3b1aab7\"\n+\"checksum flexi_logger 0.11.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"005c01dd6942ca46283b7304d14c6d04ec2c87a62f6e62e17c06fb812a574f4a\"\n \"checksum fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n \"checksum fsevent 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4bbbf71584aeed076100b5665ac14e3d85eeb31fdbb45fbd41ef9a682b5ec05\"\n \"checksum fsevent-sys 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1a772d36c338d07a032d5375a36f15f9a7043bf0cb8ce7cee658e037c6032874\"\n@@ -1923,14 +1902,15 @@ dependencies = [\n \"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7\"\n \"checksum generic-array 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef25c5683767570c2bbd7deba372926a55eaae9982d7726ee2a1050239d45b9d\"\n \"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n+\"checksum glob 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574\"\n \"checksum heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n \"checksum humansize 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b6cab2627acfc432780848602f3f558f7e9dd427352224b0d9324025796d2a5e\"\n \"checksum idna 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38f09e0f0b1fb55fdee1f17470ad800da77af5186a1a76c026b679358b7e844e\"\n \"checksum indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d\"\n \"checksum indicatif 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2c60da1c9abea75996b70a931bba6c750730399005b61ccd853cee50ef3d0d0c\"\n \"checksum inotify 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40b54539f3910d6f84fbf9a643efd6e3aa6e4f001426c0329576128255994718\"\n \"checksum inotify-sys 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e74a1aa87c59aeff6ef2cc2fa62d41bc43f54952f55652656b18a02fd5e356c0\"\n-\"checksum insta 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be9f00370d23dc7bd32a4d4506b1a14fb922fa39c576c3300fd25ce5b5dab18f\"\n+\"checksum insta 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"03e7d88a87d342ce8bd698516151be43e6eb2e84b683db528696cb4a382f734a\"\n \"checksum iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbe6e417e7d0975db6512b90796e8ce223145ac4e33c377e4a42882a0e88bb08\"\n \"checksum itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5b8467d9c1cebe26feb08c640139247fac215782d35371ade9a2136ed6085358\"\n \"checksum itoa 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1306f3464951f30e30d12373d31c79fbd52d236e5e896fd92f96ec7babbbe60b\"\n@@ -1942,7 +1922,7 @@ dependencies = [\n \"checksum lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc5729f27f159ddd61f4df6228e827e86643d4d3e7c32183cb30a1c08f604a14\"\n \"checksum lazycell 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \"checksum libc 0.2.50 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aab692d7759f5cd8c859e169db98ae5b52c924add2af5fbbca11d12fefb567c1\"\n-\"checksum linked-hash-map 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"70fb39025bc7cdd76305867c4eccf2f2dcf6e9a57f5b21a93e1c2d86cd03ec9e\"\n+\"checksum linked-hash-map 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae91b68aebc4ddb91978b11a1b02ddd8602a05ec19002801c5666000e05e0f83\"\n \"checksum lock_api 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"62ebf1391f6acad60e5c8b43706dde4582df75c06698ab44511d15016bc2442c\"\n \"checksum log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6\"\n \"checksum lsp-types 0.56.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31954f2cf354421e6f99a48fdcfd5c3113c675a0db311960ffdac0b8d45cf09c\"\n@@ -1970,10 +1950,10 @@ dependencies = [\n \"checksum pest_generator 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"63120576c4efd69615b5537d3d052257328a4ca82876771d6944424ccfd9f646\"\n \"checksum pest_meta 2.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5a3492a4ed208ffc247adcdcc7ba2a95be3104f58877d0d02f0df39bf3efb5e\"\n \"checksum proc-macro2 0.4.27 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4d317f9caece796be1980837fd5cb3dfec5613ebdb04ad0956deea83ce168915\"\n-\"checksum proptest 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8ea66c78d75f2c6e9f304269eaef90899798daecc69f1a625d5a3dd793ff3522\"\n+\"checksum proptest 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"24f5844db2f839e97e3021980975f6ebf8691d9b9b2ca67ed3feb38dc3edb52c\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quote 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdd8e04bd9c52e0342b406469d494fcb033be4bdbe5c606016defbb1681411e1\"\n-\"checksum ra_vfs 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb1839e4e003d865b58b8b6c231aae6c463dfcd01bfbbddffbdb7662a7b5a627\"\n+\"checksum ra_vfs 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d75d08da053ec832676686c72dfe509fdd1e807191a50ac79087466ffefccb1c\"\n \"checksum rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca\"\n \"checksum rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"556d3a1ca6600bfcbab7c7c91ccb085ac7fbbcd70e008a98742e7847f4f7bcef\"\n \"checksum rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b\"\n@@ -1999,8 +1979,8 @@ dependencies = [\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n \"checksum ryu 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb9e9b8cde282a9fe6a42dd4681319bfb63f121b8a8ee9439c6f4107e58a46f7\"\n-\"checksum salsa 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cad0e2348e2f80725b2980914a08a00267136c3ecf720896d3f7f08eef51e08f\"\n-\"checksum salsa-macros 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7c79744109df21b80aef1367669b0a9e4985bc966e76bf0e9321b222ec0b9fbb\"\n+\"checksum salsa 0.11.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94f14bbb013866db2fbeceb97ed82cf35f42020edd39d35268f0b11f89399c79\"\n+\"checksum salsa-macros 0.11.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1ad27cbae189e9739a96e469d37c6a6deafec36f1282d4fdf4681eae67c9dd39\"\n \"checksum same-file 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8f20c4be53a8a1ff4c1f1b2bd14570d2f634628709752f0702ecdd2b3f9a5267\"\n \"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n@@ -2014,7 +1994,6 @@ dependencies = [\n \"checksum slug 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3bc762e6a4b6c6fcaade73e77f9ebc6991b676f88bb2358bddb56560f073373\"\n \"checksum smallvec 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4488ae950c49d403731982257768f48fada354a5203fe81f9bb6f43ca9002be\"\n \"checksum smol_str 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9af1035bc5d742ab6b7ab16713e41cc2ffe78cb474f6f43cd696b2d16052007e\"\n-\"checksum spin 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"44363f6f51401c34e7be73db0db371c04705d35efbe9f7d6082e03a921a32c55\"\n \"checksum stable_deref_trait 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dba1a27d3efae4351c8051072d619e3ade2820635c3958d826bfea39d59b54c8\"\n \"checksum strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550\"\n \"checksum superslice 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n@@ -2048,7 +2027,7 @@ dependencies = [\n \"checksum url 1.7.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd4e7c0d531266369519a4aa4f399d748bd37043b00bde1e4ff1f60a120b355a\"\n \"checksum url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74e7d099f1ee52f823d4bdd60c93c3602043c728f5db3b97bdb548467f7bddea\"\n \"checksum utf8-ranges 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"796f7e48bef87609f7ade7e06495a87d5cd06c7866e6a5cbfceffc558a243737\"\n-\"checksum uuid 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0238db0c5b605dd1cf51de0f21766f97fba2645897024461d6a00c036819a768\"\n+\"checksum uuid 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"600ef8213e9f8a0ac1f876e470e90780ae0478eabce7f76aff41b0f4ef0fd5c0\"\n \"checksum vec_map 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a\"\n \"checksum version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\"\n \"checksum walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9d9d7ed3431229a144296213105a390676cc49c9b6a72bd19f3176c98e129fa1\""}, {"sha": "8df99124672693d12c48467d580ebbb4eceafc4b", "filename": "README.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -51,6 +51,12 @@ We are on the rust-lang Zulip!\n \n https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frls-2.2E0\n \n+## Quick Links\n+\n+* Work List: https://paper.dropbox.com/doc/RLS-2.0-work-list--AZ3BgHKKCtqszbsi3gi6sjchAQ-42vbnxzuKq2lKwW0mkn8Y\n+* API docs: https://rust-analyzer.github.io/rust-analyzer/ra_ide_api/index.html\n+* CI: https://travis-ci.org/rust-analyzer/rust-analyzer\n+\n ## License\n \n Rust analyzer is primarily distributed under the terms of both the MIT"}, {"sha": "ec377642e022ee1223340a7f4d2088ea98f6e59e", "filename": "crates/ra_assists/src/flip_binexpr.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -0,0 +1,141 @@\n+use hir::db::HirDatabase;\n+use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n+\n+use crate::{AssistCtx, Assist, AssistId};\n+\n+/// Flip binary expression assist.\n+pub(crate) fn flip_binexpr(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let expr = ctx.node_at_offset::<BinExpr>()?;\n+    let lhs = expr.lhs()?.syntax();\n+    let rhs = expr.rhs()?.syntax();\n+    let op_range = expr.op()?.range();\n+    // The assist should be applied only if the cursor is on the operator\n+    let cursor_in_range = ctx.frange.range.is_subrange(&op_range);\n+    if !cursor_in_range {\n+        return None;\n+    }\n+    let action: FlipAction = expr.op_kind()?.into();\n+    // The assist should not be applied for certain operators\n+    if let FlipAction::DontFlip = action {\n+        return None;\n+    }\n+\n+    ctx.add_action(AssistId(\"flip_binexpr\"), \"flip binary expression\", |edit| {\n+        edit.target(op_range);\n+        if let FlipAction::FlipAndReplaceOp(new_op) = action {\n+            edit.replace(op_range, new_op);\n+        }\n+        edit.replace(lhs.range(), rhs.text());\n+        edit.replace(rhs.range(), lhs.text());\n+    });\n+\n+    ctx.build()\n+}\n+\n+enum FlipAction {\n+    // Flip the expression\n+    Flip,\n+    // Flip the expression and replace the operator with this string\n+    FlipAndReplaceOp(&'static str),\n+    // Do not flip the expression\n+    DontFlip,\n+}\n+\n+impl From<BinOp> for FlipAction {\n+    fn from(op_kind: BinOp) -> Self {\n+        match op_kind {\n+            BinOp::Assignment => FlipAction::DontFlip,\n+            BinOp::AddAssign => FlipAction::DontFlip,\n+            BinOp::DivAssign => FlipAction::DontFlip,\n+            BinOp::MulAssign => FlipAction::DontFlip,\n+            BinOp::RemAssign => FlipAction::DontFlip,\n+            BinOp::ShrAssign => FlipAction::DontFlip,\n+            BinOp::ShlAssign => FlipAction::DontFlip,\n+            BinOp::SubAssign => FlipAction::DontFlip,\n+            BinOp::BitOrAssign => FlipAction::DontFlip,\n+            BinOp::BitAndAssign => FlipAction::DontFlip,\n+            BinOp::BitXorAssign => FlipAction::DontFlip,\n+            BinOp::GreaterTest => FlipAction::FlipAndReplaceOp(\"<\"),\n+            BinOp::GreaterEqualTest => FlipAction::FlipAndReplaceOp(\"<=\"),\n+            BinOp::LesserTest => FlipAction::FlipAndReplaceOp(\">\"),\n+            BinOp::LesserEqualTest => FlipAction::FlipAndReplaceOp(\">=\"),\n+            _ => FlipAction::Flip,\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::helpers::{ check_assist, check_assist_target, check_assist_not_applicable };\n+\n+    #[test]\n+    fn flip_binexpr_target_is_the_op() {\n+        check_assist_target(flip_binexpr, \"fn f() { let res = 1 ==<|> 2; }\", \"==\")\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_not_applicable_for_assignment() {\n+        check_assist_not_applicable(flip_binexpr, \"fn f() { let mut _x = 1; _x +=<|> 2 }\")\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_works_for_eq() {\n+        check_assist(\n+            flip_binexpr,\n+            \"fn f() { let res = 1 ==<|> 2; }\",\n+            \"fn f() { let res = 2 ==<|> 1; }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_works_for_gt() {\n+        check_assist(\n+            flip_binexpr,\n+            \"fn f() { let res = 1 ><|> 2; }\",\n+            \"fn f() { let res = 2 <<|> 1; }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_works_for_lteq() {\n+        check_assist(\n+            flip_binexpr,\n+            \"fn f() { let res = 1 <=<|> 2; }\",\n+            \"fn f() { let res = 2 >=<|> 1; }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_works_for_complex_expr() {\n+        check_assist(\n+            flip_binexpr,\n+            \"fn f() { let res = (1 + 1) ==<|> (2 + 2); }\",\n+            \"fn f() { let res = (2 + 2) ==<|> (1 + 1); }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_works_inside_match() {\n+        check_assist(\n+            flip_binexpr,\n+            r#\"\n+            fn dyn_eq(&self, other: &dyn Diagnostic) -> bool {\n+                match other.downcast_ref::<Self>() {\n+                    None => false,\n+                    Some(it) => it ==<|> self,\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn dyn_eq(&self, other: &dyn Diagnostic) -> bool {\n+                match other.downcast_ref::<Self>() {\n+                    None => false,\n+                    Some(it) => self ==<|> it,\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+}"}, {"sha": "df0bb689da55e5614d565846c8b694391de38ae1", "filename": "crates/ra_assists/src/flip_eq_operands.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9b73f809596e955216dde24fcf921d6985a1a767/crates%2Fra_assists%2Fsrc%2Fflip_eq_operands.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b73f809596e955216dde24fcf921d6985a1a767/crates%2Fra_assists%2Fsrc%2Fflip_eq_operands.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_eq_operands.rs?ref=9b73f809596e955216dde24fcf921d6985a1a767", "patch": "@@ -1,86 +0,0 @@\n-use hir::db::HirDatabase;\n-use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n-\n-use crate::{AssistCtx, Assist, AssistId};\n-\n-pub(crate) fn flip_eq_operands(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let expr = ctx.node_at_offset::<BinExpr>()?;\n-    let lhs = expr.lhs()?.syntax();\n-    let rhs = expr.rhs()?.syntax();\n-    let op_range = expr.op()?.range();\n-    let cursor_in_range = ctx.frange.range.is_subrange(&op_range);\n-    let allowed_ops = [BinOp::EqualityTest, BinOp::NegatedEqualityTest];\n-    let expr_op = expr.op_kind()?;\n-    if !cursor_in_range || !allowed_ops.iter().any(|o| *o == expr_op) {\n-        return None;\n-    }\n-    ctx.add_action(AssistId(\"flip_eq_operands\"), \"flip equality operands\", |edit| {\n-        edit.target(op_range);\n-        edit.replace(lhs.range(), rhs.text());\n-        edit.replace(rhs.range(), lhs.text());\n-    });\n-\n-    ctx.build()\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use crate::helpers::{check_assist, check_assist_target};\n-\n-    #[test]\n-    fn flip_eq_operands_for_simple_stmt() {\n-        check_assist(\n-            flip_eq_operands,\n-            \"fn f() { let res = 1 ==<|> 2; }\",\n-            \"fn f() { let res = 2 ==<|> 1; }\",\n-        )\n-    }\n-\n-    #[test]\n-    fn flip_neq_operands_for_simple_stmt() {\n-        check_assist(\n-            flip_eq_operands,\n-            \"fn f() { let res = 1 !=<|> 2; }\",\n-            \"fn f() { let res = 2 !=<|> 1; }\",\n-        )\n-    }\n-\n-    #[test]\n-    fn flip_eq_operands_for_complex_stmt() {\n-        check_assist(\n-            flip_eq_operands,\n-            \"fn f() { let res = (1 + 1) ==<|> (2 + 2); }\",\n-            \"fn f() { let res = (2 + 2) ==<|> (1 + 1); }\",\n-        )\n-    }\n-\n-    #[test]\n-    fn flip_eq_operands_in_match_expr() {\n-        check_assist(\n-            flip_eq_operands,\n-            r#\"\n-            fn dyn_eq(&self, other: &dyn Diagnostic) -> bool {\n-                match other.downcast_ref::<Self>() {\n-                    None => false,\n-                    Some(it) => it ==<|> self,\n-                }\n-            }\n-            \"#,\n-            r#\"\n-            fn dyn_eq(&self, other: &dyn Diagnostic) -> bool {\n-                match other.downcast_ref::<Self>() {\n-                    None => false,\n-                    Some(it) => self ==<|> it,\n-                }\n-            }\n-            \"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn flip_eq_operands_target() {\n-        check_assist_target(flip_eq_operands, \"fn f() { let res = 1 ==<|> 2; }\", \"==\")\n-    }\n-}"}, {"sha": "bd3cdb970c751ef27d3ed1c54696a7a32c8aa9a8", "filename": "crates/ra_assists/src/inline_local_variable.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -0,0 +1,298 @@\n+use hir::db::HirDatabase;\n+use hir::source_binder::function_from_child_node;\n+use ra_syntax::{ast::{self, AstNode}, TextRange};\n+use ra_syntax::ast::{PatKind, ExprKind};\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+use crate::assist_ctx::AssistBuilder;\n+\n+pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let let_stmt = ctx.node_at_offset::<ast::LetStmt>()?;\n+    let bind_pat = match let_stmt.pat()?.kind() {\n+        PatKind::BindPat(pat) => pat,\n+        _ => return None,\n+    };\n+    if bind_pat.is_mutable() {\n+        return None;\n+    }\n+    let initializer = let_stmt.initializer()?;\n+    let wrap_in_parens = match initializer.kind() {\n+        ExprKind::LambdaExpr(_)\n+        | ExprKind::IfExpr(_)\n+        | ExprKind::LoopExpr(_)\n+        | ExprKind::ForExpr(_)\n+        | ExprKind::WhileExpr(_)\n+        | ExprKind::ContinueExpr(_)\n+        | ExprKind::BreakExpr(_)\n+        | ExprKind::Label(_)\n+        | ExprKind::ReturnExpr(_)\n+        | ExprKind::MatchExpr(_)\n+        | ExprKind::StructLit(_)\n+        | ExprKind::CastExpr(_)\n+        | ExprKind::PrefixExpr(_)\n+        | ExprKind::RangeExpr(_)\n+        | ExprKind::BinExpr(_) => true,\n+        ExprKind::CallExpr(_)\n+        | ExprKind::IndexExpr(_)\n+        | ExprKind::MethodCallExpr(_)\n+        | ExprKind::FieldExpr(_)\n+        | ExprKind::TryExpr(_)\n+        | ExprKind::RefExpr(_)\n+        | ExprKind::Literal(_)\n+        | ExprKind::TupleExpr(_)\n+        | ExprKind::ArrayExpr(_)\n+        | ExprKind::ParenExpr(_)\n+        | ExprKind::PathExpr(_)\n+        | ExprKind::BlockExpr(_) => false,\n+    };\n+\n+    let delete_range = if let Some(whitespace) =\n+        let_stmt.syntax().next_sibling().and_then(ast::Whitespace::cast)\n+    {\n+        TextRange::from_to(let_stmt.syntax().range().start(), whitespace.syntax().range().end())\n+    } else {\n+        let_stmt.syntax().range()\n+    };\n+\n+    let init_str = if wrap_in_parens {\n+        format!(\"({})\", initializer.syntax().text().to_string())\n+    } else {\n+        initializer.syntax().text().to_string()\n+    };\n+    let function = function_from_child_node(ctx.db, ctx.frange.file_id, bind_pat.syntax())?;\n+    let scope = function.scopes(ctx.db);\n+    let refs = scope.find_all_refs(bind_pat);\n+\n+    ctx.add_action(\n+        AssistId(\"inline_local_variable\"),\n+        \"inline local variable\",\n+        move |edit: &mut AssistBuilder| {\n+            edit.delete(delete_range);\n+            for desc in refs {\n+                edit.replace(desc.range, init_str.clone())\n+            }\n+            edit.set_cursor(delete_range.start())\n+        },\n+    );\n+\n+    ctx.build()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_inline_let_bind_literal_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn bar(a: usize) {}\n+fn foo() {\n+    let a<|> = 1;\n+    a + 1;\n+    if a > 10 {\n+    }\n+\n+    while a > 10 {\n+\n+    }\n+    let b = a * 10;\n+    bar(a);\n+}\",\n+            \"\n+fn bar(a: usize) {}\n+fn foo() {\n+    <|>1 + 1;\n+    if 1 > 10 {\n+    }\n+\n+    while 1 > 10 {\n+\n+    }\n+    let b = 1 * 10;\n+    bar(1);\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_inline_let_bind_bin_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn bar(a: usize) {}\n+fn foo() {\n+    let a<|> = 1 + 1;\n+    a + 1;\n+    if a > 10 {\n+    }\n+\n+    while a > 10 {\n+\n+    }\n+    let b = a * 10;\n+    bar(a);\n+}\",\n+            \"\n+fn bar(a: usize) {}\n+fn foo() {\n+    <|>(1 + 1) + 1;\n+    if (1 + 1) > 10 {\n+    }\n+\n+    while (1 + 1) > 10 {\n+\n+    }\n+    let b = (1 + 1) * 10;\n+    bar((1 + 1));\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_inline_let_bind_function_call_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn bar(a: usize) {}\n+fn foo() {\n+    let a<|> = bar(1);\n+    a + 1;\n+    if a > 10 {\n+    }\n+\n+    while a > 10 {\n+\n+    }\n+    let b = a * 10;\n+    bar(a);\n+}\",\n+            \"\n+fn bar(a: usize) {}\n+fn foo() {\n+    <|>bar(1) + 1;\n+    if bar(1) > 10 {\n+    }\n+\n+    while bar(1) > 10 {\n+\n+    }\n+    let b = bar(1) * 10;\n+    bar(bar(1));\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_inline_let_bind_cast_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn bar(a: usize): usize { a }\n+fn foo() {\n+    let a<|> = bar(1) as u64;\n+    a + 1;\n+    if a > 10 {\n+    }\n+\n+    while a > 10 {\n+\n+    }\n+    let b = a * 10;\n+    bar(a);\n+}\",\n+            \"\n+fn bar(a: usize): usize { a }\n+fn foo() {\n+    <|>(bar(1) as u64) + 1;\n+    if (bar(1) as u64) > 10 {\n+    }\n+\n+    while (bar(1) as u64) > 10 {\n+\n+    }\n+    let b = (bar(1) as u64) * 10;\n+    bar((bar(1) as u64));\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_inline_let_bind_block_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = { 10 + 1 };\n+    a + 1;\n+    if a > 10 {\n+    }\n+\n+    while a > 10 {\n+\n+    }\n+    let b = a * 10;\n+    bar(a);\n+}\",\n+            \"\n+fn foo() {\n+    <|>{ 10 + 1 } + 1;\n+    if { 10 + 1 } > 10 {\n+    }\n+\n+    while { 10 + 1 } > 10 {\n+\n+    }\n+    let b = { 10 + 1 } * 10;\n+    bar({ 10 + 1 });\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_inline_let_bind_paren_expr() {\n+        check_assist(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let a<|> = ( 10 + 1 );\n+    a + 1;\n+    if a > 10 {\n+    }\n+\n+    while a > 10 {\n+\n+    }\n+    let b = a * 10;\n+    bar(a);\n+}\",\n+            \"\n+fn foo() {\n+    <|>( 10 + 1 ) + 1;\n+    if ( 10 + 1 ) > 10 {\n+    }\n+\n+    while ( 10 + 1 ) > 10 {\n+\n+    }\n+    let b = ( 10 + 1 ) * 10;\n+    bar(( 10 + 1 ));\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_not_inline_mut_variable() {\n+        check_assist_not_applicable(\n+            inline_local_varialbe,\n+            \"\n+fn foo() {\n+    let mut a<|> = 1 + 1;\n+    a + 1;\n+}\",\n+        );\n+    }\n+}"}, {"sha": "c1514f8e5237ced832f627d3950657651af84438", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -88,11 +88,12 @@ where\n mod add_derive;\n mod add_impl;\n mod flip_comma;\n-mod flip_eq_operands;\n+mod flip_binexpr;\n mod change_visibility;\n mod fill_match_arms;\n mod fill_struct_fields;\n mod introduce_variable;\n+mod inline_local_variable;\n mod replace_if_let_with_match;\n mod split_import;\n mod remove_dbg;\n@@ -107,14 +108,15 @@ fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assis\n         fill_match_arms::fill_match_arms,\n         fill_struct_fields::fill_struct_fields,\n         flip_comma::flip_comma,\n-        flip_eq_operands::flip_eq_operands,\n+        flip_binexpr::flip_binexpr,\n         introduce_variable::introduce_variable,\n         replace_if_let_with_match::replace_if_let_with_match,\n         split_import::split_import,\n         remove_dbg::remove_dbg,\n         auto_import::auto_import,\n         add_missing_impl_members::add_missing_impl_members,\n         add_missing_impl_members::add_missing_default_members,\n+        inline_local_variable::inline_local_varialbe,\n     ]\n }\n "}, {"sha": "328b2436f67cb5a9225edc24eef518fdda3e5916", "filename": "crates/ra_cli/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2FCargo.toml?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -14,7 +14,6 @@ indicatif = \"0.11.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_ide_api = { path = \"../ra_ide_api\" }\n-ra_ide_api_light = { path = \"../ra_ide_api_light\" }\n tools = { path = \"../tools\" }\n ra_batch = { path = \"../ra_batch\" }\n ra_hir = { path = \"../ra_hir\" }"}, {"sha": "ecea516f1f6e387037314507a702fab14feb0c22", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -5,7 +5,7 @@ use std::{fs, io::Read, path::Path};\n use clap::{App, Arg, SubCommand};\n use join_to_string::join;\n use ra_ide_api::{Analysis, FileRange};\n-use ra_ide_api_light::file_structure;\n+use ra_ide_api::file_structure;\n use ra_syntax::{SourceFile, TextRange, TreeArc, AstNode};\n use tools::collect_tests;\n use flexi_logger::Logger;"}, {"sha": "581cd32fdfd870e064f5230f471d470b2f61351f", "filename": "crates/ra_db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -5,7 +5,7 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n-salsa = \"0.10.0\"\n+salsa = \"0.11.1\"\n relative-path = \"0.4.0\"\n rustc-hash = \"1.0\"\n parking_lot = \"0.7.0\""}, {"sha": "624c25c4d6f3cbafbff772e49c0a8d49438abcfa", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -1,8 +1,7 @@\n use std::sync::Arc;\n \n-use relative_path::RelativePathBuf;\n use ra_db::{CrateId, SourceRootId, Edition};\n-use ra_syntax::{ast::self, TreeArc, SyntaxNode};\n+use ra_syntax::{ast::self, TreeArc};\n \n use crate::{\n     Name, ScopesWithSourceMap, Ty, HirFileId,\n@@ -14,9 +13,11 @@ use crate::{\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::GenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n-    ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeId},\n+    ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeAliasId},\n     impl_block::ImplBlock,\n     resolve::Resolver,\n+    diagnostics::DiagnosticSink,\n+    traits::{TraitItem, TraitData},\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -95,11 +96,6 @@ pub enum ModuleSource {\n     Module(TreeArc<ast::Module>),\n }\n \n-#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Problem {\n-    UnresolvedModule { candidate: RelativePathBuf },\n-}\n-\n impl Module {\n     /// Name of this module.\n     pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n@@ -171,8 +167,24 @@ impl Module {\n         db.crate_def_map(self.krate)[self.module_id].scope.clone()\n     }\n \n-    pub fn problems(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        self.problems_impl(db)\n+    pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n+        db.crate_def_map(self.krate).add_diagnostics(db, self.module_id, sink);\n+        for decl in self.declarations(db) {\n+            match decl {\n+                crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n+                crate::ModuleDef::Module(f) => f.diagnostics(db, sink),\n+                _ => (),\n+            }\n+        }\n+\n+        for impl_block in self.impl_blocks(db) {\n+            for item in impl_block.items(db) {\n+                match item {\n+                    crate::ImplItem::Method(f) => f.diagnostics(db, sink),\n+                    _ => (),\n+                }\n+            }\n+        }\n     }\n \n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n@@ -519,6 +531,10 @@ impl Function {\n         let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n         r\n     }\n+\n+    pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n+        self.infer(db).add_diagnostics(db, *self, sink);\n+    }\n }\n \n impl Docs for Function {\n@@ -634,6 +650,18 @@ impl Trait {\n     pub fn generic_params(&self, db: &impl DefDatabase) -> Arc<GenericParams> {\n         db.generic_params((*self).into())\n     }\n+\n+    pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n+        self.trait_data(db).name().clone()\n+    }\n+\n+    pub fn items(self, db: &impl DefDatabase) -> Vec<TraitItem> {\n+        self.trait_data(db).items().to_vec()\n+    }\n+\n+    pub(crate) fn trait_data(self, db: &impl DefDatabase) -> Arc<TraitData> {\n+        db.trait_data(self)\n+    }\n }\n \n impl Docs for Trait {\n@@ -644,7 +672,7 @@ impl Docs for Trait {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAlias {\n-    pub(crate) id: TypeId,\n+    pub(crate) id: TypeAliasId,\n }\n \n impl TypeAlias {"}, {"sha": "0edb8ade5b39a1209c35c02ed7f4b32da78f4902", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -1,27 +1,26 @@\n use ra_db::FileId;\n-use ra_syntax::{ast, SyntaxNode, TreeArc, AstNode};\n+use ra_syntax::{ast, TreeArc};\n \n use crate::{\n-    Module, ModuleSource, Problem, Name,\n+    Module, ModuleSource, Name, AstId,\n     nameres::{CrateModuleId, ImportId},\n     HirDatabase, DefDatabase,\n-    HirFileId, SourceItemId,\n+    HirFileId,\n };\n \n impl ModuleSource {\n     pub(crate) fn new(\n         db: &impl DefDatabase,\n         file_id: Option<FileId>,\n-        decl_id: Option<SourceItemId>,\n+        decl_id: Option<AstId<ast::Module>>,\n     ) -> ModuleSource {\n         match (file_id, decl_id) {\n             (Some(file_id), _) => {\n                 let source_file = db.parse(file_id);\n                 ModuleSource::SourceFile(source_file)\n             }\n             (None, Some(item_id)) => {\n-                let module = db.file_item(item_id);\n-                let module = ast::Module::cast(&*module).unwrap();\n+                let module = item_id.to_node(db);\n                 assert!(module.item_list().is_some(), \"expected inline module\");\n                 ModuleSource::Module(module.to_owned())\n             }\n@@ -55,7 +54,7 @@ impl Module {\n         let decl_id = def_map[self.module_id].declaration;\n         let file_id = def_map[self.module_id].definition;\n         let module_source = ModuleSource::new(db, file_id, decl_id);\n-        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id);\n+        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n         (file_id, module_source)\n     }\n \n@@ -65,9 +64,8 @@ impl Module {\n     ) -> Option<(HirFileId, TreeArc<ast::Module>)> {\n         let def_map = db.crate_def_map(self.krate);\n         let decl = def_map[self.module_id].declaration?;\n-        let syntax_node = db.file_item(decl);\n-        let ast = ast::Module::cast(&syntax_node).unwrap().to_owned();\n-        Some((decl.file_id, ast))\n+        let ast = decl.to_node(db);\n+        Some((decl.file_id(), ast))\n     }\n \n     pub(crate) fn import_source_impl(\n@@ -76,7 +74,7 @@ impl Module {\n         import: ImportId,\n     ) -> TreeArc<ast::PathSegment> {\n         let (file_id, source) = self.definition_source(db);\n-        let (_, source_map) = db.raw_items_with_source_map(file_id.original_file(db));\n+        let (_, source_map) = db.raw_items_with_source_map(file_id);\n         source_map.get(&source, import)\n     }\n \n@@ -108,19 +106,4 @@ impl Module {\n         let parent_id = def_map[self.module_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n-\n-    pub(crate) fn problems_impl(\n-        &self,\n-        db: &impl HirDatabase,\n-    ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        let def_map = db.crate_def_map(self.krate);\n-        let (my_file_id, _) = self.definition_source(db);\n-        // FIXME: not entirely corret filterint by module\n-        def_map\n-            .problems()\n-            .iter()\n-            .filter(|(source_item_id, _problem)| my_file_id == source_item_id.file_id)\n-            .map(|(source_item_id, problem)| (db.file_item(*source_item_id), problem.clone()))\n-            .collect()\n-    }\n }"}, {"sha": "1470058480af8d950d6e139003fa93fb4ace5bd6", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -1,10 +1,10 @@\n use std::sync::Arc;\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n-use ra_db::{SourceDatabase, salsa, FileId};\n+use ra_db::{SourceDatabase, salsa};\n \n use crate::{\n-    HirFileId, SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n+    HirFileId, MacroDefId, AstIdMap, ErasedFileAstId, Crate, Module, HirInterner,\n     Function, FnSignature, ExprScopes, TypeAlias,\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n@@ -14,11 +14,15 @@ use crate::{\n     impl_block::{ModuleImplBlocks, ImplSourceMap},\n     generics::{GenericParams, GenericDef},\n     type_ref::TypeRef,\n+    traits::TraitData, Trait, ty::TraitRef\n };\n \n #[salsa::query_group(DefDatabaseStorage)]\n pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n-    #[salsa::invoke(HirFileId::hir_parse)]\n+    #[salsa::invoke(crate::ids::macro_def_query)]\n+    fn macro_def(&self, macro_id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n+\n+    #[salsa::invoke(HirFileId::hir_parse_query)]\n     fn hir_parse(&self, file_id: HirFileId) -> TreeArc<SourceFile>;\n \n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n@@ -27,17 +31,23 @@ pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(crate::adt::EnumData::enum_data_query)]\n     fn enum_data(&self, e: Enum) -> Arc<EnumData>;\n \n-    #[salsa::invoke(crate::ids::SourceFileItems::file_items_query)]\n-    fn file_items(&self, file_id: HirFileId) -> Arc<SourceFileItems>;\n+    #[salsa::invoke(crate::traits::TraitData::trait_data_query)]\n+    fn trait_data(&self, t: Trait) -> Arc<TraitData>;\n+\n+    #[salsa::invoke(crate::source_id::AstIdMap::ast_id_map_query)]\n+    fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n \n-    #[salsa::invoke(crate::ids::SourceFileItems::file_item_query)]\n-    fn file_item(&self, source_item_id: SourceItemId) -> TreeArc<SyntaxNode>;\n+    #[salsa::invoke(crate::source_id::AstIdMap::file_item_query)]\n+    fn ast_id_to_node(&self, file_id: HirFileId, ast_id: ErasedFileAstId) -> TreeArc<SyntaxNode>;\n \n     #[salsa::invoke(RawItems::raw_items_query)]\n-    fn raw_items(&self, file_id: FileId) -> Arc<RawItems>;\n+    fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n \n     #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n-    fn raw_items_with_source_map(&self, file_id: FileId) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n+    fn raw_items_with_source_map(\n+        &self,\n+        file_id: HirFileId,\n+    ) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n \n     #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n     fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;\n@@ -98,6 +108,9 @@ pub trait HirDatabase: DefDatabase {\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n+\n+    #[salsa::invoke(crate::ty::method_resolution::implements)]\n+    fn implements(&self, trait_ref: TraitRef) -> bool;\n }\n \n #[test]"}, {"sha": "d6a51b8332ac244eb7f1f03efdd063bb078deeb1", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -0,0 +1,115 @@\n+use std::{fmt, any::Any};\n+\n+use ra_syntax::{SyntaxNodePtr, TreeArc, AstPtr, TextRange, ast, SyntaxNode};\n+use relative_path::RelativePathBuf;\n+\n+use crate::{HirFileId, HirDatabase};\n+\n+/// Diagnostic defines hir API for errors and warnings.\n+///\n+/// It is used as a `dyn` object, which you can downcast to a concrete\n+/// diagnostic. DiagnosticSink are structured, meaning that they include rich\n+/// information which can be used by IDE to create fixes. DiagnosticSink are\n+/// expressed in terms of macro-expanded syntax tree nodes (so, it's a bad idea\n+/// to diagnostic in a salsa value).\n+///\n+/// Internally, various subsystems of hir produce diagnostics specific to a\n+/// subsystem (typically, an `enum`), which are safe to store in salsa but do not\n+/// include source locations. Such internal diagnostic are transformed into an\n+/// instance of `Diagnostic` on demand.\n+pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n+    fn message(&self) -> String;\n+    fn file(&self) -> HirFileId;\n+    fn syntax_node_ptr(&self) -> SyntaxNodePtr;\n+    fn highlight_range(&self) -> TextRange {\n+        self.syntax_node_ptr().range()\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static);\n+}\n+\n+impl dyn Diagnostic {\n+    pub fn syntax_node(&self, db: &impl HirDatabase) -> TreeArc<SyntaxNode> {\n+        let source_file = db.hir_parse(self.file());\n+        self.syntax_node_ptr().to_node(&source_file).to_owned()\n+    }\n+    pub fn downcast_ref<D: Diagnostic>(&self) -> Option<&D> {\n+        self.as_any().downcast_ref()\n+    }\n+}\n+\n+pub struct DiagnosticSink<'a> {\n+    callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n+    default_callback: Box<dyn FnMut(&dyn Diagnostic) + 'a>,\n+}\n+\n+impl<'a> DiagnosticSink<'a> {\n+    pub fn new(cb: impl FnMut(&dyn Diagnostic) + 'a) -> DiagnosticSink<'a> {\n+        DiagnosticSink { callbacks: Vec::new(), default_callback: Box::new(cb) }\n+    }\n+\n+    pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> DiagnosticSink<'a> {\n+        let cb = move |diag: &dyn Diagnostic| match diag.downcast_ref::<D>() {\n+            Some(d) => {\n+                cb(d);\n+                Ok(())\n+            }\n+            None => Err(()),\n+        };\n+        self.callbacks.push(Box::new(cb));\n+        self\n+    }\n+\n+    pub(crate) fn push(&mut self, d: impl Diagnostic) {\n+        let d: &dyn Diagnostic = &d;\n+        for cb in self.callbacks.iter_mut() {\n+            match cb(d) {\n+                Ok(()) => return,\n+                Err(()) => (),\n+            }\n+        }\n+        (self.default_callback)(d)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct NoSuchField {\n+    pub file: HirFileId,\n+    pub field: AstPtr<ast::NamedField>,\n+}\n+\n+impl Diagnostic for NoSuchField {\n+    fn message(&self) -> String {\n+        \"no such field\".to_string()\n+    }\n+    fn file(&self) -> HirFileId {\n+        self.file\n+    }\n+    fn syntax_node_ptr(&self) -> SyntaxNodePtr {\n+        self.field.into()\n+    }\n+    fn as_any(&self) -> &(Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct UnresolvedModule {\n+    pub file: HirFileId,\n+    pub decl: AstPtr<ast::Module>,\n+    pub candidate: RelativePathBuf,\n+}\n+\n+impl Diagnostic for UnresolvedModule {\n+    fn message(&self) -> String {\n+        \"unresolved module\".to_string()\n+    }\n+    fn file(&self) -> HirFileId {\n+        self.file\n+    }\n+    fn syntax_node_ptr(&self) -> SyntaxNodePtr {\n+        self.decl.into()\n+    }\n+    fn as_any(&self) -> &(Any + Send + 'static) {\n+        self\n+    }\n+}"}, {"sha": "a85422955b991b39d535e65394931af2c89a3487", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -5,7 +5,7 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_syntax::{\n-    SyntaxNodePtr, AstNode,\n+    SyntaxNodePtr, AstPtr, AstNode,\n     ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralFlavor, TypeAscriptionOwner}\n };\n \n@@ -54,6 +54,7 @@ pub struct BodySourceMap {\n     expr_map_back: ArenaMap<ExprId, SyntaxNodePtr>,\n     pat_map: FxHashMap<SyntaxNodePtr, PatId>,\n     pat_map_back: ArenaMap<PatId, SyntaxNodePtr>,\n+    field_map: FxHashMap<(ExprId, usize), AstPtr<ast::NamedField>>,\n }\n \n impl Body {\n@@ -138,6 +139,10 @@ impl BodySourceMap {\n     pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n         self.pat_map.get(&SyntaxNodePtr::new(node.syntax())).cloned()\n     }\n+\n+    pub fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::NamedField> {\n+        self.field_map[&(expr, field)].clone()\n+    }\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -629,8 +634,10 @@ impl ExprCollector {\n             }\n             ast::ExprKind::StructLit(e) => {\n                 let path = e.path().and_then(Path::from_ast);\n+                let mut field_ptrs = Vec::new();\n                 let fields = if let Some(nfl) = e.named_field_list() {\n                     nfl.fields()\n+                        .inspect(|field| field_ptrs.push(AstPtr::new(*field)))\n                         .map(|field| StructLitField {\n                             name: field\n                                 .name_ref()\n@@ -657,7 +664,11 @@ impl ExprCollector {\n                     Vec::new()\n                 };\n                 let spread = e.spread().map(|s| self.collect_expr(s));\n-                self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr)\n+                let res = self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr);\n+                for (i, ptr) in field_ptrs.into_iter().enumerate() {\n+                    self.source_map.field_map.insert((res, i), ptr);\n+                }\n+                res\n             }\n             ast::ExprKind::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());"}, {"sha": "eb9939df790f57b05fda1413fbe52bb453c611c8", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 45, "deletions": 152, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -1,16 +1,15 @@\n use std::{\n-    marker::PhantomData,\n     hash::{Hash, Hasher},\n     sync::Arc,\n };\n \n use ra_db::{LocationInterner, FileId};\n-use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, SyntaxNodePtr, ast};\n-use ra_arena::{Arena, RawId, ArenaId, impl_arena_id};\n+use ra_syntax::{TreeArc, SourceFile, AstNode, ast};\n+use ra_arena::{RawId, ArenaId, impl_arena_id};\n+use mbe::MacroRules;\n \n use crate::{\n-    Module,\n-    DefDatabase,\n+    Module, DefDatabase, AstId, FileAstId,\n };\n \n #[derive(Debug, Default)]\n@@ -22,7 +21,7 @@ pub struct HirInterner {\n     consts: LocationInterner<ItemLoc<ast::ConstDef>, ConstId>,\n     statics: LocationInterner<ItemLoc<ast::StaticDef>, StaticId>,\n     traits: LocationInterner<ItemLoc<ast::TraitDef>, TraitId>,\n-    types: LocationInterner<ItemLoc<ast::TypeAliasDef>, TypeId>,\n+    types: LocationInterner<ItemLoc<ast::TypeAliasDef>, TypeAliasId>,\n }\n \n impl HirInterner {\n@@ -68,7 +67,7 @@ impl HirFileId {\n             HirFileIdRepr::File(file_id) => file_id,\n             HirFileIdRepr::Macro(macro_call_id) => {\n                 let loc = macro_call_id.loc(db);\n-                loc.source_item_id.file_id.original_file(db)\n+                loc.ast_id.file_id().original_file(db)\n             }\n         }\n     }\n@@ -83,7 +82,10 @@ impl HirFileId {\n         }\n     }\n \n-    pub(crate) fn hir_parse(db: &impl DefDatabase, file_id: HirFileId) -> TreeArc<SourceFile> {\n+    pub(crate) fn hir_parse_query(\n+        db: &impl DefDatabase,\n+        file_id: HirFileId,\n+    ) -> TreeArc<SourceFile> {\n         match file_id.0 {\n             HirFileIdRepr::File(file_id) => db.parse(file_id),\n             HirFileIdRepr::Macro(macro_call_id) => {\n@@ -96,14 +98,10 @@ impl HirFileId {\n \n fn parse_macro(db: &impl DefDatabase, macro_call_id: MacroCallId) -> Option<TreeArc<SourceFile>> {\n     let loc = macro_call_id.loc(db);\n-    let syntax = db.file_item(loc.source_item_id);\n-    let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n+    let macro_call = loc.ast_id.to_node(db);\n     let (macro_arg, _) = macro_call.token_tree().and_then(mbe::ast_to_token_tree)?;\n \n-    let def_map = db.crate_def_map(loc.module.krate);\n-    let (krate, macro_id) = def_map.resolve_macro(macro_call_id)?;\n-    let def_map = db.crate_def_map(krate);\n-    let macro_rules = &def_map[macro_id];\n+    let macro_rules = db.macro_def(loc.def)?;\n     let tt = macro_rules.expand(&macro_arg).ok()?;\n     Some(mbe::token_tree_to_ast_item_list(&tt))\n }\n@@ -126,6 +124,17 @@ impl From<MacroCallId> for HirFileId {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroDefId(pub(crate) AstId<ast::MacroCall>);\n+\n+pub(crate) fn macro_def_query(db: &impl DefDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n+    let macro_call = id.0.to_node(db);\n+    let arg = macro_call.token_tree()?;\n+    let (tt, _) = mbe::ast_to_token_tree(arg)?;\n+    let rules = MacroRules::parse(&tt).ok()?;\n+    Some(Arc::new(rules))\n+}\n+\n /// `MacroCallId` identifies a particular macro invocation, like\n /// `println!(\"Hello, {}\", world)`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -134,8 +143,8 @@ impl_arena_id!(MacroCallId);\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n-    pub(crate) module: Module,\n-    pub(crate) source_item_id: SourceItemId,\n+    pub(crate) def: MacroDefId,\n+    pub(crate) ast_id: AstId<ast::MacroCall>,\n }\n \n impl MacroCallId {\n@@ -145,7 +154,6 @@ impl MacroCallId {\n }\n \n impl MacroCallLoc {\n-    #[allow(unused)]\n     pub(crate) fn id(&self, db: &impl AsRef<HirInterner>) -> MacroCallId {\n         db.as_ref().macros.loc2id(&self)\n     }\n@@ -154,26 +162,25 @@ impl MacroCallLoc {\n #[derive(Debug)]\n pub struct ItemLoc<N: AstNode> {\n     pub(crate) module: Module,\n-    raw: SourceItemId,\n-    _ty: PhantomData<N>,\n+    ast_id: AstId<N>,\n }\n \n impl<N: AstNode> PartialEq for ItemLoc<N> {\n     fn eq(&self, other: &Self) -> bool {\n-        self.module == other.module && self.raw == other.raw\n+        self.module == other.module && self.ast_id == other.ast_id\n     }\n }\n impl<N: AstNode> Eq for ItemLoc<N> {}\n impl<N: AstNode> Hash for ItemLoc<N> {\n     fn hash<H: Hasher>(&self, hasher: &mut H) {\n         self.module.hash(hasher);\n-        self.raw.hash(hasher);\n+        self.ast_id.hash(hasher);\n     }\n }\n \n impl<N: AstNode> Clone for ItemLoc<N> {\n     fn clone(&self) -> ItemLoc<N> {\n-        ItemLoc { module: self.module, raw: self.raw, _ty: PhantomData }\n+        ItemLoc { module: self.module, ast_id: self.ast_id }\n     }\n }\n \n@@ -200,26 +207,19 @@ impl<'a, DB: DefDatabase> LocationCtx<&'a DB> {\n pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<N>, Self>;\n     fn from_ast(ctx: LocationCtx<&impl DefDatabase>, ast: &N) -> Self {\n-        let items = ctx.db.file_items(ctx.file_id);\n-        let item_id = items.id_of(ctx.file_id, ast.syntax());\n-        Self::from_source_item_id_unchecked(ctx, item_id)\n+        let items = ctx.db.ast_id_map(ctx.file_id);\n+        let item_id = items.ast_id(ast);\n+        Self::from_ast_id(ctx, item_id)\n     }\n-    fn from_source_item_id_unchecked(\n-        ctx: LocationCtx<&impl DefDatabase>,\n-        item_id: SourceFileItemId,\n-    ) -> Self {\n-        let raw = SourceItemId { file_id: ctx.file_id, item_id };\n-        let loc = ItemLoc { module: ctx.module, raw, _ty: PhantomData };\n-\n+    fn from_ast_id(ctx: LocationCtx<&impl DefDatabase>, ast_id: FileAstId<N>) -> Self {\n+        let loc = ItemLoc { module: ctx.module, ast_id: ast_id.with_file_id(ctx.file_id) };\n         Self::interner(ctx.db.as_ref()).loc2id(&loc)\n     }\n     fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<N>) {\n         let int = Self::interner(db.as_ref());\n         let loc = int.id2loc(self);\n-        let syntax = db.file_item(loc.raw);\n-        let ast =\n-            N::cast(&syntax).unwrap_or_else(|| panic!(\"invalid ItemLoc: {:?}\", loc.raw)).to_owned();\n-        (loc.raw.file_id, ast)\n+        let ast = loc.ast_id.to_node(db);\n+        (loc.ast_id.file_id(), ast)\n     }\n     fn module(self, db: &impl DefDatabase) -> Module {\n         let int = Self::interner(db.as_ref());\n@@ -229,7 +229,7 @@ pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct FunctionId(RawId);\n+pub(crate) struct FunctionId(RawId);\n impl_arena_id!(FunctionId);\n impl AstItemDef<ast::FnDef> for FunctionId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::FnDef>, Self> {\n@@ -238,7 +238,7 @@ impl AstItemDef<ast::FnDef> for FunctionId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StructId(RawId);\n+pub(crate) struct StructId(RawId);\n impl_arena_id!(StructId);\n impl AstItemDef<ast::StructDef> for StructId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::StructDef>, Self> {\n@@ -247,7 +247,7 @@ impl AstItemDef<ast::StructDef> for StructId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct EnumId(RawId);\n+pub(crate) struct EnumId(RawId);\n impl_arena_id!(EnumId);\n impl AstItemDef<ast::EnumDef> for EnumId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::EnumDef>, Self> {\n@@ -256,7 +256,7 @@ impl AstItemDef<ast::EnumDef> for EnumId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ConstId(RawId);\n+pub(crate) struct ConstId(RawId);\n impl_arena_id!(ConstId);\n impl AstItemDef<ast::ConstDef> for ConstId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::ConstDef>, Self> {\n@@ -265,7 +265,7 @@ impl AstItemDef<ast::ConstDef> for ConstId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StaticId(RawId);\n+pub(crate) struct StaticId(RawId);\n impl_arena_id!(StaticId);\n impl AstItemDef<ast::StaticDef> for StaticId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::StaticDef>, Self> {\n@@ -274,7 +274,7 @@ impl AstItemDef<ast::StaticDef> for StaticId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TraitId(RawId);\n+pub(crate) struct TraitId(RawId);\n impl_arena_id!(TraitId);\n impl AstItemDef<ast::TraitDef> for TraitId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::TraitDef>, Self> {\n@@ -283,117 +283,10 @@ impl AstItemDef<ast::TraitDef> for TraitId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TypeId(RawId);\n-impl_arena_id!(TypeId);\n-impl AstItemDef<ast::TypeAliasDef> for TypeId {\n+pub(crate) struct TypeAliasId(RawId);\n+impl_arena_id!(TypeAliasId);\n+impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::TypeAliasDef>, Self> {\n         &interner.types\n     }\n }\n-\n-/// Identifier of item within a specific file. This is stable over reparses, so\n-/// it's OK to use it as a salsa key/value.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct SourceFileItemId(RawId);\n-impl_arena_id!(SourceFileItemId);\n-\n-impl SourceFileItemId {\n-    pub(crate) fn with_file_id(self, file_id: HirFileId) -> SourceItemId {\n-        SourceItemId { file_id, item_id: self }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct SourceItemId {\n-    pub(crate) file_id: HirFileId,\n-    pub(crate) item_id: SourceFileItemId,\n-}\n-\n-/// Maps items' `SyntaxNode`s to `SourceFileItemId`s and back.\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct SourceFileItems {\n-    file_id: HirFileId,\n-    arena: Arena<SourceFileItemId, SyntaxNodePtr>,\n-}\n-\n-impl SourceFileItems {\n-    pub(crate) fn file_items_query(\n-        db: &impl DefDatabase,\n-        file_id: HirFileId,\n-    ) -> Arc<SourceFileItems> {\n-        let source_file = db.hir_parse(file_id);\n-        Arc::new(SourceFileItems::from_source_file(&source_file, file_id))\n-    }\n-\n-    pub(crate) fn file_item_query(\n-        db: &impl DefDatabase,\n-        source_item_id: SourceItemId,\n-    ) -> TreeArc<SyntaxNode> {\n-        let source_file = db.hir_parse(source_item_id.file_id);\n-        db.file_items(source_item_id.file_id)[source_item_id.item_id]\n-            .to_node(&source_file)\n-            .to_owned()\n-    }\n-\n-    pub(crate) fn from_source_file(\n-        source_file: &SourceFile,\n-        file_id: HirFileId,\n-    ) -> SourceFileItems {\n-        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n-        // By walking the tree in bread-first order we make sure that parents\n-        // get lower ids then children. That is, adding a new child does not\n-        // change parent's id. This means that, say, adding a new function to a\n-        // trait does not change ids of top-level items, which helps caching.\n-        bfs(source_file.syntax(), |it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it) {\n-                res.alloc(module_item.syntax());\n-            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n-                res.alloc(macro_call.syntax());\n-            }\n-        });\n-        res\n-    }\n-\n-    fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {\n-        self.arena.alloc(SyntaxNodePtr::new(item))\n-    }\n-    pub(crate) fn id_of(&self, file_id: HirFileId, item: &SyntaxNode) -> SourceFileItemId {\n-        assert_eq!(\n-            self.file_id, file_id,\n-            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n-            self.file_id, file_id\n-        );\n-        self.id_of_unchecked(item)\n-    }\n-    pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n-        let ptr = SyntaxNodePtr::new(item);\n-        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| **i == ptr) {\n-            return id;\n-        }\n-        panic!(\n-            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n-            item,\n-            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n-        );\n-    }\n-}\n-\n-impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n-    type Output = SyntaxNodePtr;\n-    fn index(&self, idx: SourceFileItemId) -> &SyntaxNodePtr {\n-        &self.arena[idx]\n-    }\n-}\n-\n-/// Walks the subtree in bfs order, calling `f` for each node.\n-fn bfs(node: &SyntaxNode, mut f: impl FnMut(&SyntaxNode)) {\n-    let mut curr_layer = vec![node];\n-    let mut next_layer = vec![];\n-    while !curr_layer.is_empty() {\n-        curr_layer.drain(..).for_each(|node| {\n-            next_layer.extend(node.children());\n-            f(node);\n-        });\n-        std::mem::swap(&mut curr_layer, &mut next_layer);\n-    }\n-}"}, {"sha": "7c603bbd3e77a1ad70e14701ce7719fe8547c49e", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -23,10 +23,12 @@ pub mod mock;\n mod path;\n pub mod source_binder;\n \n+mod source_id;\n mod ids;\n mod name;\n mod nameres;\n mod adt;\n+mod traits;\n mod type_alias;\n mod type_ref;\n mod ty;\n@@ -35,6 +37,7 @@ mod expr;\n mod generics;\n mod docs;\n mod resolve;\n+pub mod diagnostics;\n \n mod code_model_api;\n mod code_model_impl;\n@@ -45,13 +48,14 @@ mod marks;\n use crate::{\n     db::{HirDatabase, DefDatabase},\n     name::{AsName, KnownName},\n-    ids::{SourceItemId, SourceFileItems},\n+    source_id::{FileAstId, AstId},\n };\n \n pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n-    ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n+    source_id::{AstIdMap, ErasedFileAstId},\n+    ids::{HirFileId, MacroDefId, MacroCallId, MacroCallLoc, HirInterner},\n     nameres::{PerNs, Namespace},\n     ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay},\n     impl_block::{ImplBlock, ImplItem},\n@@ -63,7 +67,7 @@ pub use self::{\n \n pub use self::code_model_api::{\n     Crate, CrateDependency,\n-    Module, ModuleDef, ModuleSource, Problem,\n+    Module, ModuleDef, ModuleSource,\n     Struct, Enum, EnumVariant,\n     Function, FnSignature,\n     StructField, FieldSource,"}, {"sha": "aeab6b180026ff8f2e4419016b4d94f2db937643", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -9,7 +9,7 @@ use relative_path::RelativePathBuf;\n use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n use rustc_hash::FxHashMap;\n \n-use crate::{db, HirInterner};\n+use crate::{db, HirInterner, diagnostics::DiagnosticSink};\n \n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n \n@@ -70,6 +70,22 @@ impl MockDatabase {\n         self.set_crate_graph(Arc::new(crate_graph))\n     }\n \n+    pub fn diagnostics(&self) -> String {\n+        let mut buf = String::from(\"\\n\");\n+        let mut files: Vec<FileId> = self.files.values().map(|&it| it).collect();\n+        files.sort();\n+        for file in files {\n+            let module = crate::source_binder::module_from_file_id(self, file).unwrap();\n+            module.diagnostics(\n+                self,\n+                &mut DiagnosticSink::new(|d| {\n+                    buf += &format!(\"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+                }),\n+            )\n+        }\n+        buf\n+    }\n+\n     fn from_fixture(fixture: &str) -> (MockDatabase, Option<FilePosition>) {\n         let mut db = MockDatabase::default();\n "}, {"sha": "8adc6d36801071514a57af3aa1ecfd175a1bbd77", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 67, "deletions": 48, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -59,12 +59,16 @@ use rustc_hash::FxHashMap;\n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::{FileId, Edition};\n use test_utils::tested_by;\n+use ra_syntax::ast;\n use ra_prof::profile;\n \n use crate::{\n-    ModuleDef, Name, Crate, Module, Problem,\n-    DefDatabase, Path, PathKind, HirFileId,\n-    ids::{SourceItemId, SourceFileItemId, MacroCallId},\n+    ModuleDef, Name, Crate, Module,\n+    DefDatabase, Path, PathKind, HirFileId, Trait,\n+    ids::MacroDefId,\n+    diagnostics::DiagnosticSink,\n+    nameres::diagnostics::DefDiagnostic,\n+    AstId,\n };\n \n pub(crate) use self::raw::{RawItems, ImportId, ImportSourceMap};\n@@ -83,10 +87,8 @@ pub struct CrateDefMap {\n     extern_prelude: FxHashMap<Name, ModuleDef>,\n     root: CrateModuleId,\n     modules: Arena<CrateModuleId, ModuleData>,\n-    macros: Arena<CrateMacroId, mbe::MacroRules>,\n-    public_macros: FxHashMap<Name, CrateMacroId>,\n-    macro_resolutions: FxHashMap<MacroCallId, (Crate, CrateMacroId)>,\n-    problems: CrateDefMapProblems,\n+    public_macros: FxHashMap<Name, MacroDefId>,\n+    diagnostics: Vec<DefDiagnostic>,\n }\n \n impl std::ops::Index<CrateModuleId> for CrateDefMap {\n@@ -96,18 +98,6 @@ impl std::ops::Index<CrateModuleId> for CrateDefMap {\n     }\n }\n \n-impl std::ops::Index<CrateMacroId> for CrateDefMap {\n-    type Output = mbe::MacroRules;\n-    fn index(&self, id: CrateMacroId) -> &mbe::MacroRules {\n-        &self.macros[id]\n-    }\n-}\n-\n-/// An ID of a macro, **local** to a specific crate\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub(crate) struct CrateMacroId(RawId);\n-impl_arena_id!(CrateMacroId);\n-\n /// An ID of a module, **local** to a specific crate\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub(crate) struct CrateModuleId(RawId);\n@@ -119,28 +109,13 @@ pub(crate) struct ModuleData {\n     pub(crate) children: FxHashMap<Name, CrateModuleId>,\n     pub(crate) scope: ModuleScope,\n     /// None for root\n-    pub(crate) declaration: Option<SourceItemId>,\n+    pub(crate) declaration: Option<AstId<ast::Module>>,\n     /// None for inline modules.\n     ///\n     /// Note that non-inline modules, by definition, live inside non-macro file.\n     pub(crate) definition: Option<FileId>,\n }\n \n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct CrateDefMapProblems {\n-    problems: Vec<(SourceItemId, Problem)>,\n-}\n-\n-impl CrateDefMapProblems {\n-    fn add(&mut self, source_item_id: SourceItemId, problem: Problem) {\n-        self.problems.push((source_item_id, problem))\n-    }\n-\n-    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (&'a SourceItemId, &'a Problem)> + 'a {\n-        self.problems.iter().map(|(s, p)| (s, p))\n-    }\n-}\n-\n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n     items: FxHashMap<Name, Resolution>,\n@@ -153,6 +128,12 @@ impl ModuleScope {\n     pub fn get(&self, name: &Name) -> Option<&Resolution> {\n         self.items.get(name)\n     }\n+    pub fn traits<'a>(&'a self) -> impl Iterator<Item = Trait> + 'a {\n+        self.items.values().filter_map(|r| match r.def.take_types() {\n+            Some(ModuleDef::Trait(t)) => Some(t),\n+            _ => None,\n+        })\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Default)]\n@@ -210,10 +191,8 @@ impl CrateDefMap {\n                 prelude: None,\n                 root,\n                 modules,\n-                macros: Arena::default(),\n                 public_macros: FxHashMap::default(),\n-                macro_resolutions: FxHashMap::default(),\n-                problems: CrateDefMapProblems::default(),\n+                diagnostics: Vec::new(),\n             }\n         };\n         let def_map = collector::collect_defs(db, def_map);\n@@ -224,10 +203,6 @@ impl CrateDefMap {\n         self.root\n     }\n \n-    pub(crate) fn problems(&self) -> &CrateDefMapProblems {\n-        &self.problems\n-    }\n-\n     pub(crate) fn mk_module(&self, module_id: CrateModuleId) -> Module {\n         Module { krate: self.krate, module_id }\n     }\n@@ -240,19 +215,20 @@ impl CrateDefMap {\n         &self.extern_prelude\n     }\n \n-    pub(crate) fn resolve_macro(\n+    pub(crate) fn add_diagnostics(\n         &self,\n-        macro_call_id: MacroCallId,\n-    ) -> Option<(Crate, CrateMacroId)> {\n-        self.macro_resolutions.get(&macro_call_id).map(|&it| it)\n+        db: &impl DefDatabase,\n+        module: CrateModuleId,\n+        sink: &mut DiagnosticSink,\n+    ) {\n+        self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n     }\n \n     pub(crate) fn find_module_by_source(\n         &self,\n         file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n+        decl_id: Option<AstId<ast::Module>>,\n     ) -> Option<CrateModuleId> {\n-        let decl_id = decl_id.map(|it| it.with_file_id(file_id));\n         let (module_id, _module_data) = self.modules.iter().find(|(_module_id, module_data)| {\n             if decl_id.is_some() {\n                 module_data.declaration == decl_id\n@@ -452,3 +428,46 @@ impl CrateDefMap {\n         }\n     }\n }\n+\n+mod diagnostics {\n+    use relative_path::RelativePathBuf;\n+    use ra_syntax::{AstPtr, ast};\n+\n+    use crate::{\n+        AstId, DefDatabase,\n+        nameres::CrateModuleId,\n+        diagnostics::{DiagnosticSink, UnresolvedModule},\n+};\n+\n+    #[derive(Debug, PartialEq, Eq)]\n+    pub(super) enum DefDiagnostic {\n+        UnresolvedModule {\n+            module: CrateModuleId,\n+            declaration: AstId<ast::Module>,\n+            candidate: RelativePathBuf,\n+        },\n+    }\n+\n+    impl DefDiagnostic {\n+        pub(super) fn add_to(\n+            &self,\n+            db: &impl DefDatabase,\n+            target_module: CrateModuleId,\n+            sink: &mut DiagnosticSink,\n+        ) {\n+            match self {\n+                DefDiagnostic::UnresolvedModule { module, declaration, candidate } => {\n+                    if *module != target_module {\n+                        return;\n+                    }\n+                    let decl = declaration.to_node(db);\n+                    sink.push(UnresolvedModule {\n+                        file: declaration.file_id(),\n+                        decl: AstPtr::new(&decl),\n+                        candidate: candidate.clone(),\n+                    })\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "39cadc94aab3101bcdafaeb9383ff2a5869cbbdb", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 78, "deletions": 120, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -3,17 +3,22 @@ use rustc_hash::FxHashMap;\n use relative_path::RelativePathBuf;\n use test_utils::tested_by;\n use ra_db::FileId;\n+use ra_syntax::ast;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    DefDatabase, HirFileId, Name, Path, Problem, Crate,\n+    DefDatabase, HirFileId, Name, Path,\n     KnownName,\n-    nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode, raw},\n-    ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n+    nameres::{\n+        Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n+        CrateDefMap, CrateModuleId, ModuleData,\n+        diagnostics::DefDiagnostic,\n+        raw,\n+    },\n+    ids::{AstItemDef, LocationCtx, MacroCallLoc, MacroCallId, MacroDefId},\n+    AstId,\n };\n \n-use super::{CrateDefMap, CrateModuleId, ModuleData, CrateMacroId};\n-\n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n     // populate external prelude\n     for dep in def_map.krate.dependencies(db) {\n@@ -48,8 +53,8 @@ struct DefCollector<DB> {\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n-    unexpanded_macros: Vec<(CrateModuleId, MacroCallId, Path, tt::Subtree)>,\n-    global_macro_scope: FxHashMap<Name, CrateMacroId>,\n+    unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n+    global_macro_scope: FxHashMap<Name, MacroDefId>,\n }\n \n impl<'a, DB> DefCollector<&'a DB>\n@@ -59,7 +64,7 @@ where\n     fn collect(&mut self) {\n         let crate_graph = self.db.crate_graph();\n         let file_id = crate_graph.crate_root(self.def_map.krate.crate_id());\n-        let raw_items = self.db.raw_items(file_id);\n+        let raw_items = self.db.raw_items(file_id.into());\n         let module_id = self.def_map.root;\n         self.def_map.modules[module_id].definition = Some(file_id);\n         ModCollector {\n@@ -90,14 +95,11 @@ where\n         }\n     }\n \n-    fn define_macro(&mut self, name: Name, tt: &tt::Subtree, export: bool) {\n-        if let Ok(rules) = mbe::MacroRules::parse(tt) {\n-            let macro_id = self.def_map.macros.alloc(rules);\n-            if export {\n-                self.def_map.public_macros.insert(name.clone(), macro_id);\n-            }\n-            self.global_macro_scope.insert(name, macro_id);\n+    fn define_macro(&mut self, name: Name, macro_id: MacroDefId, export: bool) {\n+        if export {\n+            self.def_map.public_macros.insert(name.clone(), macro_id);\n         }\n+        self.global_macro_scope.insert(name, macro_id);\n     }\n \n     fn resolve_imports(&mut self) -> ReachedFixedPoint {\n@@ -293,7 +295,7 @@ where\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n-        macros.retain(|(module_id, call_id, path, tt)| {\n+        macros.retain(|(module_id, ast_id, path)| {\n             if path.segments.len() != 2 {\n                 return true;\n             }\n@@ -309,47 +311,23 @@ where\n             res = ReachedFixedPoint::No;\n             let def_map = self.db.crate_def_map(krate);\n             if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n-                resolved.push((*module_id, *call_id, (krate, macro_id), tt.clone()));\n+                let call_id = MacroCallLoc { def: macro_id, ast_id: *ast_id }.id(self.db);\n+                resolved.push((*module_id, call_id));\n             }\n             false\n         });\n \n-        for (module_id, macro_call_id, macro_def_id, arg) in resolved {\n-            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id, arg);\n+        for (module_id, macro_call_id) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id);\n         }\n         res\n     }\n \n-    fn collect_macro_expansion(\n-        &mut self,\n-        module_id: CrateModuleId,\n-        macro_call_id: MacroCallId,\n-        macro_def_id: (Crate, CrateMacroId),\n-        macro_arg: tt::Subtree,\n-    ) {\n-        let (macro_krate, macro_id) = macro_def_id;\n-        let dm;\n-        let rules = if macro_krate == self.def_map.krate {\n-            &self.def_map[macro_id]\n-        } else {\n-            dm = self.db.crate_def_map(macro_krate);\n-            &dm[macro_id]\n-        };\n-        if let Ok(expansion) = rules.expand(&macro_arg) {\n-            self.def_map.macro_resolutions.insert(macro_call_id, macro_def_id);\n-            // XXX: this **does not** go through a database, because we can't\n-            // identify macro_call without adding the whole state of name resolution\n-            // as a parameter to the query.\n-            //\n-            // So, we run the queries \"manually\" and we must ensure that\n-            // `db.hir_parse(macro_call_id)` returns the same source_file.\n-            let file_id: HirFileId = macro_call_id.into();\n-            let source_file = mbe::token_tree_to_ast_item_list(&expansion);\n-\n-            let raw_items = raw::RawItems::from_source_file(&source_file, file_id);\n-            ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-                .collect(raw_items.items())\n-        }\n+    fn collect_macro_expansion(&mut self, module_id: CrateModuleId, macro_call_id: MacroCallId) {\n+        let file_id: HirFileId = macro_call_id.into();\n+        let raw_items = self.db.raw_items(file_id);\n+        ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n+            .collect(raw_items.items())\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -387,12 +365,9 @@ where\n     fn collect_module(&mut self, module: &raw::ModuleData) {\n         match module {\n             // inline module, just recurse\n-            raw::ModuleData::Definition { name, items, source_item_id } => {\n-                let module_id = self.push_child_module(\n-                    name.clone(),\n-                    source_item_id.with_file_id(self.file_id),\n-                    None,\n-                );\n+            raw::ModuleData::Definition { name, items, ast_id } => {\n+                let module_id =\n+                    self.push_child_module(name.clone(), ast_id.with_file_id(self.file_id), None);\n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n                     module_id,\n@@ -402,36 +377,37 @@ where\n                 .collect(&*items);\n             }\n             // out of line module, resovle, parse and recurse\n-            raw::ModuleData::Declaration { name, source_item_id } => {\n-                let source_item_id = source_item_id.with_file_id(self.file_id);\n+            raw::ModuleData::Declaration { name, ast_id } => {\n+                let ast_id = ast_id.with_file_id(self.file_id);\n                 let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n-                let (file_ids, problem) =\n-                    resolve_submodule(self.def_collector.db, self.file_id, name, is_root);\n-\n-                if let Some(problem) = problem {\n-                    self.def_collector.def_map.problems.add(source_item_id, problem)\n-                }\n-\n-                if let Some(&file_id) = file_ids.first() {\n-                    let module_id =\n-                        self.push_child_module(name.clone(), source_item_id, Some(file_id));\n-                    let raw_items = self.def_collector.db.raw_items(file_id);\n-                    ModCollector {\n-                        def_collector: &mut *self.def_collector,\n-                        module_id,\n-                        file_id: file_id.into(),\n-                        raw_items: &raw_items,\n+                match resolve_submodule(self.def_collector.db, self.file_id, name, is_root) {\n+                    Ok(file_id) => {\n+                        let module_id = self.push_child_module(name.clone(), ast_id, Some(file_id));\n+                        let raw_items = self.def_collector.db.raw_items(file_id.into());\n+                        ModCollector {\n+                            def_collector: &mut *self.def_collector,\n+                            module_id,\n+                            file_id: file_id.into(),\n+                            raw_items: &raw_items,\n+                        }\n+                        .collect(raw_items.items())\n                     }\n-                    .collect(raw_items.items())\n-                }\n+                    Err(candidate) => self.def_collector.def_map.diagnostics.push(\n+                        DefDiagnostic::UnresolvedModule {\n+                            module: self.module_id,\n+                            declaration: ast_id,\n+                            candidate,\n+                        },\n+                    ),\n+                };\n             }\n         }\n     }\n \n     fn push_child_module(\n         &mut self,\n         name: Name,\n-        declaration: SourceItemId,\n+        declaration: AstId<ast::Module>,\n         definition: Option<FileId>,\n     ) -> CrateModuleId {\n         let modules = &mut self.def_collector.def_map.modules;\n@@ -453,23 +429,24 @@ where\n     fn define_def(&mut self, def: &raw::DefData) {\n         let module = Module { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n         let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id.into());\n-        macro_rules! id {\n-            () => {\n-                AstItemDef::from_source_item_id_unchecked(ctx, def.source_item_id)\n+\n+        macro_rules! def {\n+            ($kind:ident, $ast_id:ident) => {\n+                $kind { id: AstItemDef::from_ast_id(ctx, $ast_id) }.into()\n             };\n         }\n         let name = def.name.clone();\n         let def: PerNs<ModuleDef> = match def.kind {\n-            raw::DefKind::Function => PerNs::values(Function { id: id!() }.into()),\n-            raw::DefKind::Struct => {\n-                let s = Struct { id: id!() }.into();\n+            raw::DefKind::Function(ast_id) => PerNs::values(def!(Function, ast_id)),\n+            raw::DefKind::Struct(ast_id) => {\n+                let s = def!(Struct, ast_id);\n                 PerNs::both(s, s)\n             }\n-            raw::DefKind::Enum => PerNs::types(Enum { id: id!() }.into()),\n-            raw::DefKind::Const => PerNs::values(Const { id: id!() }.into()),\n-            raw::DefKind::Static => PerNs::values(Static { id: id!() }.into()),\n-            raw::DefKind::Trait => PerNs::types(Trait { id: id!() }.into()),\n-            raw::DefKind::TypeAlias => PerNs::types(TypeAlias { id: id!() }.into()),\n+            raw::DefKind::Enum(ast_id) => PerNs::types(def!(Enum, ast_id)),\n+            raw::DefKind::Const(ast_id) => PerNs::values(def!(Const, ast_id)),\n+            raw::DefKind::Static(ast_id) => PerNs::values(def!(Static, ast_id)),\n+            raw::DefKind::Trait(ast_id) => PerNs::types(def!(Trait, ast_id)),\n+            raw::DefKind::TypeAlias(ast_id) => PerNs::types(def!(TypeAlias, ast_id)),\n         };\n         let resolution = Resolution { def, import: None };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)])\n@@ -479,39 +456,27 @@ where\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                self.def_collector.define_macro(name.clone(), &mac.arg, mac.export)\n+                let macro_id = MacroDefId(mac.ast_id.with_file_id(self.file_id));\n+                self.def_collector.define_macro(name.clone(), macro_id, mac.export)\n             }\n             return;\n         }\n \n-        let source_item_id = SourceItemId { file_id: self.file_id, item_id: mac.source_item_id };\n-        let macro_call_id = MacroCallLoc {\n-            module: Module { krate: self.def_collector.def_map.krate, module_id: self.module_id },\n-            source_item_id,\n-        }\n-        .id(self.def_collector.db);\n+        let ast_id = mac.ast_id.with_file_id(self.file_id);\n \n         // Case 2: try to expand macro_rules from this crate, triggering\n         // recursive item collection.\n         if let Some(&macro_id) =\n             mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n         {\n-            self.def_collector.collect_macro_expansion(\n-                self.module_id,\n-                macro_call_id,\n-                (self.def_collector.def_map.krate, macro_id),\n-                mac.arg.clone(),\n-            );\n+            let macro_call_id = MacroCallLoc { def: macro_id, ast_id }.id(self.def_collector.db);\n+\n+            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id);\n             return;\n         }\n \n         // Case 3: path to a macro from another crate, expand during name resolution\n-        self.def_collector.unexpanded_macros.push((\n-            self.module_id,\n-            macro_call_id,\n-            mac.path.clone(),\n-            mac.arg.clone(),\n-        ))\n+        self.def_collector.unexpanded_macros.push((self.module_id, ast_id, mac.path.clone()))\n     }\n }\n \n@@ -524,7 +489,7 @@ fn resolve_submodule(\n     file_id: HirFileId,\n     name: &Name,\n     is_root: bool,\n-) -> (Vec<FileId>, Option<Problem>) {\n+) -> Result<FileId, RelativePathBuf> {\n     // FIXME: handle submodules of inline modules properly\n     let file_id = file_id.original_file(db);\n     let source_root_id = db.file_source_root(file_id);\n@@ -545,17 +510,10 @@ fn resolve_submodule(\n         candidates.push(file_dir_mod.clone());\n     };\n     let sr = db.source_root(source_root_id);\n-    let points_to = candidates\n-        .into_iter()\n-        .filter_map(|path| sr.files.get(&path))\n-        .map(|&it| it)\n-        .collect::<Vec<_>>();\n-    let problem = if points_to.is_empty() {\n-        Some(Problem::UnresolvedModule {\n-            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n-        })\n-    } else {\n-        None\n-    };\n-    (points_to, problem)\n+    let mut points_to = candidates.into_iter().filter_map(|path| sr.files.get(&path)).map(|&it| it);\n+    // FIXME: handle ambiguity\n+    match points_to.next() {\n+        Some(file_id) => Ok(file_id),\n+        None => Err(if is_dir_owner { file_mod } else { file_dir_mod }),\n+    }\n }"}, {"sha": "0936229acf4082eb90cffade53fb3612bd800654", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 70, "deletions": 73, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -4,7 +4,6 @@ use std::{\n };\n \n use test_utils::tested_by;\n-use ra_db::FileId;\n use ra_arena::{Arena, impl_arena_id, RawId, map::ArenaMap};\n use ra_syntax::{\n     AstNode, SourceFile, AstPtr, TreeArc,\n@@ -13,9 +12,13 @@ use ra_syntax::{\n \n use crate::{\n     DefDatabase, Name, AsName, Path, HirFileId, ModuleSource,\n-    ids::{SourceFileItemId, SourceFileItems},\n+    AstIdMap, FileAstId,\n };\n \n+/// `RawItems` is a set of top-level items in a file (except for impls).\n+///\n+/// It is the input to name resolution algorithm. `RawItems` are not invalidated\n+/// on most edits.\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct RawItems {\n     modules: Arena<Module, ModuleData>,\n@@ -32,11 +35,11 @@ pub struct ImportSourceMap {\n }\n \n impl ImportSourceMap {\n-    pub(crate) fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n+    fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n         self.map.insert(import, AstPtr::new(segment))\n     }\n \n-    pub fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n+    pub(crate) fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n         let file = match source {\n             ModuleSource::SourceFile(file) => &*file,\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n@@ -47,40 +50,27 @@ impl ImportSourceMap {\n }\n \n impl RawItems {\n-    pub(crate) fn raw_items_query(db: &impl DefDatabase, file_id: FileId) -> Arc<RawItems> {\n+    pub(crate) fn raw_items_query(db: &impl DefDatabase, file_id: HirFileId) -> Arc<RawItems> {\n         db.raw_items_with_source_map(file_id).0\n     }\n \n     pub(crate) fn raw_items_with_source_map_query(\n         db: &impl DefDatabase,\n-        file_id: FileId,\n+        file_id: HirFileId,\n     ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n-            source_file_items: db.file_items(file_id.into()),\n+            source_ast_id_map: db.ast_id_map(file_id.into()),\n             source_map: ImportSourceMap::default(),\n         };\n-        let source_file = db.parse(file_id);\n+        let source_file = db.hir_parse(file_id);\n         collector.process_module(None, &*source_file);\n         (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n     }\n \n-    pub(crate) fn items(&self) -> &[RawItem] {\n+    pub(super) fn items(&self) -> &[RawItem] {\n         &self.items\n     }\n-\n-    // We can't use queries during name resolution for fear of cycles, so this\n-    // is a query-less variant of the above function.\n-    pub(crate) fn from_source_file(source_file: &SourceFile, file_id: HirFileId) -> RawItems {\n-        let source_file_items = SourceFileItems::from_source_file(source_file, file_id);\n-        let mut collector = RawItemsCollector {\n-            raw_items: RawItems::default(),\n-            source_file_items: Arc::new(source_file_items),\n-            source_map: ImportSourceMap::default(),\n-        };\n-        collector.process_module(None, &*source_file);\n-        collector.raw_items\n-    }\n }\n \n impl Index<Module> for RawItems {\n@@ -112,21 +102,21 @@ impl Index<Macro> for RawItems {\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(crate) enum RawItem {\n+pub(super) enum RawItem {\n     Module(Module),\n     Import(ImportId),\n     Def(Def),\n     Macro(Macro),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct Module(RawId);\n+pub(super) struct Module(RawId);\n impl_arena_id!(Module);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) enum ModuleData {\n-    Declaration { name: Name, source_item_id: SourceFileItemId },\n-    Definition { name: Name, source_item_id: SourceFileItemId, items: Vec<RawItem> },\n+pub(super) enum ModuleData {\n+    Declaration { name: Name, ast_id: FileAstId<ast::Module> },\n+    Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -135,51 +125,49 @@ impl_arena_id!(ImportId);\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n-    pub(crate) path: Path,\n-    pub(crate) alias: Option<Name>,\n-    pub(crate) is_glob: bool,\n-    pub(crate) is_prelude: bool,\n-    pub(crate) is_extern_crate: bool,\n+    pub(super) path: Path,\n+    pub(super) alias: Option<Name>,\n+    pub(super) is_glob: bool,\n+    pub(super) is_prelude: bool,\n+    pub(super) is_extern_crate: bool,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct Def(RawId);\n+pub(super) struct Def(RawId);\n impl_arena_id!(Def);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct DefData {\n-    pub(crate) source_item_id: SourceFileItemId,\n-    pub(crate) name: Name,\n-    pub(crate) kind: DefKind,\n+pub(super) struct DefData {\n+    pub(super) name: Name,\n+    pub(super) kind: DefKind,\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(crate) enum DefKind {\n-    Function,\n-    Struct,\n-    Enum,\n-    Const,\n-    Static,\n-    Trait,\n-    TypeAlias,\n+pub(super) enum DefKind {\n+    Function(FileAstId<ast::FnDef>),\n+    Struct(FileAstId<ast::StructDef>),\n+    Enum(FileAstId<ast::EnumDef>),\n+    Const(FileAstId<ast::ConstDef>),\n+    Static(FileAstId<ast::StaticDef>),\n+    Trait(FileAstId<ast::TraitDef>),\n+    TypeAlias(FileAstId<ast::TypeAliasDef>),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct Macro(RawId);\n+pub(super) struct Macro(RawId);\n impl_arena_id!(Macro);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct MacroData {\n-    pub(crate) source_item_id: SourceFileItemId,\n-    pub(crate) path: Path,\n-    pub(crate) name: Option<Name>,\n-    pub(crate) arg: tt::Subtree,\n-    pub(crate) export: bool,\n+pub(super) struct MacroData {\n+    pub(super) ast_id: FileAstId<ast::MacroCall>,\n+    pub(super) path: Path,\n+    pub(super) name: Option<Name>,\n+    pub(super) export: bool,\n }\n \n struct RawItemsCollector {\n     raw_items: RawItems,\n-    source_file_items: Arc<SourceFileItems>,\n+    source_ast_id_map: Arc<AstIdMap>,\n     source_map: ImportSourceMap,\n }\n \n@@ -211,18 +199,31 @@ impl RawItemsCollector {\n                 // impls don't participate in name resolution\n                 return;\n             }\n-            ast::ModuleItemKind::StructDef(it) => (DefKind::Struct, it.name()),\n-            ast::ModuleItemKind::EnumDef(it) => (DefKind::Enum, it.name()),\n-            ast::ModuleItemKind::FnDef(it) => (DefKind::Function, it.name()),\n-            ast::ModuleItemKind::TraitDef(it) => (DefKind::Trait, it.name()),\n-            ast::ModuleItemKind::TypeAliasDef(it) => (DefKind::TypeAlias, it.name()),\n-            ast::ModuleItemKind::ConstDef(it) => (DefKind::Const, it.name()),\n-            ast::ModuleItemKind::StaticDef(it) => (DefKind::Static, it.name()),\n+            ast::ModuleItemKind::StructDef(it) => {\n+                (DefKind::Struct(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::EnumDef(it) => {\n+                (DefKind::Enum(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::FnDef(it) => {\n+                (DefKind::Function(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::TraitDef(it) => {\n+                (DefKind::Trait(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::TypeAliasDef(it) => {\n+                (DefKind::TypeAlias(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::ConstDef(it) => {\n+                (DefKind::Const(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::StaticDef(it) => {\n+                (DefKind::Static(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n         };\n         if let Some(name) = name {\n             let name = name.as_name();\n-            let source_item_id = self.source_file_items.id_of_unchecked(item.syntax());\n-            let def = self.raw_items.defs.alloc(DefData { name, kind, source_item_id });\n+            let def = self.raw_items.defs.alloc(DefData { name, kind });\n             self.push_item(current_module, RawItem::Def(def))\n         }\n     }\n@@ -232,18 +233,17 @@ impl RawItemsCollector {\n             Some(it) => it.as_name(),\n             None => return,\n         };\n-        let source_item_id = self.source_file_items.id_of_unchecked(module.syntax());\n+        let ast_id = self.source_ast_id_map.ast_id(module);\n         if module.has_semi() {\n-            let item =\n-                self.raw_items.modules.alloc(ModuleData::Declaration { name, source_item_id });\n+            let item = self.raw_items.modules.alloc(ModuleData::Declaration { name, ast_id });\n             self.push_item(current_module, RawItem::Module(item));\n             return;\n         }\n \n         if let Some(item_list) = module.item_list() {\n             let item = self.raw_items.modules.alloc(ModuleData::Definition {\n                 name,\n-                source_item_id,\n+                ast_id,\n                 items: Vec::new(),\n             });\n             self.process_module(Some(item), item_list);\n@@ -291,18 +291,15 @@ impl RawItemsCollector {\n     }\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: &ast::MacroCall) {\n-        let (path, arg) = match (\n-            m.path().and_then(Path::from_ast),\n-            m.token_tree().and_then(mbe::ast_to_token_tree),\n-        ) {\n-            (Some(path), Some((token_tree, _token_map))) => (path, token_tree),\n+        let path = match m.path().and_then(Path::from_ast) {\n+            Some(it) => it,\n             _ => return,\n         };\n \n         let name = m.name().map(|it| it.as_name());\n-        let source_item_id = self.source_file_items.id_of_unchecked(m.syntax());\n+        let ast_id = self.source_ast_id_map.ast_id(m);\n         let export = m.has_atom_attr(\"macro_export\");\n-        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, arg, name, export });\n+        let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export });\n         self.push_item(current_module, RawItem::Macro(m));\n     }\n "}, {"sha": "572bd1bf74734725ef27aa728733b63abde75579", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -552,3 +552,22 @@ foo: v\n \"###\n     );\n }\n+\n+#[test]\n+fn unresolved_module_diagnostics() {\n+    let diagnostics = MockDatabase::with_files(\n+        r\"\n+        //- /lib.rs\n+        mod foo;\n+        mod bar;\n+        mod baz {}\n+        //- /foo.rs\n+        \",\n+    )\n+    .diagnostics();\n+\n+    assert_snapshot_matches!(diagnostics, @r###\"\n+\"mod bar;\": unresolved module\n+\"###\n+    );\n+}"}, {"sha": "001f76ac30655de056b9842df24c8eae39261e40", "filename": "crates/ra_hir/src/nameres/tests/incremental.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -90,34 +90,44 @@ fn adding_inner_items_should_not_invalidate_def_map() {\n     );\n }\n \n-// It would be awesome to make this work, but it's unclear how\n #[test]\n-#[ignore]\n-fn typing_inside_a_function_inside_a_macro_should_not_invalidate_def_map() {\n-    check_def_map_is_not_recomputed(\n+fn typing_inside_a_macro_should_not_invalidate_def_map() {\n+    let (mut db, pos) = MockDatabase::with_position(\n         \"\n         //- /lib.rs\n+        macro_rules! m {\n+            ($ident:ident) => {\n+                fn f() {\n+                    $ident + $ident;\n+                };\n+            }\n+        }\n         mod foo;\n \n-        use crate::foo::bar::Baz;\n-\n         //- /foo/mod.rs\n         pub mod bar;\n \n         //- /foo/bar.rs\n         <|>\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 1 + 1 }\n-            }\n-        }\n-        \",\n-        \"\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 92 }\n-            }\n-        }\n+        m!(X);\n         \",\n     );\n+    {\n+        let events = db.log_executed(|| {\n+            let module = crate::source_binder::module_from_file_id(&db, pos.file_id).unwrap();\n+            let decls = module.declarations(&db);\n+            assert_eq!(decls.len(), 1);\n+        });\n+        assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+    }\n+    db.set_file_text(pos.file_id, Arc::new(\"m!(Y);\".to_string()));\n+\n+    {\n+        let events = db.log_executed(|| {\n+            let module = crate::source_binder::module_from_file_id(&db, pos.file_id).unwrap();\n+            let decls = module.declarations(&db);\n+            assert_eq!(decls.len(), 1);\n+        });\n+        assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+    }\n }"}, {"sha": "2609585b1f1e98607e30edaa4fdd3589e9ed4050", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     generics::GenericParams,\n     expr::{scope::{ExprScopes, ScopeId}, PatId, Body},\n     impl_block::ImplBlock,\n-    path::Path,\n+    path::Path, Trait\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -175,6 +175,21 @@ impl Resolver {\n         names\n     }\n \n+    pub(crate) fn traits_in_scope<'a>(&'a self) -> impl Iterator<Item = Trait> + 'a {\n+        // FIXME prelude\n+        self.scopes\n+            .iter()\n+            .rev()\n+            .flat_map(|scope| {\n+                match scope {\n+                    Scope::ModuleScope(m) => Some(m.crate_def_map[m.module_id].scope.traits()),\n+                    _ => None,\n+                }\n+                .into_iter()\n+            })\n+            .flatten()\n+    }\n+\n     fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),"}, {"sha": "9dae4c3d1de4d5684a3b6c9ce57581c36a099eec", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -15,8 +15,8 @@ use ra_syntax::{\n use crate::{\n     HirDatabase, Function, Struct, Enum,\n     AsName, Module, HirFileId, Crate, Trait, Resolver,\n-    ids::{LocationCtx, SourceFileItemId},\n-    expr\n+    ids::LocationCtx,\n+    expr, AstId\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -54,8 +54,8 @@ fn module_from_inline(\n ) -> Option<Module> {\n     assert!(!module.has_semi());\n     let file_id = file_id.into();\n-    let file_items = db.file_items(file_id);\n-    let item_id = file_items.id_of(file_id, module.syntax());\n+    let ast_id_map = db.ast_id_map(file_id);\n+    let item_id = ast_id_map.ast_id(module).with_file_id(file_id);\n     module_from_source(db, file_id, Some(item_id))\n }\n \n@@ -75,7 +75,7 @@ pub fn module_from_child_node(\n fn module_from_source(\n     db: &impl HirDatabase,\n     file_id: HirFileId,\n-    decl_id: Option<SourceFileItemId>,\n+    decl_id: Option<AstId<ast::Module>>,\n ) -> Option<Module> {\n     let source_root_id = db.file_source_root(file_id.as_original_file());\n     db.source_root_crates(source_root_id).iter().map(|&crate_id| Crate { crate_id }).find_map("}, {"sha": "0a8fb6d3285ad68d998664812a51f457df0fc9a2", "filename": "crates/ra_hir/src/source_id.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -0,0 +1,150 @@\n+use std::{marker::PhantomData, sync::Arc, hash::{Hash, Hasher}};\n+\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_syntax::{SyntaxNodePtr, TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n+\n+use crate::{HirFileId, DefDatabase};\n+\n+/// `AstId` points to an AST node in any file.\n+///\n+/// It is stable across reparses, and can be used as salsa key/value.\n+#[derive(Debug)]\n+pub(crate) struct AstId<N: AstNode> {\n+    file_id: HirFileId,\n+    file_ast_id: FileAstId<N>,\n+}\n+\n+impl<N: AstNode> Clone for AstId<N> {\n+    fn clone(&self) -> AstId<N> {\n+        *self\n+    }\n+}\n+impl<N: AstNode> Copy for AstId<N> {}\n+\n+impl<N: AstNode> PartialEq for AstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.file_id, self.file_ast_id) == (other.file_id, other.file_ast_id)\n+    }\n+}\n+impl<N: AstNode> Eq for AstId<N> {}\n+impl<N: AstNode> Hash for AstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        (self.file_id, self.file_ast_id).hash(hasher);\n+    }\n+}\n+\n+impl<N: AstNode> AstId<N> {\n+    pub(crate) fn file_id(&self) -> HirFileId {\n+        self.file_id\n+    }\n+\n+    pub(crate) fn to_node(&self, db: &impl DefDatabase) -> TreeArc<N> {\n+        let syntax_node = db.ast_id_to_node(self.file_id, self.file_ast_id.raw);\n+        N::cast(&syntax_node).unwrap().to_owned()\n+    }\n+}\n+\n+/// `AstId` points to an AST node in a specific file.\n+#[derive(Debug)]\n+pub(crate) struct FileAstId<N: AstNode> {\n+    raw: ErasedFileAstId,\n+    _ty: PhantomData<N>,\n+}\n+\n+impl<N: AstNode> Clone for FileAstId<N> {\n+    fn clone(&self) -> FileAstId<N> {\n+        *self\n+    }\n+}\n+impl<N: AstNode> Copy for FileAstId<N> {}\n+\n+impl<N: AstNode> PartialEq for FileAstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.raw == other.raw\n+    }\n+}\n+impl<N: AstNode> Eq for FileAstId<N> {}\n+impl<N: AstNode> Hash for FileAstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.raw.hash(hasher);\n+    }\n+}\n+\n+impl<N: AstNode> FileAstId<N> {\n+    pub(crate) fn with_file_id(self, file_id: HirFileId) -> AstId<N> {\n+        AstId { file_id, file_ast_id: self }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ErasedFileAstId(RawId);\n+impl_arena_id!(ErasedFileAstId);\n+\n+/// Maps items' `SyntaxNode`s to `ErasedFileAstId`s and back.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct AstIdMap {\n+    arena: Arena<ErasedFileAstId, SyntaxNodePtr>,\n+}\n+\n+impl AstIdMap {\n+    pub(crate) fn ast_id_map_query(db: &impl DefDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n+        let source_file = db.hir_parse(file_id);\n+        Arc::new(AstIdMap::from_source_file(&source_file))\n+    }\n+\n+    pub(crate) fn file_item_query(\n+        db: &impl DefDatabase,\n+        file_id: HirFileId,\n+        ast_id: ErasedFileAstId,\n+    ) -> TreeArc<SyntaxNode> {\n+        let source_file = db.hir_parse(file_id);\n+        db.ast_id_map(file_id).arena[ast_id].to_node(&source_file).to_owned()\n+    }\n+\n+    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n+        let ptr = SyntaxNodePtr::new(item.syntax());\n+        let raw = match self.arena.iter().find(|(_id, i)| **i == ptr) {\n+            Some((it, _)) => it,\n+            None => panic!(\n+                \"Can't find {:?} in AstIdMap:\\n{:?}\",\n+                item.syntax(),\n+                self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n+            ),\n+        };\n+\n+        FileAstId { raw, _ty: PhantomData }\n+    }\n+\n+    fn from_source_file(source_file: &SourceFile) -> AstIdMap {\n+        let mut res = AstIdMap { arena: Arena::default() };\n+        // By walking the tree in bread-first order we make sure that parents\n+        // get lower ids then children. That is, adding a new child does not\n+        // change parent's id. This means that, say, adding a new function to a\n+        // trait does not change ids of top-level items, which helps caching.\n+        bfs(source_file.syntax(), |it| {\n+            if let Some(module_item) = ast::ModuleItem::cast(it) {\n+                res.alloc(module_item.syntax());\n+            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n+                res.alloc(macro_call.syntax());\n+            }\n+        });\n+        res\n+    }\n+\n+    fn alloc(&mut self, item: &SyntaxNode) -> ErasedFileAstId {\n+        self.arena.alloc(SyntaxNodePtr::new(item))\n+    }\n+}\n+\n+/// Walks the subtree in bfs order, calling `f` for each node.\n+fn bfs(node: &SyntaxNode, mut f: impl FnMut(&SyntaxNode)) {\n+    let mut curr_layer = vec![node];\n+    let mut next_layer = vec![];\n+    while !curr_layer.is_empty() {\n+        curr_layer.drain(..).for_each(|node| {\n+            next_layer.extend(node.children());\n+            f(node);\n+        });\n+        std::mem::swap(&mut curr_layer, &mut next_layer);\n+    }\n+}"}, {"sha": "725bdd5cb3b3efc3311effe1be3f5993a5db359e", "filename": "crates/ra_hir/src/traits.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -0,0 +1,52 @@\n+//! HIR for trait definitions.\n+\n+use std::sync::Arc;\n+\n+use ra_syntax::ast::{self, NameOwner};\n+\n+use crate::{Function, Const, TypeAlias, Name, DefDatabase, Trait, ids::LocationCtx, name::AsName};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitData {\n+    name: Option<Name>,\n+    items: Vec<TraitItem>,\n+}\n+\n+impl TraitData {\n+    pub(crate) fn trait_data_query(db: &impl DefDatabase, tr: Trait) -> Arc<TraitData> {\n+        let (file_id, node) = tr.source(db);\n+        let name = node.name().map(|n| n.as_name());\n+        let module = tr.module(db);\n+        let ctx = LocationCtx::new(db, module, file_id);\n+        let items = if let Some(item_list) = node.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node.kind() {\n+                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(it) }.into(),\n+                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(it) }.into(),\n+                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(it) }.into(),\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TraitData { name, items })\n+    }\n+\n+    pub(crate) fn name(&self) -> &Option<Name> {\n+        &self.name\n+    }\n+\n+    pub(crate) fn items(&self) -> &[TraitItem] {\n+        &self.items\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum TraitItem {\n+    Function(Function),\n+    Const(Const),\n+    TypeAlias(TypeAlias),\n+    // Existential\n+}\n+impl_froms!(TraitItem: Function, Const, TypeAlias);"}, {"sha": "d42c61e9d345757bae3789428c88add9f6b84d79", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -14,7 +14,7 @@ pub(crate) mod display;\n use std::sync::Arc;\n use std::{fmt, mem};\n \n-use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase};\n+use crate::{Name, AdtDef, type_ref::Mutability, db::HirDatabase, Trait};\n \n pub(crate) use lower::{TypableDef, CallableDef, type_for_def, type_for_field, callable_item_sig};\n pub(crate) use infer::{infer, InferenceResult, InferTy};\n@@ -91,7 +91,7 @@ pub enum TypeCtor {\n /// A nominal type with (maybe 0) type parameters. This might be a primitive\n /// type like `bool`, a struct, tuple, function pointer, reference or\n /// several other things.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct ApplicationTy {\n     pub ctor: TypeCtor,\n     pub parameters: Substs,\n@@ -103,7 +103,7 @@ pub struct ApplicationTy {\n /// the same thing (but in a different way).\n ///\n /// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum Ty {\n     /// A nominal type with (maybe 0) type parameters. This might be a primitive\n     /// type like `bool`, a struct, tuple, function pointer, reference or\n@@ -132,7 +132,7 @@ pub enum Ty {\n }\n \n /// A list of substitutions for generic parameters.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs(Arc<[Ty]>);\n \n impl Substs {\n@@ -169,6 +169,21 @@ impl Substs {\n     }\n }\n \n+/// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n+/// Name to be bikeshedded: TraitBound? TraitImplements?\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TraitRef {\n+    /// FIXME name?\n+    trait_: Trait,\n+    substs: Substs,\n+}\n+\n+impl TraitRef {\n+    pub fn self_ty(&self) -> &Ty {\n+        &self.substs.0[0]\n+    }\n+}\n+\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "5731153216a4f801108e742828bc786f0d26ee8e", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -36,7 +36,9 @@ use crate::{\n     path::{GenericArgs, GenericArg},\n     adt::VariantDef,\n     resolve::{Resolver, Resolution},\n-    nameres::Namespace\n+    nameres::Namespace,\n+    ty::infer::diagnostics::InferenceDiagnostic,\n+    diagnostics::DiagnosticSink,\n };\n use super::{Ty, TypableDef, Substs, primitive, op, FnSig, ApplicationTy, TypeCtor};\n \n@@ -96,6 +98,7 @@ pub struct InferenceResult {\n     field_resolutions: FxHashMap<ExprId, StructField>,\n     /// For each associated item record what it resolves to\n     assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n+    diagnostics: Vec<InferenceDiagnostic>,\n     pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n     pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n }\n@@ -113,6 +116,14 @@ impl InferenceResult {\n     pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<ImplItem> {\n         self.assoc_resolutions.get(&id.into()).map(|it| *it)\n     }\n+    pub(crate) fn add_diagnostics(\n+        &self,\n+        db: &impl HirDatabase,\n+        owner: Function,\n+        sink: &mut DiagnosticSink,\n+    ) {\n+        self.diagnostics.iter().for_each(|it| it.add_to(db, owner, sink))\n+    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -143,6 +154,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n+    diagnostics: Vec<InferenceDiagnostic>,\n     /// The return type of the function being inferred.\n     return_ty: Ty,\n }\n@@ -155,6 +167,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             assoc_resolutions: FxHashMap::default(),\n             type_of_expr: ArenaMap::default(),\n             type_of_pat: ArenaMap::default(),\n+            diagnostics: Vec::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n@@ -181,6 +194,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             assoc_resolutions: self.assoc_resolutions,\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n+            diagnostics: self.diagnostics,\n         }\n     }\n \n@@ -807,7 +821,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::MethodCall { receiver, args, method_name, generic_args } => {\n                 let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n-                let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n+                let resolved =\n+                    receiver_ty.clone().lookup_method(self.db, method_name, &self.resolver);\n                 let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n                     Some((ty, func)) => {\n                         self.write_method_resolution(tgt_expr, func);\n@@ -915,9 +930,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::StructLit { path, fields, spread } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n-                for field in fields {\n+                for (field_idx, field) in fields.into_iter().enumerate() {\n                     let field_ty = def_id\n-                        .and_then(|it| it.field(self.db, &field.name))\n+                        .and_then(|it| match it.field(self.db, &field.name) {\n+                            Some(field) => Some(field),\n+                            None => {\n+                                self.diagnostics.push(InferenceDiagnostic::NoSuchField {\n+                                    expr: tgt_expr,\n+                                    field: field_idx,\n+                                });\n+                                None\n+                            }\n+                        })\n                         .map_or(Ty::Unknown, |field| field.ty(self.db))\n                         .subst(&substs);\n                     self.infer_expr(field.expr, &Expectation::has_type(field_ty));\n@@ -1244,3 +1268,29 @@ impl Expectation {\n         Expectation { ty: Ty::Unknown }\n     }\n }\n+\n+mod diagnostics {\n+    use crate::{expr::ExprId, diagnostics::{DiagnosticSink, NoSuchField}, HirDatabase, Function};\n+\n+    #[derive(Debug, PartialEq, Eq, Clone)]\n+    pub(super) enum InferenceDiagnostic {\n+        NoSuchField { expr: ExprId, field: usize },\n+    }\n+\n+    impl InferenceDiagnostic {\n+        pub(super) fn add_to(\n+            &self,\n+            db: &impl HirDatabase,\n+            owner: Function,\n+            sink: &mut DiagnosticSink,\n+        ) {\n+            match self {\n+                InferenceDiagnostic::NoSuchField { expr, field } => {\n+                    let (file, _) = owner.source(db);\n+                    let field = owner.body_source_map(db).field_syntax(*expr, *field);\n+                    sink.push(NoSuchField { file, field })\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3ac8dc46b0d747ebb5232f1a5cab6b2f3b9af88e", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -8,12 +8,12 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     HirDatabase, Module, Crate, Name, Function, Trait,\n-    ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n     ty::{Ty, TypeCtor},\n-    nameres::CrateModuleId,\n+    nameres::CrateModuleId, resolve::Resolver, traits::TraitItem\n \n };\n+use super::{ TraitRef, Substs};\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -38,7 +38,7 @@ pub struct CrateImplBlocks {\n     /// To make sense of the CrateModuleIds, we need the source root.\n     krate: Crate,\n     impls: FxHashMap<TyFingerprint, Vec<(CrateModuleId, ImplId)>>,\n-    impls_by_trait: FxHashMap<TraitId, Vec<(CrateModuleId, ImplId)>>,\n+    impls_by_trait: FxHashMap<Trait, Vec<(CrateModuleId, ImplId)>>,\n }\n \n impl CrateImplBlocks {\n@@ -56,8 +56,7 @@ impl CrateImplBlocks {\n         &'a self,\n         tr: &Trait,\n     ) -> impl Iterator<Item = ImplBlock> + 'a {\n-        let id = tr.id;\n-        self.impls_by_trait.get(&id).into_iter().flat_map(|i| i.iter()).map(\n+        self.impls_by_trait.get(&tr).into_iter().flat_map(|i| i.iter()).map(\n             move |(module_id, impl_id)| {\n                 let module = Module { krate: self.krate, module_id: *module_id };\n                 ImplBlock::from_id(module, *impl_id)\n@@ -73,18 +72,18 @@ impl CrateImplBlocks {\n \n             let target_ty = impl_block.target_ty(db);\n \n-            if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n-                self.impls\n-                    .entry(target_ty_fp)\n-                    .or_insert_with(Vec::new)\n-                    .push((module.module_id, impl_id));\n-            }\n-\n             if let Some(tr) = impl_block.target_trait(db) {\n                 self.impls_by_trait\n-                    .entry(tr.id)\n+                    .entry(tr)\n                     .or_insert_with(Vec::new)\n                     .push((module.module_id, impl_id));\n+            } else {\n+                if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n+                    self.impls\n+                        .entry(target_ty_fp)\n+                        .or_insert_with(Vec::new)\n+                        .push((module.module_id, impl_id));\n+                }\n             }\n         }\n \n@@ -109,6 +108,20 @@ impl CrateImplBlocks {\n     }\n }\n \n+/// Rudimentary check whether an impl exists for a given type and trait; this\n+/// will actually be done by chalk.\n+pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> bool {\n+    // FIXME use all trait impls in the whole crate graph\n+    let krate = trait_ref.trait_.module(db).krate(db);\n+    let krate = match krate {\n+        Some(krate) => krate,\n+        None => return false,\n+    };\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n+    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n+    impl_blocks.any(|impl_block| &impl_block.target_ty(db) == trait_ref.self_ty())\n+}\n+\n fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n     match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n@@ -120,20 +133,64 @@ fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n }\n \n impl Ty {\n-    // FIXME: cache this as a query?\n-    // - if so, what signature? (TyFingerprint, Name)?\n-    // - or maybe cache all names and def_ids of methods per fingerprint?\n     /// Look up the method with the given name, returning the actual autoderefed\n     /// receiver type (but without autoref applied yet).\n-    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<(Ty, Function)> {\n-        self.iterate_methods(db, |ty, f| {\n+    pub fn lookup_method(\n+        self,\n+        db: &impl HirDatabase,\n+        name: &Name,\n+        resolver: &Resolver,\n+    ) -> Option<(Ty, Function)> {\n+        // FIXME: trait methods should be used before autoderefs\n+        let inherent_method = self.clone().iterate_methods(db, |ty, f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n                 Some((ty.clone(), f))\n             } else {\n                 None\n             }\n-        })\n+        });\n+        inherent_method.or_else(|| self.lookup_trait_method(db, name, resolver))\n+    }\n+\n+    fn lookup_trait_method(\n+        self,\n+        db: &impl HirDatabase,\n+        name: &Name,\n+        resolver: &Resolver,\n+    ) -> Option<(Ty, Function)> {\n+        let mut candidates = Vec::new();\n+        for t in resolver.traits_in_scope() {\n+            let data = t.trait_data(db);\n+            for item in data.items() {\n+                match item {\n+                    &TraitItem::Function(m) => {\n+                        let sig = m.signature(db);\n+                        if sig.name() == name && sig.has_self_param() {\n+                            candidates.push((t, m));\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        // FIXME:\n+        //  - we might not actually be able to determine fully that the type\n+        //    implements the trait here; it's enough if we (well, Chalk) determine\n+        //    that it's possible.\n+        //  - when the trait method is picked, we need to register an\n+        //    'obligation' somewhere so that we later check that it's really\n+        //    implemented\n+        //  - both points go for additional requirements from where clauses as\n+        //    well (in fact, the 'implements' condition could just be considered a\n+        //    'where Self: Trait' clause)\n+        candidates.retain(|(t, _m)| {\n+            let trait_ref = TraitRef { trait_: *t, substs: Substs::single(self.clone()) };\n+            db.implements(trait_ref)\n+        });\n+        // FIXME if there's multiple candidates here, that's an ambiguity error\n+        let (_chosen_trait, chosen_method) = candidates.first()?;\n+        Some((self.clone(), *chosen_method))\n     }\n \n     // This would be nicer if it just returned an iterator, but that runs into"}, {"sha": "655f3c52237611b2897e2f0895fa1f80d90d8b3d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -1272,8 +1272,8 @@ fn test() {\n [241; 252) 'Struct::FOO': u32\n [262; 263) 'y': u32\n [266; 275) 'Enum::BAR': u32\n-[285; 286) 'z': u32\n-[289; 302) 'TraitTest::ID': u32\"###\n+[285; 286) 'z': {unknown}\n+[289; 302) 'TraitTest::ID': {unknown}\"###\n     );\n }\n \n@@ -1918,9 +1918,9 @@ fn test() {\n [110; 114) 'self': &{unknown}\n [170; 228) '{     ...i128 }': ()\n [176; 178) 'S1': S1\n-[176; 187) 'S1.method()': {unknown}\n+[176; 187) 'S1.method()': u32\n [203; 205) 'S2': S2\n-[203; 214) 'S2.method()': {unknown}\"###\n+[203; 214) 'S2.method()': i128\"###\n     );\n }\n \n@@ -1964,10 +1964,10 @@ mod bar_test {\n [169; 173) 'self': &{unknown}\n [300; 337) '{     ...     }': ()\n [310; 311) 'S': S\n-[310; 320) 'S.method()': {unknown}\n+[310; 320) 'S.method()': u32\n [416; 454) '{     ...     }': ()\n [426; 427) 'S': S\n-[426; 436) 'S.method()': {unknown}\"###\n+[426; 436) 'S.method()': i128\"###\n     );\n }\n \n@@ -2319,3 +2319,27 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }\n }\n+\n+#[test]\n+fn no_such_field_diagnostics() {\n+    let diagnostics = MockDatabase::with_files(\n+        r\"\n+        //- /lib.rs\n+        struct S { foo: i32, bar: () }\n+        impl S {\n+            fn new() -> S {\n+                S {\n+                    foo: 92,\n+                    baz: 62,\n+                }\n+            }\n+        }\n+        \",\n+    )\n+    .diagnostics();\n+\n+    assert_snapshot_matches!(diagnostics, @r###\"\n+\"baz: 62\": no such field\n+\"###\n+    );\n+}"}, {"sha": "45bab4e28b73bb58e6802f6eb3862897b9934eae", "filename": "crates/ra_ide_api/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2FCargo.toml?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -20,7 +20,6 @@ jemallocator = { version = \"0.1.9\", optional = true }\n jemalloc-ctl = { version = \"0.2.0\", optional = true }\n \n ra_syntax = { path = \"../ra_syntax\" }\n-ra_ide_api_light = { path = \"../ra_ide_api_light\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n ra_db = { path = \"../ra_db\" }\n ra_fmt = { path = \"../ra_fmt\" }"}, {"sha": "a4a086931bc0c4ff6897f0320cd8cf54fdb3a7b3", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -220,8 +220,8 @@ impl RootDatabase {\n         self.query(ra_db::ParseQuery).sweep(sweep);\n \n         self.query(hir::db::HirParseQuery).sweep(sweep);\n-        self.query(hir::db::FileItemsQuery).sweep(sweep);\n-        self.query(hir::db::FileItemQuery).sweep(sweep);\n+        self.query(hir::db::AstIdMapQuery).sweep(sweep);\n+        self.query(hir::db::AstIdToNodeQuery).sweep(sweep);\n \n         self.query(hir::db::RawItemsWithSourceMapQuery).sweep(sweep);\n         self.query(hir::db::BodyWithSourceMapQuery).sweep(sweep);"}, {"sha": "5a78e94d82225eb230b2643badf472a90bc5216b", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -1,10 +1,11 @@\n+use std::cell::RefCell;\n+\n use itertools::Itertools;\n-use hir::{Problem, source_binder};\n+use hir::{source_binder, diagnostics::{Diagnostic as _, DiagnosticSink}};\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n     ast::{self, AstNode},\n-\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n@@ -26,11 +27,31 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         check_unnecessary_braces_in_use_statement(&mut res, file_id, node);\n         check_struct_shorthand_initialization(&mut res, file_id, node);\n     }\n-\n+    let res = RefCell::new(res);\n+    let mut sink = DiagnosticSink::new(|d| {\n+        res.borrow_mut().push(Diagnostic {\n+            message: d.message(),\n+            range: d.highlight_range(),\n+            severity: Severity::Error,\n+            fix: None,\n+        })\n+    })\n+    .on::<hir::diagnostics::UnresolvedModule, _>(|d| {\n+        let source_root = db.file_source_root(d.file().original_file(db));\n+        let create_file = FileSystemEdit::CreateFile { source_root, path: d.candidate.clone() };\n+        let fix = SourceChange::file_system_edit(\"create module\", create_file);\n+        res.borrow_mut().push(Diagnostic {\n+            range: d.highlight_range(),\n+            message: d.message(),\n+            severity: Severity::Error,\n+            fix: Some(fix),\n+        })\n+    });\n     if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n-        check_module(&mut res, db, file_id, m);\n+        m.diagnostics(db, &mut sink);\n     };\n-    res\n+    drop(sink);\n+    res.into_inner()\n }\n \n fn syntax_errors(acc: &mut Vec<Diagnostic>, source_file: &SourceFile) {\n@@ -128,34 +149,12 @@ fn check_struct_shorthand_initialization(\n     Some(())\n }\n \n-fn check_module(\n-    acc: &mut Vec<Diagnostic>,\n-    db: &RootDatabase,\n-    file_id: FileId,\n-    module: hir::Module,\n-) {\n-    let source_root = db.file_source_root(file_id);\n-    for (name_node, problem) in module.problems(db) {\n-        let diag = match problem {\n-            Problem::UnresolvedModule { candidate } => {\n-                let create_file =\n-                    FileSystemEdit::CreateFile { source_root, path: candidate.clone() };\n-                let fix = SourceChange::file_system_edit(\"create module\", create_file);\n-                Diagnostic {\n-                    range: name_node.range(),\n-                    message: \"unresolved module\".to_string(),\n-                    severity: Severity::Error,\n-                    fix: Some(fix),\n-                }\n-            }\n-        };\n-        acc.push(diag)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test_utils::assert_eq_text;\n+    use insta::assert_debug_snapshot_matches;\n+\n+    use crate::mock_analysis::single_file;\n \n     use super::*;\n \n@@ -184,6 +183,34 @@ mod tests {\n         assert_eq_text!(after, &actual);\n     }\n \n+    #[test]\n+    fn test_unresolved_module_diagnostic() {\n+        let (analysis, file_id) = single_file(\"mod foo;\");\n+        let diagnostics = analysis.diagnostics(file_id).unwrap();\n+        assert_debug_snapshot_matches!(diagnostics, @r####\"[\n+    Diagnostic {\n+        message: \"unresolved module\",\n+        range: [0; 8),\n+        fix: Some(\n+            SourceChange {\n+                label: \"create module\",\n+                source_file_edits: [],\n+                file_system_edits: [\n+                    CreateFile {\n+                        source_root: SourceRootId(\n+                            0\n+                        ),\n+                        path: \"foo.rs\"\n+                    }\n+                ],\n+                cursor_position: None\n+            }\n+        ),\n+        severity: Error\n+    }\n+]\"####);\n+    }\n+\n     #[test]\n     fn test_check_unnecessary_braces_in_use_statement() {\n         check_not_applicable("}, {"sha": "9063f78a9fb350b29a116409667cf5cc3137ea80", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -6,9 +6,6 @@\n //! database, and the `ra_hir` crate, where majority of the analysis happens.\n //! However, IDE specific bits of the analysis (most notably completion) happen\n //! in this crate.\n-//!\n-//! The sibling `ra_ide_api_light` handles those bits of IDE functionality\n-//! which are restricted to a single file and need only syntax.\n \n // For proving that RootDatabase is RefUnwindSafe.\n #![recursion_limit = \"128\"]\n@@ -33,10 +30,11 @@ mod impls;\n mod assists;\n mod diagnostics;\n mod syntax_tree;\n-mod line_index;\n mod folding_ranges;\n+mod line_index;\n mod line_index_utils;\n mod join_lines;\n+mod structure;\n mod typing;\n mod matching_brace;\n \n@@ -72,9 +70,10 @@ pub use crate::{\n     line_index_utils::translate_offset_with_edit,\n     folding_ranges::{Fold, FoldKind},\n     syntax_highlighting::HighlightedRange,\n+    structure::{StructureNode, file_structure},\n     diagnostics::Severity,\n };\n-pub use ra_ide_api_light::StructureNode;\n+\n pub use ra_db::{\n     Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId,\n     Edition\n@@ -388,7 +387,7 @@ impl Analysis {\n     /// file outline.\n     pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n         let file = self.db.parse(file_id);\n-        ra_ide_api_light::file_structure(&file)\n+        structure::file_structure(&file)\n     }\n \n     /// Returns the set of folding ranges."}, {"sha": "27788c984623891c35d9639836daa391ef64c00c", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -28,7 +28,11 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n \n #[cfg(test)]\n mod tests {\n-    use crate::mock_analysis::analysis_and_position;\n+    use crate::{\n+        AnalysisChange, CrateGraph,\n+        mock_analysis::{analysis_and_position, MockAnalysis},\n+        Edition::Edition2018,\n+};\n \n     #[test]\n     fn test_resolve_parent_module() {\n@@ -59,4 +63,28 @@ mod tests {\n         let nav = analysis.parent_module(pos).unwrap().pop().unwrap();\n         nav.assert_match(\"baz MODULE FileId(1) [32; 44)\");\n     }\n+\n+    #[test]\n+    fn test_resolve_crate_root() {\n+        let mock = MockAnalysis::with_files(\n+            \"\n+        //- /bar.rs\n+        mod foo;\n+        //- /foo.rs\n+        // empty <|>\n+    \",\n+        );\n+        let root_file = mock.id_of(\"/bar.rs\");\n+        let mod_file = mock.id_of(\"/foo.rs\");\n+        let mut host = mock.analysis_host();\n+        assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n+\n+        let mut crate_graph = CrateGraph::default();\n+        let crate_id = crate_graph.add_crate_root(root_file, Edition2018);\n+        let mut change = AnalysisChange::new();\n+        change.set_crate_graph(crate_graph);\n+        host.apply_change(change);\n+\n+        assert_eq!(host.analysis().crate_for(mod_file).unwrap(), vec![crate_id]);\n+    }\n }"}, {"sha": "20bbf11a3867794ea7dc44855ff2841062415432", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -216,9 +216,55 @@ mod tests {\n     use crate::{\n         mock_analysis::single_file_with_position,\n         mock_analysis::analysis_and_position,\n-        FileId\n+        FileId, ReferenceSearchResult\n };\n \n+    #[test]\n+    fn test_find_all_refs_for_local() {\n+        let code = r#\"\n+    fn main() {\n+        let mut i = 1;\n+        let j = 1;\n+        i = i<|> + j;\n+\n+        {\n+            i = 0;\n+        }\n+\n+        i = 5;\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 5);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_for_param_inside() {\n+        let code = r#\"\n+    fn foo(i : u32) -> u32 {\n+        i<|>\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_for_fn_param() {\n+        let code = r#\"\n+    fn foo(i<|> : u32) -> u32 {\n+        i\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    fn get_all_refs(text: &str) -> ReferenceSearchResult {\n+        let (analysis, position) = single_file_with_position(text);\n+        analysis.find_all_refs(position).unwrap().unwrap()\n+    }\n+\n     #[test]\n     fn test_rename_for_local() {\n         test_rename("}, {"sha": "2efa8e22cb39047946ffe6719f05bde8ce8f7b81", "filename": "crates/ra_ide_api/src/snapshots/tests__file_structure.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__file_structure.snap", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__file_structure.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__file_structure.snap?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -1,7 +1,7 @@\n ---\n created: \"2019-02-05T22:03:50.763530100Z\"\n creator: insta@0.6.1\n-source: crates/ra_ide_api_light/src/structure.rs\n+source: crates/ra_ide_api/src/structure.rs\n expression: structure\n ---\n [", "previous_filename": "crates/ra_ide_api_light/src/snapshots/tests__file_structure.snap"}, {"sha": "ec2c9bbc6557b36a2b0d5e1f04ea6e28e8e1ad86", "filename": "crates/ra_ide_api/src/structure.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fstructure.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "previous_filename": "crates/ra_ide_api_light/src/structure.rs"}, {"sha": "0eadc4e71980aa189297762a9495f92cfccc223b", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -270,3 +270,61 @@ fn to_file_symbol(node: &SyntaxNode, file_id: FileId) -> Option<FileSymbol> {\n         container_name: None,\n     })\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_syntax::SmolStr;\n+    use crate::{\n+        navigation_target::NavigationTarget,\n+        mock_analysis::single_file,\n+        Query,\n+};\n+\n+    #[test]\n+    fn test_world_symbols_with_no_container() {\n+        let code = r#\"\n+    enum FooInner { }\n+    \"#;\n+\n+        let mut symbols = get_symbols_matching(code, \"FooInner\");\n+\n+        let s = symbols.pop().unwrap();\n+\n+        assert_eq!(s.name(), \"FooInner\");\n+        assert!(s.container_name().is_none());\n+    }\n+\n+    #[test]\n+    fn test_world_symbols_include_container_name() {\n+        let code = r#\"\n+fn foo() {\n+    enum FooInner { }\n+}\n+    \"#;\n+\n+        let mut symbols = get_symbols_matching(code, \"FooInner\");\n+\n+        let s = symbols.pop().unwrap();\n+\n+        assert_eq!(s.name(), \"FooInner\");\n+        assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n+\n+        let code = r#\"\n+mod foo {\n+    struct FooInner;\n+}\n+    \"#;\n+\n+        let mut symbols = get_symbols_matching(code, \"FooInner\");\n+\n+        let s = symbols.pop().unwrap();\n+\n+        assert_eq!(s.name(), \"FooInner\");\n+        assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n+    }\n+\n+    fn get_symbols_matching(text: &str, query: &str) -> Vec<NavigationTarget> {\n+        let (analysis, _) = single_file(text);\n+        analysis.symbol_search(Query::new(query.into())).unwrap()\n+    }\n+}"}, {"sha": "276f8a8c8acd5207c9683dc5b6f5a4356851f96e", "filename": "crates/ra_ide_api/src/syntax_tree.rs", "status": "modified", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -85,3 +85,260 @@ fn syntax_tree_for_token<T: AstToken>(node: &T, text_range: TextRange) -> Option\n \r\n     None\r\n }\r\n+\r\n+#[cfg(test)]\r\n+mod tests {\r\n+    use crate::mock_analysis::{single_file, single_file_with_range};\r\n+\r\n+    #[test]\r\n+    fn test_syntax_tree_without_range() {\r\n+        // Basic syntax\r\n+        let (analysis, file_id) = single_file(r#\"fn foo() {}\"#);\r\n+        let syn = analysis.syntax_tree(file_id, None);\r\n+\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+SOURCE_FILE@[0; 11)\r\n+  FN_DEF@[0; 11)\r\n+    FN_KW@[0; 2)\r\n+    WHITESPACE@[2; 3)\r\n+    NAME@[3; 6)\r\n+      IDENT@[3; 6) \"foo\"\r\n+    PARAM_LIST@[6; 8)\r\n+      L_PAREN@[6; 7)\r\n+      R_PAREN@[7; 8)\r\n+    WHITESPACE@[8; 9)\r\n+    BLOCK@[9; 11)\r\n+      L_CURLY@[9; 10)\r\n+      R_CURLY@[10; 11)\r\n+    \"#\r\n+            .trim()\r\n+        );\r\n+\r\n+        let (analysis, file_id) = single_file(\r\n+            r#\"\r\n+fn test() {\r\n+    assert!(\"\r\n+    fn foo() {\r\n+    }\r\n+    \", \"\");\r\n+}\"#\r\n+            .trim(),\r\n+        );\r\n+        let syn = analysis.syntax_tree(file_id, None);\r\n+\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+SOURCE_FILE@[0; 60)\r\n+  FN_DEF@[0; 60)\r\n+    FN_KW@[0; 2)\r\n+    WHITESPACE@[2; 3)\r\n+    NAME@[3; 7)\r\n+      IDENT@[3; 7) \"test\"\r\n+    PARAM_LIST@[7; 9)\r\n+      L_PAREN@[7; 8)\r\n+      R_PAREN@[8; 9)\r\n+    WHITESPACE@[9; 10)\r\n+    BLOCK@[10; 60)\r\n+      L_CURLY@[10; 11)\r\n+      WHITESPACE@[11; 16)\r\n+      EXPR_STMT@[16; 58)\r\n+        MACRO_CALL@[16; 57)\r\n+          PATH@[16; 22)\r\n+            PATH_SEGMENT@[16; 22)\r\n+              NAME_REF@[16; 22)\r\n+                IDENT@[16; 22) \"assert\"\r\n+          EXCL@[22; 23)\r\n+          TOKEN_TREE@[23; 57)\r\n+            L_PAREN@[23; 24)\r\n+            STRING@[24; 52)\r\n+            COMMA@[52; 53)\r\n+            WHITESPACE@[53; 54)\r\n+            STRING@[54; 56)\r\n+            R_PAREN@[56; 57)\r\n+        SEMI@[57; 58)\r\n+      WHITESPACE@[58; 59)\r\n+      R_CURLY@[59; 60)\r\n+    \"#\r\n+            .trim()\r\n+        );\r\n+    }\r\n+\r\n+    #[test]\r\n+    fn test_syntax_tree_with_range() {\r\n+        let (analysis, range) = single_file_with_range(r#\"<|>fn foo() {}<|>\"#.trim());\r\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range));\r\n+\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+FN_DEF@[0; 11)\r\n+  FN_KW@[0; 2)\r\n+  WHITESPACE@[2; 3)\r\n+  NAME@[3; 6)\r\n+    IDENT@[3; 6) \"foo\"\r\n+  PARAM_LIST@[6; 8)\r\n+    L_PAREN@[6; 7)\r\n+    R_PAREN@[7; 8)\r\n+  WHITESPACE@[8; 9)\r\n+  BLOCK@[9; 11)\r\n+    L_CURLY@[9; 10)\r\n+    R_CURLY@[10; 11)\r\n+    \"#\r\n+            .trim()\r\n+        );\r\n+\r\n+        let (analysis, range) = single_file_with_range(\r\n+            r#\"fn test() {\r\n+    <|>assert!(\"\r\n+    fn foo() {\r\n+    }\r\n+    \", \"\");<|>\r\n+}\"#\r\n+            .trim(),\r\n+        );\r\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range));\r\n+\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+EXPR_STMT@[16; 58)\r\n+  MACRO_CALL@[16; 57)\r\n+    PATH@[16; 22)\r\n+      PATH_SEGMENT@[16; 22)\r\n+        NAME_REF@[16; 22)\r\n+          IDENT@[16; 22) \"assert\"\r\n+    EXCL@[22; 23)\r\n+    TOKEN_TREE@[23; 57)\r\n+      L_PAREN@[23; 24)\r\n+      STRING@[24; 52)\r\n+      COMMA@[52; 53)\r\n+      WHITESPACE@[53; 54)\r\n+      STRING@[54; 56)\r\n+      R_PAREN@[56; 57)\r\n+  SEMI@[57; 58)\r\n+    \"#\r\n+            .trim()\r\n+        );\r\n+    }\r\n+\r\n+    #[test]\r\n+    fn test_syntax_tree_inside_string() {\r\n+        let (analysis, range) = single_file_with_range(\r\n+            r#\"fn test() {\r\n+    assert!(\"\r\n+<|>fn foo() {\r\n+}<|>\r\n+fn bar() {\r\n+}\r\n+    \", \"\");\r\n+}\"#\r\n+            .trim(),\r\n+        );\r\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range));\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+SOURCE_FILE@[0; 12)\r\n+  FN_DEF@[0; 12)\r\n+    FN_KW@[0; 2)\r\n+    WHITESPACE@[2; 3)\r\n+    NAME@[3; 6)\r\n+      IDENT@[3; 6) \"foo\"\r\n+    PARAM_LIST@[6; 8)\r\n+      L_PAREN@[6; 7)\r\n+      R_PAREN@[7; 8)\r\n+    WHITESPACE@[8; 9)\r\n+    BLOCK@[9; 12)\r\n+      L_CURLY@[9; 10)\r\n+      WHITESPACE@[10; 11)\r\n+      R_CURLY@[11; 12)\r\n+\"#\r\n+            .trim()\r\n+        );\r\n+\r\n+        // With a raw string\r\n+        let (analysis, range) = single_file_with_range(\r\n+            r###\"fn test() {\r\n+    assert!(r#\"\r\n+<|>fn foo() {\r\n+}<|>\r\n+fn bar() {\r\n+}\r\n+    \"#, \"\");\r\n+}\"###\r\n+                .trim(),\r\n+        );\r\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range));\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+SOURCE_FILE@[0; 12)\r\n+  FN_DEF@[0; 12)\r\n+    FN_KW@[0; 2)\r\n+    WHITESPACE@[2; 3)\r\n+    NAME@[3; 6)\r\n+      IDENT@[3; 6) \"foo\"\r\n+    PARAM_LIST@[6; 8)\r\n+      L_PAREN@[6; 7)\r\n+      R_PAREN@[7; 8)\r\n+    WHITESPACE@[8; 9)\r\n+    BLOCK@[9; 12)\r\n+      L_CURLY@[9; 10)\r\n+      WHITESPACE@[10; 11)\r\n+      R_CURLY@[11; 12)\r\n+\"#\r\n+            .trim()\r\n+        );\r\n+\r\n+        // With a raw string\r\n+        let (analysis, range) = single_file_with_range(\r\n+            r###\"fn test() {\r\n+    assert!(r<|>#\"\r\n+fn foo() {\r\n+}\r\n+fn bar() {\r\n+}\"<|>#, \"\");\r\n+}\"###\r\n+                .trim(),\r\n+        );\r\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range));\r\n+        assert_eq!(\r\n+            syn.trim(),\r\n+            r#\"\r\n+SOURCE_FILE@[0; 25)\r\n+  FN_DEF@[0; 12)\r\n+    FN_KW@[0; 2)\r\n+    WHITESPACE@[2; 3)\r\n+    NAME@[3; 6)\r\n+      IDENT@[3; 6) \"foo\"\r\n+    PARAM_LIST@[6; 8)\r\n+      L_PAREN@[6; 7)\r\n+      R_PAREN@[7; 8)\r\n+    WHITESPACE@[8; 9)\r\n+    BLOCK@[9; 12)\r\n+      L_CURLY@[9; 10)\r\n+      WHITESPACE@[10; 11)\r\n+      R_CURLY@[11; 12)\r\n+  WHITESPACE@[12; 13)\r\n+  FN_DEF@[13; 25)\r\n+    FN_KW@[13; 15)\r\n+    WHITESPACE@[15; 16)\r\n+    NAME@[16; 19)\r\n+      IDENT@[16; 19) \"bar\"\r\n+    PARAM_LIST@[19; 21)\r\n+      L_PAREN@[19; 20)\r\n+      R_PAREN@[20; 21)\r\n+    WHITESPACE@[21; 22)\r\n+    BLOCK@[22; 25)\r\n+      L_CURLY@[22; 23)\r\n+      WHITESPACE@[23; 24)\r\n+      R_CURLY@[24; 25)\r\n+\r\n+\"#\r\n+            .trim()\r\n+        );\r\n+    }\r\n+}\r"}, {"sha": "0f0766f621408e5bab834843ad710ae116c38c4e", "filename": "crates/ra_ide_api/tests/test/main.rs", "status": "removed", "additions": 0, "deletions": 392, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/9b73f809596e955216dde24fcf921d6985a1a767/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b73f809596e955216dde24fcf921d6985a1a767/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs?ref=9b73f809596e955216dde24fcf921d6985a1a767", "patch": "@@ -1,392 +0,0 @@\n-use insta::assert_debug_snapshot_matches;\n-use ra_ide_api::{\n-    mock_analysis::{single_file, single_file_with_position, single_file_with_range, MockAnalysis},\n-    AnalysisChange, CrateGraph, Edition::Edition2018, Query, NavigationTarget,\n-    ReferenceSearchResult,\n-};\n-use ra_syntax::SmolStr;\n-\n-#[test]\n-fn test_unresolved_module_diagnostic() {\n-    let (analysis, file_id) = single_file(\"mod foo;\");\n-    let diagnostics = analysis.diagnostics(file_id).unwrap();\n-    assert_debug_snapshot_matches!(\"unresolved_module_diagnostic\", &diagnostics);\n-}\n-\n-// FIXME: move this test to hir\n-#[test]\n-fn test_unresolved_module_diagnostic_no_diag_for_inline_mode() {\n-    let (analysis, file_id) = single_file(\"mod foo {}\");\n-    let diagnostics = analysis.diagnostics(file_id).unwrap();\n-    assert!(diagnostics.is_empty());\n-}\n-\n-#[test]\n-fn test_resolve_crate_root() {\n-    let mock = MockAnalysis::with_files(\n-        \"\n-        //- /bar.rs\n-        mod foo;\n-        //- /foo.rs\n-        // empty <|>\n-    \",\n-    );\n-    let root_file = mock.id_of(\"/bar.rs\");\n-    let mod_file = mock.id_of(\"/foo.rs\");\n-    let mut host = mock.analysis_host();\n-    assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n-\n-    let mut crate_graph = CrateGraph::default();\n-    let crate_id = crate_graph.add_crate_root(root_file, Edition2018);\n-    let mut change = AnalysisChange::new();\n-    change.set_crate_graph(crate_graph);\n-    host.apply_change(change);\n-\n-    assert_eq!(host.analysis().crate_for(mod_file).unwrap(), vec![crate_id]);\n-}\n-\n-fn get_all_refs(text: &str) -> ReferenceSearchResult {\n-    let (analysis, position) = single_file_with_position(text);\n-    analysis.find_all_refs(position).unwrap().unwrap()\n-}\n-\n-fn get_symbols_matching(text: &str, query: &str) -> Vec<NavigationTarget> {\n-    let (analysis, _) = single_file(text);\n-    analysis.symbol_search(Query::new(query.into())).unwrap()\n-}\n-\n-#[test]\n-fn test_find_all_refs_for_local() {\n-    let code = r#\"\n-    fn main() {\n-        let mut i = 1;\n-        let j = 1;\n-        i = i<|> + j;\n-\n-        {\n-            i = 0;\n-        }\n-\n-        i = 5;\n-    }\"#;\n-\n-    let refs = get_all_refs(code);\n-    assert_eq!(refs.len(), 5);\n-}\n-\n-#[test]\n-fn test_find_all_refs_for_param_inside() {\n-    let code = r#\"\n-    fn foo(i : u32) -> u32 {\n-        i<|>\n-    }\"#;\n-\n-    let refs = get_all_refs(code);\n-    assert_eq!(refs.len(), 2);\n-}\n-\n-#[test]\n-fn test_find_all_refs_for_fn_param() {\n-    let code = r#\"\n-    fn foo(i<|> : u32) -> u32 {\n-        i\n-    }\"#;\n-\n-    let refs = get_all_refs(code);\n-    assert_eq!(refs.len(), 2);\n-}\n-\n-#[test]\n-fn test_world_symbols_with_no_container() {\n-    let code = r#\"\n-    enum FooInner { }\n-    \"#;\n-\n-    let mut symbols = get_symbols_matching(code, \"FooInner\");\n-\n-    let s = symbols.pop().unwrap();\n-\n-    assert_eq!(s.name(), \"FooInner\");\n-    assert!(s.container_name().is_none());\n-}\n-\n-#[test]\n-fn test_world_symbols_include_container_name() {\n-    let code = r#\"\n-fn foo() {\n-    enum FooInner { }\n-}\n-    \"#;\n-\n-    let mut symbols = get_symbols_matching(code, \"FooInner\");\n-\n-    let s = symbols.pop().unwrap();\n-\n-    assert_eq!(s.name(), \"FooInner\");\n-    assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n-\n-    let code = r#\"\n-mod foo {\n-    struct FooInner;\n-}\n-    \"#;\n-\n-    let mut symbols = get_symbols_matching(code, \"FooInner\");\n-\n-    let s = symbols.pop().unwrap();\n-\n-    assert_eq!(s.name(), \"FooInner\");\n-    assert_eq!(s.container_name(), Some(&SmolStr::new(\"foo\")));\n-}\n-\n-#[test]\n-fn test_syntax_tree_without_range() {\n-    // Basic syntax\n-    let (analysis, file_id) = single_file(r#\"fn foo() {}\"#);\n-    let syn = analysis.syntax_tree(file_id, None);\n-\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-SOURCE_FILE@[0; 11)\n-  FN_DEF@[0; 11)\n-    FN_KW@[0; 2)\n-    WHITESPACE@[2; 3)\n-    NAME@[3; 6)\n-      IDENT@[3; 6) \"foo\"\n-    PARAM_LIST@[6; 8)\n-      L_PAREN@[6; 7)\n-      R_PAREN@[7; 8)\n-    WHITESPACE@[8; 9)\n-    BLOCK@[9; 11)\n-      L_CURLY@[9; 10)\n-      R_CURLY@[10; 11)\n-    \"#\n-        .trim()\n-    );\n-\n-    let (analysis, file_id) = single_file(\n-        r#\"\n-fn test() {\n-    assert!(\"\n-    fn foo() {\n-    }\n-    \", \"\");\n-}\"#\n-        .trim(),\n-    );\n-    let syn = analysis.syntax_tree(file_id, None);\n-\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-SOURCE_FILE@[0; 60)\n-  FN_DEF@[0; 60)\n-    FN_KW@[0; 2)\n-    WHITESPACE@[2; 3)\n-    NAME@[3; 7)\n-      IDENT@[3; 7) \"test\"\n-    PARAM_LIST@[7; 9)\n-      L_PAREN@[7; 8)\n-      R_PAREN@[8; 9)\n-    WHITESPACE@[9; 10)\n-    BLOCK@[10; 60)\n-      L_CURLY@[10; 11)\n-      WHITESPACE@[11; 16)\n-      EXPR_STMT@[16; 58)\n-        MACRO_CALL@[16; 57)\n-          PATH@[16; 22)\n-            PATH_SEGMENT@[16; 22)\n-              NAME_REF@[16; 22)\n-                IDENT@[16; 22) \"assert\"\n-          EXCL@[22; 23)\n-          TOKEN_TREE@[23; 57)\n-            L_PAREN@[23; 24)\n-            STRING@[24; 52)\n-            COMMA@[52; 53)\n-            WHITESPACE@[53; 54)\n-            STRING@[54; 56)\n-            R_PAREN@[56; 57)\n-        SEMI@[57; 58)\n-      WHITESPACE@[58; 59)\n-      R_CURLY@[59; 60)\n-    \"#\n-        .trim()\n-    );\n-}\n-\n-#[test]\n-fn test_syntax_tree_with_range() {\n-    let (analysis, range) = single_file_with_range(r#\"<|>fn foo() {}<|>\"#.trim());\n-    let syn = analysis.syntax_tree(range.file_id, Some(range.range));\n-\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-FN_DEF@[0; 11)\n-  FN_KW@[0; 2)\n-  WHITESPACE@[2; 3)\n-  NAME@[3; 6)\n-    IDENT@[3; 6) \"foo\"\n-  PARAM_LIST@[6; 8)\n-    L_PAREN@[6; 7)\n-    R_PAREN@[7; 8)\n-  WHITESPACE@[8; 9)\n-  BLOCK@[9; 11)\n-    L_CURLY@[9; 10)\n-    R_CURLY@[10; 11)\n-    \"#\n-        .trim()\n-    );\n-\n-    let (analysis, range) = single_file_with_range(\n-        r#\"fn test() {\n-    <|>assert!(\"\n-    fn foo() {\n-    }\n-    \", \"\");<|>\n-}\"#\n-        .trim(),\n-    );\n-    let syn = analysis.syntax_tree(range.file_id, Some(range.range));\n-\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-EXPR_STMT@[16; 58)\n-  MACRO_CALL@[16; 57)\n-    PATH@[16; 22)\n-      PATH_SEGMENT@[16; 22)\n-        NAME_REF@[16; 22)\n-          IDENT@[16; 22) \"assert\"\n-    EXCL@[22; 23)\n-    TOKEN_TREE@[23; 57)\n-      L_PAREN@[23; 24)\n-      STRING@[24; 52)\n-      COMMA@[52; 53)\n-      WHITESPACE@[53; 54)\n-      STRING@[54; 56)\n-      R_PAREN@[56; 57)\n-  SEMI@[57; 58)\n-    \"#\n-        .trim()\n-    );\n-}\n-\n-#[test]\n-fn test_syntax_tree_inside_string() {\n-    let (analysis, range) = single_file_with_range(\n-        r#\"fn test() {\n-    assert!(\"\n-<|>fn foo() {\n-}<|>\n-fn bar() {\n-}\n-    \", \"\");\n-}\"#\n-        .trim(),\n-    );\n-    let syn = analysis.syntax_tree(range.file_id, Some(range.range));\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-SOURCE_FILE@[0; 12)\n-  FN_DEF@[0; 12)\n-    FN_KW@[0; 2)\n-    WHITESPACE@[2; 3)\n-    NAME@[3; 6)\n-      IDENT@[3; 6) \"foo\"\n-    PARAM_LIST@[6; 8)\n-      L_PAREN@[6; 7)\n-      R_PAREN@[7; 8)\n-    WHITESPACE@[8; 9)\n-    BLOCK@[9; 12)\n-      L_CURLY@[9; 10)\n-      WHITESPACE@[10; 11)\n-      R_CURLY@[11; 12)\n-\"#\n-        .trim()\n-    );\n-\n-    // With a raw string\n-    let (analysis, range) = single_file_with_range(\n-        r###\"fn test() {\n-    assert!(r#\"\n-<|>fn foo() {\n-}<|>\n-fn bar() {\n-}\n-    \"#, \"\");\n-}\"###\n-            .trim(),\n-    );\n-    let syn = analysis.syntax_tree(range.file_id, Some(range.range));\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-SOURCE_FILE@[0; 12)\n-  FN_DEF@[0; 12)\n-    FN_KW@[0; 2)\n-    WHITESPACE@[2; 3)\n-    NAME@[3; 6)\n-      IDENT@[3; 6) \"foo\"\n-    PARAM_LIST@[6; 8)\n-      L_PAREN@[6; 7)\n-      R_PAREN@[7; 8)\n-    WHITESPACE@[8; 9)\n-    BLOCK@[9; 12)\n-      L_CURLY@[9; 10)\n-      WHITESPACE@[10; 11)\n-      R_CURLY@[11; 12)\n-\"#\n-        .trim()\n-    );\n-\n-    // With a raw string\n-    let (analysis, range) = single_file_with_range(\n-        r###\"fn test() {\n-    assert!(r<|>#\"\n-fn foo() {\n-}\n-fn bar() {\n-}\"<|>#, \"\");\n-}\"###\n-            .trim(),\n-    );\n-    let syn = analysis.syntax_tree(range.file_id, Some(range.range));\n-    assert_eq!(\n-        syn.trim(),\n-        r#\"\n-SOURCE_FILE@[0; 25)\n-  FN_DEF@[0; 12)\n-    FN_KW@[0; 2)\n-    WHITESPACE@[2; 3)\n-    NAME@[3; 6)\n-      IDENT@[3; 6) \"foo\"\n-    PARAM_LIST@[6; 8)\n-      L_PAREN@[6; 7)\n-      R_PAREN@[7; 8)\n-    WHITESPACE@[8; 9)\n-    BLOCK@[9; 12)\n-      L_CURLY@[9; 10)\n-      WHITESPACE@[10; 11)\n-      R_CURLY@[11; 12)\n-  WHITESPACE@[12; 13)\n-  FN_DEF@[13; 25)\n-    FN_KW@[13; 15)\n-    WHITESPACE@[15; 16)\n-    NAME@[16; 19)\n-      IDENT@[16; 19) \"bar\"\n-    PARAM_LIST@[19; 21)\n-      L_PAREN@[19; 20)\n-      R_PAREN@[20; 21)\n-    WHITESPACE@[21; 22)\n-    BLOCK@[22; 25)\n-      L_CURLY@[22; 23)\n-      WHITESPACE@[23; 24)\n-      R_CURLY@[24; 25)\n-\n-\"#\n-        .trim()\n-    );\n-}"}, {"sha": "5bb9538922312ebadc85efca82ae623c143649fa", "filename": "crates/ra_ide_api/tests/test/snapshots/test__unresolved_module_diagnostic.snap", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9b73f809596e955216dde24fcf921d6985a1a767/crates%2Fra_ide_api%2Ftests%2Ftest%2Fsnapshots%2Ftest__unresolved_module_diagnostic.snap", "raw_url": "https://github.com/rust-lang/rust/raw/9b73f809596e955216dde24fcf921d6985a1a767/crates%2Fra_ide_api%2Ftests%2Ftest%2Fsnapshots%2Ftest__unresolved_module_diagnostic.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Ftests%2Ftest%2Fsnapshots%2Ftest__unresolved_module_diagnostic.snap?ref=9b73f809596e955216dde24fcf921d6985a1a767", "patch": "@@ -1,28 +0,0 @@\n----\n-created: \"2019-01-22T14:45:01.486985900+00:00\"\n-creator: insta@0.4.0\n-expression: \"&diagnostics\"\n-source: \"crates\\\\ra_ide_api\\\\tests\\\\test\\\\main.rs\"\n----\n-[\n-    Diagnostic {\n-        message: \"unresolved module\",\n-        range: [0; 8),\n-        fix: Some(\n-            SourceChange {\n-                label: \"create module\",\n-                source_file_edits: [],\n-                file_system_edits: [\n-                    CreateFile {\n-                        source_root: SourceRootId(\n-                            0\n-                        ),\n-                        path: \"foo.rs\"\n-                    }\n-                ],\n-                cursor_position: None\n-            }\n-        ),\n-        severity: Error\n-    }\n-]"}, {"sha": "4e69f5325b58c1b60e52a2e3d58289871f178724", "filename": "crates/ra_ide_api_light/Cargo.toml", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b73f809596e955216dde24fcf921d6985a1a767/crates%2Fra_ide_api_light%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9b73f809596e955216dde24fcf921d6985a1a767/crates%2Fra_ide_api_light%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2FCargo.toml?ref=9b73f809596e955216dde24fcf921d6985a1a767", "patch": "@@ -1,26 +0,0 @@\n-[package]\n-edition = \"2018\"\n-name = \"ra_ide_api_light\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n-publish = false\n-\n-[dependencies]\n-itertools = \"0.8.0\"\n-superslice = \"1.0.0\"\n-join_to_string = \"0.1.1\"\n-rustc-hash = \"1.0\"\n-\n-ra_syntax = { path = \"../ra_syntax\" }\n-ra_text_edit = { path = \"../ra_text_edit\" }\n-ra_fmt = { path = \"../ra_fmt\" }\n-\n-[dev-dependencies]\n-test_utils = { path = \"../test_utils\" }\n-insta = \"0.7.0\"\n-\n-[dev-dependencies.proptest]\n-version = \"0.9.0\"\n-# Disable `fork` feature to allow compiling on webassembly\n-default-features = false\n-features = [\"std\", \"bit-set\", \"break-dead-code\"]"}, {"sha": "df7f144b627c5121bb3cd7a41b881e4bca7f8268", "filename": "crates/ra_ide_api_light/src/lib.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b73f809596e955216dde24fcf921d6985a1a767/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b73f809596e955216dde24fcf921d6985a1a767/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs?ref=9b73f809596e955216dde24fcf921d6985a1a767", "patch": "@@ -1,12 +0,0 @@\n-//! This crate provides those IDE features which use only a single file.\n-//!\n-//! This usually means functions which take syntax tree as an input and produce\n-//! an edit or some auxiliary info.\n-\n-mod structure;\n-\n-use ra_syntax::TextRange;\n-\n-pub use crate::{\n-    structure::{file_structure, StructureNode},\n-};"}, {"sha": "b2ffeff8c7abda48dd3ec38ae4fc26097f757b53", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -184,6 +184,10 @@ fn name_ref(p: &mut Parser) {\n         let m = p.start();\n         p.bump();\n         m.complete(p, NAME_REF);\n+    } else if p.at(SELF_KW) {\n+        let m = p.start();\n+        p.bump();\n+        m.complete(p, SELF_KW);\n     } else {\n         p.err_and_bump(\"expected identifier\");\n     }"}, {"sha": "47a37e4d19c7475baac8bc99790cb5e79f5fe1a7", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -4061,7 +4061,11 @@ impl ast::NameOwner for TraitDef {}\n impl ast::AttrsOwner for TraitDef {}\n impl ast::DocCommentsOwner for TraitDef {}\n impl ast::TypeParamsOwner for TraitDef {}\n-impl TraitDef {}\n+impl TraitDef {\n+    pub fn item_list(&self) -> Option<&ItemList> {\n+        super::child_opt(self)\n+    }\n+}\n \n // TrueKw\n #[derive(Debug, PartialEq, Eq, Hash)]"}, {"sha": "ad6d74162b94b6f871896d96955d8f306162c2d5", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -292,7 +292,10 @@ Grammar(\n         ], options: [[\"variant_list\", \"EnumVariantList\"]] ),\n         \"EnumVariantList\": ( collections: [[\"variants\", \"EnumVariant\"]] ),\n         \"EnumVariant\": ( traits: [\"NameOwner\", \"DocCommentsOwner\", \"AttrsOwner\"], options: [\"Expr\"] ),\n-        \"TraitDef\": ( traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\", \"TypeParamsOwner\"] ),\n+        \"TraitDef\": (\n+            traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\", \"TypeParamsOwner\"],\n+            options: [\"ItemList\"]\n+        ),\n         \"Module\": (\n             traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\" ],\n             options: [ \"ItemList\" ]"}, {"sha": "d8de1c4c1b535ee9ce554b65e7e3df8d9fb2d2f3", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -64,6 +64,12 @@ impl<N: AstNode> AstPtr<N> {\n     }\n }\n \n+impl<N: AstNode> From<AstPtr<N>> for SyntaxNodePtr {\n+    fn from(ptr: AstPtr<N>) -> SyntaxNodePtr {\n+        ptr.raw\n+    }\n+}\n+\n #[test]\n fn test_local_syntax_ptr() {\n     use crate::{ast, AstNode};"}, {"sha": "ab81a608cb511936bf239ac1e35eb82e24929ad6", "filename": "crates/ra_syntax/tests/data/parser/ok/0007_extern_crate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0007_extern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0007_extern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0007_extern_crate.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -1,2 +1,3 @@\n extern crate foo;\n extern crate foo as bar;\n+extern crate self as baz;"}, {"sha": "0176260c1450740ce2b778f9c6ad5d19565008f5", "filename": "crates/ra_syntax/tests/data/parser/ok/0007_extern_crate.txt", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0007_extern_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0007_extern_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Fok%2F0007_extern_crate.txt?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -1,4 +1,4 @@\n-SOURCE_FILE@[0; 43)\n+SOURCE_FILE@[0; 69)\n   EXTERN_CRATE_ITEM@[0; 17)\n     EXTERN_KW@[0; 6)\n     WHITESPACE@[6; 7)\n@@ -23,3 +23,18 @@ SOURCE_FILE@[0; 43)\n         IDENT@[38; 41) \"bar\"\n     SEMI@[41; 42)\n   WHITESPACE@[42; 43)\n+  EXTERN_CRATE_ITEM@[43; 68)\n+    EXTERN_KW@[43; 49)\n+    WHITESPACE@[49; 50)\n+    CRATE_KW@[50; 55)\n+    WHITESPACE@[55; 56)\n+    SELF_KW@[56; 60)\n+      SELF_KW@[56; 60)\n+    WHITESPACE@[60; 61)\n+    ALIAS@[61; 67)\n+      AS_KW@[61; 63)\n+      WHITESPACE@[63; 64)\n+      NAME@[64; 67)\n+        IDENT@[64; 67) \"baz\"\n+    SEMI@[67; 68)\n+  WHITESPACE@[68; 69)"}, {"sha": "11b52ccb7f060625e4b3e1775c857689daae56e1", "filename": "crates/tools/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Ftools%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/crates%2Ftools%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Flib.rs?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -115,7 +115,11 @@ pub fn install_rustfmt() -> Result<()> {\n }\n \n pub fn install_format_hook() -> Result<()> {\n-    let result_path = Path::new(\"./.git/hooks/pre-commit\");\n+    let result_path = Path::new(if cfg!(windows) {\n+        \"./.git/hooks/pre-commit.exe\"\n+    } else {\n+        \"./.git/hooks/pre-commit\"\n+    });\n     if !result_path.exists() {\n         run(\"cargo build --package tools --bin pre-commit\", \".\")?;\n         if cfg!(windows) {"}, {"sha": "890b18fcd7d73c6e002a1b66d07915d9ebdb6072", "filename": "docs/dev/architecture.md", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/docs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/docs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Farchitecture.md?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -130,19 +130,6 @@ APIs in this crate are IDE centric: they take text offsets as input and produce\n offsets and strings as output. This works on top of rich code model powered by\n `hir`.\n \n-### `crates/ra_ide_api_light`\n-\n-All IDE features which can be implemented if you only have access to a single\n-file. `ra_ide_api_light` could be used to enhance editing of Rust code without\n-the need to fiddle with build-systems, file synchronization and such.\n-\n-In a sense, `ra_ide_api_light` is just a bunch of pure functions which take a\n-syntax tree as input.\n-\n-The tests for `ra_ide_api_light` are `#[cfg(test)] mod tests` unit-tests spread\n-throughout its modules.\n-\n-\n ### `crates/ra_lsp_server`\n \n An LSP implementation which wraps `ra_ide_api` into a langauge server protocol."}, {"sha": "7173d88e924eab87cfeafa273228516450c3fe5c", "filename": "docs/user/features.md", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/docs%2Fuser%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/docs%2Fuser%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Ffeatures.md?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -210,7 +210,7 @@ fn main() {\n }\n ```\n \n--- Fill struct fields\n+- Fill struct fields\n \n ```rust\n // before:\n@@ -270,7 +270,22 @@ fn foo() {\n }\n ```\n \n--- Remove `dbg!`\n+- Inline local variable:\n+\n+```rust\n+// before:\n+fn foo() {\n+    let a<|> = 1 + 1;\n+    let b = a * 10;\n+}\n+\n+// after:\n+fn foo() {\n+    let b = (1 + 1) * 10;\n+}\n+```\n+\n+- Remove `dbg!`\n \n ```rust\n // before:"}, {"sha": "84c018b66f5b0ec99b94a297c596ea637f19dfa8", "filename": "editors/emacs/ra-emacs-lsp.el", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b74449e9952846a8ea66c3507e52c24348d6dbc9/editors%2Femacs%2Fra-emacs-lsp.el", "raw_url": "https://github.com/rust-lang/rust/raw/b74449e9952846a8ea66c3507e52c24348d6dbc9/editors%2Femacs%2Fra-emacs-lsp.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Femacs%2Fra-emacs-lsp.el?ref=b74449e9952846a8ea66c3507e52c24348d6dbc9", "patch": "@@ -159,7 +159,7 @@\n   (interactive (list (rust-analyzer--select-runnable)))\n   (-let (((&hash \"env\" \"bin\" \"args\" \"label\") runnable))\n     (compilation-start\n-     (string-join (cons bin args) \" \")\n+     (string-join (append (list bin) args '()) \" \")\n      ;; cargo-process-mode is nice, but try to work without it...\n      (if (functionp 'cargo-process-mode) 'cargo-process-mode nil)\n      (lambda (_) (concat \"*\" label \"*\")))"}]}