{"sha": "8514b8407ac83dc02532c82c9188c49967d9a5d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MTRiODQwN2FjODNkYzAyNTMyYzgyYzkxODhjNDk5NjdkOWE1ZDY=", "commit": {"author": {"name": "Christoph Walcher", "email": "christoph-wa@gmx.de", "date": "2020-08-14T12:13:35Z"}, "committer": {"name": "Christoph Walcher", "email": "christoph-wa@gmx.de", "date": "2020-08-14T12:29:16Z"}, "message": "appreciative too_large_for_stack in useless `vec!`\n\nFixes: #5847", "tree": {"sha": "d71220c97291297e45718b54b6e1a40686d1fce3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d71220c97291297e45718b54b6e1a40686d1fce3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8514b8407ac83dc02532c82c9188c49967d9a5d6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEE2xeoiquC04hUiBqUoZMWSk0F7kQFAl82g50ACgkQoZMWSk0F\n7kRTEgf+PLrlfKi0VE3ZyFzcUzZpY3gSAhqoj45ygUFFQI7DV8QOQ/e90Bua5hV5\n+79rKkRu1JQhPNe8rkZ5+k/wVCz7Wih/H1f+Gs6TJNJne1cqKejUhcECYTyc5sFa\nIVHeRq5/u22oRMzUHXs7CCtMoxlKcfcgANvb+AqhNr72I2heYXLlH8O1i53w30xz\njMaOHdnp6B/imI3q7GAdRVtEICpQHmFUH5znq2/hdlOWDsarQNquxofFqrzi/WSx\nSm1zVheFxNZSgISQA8PphamcHqNPvw+A3ZRRnFAYfjo3wg2/l7Yqe3tDEiU5PA8i\nwoXEuBsxcM+AqKjBY2W325CloywTaA==\n=ivGF\n-----END PGP SIGNATURE-----", "payload": "tree d71220c97291297e45718b54b6e1a40686d1fce3\nparent 8ecc0fc08a9bc213beb39147ee3155a6056bd2b3\nauthor Christoph Walcher <christoph-wa@gmx.de> 1597407215 +0200\ncommitter Christoph Walcher <christoph-wa@gmx.de> 1597408156 +0200\n\nappreciative too_large_for_stack in useless `vec!`\n\nFixes: #5847\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8514b8407ac83dc02532c82c9188c49967d9a5d6", "html_url": "https://github.com/rust-lang/rust/commit/8514b8407ac83dc02532c82c9188c49967d9a5d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8514b8407ac83dc02532c82c9188c49967d9a5d6/comments", "author": {"login": "wiomoc", "id": 10638299, "node_id": "MDQ6VXNlcjEwNjM4Mjk5", "avatar_url": "https://avatars.githubusercontent.com/u/10638299?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wiomoc", "html_url": "https://github.com/wiomoc", "followers_url": "https://api.github.com/users/wiomoc/followers", "following_url": "https://api.github.com/users/wiomoc/following{/other_user}", "gists_url": "https://api.github.com/users/wiomoc/gists{/gist_id}", "starred_url": "https://api.github.com/users/wiomoc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wiomoc/subscriptions", "organizations_url": "https://api.github.com/users/wiomoc/orgs", "repos_url": "https://api.github.com/users/wiomoc/repos", "events_url": "https://api.github.com/users/wiomoc/events{/privacy}", "received_events_url": "https://api.github.com/users/wiomoc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wiomoc", "id": 10638299, "node_id": "MDQ6VXNlcjEwNjM4Mjk5", "avatar_url": "https://avatars.githubusercontent.com/u/10638299?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wiomoc", "html_url": "https://github.com/wiomoc", "followers_url": "https://api.github.com/users/wiomoc/followers", "following_url": "https://api.github.com/users/wiomoc/following{/other_user}", "gists_url": "https://api.github.com/users/wiomoc/gists{/gist_id}", "starred_url": "https://api.github.com/users/wiomoc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wiomoc/subscriptions", "organizations_url": "https://api.github.com/users/wiomoc/orgs", "repos_url": "https://api.github.com/users/wiomoc/repos", "events_url": "https://api.github.com/users/wiomoc/events{/privacy}", "received_events_url": "https://api.github.com/users/wiomoc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ecc0fc08a9bc213beb39147ee3155a6056bd2b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ecc0fc08a9bc213beb39147ee3155a6056bd2b3", "html_url": "https://github.com/rust-lang/rust/commit/8ecc0fc08a9bc213beb39147ee3155a6056bd2b3"}], "stats": {"total": 115, "additions": 76, "deletions": 39}, "files": [{"sha": "4a4445200a1a30a962c4de0e45a796f67a4c3bee", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8514b8407ac83dc02532c82c9188c49967d9a5d6/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8514b8407ac83dc02532c82c9188c49967d9a5d6/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8514b8407ac83dc02532c82c9188c49967d9a5d6", "patch": "@@ -930,11 +930,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box cognitive_complexity::CognitiveComplexity::new(cognitive_complexity_threshold));\n     let too_large_for_stack = conf.too_large_for_stack;\n     store.register_late_pass(move || box escape::BoxedLocal{too_large_for_stack});\n+    store.register_late_pass(move || box vec::UselessVec{too_large_for_stack});\n     store.register_late_pass(|| box panic_unimplemented::PanicUnimplemented);\n     store.register_late_pass(|| box strings::StringLitAsBytes);\n     store.register_late_pass(|| box derive::Derive);\n     store.register_late_pass(|| box types::CharLitAsU8);\n-    store.register_late_pass(|| box vec::UselessVec);\n     store.register_late_pass(|| box drop_bounds::DropBounds);\n     store.register_late_pass(|| box get_last_with_len::GetLastWithLen);\n     store.register_late_pass(|| box drop_forget_ref::DropForgetRef);"}, {"sha": "292dbd7ad6b480babd426aae3dadc51060b419ac", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8514b8407ac83dc02532c82c9188c49967d9a5d6/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8514b8407ac83dc02532c82c9188c49967d9a5d6/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=8514b8407ac83dc02532c82c9188c49967d9a5d6", "patch": "@@ -138,7 +138,7 @@ define_Conf! {\n     (type_complexity_threshold, \"type_complexity_threshold\": u64, 250),\n     /// Lint: MANY_SINGLE_CHAR_NAMES. The maximum number of single char bindings a scope may have\n     (single_char_binding_names_threshold, \"single_char_binding_names_threshold\": u64, 4),\n-    /// Lint: BOXED_LOCAL. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n+    /// Lint: BOXED_LOCAL, USELESS_VEC. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n     (too_large_for_stack, \"too_large_for_stack\": u64, 200),\n     /// Lint: ENUM_VARIANT_NAMES. The minimum number of enum variants for the lints about variant names to trigger\n     (enum_variant_name_threshold, \"enum_variant_name_threshold\": u64, 3),"}, {"sha": "84e907d7125de8951f291dc201a4c453d417c74d", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 60, "deletions": 37, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8514b8407ac83dc02532c82c9188c49967d9a5d6/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8514b8407ac83dc02532c82c9188c49967d9a5d6/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=8514b8407ac83dc02532c82c9188c49967d9a5d6", "patch": "@@ -1,13 +1,20 @@\n-use crate::consts::constant;\n+use crate::consts::{constant, Constant};\n+use crate::rustc_target::abi::LayoutOf;\n use crate::utils::{higher, is_copy, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n \n+#[allow(clippy::module_name_repetitions)]\n+#[derive(Copy, Clone)]\n+pub struct UselessVec {\n+    pub too_large_for_stack: u64,\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n     /// be possible.\n@@ -31,7 +38,7 @@ declare_clippy_lint! {\n     \"useless `vec!`\"\n }\n \n-declare_lint_pass!(UselessVec => [USELESS_VEC]);\n+impl_lint_pass!(UselessVec => [USELESS_VEC]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessVec {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n@@ -42,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, ref addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n-                check_vec_macro(cx, &vec_args, expr.span);\n+                self.check_vec_macro(cx, &vec_args, expr.span);\n             }\n         }\n \n@@ -60,46 +67,62 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n                     .ctxt()\n                     .outer_expn_data()\n                     .call_site;\n-                check_vec_macro(cx, &vec_args, span);\n+                self.check_vec_macro(cx, &vec_args, span);\n             }\n         }\n     }\n }\n \n-fn check_vec_macro<'tcx>(cx: &LateContext<'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n-    let mut applicability = Applicability::MachineApplicable;\n-    let snippet = match *vec_args {\n-        higher::VecArgs::Repeat(elem, len) => {\n-            if constant(cx, cx.typeck_results(), len).is_some() {\n-                format!(\n-                    \"&[{}; {}]\",\n-                    snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n-                    snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n-                )\n-            } else {\n-                return;\n-            }\n-        },\n-        higher::VecArgs::Vec(args) => {\n-            if let Some(last) = args.iter().last() {\n-                let span = args[0].span.to(last.span);\n+impl UselessVec {\n+    fn check_vec_macro<'tcx>(self, cx: &LateContext<'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        let snippet = match *vec_args {\n+            higher::VecArgs::Repeat(elem, len) => {\n+                if let Some((Constant::Int(len_constant), _)) = constant(cx, cx.typeck_results(), len) {\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    if len_constant as u64 * size_of(cx, elem) > self.too_large_for_stack {\n+                        return;\n+                    }\n \n-                format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n-            } else {\n-                \"&[]\".into()\n-            }\n-        },\n-    };\n+                    format!(\n+                        \"&[{}; {}]\",\n+                        snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n+                        snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n+                    )\n+                } else {\n+                    return;\n+                }\n+            },\n+            higher::VecArgs::Vec(args) => {\n+                if let Some(last) = args.iter().last() {\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    if args.len() as u64 * size_of(cx, last) > self.too_large_for_stack {\n+                        return;\n+                    }\n+                    let span = args[0].span.to(last.span);\n+\n+                    format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n+                } else {\n+                    \"&[]\".into()\n+                }\n+            },\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            USELESS_VEC,\n+            span,\n+            \"useless use of `vec!`\",\n+            \"you can use a slice directly\",\n+            snippet,\n+            applicability,\n+        );\n+    }\n+}\n \n-    span_lint_and_sugg(\n-        cx,\n-        USELESS_VEC,\n-        span,\n-        \"useless use of `vec!`\",\n-        \"you can use a slice directly\",\n-        snippet,\n-        applicability,\n-    );\n+fn size_of(cx: &LateContext<'_>, expr: &Expr<'_>) -> u64 {\n+    let ty = cx.typeck_results().expr_ty_adjusted(expr);\n+    cx.layout_of(ty).map_or(0, |l| l.size.bytes())\n }\n \n /// Returns the item type of the vector (i.e., the `T` in `Vec<T>`)."}, {"sha": "856771596202efb47f1c755759ccf60040133d00", "filename": "tests/ui/vec.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8514b8407ac83dc02532c82c9188c49967d9a5d6/tests%2Fui%2Fvec.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8514b8407ac83dc02532c82c9188c49967d9a5d6/tests%2Fui%2Fvec.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec.fixed?ref=8514b8407ac83dc02532c82c9188c49967d9a5d6", "patch": "@@ -52,4 +52,11 @@ fn main() {\n     for a in vec![NonCopy, NonCopy] {\n         println!(\"{:?}\", a);\n     }\n+\n+    on_vec(&vec![1; 201]); // Ok, size of `vec` higher than `too_large_for_stack`\n+\n+    // Ok\n+    for a in vec![1; 201] {\n+        println!(\"{:?}\", a);\n+    }\n }"}, {"sha": "03b8ee816658ccefbebb278a89e278cc36945691", "filename": "tests/ui/vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8514b8407ac83dc02532c82c9188c49967d9a5d6/tests%2Fui%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8514b8407ac83dc02532c82c9188c49967d9a5d6/tests%2Fui%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec.rs?ref=8514b8407ac83dc02532c82c9188c49967d9a5d6", "patch": "@@ -52,4 +52,11 @@ fn main() {\n     for a in vec![NonCopy, NonCopy] {\n         println!(\"{:?}\", a);\n     }\n+\n+    on_vec(&vec![1; 201]); // Ok, size of `vec` higher than `too_large_for_stack`\n+\n+    // Ok\n+    for a in vec![1; 201] {\n+        println!(\"{:?}\", a);\n+    }\n }"}]}