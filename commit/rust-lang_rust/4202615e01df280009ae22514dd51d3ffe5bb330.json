{"sha": "4202615e01df280009ae22514dd51d3ffe5bb330", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMDI2MTVlMDFkZjI4MDAwOWFlMjI1MTRkZDUxZDNmZmU1YmIzMzA=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2015-11-04T23:41:33Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2015-11-06T00:37:32Z"}, "message": "librustdoc: improve testnames for doctests", "tree": {"sha": "53ca22243f73437def5930fb9791f78a05277d1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53ca22243f73437def5930fb9791f78a05277d1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4202615e01df280009ae22514dd51d3ffe5bb330", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4202615e01df280009ae22514dd51d3ffe5bb330", "html_url": "https://github.com/rust-lang/rust/commit/4202615e01df280009ae22514dd51d3ffe5bb330", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4202615e01df280009ae22514dd51d3ffe5bb330/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11e55e4de1602bf0a6dc403efaba17672155fa9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/11e55e4de1602bf0a6dc403efaba17672155fa9a", "html_url": "https://github.com/rust-lang/rust/commit/11e55e4de1602bf0a6dc403efaba17672155fa9a"}], "stats": {"total": 71, "additions": 59, "deletions": 12}, "files": [{"sha": "34ddd5726d38525f67467ef2d688def91f3c8eef", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4202615e01df280009ae22514dd51d3ffe5bb330/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4202615e01df280009ae22514dd51d3ffe5bb330/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4202615e01df280009ae22514dd51d3ffe5bb330", "patch": "@@ -2568,8 +2568,18 @@ fn resolve_type(cx: &DocContext,\n     debug!(\"resolve_type({:?},{:?})\", path, id);\n     let tcx = match cx.tcx_opt() {\n         Some(tcx) => tcx,\n-        // If we're extracting tests, this return value doesn't matter.\n-        None => return Primitive(Bool),\n+        // If we're extracting tests, this return value's accuracy is not\n+        // important, all we want is a string representation to help people\n+        // figure out what doctests are failing.\n+        None => {\n+            let did = DefId::local(DefIndex::from_u32(0));\n+            return ResolvedPath {\n+                path: path,\n+                typarams: None,\n+                did: did,\n+                is_generic: false\n+            };\n+        }\n     };\n     let def = match tcx.def_map.borrow().get(&id) {\n         Some(k) => k.full_def(),"}, {"sha": "1ea30a8763e40df05c77540b8383f58a64a851be", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4202615e01df280009ae22514dd51d3ffe5bb330/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4202615e01df280009ae22514dd51d3ffe5bb330/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=4202615e01df280009ae22514dd51d3ffe5bb330", "patch": "@@ -422,22 +422,59 @@ impl Collector {\n \n impl DocFolder for Collector {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        let pushed = match item.name {\n-            Some(ref name) if name.is_empty() => false,\n-            Some(ref name) => { self.names.push(name.to_string()); true }\n-            None => false\n+        let current_name = match item.name {\n+            Some(ref name) if !name.is_empty() => Some(name.clone()),\n+            _ => typename_if_impl(&item)\n         };\n-        match item.doc_value() {\n-            Some(doc) => {\n-                self.cnt = 0;\n-                markdown::find_testable_code(doc, &mut *self);\n-            }\n-            None => {}\n+\n+        let pushed = if let Some(name) = current_name {\n+            self.names.push(name);\n+            true\n+        } else {\n+            false\n+        };\n+\n+        if let Some(doc) = item.doc_value() {\n+            self.cnt = 0;\n+            markdown::find_testable_code(doc, &mut *self);\n         }\n+\n         let ret = self.fold_item_recur(item);\n         if pushed {\n             self.names.pop();\n         }\n+\n         return ret;\n+\n+        // FIXME: it would be better to not have the escaped version in the first place\n+        fn unescape_for_testname(mut s: String) -> String {\n+            // for refs `&foo`\n+            if s.contains(\"&amp;\") {\n+                s = s.replace(\"&amp;\", \"&\");\n+\n+                // `::&'a mut Foo::` looks weird, let's make it `::<&'a mut Foo>`::\n+                if let Some('&') = s.chars().nth(0) {\n+                    s = format!(\"<{}>\", s);\n+                }\n+            }\n+\n+            // either `<..>` or `->`\n+            if s.contains(\"&gt;\") {\n+                s.replace(\"&gt;\", \">\")\n+                 .replace(\"&lt;\", \"<\")\n+            } else {\n+                s\n+            }\n+        }\n+\n+        fn typename_if_impl(item: &clean::Item) -> Option<String> {\n+            if let clean::ItemEnum::ImplItem(ref impl_) = item.inner {\n+                let path = impl_.for_.to_string();\n+                let unescaped_path = unescape_for_testname(path);\n+                Some(unescaped_path)\n+            } else {\n+                None\n+            }\n+        }\n     }\n }"}]}