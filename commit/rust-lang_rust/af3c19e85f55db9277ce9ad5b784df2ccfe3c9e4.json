{"sha": "af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmM2MxOWU4NWY1NWRiOTI3N2NlOWFkNWI3ODRkZjJjY2ZlM2M5ZTQ=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-18T15:14:24Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-18T15:14:24Z"}, "message": "Merge branch 'master' of github.com:rust-analyzer/rust-analyzer", "tree": {"sha": "7a777f22f5fa79704b8d2c9aa8d67255d12123be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a777f22f5fa79704b8d2c9aa8d67255d12123be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "html_url": "https://github.com/rust-lang/rust/commit/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "379787858bbfb2691e134942d94fcbc70c5d1d7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/379787858bbfb2691e134942d94fcbc70c5d1d7f", "html_url": "https://github.com/rust-lang/rust/commit/379787858bbfb2691e134942d94fcbc70c5d1d7f"}, {"sha": "84e3304a9bf0d68e30d58b1e37a6db2e9ec97525", "url": "https://api.github.com/repos/rust-lang/rust/commits/84e3304a9bf0d68e30d58b1e37a6db2e9ec97525", "html_url": "https://github.com/rust-lang/rust/commit/84e3304a9bf0d68e30d58b1e37a6db2e9ec97525"}], "stats": {"total": 888, "additions": 705, "deletions": 183}, "files": [{"sha": "3826ae1c6f15a7b91d80bf92f32b56507024649e", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -675,6 +675,16 @@ version = \"2.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3728d817d99e5ac407411fa471ff9800a778d88a24685968b36824eaf4bee400\"\n \n+[[package]]\n+name = \"memmap\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6585fd95e7bb50d6cc31e20d4cf9afb4e2ba16c5846fc76793f11218da9c475b\"\n+dependencies = [\n+ \"libc\",\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"memoffset\"\n version = \"0.5.4\"\n@@ -1112,6 +1122,7 @@ dependencies = [\n  \"difference\",\n  \"goblin\",\n  \"libloading\",\n+ \"memmap\",\n  \"ra_mbe\",\n  \"ra_proc_macro\",\n  \"ra_tt\","}, {"sha": "0b477f0e9ea73e8e86a80a64cf102b50fecf162d", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -20,6 +20,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     db::HirDatabase,\n+    diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     AssocItem, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef, Name,\n@@ -126,6 +127,13 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         original_range(self.db, node.as_ref())\n     }\n \n+    pub fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n+        let src = diagnostics.source();\n+        let root = self.db.parse_or_expand(src.file_id).unwrap();\n+        let node = src.value.to_node(&root);\n+        original_range(self.db, src.with_value(&node))\n+    }\n+\n     pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n         let node = self.find_file(node);\n         node.ancestors_with_macros(self.db).map(|it| it.value)"}, {"sha": "23af400b8bc6bf6dc61c4fd49604146564dc06be", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 52, "deletions": 47, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -23,7 +23,7 @@ use hir_ty::{\n };\n use ra_syntax::{\n     ast::{self, AstNode},\n-    SyntaxNode, SyntaxNodePtr, TextUnit,\n+    SyntaxNode, TextRange, TextUnit,\n };\n \n use crate::{\n@@ -56,7 +56,7 @@ impl SourceAnalyzer {\n         let scopes = db.expr_scopes(def);\n         let scope = match offset {\n             None => scope_for(&scopes, &source_map, node),\n-            Some(offset) => scope_for_offset(&scopes, &source_map, node.with_value(offset)),\n+            Some(offset) => scope_for_offset(db, &scopes, &source_map, node.with_value(offset)),\n         };\n         let resolver = resolver_for_scope(db.upcast(), def, scope);\n         SourceAnalyzer {\n@@ -304,6 +304,7 @@ fn scope_for(\n }\n \n fn scope_for_offset(\n+    db: &dyn HirDatabase,\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n     offset: InFile<TextUnit>,\n@@ -317,21 +318,63 @@ fn scope_for_offset(\n             if source.file_id != offset.file_id {\n                 return None;\n             }\n-            let syntax_node_ptr = source.value.syntax_node_ptr();\n-            Some((syntax_node_ptr, scope))\n+            let root = source.file_syntax(db.upcast());\n+            let node = source.value.to_node(&root);\n+            Some((node.syntax().text_range(), scope))\n         })\n         // find containing scope\n-        .min_by_key(|(ptr, _scope)| {\n+        .min_by_key(|(expr_range, _scope)| {\n             (\n-                !(ptr.range().start() <= offset.value && offset.value <= ptr.range().end()),\n-                ptr.range().len(),\n+                !(expr_range.start() <= offset.value && offset.value <= expr_range.end()),\n+                expr_range.len(),\n             )\n         })\n-        .map(|(ptr, scope)| {\n-            adjust(scopes, source_map, ptr, offset.file_id, offset.value).unwrap_or(*scope)\n+        .map(|(expr_range, scope)| {\n+            adjust(db, scopes, source_map, expr_range, offset.file_id, offset.value)\n+                .unwrap_or(*scope)\n         })\n }\n \n+// XXX: during completion, cursor might be outside of any particular\n+// expression. Try to figure out the correct scope...\n+fn adjust(\n+    db: &dyn HirDatabase,\n+    scopes: &ExprScopes,\n+    source_map: &BodySourceMap,\n+    expr_range: TextRange,\n+    file_id: HirFileId,\n+    offset: TextUnit,\n+) -> Option<ScopeId> {\n+    let child_scopes = scopes\n+        .scope_by_expr()\n+        .iter()\n+        .filter_map(|(id, scope)| {\n+            let source = source_map.expr_syntax(*id).ok()?;\n+            // FIXME: correctly handle macro expansion\n+            if source.file_id != file_id {\n+                return None;\n+            }\n+            let root = source.file_syntax(db.upcast());\n+            let node = source.value.to_node(&root);\n+            Some((node.syntax().text_range(), scope))\n+        })\n+        .filter(|(range, _)| {\n+            range.start() <= offset && range.is_subrange(&expr_range) && *range != expr_range\n+        });\n+\n+    child_scopes\n+        .max_by(|(r1, _), (r2, _)| {\n+            if r2.is_subrange(&r1) {\n+                std::cmp::Ordering::Greater\n+            } else if r1.is_subrange(&r2) {\n+                std::cmp::Ordering::Less\n+            } else {\n+                r1.start().cmp(&r2.start())\n+            }\n+        })\n+        .map(|(_ptr, scope)| *scope)\n+}\n+\n pub(crate) fn resolve_hir_path(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n@@ -376,41 +419,3 @@ pub(crate) fn resolve_hir_path(\n             .map(|def| PathResolution::Macro(def.into()))\n     })\n }\n-\n-// XXX: during completion, cursor might be outside of any particular\n-// expression. Try to figure out the correct scope...\n-fn adjust(\n-    scopes: &ExprScopes,\n-    source_map: &BodySourceMap,\n-    ptr: SyntaxNodePtr,\n-    file_id: HirFileId,\n-    offset: TextUnit,\n-) -> Option<ScopeId> {\n-    let r = ptr.range();\n-    let child_scopes = scopes\n-        .scope_by_expr()\n-        .iter()\n-        .filter_map(|(id, scope)| {\n-            let source = source_map.expr_syntax(*id).ok()?;\n-            // FIXME: correctly handle macro expansion\n-            if source.file_id != file_id {\n-                return None;\n-            }\n-            let syntax_node_ptr = source.value.syntax_node_ptr();\n-            Some((syntax_node_ptr, scope))\n-        })\n-        .map(|(ptr, scope)| (ptr.range(), scope))\n-        .filter(|(range, _)| range.start() <= offset && range.is_subrange(&r) && *range != r);\n-\n-    child_scopes\n-        .max_by(|(r1, _), (r2, _)| {\n-            if r2.is_subrange(&r1) {\n-                std::cmp::Ordering::Greater\n-            } else if r1.is_subrange(&r2) {\n-                std::cmp::Ordering::Less\n-            } else {\n-                r1.start().cmp(&r2.start())\n-            }\n-        })\n-        .map(|(_ptr, scope)| *scope)\n-}"}, {"sha": "3b169440ad85ecdb21cb3b91a0bf67c28062aad9", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -210,7 +210,7 @@ pub struct BodySourceMap {\n     expr_map_back: ArenaMap<ExprId, Result<ExprSource, SyntheticSyntax>>,\n     pat_map: FxHashMap<PatSource, PatId>,\n     pat_map_back: ArenaMap<PatId, Result<PatSource, SyntheticSyntax>>,\n-    field_map: FxHashMap<(ExprId, usize), AstPtr<ast::RecordField>>,\n+    field_map: FxHashMap<(ExprId, usize), InFile<AstPtr<ast::RecordField>>>,\n     expansions: FxHashMap<InFile<AstPtr<ast::MacroCall>>, HirFileId>,\n }\n \n@@ -303,7 +303,7 @@ impl BodySourceMap {\n         self.pat_map.get(&src).cloned()\n     }\n \n-    pub fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::RecordField> {\n+    pub fn field_syntax(&self, expr: ExprId, field: usize) -> InFile<AstPtr<ast::RecordField>> {\n         self.field_map[&(expr, field)].clone()\n     }\n }"}, {"sha": "82a52804d50d385879b10fe2f0812a7de846a1ba", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -320,7 +320,8 @@ impl ExprCollector<'_> {\n \n                 let res = self.alloc_expr(record_lit, syntax_ptr);\n                 for (i, ptr) in field_ptrs.into_iter().enumerate() {\n-                    self.source_map.field_map.insert((res, i), ptr);\n+                    let src = self.expander.to_source(ptr);\n+                    self.source_map.field_map.insert((res, i), src);\n                 }\n                 res\n             }\n@@ -650,6 +651,7 @@ impl ExprCollector<'_> {\n             ast::Pat::SlicePat(p) => {\n                 let SlicePatComponents { prefix, slice, suffix } = p.components();\n \n+                // FIXME properly handle `DotDotPat`\n                 Pat::Slice {\n                     prefix: prefix.into_iter().map(|p| self.collect_pat(p)).collect(),\n                     slice: slice.map(|p| self.collect_pat(p)),\n@@ -666,9 +668,15 @@ impl ExprCollector<'_> {\n                     Pat::Missing\n                 }\n             }\n-            ast::Pat::DotDotPat(_) => unreachable!(\n-                \"`DotDotPat` requires special handling and should not be mapped to a Pat.\"\n-            ),\n+            ast::Pat::DotDotPat(_) => {\n+                // `DotDotPat` requires special handling and should not be mapped\n+                // to a Pat. Here we are using `Pat::Missing` as a fallback for\n+                // when `DotDotPat` is mapped to `Pat`, which can easily happen\n+                // when the source code being analyzed has a malformed pattern\n+                // which includes `..` in a place where it isn't valid.\n+\n+                Pat::Missing\n+            }\n             // FIXME: implement\n             ast::Pat::BoxPat(_) | ast::Pat::RangePat(_) | ast::Pat::MacroPat(_) => Pat::Missing,\n         };"}, {"sha": "0f872b5c047487140eff04e8ea57db9cb9b77659", "filename": "crates/ra_hir_def/src/builtin_type.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -5,7 +5,7 @@\n \n use std::fmt;\n \n-use hir_expand::name::{name, Name};\n+use hir_expand::name::{name, AsName, Name};\n \n #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n pub enum Signedness {\n@@ -75,33 +75,39 @@ impl BuiltinType {\n     ];\n }\n \n-impl fmt::Display for BuiltinType {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let type_name = match self {\n-            BuiltinType::Char => \"char\",\n-            BuiltinType::Bool => \"bool\",\n-            BuiltinType::Str => \"str\",\n+impl AsName for BuiltinType {\n+    fn as_name(&self) -> Name {\n+        match self {\n+            BuiltinType::Char => name![char],\n+            BuiltinType::Bool => name![bool],\n+            BuiltinType::Str => name![str],\n             BuiltinType::Int(BuiltinInt { signedness, bitness }) => match (signedness, bitness) {\n-                (Signedness::Signed, IntBitness::Xsize) => \"isize\",\n-                (Signedness::Signed, IntBitness::X8) => \"i8\",\n-                (Signedness::Signed, IntBitness::X16) => \"i16\",\n-                (Signedness::Signed, IntBitness::X32) => \"i32\",\n-                (Signedness::Signed, IntBitness::X64) => \"i64\",\n-                (Signedness::Signed, IntBitness::X128) => \"i128\",\n-\n-                (Signedness::Unsigned, IntBitness::Xsize) => \"usize\",\n-                (Signedness::Unsigned, IntBitness::X8) => \"u8\",\n-                (Signedness::Unsigned, IntBitness::X16) => \"u16\",\n-                (Signedness::Unsigned, IntBitness::X32) => \"u32\",\n-                (Signedness::Unsigned, IntBitness::X64) => \"u64\",\n-                (Signedness::Unsigned, IntBitness::X128) => \"u128\",\n+                (Signedness::Signed, IntBitness::Xsize) => name![isize],\n+                (Signedness::Signed, IntBitness::X8) => name![i8],\n+                (Signedness::Signed, IntBitness::X16) => name![i16],\n+                (Signedness::Signed, IntBitness::X32) => name![i32],\n+                (Signedness::Signed, IntBitness::X64) => name![i64],\n+                (Signedness::Signed, IntBitness::X128) => name![i128],\n+\n+                (Signedness::Unsigned, IntBitness::Xsize) => name![usize],\n+                (Signedness::Unsigned, IntBitness::X8) => name![u8],\n+                (Signedness::Unsigned, IntBitness::X16) => name![u16],\n+                (Signedness::Unsigned, IntBitness::X32) => name![u32],\n+                (Signedness::Unsigned, IntBitness::X64) => name![u64],\n+                (Signedness::Unsigned, IntBitness::X128) => name![u128],\n             },\n             BuiltinType::Float(BuiltinFloat { bitness }) => match bitness {\n-                FloatBitness::X32 => \"f32\",\n-                FloatBitness::X64 => \"f64\",\n+                FloatBitness::X32 => name![f32],\n+                FloatBitness::X64 => name![f64],\n             },\n-        };\n-        f.write_str(type_name)\n+        }\n+    }\n+}\n+\n+impl fmt::Display for BuiltinType {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let type_name = self.as_name();\n+        type_name.fmt(f)\n     }\n }\n "}, {"sha": "510c5e06483b6dcf3b493a957278d0d293a11876", "filename": "crates/ra_hir_def/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -20,7 +20,7 @@ impl Diagnostic for UnresolvedModule {\n         \"unresolved module\".to_string()\n     }\n     fn source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.decl.clone().into() }\n+        InFile::new(self.file, self.decl.clone().into())\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self"}, {"sha": "81eff5bfef1d9d2a98d514217b84044b5bfec259", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -7,7 +7,7 @@ use crate::{\n     visibility::Visibility,\n     CrateId, ModuleDefId, ModuleId,\n };\n-use hir_expand::name::{known, Name};\n+use hir_expand::name::{known, AsName, Name};\n use test_utils::tested_by;\n \n const MAX_PATH_LEN: usize = 15;\n@@ -113,6 +113,11 @@ fn find_path_inner(\n         }\n     }\n \n+    // - if the item is a builtin, it's in scope\n+    if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {\n+        return Some(ModPath::from_segments(PathKind::Plain, vec![builtin.as_name()]));\n+    }\n+\n     // Recursive case:\n     // - if the item is an enum variant, refer to it via the enum\n     if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n@@ -523,4 +528,18 @@ mod tests {\n         \"#;\n         check_found_path(code, \"megaalloc::Arc\");\n     }\n+\n+    #[test]\n+    fn builtins_are_in_scope() {\n+        let code = r#\"\n+        //- /main.rs\n+        <|>\n+\n+        pub mod primitive {\n+            pub use u8;\n+        }\n+        \"#;\n+        check_found_path(code, \"u8\");\n+        check_found_path(code, \"u16\");\n+    }\n }"}, {"sha": "99209c6e8c7262af710a6dfdf81baaf08aadf1da", "filename": "crates/ra_hir_expand/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -16,16 +16,13 @@\n \n use std::{any::Any, fmt};\n \n-use ra_syntax::{SyntaxNode, SyntaxNodePtr, TextRange};\n+use ra_syntax::{SyntaxNode, SyntaxNodePtr};\n \n use crate::{db::AstDatabase, InFile};\n \n pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n     fn message(&self) -> String;\n     fn source(&self) -> InFile<SyntaxNodePtr>;\n-    fn highlight_range(&self) -> TextRange {\n-        self.source().value.range()\n-    }\n     fn as_any(&self) -> &(dyn Any + Send + 'static);\n }\n "}, {"sha": "c8fd5486159ad58505a9fd4cfac3efad2668d568", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -21,7 +21,7 @@ impl Diagnostic for NoSuchField {\n     }\n \n     fn source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.field.clone().into() }\n+        InFile::new(self.file, self.field.clone().into())\n     }\n \n     fn as_any(&self) -> &(dyn Any + Send + 'static) {"}, {"sha": "b6d9b3438e7dd391c1b0ea864664d06e9aeb4b24", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -682,10 +682,10 @@ mod diagnostics {\n         ) {\n             match self {\n                 InferenceDiagnostic::NoSuchField { expr, field } => {\n-                    let file = owner.lookup(db.upcast()).source(db.upcast()).file_id;\n+                    let source = owner.lookup(db.upcast()).source(db.upcast());\n                     let (_, source_map) = db.body_with_source_map(owner.into());\n                     let field = source_map.field_syntax(*expr, *field);\n-                    sink.push(NoSuchField { file, field })\n+                    sink.push(NoSuchField { file: source.file_id, field: field.value })\n                 }\n             }\n         }"}, {"sha": "89200255a28702c45c8ebc0d50ab6de88a54bd24", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -51,7 +51,7 @@ impl<'a> InferenceContext<'a> {\n             // Trivial cases, this should go after `never` check to\n             // avoid infer result type to be never\n             _ => {\n-                if self.table.unify_inner_trivial(&from_ty, &to_ty) {\n+                if self.table.unify_inner_trivial(&from_ty, &to_ty, 0) {\n                     return true;\n                 }\n             }\n@@ -175,7 +175,7 @@ impl<'a> InferenceContext<'a> {\n                     return self.table.unify_substs(st1, st2, 0);\n                 }\n                 _ => {\n-                    if self.table.unify_inner_trivial(&derefed_ty, &to_ty) {\n+                    if self.table.unify_inner_trivial(&derefed_ty, &to_ty, 0) {\n                         return true;\n                     }\n                 }"}, {"sha": "ab0bc8b70b652e09fb74277e14de8546272d4bc6", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -8,7 +8,8 @@ use test_utils::tested_by;\n \n use super::{InferenceContext, Obligation};\n use crate::{\n-    BoundVar, Canonical, DebruijnIndex, InEnvironment, InferTy, Substs, Ty, TypeCtor, TypeWalk,\n+    BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferTy, Substs, Ty,\n+    TypeCtor, TypeWalk,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -226,16 +227,26 @@ impl InferenceTable {\n             (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n                 self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n             }\n-            _ => self.unify_inner_trivial(&ty1, &ty2),\n+\n+            _ => self.unify_inner_trivial(&ty1, &ty2, depth),\n         }\n     }\n \n-    pub(super) fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+    pub(super) fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n         match (ty1, ty2) {\n             (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n \n             (Ty::Placeholder(p1), Ty::Placeholder(p2)) if *p1 == *p2 => true,\n \n+            (Ty::Dyn(dyn1), Ty::Dyn(dyn2)) if dyn1.len() == dyn2.len() => {\n+                for (pred1, pred2) in dyn1.iter().zip(dyn2.iter()) {\n+                    if !self.unify_preds(pred1, pred2, depth + 1) {\n+                        return false;\n+                    }\n+                }\n+                true\n+            }\n+\n             (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n             | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n             | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))\n@@ -268,6 +279,31 @@ impl InferenceTable {\n         }\n     }\n \n+    fn unify_preds(\n+        &mut self,\n+        pred1: &GenericPredicate,\n+        pred2: &GenericPredicate,\n+        depth: usize,\n+    ) -> bool {\n+        match (pred1, pred2) {\n+            (GenericPredicate::Implemented(tr1), GenericPredicate::Implemented(tr2))\n+                if tr1.trait_ == tr2.trait_ =>\n+            {\n+                self.unify_substs(&tr1.substs, &tr2.substs, depth + 1)\n+            }\n+            (GenericPredicate::Projection(proj1), GenericPredicate::Projection(proj2))\n+                if proj1.projection_ty.associated_ty == proj2.projection_ty.associated_ty =>\n+            {\n+                self.unify_substs(\n+                    &proj1.projection_ty.parameters,\n+                    &proj2.projection_ty.parameters,\n+                    depth + 1,\n+                ) && self.unify_inner(&proj1.ty, &proj2.ty, depth + 1)\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     /// If `ty` is a type variable with known type, returns that type;\n     /// otherwise, return ty.\n     pub fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {"}, {"sha": "a4b8d66837ccd10c528a6707914d438857b43445", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -396,12 +396,12 @@ impl Substs {\n     }\n \n     /// Return Substs that replace each parameter by a bound variable.\n-    pub(crate) fn bound_vars(generic_params: &Generics) -> Substs {\n+    pub(crate) fn bound_vars(generic_params: &Generics, debruijn: DebruijnIndex) -> Substs {\n         Substs(\n             generic_params\n                 .iter()\n                 .enumerate()\n-                .map(|(idx, _)| Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, idx)))\n+                .map(|(idx, _)| Ty::Bound(BoundVar::new(debruijn, idx)))\n                 .collect(),\n         )\n     }"}, {"sha": "c2812e1783e64422fa6221699b2f253a4debad49", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -39,6 +39,7 @@ use crate::{\n pub struct TyLoweringContext<'a> {\n     pub db: &'a dyn HirDatabase,\n     pub resolver: &'a Resolver,\n+    in_binders: DebruijnIndex,\n     /// Note: Conceptually, it's thinkable that we could be in a location where\n     /// some type params should be represented as placeholders, and others\n     /// should be converted to variables. I think in practice, this isn't\n@@ -53,7 +54,27 @@ impl<'a> TyLoweringContext<'a> {\n         let impl_trait_counter = std::cell::Cell::new(0);\n         let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n         let type_param_mode = TypeParamLoweringMode::Placeholder;\n-        Self { db, resolver, impl_trait_mode, impl_trait_counter, type_param_mode }\n+        let in_binders = DebruijnIndex::INNERMOST;\n+        Self { db, resolver, in_binders, impl_trait_mode, impl_trait_counter, type_param_mode }\n+    }\n+\n+    pub fn with_shifted_in<T>(\n+        &self,\n+        debruijn: DebruijnIndex,\n+        f: impl FnOnce(&TyLoweringContext) -> T,\n+    ) -> T {\n+        let new_ctx = Self {\n+            in_binders: self.in_binders.shifted_in_from(debruijn),\n+            impl_trait_counter: std::cell::Cell::new(self.impl_trait_counter.get()),\n+            ..*self\n+        };\n+        let result = f(&new_ctx);\n+        self.impl_trait_counter.set(new_ctx.impl_trait_counter.get());\n+        result\n+    }\n+\n+    pub fn shifted_in(self, debruijn: DebruijnIndex) -> Self {\n+        Self { in_binders: self.in_binders.shifted_in_from(debruijn), ..self }\n     }\n \n     pub fn with_impl_trait_mode(self, impl_trait_mode: ImplTraitLoweringMode) -> Self {\n@@ -134,22 +155,26 @@ impl Ty {\n             }\n             TypeRef::DynTrait(bounds) => {\n                 let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n-                let predicates = bounds\n-                    .iter()\n-                    .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n-                    .collect();\n+                let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n+                    bounds\n+                        .iter()\n+                        .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n+                        .collect()\n+                });\n                 Ty::Dyn(predicates)\n             }\n             TypeRef::ImplTrait(bounds) => {\n                 match ctx.impl_trait_mode {\n                     ImplTraitLoweringMode::Opaque => {\n                         let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n-                        let predicates = bounds\n-                            .iter()\n-                            .flat_map(|b| {\n-                                GenericPredicate::from_type_bound(ctx, b, self_ty.clone())\n-                            })\n-                            .collect();\n+                        let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n+                            bounds\n+                                .iter()\n+                                .flat_map(|b| {\n+                                    GenericPredicate::from_type_bound(ctx, b, self_ty.clone())\n+                                })\n+                                .collect()\n+                        });\n                         Ty::Opaque(predicates)\n                     }\n                     ImplTraitLoweringMode::Param => {\n@@ -180,7 +205,7 @@ impl Ty {\n                                 (0, 0, 0, 0)\n                             };\n                         Ty::Bound(BoundVar::new(\n-                            DebruijnIndex::INNERMOST,\n+                            ctx.in_binders,\n                             idx as usize + parent_params + self_params + list_params,\n                         ))\n                     }\n@@ -293,7 +318,7 @@ impl Ty {\n                     TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n                     TypeParamLoweringMode::Variable => {\n                         let idx = generics.param_idx(param_id).expect(\"matching generics\");\n-                        Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n+                        Ty::Bound(BoundVar::new(ctx.in_binders, idx))\n                     }\n                 }\n             }\n@@ -303,7 +328,9 @@ impl Ty {\n                     TypeParamLoweringMode::Placeholder => {\n                         Substs::type_params_for_generics(&generics)\n                     }\n-                    TypeParamLoweringMode::Variable => Substs::bound_vars(&generics),\n+                    TypeParamLoweringMode::Variable => {\n+                        Substs::bound_vars(&generics, ctx.in_binders)\n+                    }\n                 };\n                 ctx.db.impl_self_ty(impl_id).subst(&substs)\n             }\n@@ -313,7 +340,9 @@ impl Ty {\n                     TypeParamLoweringMode::Placeholder => {\n                         Substs::type_params_for_generics(&generics)\n                     }\n-                    TypeParamLoweringMode::Variable => Substs::bound_vars(&generics),\n+                    TypeParamLoweringMode::Variable => {\n+                        Substs::bound_vars(&generics, ctx.in_binders)\n+                    }\n                 };\n                 ctx.db.ty(adt.into()).subst(&substs)\n             }\n@@ -797,7 +826,7 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n /// function body.\n fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), def.into());\n-    let substs = Substs::bound_vars(&generics);\n+    let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n }\n \n@@ -851,7 +880,7 @@ fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<T\n         return type_for_adt(db, def.into());\n     }\n     let generics = generics(db.upcast(), def.into());\n-    let substs = Substs::bound_vars(&generics);\n+    let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n }\n \n@@ -876,13 +905,13 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n         return type_for_adt(db, def.parent.into());\n     }\n     let generics = generics(db.upcast(), def.parent.into());\n-    let substs = Substs::bound_vars(&generics);\n+    let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(substs.len(), Ty::apply(TypeCtor::FnDef(def.into()), substs))\n }\n \n fn type_for_adt(db: &dyn HirDatabase, adt: AdtId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), adt.into());\n-    let substs = Substs::bound_vars(&generics);\n+    let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     Binders::new(substs.len(), Ty::apply(TypeCtor::Adt(adt), substs))\n }\n \n@@ -892,7 +921,7 @@ fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let type_ref = &db.type_alias_data(t).type_ref;\n-    let substs = Substs::bound_vars(&generics);\n+    let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n     let inner = Ty::from_hir(&ctx, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n     Binders::new(substs.len(), inner)\n }"}, {"sha": "61284d67220d50176eea2cddcaed4cfad4c96598", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -484,3 +484,52 @@ fn main() {\n \n     assert_eq!(\"()\", super::type_at_pos(&db, pos));\n }\n+\n+#[test]\n+fn issue_3999_slice() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo(params: &[usize]) {\n+    match params {\n+        [ps @ .., _] => {}\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [8; 14) 'params': &[usize]\n+    [26; 81) '{     ...   } }': ()\n+    [32; 79) 'match ...     }': ()\n+    [38; 44) 'params': &[usize]\n+    [55; 67) '[ps @ .., _]': [usize]\n+    [65; 66) '_': usize\n+    [71; 73) '{}': ()\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn issue_3999_struct() {\n+    // rust-analyzer should not panic on seeing this malformed\n+    // record pattern.\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Bar {\n+    a: bool,\n+}\n+fn foo(b: Bar) {\n+    match b {\n+        Bar { a: .. } => {},\n+    }\n+}\n+\"#),\n+        @r###\"\n+    [36; 37) 'b': Bar\n+    [44; 96) '{     ...   } }': ()\n+    [50; 94) 'match ...     }': ()\n+    [56; 57) 'b': Bar\n+    [68; 81) 'Bar { a: .. }': Bar\n+    [77; 79) '..': bool\n+    [85; 87) '{}': ()\n+    \"###\n+    );\n+}"}, {"sha": "a46f03b7f5755b7b0f8ac6ef5c411c60b40afc0a", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -1210,6 +1210,42 @@ fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n     );\n }\n \n+#[test]\n+fn dyn_trait_in_impl() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T, U> {\n+    fn foo(&self) -> (T, U);\n+}\n+struct S<T, U> {}\n+impl<T, U> S<T, U> {\n+    fn bar(&self) -> &dyn Trait<T, U> { loop {} }\n+}\n+trait Trait2<T, U> {\n+    fn baz(&self) -> (T, U);\n+}\n+impl<T, U> Trait2<T, U> for dyn Trait<T, U> { }\n+\n+fn test(s: S<u32, i32>) {\n+    s.bar().baz();\n+}\n+\"#),\n+        @r###\"\n+    [33; 37) 'self': &Self\n+    [103; 107) 'self': &S<T, U>\n+    [129; 140) '{ loop {} }': &dyn Trait<T, U>\n+    [131; 138) 'loop {}': !\n+    [136; 138) '{}': ()\n+    [176; 180) 'self': &Self\n+    [252; 253) 's': S<u32, i32>\n+    [268; 290) '{     ...z(); }': ()\n+    [274; 275) 's': S<u32, i32>\n+    [274; 281) 's.bar()': &dyn Trait<u32, i32>\n+    [274; 287) 's.bar().baz()': (u32, i32)\n+    \"###\n+    );\n+}\n+\n #[test]\n fn dyn_trait_bare() {\n     assert_snapshot!(\n@@ -2204,3 +2240,201 @@ fn test(x: Box<dyn Trait>) {\n     );\n     assert_eq!(t, \"()\");\n }\n+\n+#[test]\n+fn string_to_owned() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct String {}\n+pub trait ToOwned {\n+    type Owned;\n+    fn to_owned(&self) -> Self::Owned;\n+}\n+impl ToOwned for str {\n+    type Owned = String;\n+}\n+fn test() {\n+    \"foo\".to_owned()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"String\");\n+}\n+\n+#[test]\n+fn iterator_chain() {\n+    assert_snapshot!(\n+        infer(r#\"\n+//- /main.rs\n+#[lang = \"fn_once\"]\n+trait FnOnce<Args> {\n+    type Output;\n+}\n+#[lang = \"fn_mut\"]\n+trait FnMut<Args>: FnOnce<Args> { }\n+\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+pub trait Iterator {\n+    type Item;\n+\n+    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F>\n+    where\n+        F: FnMut(Self::Item) -> Option<B>,\n+    { loop {} }\n+\n+    fn for_each<F>(self, f: F)\n+    where\n+        F: FnMut(Self::Item),\n+    { loop {} }\n+}\n+\n+pub trait IntoIterator {\n+    type Item;\n+    type IntoIter: Iterator<Item = Self::Item>;\n+    fn into_iter(self) -> Self::IntoIter;\n+}\n+\n+pub struct FilterMap<I, F> { }\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> IntoIterator for I {\n+    type Item = I::Item;\n+    type IntoIter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+struct Vec<T> {}\n+impl<T> Vec<T> {\n+    fn new() -> Self { loop {} }\n+}\n+\n+impl<T> IntoIterator for Vec<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+}\n+\n+pub struct IntoIter<T> { }\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+}\n+\n+fn main() {\n+    Vec::<i32>::new().into_iter()\n+      .filter_map(|x| if x > 0 { Some(x as u32) } else { None })\n+      .for_each(|y| { y; });\n+}\n+\"#),\n+        @r###\"\n+    [240; 244) 'self': Self\n+    [246; 247) 'f': F\n+    [331; 342) '{ loop {} }': FilterMap<Self, F>\n+    [333; 340) 'loop {}': !\n+    [338; 340) '{}': ()\n+    [363; 367) 'self': Self\n+    [369; 370) 'f': F\n+    [419; 430) '{ loop {} }': ()\n+    [421; 428) 'loop {}': !\n+    [426; 428) '{}': ()\n+    [539; 543) 'self': Self\n+    [868; 872) 'self': I\n+    [879; 899) '{     ...     }': I\n+    [889; 893) 'self': I\n+    [958; 969) '{ loop {} }': Vec<T>\n+    [960; 967) 'loop {}': !\n+    [965; 967) '{}': ()\n+    [1156; 1287) '{     ... }); }': ()\n+    [1162; 1177) 'Vec::<i32>::new': fn new<i32>() -> Vec<i32>\n+    [1162; 1179) 'Vec::<...:new()': Vec<i32>\n+    [1162; 1191) 'Vec::<...iter()': IntoIter<i32>\n+    [1162; 1256) 'Vec::<...one })': FilterMap<IntoIter<i32>, |i32| -> Option<u32>>\n+    [1162; 1284) 'Vec::<... y; })': ()\n+    [1210; 1255) '|x| if...None }': |i32| -> Option<u32>\n+    [1211; 1212) 'x': i32\n+    [1214; 1255) 'if x >...None }': Option<u32>\n+    [1217; 1218) 'x': i32\n+    [1217; 1222) 'x > 0': bool\n+    [1221; 1222) '0': i32\n+    [1223; 1241) '{ Some...u32) }': Option<u32>\n+    [1225; 1229) 'Some': Some<u32>(u32) -> Option<u32>\n+    [1225; 1239) 'Some(x as u32)': Option<u32>\n+    [1230; 1231) 'x': i32\n+    [1230; 1238) 'x as u32': u32\n+    [1247; 1255) '{ None }': Option<u32>\n+    [1249; 1253) 'None': Option<u32>\n+    [1273; 1283) '|y| { y; }': |u32| -> ()\n+    [1274; 1275) 'y': u32\n+    [1277; 1283) '{ y; }': ()\n+    [1279; 1280) 'y': u32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn nested_assoc() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct Bar;\n+struct Foo;\n+\n+trait A {\n+    type OutputA;\n+}\n+\n+impl A for Bar {\n+    type OutputA = Foo;\n+}\n+\n+trait B {\n+    type Output;\n+    fn foo() -> Self::Output;\n+}\n+\n+impl<T:A> B for T {\n+    type Output = T::OutputA;\n+    fn foo() -> Self::Output { loop {} }\n+}\n+\n+fn main() {\n+    Bar::foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"Foo\");\n+}\n+\n+#[test]\n+fn trait_object_no_coercion() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Foo {}\n+\n+fn foo(x: &dyn Foo) {}\n+\n+fn test(x: &dyn Foo) {\n+    foo(x);\n+}\n+\"#, true),\n+        @r###\"\n+    [22; 23) 'x': &dyn Foo\n+    [35; 37) '{}': ()\n+    [47; 48) 'x': &dyn Foo\n+    [60; 75) '{     foo(x); }': ()\n+    [66; 69) 'foo': fn foo(&dyn Foo)\n+    [66; 72) 'foo(x)': ()\n+    [70; 71) 'x': &dyn Foo\n+    \"###\n+    );\n+}"}, {"sha": "e00a82db2a895feefb934b60546b31f0778db2fa", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -17,7 +17,7 @@ use ra_db::{\n use super::{builtin, AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n     db::HirDatabase, display::HirDisplay, method_resolution::TyFingerprint, utils::generics,\n-    ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    ApplicationTy, DebruijnIndex, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n \n pub(super) mod tls;\n@@ -815,7 +815,7 @@ pub(crate) fn associated_ty_data_query(\n     // Lower bounds -- we could/should maybe move this to a separate query in `lower`\n     let type_alias_data = db.type_alias_data(type_alias);\n     let generic_params = generics(db.upcast(), type_alias.into());\n-    let bound_vars = Substs::bound_vars(&generic_params);\n+    let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n     let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n         .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n@@ -849,7 +849,7 @@ pub(crate) fn trait_datum_query(\n     let trait_data = db.trait_data(trait_);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n     let generic_params = generics(db.upcast(), trait_.into());\n-    let bound_vars = Substs::bound_vars(&generic_params);\n+    let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n     let flags = chalk_rust_ir::TraitFlags {\n         auto: trait_data.auto,\n         upstream: trait_.lookup(db.upcast()).container.module(db.upcast()).krate != krate,\n@@ -888,7 +888,7 @@ pub(crate) fn struct_datum_query(\n         .as_generic_def()\n         .map(|generic_def| {\n             let generic_params = generics(db.upcast(), generic_def);\n-            let bound_vars = Substs::bound_vars(&generic_params);\n+            let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n             convert_where_clauses(db, generic_def, &bound_vars)\n         })\n         .unwrap_or_else(Vec::new);\n@@ -934,7 +934,7 @@ fn impl_def_datum(\n     let impl_data = db.impl_data(impl_id);\n \n     let generic_params = generics(db.upcast(), impl_id.into());\n-    let bound_vars = Substs::bound_vars(&generic_params);\n+    let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n     let trait_ = trait_ref.trait_;\n     let impl_type = if impl_id.lookup(db.upcast()).container.module(db.upcast()).krate == krate {\n         chalk_rust_ir::ImplType::Local"}, {"sha": "2ec0e7ce9df356c6d1f2a1e9a25964fc44e8436a", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -142,11 +142,11 @@ fn add_function_impl(\n         CompletionItemKind::Function\n     };\n \n-    let snippet = format!(\"{} {{}}\", display);\n+    let snippet = format!(\"{} {{\\n    $0\\n}}\", display);\n \n     let range = TextRange::from_to(fn_def_node.text_range().start(), ctx.source_range().end());\n \n-    builder.text_edit(TextEdit::replace(range, snippet)).kind(completion_kind).add_to(acc);\n+    builder.snippet_edit(TextEdit::replace(range, snippet)).kind(completion_kind).add_to(acc);\n }\n \n fn add_type_alias_impl(\n@@ -217,9 +217,10 @@ fn make_const_compl_syntax(const_: &ast::ConstDef) -> String {\n \n #[cfg(test)]\n mod tests {\n-    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n     use insta::assert_debug_snapshot;\n \n+    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n+\n     fn complete(code: &str) -> Vec<CompletionItem> {\n         do_completion(code, CompletionKind::Magic)\n     }\n@@ -255,7 +256,7 @@ mod tests {\n                 label: \"fn test()\",\n                 source_range: [209; 210),\n                 delete: [209; 210),\n-                insert: \"fn test() {}\",\n+                insert: \"fn test() {\\n    $0\\n}\",\n                 kind: Function,\n                 lookup: \"test\",\n             },\n@@ -313,7 +314,7 @@ mod tests {\n                 label: \"fn test()\",\n                 source_range: [139; 140),\n                 delete: [139; 140),\n-                insert: \"fn test() {}\",\n+                insert: \"fn test() {\\n    $0\\n}\",\n                 kind: Function,\n                 lookup: \"test\",\n             },\n@@ -342,7 +343,7 @@ mod tests {\n                 label: \"fn foo()\",\n                 source_range: [141; 142),\n                 delete: [138; 142),\n-                insert: \"fn foo() {}\",\n+                insert: \"fn foo() {\\n    $0\\n}\",\n                 kind: Function,\n                 lookup: \"foo\",\n             },\n@@ -374,7 +375,7 @@ mod tests {\n                 label: \"fn foo_bar()\",\n                 source_range: [200; 201),\n                 delete: [197; 201),\n-                insert: \"fn foo_bar() {}\",\n+                insert: \"fn foo_bar() {\\n    $0\\n}\",\n                 kind: Function,\n                 lookup: \"foo_bar\",\n             },\n@@ -425,7 +426,7 @@ mod tests {\n                 label: \"fn foo()\",\n                 source_range: [144; 145),\n                 delete: [141; 145),\n-                insert: \"fn foo<T>() {}\",\n+                insert: \"fn foo<T>() {\\n    $0\\n}\",\n                 kind: Function,\n                 lookup: \"foo\",\n             },\n@@ -454,7 +455,7 @@ mod tests {\n                 label: \"fn foo()\",\n                 source_range: [166; 167),\n                 delete: [163; 167),\n-                insert: \"fn foo<T>()\\nwhere T: Into<String> {}\",\n+                insert: \"fn foo<T>()\\nwhere T: Into<String> {\\n    $0\\n}\",\n                 kind: Function,\n                 lookup: \"foo\",\n             },"}, {"sha": "ad5fdcc4ea47c7d68295c61afbb9aba2ed251381", "filename": "crates/ra_ide/src/completion/complete_unqualified_path.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -1,6 +1,10 @@\n //! Completion of names from the current scope, e.g. locals and imported items.\n \n+use hir::ScopeDef;\n+use test_utils::tested_by;\n+\n use crate::completion::{CompletionContext, Completions};\n+use ra_syntax::AstNode;\n \n pub(super) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_trivial_path {\n@@ -14,19 +18,53 @@ pub(super) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         return;\n     }\n \n-    ctx.scope().process_all_names(&mut |name, res| acc.add_resolution(ctx, name.to_string(), &res));\n+    ctx.scope().process_all_names(&mut |name, res| {\n+        if ctx.use_item_syntax.is_some() {\n+            if let (ScopeDef::Unknown, Some(name_ref)) = (&res, &ctx.name_ref_syntax) {\n+                if name_ref.syntax().text() == name.to_string().as_str() {\n+                    tested_by!(self_fulfilling_completion);\n+                    return;\n+                }\n+            }\n+        }\n+        acc.add_resolution(ctx, name.to_string(), &res)\n+    });\n }\n \n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;\n+    use test_utils::covers;\n \n     use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n \n     fn do_reference_completion(ra_fixture: &str) -> Vec<CompletionItem> {\n         do_completion(ra_fixture, CompletionKind::Reference)\n     }\n \n+    #[test]\n+    fn self_fulfilling_completion() {\n+        covers!(self_fulfilling_completion);\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r#\"\n+                use foo<|>\n+                use std::collections;\n+                \"#,\n+            ),\n+            @r###\"\n+            [\n+                CompletionItem {\n+                    label: \"collections\",\n+                    source_range: [21; 24),\n+                    delete: [21; 24),\n+                    insert: \"collections\",\n+                },\n+            ]\n+            \"###\n+        );\n+    }\n+\n     #[test]\n     fn bind_pat_and_path_ignore_at() {\n         assert_debug_snapshot!("}, {"sha": "e7e201709880c9c947bf0d6d5e2da7437f93cb6e", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -1,4 +1,8 @@\n-//! FIXME: write short doc here\n+//! Collects diagnostics & fixits  for a single file.\n+//!\n+//! The tricky bit here is that diagnostics are produced by hir in terms of\n+//! macro-expanded files, but we need to present them to the users in terms of\n+//! original files. So we need to map the ranges.\n \n use std::cell::RefCell;\n \n@@ -46,7 +50,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n     let mut sink = DiagnosticSink::new(|d| {\n         res.borrow_mut().push(Diagnostic {\n             message: d.message(),\n-            range: d.highlight_range(),\n+            range: sema.diagnostics_range(d).range,\n             severity: Severity::Error,\n             fix: None,\n         })\n@@ -62,7 +66,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         let create_file = FileSystemEdit::CreateFile { source_root, path };\n         let fix = SourceChange::file_system_edit(\"create module\", create_file);\n         res.borrow_mut().push(Diagnostic {\n-            range: d.highlight_range(),\n+            range: sema.diagnostics_range(d).range,\n             message: d.message(),\n             severity: Severity::Error,\n             fix: Some(fix),\n@@ -95,15 +99,15 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         };\n \n         res.borrow_mut().push(Diagnostic {\n-            range: d.highlight_range(),\n+            range: sema.diagnostics_range(d).range,\n             message: d.message(),\n             severity: Severity::Error,\n             fix,\n         })\n     })\n     .on::<hir::diagnostics::MissingMatchArms, _>(|d| {\n         res.borrow_mut().push(Diagnostic {\n-            range: d.highlight_range(),\n+            range: sema.diagnostics_range(d).range,\n             message: d.message(),\n             severity: Severity::Error,\n             fix: None,\n@@ -115,7 +119,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         let edit = TextEdit::replace(node.syntax().text_range(), replacement);\n         let fix = SourceChange::source_file_edit_from(\"wrap with ok\", file_id, edit);\n         res.borrow_mut().push(Diagnostic {\n-            range: d.highlight_range(),\n+            range: sema.diagnostics_range(d).range,\n             message: d.message(),\n             severity: Severity::Error,\n             fix: Some(fix),\n@@ -621,6 +625,62 @@ mod tests {\n         \"###);\n     }\n \n+    #[test]\n+    fn range_mapping_out_of_macros() {\n+        let (analysis, file_id) = single_file(\n+            r\"\n+            fn some() {}\n+            fn items() {}\n+            fn here() {}\n+\n+            macro_rules! id {\n+                ($($tt:tt)*) => { $($tt)*};\n+            }\n+\n+            fn main() {\n+                let _x = id![Foo { a: 42 }];\n+            }\n+\n+            pub struct Foo {\n+                pub a: i32,\n+                pub b: i32,\n+            }\n+        \",\n+        );\n+        let diagnostics = analysis.diagnostics(file_id).unwrap();\n+        assert_debug_snapshot!(diagnostics, @r###\"\n+        [\n+            Diagnostic {\n+                message: \"Missing structure fields:\\n- b\",\n+                range: [224; 233),\n+                fix: Some(\n+                    SourceChange {\n+                        label: \"fill struct fields\",\n+                        source_file_edits: [\n+                            SourceFileEdit {\n+                                file_id: FileId(\n+                                    1,\n+                                ),\n+                                edit: TextEdit {\n+                                    atoms: [\n+                                        AtomTextEdit {\n+                                            delete: [3; 9),\n+                                            insert: \"{a:42, b: ()}\",\n+                                        },\n+                                    ],\n+                                },\n+                            },\n+                        ],\n+                        file_system_edits: [],\n+                        cursor_position: None,\n+                    },\n+                ),\n+                severity: Error,\n+            },\n+        ]\n+        \"###);\n+    }\n+\n     #[test]\n     fn test_check_unnecessary_braces_in_use_statement() {\n         check_not_applicable("}, {"sha": "0774fa0a14f0181fa221ee364ed2457f539143a6", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -237,7 +237,8 @@ fn should_show_param_hint(\n ) -> bool {\n     if param_name.is_empty()\n         || is_argument_similar_to_param(argument, param_name)\n-        || Some(param_name) == fn_signature.name.as_ref().map(String::as_str)\n+        || Some(param_name.trim_start_matches('_'))\n+            == fn_signature.name.as_ref().map(|s| s.trim_start_matches('_'))\n     {\n         return false;\n     }\n@@ -255,6 +256,8 @@ fn should_show_param_hint(\n \n fn is_argument_similar_to_param(argument: &ast::Expr, param_name: &str) -> bool {\n     let argument_string = remove_ref(argument.clone()).syntax().to_string();\n+    let param_name = param_name.trim_start_matches('_');\n+    let argument_string = argument_string.trim_start_matches('_');\n     argument_string.starts_with(&param_name) || argument_string.ends_with(&param_name)\n }\n \n@@ -1094,8 +1097,10 @@ struct Param {}\n \n fn different_order(param: &Param) {}\n fn different_order_mut(param: &mut Param) {}\n+fn has_underscore(_param: bool) {}\n \n fn twiddle(twiddle: bool) {}\n+fn doo(_doo: bool) {}\n \n fn main() {\n     let container: TestVarContainer = TestVarContainer { test_var: 42 };\n@@ -1112,11 +1117,15 @@ fn main() {\n     test_processed.frob(false);\n \n     twiddle(true);\n+    doo(true);\n \n     let param_begin: Param = Param {};\n     different_order(&param_begin);\n     different_order(&mut param_begin);\n \n+    let param: bool = true;\n+    has_underscore(param);\n+\n     let a: f64 = 7.0;\n     let b: f64 = 4.0;\n     let _: f64 = a.div_euclid(b);"}, {"sha": "eee44e88697537a161cd9485465e2550e35b1cc0", "filename": "crates/ra_ide/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarks.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -8,4 +8,5 @@ test_utils::marks!(\n     test_resolve_parent_module_on_module_decl\n     search_filters_by_range\n     dont_insert_macro_call_parens_unncessary\n+    self_fulfilling_completion\n );"}, {"sha": "7b15b82bdb6d4bb7333b15f4811673dcb69753db", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -174,7 +174,8 @@ pub(crate) fn highlight(\n     }\n \n     assert_eq!(res.len(), 1, \"after DFS traversal, the stack should only contain a single element\");\n-    let res = res.pop().unwrap();\n+    let mut res = res.pop().unwrap();\n+    res.sort_by_key(|range| range.range.start());\n     // Check that ranges are sorted and disjoint\n     assert!(res\n         .iter()"}, {"sha": "73611e23a5a50c397a2dc3762e1015aba6be5c9e", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -156,3 +156,15 @@ fn main() {\n     fs::write(dst_file, &actual_html).unwrap();\n     assert_eq_text!(expected_html, actual_html);\n }\n+\n+#[test]\n+fn ranges_sorted() {\n+    let (analysis, file_id) = single_file(\n+        r#\"\n+#[foo(bar = \"bar\")]\n+macro_rules! test {}\n+}\"#\n+        .trim(),\n+    );\n+    let _ = analysis.highlight(file_id).unwrap();\n+}"}, {"sha": "ac2d156dc29217665a9a640d35fffb4aee03a837", "filename": "crates/ra_proc_macro_srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_proc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_proc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2FCargo.toml?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -14,6 +14,7 @@ ra_mbe = { path = \"../ra_mbe\" }\n ra_proc_macro = { path = \"../ra_proc_macro\" }\n goblin = \"0.2.1\"\n libloading = \"0.6.0\"\n+memmap = \"0.7\"\n test_utils = { path = \"../test_utils\" }\n \n [dev-dependencies]"}, {"sha": "16bd7466e3862fc5166e2fa378b7de08a12f96b1", "filename": "crates/ra_proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -1,10 +1,12 @@\n //! Handles dynamic library loading for proc macro\n \n use crate::{proc_macro::bridge, rustc_server::TokenStream};\n+use std::fs::File;\n use std::path::Path;\n \n use goblin::{mach::Mach, Object};\n use libloading::Library;\n+use memmap::Mmap;\n use ra_proc_macro::ProcMacroKind;\n \n use std::io::Error as IoError;\n@@ -16,55 +18,54 @@ fn invalid_data_err(e: impl Into<Box<dyn std::error::Error + Send + Sync>>) -> I\n     IoError::new(IoErrorKind::InvalidData, e)\n }\n \n-fn get_symbols_from_lib(file: &Path) -> Result<Vec<String>, IoError> {\n-    let buffer = std::fs::read(file)?;\n+fn is_derive_registrar_symbol(symbol: &str) -> bool {\n+    symbol.contains(NEW_REGISTRAR_SYMBOL)\n+}\n+\n+fn find_registrar_symbol(file: &Path) -> Result<Option<String>, IoError> {\n+    let file = File::open(file)?;\n+    let buffer = unsafe { Mmap::map(&file)? };\n     let object = Object::parse(&buffer).map_err(invalid_data_err)?;\n \n     match object {\n         Object::Elf(elf) => {\n             let symbols = elf.dynstrtab.to_vec().map_err(invalid_data_err)?;\n-            let names = symbols.iter().map(|s| s.to_string()).collect();\n-            Ok(names)\n+            let name =\n+                symbols.iter().find(|s| is_derive_registrar_symbol(s)).map(|s| s.to_string());\n+            Ok(name)\n         }\n         Object::PE(pe) => {\n-            let symbol_names =\n-                pe.exports.iter().flat_map(|s| s.name).map(|n| n.to_string()).collect();\n-            Ok(symbol_names)\n+            let name = pe\n+                .exports\n+                .iter()\n+                .flat_map(|s| s.name)\n+                .find(|s| is_derive_registrar_symbol(s))\n+                .map(|s| s.to_string());\n+            Ok(name)\n         }\n-        Object::Mach(mach) => match mach {\n-            Mach::Binary(binary) => {\n-                let exports = binary.exports().map_err(invalid_data_err)?;\n-                let names = exports\n-                    .into_iter()\n-                    .map(|s| {\n-                        // In macos doc:\n-                        // https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlsym.3.html\n-                        // Unlike other dyld API's, the symbol name passed to dlsym() must NOT be\n-                        // prepended with an underscore.\n-                        if s.name.starts_with(\"_\") {\n-                            s.name[1..].to_string()\n-                        } else {\n-                            s.name\n-                        }\n-                    })\n-                    .collect();\n-                Ok(names)\n-            }\n-            Mach::Fat(_) => Ok(vec![]),\n-        },\n-        Object::Archive(_) | Object::Unknown(_) => Ok(vec![]),\n+        Object::Mach(Mach::Binary(binary)) => {\n+            let exports = binary.exports().map_err(invalid_data_err)?;\n+            let name = exports\n+                .iter()\n+                .map(|s| {\n+                    // In macos doc:\n+                    // https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlsym.3.html\n+                    // Unlike other dyld API's, the symbol name passed to dlsym() must NOT be\n+                    // prepended with an underscore.\n+                    if s.name.starts_with(\"_\") {\n+                        &s.name[1..]\n+                    } else {\n+                        &s.name\n+                    }\n+                })\n+                .find(|s| is_derive_registrar_symbol(s))\n+                .map(|s| s.to_string());\n+            Ok(name)\n+        }\n+        _ => Ok(None),\n     }\n }\n \n-fn is_derive_registrar_symbol(symbol: &str) -> bool {\n-    symbol.contains(NEW_REGISTRAR_SYMBOL)\n-}\n-\n-fn find_registrar_symbol(file: &Path) -> Result<Option<String>, IoError> {\n-    let symbols = get_symbols_from_lib(file)?;\n-    Ok(symbols.into_iter().find(|s| is_derive_registrar_symbol(s)))\n-}\n-\n /// Loads dynamic library in platform dependent manner.\n ///\n /// For unix, you have to use RTLD_DEEPBIND flag to escape problems described"}, {"sha": "762f776fea85e79c24aa6ae60a189f8046e11a52", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -75,9 +75,7 @@ pub(crate) fn load_cargo(\n     let proc_macro_client = if !with_proc_macro {\n         ProcMacroClient::dummy()\n     } else {\n-        let mut path = std::env::current_exe()?;\n-        path.pop();\n-        path.push(\"rust-analyzer\");\n+        let path = std::env::current_exe()?;\n         ProcMacroClient::extern_process(&path, &[\"proc-macro\"]).unwrap()\n     };\n     let host = load(&source_roots, ws, &mut vfs, receiver, extern_dirs, &proc_macro_client);"}, {"sha": "3597a14e362341526fb7b2923432453cd10f3810", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -134,9 +134,7 @@ impl Config {\n \n         match get::<bool>(value, \"/procMacro/enabled\") {\n             Some(true) => {\n-                if let Ok(mut path) = std::env::current_exe() {\n-                    path.pop();\n-                    path.push(\"rust-analyzer\");\n+                if let Ok(path) = std::env::current_exe() {\n                     self.proc_macro_srv = Some((path.to_string_lossy().to_string(), vec![\"proc-macro\".to_string()]));\n                 }\n             }"}, {"sha": "ead642acc6db0a71fc59eac730b8d69d15ba1b39", "filename": "xtask/tests/tidy-tests/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/xtask%2Ftests%2Ftidy-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4/xtask%2Ftests%2Ftidy-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fmain.rs?ref=af3c19e85f55db9277ce9ad5b784df2ccfe3c9e4", "patch": "@@ -35,7 +35,7 @@ fn check_todo(path: &Path, text: &str) {\n     }\n     if text.contains(\"TODO\") || text.contains(\"TOOD\") || text.contains(\"todo!\") {\n         panic!(\n-            \"\\nTODO markers should not be committed to the master branch,\\n\\\n+            \"\\nTODO markers or todo! macros should not be committed to the master branch,\\n\\\n              use FIXME instead\\n\\\n              {}\\n\",\n             path.display(),\n@@ -47,9 +47,9 @@ fn check_trailing_ws(path: &Path, text: &str) {\n     if is_exclude_dir(path, &[\"test_data\"]) {\n         return;\n     }\n-    for line in text.lines() {\n+    for (line_number, line) in text.lines().enumerate() {\n         if line.chars().last().map(char::is_whitespace) == Some(true) {\n-            panic!(\"Trailing whitespace in {}\", path.display())\n+            panic!(\"Trailing whitespace in {} at line {}\", path.display(), line_number)\n         }\n     }\n }"}]}