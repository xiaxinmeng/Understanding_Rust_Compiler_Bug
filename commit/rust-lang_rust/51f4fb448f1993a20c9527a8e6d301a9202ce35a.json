{"sha": "51f4fb448f1993a20c9527a8e6d301a9202ce35a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZjRmYjQ0OGYxOTkzYTIwYzk1MjdhOGU2ZDMwMWE5MjAyY2UzNWE=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-12-07T11:20:41Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-12-07T11:24:15Z"}, "message": "Refactor resolve_imports logic", "tree": {"sha": "112fe280ceeb3d27d79ff79f31aabae170aafd78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/112fe280ceeb3d27d79ff79f31aabae170aafd78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51f4fb448f1993a20c9527a8e6d301a9202ce35a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51f4fb448f1993a20c9527a8e6d301a9202ce35a", "html_url": "https://github.com/rust-lang/rust/commit/51f4fb448f1993a20c9527a8e6d301a9202ce35a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51f4fb448f1993a20c9527a8e6d301a9202ce35a/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5997e174666435acd5abb4531f833bd41bbdb00", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5997e174666435acd5abb4531f833bd41bbdb00", "html_url": "https://github.com/rust-lang/rust/commit/e5997e174666435acd5abb4531f833bd41bbdb00"}], "stats": {"total": 169, "additions": 129, "deletions": 40}, "files": [{"sha": "3b3f30eecf084a24d1aed8dfb7726971177bd04f", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 120, "deletions": 36, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/51f4fb448f1993a20c9527a8e6d301a9202ce35a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51f4fb448f1993a20c9527a8e6d301a9202ce35a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=51f4fb448f1993a20c9527a8e6d301a9202ce35a", "patch": "@@ -58,6 +58,8 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         def_map,\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n+        resolved_imports: Vec::new(),\n+\n         unexpanded_macros: Vec::new(),\n         unexpanded_attribute_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n@@ -97,12 +99,41 @@ impl MacroStackMonitor {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+enum PartialResolvedImport {\n+    /// None of any namespaces is resolved\n+    Unresolved,\n+    /// One of namespaces is resolved\n+    Indeterminate(PerNs),\n+    /// All namespaces are resolved, OR it is came from other crate\n+    Resolved(PerNs),\n+}\n+\n+impl PartialResolvedImport {\n+    fn namespaces(&self) -> PerNs {\n+        match self {\n+            PartialResolvedImport::Unresolved => PerNs::none(),\n+            PartialResolvedImport::Indeterminate(ns) => *ns,\n+            PartialResolvedImport::Resolved(ns) => *ns,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct ImportDirective {\n+    module_id: LocalModuleId,\n+    import_id: LocalImportId,\n+    import: raw::ImportData,\n+    status: PartialResolvedImport,\n+}\n+\n /// Walks the tree of module recursively\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, LocalImportId)>>,\n-    unresolved_imports: Vec<(LocalModuleId, LocalImportId, raw::ImportData)>,\n+    unresolved_imports: Vec<ImportDirective>,\n+    resolved_imports: Vec<ImportDirective>,\n     unexpanded_macros: Vec<(LocalModuleId, AstId<ast::MacroCall>, Path)>,\n     unexpanded_attribute_macros: Vec<(LocalModuleId, AstId<ast::ModuleItem>, Path)>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n@@ -148,20 +179,38 @@ where\n         let mut i = 0;\n         loop {\n             self.db.check_canceled();\n-            match (self.resolve_imports(), self.resolve_macros()) {\n-                (ReachedFixedPoint::Yes, ReachedFixedPoint::Yes) => break,\n-                _ => i += 1,\n+            self.resolve_imports();\n+\n+            match self.resolve_macros() {\n+                ReachedFixedPoint::Yes => break,\n+                ReachedFixedPoint::No => i += 1,\n             }\n             if i == 1000 {\n                 log::error!(\"name resolution is stuck\");\n                 break;\n             }\n         }\n \n+        // Resolve all indeterminate resolved imports again\n+        // As some of the macros will expand newly import shadowing partial resolved imports\n+        // FIXME: We maybe could skip this, if we handle the Indetermine imports in `resolve_imports`\n+        // correctly\n+        let partial_resolved = self.resolved_imports.iter().filter_map(|directive| {\n+            if let PartialResolvedImport::Indeterminate(_) = directive.status {\n+                let mut directive = directive.clone();\n+                directive.status = PartialResolvedImport::Unresolved;\n+                Some(directive)\n+            } else {\n+                None\n+            }\n+        });\n+        self.unresolved_imports.extend(partial_resolved);\n+        self.resolve_imports();\n+\n         let unresolved_imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n         // show unresolved imports in completion, etc\n-        for (module_id, import, import_data) in unresolved_imports {\n-            self.record_resolved_import(module_id, PerNs::none(), import, &import_data)\n+        for directive in unresolved_imports {\n+            self.record_resolved_import(&directive)\n         }\n     }\n \n@@ -262,31 +311,43 @@ where\n         }\n     }\n \n-    fn resolve_imports(&mut self) -> ReachedFixedPoint {\n-        let mut imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n-        let mut resolved = Vec::new();\n-        imports.retain(|(module_id, import, import_data)| {\n-            let (def, fp) = self.resolve_import(*module_id, import_data);\n-            if fp == ReachedFixedPoint::Yes {\n-                resolved.push((*module_id, def, *import, import_data.clone()))\n+    /// Import resolution\n+    ///\n+    /// This is a fix point algorithm. We resolve imports until no forward\n+    /// progress in resolving imports is made\n+    fn resolve_imports(&mut self) {\n+        let mut n_previous_unresolved = self.unresolved_imports.len() + 1;\n+\n+        while self.unresolved_imports.len() < n_previous_unresolved {\n+            n_previous_unresolved = self.unresolved_imports.len();\n+            let imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+            for mut directive in imports {\n+                directive.status = self.resolve_import(directive.module_id, &directive.import);\n+\n+                match directive.status {\n+                    PartialResolvedImport::Indeterminate(_) => {\n+                        self.record_resolved_import(&directive);\n+                        // FIXME: For avoid performance regression,\n+                        // we consider an imported resolved if it is indeterminate (i.e not all namespace resolved)\n+                        self.resolved_imports.push(directive)\n+                    }\n+                    PartialResolvedImport::Resolved(_) => {\n+                        self.record_resolved_import(&directive);\n+                        self.resolved_imports.push(directive)\n+                    }\n+                    PartialResolvedImport::Unresolved => {\n+                        self.unresolved_imports.push(directive);\n+                    }\n+                }\n             }\n-            fp == ReachedFixedPoint::No\n-        });\n-        self.unresolved_imports = imports;\n-        // Resolves imports, filling-in module scopes\n-        let result =\n-            if resolved.is_empty() { ReachedFixedPoint::Yes } else { ReachedFixedPoint::No };\n-        for (module_id, def, import, import_data) in resolved {\n-            self.record_resolved_import(module_id, def, import, &import_data)\n         }\n-        result\n     }\n \n     fn resolve_import(\n         &self,\n         module_id: LocalModuleId,\n         import: &raw::ImportData,\n-    ) -> (PerNs, ReachedFixedPoint) {\n+    ) -> PartialResolvedImport {\n         log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n         if import.is_extern_crate {\n             let res = self.def_map.resolve_name_in_extern_prelude(\n@@ -295,7 +356,7 @@ where\n                     .as_ident()\n                     .expect(\"extern crate should have been desugared to one-element path\"),\n             );\n-            (res, ReachedFixedPoint::Yes)\n+            PartialResolvedImport::Resolved(res)\n         } else {\n             let res = self.def_map.resolve_path_fp_with_macro(\n                 self.db,\n@@ -305,17 +366,35 @@ where\n                 BuiltinShadowMode::Module,\n             );\n \n-            (res.resolved_def, res.reached_fixedpoint)\n+            let def = res.resolved_def;\n+            if res.reached_fixedpoint == ReachedFixedPoint::No {\n+                return PartialResolvedImport::Unresolved;\n+            }\n+\n+            if let Some(krate) = res.krate {\n+                if krate != self.def_map.krate {\n+                    return PartialResolvedImport::Resolved(def);\n+                }\n+            }\n+\n+            // Check whether all namespace is resolved\n+            if def.take_types().is_some()\n+                && def.take_values().is_some()\n+                && def.take_macros().is_some()\n+            {\n+                PartialResolvedImport::Resolved(def)\n+            } else {\n+                PartialResolvedImport::Indeterminate(def)\n+            }\n         }\n     }\n \n-    fn record_resolved_import(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        def: PerNs,\n-        import_id: LocalImportId,\n-        import: &raw::ImportData,\n-    ) {\n+    fn record_resolved_import(&mut self, directive: &ImportDirective) {\n+        let module_id = directive.module_id;\n+        let import_id = directive.import_id;\n+        let import = &directive.import;\n+        let def = directive.status.namespaces();\n+\n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n             match def.take_types() {\n@@ -615,10 +694,14 @@ where\n                     raw::RawItemKind::Module(m) => {\n                         self.collect_module(&self.raw_items[m], &item.attrs)\n                     }\n-                    raw::RawItemKind::Import(import_id) => self\n-                        .def_collector\n-                        .unresolved_imports\n-                        .push((self.module_id, import_id, self.raw_items[import_id].clone())),\n+                    raw::RawItemKind::Import(import_id) => {\n+                        self.def_collector.unresolved_imports.push(ImportDirective {\n+                            module_id: self.module_id,\n+                            import_id,\n+                            import: self.raw_items[import_id].clone(),\n+                            status: PartialResolvedImport::Unresolved,\n+                        })\n+                    }\n                     raw::RawItemKind::Def(def) => {\n                         self.define_def(&self.raw_items[def], &item.attrs)\n                     }\n@@ -886,6 +969,7 @@ mod tests {\n             def_map,\n             glob_imports: FxHashMap::default(),\n             unresolved_imports: Vec::new(),\n+            resolved_imports: Vec::new(),\n             unexpanded_macros: Vec::new(),\n             unexpanded_attribute_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),"}, {"sha": "aab4b1dd97672ac744a15c54f1d020e569ca0ccc", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/51f4fb448f1993a20c9527a8e6d301a9202ce35a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51f4fb448f1993a20c9527a8e6d301a9202ce35a/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=51f4fb448f1993a20c9527a8e6d301a9202ce35a", "patch": "@@ -19,7 +19,7 @@ use crate::{\n     nameres::{BuiltinShadowMode, CrateDefMap},\n     path::{Path, PathKind},\n     per_ns::PerNs,\n-    AdtId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n+    AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -39,19 +39,21 @@ pub(super) struct ResolvePathResult {\n     pub(super) resolved_def: PerNs,\n     pub(super) segment_index: Option<usize>,\n     pub(super) reached_fixedpoint: ReachedFixedPoint,\n+    pub(super) krate: Option<CrateId>,\n }\n \n impl ResolvePathResult {\n     fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None, None)\n     }\n \n     fn with(\n         resolved_def: PerNs,\n         reached_fixedpoint: ReachedFixedPoint,\n         segment_index: Option<usize>,\n+        krate: Option<CrateId>,\n     ) -> ResolvePathResult {\n-        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n+        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index, krate }\n     }\n }\n \n@@ -175,6 +177,7 @@ impl CrateDefMap {\n                             def,\n                             ReachedFixedPoint::Yes,\n                             s.map(|s| s + i),\n+                            Some(module.krate),\n                         );\n                     }\n \n@@ -201,6 +204,7 @@ impl CrateDefMap {\n                                 PerNs::types(e.into()),\n                                 ReachedFixedPoint::Yes,\n                                 Some(i),\n+                                Some(self.krate),\n                             );\n                         }\n                     }\n@@ -218,12 +222,13 @@ impl CrateDefMap {\n                         PerNs::types(s),\n                         ReachedFixedPoint::Yes,\n                         Some(i),\n+                        Some(self.krate),\n                     );\n                 }\n             };\n         }\n \n-        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None, Some(self.krate))\n     }\n \n     fn resolve_name_in_module("}]}