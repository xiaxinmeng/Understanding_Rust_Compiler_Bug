{"sha": "b31f9cc22bcd720b37ddf927afe378108a5b9a54", "node_id": "C_kwDOAAsO6NoAKGIzMWY5Y2MyMmJjZDcyMGIzN2RkZjkyN2FmZTM3ODEwOGE1YjlhNTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-15T21:08:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-15T21:08:08Z"}, "message": "Auto merge of #97178 - sunfishcode:ownedfd-and-dup, r=joshtriplett\n\nAdd a `BorrowedFd::try_clone_to_owned` and accompanying documentation\n\nAdd a `BorrowedFd::try_clone_to_owned`, which returns a new `OwnedFd` sharing the underlying file description. And similar for `BorrowedHandle` and `BorrowedSocket` on WIndows.\n\nThis is similar to the existing `OwnedFd::try_clone`, but it's named differently to reflect that it doesn't return `Result<Self, ...>`. I'm open to suggestions for better names.\n\nAlso, extend the `unix::io` documentation to mention that `dup` is permitted on `BorrowedFd`.\n\nThis was originally requsted [here](https://github.com/rust-lang/rust/issues/88564#issuecomment-910786081). At the time I wasn't sure whether it was desirable, but it does have uses and it helps clarify the API. The documentation previously didn't rule out using `dup` on a `BorrowedFd`, but the API only offered convenient ways to do it from an `OwnedFd`. With this patch, the API allows one to do `try_clone` on any type where it's permitted.", "tree": {"sha": "de2017de0932a8e9f7bc024a39046d0412536522", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de2017de0932a8e9f7bc024a39046d0412536522"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b31f9cc22bcd720b37ddf927afe378108a5b9a54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b31f9cc22bcd720b37ddf927afe378108a5b9a54", "html_url": "https://github.com/rust-lang/rust/commit/b31f9cc22bcd720b37ddf927afe378108a5b9a54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b31f9cc22bcd720b37ddf927afe378108a5b9a54/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca983054e19afd74d63c3ed37997f3bf30fe85d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca983054e19afd74d63c3ed37997f3bf30fe85d0", "html_url": "https://github.com/rust-lang/rust/commit/ca983054e19afd74d63c3ed37997f3bf30fe85d0"}, {"sha": "ee49d65fc35d968e328ab63cc8330c1a43088bd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee49d65fc35d968e328ab63cc8330c1a43088bd2", "html_url": "https://github.com/rust-lang/rust/commit/ee49d65fc35d968e328ab63cc8330c1a43088bd2"}], "stats": {"total": 117, "additions": 81, "deletions": 36}, "files": [{"sha": "dd965ddc01eef89192ea0b262b10c7528be58cbc", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=b31f9cc22bcd720b37ddf927afe378108a5b9a54", "patch": "@@ -77,11 +77,20 @@ impl BorrowedFd<'_> {\n }\n \n impl OwnedFd {\n-    /// Creates a new `OwnedFd` instance that shares the same underlying file handle\n-    /// as the existing `OwnedFd` instance.\n-    #[cfg(not(target_arch = \"wasm32\"))]\n+    /// Creates a new `OwnedFd` instance that shares the same underlying file\n+    /// description as the existing `OwnedFd` instance.\n     #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n     pub fn try_clone(&self) -> crate::io::Result<Self> {\n+        self.as_fd().try_clone_to_owned()\n+    }\n+}\n+\n+impl BorrowedFd<'_> {\n+    /// Creates a new `OwnedFd` instance that shares the same underlying file\n+    /// description as the existing `BorrowedFd` instance.\n+    #[cfg(not(target_arch = \"wasm32\"))]\n+    #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+    pub fn try_clone_to_owned(&self) -> crate::io::Result<OwnedFd> {\n         // We want to atomically duplicate this file descriptor and set the\n         // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n         // is a POSIX flag that was added to Linux in 2.6.24.\n@@ -96,12 +105,14 @@ impl OwnedFd {\n         let cmd = libc::F_DUPFD;\n \n         let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 0) })?;\n-        Ok(unsafe { Self::from_raw_fd(fd) })\n+        Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n     }\n \n+    /// Creates a new `OwnedFd` instance that shares the same underlying file\n+    /// description as the existing `BorrowedFd` instance.\n     #[cfg(target_arch = \"wasm32\")]\n     #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n-    pub fn try_clone(&self) -> crate::io::Result<Self> {\n+    pub fn try_clone_to_owned(&self) -> crate::io::Result<OwnedFd> {\n         Err(crate::io::const_io_error!(\n             crate::io::ErrorKind::Unsupported,\n             \"operation not supported on WASI yet\","}, {"sha": "7556d3ad0b230d00353a23b81e6295db8e1e68ba", "filename": "library/std/src/os/unix/io/mod.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs?ref=b31f9cc22bcd720b37ddf927afe378108a5b9a54", "patch": "@@ -26,20 +26,30 @@\n //! that they don't outlive the resource they point to. These are safe to\n //! use. `BorrowedFd` values may be used in APIs which provide safe access to\n //! any system call except for:\n+//!\n //!  - `close`, because that would end the dynamic lifetime of the resource\n //!    without ending the lifetime of the file descriptor.\n+//!\n //!  - `dup2`/`dup3`, in the second argument, because this argument is\n //!    closed and assigned a new resource, which may break the assumptions\n //!    other code using that file descriptor.\n-//! This list doesn't include `mmap`, since `mmap` does do a proper borrow of\n-//! its file descriptor argument. That said, `mmap` is unsafe for other\n-//! reasons: it operates on raw pointers, and it can have undefined behavior if\n-//! the underlying storage is mutated. Mutations may come from other processes,\n-//! or from the same process if the API provides `BorrowedFd` access, since as\n-//! mentioned earlier, `BorrowedFd` values may be used in APIs which provide\n-//! safe access to any system call. Consequently, code using `mmap` and\n-//! presenting a safe API must take full responsibility for ensuring that safe\n-//! Rust code cannot evoke undefined behavior through it.\n+//!\n+//! `BorrowedFd` values may be used in APIs which provide safe access to `dup`\n+//! system calls, so types implementing `AsFd` or `From<OwnedFd>` should not\n+//! assume they always have exclusive access to the underlying file\n+//! description.\n+//!\n+//! `BorrowedFd` values may also be used with `mmap`, since `mmap` uses the\n+//! provided file descriptor in a manner similar to `dup` and does not require\n+//! the `BorrowedFd` passed to it to live for the lifetime of the resulting\n+//! mapping. That said, `mmap` is unsafe for other reasons: it operates on raw\n+//! pointers, and it can have undefined behavior if the underlying storage is\n+//! mutated. Mutations may come from other processes, or from the same process\n+//! if the API provides `BorrowedFd` access, since as mentioned earlier,\n+//! `BorrowedFd` values may be used in APIs which provide safe access to any\n+//! system call. Consequently, code using `mmap` and presenting a safe API must\n+//! take full responsibility for ensuring that safe Rust code cannot evoke\n+//! undefined behavior through it.\n //!\n //! Like boxes, `OwnedFd` values conceptually own the resource they point to,\n //! and free (close) it when they are dropped."}, {"sha": "16cc8fa2783eea6c13492710ccebfbe977e1b9ff", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=b31f9cc22bcd720b37ddf927afe378108a5b9a54", "patch": "@@ -177,10 +177,19 @@ impl TryFrom<HandleOrNull> for OwnedHandle {\n }\n \n impl OwnedHandle {\n-    /// Creates a new `OwnedHandle` instance that shares the same underlying file handle\n-    /// as the existing `OwnedHandle` instance.\n+    /// Creates a new `OwnedHandle` instance that shares the same underlying\n+    /// object as the existing `OwnedHandle` instance.\n     #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n     pub fn try_clone(&self) -> crate::io::Result<Self> {\n+        self.as_handle().try_clone_to_owned()\n+    }\n+}\n+\n+impl BorrowedHandle<'_> {\n+    /// Creates a new `OwnedHandle` instance that shares the same underlying\n+    /// object as the existing `BorrowedHandle` instance.\n+    #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+    pub fn try_clone_to_owned(&self) -> crate::io::Result<OwnedHandle> {\n         self.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)\n     }\n \n@@ -189,15 +198,15 @@ impl OwnedHandle {\n         access: c::DWORD,\n         inherit: bool,\n         options: c::DWORD,\n-    ) -> io::Result<Self> {\n+    ) -> io::Result<OwnedHandle> {\n         let handle = self.as_raw_handle();\n \n         // `Stdin`, `Stdout`, and `Stderr` can all hold null handles, such as\n         // in a process with a detached console. `DuplicateHandle` would fail\n         // if we passed it a null handle, but we can treat null as a valid\n         // handle which doesn't do any I/O, and allow it to be duplicated.\n         if handle.is_null() {\n-            return unsafe { Ok(Self::from_raw_handle(handle)) };\n+            return unsafe { Ok(OwnedHandle::from_raw_handle(handle)) };\n         }\n \n         let mut ret = ptr::null_mut();\n@@ -213,7 +222,7 @@ impl OwnedHandle {\n                 options,\n             )\n         })?;\n-        unsafe { Ok(Self::from_raw_handle(ret)) }\n+        unsafe { Ok(OwnedHandle::from_raw_handle(ret)) }\n     }\n }\n "}, {"sha": "e2a401fb6962b5ca090c2198dafcd0b138442b5f", "filename": "library/std/src/os/windows/io/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fmod.rs?ref=b31f9cc22bcd720b37ddf927afe378108a5b9a54", "patch": "@@ -36,6 +36,12 @@\n //! dynamic lifetime of the resource without ending the lifetime of the\n //! handle or socket.\n //!\n+//! `BorrowedHandle` and `BorrowedSocket` values may be used in APIs which\n+//! provide safe access to `DuplicateHandle` and `WSADuplicateSocketW` and\n+//! related functions, so types implementing `AsHandle`, `AsSocket`,\n+//! `From<OwnedHandle>`, or `From<OwnedSocket>` should not assume they always\n+//! have exclusive access to the underlying object.\n+//!\n //! Like boxes, `OwnedHandle` and `OwnedSocket` values conceptually own the\n //! resource they point to, and free (close) it when they are dropped.\n //!"}, {"sha": "72cb3406dcadaf7f4bbe5daa3494aaefc5ec6700", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=b31f9cc22bcd720b37ddf927afe378108a5b9a54", "patch": "@@ -82,10 +82,33 @@ impl BorrowedSocket<'_> {\n }\n \n impl OwnedSocket {\n-    /// Creates a new `OwnedSocket` instance that shares the same underlying socket\n-    /// as the existing `OwnedSocket` instance.\n+    /// Creates a new `OwnedSocket` instance that shares the same underlying\n+    /// object as the existing `OwnedSocket` instance.\n     #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n     pub fn try_clone(&self) -> io::Result<Self> {\n+        self.as_socket().try_clone_to_owned()\n+    }\n+\n+    // FIXME(strict_provenance_magic): we defined RawSocket to be a u64 ;-;\n+    #[cfg(not(target_vendor = \"uwp\"))]\n+    pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n+        cvt(unsafe {\n+            c::SetHandleInformation(self.as_raw_socket() as c::HANDLE, c::HANDLE_FLAG_INHERIT, 0)\n+        })\n+        .map(drop)\n+    }\n+\n+    #[cfg(target_vendor = \"uwp\")]\n+    pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n+        Err(io::const_io_error!(io::ErrorKind::Unsupported, \"Unavailable on UWP\"))\n+    }\n+}\n+\n+impl BorrowedSocket<'_> {\n+    /// Creates a new `OwnedSocket` instance that shares the same underlying\n+    /// object as the existing `BorrowedSocket` instance.\n+    #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n+    pub fn try_clone_to_owned(&self) -> io::Result<OwnedSocket> {\n         let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n         let result = unsafe {\n             c::WSADuplicateSocketW(self.as_raw_socket(), c::GetCurrentProcessId(), &mut info)\n@@ -133,20 +156,6 @@ impl OwnedSocket {\n             }\n         }\n     }\n-\n-    // FIXME(strict_provenance_magic): we defined RawSocket to be a u64 ;-;\n-    #[cfg(not(target_vendor = \"uwp\"))]\n-    pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n-        cvt(unsafe {\n-            c::SetHandleInformation(self.as_raw_socket() as c::HANDLE, c::HANDLE_FLAG_INHERIT, 0)\n-        })\n-        .map(drop)\n-    }\n-\n-    #[cfg(target_vendor = \"uwp\")]\n-    pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n-        Err(io::const_io_error!(io::ErrorKind::Unsupported, \"Unavailable on UWP\"))\n-    }\n }\n \n /// Returns the last error from the Windows socket interface."}, {"sha": "1e7b6e1eab03a29c4b0d7abdf54245c5beb0eee0", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31f9cc22bcd720b37ddf927afe378108a5b9a54/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=b31f9cc22bcd720b37ddf927afe378108a5b9a54", "patch": "@@ -218,7 +218,7 @@ impl Handle {\n         inherit: bool,\n         options: c::DWORD,\n     ) -> io::Result<Self> {\n-        Ok(Self(self.0.duplicate(access, inherit, options)?))\n+        Ok(Self(self.0.as_handle().duplicate(access, inherit, options)?))\n     }\n \n     /// Performs a synchronous read."}]}