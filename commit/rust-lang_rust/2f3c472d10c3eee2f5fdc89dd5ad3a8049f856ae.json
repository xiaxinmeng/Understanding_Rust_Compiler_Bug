{"sha": "2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmM2M0NzJkMTBjM2VlZTJmNWZkYzg5ZGQ1YWQzYTgwNDlmODU2YWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-12-23T22:03:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-12-23T22:03:45Z"}, "message": "Remove the FAQs in favor of the website", "tree": {"sha": "11390624b538570d7c2b3131846b17f28c93d261", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11390624b538570d7c2b3131846b17f28c93d261"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae", "html_url": "https://github.com/rust-lang/rust/commit/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b8e96dad2d30d1ece97a382e63dd845b354890e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8e96dad2d30d1ece97a382e63dd845b354890e", "html_url": "https://github.com/rust-lang/rust/commit/2b8e96dad2d30d1ece97a382e63dd845b354890e"}], "stats": {"total": 411, "additions": 3, "deletions": 408}, "files": [{"sha": "f4898dc676530356e86b287c42018a2ad4cd5699", "filename": "src/doc/complement-design-faq.md", "status": "modified", "additions": 1, "deletions": 184, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae/src%2Fdoc%2Fcomplement-design-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae/src%2Fdoc%2Fcomplement-design-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-design-faq.md?ref=2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae", "patch": "@@ -1,186 +1,3 @@\n % The Rust Design FAQ\n \n-This document describes decisions that were arrived at after lengthy discussion and\n-experimenting with alternatives. Please do not propose reversing them unless\n-you have a new, extremely compelling argument. Note that this document\n-specifically talks about the *language* and not any library or implementation.\n-\n-A few general guidelines define the philosophy:\n-\n-- [Memory safety][mem] must never be compromised\n-- [Abstraction][abs] should be zero-cost, while still maintaining safety\n-- Practicality is key\n-\n-[mem]: http://en.wikipedia.org/wiki/Memory_safety\n-[abs]: http://en.wikipedia.org/wiki/Abstraction_%28computer_science%29\n-\n-# Semantics\n-\n-## Data layout is unspecified\n-\n-In the general case, `enum` and `struct` layout is undefined. This allows the\n-compiler to potentially do optimizations like re-using padding for the\n-discriminant, compacting variants of nested enums, reordering fields to remove\n-padding, etc. `enum`s which carry no data (\"C-like\") are eligible to have a\n-defined representation. Such `enum`s are easily distinguished in that they are\n-simply a list of names that carry no data:\n-\n-```\n-enum CLike {\n-    A,\n-    B = 32,\n-    C = 34,\n-    D\n-}\n-```\n-\n-The [repr attribute][repr] can be applied to such `enum`s to give them the same\n-representation as a primitive. This allows using Rust `enum`s in FFI where C\n-`enum`s are also used, for most use cases. The attribute can also be applied\n-to `struct`s to get the same layout as a C struct would.\n-\n-[repr]: reference.html#ffi-attributes\n-\n-## There is no GC\n-\n-A language that requires a GC is a language that opts into a larger, more\n-complex runtime than Rust cares for. Rust is usable on bare metal with no\n-extra runtime. Additionally, garbage collection is frequently a source of\n-non-deterministic behavior. Rust provides the tools to make using a GC\n-possible and even pleasant, but it should not be a requirement for\n-implementing the language.\n-\n-## Non-`Sync` `static mut` is unsafe\n-\n-Types which are [`Sync`][sync] are thread-safe when multiple shared\n-references to them are used concurrently. Types which are not `Sync` are not\n-thread-safe, and thus when used in a global require unsafe code to use.\n-\n-[sync]: core/marker/trait.Sync.html\n-\n-### If mutable static items that implement `Sync` are safe, why is taking &mut SHARABLE unsafe?\n-\n-Having multiple aliasing `&mut T`s is never allowed. Due to the nature of\n-globals, the borrow checker cannot possibly ensure that a static obeys the\n-borrowing rules, so taking a mutable reference to a static is always unsafe.\n-\n-## There is no life before or after main (no static ctors/dtors)\n-\n-Globals can not have a non-constant-expression constructor and cannot have a\n-destructor at all. This is an opinion of the language. Static constructors are\n-undesirable because they can slow down program startup. Life before main is\n-often considered a misfeature, never to be used. Rust helps this along by just\n-not having the feature.\n-\n-See [the C++ FQA][fqa]  about the \"static initialization order fiasco\", and\n-[Eric Lippert's blog][elp] for the challenges in C#, which also has this\n-feature.\n-\n-A nice replacement is [lazy_static][lazy_static].\n-\n-[fqa]: http://yosefk.com/c++fqa/ctors.html#fqa-10.12\n-[elp]: http://ericlippert.com/2013/02/06/static-constructors-part-one/\n-[lazy_static]: https://crates.io/crates/lazy_static\n-\n-## The language does not require a runtime\n-\n-See the above entry on GC. Requiring a runtime limits the utility of the\n-language, and makes it undeserving of the title \"systems language\". All Rust\n-code should need to run is a stack.\n-\n-## `match` must be exhaustive\n-\n-`match` being exhaustive has some useful properties. First, if every\n-possibility is covered by the `match`, adding further variants to the `enum`\n-in the future will prompt a compilation failure, rather than runtime panic.\n-Second, it makes cost explicit. In general, the only safe way to have a\n-non-exhaustive match would be to panic the thread if nothing is matched, though\n-it could fall through if the type of the `match` expression is `()`. This sort\n-of hidden cost and special casing is against the language's philosophy. It's\n-easy to ignore all unspecified cases by using the `_` wildcard:\n-\n-```rust,ignore\n-match val.do_something() {\n-    Cat(a) => { /* ... */ }\n-    _      => { /* ... */ }\n-}\n-```\n-\n-[#3101][iss] is the issue that proposed making this the only behavior, with\n-rationale and discussion.\n-\n-[iss]: https://github.com/rust-lang/rust/issues/3101\n-\n-## No guaranteed tail-call optimization\n-\n-In general, tail-call optimization is not guaranteed: see [here][tml] for a\n-detailed explanation with references. There is a [proposed extension][tce] that\n-would allow tail-call elimination in certain contexts. The compiler is still\n-free to optimize tail-calls [when it pleases][sco], however.\n-\n-[tml]: https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html\n-[sco]: http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization\n-[tce]: https://github.com/rust-lang/rfcs/pull/81\n-\n-## No constructors\n-\n-Functions can serve the same purpose as constructors without adding any\n-language complexity.\n-\n-## No copy constructors\n-\n-Types which implement [`Copy`][copy], will do a standard C-like \"shallow copy\"\n-with no extra work (similar to \"plain old data\" in C++). It is impossible to\n-implement `Copy` types that require custom copy behavior. Instead, in Rust\n-\"copy constructors\" are created by implementing the [`Clone`][clone] trait,\n-and explicitly calling the `clone` method. Making user-defined copy operators\n-explicit surfaces the underlying complexity, forcing the developer to opt-in\n-to potentially expensive operations.\n-\n-[copy]: core/marker/trait.Copy.html\n-[clone]: core/clone/trait.Clone.html\n-\n-## No move constructors\n-\n-Values of all types are moved via `memcpy`. This makes writing generic unsafe\n-code much simpler since assignment, passing and returning are known to never\n-have a side effect like unwinding.\n-\n-# Syntax\n-\n-## Macros require balanced delimiters\n-\n-This is to make the language easier to parse for machines. Since the body of a\n-macro can contain arbitrary tokens, some restriction is needed to allow simple\n-non-macro-expanding lexers and parsers. This comes in the form of requiring\n-that all delimiters be balanced.\n-\n-## `->` for function return type\n-\n-This is to make the language easier to parse for humans, especially in the face\n-of higher-order functions. `fn foo<T>(f: fn(i32): i32, fn(T): U): U` is not\n-particularly easy to read.\n-\n-## Why is `let` used to introduce variables?\n-\n-Instead of the term \"variable\", we use \"variable bindings\". The\n-simplest way for creating a binding is by using the `let` syntax.\n-Other ways include `if let`, `while let`, and `match`. Bindings also\n-exist in function argument positions.\n-\n-Bindings always happen in pattern matching positions, and it's also Rust's way\n-to declare mutability. One can also re-declare mutability of a binding in\n-pattern matching. This is useful to avoid unnecessary `mut` annotations. An\n-interesting historical note is that Rust comes, syntactically, most closely\n-from ML, which also uses `let` to introduce bindings.\n-\n-See also [a long thread][alt] on renaming `let mut` to `var`.\n-\n-[alt]: https://mail.mozilla.org/pipermail/rust-dev/2014-January/008319.html\n-\n-## Why no `--x` or `x++`?\n-\n-Preincrement and postincrement, while convenient, are also fairly complex. They\n-require knowledge of evaluation order, and often lead to subtle bugs and\n-undefined behavior in C and C++. `x = x + 1` or `x += 1` is only slightly\n-longer, but unambiguous.\n+This content has moved to [the website](https://www.rust-lang.org/)."}, {"sha": "920c6edc389fe8aafdd17f582df8af6aed80cf2e", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 175, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae", "patch": "@@ -1,177 +1,3 @@\n % The Rust Language FAQ\n \n-## Are there any big programs written in it yet? I want to read big samples.\n-\n-There aren't many large programs yet. The Rust [compiler][rustc], 60,000+ lines at the time of writing, is written in Rust. As the oldest body of Rust code it has gone through many iterations of the language, and some parts are nicer to look at than others. It may not be the best code to learn from, but [borrowck] and [resolve] were written recently.\n-\n-[rustc]: https://github.com/rust-lang/rust/tree/master/src/librustc\n-[resolve]: https://github.com/rust-lang/rust/tree/master/src/librustc_resolve\n-[borrowck]: https://github.com/rust-lang/rust/tree/master/src/librustc_borrowck/borrowck\n-\n-A research browser engine called [Servo][servo], currently 30,000+ lines across more than a dozen crates, will be exercising a lot of Rust's distinctive type-system and concurrency features, and integrating many native libraries.\n-\n-[servo]: https://github.com/servo/servo\n-\n-Some examples that demonstrate different aspects of the language:\n-\n-* [sprocketnes], an NES emulator with no GC, using modern Rust conventions\n-* The language's general-purpose [hash] function, SipHash-2-4. Bit twiddling, OO, macros\n-* The standard library's [HashMap], a sendable hash map in an OO style\n-* The standard library's [json] module. Enums and pattern matching\n-\n-[sprocketnes]: https://github.com/pcwalton/sprocketnes\n-[hash]: https://github.com/rust-lang/rust/tree/master/src/libcore/hash\n-[HashMap]: https://github.com/rust-lang/rust/tree/master/src/libstd/collections/hash\n-[json]: https://github.com/rust-lang/rust/blob/master/src/libserialize/json.rs\n-\n-You may also be interested in browsing [trending Rust repositories][github-rust] on GitHub.\n-\n-[github-rust]: https://github.com/trending?l=rust\n-\n-## Is anyone using Rust in production?\n-\n-Yes. For example (incomplete):\n-\n-* [OpenDNS](http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/)\n-* [Skylight](http://skylight.io)\n-* [wit.ai](https://github.com/wit-ai/witd)\n-* [Codius](https://codius.org/blog/codius-rust/)\n-* [MaidSafe](http://maidsafe.net/)\n-* [Terminal.com](https://terminal.com)\n-\n-## Does it run on Windows?\n-\n-Yes. All development happens in lockstep on all 3 target platforms (using MinGW, not Cygwin).\n-\n-## Is it OO? How do I do this thing I normally do in an OO language?\n-\n-It is multi-paradigm. Not everything is shoe-horned into a single abstraction. Many things you can do in OO languages you can do in Rust, but not everything, and not always using the same abstraction you're accustomed to.\n-\n-## How do you get away with \"no null pointers\"?\n-\n-Data values in the language can only be constructed through a fixed set of initializer forms. Each of those forms requires that its inputs already be initialized. A liveness analysis ensures that local variables are initialized before use.\n-\n-## What is the relationship between a module and a crate?\n-\n-* A crate is a top-level compilation unit that corresponds to a single loadable object.\n-* A module is a (possibly nested) unit of name-management inside a crate.\n-* A crate contains an implicit, un-named top-level module.\n-* Recursive definitions can span modules, but not crates.\n-* Crates do not have global names, only a set of non-unique metadata tags.\n-* There is no global inter-crate namespace; all name management occurs within a crate.\n- * Using another crate binds the root of _its_ namespace into the user's namespace.\n-\n-## Why is panic unwinding non-recoverable within a thread? Why not try to \"catch exceptions\"?\n-\n-In short, because too few guarantees could be made about the dynamic environment of the catch block, as well as invariants holding in the unwound heap, to be able to safely resume; we believe that other methods of signalling and logging errors are more appropriate, with threads playing the role of a \"hard\" isolation boundary between separate heaps.\n-\n-Rust provides, instead, three predictable and well-defined options for handling any combination of the three main categories of \"catch\" logic:\n-\n-* Failure _logging_ is done by the integrated logging subsystem.\n-* _Recovery_ after a panic is done by trapping a thread panic from _outside_\n-  the thread, where other threads are known to be unaffected.\n-* _Cleanup_ of resources is done by RAII-style objects with destructors.\n-\n-Cleanup through RAII-style destructors is more likely to work than in catch blocks anyways, since it will be better tested (part of the non-error control paths, so executed all the time).\n-\n-## Why aren't modules type-parametric?\n-\n-We want to maintain the option to parameterize at runtime. We may eventually change this limitation, but initially this is how type parameters were implemented.\n-\n-## Why aren't values type-parametric? Why only items?\n-\n-Doing so would make type inference much more complex, and require the implementation strategy of runtime parameterization.\n-\n-## Why are enumerations nominal and closed?\n-\n-We don't know if there's an obvious, easy, efficient, stock-textbook way of supporting open or structural disjoint unions. We prefer to stick to language features that have an obvious and well-explored semantics.\n-\n-## Why aren't channels synchronous?\n-\n-There's a lot of debate on this topic; it's easy to find a proponent of default-sync or default-async communication, and there are good reasons for either. Our choice rests on the following arguments:\n-\n-* Part of the point of isolating threads is to decouple threads from one another, such that assumptions in one thread do not cause undue constraints (or bugs, if violated!) in another. Temporal coupling is as real as any other kind; async-by-default relaxes the default case to only _causal_ coupling.\n-* Default-async supports buffering and batching communication, reducing the frequency and severity of thread-switching and inter-thread / inter-domain synchronization.\n-* Default-async with transmittable channels is the lowest-level building block on which more-complex synchronization topologies and strategies can be built; it is not clear to us that the majority of cases fit the 2-party full-synchronization pattern rather than some more complex multi-party or multi-stage scenario. We did not want to force all programs to pay for wiring the former assumption into all communications.\n-\n-## Why are channels half-duplex (one-way)?\n-\n-Similar to the reasoning about default-sync: it wires fewer assumptions into the implementation, that would have to be paid by all use-cases even if they actually require a more complex communication topology.\n-\n-## Why are strings UTF-8 by default? Why not UCS2 or UCS4?\n-\n-The `str` type is UTF-8 because we observe more text in the wild in this encoding \u2013 particularly in network transmissions, which are endian-agnostic \u2013 and we think it's best that the default treatment of I/O not involve having to recode codepoints in each direction.\n-\n-This does mean that indexed access to a Unicode codepoint inside a `str` value is an O(n) operation. On the one hand, this is clearly undesirable; on the other hand, this problem is full of trade-offs and we'd like to point a few important qualifications:\n-\n-* Scanning a `str` for ASCII-range codepoints can still be done safely octet-at-a-time. If you use `.as_bytes()`, pulling out a `u8` costs only O(1) and produces a value that can be cast and compared to an ASCII-range `char`. So if you're (say) line-breaking on `'\\n'`, octet-based treatment still works. UTF8 was well-designed this way.\n-* Most \"character oriented\" operations on text only work under very restricted language assumptions sets such as \"ASCII-range codepoints only\". Outside ASCII-range, you tend to have to use a complex (non-constant-time) algorithm for determining linguistic-unit (glyph, word, paragraph) boundaries anyways. We recommend using an \"honest\" linguistically-aware, Unicode-approved algorithm.\n-* The `char` type is UCS4. If you honestly need to do a codepoint-at-a-time algorithm, it's trivial to write a `type wstr = [char]`, and unpack a `str` into it in a single pass, then work with the `wstr`. In other words: the fact that the language is not \"decoding to UCS4 by default\" shouldn't stop you from decoding (or re-encoding any other way) if you need to work with that encoding.\n-\n-## Why are `str`s, slices, arrays etc. built-in types rather than (say) special kinds of trait/impl?\n-\n-In each case there is one or more operator, literal constructor, overloaded use or integration with a built-in control structure that makes us think it would be awkward to phrase the type in terms of more-general type constructors. Same as, say, with numbers! But this is partly an aesthetic call, and we'd be willing to look at a worked-out proposal for eliminating or rephrasing these special cases.\n-\n-## Can Rust code call C code?\n-\n-Yes. Calling C code from Rust is simple and exactly as efficient as calling C code from C.\n-\n-## Can C code call Rust code?\n-\n-Yes. The Rust code has to be exposed via an `extern` declaration, which makes it C-ABI compatible. Such a function can be passed to C code as a function pointer or, if given the `#[no_mangle]` attribute to disable symbol mangling, can be called directly from C code.\n-\n-## Why aren't function signatures inferred? Why only local variables?\n-\n-* Mechanically, it simplifies the inference algorithm; inference only requires looking at one function at a time.\n-* The same simplification goes double for human readers. A reader does not need an IDE running an inference algorithm across an entire crate to be able to guess at a function's argument types; it's always explicit and nearby.\n-\n-## Why does a type parameter need explicit trait bounds to invoke methods on it, when C++ templates do not?\n-\n-* Requiring explicit bounds means that the compiler can type-check the code at the point where the type-parametric item is *defined*, rather than delaying to when its type parameters are instantiated.  You know that *any* set of type parameters fulfilling the bounds listed in the API will compile. It's an enforced minimal level of documentation, and results in very clean error messages.\n-\n-* Scoping of methods is also a problem.  C++ needs [Koenig (argument dependent) lookup](http://en.wikipedia.org/wiki/Argument-dependent_name_lookup), which comes with its own host of problems. Explicit bounds avoid this issue: traits are explicitly imported and then used as bounds on type parameters, so there is a clear mapping from the method to its implementation (via the trait and the instantiated type).\n-\n-  * Related to the above point: since a parameter explicitly names its trait bounds, a single type is able to implement traits whose sets of method names overlap, cleanly and unambiguously.\n-\n-* There is further discussion on [this thread on the Rust mailing list](https://mail.mozilla.org/pipermail/rust-dev/2013-September/005603.html).\n-\n-## Will Rust implement automatic semicolon insertion, like in Go?\n-\n-For simplicity, we do not plan to do so. Implementing automatic semicolon insertion for Rust would be tricky because the absence of a trailing semicolon means \"return a value\".\n-\n-## How do I get my program to display the output of logging macros?\n-\n-**Short Answer**: Set the `RUST_LOG` environment variable to the name of your source file, sans extension.\n-\n-```sh\n-rustc hello.rs\n-export RUST_LOG=hello\n-./hello\n-```\n-\n-**Long Answer**: `RUST_LOG` takes a 'logging spec' that consists of a\n-comma-separated list of paths, where a path consists of the crate name and\n-sequence of module names, each separated by double-colons. For standalone `.rs`\n-files, the crate is implicitly named after the source file, so in the above\n-example we were setting `RUST_LOG` to the name of the hello crate. Multiple paths\n-can be combined to control the exact logging you want to see. For example, when\n-debugging linking in the compiler, you might set the following:\n-\n-```sh\n-RUST_LOG=rustc_metadata::creader,rustc::util::filesearch,rustc::back::rpath\n-```\n-\n-For a full description, see [the logging crate][1].\n-\n-## How fast is Rust?\n-\n-As always, this question is difficult to answer. There's still a lot of work to\n-do on speed, and depending on what you're benchmarking, Rust has variable\n-performance.\n-\n-That said, it is an explicit goal of Rust to be as fast as C++ for most things.\n-Language decisions are made with performance in mind, and we want Rust to be as\n-fast as possible. Given that Rust is built on top of LLVM, any performance\n-improvements in it also help Rust become faster.\n-\n-[1]:log/index.html\n+This content has moved to [the website](https://www.rust-lang.org/)."}, {"sha": "b44de8e2cb32d3cd72213bcb4228870f1edcf0dc", "filename": "src/doc/complement-project-faq.md", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae/src%2Fdoc%2Fcomplement-project-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae/src%2Fdoc%2Fcomplement-project-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-project-faq.md?ref=2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae", "patch": "@@ -1,42 +1,3 @@\n % The Rust Project FAQ\n \n-# What is this project's goal, in one sentence?\n-\n-To design and implement a safe, concurrent, practical, static systems language.\n-\n-# Why are you doing this?\n-\n-Existing languages at this level of abstraction and efficiency are unsatisfactory. In particular:\n-\n-* Too little attention paid to safety.\n-* Poor concurrency support.\n-* Lack of practical affordances, too dogmatic about paradigm.\n-\n-# What are some non-goals?\n-\n-* To employ any particularly cutting-edge technologies. Old, established techniques are better.\n-* To prize expressiveness, minimalism or elegance above other goals. These are desirable but subordinate goals.\n-* To cover the complete feature-set of C++, or any other language. It should provide majority-case features.\n-* To be 100% static, 100% safe, 100% reflective, or too dogmatic in any other sense. Trade-offs exist.\n-* To run on \"every possible platform\". It must eventually work without unnecessary compromises on widely-used hardware and software platforms.\n-\n-# Is any part of this thing production-ready?\n-\n-Yes!\n-\n-# Is this a completely Mozilla-planned and orchestrated thing?\n-\n-No. It started as a Graydon Hoare's part-time side project in 2006 and remained so for over 3 years. Mozilla got involved in 2009 once the language was mature enough to run some basic tests and demonstrate the idea. Though it is sponsored by Mozilla, Rust is developed by a diverse community of enthusiasts.\n-\n-# What will Mozilla use Rust for?\n-\n-Mozilla intends to use Rust as a platform for prototyping experimental browser architectures. Specifically, the hope is to develop a browser that is more amenable to parallelization than existing ones, while also being less prone to common C++ coding errors that result in security exploits. The name of that project is _[Servo](http://github.com/servo/servo)_.\n-\n-# Why a BSD-style permissive license rather than MPL or tri-license?\n-\n-* Partly due to preference of the original developer (Graydon).\n-* Partly due to the fact that languages tend to have a wider audience and more diverse set of possible embeddings and end-uses than focused, coherent products such as web browsers. We'd like to appeal to as many of those potential contributors as possible.\n-\n-# Why dual MIT/ASL2 license?\n-\n-The Apache license includes important protection against patent aggression, but it is not compatible with the GPL, version 2. To avoid problems using Rust with GPL2, it is alternately MIT licensed.\n+This content has moved to [the website](https://www.rust-lang.org/)."}, {"sha": "7f43c0fba6299c8e12eea63db248f22c59120f96", "filename": "src/doc/index.md", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=2f3c472d10c3eee2f5fdc89dd5ad3a8049f856ae", "patch": "@@ -46,15 +46,6 @@ beyond the standard one, and its website contains lots of good documentation.\n [`rustdoc`](book/documentation.html) is the Rust's documentation generator, a tool converting\n annotated source code into HTML docs.\n \n-# FAQs\n-\n-There are questions that are asked quite often, so we've made FAQs for them:\n-\n-* [Language Design FAQ](complement-design-faq.html)\n-* [Language FAQ](complement-lang-faq.html)\n-* [Project FAQ](complement-project-faq.html)\n-* [How to submit a bug report](https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports)\n-\n # The Error Index\n \n If you encounter an error while compiling your code you may be able to look it"}]}