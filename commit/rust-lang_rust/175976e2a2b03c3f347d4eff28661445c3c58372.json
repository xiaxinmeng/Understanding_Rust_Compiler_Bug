{"sha": "175976e2a2b03c3f347d4eff28661445c3c58372", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NTk3NmUyYTJiMDNjM2YzNDdkNGVmZjI4NjYxNDQ1YzNjNTgzNzI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril@gmail.com", "date": "2019-09-23T15:37:42Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-01T17:22:32Z"}, "message": "Refactor \"wild constructor\" construction", "tree": {"sha": "5e3f125c44fab7722d462dbcd55a35d571405480", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e3f125c44fab7722d462dbcd55a35d571405480"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/175976e2a2b03c3f347d4eff28661445c3c58372", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/175976e2a2b03c3f347d4eff28661445c3c58372", "html_url": "https://github.com/rust-lang/rust/commit/175976e2a2b03c3f347d4eff28661445c3c58372", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/175976e2a2b03c3f347d4eff28661445c3c58372/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b45458124ee662ac2746e091f28c3b70b95f7ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b45458124ee662ac2746e091f28c3b70b95f7ef2", "html_url": "https://github.com/rust-lang/rust/commit/b45458124ee662ac2746e091f28c3b70b95f7ef2"}], "stats": {"total": 73, "additions": 33, "deletions": 40}, "files": [{"sha": "806575ba0be3cb9362d11c6465008ef6eda7476c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/175976e2a2b03c3f347d4eff28661445c3c58372/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/175976e2a2b03c3f347d4eff28661445c3c58372/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=175976e2a2b03c3f347d4eff28661445c3c58372", "patch": "@@ -642,15 +642,17 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n+    /// This returns one wildcard pattern for each argument to this constructor.\n     fn wildcard_subpatterns<'a>(\n         &self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n         ty: Ty<'tcx>,\n-    ) -> Vec<Pat<'tcx>> {\n-        constructor_sub_pattern_tys(cx, self, ty)\n-            .into_iter()\n-            .map(|ty| Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild })\n-            .collect()\n+    ) -> impl Iterator<Item = Pat<'tcx>> + DoubleEndedIterator {\n+        constructor_sub_pattern_tys(cx, self, ty).into_iter().map(|ty| Pat {\n+            ty,\n+            span: DUMMY_SP,\n+            kind: box PatKind::Wild,\n+        })\n     }\n \n     /// This computes the arity of a constructor. The arity of a constructor\n@@ -735,6 +737,12 @@ impl<'tcx> Constructor<'tcx> {\n \n         Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n     }\n+\n+    /// Like `apply`, but where all the subpatterns are wildcards `_`.\n+    fn apply_wildcards<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n+        let pats = self.wildcard_subpatterns(cx, ty).rev();\n+        self.apply(cx, ty, pats)\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -807,16 +815,6 @@ impl<'tcx> Witness<'tcx> {\n         self.0.into_iter().next().unwrap()\n     }\n \n-    fn push_wild_constructor<'a>(\n-        mut self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n-        ctor: &Constructor<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> Self {\n-        self.0.extend(ctor.wildcard_subpatterns(cx, ty));\n-        self.apply_constructor(cx, ctor, ty)\n-    }\n-\n     /// Constructs a partial witness for a pattern given a list of\n     /// patterns expanded by the specialization step.\n     ///\n@@ -1530,33 +1528,28 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                     // `(<direction-1>, <direction-2>, true)` - we are\n                     // satisfied with `(_, _, true)`. In this case,\n                     // `used_ctors` is empty.\n-                    let new_witnesses = if is_non_exhaustive || used_ctors.is_empty() {\n-                        // All constructors are unused. Add wild patterns\n+                    let new_patterns = if is_non_exhaustive || used_ctors.is_empty() {\n+                        // All constructors are unused. Add a wild pattern\n                         // rather than each individual constructor.\n-                        pats.into_iter()\n-                            .map(|mut witness| {\n-                                witness.0.push(Pat {\n-                                    ty: pcx.ty,\n-                                    span: DUMMY_SP,\n-                                    kind: box PatKind::Wild,\n-                                });\n-                                witness\n-                            })\n-                            .collect()\n+                        vec![Pat { ty: pcx.ty, span: DUMMY_SP, kind: box PatKind::Wild }]\n                     } else {\n-                        let missing_ctors: Vec<_> = missing_ctors.collect();\n-                        pats.into_iter()\n-                            .flat_map(|witness| {\n-                                missing_ctors.iter().map(move |ctor| {\n-                                    // Extends the witness with a \"wild\" version of this\n-                                    // constructor, that matches everything that can be built with\n-                                    // it. For example, if `ctor` is a `Constructor::Variant` for\n-                                    // `Option::Some`, this pushes the witness for `Some(_)`.\n-                                    witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n-                                })\n-                            })\n-                            .collect()\n+                        // Construct for each missing constructor a \"wild\" version of this\n+                        // constructor, that matches everything that can be built with\n+                        // it. For example, if `ctor` is a `Constructor::Variant` for\n+                        // `Option::Some`, we get the pattern `Some(_)`.\n+                        missing_ctors.map(|ctor| ctor.apply_wildcards(cx, pcx.ty)).collect()\n                     };\n+                    // Add the new patterns to each witness\n+                    let new_witnesses = pats\n+                        .into_iter()\n+                        .flat_map(|witness| {\n+                            new_patterns.iter().map(move |pat| {\n+                                let mut witness = witness.clone();\n+                                witness.0.push(pat.clone());\n+                                witness\n+                            })\n+                        })\n+                        .collect();\n                     UsefulWithWitness(new_witnesses)\n                 }\n                 result => result,\n@@ -1578,7 +1571,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n \n-    let wild_patterns_owned = ctor.wildcard_subpatterns(cx, lty);\n+    let wild_patterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty).collect();\n     let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n     let matrix = matrix.specialize_constructor(cx, &ctor, &wild_patterns);\n     match v.specialize_constructor(cx, &ctor, &wild_patterns) {"}]}