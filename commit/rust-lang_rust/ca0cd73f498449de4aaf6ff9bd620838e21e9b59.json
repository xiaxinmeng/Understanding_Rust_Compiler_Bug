{"sha": "ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMGNkNzNmNDk4NDQ5ZGU0YWFmNmZmOWJkNjIwODM4ZTIxZTliNTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-28T01:01:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-28T01:01:46Z"}, "message": "Rollup merge of #62771 - petrochenkov:depext, r=eddyb\n\nBreak dependencies between `syntax_ext` and other crates\n\nMove `source_util` macros into `syntax_ext`.\nMove other early code generation facilities like standard library injection into `syntax_ext`.\n\nThe only crate that depends on `syntax_ext` now is `rustc_interface` which is one of the \"final\" crates that depend on everything.\n\nMinor: Cleanup dependencies of `rustc_driver`, many of them are no longer used after introduction of `rustc_interface`.\n\nr? @eddyb", "tree": {"sha": "280fcc7c01b7df71760dee45401de2416b681648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/280fcc7c01b7df71760dee45401de2416b681648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdPPP6CRBK7hj4Ov3rIwAAdHIIACc5UK9k9BVzqoeOnAsBj1Lm\nhCbNqb89/k5/KOWIM26iFPq+ZVU3lNrAeiJwKOal++mr2TeTsO5fidBl0MRn4ux2\nncX9KKFDx1muGtmaEguPUytw3hX729a7v7AZfFo/1Z110OyTpQSaHLL6OfUdbcxg\nzeh9lX0VdIXhenquOnm8ri9yWSFXSaFqE8ZDFj7LtceAv8FYFCiJbRddscgXsjVv\ncWBrw0MSLvDO6rMK81+wmfvYH6fsjDPut9Hy8bYnQhuIONXy+Qmjza0U5KdhMisf\n6B7RqIwi+KYmne8Ylw3GYkGhb7bkadcWaqqn1RjjqfVgy2JAuJo4Q5sx4GhJ1LI=\n=UHpP\n-----END PGP SIGNATURE-----\n", "payload": "tree 280fcc7c01b7df71760dee45401de2416b681648\nparent cb8b491a65d93fd08752347d6a237457830567fa\nparent b5a0e6ea807bcdc71f145038dd1129c22dcf17fd\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564275706 +0200\ncommitter GitHub <noreply@github.com> 1564275706 +0200\n\nRollup merge of #62771 - petrochenkov:depext, r=eddyb\n\nBreak dependencies between `syntax_ext` and other crates\n\nMove `source_util` macros into `syntax_ext`.\nMove other early code generation facilities like standard library injection into `syntax_ext`.\n\nThe only crate that depends on `syntax_ext` now is `rustc_interface` which is one of the \"final\" crates that depend on everything.\n\nMinor: Cleanup dependencies of `rustc_driver`, many of them are no longer used after introduction of `rustc_interface`.\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "html_url": "https://github.com/rust-lang/rust/commit/ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb8b491a65d93fd08752347d6a237457830567fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb8b491a65d93fd08752347d6a237457830567fa", "html_url": "https://github.com/rust-lang/rust/commit/cb8b491a65d93fd08752347d6a237457830567fa"}, {"sha": "b5a0e6ea807bcdc71f145038dd1129c22dcf17fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a0e6ea807bcdc71f145038dd1129c22dcf17fd", "html_url": "https://github.com/rust-lang/rust/commit/b5a0e6ea807bcdc71f145038dd1129c22dcf17fd"}], "stats": {"total": 940, "additions": 394, "deletions": 546}, "files": [{"sha": "46d8b3de806ffc1ff259ab39afca12282a83452d", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -2863,31 +2863,20 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena 0.0.0\",\n  \"env_logger 0.5.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_ast_borrowck 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_incremental 0.0.0\",\n  \"rustc_interface 0.0.0\",\n- \"rustc_lint 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n- \"rustc_passes 0.0.0\",\n- \"rustc_plugin 0.0.0\",\n- \"rustc_privacy 0.0.0\",\n- \"rustc_resolve 0.0.0\",\n  \"rustc_save_analysis 0.0.0\",\n  \"rustc_target 0.0.0\",\n- \"rustc_traits 0.0.0\",\n- \"rustc_typeck 0.0.0\",\n  \"serialize 0.0.0\",\n- \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -3019,7 +3008,6 @@ dependencies = [\n  \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n- \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n \n@@ -3064,9 +3052,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n- \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n "}, {"sha": "eb0ea9e08a40ee95cad1772cab2fd35e88522937", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -63,7 +63,6 @@ use syntax::errors;\n use syntax::ext::hygiene::ExpnId;\n use syntax::print::pprust;\n use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n-use syntax::std_inject;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n@@ -241,7 +240,7 @@ pub fn lower_crate(\n     dep_graph.assert_ignored();\n \n     LoweringContext {\n-        crate_root: std_inject::injected_crate_name().map(Symbol::intern),\n+        crate_root: sess.parse_sess.injected_crate_name.try_get().copied(),\n         sess,\n         cstore,\n         resolver,"}, {"sha": "42aa8203cba0eb21882745ff5287fed5bdc557a6", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -10,30 +10,19 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-arena = { path = \"../libarena\" }\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n env_logger = { version = \"0.5\", default-features = false }\n-rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n-rustc_incremental = { path = \"../librustc_incremental\" }\n-rustc_lint = { path = \"../librustc_lint\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n-rustc_passes = { path = \"../librustc_passes\" }\n-rustc_plugin = { path = \"../librustc_plugin\" }\n-rustc_privacy = { path = \"../librustc_privacy\" }\n-rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n-rustc_traits = { path = \"../librustc_traits\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n-rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_interface = { path = \"../librustc_interface\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "3c7d854b36b13b651efeb0e0955e2c11dc37f972", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -278,7 +278,12 @@ pub fn register_plugins<'a>(\n \n     krate = time(sess, \"crate injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n-        syntax::std_inject::maybe_inject_crates_ref(krate, alt_std_name, sess.edition())\n+        let (krate, name) =\n+            syntax_ext::standard_library_imports::inject(krate, alt_std_name, sess.edition());\n+        if let Some(name) = name {\n+            sess.parse_sess.injected_crate_name.set(name);\n+        }\n+        krate\n     });\n \n     let registrars = time(sess, \"plugin loading\", || {\n@@ -456,7 +461,7 @@ fn configure_and_expand_inner<'a>(\n     sess.profiler(|p| p.end_activity(\"macro expansion\"));\n \n     time(sess, \"maybe building test harness\", || {\n-        syntax::test::modify_for_testing(\n+        syntax_ext::test_harness::inject(\n             &sess.parse_sess,\n             &mut resolver,\n             sess.opts.test,\n@@ -485,7 +490,7 @@ fn configure_and_expand_inner<'a>(\n             let num_crate_types = crate_types.len();\n             let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n             let is_test_crate = sess.opts.test;\n-            syntax_ext::proc_macro_decls::modify(\n+            syntax_ext::proc_macro_harness::inject(\n                 &sess.parse_sess,\n                 &mut resolver,\n                 krate,"}, {"sha": "5ff60a9267bad52ba8dbde98a128679ceace9f42", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -21,5 +21,4 @@ rustc_target = { path = \"../librustc_target\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n stable_deref_trait = \"1.0.0\"\n syntax = { path = \"../libsyntax\" }\n-syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "d5f1e715186f4ca984eb3c1f1a218bfe0aa4630d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -586,8 +586,7 @@ impl<'a> CrateLoader<'a> {\n         use std::{env, mem};\n         use crate::dynamic_lib::DynamicLibrary;\n         use proc_macro::bridge::client::ProcMacro;\n-        use syntax_ext::deriving::custom::ProcMacroDerive;\n-        use syntax_ext::proc_macro_impl::{AttrProcMacro, BangProcMacro};\n+        use syntax::ext::proc_macro::{BangProcMacro, AttrProcMacro, ProcMacroDerive};\n \n         let path = match dylib {\n             Some(dylib) => dylib,"}, {"sha": "ee1175e798d806cddfb85c3f0618a316979b3e33", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -31,10 +31,10 @@ use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n-use syntax_ext::proc_macro_impl::BangProcMacro;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::bit_set::BitSet;\n "}, {"sha": "596ec6c19bcbfd0b5e419173ca1d6541a47270df", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -11,9 +11,7 @@ path = \"lib.rs\"\n [dependencies]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n-rustc_mir = { path = \"../librustc_mir\"}\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n syntax = { path = \"../libsyntax\" }\n-syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }"}, {"sha": "562865ef55f4cff5a6b2e0d2cc0aad2337bcdbf6", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -14,12 +14,12 @@ use rustc::session::Session;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::*;\n use syntax::attr;\n+use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n use syntax::{span_err, struct_span_err, walk_list};\n-use syntax_ext::proc_macro_decls::is_proc_macro_attr;\n use syntax_pos::{Span, MultiSpan};\n use errors::{Applicability, FatalError};\n "}, {"sha": "41349cf72a16024c5ef48bcc6a333cbc084e4c39", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -34,7 +34,6 @@ use syntax::ext::hygiene::ExpnId;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n use syntax::span_err;\n-use syntax::std_inject::injected_crate_name;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n \n@@ -367,8 +366,10 @@ impl<'a> Resolver<'a> {\n                 };\n \n                 self.populate_module_if_necessary(module);\n-                if injected_crate_name().map_or(false, |name| ident.name.as_str() == name) {\n-                    self.injected_crate = Some(module);\n+                if let Some(name) = self.session.parse_sess.injected_crate_name.try_get() {\n+                    if name.as_str() == ident.name.as_str() {\n+                        self.injected_crate = Some(module);\n+                    }\n                 }\n \n                 let used = self.process_legacy_macro_imports(item, module, &parent_scope);"}, {"sha": "bb7834a133f039a564681a514b1ab064d758071a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -1,6 +1,6 @@\n use crate::ast::{self, Attribute, Name, PatKind};\n use crate::attr::{HasAttrs, Stability, Deprecation};\n-use crate::source_map::{SourceMap, Spanned, FileName, respan};\n+use crate::source_map::{SourceMap, Spanned, respan};\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, Transparency};\n@@ -14,7 +14,7 @@ use crate::tokenstream::{self, TokenStream, TokenTree};\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n-use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n+use syntax_pos::{FileName, Span, MultiSpan, DUMMY_SP};\n use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n \n use rustc_data_structures::fx::FxHashMap;"}, {"sha": "ff9ad46deecc078c0d3a7cf1683d2f08f502bb2d", "filename": "src/libsyntax/ext/derive.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cb8b491a65d93fd08752347d6a237457830567fa/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8b491a65d93fd08752347d6a237457830567fa/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=cb8b491a65d93fd08752347d6a237457830567fa", "patch": "@@ -1,72 +0,0 @@\n-use crate::attr::HasAttrs;\n-use crate::ast;\n-use crate::source_map::{ExpnInfo, ExpnKind};\n-use crate::ext::base::{ExtCtxt, MacroKind};\n-use crate::ext::build::AstBuilder;\n-use crate::parse::parser::PathStyle;\n-use crate::symbol::{Symbol, sym};\n-use crate::errors::Applicability;\n-\n-use syntax_pos::Span;\n-use rustc_data_structures::fx::FxHashSet;\n-\n-pub fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n-    let mut result = Vec::new();\n-    attrs.retain(|attr| {\n-        if attr.path != sym::derive {\n-            return true;\n-        }\n-        if !attr.is_meta_item_list() {\n-            cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n-                .span_suggestion(\n-                    attr.span,\n-                    \"missing traits to be derived\",\n-                    \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n-                    Applicability::HasPlaceholders,\n-                ).emit();\n-            return false;\n-        }\n-\n-        match attr.parse_list(cx.parse_sess,\n-                              |parser| parser.parse_path_allowing_meta(PathStyle::Mod)) {\n-            Ok(traits) => {\n-                result.extend(traits);\n-                true\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                false\n-            }\n-        }\n-    });\n-    result\n-}\n-\n-pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::Path], item: &mut T)\n-    where T: HasAttrs,\n-{\n-    let (mut names, mut pretty_name) = (FxHashSet::default(), String::new());\n-    for (i, path) in traits.iter().enumerate() {\n-        if i > 0 {\n-            pretty_name.push_str(\", \");\n-        }\n-        pretty_name.push_str(&path.to_string());\n-        names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n-    }\n-\n-    let span = span.fresh_expansion(cx.current_expansion.id, ExpnInfo::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n-        cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n-    ));\n-\n-    item.visit_attrs(|attrs| {\n-        if names.contains(&sym::Eq) && names.contains(&sym::PartialEq) {\n-            let meta = cx.meta_word(span, sym::structural_match);\n-            attrs.push(cx.attribute(span, meta));\n-        }\n-        if names.contains(&sym::Copy) {\n-            let meta = cx.meta_word(span, sym::rustc_copy_clone_marker);\n-            attrs.push(cx.attribute(span, meta));\n-        }\n-    });\n-}"}, {"sha": "cd602d08c5baaf0e886cc9be4422800173a4eb06", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -4,7 +4,7 @@ use crate::attr::{self, HasAttrs};\n use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n-use crate::ext::derive::{add_derived_markers, collect_derives};\n+use crate::ext::proc_macro::{add_derived_markers, collect_derives};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};"}, {"sha": "425b9813f5904da34431bf194c120c7bfe4f42e6", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -0,0 +1,249 @@\n+use crate::ast::{self, ItemKind, Attribute, Mac};\n+use crate::attr::{mark_used, mark_known, HasAttrs};\n+use crate::errors::{Applicability, FatalError};\n+use crate::ext::base::{self, *};\n+use crate::ext::build::AstBuilder;\n+use crate::ext::proc_macro_server;\n+use crate::parse::{self, token};\n+use crate::parse::parser::PathStyle;\n+use crate::symbol::{sym, Symbol};\n+use crate::tokenstream::{self, TokenStream};\n+use crate::visit::Visitor;\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+const EXEC_STRATEGY: proc_macro::bridge::server::SameThread =\n+    proc_macro::bridge::server::SameThread;\n+\n+pub struct BangProcMacro {\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n+    >,\n+}\n+\n+impl base::ProcMacro for BangProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt<'_>,\n+                   span: Span,\n+                   input: TokenStream)\n+                   -> TokenStream {\n+        let server = proc_macro_server::Rustc::new(ecx);\n+        match self.client.run(&EXEC_STRATEGY, server, input) {\n+            Ok(stream) => stream,\n+            Err(e) => {\n+                let msg = \"proc macro panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.as_str() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                FatalError.raise();\n+            }\n+        }\n+    }\n+}\n+\n+pub struct AttrProcMacro {\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream,\n+    >,\n+}\n+\n+impl base::AttrProcMacro for AttrProcMacro {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt<'_>,\n+                   span: Span,\n+                   annotation: TokenStream,\n+                   annotated: TokenStream)\n+                   -> TokenStream {\n+        let server = proc_macro_server::Rustc::new(ecx);\n+        match self.client.run(&EXEC_STRATEGY, server, annotation, annotated) {\n+            Ok(stream) => stream,\n+            Err(e) => {\n+                let msg = \"custom attribute panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.as_str() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                FatalError.raise();\n+            }\n+        }\n+    }\n+}\n+\n+pub struct ProcMacroDerive {\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n+    >,\n+    pub attrs: Vec<ast::Name>,\n+}\n+\n+impl MultiItemModifier for ProcMacroDerive {\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt<'_>,\n+              span: Span,\n+              _meta_item: &ast::MetaItem,\n+              item: Annotatable)\n+              -> Vec<Annotatable> {\n+        let item = match item {\n+            Annotatable::Item(item) => item,\n+            Annotatable::ImplItem(_) |\n+            Annotatable::TraitItem(_) |\n+            Annotatable::ForeignItem(_) |\n+            Annotatable::Stmt(_) |\n+            Annotatable::Expr(_) => {\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n+                                    applied to a struct, enum, or union\");\n+                return Vec::new()\n+            }\n+        };\n+        match item.node {\n+            ItemKind::Struct(..) |\n+            ItemKind::Enum(..) |\n+            ItemKind::Union(..) => {},\n+            _ => {\n+                ecx.span_err(span, \"proc-macro derives may only be \\\n+                                    applied to a struct, enum, or union\");\n+                return Vec::new()\n+            }\n+        }\n+\n+        // Mark attributes as known, and used.\n+        MarkAttrs(&self.attrs).visit_item(&item);\n+\n+        let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n+        let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n+\n+        let server = proc_macro_server::Rustc::new(ecx);\n+        let stream = match self.client.run(&EXEC_STRATEGY, server, input) {\n+            Ok(stream) => stream,\n+            Err(e) => {\n+                let msg = \"proc-macro derive panicked\";\n+                let mut err = ecx.struct_span_fatal(span, msg);\n+                if let Some(s) = e.as_str() {\n+                    err.help(&format!(\"message: {}\", s));\n+                }\n+\n+                err.emit();\n+                FatalError.raise();\n+            }\n+        };\n+\n+        let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n+        let msg = \"proc-macro derive produced unparseable tokens\";\n+\n+        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n+        let mut items = vec![];\n+\n+        loop {\n+            match parser.parse_item() {\n+                Ok(None) => break,\n+                Ok(Some(item)) => {\n+                    items.push(Annotatable::Item(item))\n+                }\n+                Err(mut err) => {\n+                    // FIXME: handle this better\n+                    err.cancel();\n+                    ecx.struct_span_fatal(span, msg).emit();\n+                    FatalError.raise();\n+                }\n+            }\n+        }\n+\n+\n+        // fail if there have been errors emitted\n+        if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n+            ecx.struct_span_fatal(span, msg).emit();\n+            FatalError.raise();\n+        }\n+\n+        items\n+    }\n+}\n+\n+struct MarkAttrs<'a>(&'a [ast::Name]);\n+\n+impl<'a> Visitor<'a> for MarkAttrs<'a> {\n+    fn visit_attribute(&mut self, attr: &Attribute) {\n+        if let Some(ident) = attr.ident() {\n+            if self.0.contains(&ident.name) {\n+                mark_used(attr);\n+                mark_known(attr);\n+            }\n+        }\n+    }\n+\n+    fn visit_mac(&mut self, _mac: &Mac) {}\n+}\n+\n+pub fn is_proc_macro_attr(attr: &Attribute) -> bool {\n+    [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+        .iter().any(|kind| attr.check_name(*kind))\n+}\n+\n+crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n+    let mut result = Vec::new();\n+    attrs.retain(|attr| {\n+        if attr.path != sym::derive {\n+            return true;\n+        }\n+        if !attr.is_meta_item_list() {\n+            cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n+                .span_suggestion(\n+                    attr.span,\n+                    \"missing traits to be derived\",\n+                    \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n+                    Applicability::HasPlaceholders,\n+                ).emit();\n+            return false;\n+        }\n+\n+        match attr.parse_list(cx.parse_sess,\n+                              |parser| parser.parse_path_allowing_meta(PathStyle::Mod)) {\n+            Ok(traits) => {\n+                result.extend(traits);\n+                true\n+            }\n+            Err(mut e) => {\n+                e.emit();\n+                false\n+            }\n+        }\n+    });\n+    result\n+}\n+\n+crate fn add_derived_markers<T: HasAttrs>(\n+    cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::Path], item: &mut T\n+) {\n+    let (mut names, mut pretty_name) = (FxHashSet::default(), String::new());\n+    for (i, path) in traits.iter().enumerate() {\n+        if i > 0 {\n+            pretty_name.push_str(\", \");\n+        }\n+        pretty_name.push_str(&path.to_string());\n+        names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n+    }\n+\n+    let span = span.fresh_expansion(cx.current_expansion.id, ExpnInfo::allow_unstable(\n+        ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n+        cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n+    ));\n+\n+    item.visit_attrs(|attrs| {\n+        if names.contains(&sym::Eq) && names.contains(&sym::PartialEq) {\n+            let meta = cx.meta_word(span, sym::structural_match);\n+            attrs.push(cx.attribute(span, meta));\n+        }\n+        if names.contains(&sym::Copy) {\n+            let meta = cx.meta_word(span, sym::rustc_copy_clone_marker);\n+            attrs.push(cx.attribute(span, meta));\n+        }\n+    });\n+}"}, {"sha": "8d0023c9ab1eb986e57c69a8a6ef3e81b41e4758", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "renamed", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -1,21 +1,19 @@\n-use errors::{Diagnostic, DiagnosticBuilder};\n-\n-use std::panic;\n-\n-use proc_macro::bridge::{server, TokenTree};\n-use proc_macro::{Delimiter, Level, LineColumn, Spacing};\n+use crate::ast;\n+use crate::ext::base::ExtCtxt;\n+use crate::parse::{self, token, ParseSess};\n+use crate::parse::lexer::comments;\n+use crate::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n \n+use errors::{Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n-use std::ascii;\n-use std::ops::Bound;\n-use syntax::ast;\n-use syntax::ext::base::ExtCtxt;\n-use syntax::parse::lexer::comments;\n-use syntax::parse::{self, token, ParseSess};\n-use syntax::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n+use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n use syntax_pos::hygiene::{SyntaxContext, Transparency};\n use syntax_pos::symbol::{kw, sym, Symbol};\n-use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n+\n+use proc_macro::{Delimiter, Level, LineColumn, Spacing};\n+use proc_macro::bridge::{server, TokenTree};\n+use std::{ascii, panic};\n+use std::ops::Bound;\n \n trait FromInternal<T> {\n     fn from_internal(x: T) -> Self;\n@@ -52,7 +50,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n {\n     fn from_internal(((tree, is_joint), sess, stack): (TreeAndJoint, &ParseSess, &mut Vec<Self>))\n                     -> Self {\n-        use syntax::parse::token::*;\n+        use crate::parse::token::*;\n \n         let joint = is_joint == Joint;\n         let Token { kind, span } = match tree {\n@@ -193,7 +191,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n \n impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n     fn to_internal(self) -> TokenStream {\n-        use syntax::parse::token::*;\n+        use crate::parse::token::*;\n \n         let (ch, joint, span) = match self {\n             TokenTree::Punct(Punct { ch, joint, span }) => (ch, joint, span),", "previous_filename": "src/libsyntax_ext/proc_macro_server.rs"}, {"sha": "bb6a8dfb1411ecf5c355103a458a38229e8047c8", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -18,12 +18,17 @@\n #![feature(label_break_value)]\n #![feature(mem_take)]\n #![feature(nll)]\n+#![feature(proc_macro_diagnostic)]\n+#![feature(proc_macro_internals)]\n+#![feature(proc_macro_span)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(try_trait)]\n #![feature(unicode_internals)]\n \n #![recursion_limit=\"256\"]\n \n+extern crate proc_macro;\n+\n pub use errors;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::bit_set::GrowableBitSet;\n@@ -37,6 +42,7 @@ const MACRO_ARGUMENTS: Option<&'static str> = Some(\"macro arguments\");\n // way towards a non-panic!-prone parser. It should be used for fatal parsing\n // errors; eventually we plan to convert all code using panictry to just use\n // normal try.\n+#[macro_export]\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n@@ -147,10 +153,8 @@ pub mod mut_visit;\n pub mod parse;\n pub mod ptr;\n pub mod show_span;\n-pub mod std_inject;\n pub use syntax_pos::edition;\n pub use syntax_pos::symbol;\n-pub mod test;\n pub mod tokenstream;\n pub mod visit;\n \n@@ -161,14 +165,15 @@ pub mod print {\n }\n \n pub mod ext {\n+    mod placeholders;\n+    mod proc_macro_server;\n+\n     pub use syntax_pos::hygiene;\n     pub mod allocator;\n     pub mod base;\n     pub mod build;\n-    pub mod derive;\n     pub mod expand;\n-    pub mod placeholders;\n-    pub mod source_util;\n+    pub mod proc_macro;\n \n     pub mod tt {\n         pub mod transcribe;"}, {"sha": "3cd5464f35710c4fd67c6c57cc3a57a409a0462c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -794,7 +794,7 @@ mod tests {\n     use std::path::PathBuf;\n     use syntax_pos::{BytePos, Span, NO_EXPANSION, edition::Edition};\n     use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-    use rustc_data_structures::sync::Lock;\n+    use rustc_data_structures::sync::{Lock, Once};\n \n     fn mk_sess(sm: Lrc<SourceMap>) -> ParseSess {\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n@@ -817,6 +817,7 @@ mod tests {\n             param_attr_spans: Lock::new(Vec::new()),\n             let_chains_spans: Lock::new(Vec::new()),\n             async_closure_spans: Lock::new(Vec::new()),\n+            injected_crate_name: Once::new(),\n         }\n     }\n "}, {"sha": "1aac8bbb7aa46589d9d07a3af0017a1757f838ef", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -10,9 +10,10 @@ use crate::parse::token::TokenKind;\n use crate::tokenstream::{TokenStream, TokenTree};\n use crate::diagnostics::plugin::ErrorMap;\n use crate::print::pprust;\n+use crate::symbol::Symbol;\n \n use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n-use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::sync::{Lrc, Lock, Once};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n use syntax_pos::edition::Edition;\n \n@@ -58,6 +59,7 @@ pub struct ParseSess {\n     pub let_chains_spans: Lock<Vec<Span>>,\n     // Places where `async || ..` exprs were used and should be feature gated.\n     pub async_closure_spans: Lock<Vec<Span>>,\n+    pub injected_crate_name: Once<Symbol>,\n }\n \n impl ParseSess {\n@@ -86,6 +88,7 @@ impl ParseSess {\n             param_attr_spans: Lock::new(Vec::new()),\n             let_chains_spans: Lock::new(Vec::new()),\n             async_closure_spans: Lock::new(Vec::new()),\n+            injected_crate_name: Once::new(),\n         }\n     }\n "}, {"sha": "c462357639506d50a29a18f625151d0c703bac1e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -10,7 +10,6 @@ use crate::parse::{self, ParseSess};\n use crate::print::pp::{self, Breaks};\n use crate::print::pp::Breaks::{Consistent, Inconsistent};\n use crate::ptr::P;\n-use crate::std_inject;\n use crate::symbol::{kw, sym};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n \n@@ -114,7 +113,7 @@ pub fn print_crate<'a>(cm: &'a SourceMap,\n         is_expanded,\n     };\n \n-    if is_expanded && std_inject::injected_crate_name().is_some() {\n+    if is_expanded && sess.injected_crate_name.try_get().is_some() {\n         // We need to print `#![no_std]` (and its feature gate) so that\n         // compiling pretty-printed source won't inject libstd again.\n         // However we don't want these attributes in the AST because"}, {"sha": "73310df305b32cb9892b5e5ce2e1327f6ac794c7", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -10,11 +10,11 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-fmt_macros = { path = \"../libfmt_macros\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n-syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n+fmt_macros = { path = \"../libfmt_macros\" }\n+log = \"0.4\"\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n-log = \"0.4\"\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "98465d75e4680e9d31beb6665f871e22e0ade22b", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/cb8b491a65d93fd08752347d6a237457830567fa/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8b491a65d93fd08752347d6a237457830567fa/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=cb8b491a65d93fd08752347d6a237457830567fa", "patch": "@@ -1,119 +0,0 @@\n-use crate::proc_macro_impl::EXEC_STRATEGY;\n-use crate::proc_macro_server;\n-\n-use errors::FatalError;\n-use rustc_data_structures::sync::Lrc;\n-use syntax::ast::{self, ItemKind, Attribute, Mac};\n-use syntax::attr::{mark_used, mark_known};\n-use syntax::source_map::Span;\n-use syntax::ext::base::*;\n-use syntax::parse;\n-use syntax::parse::token;\n-use syntax::tokenstream;\n-use syntax::visit::Visitor;\n-use syntax_pos::DUMMY_SP;\n-\n-struct MarkAttrs<'a>(&'a [ast::Name]);\n-\n-impl<'a> Visitor<'a> for MarkAttrs<'a> {\n-    fn visit_attribute(&mut self, attr: &Attribute) {\n-        if let Some(ident) = attr.ident() {\n-            if self.0.contains(&ident.name) {\n-                mark_used(attr);\n-                mark_known(attr);\n-            }\n-        }\n-    }\n-\n-    fn visit_mac(&mut self, _mac: &Mac) {}\n-}\n-\n-pub struct ProcMacroDerive {\n-    pub client: proc_macro::bridge::client::Client<\n-        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n-    >,\n-    pub attrs: Vec<ast::Name>,\n-}\n-\n-impl MultiItemModifier for ProcMacroDerive {\n-    fn expand(&self,\n-              ecx: &mut ExtCtxt<'_>,\n-              span: Span,\n-              _meta_item: &ast::MetaItem,\n-              item: Annotatable)\n-              -> Vec<Annotatable> {\n-        let item = match item {\n-            Annotatable::Item(item) => item,\n-            Annotatable::ImplItem(_) |\n-            Annotatable::TraitItem(_) |\n-            Annotatable::ForeignItem(_) |\n-            Annotatable::Stmt(_) |\n-            Annotatable::Expr(_) => {\n-                ecx.span_err(span, \"proc-macro derives may only be \\\n-                                    applied to a struct, enum, or union\");\n-                return Vec::new()\n-            }\n-        };\n-        match item.node {\n-            ItemKind::Struct(..) |\n-            ItemKind::Enum(..) |\n-            ItemKind::Union(..) => {},\n-            _ => {\n-                ecx.span_err(span, \"proc-macro derives may only be \\\n-                                    applied to a struct, enum, or union\");\n-                return Vec::new()\n-            }\n-        }\n-\n-        // Mark attributes as known, and used.\n-        MarkAttrs(&self.attrs).visit_item(&item);\n-\n-        let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n-        let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n-\n-        let server = proc_macro_server::Rustc::new(ecx);\n-        let stream = match self.client.run(&EXEC_STRATEGY, server, input) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"proc-macro derive panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n-            }\n-        };\n-\n-        let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n-        let msg = \"proc-macro derive produced unparseable tokens\";\n-\n-        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n-        let mut items = vec![];\n-\n-        loop {\n-            match parser.parse_item() {\n-                Ok(None) => break,\n-                Ok(Some(item)) => {\n-                    items.push(Annotatable::Item(item))\n-                }\n-                Err(mut err) => {\n-                    // FIXME: handle this better\n-                    err.cancel();\n-                    ecx.struct_span_fatal(span, msg).emit();\n-                    FatalError.raise();\n-                }\n-            }\n-        }\n-\n-\n-        // fail if there have been errors emitted\n-        if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n-            ecx.struct_span_fatal(span, msg).emit();\n-            FatalError.raise();\n-        }\n-\n-        items\n-    }\n-}"}, {"sha": "7f27769f236e29b97b4a1c098980254b5a1d8a8e", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -1770,50 +1770,6 @@ pub fn cs_fold1<F, B>(use_foldl: bool,\n     }\n }\n \n-/// Call the method that is being derived on all the fields, and then\n-/// process the collected results. i.e.\n-///\n-/// ```ignore (only-for-syntax-highlight)\n-/// f(cx, span, vec![self_1.method(__arg_1_1, __arg_2_1),\n-///                  self_2.method(__arg_1_2, __arg_2_2)])\n-/// ```\n-#[inline]\n-pub fn cs_same_method<F>(f: F,\n-                         mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n-                         cx: &mut ExtCtxt<'_>,\n-                         trait_span: Span,\n-                         substructure: &Substructure<'_>)\n-                         -> P<Expr>\n-    where F: FnOnce(&mut ExtCtxt<'_>, Span, Vec<P<Expr>>) -> P<Expr>\n-{\n-    match *substructure.fields {\n-        EnumMatching(.., ref all_fields) |\n-        Struct(_, ref all_fields) => {\n-            // call self_n.method(other_1_n, other_2_n, ...)\n-            let called = all_fields.iter()\n-                .map(|field| {\n-                    cx.expr_method_call(field.span,\n-                                        field.self_.clone(),\n-                                        substructure.method_ident,\n-                                        field.other\n-                                            .iter()\n-                                            .map(|e| cx.expr_addr_of(field.span, e.clone()))\n-                                            .collect())\n-                })\n-                .collect();\n-\n-            f(cx, trait_span, called)\n-        }\n-        EnumNonMatchingCollapsed(ref all_self_args, _, tuple) => {\n-            enum_nonmatch_f(cx,\n-                            trait_span,\n-                            (&all_self_args[..], tuple),\n-                            substructure.nonself_args)\n-        }\n-        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n-    }\n-}\n-\n /// Returns `true` if the type has no value fields\n /// (for an enum, no variant has any fields)\n pub fn is_type_without_fields(item: &Annotatable) -> bool {"}, {"sha": "394beb141712d8b7ad254120a04677da7496e578", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -18,6 +18,7 @@ pub enum PtrTy<'a> {\n     /// &'lifetime mut\n     Borrowed(Option<&'a str>, ast::Mutability),\n     /// *mut\n+    #[allow(dead_code)]\n     Raw(ast::Mutability),\n }\n \n@@ -107,13 +108,6 @@ pub enum Ty<'a> {\n     Tuple(Vec<Ty<'a>>),\n }\n \n-/// A const expression. Supports literals and blocks.\n-#[derive(Clone, Eq, PartialEq)]\n-pub enum Const {\n-    Literal,\n-    Block,\n-}\n-\n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n     Borrowed(None, ast::Mutability::Immutable)\n }"}, {"sha": "cad79917af284a623841f5e7104a718482f96a2b", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -26,7 +26,6 @@ pub mod decodable;\n pub mod hash;\n pub mod debug;\n pub mod default;\n-pub mod custom;\n \n #[path=\"cmp/partial_eq.rs\"]\n pub mod partial_eq;"}, {"sha": "fae884860ed56f262322f6f12aa5347659c8cac4", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -1,4 +1,5 @@\n-//! Syntax extensions in the Rust compiler.\n+//! This crate contains implementations of built-in macros and other code generating facilities\n+//! injecting code into the crate before it is lowered to HIR.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n@@ -7,21 +8,15 @@\n \n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n+#![feature(mem_take)]\n #![feature(nll)]\n-#![feature(proc_macro_diagnostic)]\n-#![feature(proc_macro_internals)]\n-#![feature(proc_macro_span)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unicode_internals)]\n-\n-extern crate proc_macro;\n \n use crate::deriving::*;\n \n use syntax::ast::Ident;\n use syntax::edition::Edition;\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, MacroExpanderFn};\n-use syntax::ext::source_util;\n use syntax::symbol::sym;\n \n mod error_codes;\n@@ -32,21 +27,21 @@ mod cfg;\n mod compile_error;\n mod concat;\n mod concat_idents;\n+mod deriving;\n mod env;\n mod format;\n mod format_foreign;\n mod global_allocator;\n mod global_asm;\n mod log_syntax;\n-mod proc_macro_server;\n+mod source_util;\n mod test;\n-mod test_case;\n mod trace_macros;\n \n-pub mod deriving;\n pub mod plugin_macro_defs;\n-pub mod proc_macro_decls;\n-pub mod proc_macro_impl;\n+pub mod proc_macro_harness;\n+pub mod standard_library_imports;\n+pub mod test_harness;\n \n pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, edition: Edition) {\n     let mut register = |name, kind| resolver.register_builtin_macro(\n@@ -93,7 +88,7 @@ pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, e\n         bench: test::expand_bench,\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,\n-        test_case: test_case::expand,\n+        test_case: test::expand_test_case,\n     }\n \n     register_derive! {"}, {"sha": "fc6cd5dc94cd596e617abdb2813ad8d0dc3e5f9e", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "renamed", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -7,21 +7,15 @@ use syntax::ext::base::{ExtCtxt, MacroKind};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::ext::hygiene::ExpnId;\n+use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::mut_visit::MutVisitor;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n-const PROC_MACRO_KINDS: [Symbol; 3] = [\n-    sym::proc_macro_derive,\n-    sym::proc_macro_attribute,\n-    sym::proc_macro\n-];\n-\n struct ProcMacroDerive {\n     trait_name: ast::Name,\n     function_name: Ident,\n@@ -44,7 +38,7 @@ struct CollectProcMacros<'a> {\n     is_test_crate: bool,\n }\n \n-pub fn modify(sess: &ParseSess,\n+pub fn inject(sess: &ParseSess,\n               resolver: &mut dyn (::syntax::ext::base::Resolver),\n               mut krate: ast::Crate,\n               is_proc_macro_crate: bool,\n@@ -88,10 +82,6 @@ pub fn modify(sess: &ParseSess,\n     krate\n }\n \n-pub fn is_proc_macro_attr(attr: &ast::Attribute) -> bool {\n-    PROC_MACRO_KINDS.iter().any(|kind| attr.check_name(*kind))\n-}\n-\n impl<'a> CollectProcMacros<'a> {\n     fn check_not_pub_in_root(&self, vis: &ast::Visibility, sp: Span) {\n         if self.is_proc_macro_crate && self.in_root && vis.node.is_pub() {", "previous_filename": "src/libsyntax_ext/proc_macro_decls.rs"}, {"sha": "f0fc6392cd73f593f7e963e8c4342f8ce2182b37", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cb8b491a65d93fd08752347d6a237457830567fa/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8b491a65d93fd08752347d6a237457830567fa/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=cb8b491a65d93fd08752347d6a237457830567fa", "patch": "@@ -1,68 +0,0 @@\n-use crate::proc_macro_server;\n-\n-use errors::FatalError;\n-use syntax::source_map::Span;\n-use syntax::ext::base::{self, *};\n-use syntax::tokenstream::TokenStream;\n-\n-pub const EXEC_STRATEGY: proc_macro::bridge::server::SameThread =\n-    proc_macro::bridge::server::SameThread;\n-\n-pub struct AttrProcMacro {\n-    pub client: proc_macro::bridge::client::Client<\n-        fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream,\n-    >,\n-}\n-\n-impl base::AttrProcMacro for AttrProcMacro {\n-    fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt<'_>,\n-                   span: Span,\n-                   annotation: TokenStream,\n-                   annotated: TokenStream)\n-                   -> TokenStream {\n-        let server = proc_macro_server::Rustc::new(ecx);\n-        match self.client.run(&EXEC_STRATEGY, server, annotation, annotated) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"custom attribute panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n-            }\n-        }\n-    }\n-}\n-\n-pub struct BangProcMacro {\n-    pub client: proc_macro::bridge::client::Client<\n-        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n-    >,\n-}\n-\n-impl base::ProcMacro for BangProcMacro {\n-    fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt<'_>,\n-                   span: Span,\n-                   input: TokenStream)\n-                   -> TokenStream {\n-        let server = proc_macro_server::Rustc::new(ecx);\n-        match self.client.run(&EXEC_STRATEGY, server, input) {\n-            Ok(stream) => stream,\n-            Err(e) => {\n-                let msg = \"proc macro panicked\";\n-                let mut err = ecx.struct_span_fatal(span, msg);\n-                if let Some(s) = e.as_str() {\n-                    err.help(&format!(\"message: {}\", s));\n-                }\n-\n-                err.emit();\n-                FatalError.raise();\n-            }\n-        }\n-    }\n-}"}, {"sha": "8ecfd4ddda7bfe7abc78b1f7f96b9137ca47c532", "filename": "src/libsyntax_ext/source_util.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fsource_util.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -1,11 +1,11 @@\n-use crate::ast;\n-use crate::ext::base::{self, *};\n-use crate::ext::build::AstBuilder;\n-use crate::parse::{self, token, DirectoryOwnership};\n-use crate::print::pprust;\n-use crate::ptr::P;\n-use crate::symbol::Symbol;\n-use crate::tokenstream;\n+use syntax::{ast, panictry};\n+use syntax::ext::base::{self, *};\n+use syntax::ext::build::AstBuilder;\n+use syntax::parse::{self, token, DirectoryOwnership};\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n+use syntax::tokenstream;\n \n use smallvec::SmallVec;\n use syntax_pos::{self, Pos, Span};\n@@ -94,7 +94,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: &[tokenstrea\n             while self.p.token != token::Eof {\n                 match panictry!(self.p.parse_item()) {\n                     Some(item) => ret.push(item),\n-                    None => self.p.diagnostic().span_fatal(self.p.token.span,\n+                    None => self.p.sess.span_diagnostic.span_fatal(self.p.token.span,\n                                                            &format!(\"expected item, found `{}`\",\n                                                                     self.p.this_token_to_string()))\n                                                .raise()", "previous_filename": "src/libsyntax/ext/source_util.rs"}, {"sha": "81bb32d79a2aa84eead684dbbe190065925ea2de", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "renamed", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -1,37 +1,22 @@\n-use crate::ast;\n-use crate::attr;\n-use crate::edition::Edition;\n-use crate::ext::hygiene::{ExpnId, MacroKind};\n-use crate::symbol::{Ident, Symbol, kw, sym};\n-use crate::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n-use crate::ptr::P;\n-use crate::tokenstream::TokenStream;\n-\n-use std::cell::Cell;\n-use std::iter;\n+use syntax::{ast, attr};\n+use syntax::edition::Edition;\n+use syntax::ext::hygiene::{ExpnId, MacroKind};\n+use syntax::ptr::P;\n+use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n+use syntax::symbol::{Ident, Symbol, kw, sym};\n+use syntax::tokenstream::TokenStream;\n use syntax_pos::DUMMY_SP;\n \n-pub fn injected_crate_name() -> Option<&'static str> {\n-    INJECTED_CRATE_NAME.with(|name| name.get())\n-}\n-\n-thread_local! {\n-    // A `Symbol` might make more sense here, but it doesn't work, probably for\n-    // reasons relating to the use of thread-local storage for the Symbol\n-    // interner.\n-    static INJECTED_CRATE_NAME: Cell<Option<&'static str>> = Cell::new(None);\n-}\n+use std::iter;\n \n-pub fn maybe_inject_crates_ref(\n-    mut krate: ast::Crate,\n-    alt_std_name: Option<&str>,\n-    edition: Edition,\n-) -> ast::Crate {\n+pub fn inject(\n+    mut krate: ast::Crate, alt_std_name: Option<&str>, edition: Edition\n+) -> (ast::Crate, Option<Symbol>) {\n     let rust_2018 = edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n     let names: &[&str] = if attr::contains_name(&krate.attrs, sym::no_core) {\n-        return krate;\n+        return (krate, None);\n     } else if attr::contains_name(&krate.attrs, sym::no_std) {\n         if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[\"core\"]\n@@ -73,8 +58,6 @@ pub fn maybe_inject_crates_ref(\n     // the prelude.\n     let name = names[0];\n \n-    INJECTED_CRATE_NAME.with(|opt_name| opt_name.set(Some(name)));\n-\n     let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n         [sym::prelude_import][..].into(),\n@@ -108,5 +91,5 @@ pub fn maybe_inject_crates_ref(\n         tokens: None,\n     }));\n \n-    krate\n+    (krate, Some(Symbol::intern(name)))\n }", "previous_filename": "src/libsyntax/std_inject.rs"}, {"sha": "a2d93d01cec5623c9e463008ad69cb6baa11f0db", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -7,11 +7,44 @@ use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::print::pprust;\n+use syntax::source_map::respan;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n \n use std::iter;\n \n+// #[test_case] is used by custom test authors to mark tests\n+// When building for test, it needs to make the item public and gensym the name\n+// Otherwise, we'll omit the item. This behavior means that any item annotated\n+// with #[test_case] is never addressable.\n+//\n+// We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n+// logic will pick up on.\n+pub fn expand_test_case(\n+    ecx: &mut ExtCtxt<'_>,\n+    attr_sp: Span,\n+    meta_item: &ast::MetaItem,\n+    anno_item: Annotatable\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::test_case);\n+\n+    if !ecx.ecfg.should_test { return vec![]; }\n+\n+    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n+    let mut item = anno_item.expect_item();\n+    item = item.map(|mut item| {\n+        item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n+        item.ident = item.ident.gensym();\n+        item.attrs.push(\n+            ecx.attribute(sp,\n+                ecx.meta_word(sp, sym::rustc_test_marker))\n+        );\n+        item\n+    });\n+\n+    return vec![Annotatable::Item(item)]\n+}\n+\n pub fn expand_test(\n     cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,"}, {"sha": "ea4a8d541ab9928f8636bdde77b24a1adfc17532", "filename": "src/libsyntax_ext/test_case.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cb8b491a65d93fd08752347d6a237457830567fa/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8b491a65d93fd08752347d6a237457830567fa/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=cb8b491a65d93fd08752347d6a237457830567fa", "patch": "@@ -1,44 +0,0 @@\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-\n-// #[test_case] is used by custom test authors to mark tests\n-// When building for test, it needs to make the item public and gensym the name\n-// Otherwise, we'll omit the item. This behavior means that any item annotated\n-// with #[test_case] is never addressable.\n-//\n-// We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n-// logic will pick up on.\n-\n-use syntax::ast;\n-use syntax::attr::check_builtin_macro_attribute;\n-use syntax::ext::base::*;\n-use syntax::ext::build::AstBuilder;\n-use syntax::ext::hygiene::SyntaxContext;\n-use syntax::source_map::respan;\n-use syntax::symbol::sym;\n-use syntax_pos::Span;\n-\n-pub fn expand(\n-    ecx: &mut ExtCtxt<'_>,\n-    attr_sp: Span,\n-    meta_item: &ast::MetaItem,\n-    anno_item: Annotatable\n-) -> Vec<Annotatable> {\n-    check_builtin_macro_attribute(ecx, meta_item, sym::test_case);\n-\n-    if !ecx.ecfg.should_test { return vec![]; }\n-\n-    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n-    let mut item = anno_item.expect_item();\n-    item = item.map(|mut item| {\n-        item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n-        item.ident = item.ident.gensym();\n-        item.attrs.push(\n-            ecx.attribute(sp,\n-                ecx.meta_word(sp, sym::rustc_test_marker))\n-        );\n-        item\n-    });\n-\n-    return vec![Annotatable::Item(item)]\n-}"}, {"sha": "848c797856ea9c39d3f99f55612d8a8973d2cac6", "filename": "src/libsyntax_ext/test_harness.rs", "status": "renamed", "additions": 24, "deletions": 54, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca0cd73f498449de4aaf6ff9bd620838e21e9b59/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=ca0cd73f498449de4aaf6ff9bd620838e21e9b59", "patch": "@@ -1,35 +1,23 @@\n // Code that generates a test runner to run all the tests in a crate\n \n-#![allow(dead_code)]\n-#![allow(unused_imports)]\n-\n-use HasTestSignature::*;\n-\n-use std::iter;\n-use std::slice;\n-use std::mem;\n-use std::vec;\n-\n use log::debug;\n use smallvec::{smallvec, SmallVec};\n-use syntax_pos::{DUMMY_SP, NO_EXPANSION, Span, SourceFile, BytePos};\n-\n-use crate::attr::{self, HasAttrs};\n-use crate::source_map::{self, SourceMap, ExpnInfo, ExpnKind, dummy_spanned, respan};\n-use crate::config;\n-use crate::entry::{self, EntryPointType};\n-use crate::ext::base::{ExtCtxt, Resolver};\n-use crate::ext::build::AstBuilder;\n-use crate::ext::expand::ExpansionConfig;\n-use crate::ext::hygiene::{self, ExpnId, SyntaxContext, MacroKind};\n-use crate::mut_visit::{*, ExpectOne};\n-use crate::feature_gate::Features;\n-use crate::util::map_in_place::MapInPlace;\n-use crate::parse::{token, ParseSess};\n-use crate::ast::{self, Ident};\n-use crate::ptr::P;\n-use crate::symbol::{self, Symbol, kw, sym};\n-use crate::ThinVec;\n+use syntax::ast::{self, Ident};\n+use syntax::attr;\n+use syntax::entry::{self, EntryPointType};\n+use syntax::ext::base::{ExtCtxt, Resolver};\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::expand::ExpansionConfig;\n+use syntax::ext::hygiene::{ExpnId, MacroKind};\n+use syntax::feature_gate::Features;\n+use syntax::mut_visit::{*, ExpectOne};\n+use syntax::parse::ParseSess;\n+use syntax::ptr::P;\n+use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned};\n+use syntax::symbol::{kw, sym, Symbol};\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+use std::{iter, mem};\n \n struct Test {\n     span: Span,\n@@ -42,22 +30,21 @@ struct TestCtxt<'a> {\n     ext_cx: ExtCtxt<'a>,\n     test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n-    is_libtest: bool,\n-    features: &'a Features,\n     test_runner: Option<ast::Path>,\n-\n     // top-level re-export submodule, filled out after folding is finished\n     toplevel_reexport: Option<Ident>,\n }\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-pub fn modify_for_testing(sess: &ParseSess,\n-                          resolver: &mut dyn Resolver,\n-                          should_test: bool,\n-                          krate: &mut ast::Crate,\n-                          span_diagnostic: &errors::Handler,\n-                          features: &Features) {\n+pub fn inject(\n+    sess: &ParseSess,\n+    resolver: &mut dyn Resolver,\n+    should_test: bool,\n+    krate: &mut ast::Crate,\n+    span_diagnostic: &errors::Handler,\n+    features: &Features,\n+) {\n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n     // creates a `use __test::main as some_name;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n@@ -267,11 +254,7 @@ fn generate_test_harness(sess: &ParseSess,\n         path: Vec::new(),\n         test_cases: Vec::new(),\n         reexport_test_harness_main,\n-        // N.B., doesn't consider the value of `--crate-name` passed on the command line.\n-        is_libtest: attr::find_crate_name(&krate.attrs)\n-            .map(|s| s == sym::test).unwrap_or(false),\n         toplevel_reexport: None,\n-        features,\n         test_runner\n     };\n \n@@ -282,19 +265,6 @@ fn generate_test_harness(sess: &ParseSess,\n     }.visit_crate(krate);\n }\n \n-enum HasTestSignature {\n-    Yes,\n-    No(BadTestSignature),\n-}\n-\n-#[derive(PartialEq)]\n-enum BadTestSignature {\n-    NotEvenAFunction,\n-    WrongTypeSignature,\n-    NoArgumentsAllowed,\n-    ShouldPanicOnlyWithNoArgs,\n-}\n-\n /// Creates a function item for use as the main function of a test build.\n /// This function will call the `test_runner` as specified by the crate attribute\n fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {", "previous_filename": "src/libsyntax/test.rs"}]}