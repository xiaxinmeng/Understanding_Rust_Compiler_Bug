{"sha": "982b8f4f49588ffe47475321a0d59c2beef1c9be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MmI4ZjRmNDk1ODhmZmU0NzQ3NTMyMWEwZDU5YzJiZWVmMWM5YmU=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-02T18:00:42Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-04T18:37:44Z"}, "message": "Move trans_const to mir::constant", "tree": {"sha": "8ca5e14cb99311ab13c338118179e18a72969df4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ca5e14cb99311ab13c338118179e18a72969df4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/982b8f4f49588ffe47475321a0d59c2beef1c9be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/982b8f4f49588ffe47475321a0d59c2beef1c9be", "html_url": "https://github.com/rust-lang/rust/commit/982b8f4f49588ffe47475321a0d59c2beef1c9be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/982b8f4f49588ffe47475321a0d59c2beef1c9be/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb", "html_url": "https://github.com/rust-lang/rust/commit/ea0ebe41c7dc04374ec0e7e1173bb32b374d02fb"}], "stats": {"total": 325, "additions": 164, "deletions": 161}, "files": [{"sha": "04634607c2c502ed7b71ec021073d30fbe31158d", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 5, "deletions": 149, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/982b8f4f49588ffe47475321a0d59c2beef1c9be/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982b8f4f49588ffe47475321a0d59c2beef1c9be/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=982b8f4f49588ffe47475321a0d59c2beef1c9be", "patch": "@@ -70,9 +70,9 @@ pub enum BranchKind {\n /// Treats closures as a struct with one variant.\n /// `empty_if_no_variants` is a switch to deal with empty enums.\n /// If true, `variant_index` is disregarded and an empty Vec returned in this case.\n-fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                            variant_index: usize,\n-                            empty_if_no_variants: bool) -> Vec<Ty<'tcx>> {\n+pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n+                                variant_index: usize,\n+                                empty_if_no_variants: bool) -> Vec<Ty<'tcx>> {\n     match t.sty {\n         ty::TyAdt(ref def, _) if def.variants.len() == 0 && empty_if_no_variants => {\n             Vec::default()\n@@ -412,9 +412,7 @@ pub fn trans_case<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -\n \n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n-pub fn trans_set_discr<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr\n-) {\n+pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr) {\n     let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n@@ -465,7 +463,7 @@ fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n     bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n }\n \n-fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n+pub fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n     if min <= max {\n         assert!(min <= discr && discr <= max)\n     } else {\n@@ -630,148 +628,6 @@ fn struct_field_ptr<'a, 'tcx>(\n     bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n }\n \n-/// Construct a constant value, suitable for initializing a\n-/// GlobalVariable, given a case and constant values for its fields.\n-/// Note that this may have a different LLVM type (and different\n-/// alignment!) from the representation's `type_of`, so it needs a\n-/// pointer cast before use.\n-///\n-/// The LLVM type system does not directly support unions, and only\n-/// pointers can be bitcast, so a constant (and, by extension, the\n-/// GlobalVariable initialized by it) will have a type that can vary\n-/// depending on which case of an enum it is.\n-///\n-/// To understand the alignment situation, consider `enum E { V64(u64),\n-/// V32(u32, u32) }` on Windows.  The type has 8-byte alignment to\n-/// accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n-/// i32, i32}`, which is 4-byte aligned.\n-///\n-/// Currently the returned value has the same size as the type, but\n-/// this could be changed in the future to avoid allocating unnecessary\n-/// space after values of shorter-than-maximum cases.\n-pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>, discr: Disr,\n-                             vals: &[ValueRef]) -> ValueRef {\n-    let l = ccx.layout_of(t);\n-    let dl = &ccx.tcx().data_layout;\n-    match *l {\n-        layout::CEnum { discr: d, min, max, .. } => {\n-            assert_eq!(vals.len(), 0);\n-            assert_discr_in_range(Disr(min), Disr(max), discr);\n-            C_integral(Type::from_integer(ccx, d), discr.0, true)\n-        }\n-        layout::General { discr: d, ref variants, .. } => {\n-            let variant = &variants[discr.0 as usize];\n-            let lldiscr = C_integral(Type::from_integer(ccx, d), discr.0 as u64, true);\n-            let mut vals_with_discr = vec![lldiscr];\n-            vals_with_discr.extend_from_slice(vals);\n-            let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);\n-            let needed_padding = l.size(dl).bytes() - variant.stride().bytes();\n-            if needed_padding > 0 {\n-                contents.push(padding(ccx, needed_padding));\n-            }\n-            C_struct(ccx, &contents[..], false)\n-        }\n-        layout::UntaggedUnion { ref variants, .. }=> {\n-            assert_eq!(discr, Disr(0));\n-            let contents = build_const_union(ccx, variants, vals[0]);\n-            C_struct(ccx, &contents, variants.packed)\n-        }\n-        layout::Univariant { ref variant, .. } => {\n-            assert_eq!(discr, Disr(0));\n-            let contents = build_const_struct(ccx, &variant, vals);\n-            C_struct(ccx, &contents[..], variant.packed)\n-        }\n-        layout::Vector { .. } => {\n-            C_vector(vals)\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(ccx, t, nndiscr as usize, false)[0];\n-            if discr.0 == nndiscr {\n-                assert_eq!(vals.len(), 1);\n-                vals[0]\n-            } else {\n-                C_null(type_of::sizing_type_of(ccx, nnty))\n-            }\n-        }\n-        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-            if discr.0 == nndiscr {\n-                C_struct(ccx, &build_const_struct(ccx, &nonnull, vals), false)\n-            } else {\n-                let fields = compute_fields(ccx, t, nndiscr as usize, false);\n-                let vals = fields.iter().map(|&ty| {\n-                    // Always use null even if it's not the `discrfield`th\n-                    // field; see #8506.\n-                    C_null(type_of::sizing_type_of(ccx, ty))\n-                }).collect::<Vec<ValueRef>>();\n-                C_struct(ccx, &build_const_struct(ccx, &nonnull, &vals[..]), false)\n-            }\n-        }\n-        _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)\n-    }\n-}\n-\n-/// Building structs is a little complicated, because we might need to\n-/// insert padding if a field's value is less aligned than its type.\n-///\n-/// Continuing the example from `trans_const`, a value of type `(u32,\n-/// E)` should have the `E` at offset 8, but if that field's\n-/// initializer is 4-byte aligned then simply translating the tuple as\n-/// a two-element struct will locate it at offset 4, and accesses to it\n-/// will read the wrong memory.\n-fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                st: &layout::Struct,\n-                                vals: &[ValueRef])\n-                                -> Vec<ValueRef> {\n-    assert_eq!(vals.len(), st.offsets.len());\n-\n-    if vals.len() == 0 {\n-        return Vec::new();\n-    }\n-\n-    // offset of current value\n-    let mut offset = 0;\n-    let mut cfields = Vec::new();\n-    cfields.reserve(st.offsets.len()*2);\n-\n-    let parts = st.field_index_by_increasing_offset().map(|i| {\n-        (&vals[i], st.offsets[i].bytes())\n-    });\n-    for (&val, target_offset) in parts {\n-        if offset < target_offset {\n-            cfields.push(padding(ccx, target_offset - offset));\n-            offset = target_offset;\n-        }\n-        assert!(!is_undef(val));\n-        cfields.push(val);\n-        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n-    }\n-\n-    if offset < st.stride().bytes() {\n-        cfields.push(padding(ccx, st.stride().bytes() - offset));\n-    }\n-\n-    cfields\n-}\n-\n-fn build_const_union<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               un: &layout::Union,\n-                               field_val: ValueRef)\n-                               -> Vec<ValueRef> {\n-    let mut cfields = vec![field_val];\n-\n-    let offset = machine::llsize_of_alloc(ccx, val_ty(field_val));\n-    let size = un.stride().bytes();\n-    if offset != size {\n-        cfields.push(padding(ccx, size - offset));\n-    }\n-\n-    cfields\n-}\n-\n-fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(ccx), size))\n-}\n-\n // FIXME this utility routine should be somewhere more general\n #[inline]\n fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }"}, {"sha": "13e659a5ae0e8cb7149e052489cbd2689b30f962", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 159, "deletions": 12, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/982b8f4f49588ffe47475321a0d59c2beef1c9be/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982b8f4f49588ffe47475321a0d59c2beef1c9be/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=982b8f4f49588ffe47475321a0d59c2beef1c9be", "patch": "@@ -18,7 +18,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, layout, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -27,7 +27,7 @@ use callee::Callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n-use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n+use common::{C_null, C_struct, C_str_slice, C_undef, C_uint, C_vector, is_undef};\n use common::const_to_opt_u128;\n use consts;\n use monomorphize::{self, Instance};\n@@ -549,16 +549,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::AggregateKind::Adt(..) |\n                     mir::AggregateKind::Closure(..) |\n                     mir::AggregateKind::Tuple => {\n-                        let disr = match *kind {\n-                            mir::AggregateKind::Adt(adt_def, index, _, _) => {\n-                                Disr::from(adt_def.variants[index].disr_val)\n-                            }\n-                            _ => Disr(0)\n-                        };\n-                        Const::new(\n-                            adt::trans_const(self.ccx, dest_ty, disr, &fields),\n-                            dest_ty\n-                        )\n+                        Const::new(trans_const(self.ccx, dest_ty, kind, &fields), dest_ty)\n                     }\n                 }\n             }\n@@ -946,3 +937,159 @@ pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n     let instance = Instance::mono(ccx.shared(), def_id);\n     MirConstContext::trans_def(ccx, instance, IndexVec::new()).map(|c| c.llval)\n }\n+\n+/// Construct a constant value, suitable for initializing a\n+/// GlobalVariable, given a case and constant values for its fields.\n+/// Note that this may have a different LLVM type (and different\n+/// alignment!) from the representation's `type_of`, so it needs a\n+/// pointer cast before use.\n+///\n+/// The LLVM type system does not directly support unions, and only\n+/// pointers can be bitcast, so a constant (and, by extension, the\n+/// GlobalVariable initialized by it) will have a type that can vary\n+/// depending on which case of an enum it is.\n+///\n+/// To understand the alignment situation, consider `enum E { V64(u64),\n+/// V32(u32, u32) }` on Windows.  The type has 8-byte alignment to\n+/// accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n+/// i32, i32}`, which is 4-byte aligned.\n+///\n+/// Currently the returned value has the same size as the type, but\n+/// this could be changed in the future to avoid allocating unnecessary\n+/// space after values of shorter-than-maximum cases.\n+fn trans_const<'a, 'tcx>(\n+    ccx: &CrateContext<'a, 'tcx>,\n+    t: Ty<'tcx>,\n+    kind: &mir::AggregateKind,\n+    vals: &[ValueRef]\n+) -> ValueRef {\n+    let l = ccx.layout_of(t);\n+    let dl = &ccx.tcx().data_layout;\n+    let variant_index = match *kind {\n+        mir::AggregateKind::Adt(_, index, _, _) => index,\n+        _ => 0,\n+    };\n+    match *l {\n+        layout::CEnum { discr: d, min, max, .. } => {\n+            let discr = match *kind {\n+                mir::AggregateKind::Adt(adt_def, _, _, _) => {\n+                    Disr::from(adt_def.variants[variant_index].disr_val)\n+                },\n+                _ => Disr(0),\n+            };\n+            assert_eq!(vals.len(), 0);\n+            adt::assert_discr_in_range(Disr(min), Disr(max), discr);\n+            C_integral(Type::from_integer(ccx, d), discr.0, true)\n+        }\n+        layout::General { discr: d, ref variants, .. } => {\n+            let variant = &variants[variant_index];\n+            let lldiscr = C_integral(Type::from_integer(ccx, d), variant_index as u64, true);\n+            let mut vals_with_discr = vec![lldiscr];\n+            vals_with_discr.extend_from_slice(vals);\n+            let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);\n+            let needed_padding = l.size(dl).bytes() - variant.stride().bytes();\n+            if needed_padding > 0 {\n+                contents.push(padding(ccx, needed_padding));\n+            }\n+            C_struct(ccx, &contents[..], false)\n+        }\n+        layout::UntaggedUnion { ref variants, .. }=> {\n+            assert_eq!(variant_index, 0);\n+            let contents = build_const_union(ccx, variants, vals[0]);\n+            C_struct(ccx, &contents, variants.packed)\n+        }\n+        layout::Univariant { ref variant, .. } => {\n+            assert_eq!(variant_index, 0);\n+            let contents = build_const_struct(ccx, &variant, vals);\n+            C_struct(ccx, &contents[..], variant.packed)\n+        }\n+        layout::Vector { .. } => {\n+            C_vector(vals)\n+        }\n+        layout::RawNullablePointer { nndiscr, .. } => {\n+            let nnty = adt::compute_fields(ccx, t, nndiscr as usize, false)[0];\n+            if variant_index as u64 == nndiscr {\n+                assert_eq!(vals.len(), 1);\n+                vals[0]\n+            } else {\n+                C_null(type_of::sizing_type_of(ccx, nnty))\n+            }\n+        }\n+        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+            if variant_index as u64 == nndiscr {\n+                C_struct(ccx, &build_const_struct(ccx, &nonnull, vals), false)\n+            } else {\n+                let fields = adt::compute_fields(ccx, t, nndiscr as usize, false);\n+                let vals = fields.iter().map(|&ty| {\n+                    // Always use null even if it's not the `discrfield`th\n+                    // field; see #8506.\n+                    C_null(type_of::sizing_type_of(ccx, ty))\n+                }).collect::<Vec<ValueRef>>();\n+                C_struct(ccx, &build_const_struct(ccx, &nonnull, &vals[..]), false)\n+            }\n+        }\n+        _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)\n+    }\n+}\n+\n+/// Building structs is a little complicated, because we might need to\n+/// insert padding if a field's value is less aligned than its type.\n+///\n+/// Continuing the example from `trans_const`, a value of type `(u32,\n+/// E)` should have the `E` at offset 8, but if that field's\n+/// initializer is 4-byte aligned then simply translating the tuple as\n+/// a two-element struct will locate it at offset 4, and accesses to it\n+/// will read the wrong memory.\n+fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                st: &layout::Struct,\n+                                vals: &[ValueRef])\n+                                -> Vec<ValueRef> {\n+    assert_eq!(vals.len(), st.offsets.len());\n+\n+    if vals.len() == 0 {\n+        return Vec::new();\n+    }\n+\n+    // offset of current value\n+    let mut offset = 0;\n+    let mut cfields = Vec::new();\n+    cfields.reserve(st.offsets.len()*2);\n+\n+    let parts = st.field_index_by_increasing_offset().map(|i| {\n+        (&vals[i], st.offsets[i].bytes())\n+    });\n+    for (&val, target_offset) in parts {\n+        if offset < target_offset {\n+            cfields.push(padding(ccx, target_offset - offset));\n+            offset = target_offset;\n+        }\n+        assert!(!is_undef(val));\n+        cfields.push(val);\n+        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n+    }\n+\n+    if offset < st.stride().bytes() {\n+        cfields.push(padding(ccx, st.stride().bytes() - offset));\n+    }\n+\n+    cfields\n+}\n+\n+fn build_const_union<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               un: &layout::Union,\n+                               field_val: ValueRef)\n+                               -> Vec<ValueRef> {\n+    let mut cfields = vec![field_val];\n+\n+    let offset = machine::llsize_of_alloc(ccx, val_ty(field_val));\n+    let size = un.stride().bytes();\n+    if offset != size {\n+        cfields.push(padding(ccx, size - offset));\n+    }\n+\n+    cfields\n+}\n+\n+fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n+    C_undef(Type::array(&Type::i8(ccx), size))\n+}"}]}