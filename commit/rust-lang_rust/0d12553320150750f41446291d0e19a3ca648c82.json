{"sha": "0d12553320150750f41446291d0e19a3ca648c82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMTI1NTMzMjAxNTA3NTBmNDE0NDYyOTFkMGUxOWEzY2E2NDhjODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-14T14:15:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-14T14:15:06Z"}, "message": "Auto merge of #43740 - michaelwoerister:local-id-in-typecktables, r=arielb1\n\nUse hir::ItemLocalId as keys in TypeckTables.\n\nThis PR makes `TypeckTables` use `ItemLocalId` instead of `NodeId` as key. This is needed for incremental compilation -- for stable hashing and for being able to persist and reload these tables. The PR implements the most important part of https://github.com/rust-lang/rust/issues/40303.\n\nSome notes on the implementation:\n* The PR adds the `HirId` to HIR nodes where needed (`Expr`, `Local`, `Block`, `Pat`) which obviates the need to store a `NodeId -> HirId` mapping in crate metadata. Thanks @eddyb for the suggestion! In the future the `HirId` should completely replace the `NodeId` in HIR nodes.\n* Before something is read or stored in one of the various `TypeckTables` subtables, the entry's key is validated via the new `TypeckTables::validate_hir_id()` method. This makes sure that we are not mixing information from different items in a single table.\n\nThat last part could be made a bit nicer by either (a) new-typing the table-key and making `validate_hir_id()` the only way to convert a `HirId` to the new-typed key, or (b) just encapsulate sub-table access a little better. This PR, however, contents itself with not making things significantly worse.\n\nAlso, there's quite a bit of switching around between `NodeId`, `HirId`, and `DefIndex`. These conversions are cheap except for `HirId -> NodeId`, so if the valued reviewer finds such an instance in a performance critical place, please let me know.\n\nIdeally we convert more and more code from `NodeId` to `HirId` in the future so that there are no more `NodeId`s after HIR lowering anywhere. Then the amount of switching should be minimal again.\n\nr? @eddyb, maybe?", "tree": {"sha": "890c8aa7c7b51c7025be0efd6f6fb7c1673b0605", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/890c8aa7c7b51c7025be0efd6f6fb7c1673b0605"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d12553320150750f41446291d0e19a3ca648c82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d12553320150750f41446291d0e19a3ca648c82", "html_url": "https://github.com/rust-lang/rust/commit/0d12553320150750f41446291d0e19a3ca648c82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d12553320150750f41446291d0e19a3ca648c82/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d49b730157c83ac3b1502a0127f199607b06a174", "url": "https://api.github.com/repos/rust-lang/rust/commits/d49b730157c83ac3b1502a0127f199607b06a174", "html_url": "https://github.com/rust-lang/rust/commit/d49b730157c83ac3b1502a0127f199607b06a174"}, {"sha": "3b92b97bfb98456cf2c1c0b87237a6eac8857e42", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b92b97bfb98456cf2c1c0b87237a6eac8857e42", "html_url": "https://github.com/rust-lang/rust/commit/3b92b97bfb98456cf2c1c0b87237a6eac8857e42"}], "stats": {"total": 1766, "additions": 1222, "deletions": 544}, "files": [{"sha": "010c7f6171aef3b49f11263f0d8f5e107d635753", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 118, "deletions": 62, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -155,6 +155,11 @@ enum ParamMode {\n     Optional\n }\n \n+struct LoweredNodeId {\n+    node_id: NodeId,\n+    hir_id: hir::HirId,\n+}\n+\n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         /// Full-crate AST visitor that inserts into a fresh\n@@ -278,11 +283,14 @@ impl<'a> LoweringContext<'a> {\n     fn lower_node_id_generic<F>(&mut self,\n                                 ast_node_id: NodeId,\n                                 alloc_hir_id: F)\n-                                -> NodeId\n+                                -> LoweredNodeId\n         where F: FnOnce(&mut Self) -> hir::HirId\n     {\n         if ast_node_id == DUMMY_NODE_ID {\n-            return ast_node_id;\n+            return LoweredNodeId {\n+                node_id: DUMMY_NODE_ID,\n+                hir_id: hir::DUMMY_HIR_ID,\n+            }\n         }\n \n         let min_size = ast_node_id.as_usize() + 1;\n@@ -291,12 +299,22 @@ impl<'a> LoweringContext<'a> {\n             self.node_id_to_hir_id.resize(min_size, hir::DUMMY_HIR_ID);\n         }\n \n-        if self.node_id_to_hir_id[ast_node_id] == hir::DUMMY_HIR_ID {\n+        let existing_hir_id = self.node_id_to_hir_id[ast_node_id];\n+\n+        if existing_hir_id == hir::DUMMY_HIR_ID {\n             // Generate a new HirId\n-            self.node_id_to_hir_id[ast_node_id] = alloc_hir_id(self);\n+            let hir_id = alloc_hir_id(self);\n+            self.node_id_to_hir_id[ast_node_id] = hir_id;\n+            LoweredNodeId {\n+                node_id: ast_node_id,\n+                hir_id,\n+            }\n+        } else {\n+            LoweredNodeId {\n+                node_id: ast_node_id,\n+                hir_id: existing_hir_id,\n+            }\n         }\n-\n-        ast_node_id\n     }\n \n     fn with_hir_id_owner<F>(&mut self, owner: NodeId, f: F)\n@@ -323,7 +341,7 @@ impl<'a> LoweringContext<'a> {\n     /// actually used in the HIR, as that would trigger an assertion in the\n     /// HirIdValidator later on, which makes sure that all NodeIds got mapped\n     /// properly. Calling the method twice with the same NodeId is fine though.\n-    fn lower_node_id(&mut self, ast_node_id: NodeId) -> NodeId {\n+    fn lower_node_id(&mut self, ast_node_id: NodeId) -> LoweredNodeId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n             let &mut (def_index, ref mut local_id_counter) = this.current_hir_id_owner\n                                                                  .last_mut()\n@@ -340,7 +358,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_node_id_with_owner(&mut self,\n                                 ast_node_id: NodeId,\n                                 owner: NodeId)\n-                                -> NodeId {\n+                                -> LoweredNodeId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n             let local_id_counter = this.item_local_id_counters\n                                        .get_mut(&owner)\n@@ -375,7 +393,7 @@ impl<'a> LoweringContext<'a> {\n         id\n     }\n \n-    fn next_id(&mut self) -> NodeId {\n+    fn next_id(&mut self) -> LoweredNodeId {\n         self.lower_node_id(self.sess.next_node_id())\n     }\n \n@@ -518,7 +536,7 @@ impl<'a> LoweringContext<'a> {\n         match destination {\n             Some((id, label_ident)) => {\n                 let target = if let Def::Label(loop_id) = self.expect_full_def(id) {\n-                    hir::LoopIdResult::Ok(self.lower_node_id(loop_id))\n+                    hir::LoopIdResult::Ok(self.lower_node_id(loop_id).node_id)\n                 } else {\n                     hir::LoopIdResult::Err(hir::LoopIdError::UnresolvedLabel)\n                 };\n@@ -535,7 +553,7 @@ impl<'a> LoweringContext<'a> {\n                 hir::Destination {\n                     ident: None,\n                     target_id: hir::ScopeTarget::Loop(\n-                        loop_id.map(|id| Ok(self.lower_node_id(id)))\n+                        loop_id.map(|id| Ok(self.lower_node_id(id).node_id))\n                                .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n                                .into())\n                 }\n@@ -558,7 +576,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_ty_binding(&mut self, b: &TypeBinding) -> hir::TypeBinding {\n         hir::TypeBinding {\n-            id: self.lower_node_id(b.id),\n+            id: self.lower_node_id(b.id).node_id,\n             name: self.lower_ident(b.ident),\n             ty: self.lower_ty(&b.ty),\n             span: b.span,\n@@ -595,7 +613,7 @@ impl<'a> LoweringContext<'a> {\n                 return self.lower_ty(ty);\n             }\n             TyKind::Path(ref qself, ref path) => {\n-                let id = self.lower_node_id(t.id);\n+                let id = self.lower_node_id(t.id).node_id;\n                 let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit);\n                 return self.ty_path(id, t.span, qpath);\n             }\n@@ -646,7 +664,7 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         P(hir::Ty {\n-            id: self.lower_node_id(t.id),\n+            id: self.lower_node_id(t.id).node_id,\n             node: kind,\n             span: t.span,\n         })\n@@ -759,7 +777,7 @@ impl<'a> LoweringContext<'a> {\n             // Otherwise, the base path is an implicit `Self` type path,\n             // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n-            let new_id = self.next_id();\n+            let new_id = self.next_id().node_id;\n             self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path))\n         };\n \n@@ -783,7 +801,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             // Wrap the associated extension in another type node.\n-            let new_id = self.next_id();\n+            let new_id = self.next_id().node_id;\n             ty = self.ty_path(new_id, p.span, qpath);\n         }\n \n@@ -887,8 +905,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_local(&mut self, l: &Local) -> P<hir::Local> {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(l.id);\n         P(hir::Local {\n-            id: self.lower_node_id(l.id),\n+            id: node_id,\n+            hir_id,\n             ty: l.ty.as_ref().map(|t| self.lower_ty(t)),\n             pat: self.lower_pat(&l.pat),\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n@@ -906,8 +926,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(arg.id);\n         hir::Arg {\n-            id: self.lower_node_id(arg.id),\n+            id: node_id,\n+            hir_id,\n             pat: self.lower_pat(&arg.pat),\n         }\n     }\n@@ -970,7 +992,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::TyParam {\n-            id: self.lower_node_id(tp.id),\n+            id: self.lower_node_id(tp.id).node_id,\n             name,\n             bounds,\n             default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n@@ -988,7 +1010,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         hir::Lifetime {\n-            id: self.lower_node_id(l.id),\n+            id: self.lower_node_id(l.id).node_id,\n             name: self.lower_ident(l.ident),\n             span: l.span,\n         }\n@@ -1060,7 +1082,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause {\n         hir::WhereClause {\n-            id: self.lower_node_id(wc.id),\n+            id: self.lower_node_id(wc.id).node_id,\n             predicates: wc.predicates\n                           .iter()\n                           .map(|predicate| self.lower_where_predicate(predicate))\n@@ -1099,7 +1121,7 @@ impl<'a> LoweringContext<'a> {\n                                                           ref rhs_ty,\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    id: self.lower_node_id(id),\n+                    id: self.lower_node_id(id).node_id,\n                     lhs_ty: self.lower_ty(lhs_ty),\n                     rhs_ty: self.lower_ty(rhs_ty),\n                     span,\n@@ -1115,16 +1137,16 @@ impl<'a> LoweringContext<'a> {\n                                                .enumerate()\n                                                .map(|f| self.lower_struct_field(f))\n                                                .collect(),\n-                                         self.lower_node_id(id))\n+                                         self.lower_node_id(id).node_id)\n             }\n             VariantData::Tuple(ref fields, id) => {\n                 hir::VariantData::Tuple(fields.iter()\n                                               .enumerate()\n                                               .map(|f| self.lower_struct_field(f))\n                                               .collect(),\n-                                        self.lower_node_id(id))\n+                                        self.lower_node_id(id).node_id)\n             }\n-            VariantData::Unit(id) => hir::VariantData::Unit(self.lower_node_id(id)),\n+            VariantData::Unit(id) => hir::VariantData::Unit(self.lower_node_id(id).node_id),\n         }\n     }\n \n@@ -1135,7 +1157,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         hir::TraitRef {\n             path,\n-            ref_id: self.lower_node_id(p.ref_id),\n+            ref_id: self.lower_node_id(p.ref_id).node_id,\n         }\n     }\n \n@@ -1150,7 +1172,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n         hir::StructField {\n             span: f.span,\n-            id: self.lower_node_id(f.id),\n+            id: self.lower_node_id(f.id).node_id,\n             name: self.lower_ident(match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried) positional field hygiene\n@@ -1199,8 +1221,11 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(b.id);\n+\n         P(hir::Block {\n-            id: self.lower_node_id(b.id),\n+            id: node_id,\n+            hir_id,\n             stmts: stmts.into(),\n             expr,\n             rules: self.lower_block_check_mode(&b.rules),\n@@ -1250,7 +1275,7 @@ impl<'a> LoweringContext<'a> {\n                                         hir::Visibility::Restricted {\n                                             path: path.clone(),\n                                             // We are allocating a new NodeId here\n-                                            id: this.next_id(),\n+                                            id: this.next_id().node_id,\n                                         }\n                                     }\n                                 };\n@@ -1388,7 +1413,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         self.with_parent_def(i.id, |this| {\n             hir::TraitItem {\n-                id: this.lower_node_id(i.id),\n+                id: this.lower_node_id(i.id).node_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n@@ -1449,7 +1474,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n         self.with_parent_def(i.id, |this| {\n             hir::ImplItem {\n-                id: this.lower_node_id(i.id),\n+                id: this.lower_node_id(i.id).node_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 vis: this.lower_visibility(&i.vis, None),\n@@ -1541,7 +1566,7 @@ impl<'a> LoweringContext<'a> {\n         });\n \n         Some(hir::Item {\n-            id: self.lower_node_id(i.id),\n+            id: self.lower_node_id(i.id).node_id,\n             name,\n             attrs,\n             node,\n@@ -1553,7 +1578,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {\n         self.with_parent_def(i.id, |this| {\n             hir::ForeignItem {\n-                id: this.lower_node_id(i.id),\n+                id: this.lower_node_id(i.id).node_id,\n                 name: i.ident.name,\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n@@ -1631,8 +1656,11 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n+\n         P(hir::Pat {\n-            id: self.lower_node_id(p.id),\n+            id: node_id,\n+            hir_id,\n             node: match p.node {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n@@ -1814,7 +1842,7 @@ impl<'a> LoweringContext<'a> {\n                     let call_move_val_init =\n                         hir::StmtSemi(\n                             make_call(self, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n-                            self.next_id());\n+                            self.next_id().node_id);\n                     let call_move_val_init = respan(e.span, call_move_val_init);\n \n                     let place = self.expr_ident(e.span, place_ident, place_binding);\n@@ -1884,11 +1912,15 @@ impl<'a> LoweringContext<'a> {\n                             // wrap the if-let expr in a block\n                             let span = els.span;\n                             let els = P(self.lower_expr(els));\n-                            let id = self.next_id();\n+                            let LoweredNodeId {\n+                                node_id,\n+                                hir_id,\n+                            } = self.next_id();\n                             let blk = P(hir::Block {\n                                 stmts: hir_vec![],\n                                 expr: Some(els),\n-                                id,\n+                                id: node_id,\n+                                hir_id,\n                                 rules: hir::DefaultBlock,\n                                 span,\n                                 targeted_by_break: false,\n@@ -1987,8 +2019,11 @@ impl<'a> LoweringContext<'a> {\n                 let struct_path = self.std_path(unstable_span, &struct_path, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n+                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+\n                 return hir::Expr {\n-                    id: self.lower_node_id(e.id),\n+                    id: node_id,\n+                    hir_id,\n                     node: if is_unit {\n                         hir::ExprPath(struct_path)\n                     } else {\n@@ -2235,7 +2270,7 @@ impl<'a> LoweringContext<'a> {\n                                                hir::MatchSource::ForLoopDesugar),\n                                 ThinVec::new()))\n                 };\n-                let match_stmt = respan(e.span, hir::StmtExpr(match_expr, self.next_id()));\n+                let match_stmt = respan(e.span, hir::StmtExpr(match_expr, self.next_id().node_id));\n \n                 let next_expr = P(self.expr_ident(e.span, next_ident, next_pat.id));\n \n@@ -2255,7 +2290,7 @@ impl<'a> LoweringContext<'a> {\n                 let body_block = self.with_loop_scope(e.id,\n                                                         |this| this.lower_block(body, false));\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                let body_stmt = respan(e.span, hir::StmtExpr(body_expr, self.next_id()));\n+                let body_stmt = respan(e.span, hir::StmtExpr(body_expr, self.next_id().node_id));\n \n                 let loop_block = P(self.block_all(e.span,\n                                                   hir_vec![next_let,\n@@ -2267,8 +2302,10 @@ impl<'a> LoweringContext<'a> {\n                 // `[opt_ident]: loop { ... }`\n                 let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n                                               hir::LoopSource::ForLoop);\n+                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n                 let loop_expr = P(hir::Expr {\n-                    id: self.lower_node_id(e.id),\n+                    id: node_id,\n+                    hir_id,\n                     node: loop_expr,\n                     span: e.span,\n                     attrs: ThinVec::new(),\n@@ -2407,8 +2444,11 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+\n         hir::Expr {\n-            id: self.lower_node_id(e.id),\n+            id: node_id,\n+            hir_id,\n             node: kind,\n             span: e.span,\n             attrs: e.attrs.clone(),\n@@ -2421,7 +2461,7 @@ impl<'a> LoweringContext<'a> {\n                 node: hir::StmtDecl(P(Spanned {\n                     node: hir::DeclLocal(self.lower_local(l)),\n                     span: s.span,\n-                }), self.lower_node_id(s.id)),\n+                }), self.lower_node_id(s.id).node_id),\n                 span: s.span,\n             },\n             StmtKind::Item(ref it) => {\n@@ -2432,22 +2472,22 @@ impl<'a> LoweringContext<'a> {\n                         node: hir::DeclItem(item_id),\n                         span: s.span,\n                     }), id.take()\n-                          .map(|id| self.lower_node_id(id))\n-                          .unwrap_or_else(|| self.next_id())),\n+                          .map(|id| self.lower_node_id(id).node_id)\n+                          .unwrap_or_else(|| self.next_id().node_id)),\n                     span: s.span,\n                 }).collect();\n             }\n             StmtKind::Expr(ref e) => {\n                 Spanned {\n                     node: hir::StmtExpr(P(self.lower_expr(e)),\n-                                          self.lower_node_id(s.id)),\n+                                          self.lower_node_id(s.id).node_id),\n                     span: s.span,\n                 }\n             }\n             StmtKind::Semi(ref e) => {\n                 Spanned {\n                     node: hir::StmtSemi(P(self.lower_expr(e)),\n-                                          self.lower_node_id(s.id)),\n+                                          self.lower_node_id(s.id).node_id),\n                     span: s.span,\n                 }\n             }\n@@ -2478,9 +2518,9 @@ impl<'a> LoweringContext<'a> {\n                 hir::Visibility::Restricted {\n                     path: P(self.lower_path(id, path, ParamMode::Explicit, true)),\n                     id: if let Some(owner) = explicit_owner {\n-                        self.lower_node_id_with_owner(id, owner)\n+                        self.lower_node_id_with_owner(id, owner).node_id\n                     } else {\n-                        self.lower_node_id(id)\n+                        self.lower_node_id(id).node_id\n                     }\n                 }\n             }\n@@ -2622,8 +2662,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n         hir::Expr {\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             node,\n             span,\n             attrs,\n@@ -2636,17 +2678,20 @@ impl<'a> LoweringContext<'a> {\n                     pat: P<hir::Pat>,\n                     source: hir::LocalSource)\n                     -> hir::Stmt {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n         let local = P(hir::Local {\n             pat,\n             ty: None,\n             init: ex,\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             span: sp,\n             attrs: ThinVec::new(),\n             source,\n         });\n         let decl = respan(sp, hir::DeclLocal(local));\n-        respan(sp, hir::StmtDecl(P(decl), self.next_id()))\n+        respan(sp, hir::StmtDecl(P(decl), self.next_id().node_id))\n     }\n \n     fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n@@ -2666,10 +2711,13 @@ impl<'a> LoweringContext<'a> {\n \n     fn block_all(&mut self, span: Span, stmts: hir::HirVec<hir::Stmt>, expr: Option<P<hir::Expr>>)\n                  -> hir::Block {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n         hir::Block {\n             stmts,\n             expr,\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             rules: hir::DefaultBlock,\n             span,\n             targeted_by_break: false,\n@@ -2713,18 +2761,22 @@ impl<'a> LoweringContext<'a> {\n \n     fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingAnnotation)\n                               -> P<hir::Pat> {\n-        let id = self.next_id();\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n         let parent_def = self.parent_def.unwrap();\n         let def_id = {\n             let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name);\n-            let def_index = defs\n-                .create_def_with_parent(parent_def, id, def_path_data, REGULAR_SPACE, Mark::root());\n+            let def_index = defs.create_def_with_parent(parent_def,\n+                                                        node_id,\n+                                                        def_path_data,\n+                                                        REGULAR_SPACE,\n+                                                        Mark::root());\n             DefId::local(def_index)\n         };\n \n         P(hir::Pat {\n-            id,\n+            id: node_id,\n+            hir_id,\n             node: hir::PatKind::Binding(bm,\n                                         def_id,\n                                         Spanned {\n@@ -2741,8 +2793,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat(&mut self, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n         P(hir::Pat {\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             node: pat,\n             span,\n         })\n@@ -2771,11 +2825,13 @@ impl<'a> LoweringContext<'a> {\n                          rule: hir::BlockCheckMode,\n                          attrs: ThinVec<Attribute>)\n                          -> hir::Expr {\n-        let id = self.next_id();\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n         let block = P(hir::Block {\n             rules: rule,\n             span,\n-            id,\n+            id: node_id,\n+            hir_id,\n             stmts,\n             expr: Some(expr),\n             targeted_by_break: false,\n@@ -2800,7 +2856,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n-                    id = self.next_id();\n+                    id = self.next_id().node_id;\n \n                     hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n                 } else {\n@@ -2814,7 +2870,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn elided_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         hir::Lifetime {\n-            id: self.next_id(),\n+            id: self.next_id().node_id,\n             span,\n             name: keywords::Invalid.name()\n         }"}, {"sha": "b371366bc5d5589b5de54be67b052c7583dc7f2a", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -434,18 +434,22 @@ impl Definitions {\n         DefPath::make(LOCAL_CRATE, index, |p| self.def_key(p))\n     }\n \n+    #[inline]\n     pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n         self.node_to_def_index.get(&node).cloned()\n     }\n \n+    #[inline]\n     pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<DefId> {\n         self.opt_def_index(node).map(DefId::local)\n     }\n \n+    #[inline]\n     pub fn local_def_id(&self, node: ast::NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap()\n     }\n \n+    #[inline]\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n             let space_index = def_id.index.address_space().index();\n@@ -461,10 +465,27 @@ impl Definitions {\n         }\n     }\n \n+    #[inline]\n     pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n         self.node_to_hir_id[node_id]\n     }\n \n+    pub fn find_node_for_hir_id(&self, hir_id: hir::HirId) -> ast::NodeId {\n+        self.node_to_hir_id\n+            .iter()\n+            .position(|x| *x == hir_id)\n+            .map(|idx| ast::NodeId::new(idx))\n+            .unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn def_index_to_hir_id(&self, def_index: DefIndex) -> hir::HirId {\n+        let space_index = def_index.address_space().index();\n+        let array_index = def_index.as_array_index();\n+        let node_id = self.def_index_to_node[space_index][array_index];\n+        self.node_to_hir_id[node_id]\n+    }\n+\n     /// Add a definition with a parent definition.\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,"}, {"sha": "ed4e28cc9ebf2ddcf7502e3a63ab3c6cd5473e5e", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -357,6 +357,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    #[inline]\n     pub fn definitions(&self) -> &Definitions {\n         &self.definitions\n     }\n@@ -377,21 +378,39 @@ impl<'hir> Map<'hir> {\n         self.definitions.def_path(def_id.index)\n     }\n \n+    #[inline]\n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| {\n             bug!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n                  node, self.find_entry(node))\n         })\n     }\n \n+    #[inline]\n     pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n         self.definitions.opt_local_def_id(node)\n     }\n \n+    #[inline]\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n+    #[inline]\n+    pub fn node_to_hir_id(&self, node_id: NodeId) -> HirId {\n+        self.definitions.node_to_hir_id(node_id)\n+    }\n+\n+    #[inline]\n+    pub fn def_index_to_hir_id(&self, def_index: DefIndex) -> HirId {\n+        self.definitions.def_index_to_hir_id(def_index)\n+    }\n+\n+    #[inline]\n+    pub fn def_index_to_node_id(&self, def_index: DefIndex) -> NodeId {\n+        self.definitions.as_local_node_id(DefId::local(def_index)).unwrap()\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.len()\n     }"}, {"sha": "3806b517f7782d43dff4201f59ec99da65b472af", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -129,9 +129,11 @@ pub const CRATE_HIR_ID: HirId = HirId {\n \n pub const DUMMY_HIR_ID: HirId = HirId {\n     owner: CRATE_DEF_INDEX,\n-    local_id: ItemLocalId(!0)\n+    local_id: DUMMY_ITEM_LOCAL_ID,\n };\n \n+pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId(!0);\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -547,6 +549,7 @@ pub struct Block {\n     /// without a semicolon, if any\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n     pub span: Span,\n@@ -560,6 +563,7 @@ pub struct Block {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n+    pub hir_id: HirId,\n     pub node: PatKind,\n     pub span: Span,\n }\n@@ -897,6 +901,7 @@ pub struct Local {\n     /// Initializer expression to set the value, if any\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n     pub source: LocalSource,\n@@ -986,6 +991,7 @@ pub struct Expr {\n     pub span: Span,\n     pub node: Expr_,\n     pub attrs: ThinVec<Attribute>,\n+    pub hir_id: HirId,\n }\n \n impl fmt::Debug for Expr {\n@@ -1423,6 +1429,7 @@ pub struct InlineAsm {\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n }\n \n /// Represents the header (not the body) of a function declaration"}, {"sha": "218483232d673f66f362f9a565a1808f677a9681", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -14,7 +14,7 @@ use hir::map::DefPathHash;\n use ich::{self, CachingCodemapView};\n use session::config::DebugInfoLevel::NoDebugInfo;\n use ty;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{NodeMap, ItemLocalMap};\n \n use std::hash as std_hash;\n use std::collections::{HashMap, HashSet, BTreeMap};\n@@ -358,6 +358,18 @@ pub fn hash_stable_nodemap<'a, 'tcx, 'gcx, V, W>(\n     });\n }\n \n+pub fn hash_stable_itemlocalmap<'a, 'tcx, 'gcx, V, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &ItemLocalMap<V>)\n+    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          W: StableHasherResult,\n+{\n+    hash_stable_hashmap(hcx, hasher, map, |_, local_id| {\n+        *local_id\n+    });\n+}\n+\n \n pub fn hash_stable_btreemap<'a, 'tcx, 'gcx, K, V, SK, F, W>(\n     hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,"}, {"sha": "4c70816c0b83300e1337cc23c95f3fc437261dcf", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -359,6 +359,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::B\n             ref stmts,\n             ref expr,\n             id,\n+            hir_id: _,\n             rules,\n             span,\n             targeted_by_break,\n@@ -423,6 +424,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::P\n \n         let hir::Pat {\n             id,\n+            hir_id: _,\n             ref node,\n             ref span\n         } = *self;\n@@ -504,6 +506,7 @@ impl_stable_hash_for!(struct hir::Local {\n     ty,\n     init,\n     id,\n+    hir_id,\n     span,\n     attrs,\n     source\n@@ -551,6 +554,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::E\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n                 id,\n+                hir_id: _,\n                 ref span,\n                 ref node,\n                 ref attrs\n@@ -1021,7 +1025,8 @@ impl_stable_hash_for!(enum hir::Stmt_ {\n \n impl_stable_hash_for!(struct hir::Arg {\n     pat,\n-    id\n+    id,\n+    hir_id\n });\n \n impl_stable_hash_for!(struct hir::Body {"}, {"sha": "45b2a4a1e9667a076e3ece26a1097b902887e086", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 59, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -11,7 +11,7 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::ty in no particular order.\n \n-use ich::{self, StableHashingContext, NodeIdHashingMode};\n+use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::hash as std_hash;\n@@ -611,64 +611,6 @@ impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n     ty\n });\n \n-\n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-for ty::TypeckTables<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::TypeckTables {\n-            ref type_dependent_defs,\n-            ref node_types,\n-            ref node_substs,\n-            ref adjustments,\n-            ref pat_binding_modes,\n-            ref upvar_capture_map,\n-            ref closure_tys,\n-            ref closure_kinds,\n-            ref liberated_fn_sigs,\n-            ref fru_field_types,\n-\n-            ref cast_kinds,\n-\n-            ref used_trait_imports,\n-            tainted_by_errors,\n-            ref free_region_map,\n-        } = *self;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            ich::hash_stable_nodemap(hcx, hasher, type_dependent_defs);\n-            ich::hash_stable_nodemap(hcx, hasher, node_types);\n-            ich::hash_stable_nodemap(hcx, hasher, node_substs);\n-            ich::hash_stable_nodemap(hcx, hasher, adjustments);\n-            ich::hash_stable_nodemap(hcx, hasher, pat_binding_modes);\n-            ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n-                let ty::UpvarId {\n-                    var_id,\n-                    closure_expr_id\n-                } = *up_var_id;\n-\n-                let var_def_id = hcx.tcx().hir.local_def_id(var_id);\n-                let closure_def_id = hcx.tcx().hir.local_def_id(closure_expr_id);\n-                (hcx.def_path_hash(var_def_id), hcx.def_path_hash(closure_def_id))\n-            });\n-\n-            ich::hash_stable_nodemap(hcx, hasher, closure_tys);\n-            ich::hash_stable_nodemap(hcx, hasher, closure_kinds);\n-            ich::hash_stable_nodemap(hcx, hasher, liberated_fn_sigs);\n-            ich::hash_stable_nodemap(hcx, hasher, fru_field_types);\n-            ich::hash_stable_nodemap(hcx, hasher, cast_kinds);\n-\n-            ich::hash_stable_hashset(hcx, hasher, used_trait_imports, |hcx, def_id| {\n-                hcx.def_path_hash(*def_id)\n-            });\n-\n-            tainted_by_errors.hash_stable(hcx, hasher);\n-            free_region_map.hash_stable(hcx, hasher);\n-        })\n-    }\n-}\n-\n impl_stable_hash_for!(enum ty::fast_reject::SimplifiedType {\n     BoolSimplifiedType,\n     CharSimplifiedType,"}, {"sha": "dcf84be0eeb3ad192fd6c0b0cc6256fb0bc14c44", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -14,7 +14,7 @@ pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n pub use self::hcx::{StableHashingContext, NodeIdHashingMode, hash_stable_hashmap,\n                     hash_stable_hashset, hash_stable_nodemap,\n-                    hash_stable_btreemap};\n+                    hash_stable_btreemap, hash_stable_itemlocalmap};\n mod fingerprint;\n mod caching_codemap_view;\n mod hcx;"}, {"sha": "b5390da7e852d184158109fae5afb6e16c733529", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -913,7 +913,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\",\n-                        self.tcx.local_var_name_str(upvar_id.var_id).to_string())\n+                        self.tcx.local_var_name_str_def_index(upvar_id.var_id))\n             }\n         };\n "}, {"sha": "22d9a9e313b77b1f7fa256a05f0bf65d5da6ff88", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::{self, Local, Pat, Body};\n+use hir::{self, Local, Pat, Body, HirId};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use infer::InferCtxt;\n use infer::type_variable::TypeVariableOrigin;\n use ty::{self, Ty, TyInfer, TyVar};\n-\n-use syntax::ast::NodeId;\n use syntax_pos::Span;\n \n struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -26,7 +24,7 @@ struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn node_matches_type(&mut self, node_id: NodeId) -> bool {\n+    fn node_matches_type(&mut self, node_id: HirId) -> bool {\n         let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n             tables.borrow().node_id_to_type_opt(node_id)\n         });\n@@ -56,15 +54,15 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_local(&mut self, local: &'gcx Local) {\n-        if self.found_local_pattern.is_none() && self.node_matches_type(local.id) {\n+        if self.found_local_pattern.is_none() && self.node_matches_type(local.hir_id) {\n             self.found_local_pattern = Some(&*local.pat);\n         }\n         intravisit::walk_local(self, local);\n     }\n \n     fn visit_body(&mut self, body: &'gcx Body) {\n         for argument in &body.arguments {\n-            if self.found_arg_pattern.is_none() && self.node_matches_type(argument.id) {\n+            if self.found_arg_pattern.is_none() && self.node_matches_type(argument.hir_id) {\n                 self.found_arg_pattern = Some(&*argument.pat);\n             }\n         }"}, {"sha": "87047d0df144cca40f03a3f0c83ba835545f8a8d", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -45,8 +45,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.span_note(span,\n                               &format!(\"...so that closure can access `{}`\",\n                                        self.tcx\n-                                           .local_var_name_str(upvar_id.var_id)\n-                                           .to_string()));\n+                                           .local_var_name_str_def_index(upvar_id.var_id)));\n             }\n             infer::InfStackClosure(span) => {\n                 err.span_note(span, \"...so that closure does not outlive its stack frame\");\n@@ -176,18 +175,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0313,\n                                                \"lifetime of borrowed pointer outlives lifetime \\\n                                                 of captured variable `{}`...\",\n-                                               self.tcx.local_var_name_str(upvar_id.var_id));\n+                                               self.tcx\n+                                                   .local_var_name_str_def_index(upvar_id.var_id));\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"...the borrowed pointer is valid for \",\n                                                  sub,\n                                                  \"...\");\n                 self.tcx\n-                    .note_and_explain_region(&mut err,\n-                                             &format!(\"...but `{}` is only valid for \",\n-                                                      self.tcx\n-                                                          .local_var_name_str(upvar_id.var_id)),\n-                                             sup,\n-                                             \"\");\n+                    .note_and_explain_region(\n+                      &mut err,\n+                      &format!(\"...but `{}` is only valid for \",\n+                               self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n+                      sup,\n+                      \"\");\n                 err\n             }\n             infer::InfStackClosure(span) => {"}, {"sha": "c8f78367420e64e0c00a52c98cb80bdb6999bbb1", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             .iter()\n                             .enumerate()\n                             .filter_map(|(index, arg)| {\n-                                let ty = tables.borrow().node_id_to_type(arg.id);\n+                                let ty = tables.borrow().node_id_to_type(arg.hir_id);\n                                 let mut found_anon_region = false;\n                                 let new_arg_ty = self.tcx\n                                     .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {"}, {"sha": "186eab724db3650bfc95b2b63c8d318282f091d0", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -358,8 +358,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n-    pub fn with_fresh_in_progress_tables(mut self) -> Self {\n-        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty()));\n+    pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n+        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty(Some(table_owner))));\n         self\n     }\n \n@@ -1331,9 +1331,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 return tables.borrow()\n-                             .closure_kinds\n-                             .get(&id)\n+                             .closure_kinds()\n+                             .get(hir_id)\n                              .cloned()\n                              .map(|(kind, _)| kind);\n             }\n@@ -1353,7 +1354,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn fn_sig(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n         if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                if let Some(&ty) = tables.borrow().closure_tys.get(&id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                if let Some(&ty) = tables.borrow().closure_tys().get(hir_id) {\n                     return ty;\n                 }\n             }"}, {"sha": "40d78d0138bb266cc9c60bacc06a7f4cd7c875c6", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -986,7 +986,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let mut cx = LateContext {\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n         access_levels,\n         lint_sess: LintSession::new(&tcx.sess.lint_store),"}, {"sha": "8a2b115e58d3d083b1abf9532f13120a803e20c2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -94,8 +94,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n-        self.check_def_id(self.tables.type_dependent_defs[&id].def_id());\n+    fn lookup_and_handle_method(&mut self, id: hir::HirId) {\n+        self.check_def_id(self.tables.type_dependent_defs()[id].def_id());\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n@@ -119,7 +119,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n-        let variant = match self.tables.node_id_to_type(lhs.id).sty {\n+        let variant = match self.tables.node_id_to_type(lhs.hir_id).sty {\n             ty::TyAdt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n@@ -235,11 +235,11 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tables.qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 self.handle_definition(def);\n             }\n             hir::ExprMethodCall(..) => {\n-                self.lookup_and_handle_method(expr.id);\n+                self.lookup_and_handle_method(expr.hir_id);\n             }\n             hir::ExprField(ref lhs, ref name) => {\n                 self.handle_field_access(&lhs, name.node);\n@@ -282,7 +282,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_field_pattern_match(pat, path.def, fields);\n             }\n             PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 self.handle_definition(def);\n             }\n             _ => ()\n@@ -425,7 +425,7 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         live_symbols: box FxHashSet(),\n         struct_has_extern_repr: false,\n         ignore_non_const_paths: false,"}, {"sha": "98934d607032840780a28ecf72729fecad7d020b", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n-                let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 let sig = self.tcx.fn_sig(def_id);\n                 debug!(\"effect: method call case, signature is {:?}\",\n                         sig);\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = EffectCheckVisitor {\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         body_id: hir::BodyId { node_id: ast::CRATE_NODE_ID },\n         unsafe_context: UnsafeContext::new(SafeContext),\n     };"}, {"sha": "324f9a6e9061f2da68e58178538516eb720383fd", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -296,7 +296,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"consume_body(body={:?})\", body);\n \n         for arg in &body.arguments {\n-            let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.id));\n+            let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.hir_id));\n \n             let fn_body_scope_r = self.tcx().node_scope_region(body.value.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -537,7 +537,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n             ty::TyError => { }\n             _ => {\n-                let def_id = self.mc.tables.type_dependent_defs[&call.id].def_id();\n+                let def_id = self.mc.tables.type_dependent_defs()[call.hir_id].def_id();\n                 match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n                         let call_scope_r = self.tcx().node_scope_region(call.id);\n@@ -797,7 +797,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n             if let PatKind::Binding(..) = pat.node {\n-                let bm = *self.mc.tables.pat_binding_modes.get(&pat.id)\n+                let bm = *self.mc.tables.pat_binding_modes().get(pat.hir_id)\n                                                           .expect(\"missing binding mode\");\n                 match bm {\n                     ty::BindByReference(..) =>\n@@ -823,10 +823,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(_, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n-                let bm = *mc.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\");\n+                let bm = *mc.tables.pat_binding_modes().get(pat.hir_id)\n+                                                     .expect(\"missing binding mode\");\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(mc.node_ty(pat.id));\n+                let pat_ty = return_if_err!(mc.node_ty(pat.hir_id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n@@ -863,7 +864,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 PatKind::Struct(ref qpath, ..) => qpath,\n                 _ => return\n             };\n-            let def = mc.tables.qpath_def(qpath, pat.id);\n+            let def = mc.tables.qpath_def(qpath, pat.hir_id);\n             match def {\n                 Def::Variant(variant_did) |\n                 Def::VariantCtor(variant_did, ..) => {\n@@ -887,10 +888,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let def_id = freevar.def.def_id();\n-                let id_var = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-                let upvar_id = ty::UpvarId { var_id: id_var,\n-                                             closure_expr_id: closure_expr.id };\n+                let var_def_id = freevar.def.def_id();\n+                debug_assert!(var_def_id.is_local());\n+                let closure_def_id = self.tcx().hir.local_def_id(closure_expr.id);\n+                let upvar_id = ty::UpvarId {\n+                    var_id: var_def_id.index,\n+                    closure_expr_id: closure_def_id.index\n+                };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                    fn_decl_span,\n@@ -923,8 +927,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = self.tcx().hir.as_local_node_id(upvar_def.def_id()).unwrap();\n-        let var_ty = self.mc.node_ty(var_id)?;\n+        let var_node_id = self.tcx().hir.as_local_node_id(upvar_def.def_id()).unwrap();\n+        let var_hir_id = self.tcx().hir.node_to_hir_id(var_node_id);\n+        let var_ty = self.mc.node_ty(var_hir_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }"}, {"sha": "0a4e5094cde773b949a07f9ea8b4215b4e581a35", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -146,13 +146,13 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = if let hir::ExprPath(ref qpath) = expr.node {\n-            self.tables.qpath_def(qpath, expr.id)\n+            self.tables.qpath_def(qpath, expr.hir_id)\n         } else {\n             Def::Err\n         };\n         if let Def::Fn(did) = def {\n             if self.def_id_is_transmute(did) {\n-                let typ = self.tables.node_id_to_type(expr.id);\n+                let typ = self.tables.node_id_to_type(expr.hir_id);\n                 let sig = typ.fn_sig(self.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n                 let to = *sig.output().skip_binder();"}, {"sha": "8919d0afc1d7beb80bccd87a74cbb7f09df6020e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -70,7 +70,7 @@ pub use self::Note::*;\n use self::Aliasability::*;\n \n use middle::region::RegionMaps;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, DefIndex};\n use hir::map as hir_map;\n use infer::InferCtxt;\n use hir::def::{Def, CtorKind};\n@@ -190,7 +190,7 @@ pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n pub enum ImmutabilityBlame<'tcx> {\n     ImmLocal(ast::NodeId),\n-    ClosureEnv(ast::NodeId),\n+    ClosureEnv(DefIndex),\n     LocalDeref(ast::NodeId),\n     AdtFieldDeref(&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n }\n@@ -334,7 +334,9 @@ impl MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n             hir_map::NodeLocal(p) => match p.node {\n                 PatKind::Binding(..) => {\n-                    let bm = *tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+                    let bm = *tables.pat_binding_modes()\n+                                    .get(p.hir_id)\n+                                    .expect(\"missing binding mode\");\n                     if bm == ty::BindByValue(hir::MutMutable) {\n                         McDeclared\n                     } else {\n@@ -435,7 +437,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn resolve_type_vars_or_error(&self,\n-                                  id: ast::NodeId,\n+                                  id: hir::HirId,\n                                   ty: Option<Ty<'tcx>>)\n                                   -> McResult<Ty<'tcx>> {\n         match ty {\n@@ -451,33 +453,41 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // FIXME\n             None if self.is_tainted_by_errors() => Err(()),\n             None => {\n+                let id = self.tcx.hir.definitions().find_node_for_hir_id(id);\n                 bug!(\"no type for node {}: {} in mem_categorization\",\n                      id, self.tcx.hir.node_to_string(id));\n             }\n         }\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(id, self.tables.node_id_to_type_opt(id))\n+    pub fn node_ty(&self,\n+                   hir_id: hir::HirId)\n+                   -> McResult<Ty<'tcx>> {\n+        self.resolve_type_vars_or_error(hir_id,\n+                                        self.tables.node_id_to_type_opt(hir_id))\n     }\n \n     pub fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(expr.id, self.tables.expr_ty_opt(expr))\n+        self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_opt(expr))\n     }\n \n     pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(expr.id, self.tables.expr_ty_adjusted_opt(expr))\n+        self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_adjusted_opt(expr))\n     }\n \n     fn pat_ty(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n-        let base_ty = self.node_ty(pat.id)?;\n+        let base_ty = self.node_ty(pat.hir_id)?;\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n             PatKind::Binding(..) => {\n-                let bm = *self.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\");\n+                let bm = *self.tables\n+                              .pat_binding_modes()\n+                              .get(pat.hir_id)\n+                              .expect(\"missing binding mode\");\n+\n                 if let ty::BindByReference(_) = bm {\n                     // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                     // but what we want here is the type of the underlying value being borrowed.\n@@ -604,7 +614,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprPath(ref qpath) => {\n-            let def = self.tables.qpath_def(qpath, expr.id);\n+            let def = self.tables.qpath_def(qpath, expr.hir_id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -690,6 +700,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  fn_node_id: ast::NodeId)\n                  -> McResult<cmt<'tcx>>\n     {\n+        let fn_hir_id = self.tcx.hir.node_to_hir_id(fn_node_id);\n+\n         // An upvar can have up to 3 components. We translate first to a\n         // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n         // field from the environment.\n@@ -713,14 +725,20 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n \n-        let kind = match self.tables.closure_kinds.get(&fn_node_id) {\n+        let kind = match self.tables.closure_kinds().get(fn_hir_id) {\n             Some(&(kind, _)) => kind,\n             None => span_bug!(span, \"missing closure kind\")\n         };\n \n-        let upvar_id = ty::UpvarId { var_id,\n-                                     closure_expr_id: fn_node_id };\n-        let var_ty = self.node_ty(var_id)?;\n+        let closure_expr_def_index = self.tcx.hir.local_def_id(fn_node_id).index;\n+        let var_def_index = self.tcx.hir.local_def_id(var_id).index;\n+\n+        let upvar_id = ty::UpvarId {\n+            var_id: var_def_index,\n+            closure_expr_id: closure_expr_def_index\n+        };\n+        let var_hir_id = self.tcx.hir.node_to_hir_id(var_id);\n+        let var_ty = self.node_ty(var_hir_id)?;\n \n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx, self.tables, var_id);\n@@ -755,8 +773,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // If this is a by-ref capture, then the upvar we loaded is\n         // actually a reference, so we have to add an implicit deref\n         // for that.\n-        let upvar_id = ty::UpvarId { var_id,\n-                                     closure_expr_id: fn_node_id };\n         let upvar_capture = self.tables.upvar_capture(upvar_id);\n         let cmt_result = match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n@@ -794,7 +810,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: self.tcx.hir.local_def_id(upvar_id.closure_expr_id),\n+            scope: DefId::local(upvar_id.closure_expr_id),\n             bound_region: ty::BrEnv\n         }));\n \n@@ -1130,7 +1146,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         match pat.node {\n           PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-            let def = self.tables.qpath_def(qpath, pat.id);\n+            let def = self.tables.qpath_def(qpath, pat.hir_id);\n             let (cmt, expected_len) = match def {\n                 Def::Err => {\n                     debug!(\"access to unresolvable pattern {:?}\", pat);\n@@ -1167,7 +1183,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n           PatKind::Struct(ref qpath, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n-            let def = self.tables.qpath_def(qpath, pat.id);\n+            let def = self.tables.qpath_def(qpath, pat.hir_id);\n             let cmt = match def {\n                 Def::Err => {\n                     debug!(\"access to unresolvable pattern {:?}\", pat);"}, {"sha": "666f71cca06bb60e69eca0729b9321e516072062", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -107,10 +107,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = match expr.node {\n             hir::ExprPath(ref qpath) => {\n-                Some(self.tables.qpath_def(qpath, expr.id))\n+                Some(self.tables.qpath_def(qpath, expr.hir_id))\n             }\n             hir::ExprMethodCall(..) => {\n-                Some(self.tables.type_dependent_defs[&expr.id])\n+                Some(self.tables.type_dependent_defs()[expr.hir_id])\n             }\n             _ => None\n         };\n@@ -378,7 +378,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     });\n     let mut reachable_context = ReachableContext {\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         reachable_symbols: NodeSet(),\n         worklist: Vec::new(),\n         any_library,"}, {"sha": "c04d448716c5bf205419843eaa71f05ab9e175b7", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -682,7 +682,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // Additional context information explaining why the closure only implements\n                         // a particular trait.\n                         if let Some(tables) = self.in_progress_tables {\n-                            match tables.borrow().closure_kinds.get(&node_id) {\n+                            let tables = tables.borrow();\n+                            let closure_hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                            match tables.closure_kinds().get(closure_hir_id) {\n                                 Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) => {\n                                     err.span_note(span, &format!(\n                                         \"closure is `FnOnce` because it moves the \\"}, {"sha": "6e8a7ca35a8427d513ccb638ae5ab848cd42c218", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 355, "deletions": 37, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -14,12 +14,13 @@ use dep_graph::DepGraph;\n use errors::DiagnosticBuilder;\n use session::Session;\n use middle;\n-use hir::TraitMap;\n+use hir::{TraitMap};\n use hir::def::{Def, ExportMap};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n+use ich::{self, StableHashingContext, NodeIdHashingMode};\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime;\n@@ -42,15 +43,18 @@ use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n-use util::nodemap::{NodeMap, NodeSet, DefIdSet};\n+use util::nodemap::{NodeMap, NodeSet, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n \n use arena::{TypedArena, DroplessArena};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n+use std::collections::hash_map::{self, Entry};\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n@@ -207,54 +211,151 @@ pub struct CommonTypes<'tcx> {\n     pub re_erased: Region<'tcx>,\n }\n \n+pub struct LocalTableInContext<'a, V: 'a> {\n+    local_id_root: Option<DefId>,\n+    data: &'a ItemLocalMap<V>\n+}\n+\n+/// Validate that the given HirId (respectively its `local_id` part) can be\n+/// safely used as a key in the tables of a TypeckTable. For that to be\n+/// the case, the HirId must have the same `owner` as all the other IDs in\n+/// this table (signified by `local_id_root`). Otherwise the HirId\n+/// would be in a different frame of reference and using its `local_id`\n+/// would result in lookup errors, or worse, in silently wrong data being\n+/// stored/returned.\n+fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n+                                     hir_id: hir::HirId,\n+                                     mut_access: bool) {\n+    if cfg!(debug_assertions) {\n+        if let Some(local_id_root) = local_id_root {\n+            if hir_id.owner != local_id_root.index {\n+                ty::tls::with(|tcx| {\n+                    let node_id = tcx.hir\n+                                     .definitions()\n+                                     .find_node_for_hir_id(hir_id);\n+\n+                    bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n+                          TypeckTables with local_id_root {:?}\",\n+                          tcx.hir.node_to_string(node_id),\n+                          DefId::local(hir_id.owner),\n+                          local_id_root)\n+                });\n+            }\n+        } else {\n+            // We use \"Null Object\" TypeckTables in some of the analysis passes.\n+            // These are just expected to be empty and their `local_id_root` is\n+            // `None`. Therefore we cannot verify whether a given `HirId` would\n+            // be a valid key for the given table. Instead we make sure that\n+            // nobody tries to write to such a Null Object table.\n+            if mut_access {\n+                bug!(\"access to invalid TypeckTables\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, V> LocalTableInContext<'a, V> {\n+    pub fn contains_key(&self, id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.data.contains_key(&id.local_id)\n+    }\n+\n+    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.data.get(&id.local_id)\n+    }\n+\n+    pub fn iter(&self) -> hash_map::Iter<hir::ItemLocalId, V> {\n+        self.data.iter()\n+    }\n+}\n+\n+impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n+    type Output = V;\n+\n+    fn index(&self, key: hir::HirId) -> &V {\n+        self.get(key).expect(\"LocalTableInContext: key not found\")\n+    }\n+}\n+\n+pub struct LocalTableInContextMut<'a, V: 'a> {\n+    local_id_root: Option<DefId>,\n+    data: &'a mut ItemLocalMap<V>\n+}\n+\n+impl<'a, V> LocalTableInContextMut<'a, V> {\n+    pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        self.data.get_mut(&id.local_id)\n+    }\n+\n+    pub fn entry(&mut self, id: hir::HirId) -> Entry<hir::ItemLocalId, V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        self.data.entry(id.local_id)\n+    }\n+\n+    pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        self.data.insert(id.local_id, val)\n+    }\n+\n+    pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        self.data.remove(&id.local_id)\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TypeckTables<'tcx> {\n+    /// The HirId::owner all ItemLocalIds in this table are relative to.\n+    pub local_id_root: Option<DefId>,\n+\n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n-    pub type_dependent_defs: NodeMap<Def>,\n+    type_dependent_defs: ItemLocalMap<Def>,\n \n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n-    pub node_types: NodeMap<Ty<'tcx>>,\n+    node_types: ItemLocalMap<Ty<'tcx>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n     /// of this node.  This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n     /// other items.\n-    pub node_substs: NodeMap<&'tcx Substs<'tcx>>,\n+    node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n \n-    pub adjustments: NodeMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n+    adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n     // Stores the actual binding mode for all instances of hir::BindingAnnotation.\n-    pub pat_binding_modes: NodeMap<BindingMode>,\n+    pat_binding_modes: ItemLocalMap<BindingMode>,\n \n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n     /// Records the type of each closure.\n-    pub closure_tys: NodeMap<ty::PolyFnSig<'tcx>>,\n+    closure_tys: ItemLocalMap<ty::PolyFnSig<'tcx>>,\n \n     /// Records the kind of each closure and the span and name of the variable\n     /// that caused the closure to be this kind.\n-    pub closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n+    closure_kinds: ItemLocalMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n     /// (including late-bound regions) are replaced with free\n     /// equivalents. This table is not used in trans (since regions\n     /// are erased there) and hence is not serialized to metadata.\n-    pub liberated_fn_sigs: NodeMap<ty::FnSig<'tcx>>,\n+    liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n \n     /// For each FRU expression, record the normalized types of the fields\n     /// of the struct - this is needed because it is non-trivial to\n     /// normalize while preserving regions. This table is used only in\n     /// MIR construction and hence is not serialized to metadata.\n-    pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>,\n+    fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n \n     /// Maps a cast expression to its kind. This is keyed on the\n     /// *from* expression of the cast, not the cast itself.\n-    pub cast_kinds: NodeMap<ty::cast::CastKind>,\n+    cast_kinds: ItemLocalMap<ty::cast::CastKind>,\n \n     /// Set of trait imports actually used in the method resolution.\n     /// This is used for warning unused imports.\n@@ -271,61 +372,108 @@ pub struct TypeckTables<'tcx> {\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n-    pub fn empty() -> TypeckTables<'tcx> {\n+    pub fn empty(local_id_root: Option<DefId>) -> TypeckTables<'tcx> {\n         TypeckTables {\n-            type_dependent_defs: NodeMap(),\n-            node_types: FxHashMap(),\n-            node_substs: NodeMap(),\n-            adjustments: NodeMap(),\n-            pat_binding_modes: NodeMap(),\n+            local_id_root,\n+            type_dependent_defs: ItemLocalMap(),\n+            node_types: ItemLocalMap(),\n+            node_substs: ItemLocalMap(),\n+            adjustments: ItemLocalMap(),\n+            pat_binding_modes: ItemLocalMap(),\n             upvar_capture_map: FxHashMap(),\n-            closure_tys: NodeMap(),\n-            closure_kinds: NodeMap(),\n-            liberated_fn_sigs: NodeMap(),\n-            fru_field_types: NodeMap(),\n-            cast_kinds: NodeMap(),\n+            closure_tys: ItemLocalMap(),\n+            closure_kinds: ItemLocalMap(),\n+            liberated_fn_sigs: ItemLocalMap(),\n+            fru_field_types: ItemLocalMap(),\n+            cast_kinds: ItemLocalMap(),\n             used_trait_imports: DefIdSet(),\n             tainted_by_errors: false,\n             free_region_map: FreeRegionMap::new(),\n         }\n     }\n \n     /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n-    pub fn qpath_def(&self, qpath: &hir::QPath, id: NodeId) -> Def {\n+    pub fn qpath_def(&self, qpath: &hir::QPath, id: hir::HirId) -> Def {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.def,\n             hir::QPath::TypeRelative(..) => {\n-                self.type_dependent_defs.get(&id).cloned().unwrap_or(Def::Err)\n+                validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+                self.type_dependent_defs.get(&id.local_id).cloned().unwrap_or(Def::Err)\n             }\n         }\n     }\n \n-    pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n+    pub fn type_dependent_defs(&self) -> LocalTableInContext<Def> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.type_dependent_defs\n+        }\n+    }\n+\n+    pub fn type_dependent_defs_mut(&mut self) -> LocalTableInContextMut<Def> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.type_dependent_defs\n+        }\n+    }\n+\n+    pub fn node_types(&self) -> LocalTableInContext<Ty<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.node_types\n+        }\n+    }\n+\n+    pub fn node_types_mut(&mut self) -> LocalTableInContextMut<Ty<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.node_types\n+        }\n+    }\n+\n+    pub fn node_id_to_type(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n             Some(ty) => ty,\n             None => {\n                 bug!(\"node_id_to_type: no type for node `{}`\",\n-                     tls::with(|tcx| tcx.hir.node_to_string(id)))\n+                    tls::with(|tcx| {\n+                        let id = tcx.hir.definitions().find_node_for_hir_id(id);\n+                        tcx.hir.node_to_string(id)\n+                    }))\n             }\n         }\n     }\n \n-    pub fn node_id_to_type_opt(&self, id: NodeId) -> Option<Ty<'tcx>> {\n-        self.node_types.get(&id).cloned()\n+    pub fn node_id_to_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.node_types.get(&id.local_id).cloned()\n+    }\n+\n+    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<&'tcx Substs<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.node_substs\n+        }\n+    }\n+\n+    pub fn node_substs(&self, id: hir::HirId) -> &'tcx Substs<'tcx> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.node_substs.get(&id.local_id).cloned().unwrap_or(Substs::empty())\n     }\n \n-    pub fn node_substs(&self, id: NodeId) -> &'tcx Substs<'tcx> {\n-        self.node_substs.get(&id).cloned().unwrap_or(Substs::empty())\n+    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<&'tcx Substs<'tcx>> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.node_substs.get(&id.local_id).cloned()\n     }\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n     pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n-        self.node_id_to_type(pat.id)\n+        self.node_id_to_type(pat.hir_id)\n     }\n \n     pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n-        self.node_id_to_type_opt(pat.id)\n+        self.node_id_to_type_opt(pat.hir_id)\n     }\n \n     // Returns the type of an expression as a monotype.\n@@ -339,16 +487,32 @@ impl<'tcx> TypeckTables<'tcx> {\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n     pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n-        self.node_id_to_type(expr.id)\n+        self.node_id_to_type(expr.hir_id)\n     }\n \n     pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n-        self.node_id_to_type_opt(expr.id)\n+        self.node_id_to_type_opt(expr.hir_id)\n+    }\n+\n+    pub fn adjustments(&self) -> LocalTableInContext<Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.adjustments\n+        }\n+    }\n+\n+    pub fn adjustments_mut(&mut self)\n+                           -> LocalTableInContextMut<Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.adjustments\n+        }\n     }\n \n     pub fn expr_adjustments(&self, expr: &hir::Expr)\n                             -> &[ty::adjustment::Adjustment<'tcx>] {\n-        self.adjustments.get(&expr.id).map_or(&[], |a| &a[..])\n+        validate_hir_id_for_typeck_tables(self.local_id_root, expr.hir_id, false);\n+        self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n     /// Returns the type of `expr`, considering any `Adjustment`\n@@ -373,15 +537,169 @@ impl<'tcx> TypeckTables<'tcx> {\n             return false;\n         }\n \n-        match self.type_dependent_defs.get(&expr.id) {\n+        match self.type_dependent_defs().get(expr.hir_id) {\n             Some(&Def::Method(_)) => true,\n             _ => false\n         }\n     }\n \n+    pub fn pat_binding_modes(&self) -> LocalTableInContext<BindingMode> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.pat_binding_modes\n+        }\n+    }\n+\n+    pub fn pat_binding_modes_mut(&mut self)\n+                           -> LocalTableInContextMut<BindingMode> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.pat_binding_modes\n+        }\n+    }\n+\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n+\n+    pub fn closure_tys(&self) -> LocalTableInContext<ty::PolyFnSig<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.closure_tys\n+        }\n+    }\n+\n+    pub fn closure_tys_mut(&mut self)\n+                           -> LocalTableInContextMut<ty::PolyFnSig<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.closure_tys\n+        }\n+    }\n+\n+    pub fn closure_kinds(&self) -> LocalTableInContext<(ty::ClosureKind,\n+                                                        Option<(Span, ast::Name)>)> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.closure_kinds\n+        }\n+    }\n+\n+    pub fn closure_kinds_mut(&mut self)\n+            -> LocalTableInContextMut<(ty::ClosureKind, Option<(Span, ast::Name)>)> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.closure_kinds\n+        }\n+    }\n+\n+    pub fn liberated_fn_sigs(&self) -> LocalTableInContext<ty::FnSig<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.liberated_fn_sigs\n+        }\n+    }\n+\n+    pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<ty::FnSig<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.liberated_fn_sigs\n+        }\n+    }\n+\n+    pub fn fru_field_types(&self) -> LocalTableInContext<Vec<Ty<'tcx>>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.fru_field_types\n+        }\n+    }\n+\n+    pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<Vec<Ty<'tcx>>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.fru_field_types\n+        }\n+    }\n+\n+    pub fn cast_kinds(&self) -> LocalTableInContext<ty::cast::CastKind> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.cast_kinds\n+        }\n+    }\n+\n+    pub fn cast_kinds_mut(&mut self) -> LocalTableInContextMut<ty::cast::CastKind> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.cast_kinds\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TypeckTables<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::TypeckTables {\n+            local_id_root,\n+            ref type_dependent_defs,\n+            ref node_types,\n+            ref node_substs,\n+            ref adjustments,\n+            ref pat_binding_modes,\n+            ref upvar_capture_map,\n+            ref closure_tys,\n+            ref closure_kinds,\n+            ref liberated_fn_sigs,\n+            ref fru_field_types,\n+\n+            ref cast_kinds,\n+\n+            ref used_trait_imports,\n+            tainted_by_errors,\n+            ref free_region_map,\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            ich::hash_stable_itemlocalmap(hcx, hasher, type_dependent_defs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, node_types);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, node_substs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, adjustments);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, pat_binding_modes);\n+            ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n+                let ty::UpvarId {\n+                    var_id,\n+                    closure_expr_id\n+                } = *up_var_id;\n+\n+                let local_id_root =\n+                    local_id_root.expect(\"trying to hash invalid TypeckTables\");\n+\n+                let var_def_id = DefId {\n+                    krate: local_id_root.krate,\n+                    index: var_id,\n+                };\n+                let closure_def_id = DefId {\n+                    krate: local_id_root.krate,\n+                    index: closure_expr_id,\n+                };\n+                (hcx.def_path_hash(var_def_id), hcx.def_path_hash(closure_def_id))\n+            });\n+\n+            ich::hash_stable_itemlocalmap(hcx, hasher, closure_tys);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, closure_kinds);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, liberated_fn_sigs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, fru_field_types);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, cast_kinds);\n+\n+            ich::hash_stable_hashset(hcx, hasher, used_trait_imports, |hcx, def_id| {\n+                hcx.def_path_hash(*def_id)\n+            });\n+\n+            tainted_by_errors.hash_stable(hcx, hasher);\n+            free_region_map.hash_stable(hcx, hasher);\n+        })\n+    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {"}, {"sha": "af322fc72d8995b3cf7bb31865508ec0d2c0f3b4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -572,8 +572,8 @@ impl<T> Slice<T> {\n /// by the upvar) and the id of the closure expression.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n-    pub var_id: NodeId,\n-    pub closure_expr_id: NodeId,\n+    pub var_id: DefIndex,\n+    pub closure_expr_id: DefIndex,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n@@ -1983,6 +1983,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn local_var_name_str_def_index(self, def_index: DefIndex) -> InternedString {\n+        let node_id = self.hir.as_local_node_id(DefId::local(def_index)).unwrap();\n+        self.local_var_name_str(node_id)\n+    }\n+\n     pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n             hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {"}, {"sha": "c397371c5c7672021fcca82928b05eb20ad49199", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -13,19 +13,22 @@\n #![allow(non_snake_case)]\n \n use hir::def_id::DefId;\n+use hir::ItemLocalId;\n use syntax::ast;\n \n pub use rustc_data_structures::fx::FxHashMap;\n pub use rustc_data_structures::fx::FxHashSet;\n \n pub type NodeMap<T> = FxHashMap<ast::NodeId, T>;\n pub type DefIdMap<T> = FxHashMap<DefId, T>;\n+pub type ItemLocalMap<T> = FxHashMap<ItemLocalId, T>;\n \n pub type NodeSet = FxHashSet<ast::NodeId>;\n pub type DefIdSet = FxHashSet<DefId>;\n \n pub fn NodeMap<T>() -> NodeMap<T> { FxHashMap() }\n pub fn DefIdMap<T>() -> DefIdMap<T> { FxHashMap() }\n+pub fn ItemLocalMap<T>() -> ItemLocalMap<T> { FxHashMap() }\n pub fn NodeSet() -> NodeSet { FxHashSet() }\n pub fn DefIdSet() -> DefIdSet { FxHashSet() }\n "}, {"sha": "184fd75135e471425084c505ebbe1c26c8345553", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -864,9 +864,9 @@ impl<'tcx> fmt::Display for ty::TyS<'tcx> {\n \n impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarId({};`{}`;{})\",\n+        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n                self.var_id,\n-               ty::tls::with(|tcx| tcx.local_var_name_str(self.var_id)),\n+               ty::tls::with(|tcx| tcx.local_var_name_str_def_index(self.var_id)),\n                self.closure_expr_id)\n     }\n }"}, {"sha": "35af83c8ae23a2e46bae33a8e090692aca7a5344", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -155,7 +155,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n-        let ty = self.bccx.tables.node_id_to_type(id);\n+        let ty = self.bccx\n+                     .tables\n+                     .node_id_to_type(self.bccx.tcx.hir.node_to_hir_id(id));\n         gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }\n@@ -447,7 +449,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     }\n                     None\n                 }\n-                LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {\n+                LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n+                    let local_id = self.tcx().hir.def_index_to_node_id(var_id);\n                     self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n                     None\n                 }"}, {"sha": "bfd883be84876252e9671819c0980948d79dc78a", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -93,11 +93,11 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &Vec<Move\n             }\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            err.span_label(bccx.tcx.hir.span(upvar_id.var_id),\n+            let var_node_id = bccx.tcx.hir.def_index_to_node_id(upvar_id.var_id);\n+            err.span_label(bccx.tcx.hir.span(var_node_id),\n                            \"captured outer variable\");\n         }\n         err.emit();\n-\n     }\n }\n "}, {"sha": "412af05f5bdfa4cffe3517b04ad8203fb47d6e39", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -27,7 +27,7 @@ use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n@@ -323,8 +323,9 @@ pub enum LoanPathElem<'tcx> {\n     LpInterior(Option<DefId>, InteriorKind),\n }\n \n-pub fn closure_to_block(closure_id: ast::NodeId,\n-                        tcx: TyCtxt) -> ast::NodeId {\n+fn closure_to_block(closure_id: DefIndex,\n+                    tcx: TyCtxt) -> ast::NodeId {\n+    let closure_id = tcx.hir.def_index_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n             hir::ExprClosure(.., body_id, _) => {\n@@ -598,8 +599,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let need_note = match lp.ty.sty {\n                     ty::TypeVariants::TyClosure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n+                        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n                         if let Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) =\n-                            self.tables.closure_kinds.get(&node_id)\n+                            self.tables.closure_kinds().get(hir_id)\n                         {\n                             err.span_note(span, &format!(\n                                 \"closure cannot be invoked more than once because \\\n@@ -843,7 +845,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 } else {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n-                err.span_help(self.tcx.hir.span(id), help);\n+                let node_id = self.tcx.hir.def_index_to_node_id(id);\n+                err.span_help(self.tcx.hir.span(node_id), help);\n                 err\n             }\n             _ =>  {\n@@ -899,8 +902,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         };\n \n         match pat.node {\n-            hir::PatKind::Binding(..) =>\n-                *self.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\"),\n+            hir::PatKind::Binding(..) => {\n+                *self.tables\n+                     .pat_binding_modes()\n+                     .get(pat.hir_id)\n+                     .expect(\"missing binding mode\")\n+            }\n             _ => bug!(\"local is not a binding: {:?}\", pat)\n         }\n     }\n@@ -1174,7 +1181,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     _ => bug!()\n                 };\n                 if kind == ty::ClosureKind::Fn {\n-                    db.span_help(self.tcx.hir.span(upvar_id.closure_expr_id),\n+                    let closure_node_id =\n+                        self.tcx.hir.def_index_to_node_id(upvar_id.closure_expr_id);\n+                    db.span_help(self.tcx.hir.span(closure_node_id),\n                                  \"consider changing this closure to take \\\n                                   self by mutable reference\");\n                 }\n@@ -1207,7 +1216,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                       loan_path: &LoanPath<'tcx>,\n                                       out: &mut String) {\n         match loan_path.kind {\n-            LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |\n+            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) => {\n+                out.push_str(&self.tcx.local_var_name_str_def_index(id));\n+            }\n             LpVar(id) => {\n                 out.push_str(&self.tcx.local_var_name_str(id));\n             }\n@@ -1345,8 +1356,11 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n-                let s = ty::tls::with(|tcx| tcx.hir.node_to_string(var_id));\n-                write!(f, \"$({} captured by id={})\", s, closure_expr_id)\n+                let s = ty::tls::with(|tcx| {\n+                    let var_node_id = tcx.hir.def_index_to_node_id(var_id);\n+                    tcx.hir.node_to_string(var_node_id)\n+                });\n+                write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n@@ -1377,7 +1391,10 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n-                let s = ty::tls::with(|tcx| tcx.hir.node_to_user_string(var_id));\n+                let s = ty::tls::with(|tcx| {\n+                    let var_node_id = tcx.hir.def_index_to_node_id(var_id);\n+                    tcx.hir.node_to_string(var_node_id)\n+                });\n                 write!(f, \"$({} captured by closure)\", s)\n             }\n "}, {"sha": "ea7deef472425632798f9e6848752942e5d97050", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n-            let pat_ty = self.tables.node_id_to_type(scrut.id);\n+            let pat_ty = self.tables.node_id_to_type(scrut.hir_id);\n             let module = self.tcx.hir.get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 .flat_map(|arm| &arm.0)\n                 .map(|pat| vec![pat.0])\n                 .collect();\n-            let scrut_ty = self.tables.node_id_to_type(scrut.id);\n+            let scrut_ty = self.tables.node_id_to_type(scrut.hir_id);\n             check_exhaustive(cx, scrut_ty, scrut.span, &matrix);\n         })\n     }\n@@ -269,7 +269,11 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(_, _, name, None) = p.node {\n-            let bm = *cx.tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+            let bm = *cx.tables\n+                        .pat_binding_modes()\n+                        .get(p.hir_id)\n+                        .expect(\"missing binding mode\");\n+\n             if bm != ty::BindByValue(hir::MutImmutable) {\n                 // Nothing to check.\n                 return true;\n@@ -458,7 +462,11 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     let mut by_ref_span = None;\n     for pat in pats {\n         pat.each_binding(|_, id, span, _path| {\n-            let bm = *cx.tables.pat_binding_modes.get(&id).expect(\"missing binding mode\");\n+            let hir_id = cx.tcx.hir.node_to_hir_id(id);\n+            let bm = *cx.tables\n+                        .pat_binding_modes()\n+                        .get(hir_id)\n+                        .expect(\"missing binding mode\");\n             if let ty::BindByReference(..) = bm {\n                 by_ref_span = Some(span);\n             }\n@@ -491,10 +499,13 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(_, _, _, ref sub) = p.node {\n-                let bm = *cx.tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+                let bm = *cx.tables\n+                            .pat_binding_modes()\n+                            .get(p.hir_id)\n+                            .expect(\"missing binding mode\");\n                 match bm {\n                     ty::BindByValue(..) => {\n-                        let pat_ty = cx.tables.node_id_to_type(p.id);\n+                        let pat_ty = cx.tables.node_id_to_type(p.hir_id);\n                         if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }"}, {"sha": "20ca218571c790fd98eda7e2bf81670b94e3e2d7", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -275,8 +275,8 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n-        let substs = cx.tables.node_substs(e.id).subst(tcx, cx.substs);\n-          match cx.tables.qpath_def(qpath, e.id) {\n+        let substs = cx.tables.node_substs(e.hir_id).subst(tcx, cx.substs);\n+          match cx.tables.qpath_def(qpath, e.hir_id) {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                     match tcx.at(e.span).const_eval(cx.param_env.and((def_id, substs))) {"}, {"sha": "d151e817040a9a2733b628eca38798f2ec653fa6", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n \n     pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.tables.node_id_to_type(pat.id);\n+        let mut ty = self.tables.node_id_to_type(pat.hir_id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Path(ref qpath) => {\n-                return self.lower_path(qpath, pat.id, pat.id, pat.span);\n+                return self.lower_path(qpath, pat.hir_id, pat.id, pat.span);\n             }\n \n             PatKind::Ref(ref subpattern, _) |\n@@ -330,7 +330,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.tables.node_id_to_type(pat.id);\n+                let ty = self.tables.node_id_to_type(pat.hir_id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n@@ -355,7 +355,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                let ty = self.tables.node_id_to_type(pat.id);\n+                let ty = self.tables.node_id_to_type(pat.hir_id);\n                 match ty.sty {\n                     ty::TyTuple(ref tys, _) => {\n                         let subpatterns =\n@@ -376,13 +376,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Binding(_, def_id, ref ident, ref sub) => {\n                 let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.tables.node_id_to_type(pat.id);\n+                let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n                 };\n-                let bm = *self.tables.pat_binding_modes.get(&pat.id)\n-                                                       .expect(\"missing binding mode\");\n+                let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n+                                                         .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n                     ty::BindByValue(hir::MutMutable) =>\n                         (Mutability::Mut, BindingMode::ByValue),\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n@@ -436,7 +436,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n@@ -590,7 +590,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n     fn lower_path(&mut self,\n                   qpath: &hir::QPath,\n-                  id: ast::NodeId,\n+                  id: hir::HirId,\n                   pat_id: ast::NodeId,\n                   span: Span)\n                   -> Pattern<'tcx> {\n@@ -695,8 +695,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     hir::ExprPath(ref qpath) => qpath,\n                     _ => bug!()\n                 };\n-                let ty = self.tables.node_id_to_type(callee.id);\n-                let def = self.tables.qpath_def(qpath, callee.id);\n+                let ty = self.tables.node_id_to_type(callee.hir_id);\n+                let def = self.tables.qpath_def(qpath, callee.hir_id);\n                 match def {\n                     Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n                     _ => {\n@@ -712,7 +712,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             hir::ExprStruct(ref qpath, ref fields, None) => {\n-                let def = self.tables.qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n@@ -755,7 +755,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             hir::ExprPath(ref qpath) => {\n-                return self.lower_path(qpath, expr.id, pat_id, span);\n+                return self.lower_path(qpath, expr.hir_id, pat_id, span);\n             }\n \n             _ => self.lower_lit(expr)"}, {"sha": "bc9bfa4049723fccdce3fc7aef4277a455a8b1d9", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -196,6 +196,16 @@ impl<I: Idx, T: Clone> IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T: Ord> IndexVec<I, T> {\n+    #[inline]\n+    pub fn binary_search(&self, value: &T) -> Result<I, I> {\n+        match self.raw.binary_search(value) {\n+            Ok(i) => Ok(Idx::new(i)),\n+            Err(i) => Err(Idx::new(i)),\n+        }\n+    }\n+}\n+\n impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n     type Output = T;\n "}, {"sha": "84d3ab65b1c1f6eab9e44031ba670f51905d9256", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -233,7 +233,7 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  |tcx, _, _, _| {\n-                    let empty_tables = ty::TypeckTables::empty();\n+                    let empty_tables = ty::TypeckTables::empty(None);\n                     let annotation = TypedAnnotation {\n                         tcx: tcx,\n                         tables: Cell::new(&empty_tables)"}, {"sha": "3bfe2897de175866e03b8855204424a214d8affa", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        let ty = cx.tables.node_id_to_type(e.id);\n+        let ty = cx.tables.node_id_to_type(e.hir_id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -905,7 +905,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             match cx.tcx.hir.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                        cx.tables.qpath_def(qpath, callee.id)\n+                        cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n                         return false;\n                     };\n@@ -943,8 +943,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n             // Check for method calls and overloaded operators.\n             if cx.tables.is_method_call(expr) {\n-                let def_id = cx.tables.type_dependent_defs[&id].def_id();\n-                let substs = cx.tables.node_substs(id);\n+                let hir_id = cx.tcx.hir.definitions().node_to_hir_id(id);\n+                let def_id = cx.tables.type_dependent_defs()[hir_id].def_id();\n+                let substs = cx.tables.node_substs(hir_id);\n                 if method_call_refers_to_method(cx, method, def_id, substs, id) {\n                     return true;\n                 }\n@@ -954,13 +955,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             match expr.node {\n                 hir::ExprCall(ref callee, _) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                        cx.tables.qpath_def(qpath, callee.id)\n+                        cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n                         return false;\n                     };\n                     match def {\n                         Def::Method(def_id) => {\n-                            let substs = cx.tables.node_substs(callee.id);\n+                            let substs = cx.tables.node_substs(callee.hir_id);\n                             method_call_refers_to_method(cx, method, def_id, substs, id)\n                         }\n                         _ => false,\n@@ -1188,15 +1189,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n              expr: &hir::Expr)\n              -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             let def = if let hir::ExprPath(ref qpath) = expr.node {\n-                cx.tables.qpath_def(qpath, expr.id)\n+                cx.tables.qpath_def(qpath, expr.hir_id)\n             } else {\n                 return None;\n             };\n             if let Def::Fn(did) = def {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let sig = cx.tables.node_id_to_type(expr.id).fn_sig(cx.tcx);\n+                let sig = cx.tables.node_id_to_type(expr.hir_id).fn_sig(cx.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n                 let to = *sig.output().skip_binder();\n                 return Some((&from.sty, &to.sty));"}, {"sha": "cdf0996796085a82120754bfcc3e6844df1cacc6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n \n                 if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tables.node_id_to_type(l.id).sty {\n+                    let opt_ty_bits = match cx.tables.node_id_to_type(l.hir_id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None,\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n             }\n             hir::ExprLit(ref lit) => {\n-                match cx.tables.node_id_to_type(e.id).sty {\n+                match cx.tables.node_id_to_type(e.hir_id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match cx.tables.node_id_to_type(expr.id).sty {\n+            match cx.tables.node_id_to_type(expr.hir_id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.node {"}, {"sha": "195bd2acce0fe3ed1ee2ad7837f5eb2a5d23e836", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -45,7 +45,8 @@ impl UnusedMut {\n         let mut mutables = FxHashMap();\n         for p in pats {\n             p.each_binding(|_, id, span, path1| {\n-                let bm = match cx.tables.pat_binding_modes.get(&id) {\n+                let hir_id = cx.tcx.hir.node_to_hir_id(id);\n+                let bm = match cx.tables.pat_binding_modes().get(hir_id) {\n                     Some(&bm) => bm,\n                     None => span_bug!(span, \"missing binding mode\"),\n                 };\n@@ -162,12 +163,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         let maybe_def = match expr.node {\n             hir::ExprCall(ref callee, _) => {\n                 match callee.node {\n-                    hir::ExprPath(ref qpath) => Some(cx.tables.qpath_def(qpath, callee.id)),\n+                    hir::ExprPath(ref qpath) => Some(cx.tables.qpath_def(qpath, callee.hir_id)),\n                     _ => None\n                 }\n             },\n             hir::ExprMethodCall(..) => {\n-                cx.tables.type_dependent_defs.get(&expr.id).cloned()\n+                cx.tables.type_dependent_defs().get(expr.hir_id).cloned()\n             },\n             _ => { None }\n         };"}, {"sha": "14392ae70e4e34a9f847254c20dbfa7258c140df", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -90,7 +90,8 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n         } else if let MirSource::Fn(id) = src {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n+            let fn_hir_id = tcx.hir.node_to_hir_id(id);\n+            let fn_sig = cx.tables().liberated_fn_sigs()[fn_hir_id].clone();\n \n             let ty = tcx.type_of(tcx.hir.local_def_id(id));\n             let mut abi = fn_sig.abi;\n@@ -202,7 +203,8 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: hir::BodyId)\n                              -> Ty<'tcx> {\n-    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n+    let closure_expr_hir_id = tcx.hir.node_to_hir_id(closure_expr_id);\n+    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_hir_id);\n \n     let closure_def_id = tcx.hir.local_def_id(closure_expr_id);\n     let region = ty::ReFree(ty::FreeRegion {\n@@ -365,10 +367,12 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     // Gather the upvars of a closure, if any.\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n-            let var_id = tcx.hir.as_local_node_id(fv.def.def_id()).unwrap();\n+            let var_def_id = fv.def.def_id();\n+            let var_node_id = tcx.hir.as_local_node_id(var_def_id).unwrap();\n+            let closure_expr_id = tcx.hir.local_def_id(fn_id).index;\n             let capture = hir.tables().upvar_capture(ty::UpvarId {\n-                var_id: var_id,\n-                closure_expr_id: fn_id\n+                var_id: var_def_id.index,\n+                closure_expr_id,\n             });\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n@@ -378,7 +382,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 debug_name: keywords::Invalid.name(),\n                 by_ref: by_ref\n             };\n-            if let Some(hir::map::NodeLocal(pat)) = tcx.hir.find(var_id) {\n+            if let Some(hir::map::NodeLocal(pat)) = tcx.hir.find(var_node_id) {\n                 if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n                 }"}, {"sha": "fa54925c6e75e1d2330eabc6070d9858dd2f6b9d", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -95,7 +95,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n-    let block_ty = cx.tables().node_id_to_type(block.id);\n+    let block_ty = cx.tables().node_id_to_type(block.hir_id);\n     let temp_lifetime = cx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,"}, {"sha": "617c3c77bbb116f5693baaa88d10387ea7f345b6", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -217,7 +217,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     None\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tables().node_substs(fun.id);\n+                    let substs = cx.tables().node_substs(fun.hir_id);\n                     let field_refs = args.iter()\n                         .enumerate()\n                         .map(|(idx, e)| {\n@@ -236,7 +236,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 } else {\n                     ExprKind::Call {\n-                        ty: cx.tables().node_id_to_type(fun.id),\n+                        ty: cx.tables().node_id_to_type(fun.hir_id),\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                     }\n@@ -389,7 +389,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 base: base.as_ref().map(|base| {\n                                     FruInfo {\n                                         base: base.to_ref(),\n-                                        field_types: cx.tables().fru_field_types[&expr.id].clone(),\n+                                        field_types: cx.tables()\n+                                                       .fru_field_types()[expr.hir_id]\n+                                                       .clone(),\n                                     }\n                                 }),\n                             }\n@@ -450,7 +452,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprPath(ref qpath) => {\n-            let def = cx.tables().qpath_def(qpath, expr.id);\n+            let def = cx.tables().qpath_def(qpath, expr.hir_id);\n             convert_path_expr(cx, expr, def)\n         }\n \n@@ -548,7 +550,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprCast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n-            if let Some(&TyCastKind::CoercionCast) = cx.tables().cast_kinds.get(&source.id) {\n+            if let Some(&TyCastKind::CoercionCast) = cx.tables()\n+                                                       .cast_kinds()\n+                                                       .get(source.hir_id) {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n             } else {\n@@ -579,8 +583,8 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  -> Expr<'tcx> {\n     let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n     let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n-        (cx.tables().type_dependent_defs[&expr.id].def_id(),\n-         cx.tables().node_substs(expr.id))\n+        (cx.tables().type_dependent_defs()[expr.hir_id].def_id(),\n+         cx.tables().node_substs(expr.hir_id))\n     });\n     Expr {\n         temp_lifetime: temp_lifetime,\n@@ -618,7 +622,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tables().node_substs(expr.id);\n+    let substs = cx.tables().node_substs(expr.hir_id);\n     match def {\n         // A regular function, constructor function or a constant.\n         Def::Fn(def_id) |\n@@ -640,7 +644,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n-            match cx.tables().node_id_to_type(expr.id).sty {\n+            match cx.tables().node_id_to_type(expr.hir_id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n                 ty::TyAdt(adt_def, substs) => {\n@@ -676,16 +680,18 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::VarRef { id: node_id }\n         }\n \n-        Def::Upvar(def_id, index, closure_expr_id) => {\n-            let id_var = cx.tcx.hir.as_local_node_id(def_id).unwrap();\n+        Def::Upvar(var_def_id, index, closure_expr_id) => {\n+            let id_var = cx.tcx.hir.as_local_node_id(var_def_id).unwrap();\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n                    id_var,\n                    index,\n                    closure_expr_id);\n-            let var_ty = cx.tables().node_id_to_type(id_var);\n+            let var_ty = cx.tables()\n+                           .node_id_to_type(cx.tcx.hir.node_to_hir_id(id_var));\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tables().node_id_to_type(closure_expr_id);\n+            let closure_ty = cx.tables()\n+                               .node_id_to_type(cx.tcx.hir.node_to_hir_id(closure_expr_id));\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n@@ -758,8 +764,8 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n             // point we need an implicit deref\n             let upvar_id = ty::UpvarId {\n-                var_id: id_var,\n-                closure_expr_id: closure_expr_id,\n+                var_id: var_def_id.index,\n+                closure_expr_id: closure_def_id.index,\n             };\n             match cx.tables().upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => field_kind,\n@@ -870,14 +876,16 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    freevar: &hir::Freevar,\n                                    freevar_ty: Ty<'tcx>)\n                                    -> ExprRef<'tcx> {\n-    let id_var = cx.tcx.hir.as_local_node_id(freevar.def.def_id()).unwrap();\n+    let var_def_id = freevar.def.def_id();\n+    let var_node_id = cx.tcx.hir.as_local_node_id(var_def_id).unwrap();\n     let upvar_id = ty::UpvarId {\n-        var_id: id_var,\n-        closure_expr_id: closure_expr.id,\n+        var_id: var_def_id.index,\n+        closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).index,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.id);\n-    let var_ty = cx.tables().node_id_to_type(id_var);\n+    let var_ty = cx.tables()\n+                   .node_id_to_type(cx.tcx.hir.node_to_hir_id(var_node_id));\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n         ty: var_ty,"}, {"sha": "9185f73974cd72118c459390a0ddb7871b6bc0dd", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let outer = self.promotable;\n         self.promotable = true;\n \n-        let node_ty = self.tables.node_id_to_type(ex.id);\n+        let node_ty = self.tables.node_id_to_type(ex.hir_id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n@@ -297,7 +297,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             v.promotable = false;\n         }\n         hir::ExprUnary(op, ref inner) => {\n-            match v.tables.node_id_to_type(inner.id).sty {\n+            match v.tables.node_id_to_type(inner.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n@@ -307,7 +307,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprBinary(op, ref lhs, _) => {\n-            match v.tables.node_id_to_type(lhs.id).sty {\n+            match v.tables.node_id_to_type(lhs.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n                             op.node == hir::BiLe || op.node == hir::BiLt ||\n@@ -320,7 +320,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         }\n         hir::ExprCast(ref from, _) => {\n             debug!(\"Checking const cast(id={})\", from.id);\n-            match v.tables.cast_kinds.get(&from.id) {\n+            match v.tables.cast_kinds().get(from.hir_id) {\n                 None => span_bug!(e.span, \"no kind for cast\"),\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n                     v.promotable = false;\n@@ -329,7 +329,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprPath(ref qpath) => {\n-            let def = v.tables.qpath_def(qpath, e.id);\n+            let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n                 Def::Fn(..) | Def::Method(..) => {}\n@@ -365,7 +365,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n             let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                v.tables.qpath_def(qpath, callee.id)\n+                v.tables.qpath_def(qpath, callee.hir_id)\n             } else {\n                 Def::Err\n             };\n@@ -387,7 +387,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let def_id = v.tables.type_dependent_defs[&e.id].def_id();\n+            let def_id = v.tables.type_dependent_defs()[e.hir_id].def_id();\n             match v.tcx.associated_item(def_id).container {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(def_id, node_ty),\n                 ty::TraitContainer(_) => v.promotable = false\n@@ -471,7 +471,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir.krate().visit_all_item_likes(&mut CheckCrateVisitor {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         in_fn: false,\n         promotable: false,\n         mut_rvalue_borrows: NodeSet(),"}, {"sha": "983f478e07d620d3dec6f58837d7026e504c540c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 65, "deletions": 12, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -474,6 +474,7 @@ struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: ast::NodeId,\n+    empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n@@ -490,6 +491,22 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n+// Set the correct TypeckTables for the given `item_id` (or an empty table if\n+// there is no TypeckTables for the item).\n+fn update_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           item_id: ast::NodeId,\n+                           tables: &mut &'a ty::TypeckTables<'tcx>,\n+                           empty_tables: &'a ty::TypeckTables<'tcx>)\n+                           -> &'a ty::TypeckTables<'tcx> {\n+    let def_id = tcx.hir.local_def_id(item_id);\n+\n+    if tcx.has_typeck_tables(def_id) {\n+        replace(tables, tcx.typeck_tables_of(def_id))\n+    } else {\n+        replace(tables, empty_tables)\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n@@ -506,14 +523,28 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item = replace(&mut self.current_item, item.id);\n+        let orig_tables = update_tables(self.tcx, item.id, &mut self.tables, self.empty_tables);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n+        self.tables = orig_tables;\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_trait_item(self, ti);\n+        self.tables = orig_tables;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_impl_item(self, ii);\n+        self.tables = orig_tables;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprStruct(ref qpath, ref fields, ref base) => {\n-                let def = self.tables.qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 if let Some(ref base) = *base {\n@@ -540,7 +571,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         match pat.node {\n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n@@ -565,6 +596,7 @@ struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: DefId,\n     span: Span,\n+    empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n@@ -608,7 +640,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Take node ID of an expression or pattern and check its type for privacy.\n-    fn check_expr_pat_type(&mut self, id: ast::NodeId, span: Span) -> bool {\n+    fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n         if let Some(ty) = self.tables.node_id_to_type_opt(id) {\n             if ty.visit_with(self) {\n@@ -618,7 +650,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         if self.tables.node_substs(id).visit_with(self) {\n             return true;\n         }\n-        if let Some(adjustments) = self.tables.adjustments.get(&id) {\n+        if let Some(adjustments) = self.tables.adjustments().get(id) {\n             for adjustment in adjustments {\n                 if adjustment.target.visit_with(self) {\n                     return true;\n@@ -704,20 +736,20 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types of expressions\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if self.check_expr_pat_type(expr.id, expr.span) {\n+        if self.check_expr_pat_type(expr.hir_id, expr.span) {\n             // Do not check nested expressions if the error already happened.\n             return;\n         }\n         match expr.node {\n             hir::ExprAssign(.., ref rhs) | hir::ExprMatch(ref rhs, ..) => {\n                 // Do not report duplicate errors for `x = y` and `match x { ... }`.\n-                if self.check_expr_pat_type(rhs.id, rhs.span) {\n+                if self.check_expr_pat_type(rhs.hir_id, rhs.span) {\n                     return;\n                 }\n             }\n             hir::ExprMethodCall(_, span, _) => {\n                 // Method calls have to be checked specially.\n-                let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 self.span = span;\n                 if self.tcx.type_of(def_id).visit_with(self) {\n                     return;\n@@ -733,7 +765,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         // Inherent associated constants don't have self type in substs,\n         // we have to check it additionally.\n         if let hir::QPath::TypeRelative(..) = *qpath {\n-            if let Some(def) = self.tables.type_dependent_defs.get(&id).cloned() {\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            if let Some(def) = self.tables.type_dependent_defs().get(hir_id).cloned() {\n                 if let Some(assoc_item) = self.tcx.opt_associated_item(def.def_id()) {\n                     if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n                         if self.tcx.type_of(impl_def_id).visit_with(self) {\n@@ -749,7 +782,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types of patterns\n     fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n-        if self.check_expr_pat_type(pattern.id, pattern.span) {\n+        if self.check_expr_pat_type(pattern.hir_id, pattern.span) {\n             // Do not check nested patterns if the error already happened.\n             return;\n         }\n@@ -759,7 +792,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_local(&mut self, local: &'tcx hir::Local) {\n         if let Some(ref init) = local.init {\n-            if self.check_expr_pat_type(init.id, init.span) {\n+            if self.check_expr_pat_type(init.hir_id, init.span) {\n                 // Do not report duplicate errors for `let x = y`.\n                 return;\n             }\n@@ -771,6 +804,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // Check types in item interfaces\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item = self.current_item;\n+        let orig_tables = update_tables(self.tcx,\n+                                        item.id,\n+                                        &mut self.tables,\n+                                        self.empty_tables);\n \n         match item.node {\n             hir::ItemExternCrate(..) | hir::ItemMod(..) |\n@@ -830,8 +867,21 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n         self.current_item = self.tcx.hir.local_def_id(item.id);\n         intravisit::walk_item(self, item);\n+        self.tables = orig_tables;\n         self.current_item = orig_current_item;\n     }\n+\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_trait_item(self, ti);\n+        self.tables = orig_tables;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_impl_item(self, ii);\n+        self.tables = orig_tables;\n+    }\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n@@ -1606,22 +1656,25 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let krate = tcx.hir.krate();\n+    let empty_tables = ty::TypeckTables::empty(None);\n \n     // Check privacy of names not checked in previous compilation stages.\n     let mut visitor = NamePrivacyVisitor {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &empty_tables,\n         current_item: CRATE_NODE_ID,\n+        empty_tables: &empty_tables,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n \n     // Check privacy of explicitly written types and traits as well as\n     // inferred types of expressions and patterns.\n     let mut visitor = TypePrivacyVisitor {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &empty_tables,\n         current_item: DefId::local(CRATE_DEF_INDEX),\n         span: krate.span,\n+        empty_tables: &empty_tables,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n "}, {"sha": "f89d59b5a449263159c8602dd1a44beca2a0ad3d", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -345,7 +345,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, ..) in &collector.collected_paths {\n-                let typ = match self.save_ctxt.tables.node_types.get(&id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n@@ -499,12 +500,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                                     item: &'l ast::Item,\n                                     typ: &'l ast::Ty,\n                                     expr: &'l ast::Expr) {\n-        if let Some(var_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(var_data, DefData, item.span);\n-            self.dumper.dump_def(item.vis == ast::Visibility::Public, var_data);\n-        }\n-        self.visit_ty(&typ);\n-        self.visit_expr(expr);\n+        self.nest_tables(item.id, |v| {\n+            if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n+                down_cast_data!(var_data, DefData, item.span);\n+                v.dumper.dump_def(item.vis == ast::Visibility::Public, var_data);\n+            }\n+            v.visit_ty(&typ);\n+            v.visit_expr(expr);\n+        });\n     }\n \n     fn process_assoc_const(&mut self,\n@@ -893,7 +896,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         match p.node {\n             PatKind::Struct(ref _path, ref fields, _) => {\n                 // FIXME do something with _path?\n-                let adt = match self.save_ctxt.tables.node_id_to_type_opt(p.id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(p.id);\n+                let adt = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(ty) => ty.ty_adt_def().unwrap(),\n                     None => {\n                         visit::walk_pat(self, p);\n@@ -935,7 +939,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n             };\n-            let typ = match self.save_ctxt.tables.node_types.get(&id) {\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                 Some(typ) => {\n                     let typ = typ.to_string();\n                     if !value.is_empty() {\n@@ -1466,8 +1471,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n-                    let typ = self.save_ctxt.tables.node_types\n-                                  .get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n+                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    let typ = self.save_ctxt\n+                                  .tables\n+                                  .node_id_to_type_opt(hir_id)\n+                                  .map(|t| t.to_string())\n+                                  .unwrap_or(String::new());\n                     value.push_str(\": \");\n                     value.push_str(&typ);\n "}, {"sha": "c3d071d27d6ef76a7218968239b0002c793200c2", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -550,7 +550,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::MethodCall(..) => {\n-                let method_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                let expr_hir_id = self.tcx.hir.definitions().node_to_hir_id(expr.id);\n+                let method_id = self.tables.type_dependent_defs()[expr_hir_id].def_id();\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n@@ -586,7 +587,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Path(ref qpath), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Struct(ref qpath, ..), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::TupleStruct(ref qpath, ..), .. }) => {\n-                self.tables.qpath_def(qpath, id)\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                self.tables.qpath_def(qpath, hir_id)\n             }\n \n             Node::NodeLocal(&hir::Pat { node: hir::PatKind::Binding(_, def_id, ..), .. }) => {\n@@ -975,7 +977,7 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n \n     let save_ctxt = SaveContext {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         analysis: analysis,\n         span_utils: SpanUtils::new(&tcx.sess),\n         config: find_config(config),"}, {"sha": "b49b9377e8c56095370a006a19ba8cd5c4016fe1", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -118,8 +118,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // identical to what could be scraped from the HIR, but this will change with\n                 // default binding modes (#42640).\n                 let bm = ty::BindingMode::convert(ba);\n-                self.inh.tables.borrow_mut().pat_binding_modes.insert(pat.id, bm);\n-\n+                self.inh\n+                    .tables\n+                    .borrow_mut()\n+                    .pat_binding_modes_mut()\n+                    .insert(pat.hir_id, bm);\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n                     ty::BindByReference(mutbl) => {\n@@ -323,7 +326,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        self.write_ty(pat.id, ty);\n+        self.write_ty(pat.hir_id, ty);\n \n         // (*) In most of the cases above (literals and constants being\n         // the exception), we relate types using strict equality, evewn"}, {"sha": "460e2858b22ec091ea4272467e4bdc2cef4c1235", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 if let hir::ExprCall(ref expr, _) = call_expr.node {\n                     let def = if let hir::ExprPath(ref qpath) = expr.node {\n-                        self.tables.borrow().qpath_def(qpath, expr.id)\n+                        self.tables.borrow().qpath_def(qpath, expr.hir_id)\n                     } else {\n                         Def::Err\n                     };\n@@ -314,7 +314,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                            TupleArgumentsFlag::TupleArguments,\n                                                            expected);\n \n-        self.write_method_call(call_expr.id, method_callee);\n+        self.write_method_call(call_expr.hir_id, method_callee);\n         output_type\n     }\n }\n@@ -364,7 +364,8 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n                 adjustments.extend(autoref);\n                 fcx.apply_adjustments(self.callee_expr, adjustments);\n \n-                fcx.write_method_call(self.call_expr.id, method_callee);\n+                fcx.write_method_call(self.call_expr.hir_id,\n+                                      method_callee);\n             }\n             None => {\n                 span_bug!(self.call_expr.span,"}, {"sha": "b18b11f3d906992c2f4bfb09dc5c775672fd893b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -330,12 +330,13 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);\n             debug!(\" -> CoercionCast\");\n-            fcx.tables.borrow_mut().cast_kinds.insert(self.expr.id, CastKind::CoercionCast);\n+            fcx.tables.borrow_mut().cast_kinds_mut().insert(self.expr.hir_id,\n+                                                            CastKind::CoercionCast);\n         } else {\n             match self.do_check(fcx) {\n                 Ok(k) => {\n                     debug!(\" -> {:?}\", k);\n-                    fcx.tables.borrow_mut().cast_kinds.insert(self.expr.id, k);\n+                    fcx.tables.borrow_mut().cast_kinds_mut().insert(self.expr.hir_id, k);\n                 }\n                 Err(e) => self.report_cast_error(fcx, e),\n             };"}, {"sha": "61795a7e623d3f253f019c7ec70c857fc124083f", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -102,12 +102,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                sig,\n                opt_kind);\n \n-        self.tables.borrow_mut().closure_tys.insert(expr.id, sig);\n-        match opt_kind {\n-            Some(kind) => {\n-                self.tables.borrow_mut().closure_kinds.insert(expr.id, (kind, None));\n+        {\n+            let mut tables = self.tables.borrow_mut();\n+            tables.closure_tys_mut().insert(expr.hir_id, sig);\n+            match opt_kind {\n+                Some(kind) => {\n+                    tables.closure_kinds_mut().insert(expr.hir_id, (kind, None));\n+                }\n+                None => {}\n             }\n-            None => {}\n         }\n \n         closure_type"}, {"sha": "53f3d811fae4fb9d3ebba7d8f441197c40ca7e8e", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // First try to coerce the new expression to the type of the previous ones,\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n-        if !self.tables.borrow().adjustments.contains_key(&new.id) {\n+        if !self.tables.borrow().adjustments().contains_key(new.hir_id) {\n             let result = self.commit_if_ok(|_| coerce.coerce(new_ty, prev_ty));\n             match result {\n                 Ok(ok) => {\n@@ -866,7 +866,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Adjustment { kind: Adjust::Deref(_), .. },\n                     Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }\n                 ] => {\n-                    match self.node_ty(expr.id).sty {\n+                    match self.node_ty(expr.hir_id).sty {\n                         ty::TyRef(_, mt_orig) => {\n                             // Reborrow that we can safely ignore, because\n                             // the next adjustment can only be a Deref"}, {"sha": "355e6cdbbe074b2093cc3d4012bc0bee7b1938eb", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -445,11 +445,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n             // overloaded lvalue ops, and will be fixed by them in order to get\n             // the correct region.\n-            let mut source = self.node_ty(expr.id);\n+            let mut source = self.node_ty(expr.hir_id);\n             // Do not mutate adjustments in place, but rather take them,\n             // and replace them after mutating them, to avoid having the\n             // tables borrowed during (`deref_mut`) method resolution.\n-            let previous_adjustments = self.tables.borrow_mut().adjustments.remove(&expr.id);\n+            let previous_adjustments = self.tables\n+                                           .borrow_mut()\n+                                           .adjustments_mut()\n+                                           .remove(expr.hir_id);\n             if let Some(mut adjustments) = previous_adjustments {\n                 let pref = LvaluePreference::PreferMutLvalue;\n                 for adjustment in &mut adjustments {\n@@ -466,12 +469,12 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     }\n                     source = adjustment.target;\n                 }\n-                self.tables.borrow_mut().adjustments.insert(expr.id, adjustments);\n+                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n             }\n \n             match expr.node {\n                 hir::ExprIndex(ref base_expr, ref index_expr) => {\n-                    let index_expr_ty = self.node_ty(index_expr.id);\n+                    let index_expr_ty = self.node_ty(index_expr.hir_id);\n                     self.convert_lvalue_op_to_mutable(\n                         LvalueOp::Index, expr, base_expr, &[index_expr_ty]);\n                 }\n@@ -498,7 +501,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         }\n \n         let base_ty = self.tables.borrow().expr_adjustments(base_expr).last()\n-            .map_or_else(|| self.node_ty(expr.id), |adj| adj.target);\n+            .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n         let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n \n         // Need to deref because overloaded lvalue ops take self by-reference.\n@@ -513,7 +516,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")\n         };\n         debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n-        self.write_method_call(expr.id, method);\n+        self.write_method_call(expr.hir_id, method);\n \n         let (region, mutbl) = if let ty::TyRef(r, mt) = method.sig.inputs()[0].sty {\n             (r, mt.mutbl)\n@@ -523,8 +526,11 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Convert the autoref in the base expr to mutable with the correct\n         // region and mutability.\n-        let base_expr_ty = self.node_ty(base_expr.id);\n-        if let Some(adjustments) = self.tables.borrow_mut().adjustments.get_mut(&base_expr.id) {\n+        let base_expr_ty = self.node_ty(base_expr.hir_id);\n+        if let Some(adjustments) = self.tables\n+                                       .borrow_mut()\n+                                       .adjustments_mut()\n+                                       .get_mut(base_expr.hir_id) {\n             let mut source = base_expr_ty;\n             for adjustment in &mut adjustments[..] {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {"}, {"sha": "5de4a35bdc724ce687d616d294101c2bfca2d937", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -820,19 +820,20 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let closure_id = match step.self_ty.sty {\n                 ty::TyClosure(def_id, _) => {\n                     if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        id\n+                        self.tcx.hir.node_to_hir_id(id)\n                     } else {\n                         continue;\n                     }\n                 }\n                 _ => continue,\n             };\n \n-            let closure_kinds = &self.tables.borrow().closure_kinds;\n-            let closure_kind = match closure_kinds.get(&closure_id) {\n-                Some(&(k, _)) => k,\n-                None => {\n-                    return Err(MethodError::ClosureAmbiguity(trait_def_id));\n+            let closure_kind = {\n+                match self.tables.borrow().closure_kinds().get(closure_id) {\n+                    Some(&(k, _)) => k,\n+                    None => {\n+                        return Err(MethodError::ClosureAmbiguity(trait_def_id));\n+                    }\n                 }\n             };\n "}, {"sha": "1b56044710ba33d5a52c13c918609ae6bbf5648f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 67, "deletions": 37, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -572,8 +572,16 @@ pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+        let hir_id_root = if def_id.is_local() {\n+            let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+            let hir_id = tcx.hir.definitions().node_to_hir_id(node_id);\n+            DefId::local(hir_id.owner)\n+        } else {\n+            def_id\n+        };\n+\n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(),\n+            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(hir_id_root),\n             def_id,\n         }\n     }\n@@ -735,7 +743,8 @@ fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::ClosureKind {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    tcx.typeck_tables_of(def_id).closure_kinds[&node_id].0\n+    let hir_id = tcx.hir.node_to_hir_id(node_id);\n+    tcx.typeck_tables_of(def_id).closure_kinds()[hir_id].0\n }\n \n fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -840,7 +849,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n     let body = tcx.hir.body(body_id);\n \n-    Inherited::build(tcx, def_id).enter(|inh| {\n+    let tables = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n         let fcx = if let Some(decl) = fn_decl {\n             let fn_sig = tcx.fn_sig(def_id);\n@@ -887,7 +896,13 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         fcx.resolve_type_vars_in_body(body)\n-    })\n+    });\n+\n+    // Consistency check our TypeckTables instance can hold all ItemLocalIds\n+    // it will need to hold.\n+    assert_eq!(tables.local_id_root,\n+               Some(DefId::local(tcx.hir.definitions().node_to_hir_id(id).owner)));\n+    tables\n }\n \n fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n@@ -1010,10 +1025,11 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             fcx.require_type_is_sized(arg_ty, decl.output.span(), traits::MiscObligation);\n         }\n \n-        fcx.write_ty(arg.id, arg_ty);\n+        fcx.write_ty(arg.hir_id, arg_ty);\n     }\n \n-    inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n+    let fn_hir_id = fcx.tcx.hir.node_to_hir_id(fn_id);\n+    inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_hir_id, fn_sig);\n \n     fcx.check_return_expr(&body.value);\n \n@@ -1793,30 +1809,37 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-        debug!(\"write_ty({}, {:?}) in fcx {}\",\n-               node_id, self.resolve_type_vars_if_possible(&ty), self.tag());\n-        self.tables.borrow_mut().node_types.insert(node_id, ty);\n+    pub fn write_ty(&self, id: hir::HirId, ty: Ty<'tcx>) {\n+        debug!(\"write_ty({:?}, {:?}) in fcx {}\",\n+               id, self.resolve_type_vars_if_possible(&ty), self.tag());\n+        self.tables.borrow_mut().node_types_mut().insert(id, ty);\n \n         if ty.references_error() {\n             self.has_errors.set(true);\n             self.set_tainted_by_errors();\n         }\n     }\n \n-    pub fn write_method_call(&self, node_id: ast::NodeId, method: MethodCallee<'tcx>) {\n-        self.tables.borrow_mut().type_dependent_defs.insert(node_id, Def::Method(method.def_id));\n-        self.write_substs(node_id, method.substs);\n+    // The NodeId and the ItemLocalId must identify the same item. We just pass\n+    // both of them for consistency checking.\n+    pub fn write_method_call(&self,\n+                             hir_id: hir::HirId,\n+                             method: MethodCallee<'tcx>) {\n+        self.tables\n+            .borrow_mut()\n+            .type_dependent_defs_mut()\n+            .insert(hir_id, Def::Method(method.def_id));\n+        self.write_substs(hir_id, method.substs);\n     }\n \n-    pub fn write_substs(&self, node_id: ast::NodeId, substs: &'tcx Substs<'tcx>) {\n+    pub fn write_substs(&self, node_id: hir::HirId, substs: &'tcx Substs<'tcx>) {\n         if !substs.is_noop() {\n-            debug!(\"write_substs({}, {:?}) in fcx {}\",\n+            debug!(\"write_substs({:?}, {:?}) in fcx {}\",\n                    node_id,\n                    substs,\n                    self.tag());\n \n-            self.tables.borrow_mut().node_substs.insert(node_id, substs);\n+            self.tables.borrow_mut().node_substs_mut().insert(node_id, substs);\n         }\n     }\n \n@@ -1827,7 +1850,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        match self.tables.borrow_mut().adjustments.entry(expr.id) {\n+        match self.tables.borrow_mut().adjustments_mut().entry(expr.hir_id) {\n             Entry::Vacant(entry) => { entry.insert(adj); },\n             Entry::Occupied(mut entry) => {\n                 debug!(\" - composing on top of {:?}\", entry.get());\n@@ -1980,13 +2003,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        match self.tables.borrow().node_types.get(&id) {\n+    pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n+        match self.tables.borrow().node_types().get(id) {\n             Some(&t) => t,\n             None if self.err_count_since_creation() != 0 => self.tcx.types.err,\n             None => {\n+                let node_id = self.tcx.hir.definitions().find_node_for_hir_id(id);\n                 bug!(\"no type for node {}: {} in fcx {}\",\n-                     id, self.tcx.hir.node_to_string(id),\n+                     node_id, self.tcx.hir.node_to_string(node_id),\n                      self.tag());\n             }\n         }\n@@ -2254,7 +2278,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 self.apply_adjustments(base_expr, adjustments);\n \n-                self.write_method_call(expr.id, method);\n+                self.write_method_call(expr.hir_id, method);\n                 (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n             });\n             if result.is_some() {\n@@ -2643,7 +2667,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // While we don't allow *arbitrary* coercions here, we *do* allow\n         // coercions from ! to `expected`.\n         if ty.is_never() {\n-            assert!(!self.tables.borrow().adjustments.contains_key(&expr.id),\n+            assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n@@ -2794,7 +2818,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                               expr,\n                                               rcvr) {\n             Ok(method) => {\n-                self.write_method_call(expr.id, method);\n+                self.write_method_call(expr.hir_id, method);\n                 Ok(method)\n             }\n             Err(error) => {\n@@ -3368,7 +3392,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let fru_field_types = adt.struct_variant().fields.iter().map(|f| {\n                         self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n                     }).collect();\n-                    self.tables.borrow_mut().fru_field_types.insert(expr.id, fru_field_types);\n+\n+                    self.tables\n+                        .borrow_mut()\n+                        .fru_field_types_mut()\n+                        .insert(expr.hir_id, fru_field_types);\n                 }\n                 _ => {\n                     span_err!(self.tcx.sess, base_expr.span, E0436,\n@@ -3426,7 +3454,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Record the type, which applies it effects.\n         // We need to do this after the warning above, so that\n         // we don't warn for the diverging expression itself.\n-        self.write_ty(expr.id, ty);\n+        self.write_ty(expr.hir_id, ty);\n \n         // Combine the diverging and has_error flags.\n         self.diverges.set(self.diverges.get() | old_diverges);\n@@ -3499,7 +3527,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }]);\n                             }\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n-                            self.write_method_call(expr.id, method);\n+                            self.write_method_call(expr.hir_id, method);\n                         } else {\n                             type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n                                                \"type `{}` cannot be dereferenced\",\n@@ -3577,7 +3605,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n               // We always require that the type provided as the value for\n               // a type parameter outlives the moment of instantiation.\n-              let substs = self.tables.borrow().node_substs(expr.id);\n+              let substs = self.tables.borrow().node_substs(expr.hir_id);\n               self.add_wf_bounds(substs, expr);\n \n               ty\n@@ -4000,7 +4028,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    ty, def, segment);\n \n                 // Write back the new resolution.\n-                self.tables.borrow_mut().type_dependent_defs.insert(node_id, def);\n+                let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n \n                 (def, ty)\n             }\n@@ -4041,7 +4070,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Write back the new resolution.\n-        self.tables.borrow_mut().type_dependent_defs.insert(node_id, def);\n+        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n         (def, Some(ty), slice::ref_slice(&**item_segment))\n     }\n \n@@ -4073,19 +4103,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n         let t = self.local_ty(local.span, local.id);\n-        self.write_ty(local.id, t);\n+        self.write_ty(local.hir_id, t);\n \n         if let Some(ref init) = local.init {\n             let init_ty = self.check_decl_initializer(local, &init);\n             if init_ty.references_error() {\n-                self.write_ty(local.id, init_ty);\n+                self.write_ty(local.hir_id, init_ty);\n             }\n         }\n \n         self.check_pat(&local.pat, t);\n-        let pat_ty = self.node_ty(local.pat.id);\n+        let pat_ty = self.node_ty(local.pat.hir_id);\n         if pat_ty.references_error() {\n-            self.write_ty(local.id, pat_ty);\n+            self.write_ty(local.hir_id, pat_ty);\n         }\n     }\n \n@@ -4237,7 +4267,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty = self.tcx.types.err\n         }\n \n-        self.write_ty(blk.id, ty);\n+        self.write_ty(blk.hir_id, ty);\n \n         *self.ps.borrow_mut() = prev;\n         ty\n@@ -4415,7 +4445,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::StmtSemi(ref e, _) => e,\n             _ => return,\n         };\n-        let last_expr_ty = self.node_ty(last_expr.id);\n+        let last_expr_ty = self.node_ty(last_expr.hir_id);\n         if self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err() {\n             return;\n         }\n@@ -4558,7 +4588,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let nid = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let ty = self.local_ty(span, nid);\n                 let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(node_id, ty);\n+                self.write_ty(self.tcx.hir.node_to_hir_id(node_id), ty);\n                 return ty;\n             }\n             _ => {}\n@@ -4690,7 +4720,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        self.write_substs(node_id, substs);\n+        self.write_substs(self.tcx.hir.node_to_hir_id(node_id), substs);\n         ty_substituted\n     }\n "}, {"sha": "a4e1fdaf39e29a4a306d23dcba5a198c8b918e24", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -210,11 +210,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // some cases applied on the RHS, on top of which we need\n                         // to autoref, which is not allowed by apply_adjustments.\n                         // self.apply_adjustments(rhs_expr, vec![autoref]);\n-                        self.tables.borrow_mut().adjustments.entry(rhs_expr.id)\n-                            .or_insert(vec![]).push(autoref);\n+                        self.tables\n+                            .borrow_mut()\n+                            .adjustments_mut()\n+                            .entry(rhs_expr.hir_id)\n+                            .or_insert(vec![])\n+                            .push(autoref);\n                     }\n                 }\n-                self.write_method_call(expr.id, method);\n+                self.write_method_call(expr.hir_id, method);\n \n                 method.sig.output()\n             }\n@@ -340,7 +344,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(op.is_by_value());\n         match self.lookup_op_method(operand_ty, &[], Op::Unary(op, ex.span)) {\n             Ok(method) => {\n-                self.write_method_call(ex.id, method);\n+                self.write_method_call(ex.hir_id, method);\n                 method.sig.output()\n             }\n             Err(()) => {"}, {"sha": "b187075a36d27f7840b6f8a3706308bccda61e9e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n+    fn resolve_node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n         let t = self.node_ty(id);\n         self.resolve_type(t)\n     }\n@@ -309,8 +309,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n-            let fn_sig_map = &self.tables.borrow().liberated_fn_sigs;\n-            match fn_sig_map.get(&id) {\n+            let fn_hir_id = self.tcx.hir.node_to_hir_id(id);\n+            match self.tables.borrow().liberated_fn_sigs().get(fn_hir_id) {\n                 Some(f) => f.clone(),\n                 None => {\n                     bug!(\"No fn-sig entry for id={}\", id);\n@@ -338,8 +338,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n                body.id(), call_site_scope);\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n+        let body_hir_id = self.tcx.hir.node_to_hir_id(body_id.node_id);\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n-                                       body_id.node_id,\n+                                       body_hir_id,\n                                        call_site_region);\n \n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n@@ -613,9 +614,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-            self.type_of_node_must_outlive(origin, id, var_region);\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            self.type_of_node_must_outlive(origin, hir_id, var_region);\n \n-            let typ = self.resolve_node_type(id);\n+            let typ = self.resolve_node_type(hir_id);\n             let _ = dropck::check_safety_of_destructor_if_necessary(\n                 self, typ, span, var_scope);\n         })\n@@ -664,7 +666,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // No matter what, the type of each expression must outlive the\n         // scope of that expression. This also guarantees basic WF.\n-        let expr_ty = self.resolve_node_type(expr.id);\n+        let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n         let expr_region = self.tcx.node_scope_region(expr.id);\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n@@ -686,7 +688,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                     infer::ParameterOrigin::OverloadedOperator\n             };\n \n-            let substs = self.tables.borrow().node_substs(expr.id);\n+            let substs = self.tables.borrow().node_substs(expr.hir_id);\n             self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             // Arguments (sub-expressions) are checked via `constrain_call`, below.\n         }\n@@ -709,7 +711,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                expr, self.repeating_scope);\n         match expr.node {\n             hir::ExprPath(_) => {\n-                let substs = self.tables.borrow().node_substs(expr.id);\n+                let substs = self.tables.borrow().node_substs(expr.hir_id);\n                 let origin = infer::ParameterOrigin::Path;\n                 self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             }\n@@ -718,7 +720,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 if is_method_call {\n                     self.constrain_call(expr, Some(&callee), args.iter().map(|e| &*e));\n                 } else {\n-                    self.constrain_callee(callee.id, expr, &callee);\n+                    self.constrain_callee(&callee);\n                     self.constrain_call(expr, None, args.iter().map(|e| &*e));\n                 }\n \n@@ -812,7 +814,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 // adjustments*.\n                 //\n                 // FIXME(#6268) nested method calls requires that this rule change\n-                let ty0 = self.resolve_node_type(expr.id);\n+                let ty0 = self.resolve_node_type(expr.hir_id);\n                 self.type_must_outlive(infer::AddrOf(expr.span), ty0, expr_region);\n                 intravisit::walk_expr(self, expr);\n             }\n@@ -849,7 +851,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                        ret_expr.id, call_site_scope);\n                 let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n                 self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),\n-                                               ret_expr.id,\n+                                               ret_expr.hir_id,\n                                                call_site_region);\n                 intravisit::walk_expr(self, expr);\n             }\n@@ -870,8 +872,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                cast_expr,\n                source_expr);\n \n-        let source_ty = self.resolve_node_type(source_expr.id);\n-        let target_ty = self.resolve_node_type(cast_expr.id);\n+        let source_ty = self.resolve_node_type(source_expr.hir_id);\n+        let target_ty = self.resolve_node_type(cast_expr.hir_id);\n \n         self.walk_cast(cast_expr, source_ty, target_ty);\n     }\n@@ -915,11 +917,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.set_repeating_scope(repeating_scope);\n     }\n \n-    fn constrain_callee(&mut self,\n-                        callee_id: ast::NodeId,\n-                        _call_expr: &hir::Expr,\n-                        _callee_expr: &hir::Expr) {\n-        let callee_ty = self.resolve_node_type(callee_id);\n+    fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n+        let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n         match callee_ty.sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => { }\n             _ => {\n@@ -962,14 +961,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // ensure that any regions appearing in the argument type are\n             // valid for at least the lifetime of the function:\n             self.type_of_node_must_outlive(infer::CallArg(arg_expr.span),\n-                                           arg_expr.id, callee_region);\n+                                           arg_expr.hir_id,\n+                                           callee_region);\n         }\n \n         // as loop above, but for receiver\n         if let Some(r) = receiver {\n             debug!(\"receiver: {:?}\", r);\n             self.type_of_node_must_outlive(infer::CallRcvr(r.span),\n-                                           r.id, callee_region);\n+                                           r.hir_id,\n+                                           callee_region);\n         }\n     }\n \n@@ -1038,7 +1039,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 //\n                 // FIXME(#6268) remove to support nested method calls\n                 self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n-                                               expr.id, expr_region);\n+                                               expr.hir_id,\n+                                               expr_region);\n             }\n \n             cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n@@ -1109,21 +1111,25 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// adjustments) are valid for at least `minimum_lifetime`\n     fn type_of_node_must_outlive(&mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n-        id: ast::NodeId,\n+        hir_id: hir::HirId,\n         minimum_lifetime: ty::Region<'tcx>)\n     {\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n-        let ty0 = self.resolve_node_type(id);\n-        let ty = self.tables.borrow().adjustments.get(&id)\n-            .and_then(|adj| adj.last())\n-            .map_or(ty0, |adj| adj.target);\n+        let ty0 = self.resolve_node_type(hir_id);\n+\n+        let ty = self.tables\n+                     .borrow()\n+                     .adjustments()\n+                     .get(hir_id)\n+                     .and_then(|adj| adj.last())\n+                     .map_or(ty0, |adj| adj.target);\n         let ty = self.resolve_type(ty);\n         debug!(\"constrain_regions_in_type_of_node(\\\n-                ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n+                ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n                 ty,  ty0,\n-               id, minimum_lifetime);\n+                hir_id, minimum_lifetime);\n         self.type_must_outlive(origin, ty, minimum_lifetime);\n     }\n \n@@ -1137,7 +1143,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"link_addr_of: cmt={:?}\", cmt);\n \n-        self.link_region_from_node_type(expr.span, expr.id, mutability, cmt);\n+        self.link_region_from_node_type(expr.span, expr.hir_id, mutability, cmt);\n     }\n \n     /// Computes the guarantors for any ref bindings in a `let` and\n@@ -1173,7 +1179,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n         for arg in args {\n-            let arg_ty = self.node_ty(arg.id);\n+            let arg_ty = self.node_ty(arg.hir_id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let arg_cmt = self.with_mc(|mc| {\n                 mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty)\n@@ -1197,10 +1203,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(..) => {\n-                        let bm = *mc.tables.pat_binding_modes.get(&sub_pat.id)\n-                                                             .expect(\"missing binding mode\");\n+                        let bm = *mc.tables.pat_binding_modes().get(sub_pat.hir_id)\n+                                                               .expect(\"missing binding mode\");\n                         if let ty::BindByReference(mutbl) = bm {\n-                            self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n+                            self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n                                                             mutbl, sub_cmt);\n                         }\n                     }\n@@ -1236,7 +1242,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// which must be some reference (`&T`, `&str`, etc).\n     fn link_region_from_node_type(&self,\n                                   span: Span,\n-                                  id: ast::NodeId,\n+                                  id: hir::HirId,\n                                   mutbl: hir::Mutability,\n                                   cmt_borrowed: mc::cmt<'tcx>) {\n         debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\","}, {"sha": "6db5c5b1cb0af84916ee8ef3b363831fff173040", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -50,8 +50,9 @@ use rustc::infer::UpvarRegion;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n+use rustc::hir::def_id::DefIndex;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::util::nodemap::NodeMap;\n+use rustc::util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry;\n \n@@ -78,7 +79,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n             hir::ExprClosure(cc, _, body_id, _) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n-                self.fcx.analyze_closure(expr.id, expr.span, body, cc);\n+                self.fcx.analyze_closure((expr.id, expr.hir_id), expr.span, body, cc);\n             }\n \n             _ => { }\n@@ -90,31 +91,37 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn analyze_closure(&self,\n-                       id: ast::NodeId,\n+                       (closure_node_id, closure_hir_id): (ast::NodeId, hir::HirId),\n                        span: Span,\n                        body: &hir::Body,\n                        capture_clause: hir::CaptureClause) {\n         /*!\n          * Analysis starting point.\n          */\n \n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n+        debug!(\"analyze_closure(id={:?}, body.id={:?})\", closure_node_id, body.id());\n \n-        let infer_kind = match self.tables.borrow_mut().closure_kinds.entry(id) {\n+        let infer_kind = match self.tables\n+                                   .borrow_mut()\n+                                   .closure_kinds_mut()\n+                                   .entry(closure_hir_id) {\n             Entry::Occupied(_) => false,\n             Entry::Vacant(entry) => {\n-                debug!(\"check_closure: adding closure {:?} as Fn\", id);\n+                debug!(\"check_closure: adding closure {:?} as Fn\", closure_node_id);\n                 entry.insert((ty::ClosureKind::Fn, None));\n                 true\n             }\n         };\n \n-        self.tcx.with_freevars(id, |freevars| {\n+        let closure_def_id = self.tcx.hir.local_def_id(closure_node_id);\n+\n+        self.tcx.with_freevars(closure_node_id, |freevars| {\n             for freevar in freevars {\n-                let def_id = freevar.def.def_id();\n-                let var_node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                             closure_expr_id: id };\n+                let var_def_id = freevar.def.def_id();\n+                let upvar_id = ty::UpvarId {\n+                    var_id: var_def_id.index,\n+                    closure_expr_id: closure_def_id.index,\n+                };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n \n                 let capture_kind = match capture_clause {\n@@ -139,7 +146,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let region_maps = &self.tcx.region_maps(body_owner_def_id);\n             let mut delegate = InferBorrowKind {\n                 fcx: self,\n-                adjust_closure_kinds: NodeMap(),\n+                adjust_closure_kinds: FxHashMap(),\n                 adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n             };\n             euv::ExprUseVisitor::with_infer(&mut delegate,\n@@ -151,8 +158,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Write the adjusted values back into the main tables.\n             if infer_kind {\n-                if let Some(kind) = delegate.adjust_closure_kinds.remove(&id) {\n-                    self.tables.borrow_mut().closure_kinds.insert(id, kind);\n+                if let Some(kind) = delegate.adjust_closure_kinds\n+                                            .remove(&closure_def_id.index) {\n+                    self.tables\n+                        .borrow_mut()\n+                        .closure_kinds_mut()\n+                        .insert(closure_hir_id, kind);\n                 }\n             }\n             self.tables.borrow_mut().upvar_capture_map.extend(\n@@ -172,20 +183,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Extract the type variables UV0...UVn.\n-        let (def_id, closure_substs) = match self.node_ty(id).sty {\n+        let (def_id, closure_substs) = match self.node_ty(closure_hir_id).sty {\n             ty::TyClosure(def_id, substs) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n                     span,\n                     \"type of closure expr {:?} is not a closure {:?}\",\n-                    id, t);\n+                    closure_node_id, t);\n             }\n         };\n \n         // Equate the type variables with the actual types.\n-        let final_upvar_tys = self.final_upvar_tys(id);\n+        let final_upvar_tys = self.final_upvar_tys(closure_node_id);\n         debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n-               id, closure_substs, final_upvar_tys);\n+               closure_node_id, closure_substs, final_upvar_tys);\n         for (upvar_ty, final_upvar_ty) in\n             closure_substs.upvar_tys(def_id, self.tcx).zip(final_upvar_tys)\n         {\n@@ -195,7 +206,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If we are also inferred the closure kind here,\n         // process any deferred resolutions.\n         if infer_kind {\n-            let closure_def_id = self.tcx.hir.local_def_id(id);\n             let deferred_call_resolutions =\n                 self.remove_deferred_call_resolutions(closure_def_id);\n             for deferred_call_resolution in deferred_call_resolutions {\n@@ -212,19 +222,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // This may change if abstract return types of some sort are\n         // implemented.\n         let tcx = self.tcx;\n+        let closure_def_index = tcx.hir.local_def_id(closure_id).index;\n+\n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter().map(|freevar| {\n-                let def_id = freevar.def.def_id();\n-                let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                let freevar_ty = self.node_ty(var_id);\n+                let var_def_id = freevar.def.def_id();\n+                let var_node_id = tcx.hir.as_local_node_id(var_def_id).unwrap();\n+                let freevar_ty = self.node_ty(tcx.hir.node_to_hir_id(var_node_id));\n                 let upvar_id = ty::UpvarId {\n-                    var_id: var_id,\n-                    closure_expr_id: closure_id\n+                    var_id: var_def_id.index,\n+                    closure_expr_id: closure_def_index,\n                 };\n                 let capture = self.tables.borrow().upvar_capture(upvar_id);\n \n                 debug!(\"var_id={:?} freevar_ty={:?} capture={:?}\",\n-                       var_id, freevar_ty, capture);\n+                       var_node_id, freevar_ty, capture);\n \n                 match capture {\n                     ty::UpvarCapture::ByValue => freevar_ty,\n@@ -242,7 +254,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n struct InferBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    adjust_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n+    adjust_closure_kinds: FxHashMap<DefIndex, (ty::ClosureKind, Option<(Span, ast::Name)>)>,\n     adjust_upvar_captures: ty::UpvarCaptureMap<'tcx>,\n }\n \n@@ -281,7 +293,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                         self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                                  ty::ClosureKind::FnOnce,\n                                                  guarantor.span,\n-                                                 tcx.hir.name(upvar_id.var_id));\n+                                                 var_name(tcx, upvar_id.var_id));\n \n                         self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n@@ -295,7 +307,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                         self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                                  ty::ClosureKind::FnOnce,\n                                                  guarantor.span,\n-                                                 tcx.hir.name(upvar_id.var_id));\n+                                                 var_name(tcx, upvar_id.var_id));\n                     }\n                     mc::NoteNone => {\n                     }\n@@ -400,7 +412,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                          ty::ClosureKind::FnMut,\n                                          cmt.span,\n-                                         tcx.hir.name(upvar_id.var_id));\n+                                         var_name(tcx, upvar_id.var_id));\n \n                 true\n             }\n@@ -411,7 +423,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                          ty::ClosureKind::FnMut,\n                                          cmt.span,\n-                                         tcx.hir.name(upvar_id.var_id));\n+                                         var_name(tcx, upvar_id.var_id));\n \n                 true\n             }\n@@ -460,17 +472,21 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     }\n \n     fn adjust_closure_kind(&mut self,\n-                           closure_id: ast::NodeId,\n+                           closure_id: DefIndex,\n                            new_kind: ty::ClosureKind,\n                            upvar_span: Span,\n                            var_name: ast::Name) {\n-        debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n+        debug!(\"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n                closure_id, new_kind, upvar_span, var_name);\n \n         let closure_kind = self.adjust_closure_kinds.get(&closure_id).cloned()\n-            .or_else(|| self.fcx.tables.borrow().closure_kinds.get(&closure_id).cloned());\n+            .or_else(|| {\n+                let closure_id = self.fcx.tcx.hir.def_index_to_hir_id(closure_id);\n+                self.fcx.tables.borrow().closure_kinds().get(closure_id).cloned()\n+            });\n+\n         if let Some((existing_kind, _)) = closure_kind {\n-            debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n+            debug!(\"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n                    closure_id, existing_kind, new_kind);\n \n             match (existing_kind, new_kind) {\n@@ -560,3 +576,8 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n     }\n }\n+\n+fn var_name(tcx: ty::TyCtxt, var_def_index: DefIndex) -> ast::Name {\n+    let var_node_id = tcx.hir.def_index_to_node_id(var_def_index);\n+    tcx.hir.name(var_node_id)\n+}"}, {"sha": "a363e47a14f2925d0d46a4a298d9a4b6212b022e", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 124, "deletions": 53, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -14,6 +14,7 @@\n \n use check::FnCtxt;\n use rustc::hir;\n+use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -34,7 +35,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut wbcx = WritebackCx::new(self, body);\n         for arg in &body.arguments {\n-            wbcx.visit_node_id(arg.pat.span, arg.id);\n+            wbcx.visit_node_id(arg.pat.span, arg.hir_id);\n         }\n         wbcx.visit_body(body);\n         wbcx.visit_upvar_borrow_map();\n@@ -74,10 +75,13 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, body: &'gcx hir::Body)\n-        -> WritebackCx<'cx, 'gcx, 'tcx> {\n+        -> WritebackCx<'cx, 'gcx, 'tcx>\n+    {\n+        let owner = fcx.tcx.hir.definitions().node_to_hir_id(body.id().node_id);\n+\n         WritebackCx {\n             fcx: fcx,\n-            tables: ty::TypeckTables::empty(),\n+            tables: ty::TypeckTables::empty(Some(DefId::local(owner.owner))),\n             body: body\n         }\n     }\n@@ -86,10 +90,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n-    fn write_ty_to_tables(&mut self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n-        debug!(\"write_ty_to_tables({}, {:?})\", node_id,  ty);\n+    fn write_ty_to_tables(&mut self, hir_id: hir::HirId, ty: Ty<'gcx>) {\n+        debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id,  ty);\n         assert!(!ty.needs_infer());\n-        self.tables.node_types.insert(node_id, ty);\n+        self.tables.node_types_mut().insert(hir_id, ty);\n     }\n \n     // Hacky hack: During type-checking, we treat *all* operators\n@@ -100,37 +104,38 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref inner) |\n             hir::ExprUnary(hir::UnNot, ref inner)  => {\n-                let inner_ty = self.fcx.node_ty(inner.id);\n+                let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n                 if inner_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n-                    tables.type_dependent_defs.remove(&e.id);\n-                    tables.node_substs.remove(&e.id);\n+                    tables.type_dependent_defs_mut().remove(e.hir_id);\n+                    tables.node_substs_mut().remove(e.hir_id);\n                 }\n             }\n             hir::ExprBinary(ref op, ref lhs, ref rhs) |\n             hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n-                let lhs_ty = self.fcx.node_ty(lhs.id);\n+                let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n                 let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n \n-                let rhs_ty = self.fcx.node_ty(rhs.id);\n+                let rhs_ty = self.fcx.node_ty(rhs.hir_id);\n                 let rhs_ty = self.fcx.resolve_type_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n-                    tables.type_dependent_defs.remove(&e.id);\n-                    tables.node_substs.remove(&e.id);\n+                    tables.type_dependent_defs_mut().remove(e.hir_id);\n+                    tables.node_substs_mut().remove(e.hir_id);\n \n                     match e.node {\n                         hir::ExprBinary(..) => {\n                             if !op.node.is_by_value() {\n-                                tables.adjustments.get_mut(&lhs.id).map(|a| a.pop());\n-                                tables.adjustments.get_mut(&rhs.id).map(|a| a.pop());\n+                                let mut adjustments = tables.adjustments_mut();\n+                                adjustments.get_mut(lhs.hir_id).map(|a| a.pop());\n+                                adjustments.get_mut(rhs.hir_id).map(|a| a.pop());\n                             }\n                         },\n                         hir::ExprAssignOp(..) => {\n-                            tables.adjustments.get_mut(&lhs.id).map(|a| a.pop());\n+                            tables.adjustments_mut().get_mut(lhs.hir_id).map(|a| a.pop());\n                         },\n                         _ => {},\n                     }\n@@ -157,12 +162,12 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, e: &'gcx hir::Expr) {\n         self.fix_scalar_builtin_expr(e);\n \n-        self.visit_node_id(e.span, e.id);\n+        self.visit_node_id(e.span, e.hir_id);\n \n         if let hir::ExprClosure(_, _, body, _) = e.node {\n             let body = self.fcx.tcx.hir.body(body);\n             for arg in &body.arguments {\n-                self.visit_node_id(e.span, arg.id);\n+                self.visit_node_id(e.span, arg.hir_id);\n             }\n \n             self.visit_body(body);\n@@ -172,29 +177,33 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_block(&mut self, b: &'gcx hir::Block) {\n-        self.visit_node_id(b.span, b.id);\n+        self.visit_node_id(b.span, b.hir_id);\n         intravisit::walk_block(self, b);\n     }\n \n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n         match p.node {\n             hir::PatKind::Binding(..) => {\n-                let bm = *self.fcx.tables.borrow().pat_binding_modes.get(&p.id)\n-                                                                    .expect(\"missing binding mode\");\n-                self.tables.pat_binding_modes.insert(p.id, bm);\n+                let bm = *self.fcx\n+                              .tables\n+                              .borrow()\n+                              .pat_binding_modes()\n+                              .get(p.hir_id)\n+                              .expect(\"missing binding mode\");\n+                self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n             }\n             _ => {}\n         };\n \n-        self.visit_node_id(p.span, p.id);\n+        self.visit_node_id(p.span, p.hir_id);\n         intravisit::walk_pat(self, p);\n     }\n \n     fn visit_local(&mut self, l: &'gcx hir::Local) {\n         intravisit::walk_local(self, l);\n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, &l.span);\n-        self.write_ty_to_tables(l.id, var_ty);\n+        self.write_ty_to_tables(l.hir_id, var_ty);\n     }\n }\n \n@@ -218,19 +227,42 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_closures(&mut self) {\n-        for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n-            let closure_ty = self.resolve(closure_ty, &id);\n-            self.tables.closure_tys.insert(id, closure_ty);\n+        let fcx_tables = self.fcx.tables.borrow();\n+        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+\n+        for (&id, closure_ty) in fcx_tables.closure_tys().iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id: id,\n+            };\n+            let closure_ty = self.resolve(closure_ty, &hir_id);\n+            self.tables.closure_tys_mut().insert(hir_id, closure_ty);\n         }\n \n-        for (&id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n-            self.tables.closure_kinds.insert(id, closure_kind);\n+        for (&id, &closure_kind) in fcx_tables.closure_kinds().iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id: id,\n+            };\n+            self.tables.closure_kinds_mut().insert(hir_id, closure_kind);\n         }\n     }\n \n     fn visit_cast_types(&mut self) {\n-        self.tables.cast_kinds.extend(\n-            self.fcx.tables.borrow().cast_kinds.iter().map(|(&key, &value)| (key, value)));\n+        let fcx_tables = self.fcx.tables.borrow();\n+        let fcx_cast_kinds = fcx_tables.cast_kinds();\n+        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        let mut self_cast_kinds = self.tables.cast_kinds_mut();\n+        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+\n+        for (&local_id, &cast_kind) in fcx_cast_kinds.iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id,\n+            };\n+            self_cast_kinds.insert(hir_id, cast_kind);\n+        }\n     }\n \n     fn visit_free_region_map(&mut self) {\n@@ -273,60 +305,85 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            self.tables.node_types.insert(node_id, outside_ty);\n+            let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n+            self.tables.node_types_mut().insert(hir_id, outside_ty);\n         }\n     }\n \n-    fn visit_node_id(&mut self, span: Span, node_id: ast::NodeId) {\n+    fn visit_node_id(&mut self, span: Span, hir_id: hir::HirId) {\n         // Export associated path extensions and method resultions.\n-        if let Some(def) = self.fcx.tables.borrow_mut().type_dependent_defs.remove(&node_id) {\n-            self.tables.type_dependent_defs.insert(node_id, def);\n+        if let Some(def) = self.fcx\n+                               .tables\n+                               .borrow_mut()\n+                               .type_dependent_defs_mut()\n+                               .remove(hir_id) {\n+            self.tables.type_dependent_defs_mut().insert(hir_id, def);\n         }\n \n         // Resolve any borrowings for the node with id `node_id`\n-        self.visit_adjustments(span, node_id);\n+        self.visit_adjustments(span, hir_id);\n \n         // Resolve the type of the node with id `node_id`\n-        let n_ty = self.fcx.node_ty(node_id);\n+        let n_ty = self.fcx.node_ty(hir_id);\n         let n_ty = self.resolve(&n_ty, &span);\n-        self.write_ty_to_tables(node_id, n_ty);\n-        debug!(\"Node {} has type {:?}\", node_id, n_ty);\n+        self.write_ty_to_tables(hir_id, n_ty);\n+        debug!(\"Node {:?} has type {:?}\", hir_id, n_ty);\n \n         // Resolve any substitutions\n-        if let Some(&substs) = self.fcx.tables.borrow().node_substs.get(&node_id) {\n+        if let Some(substs) = self.fcx.tables.borrow().node_substs_opt(hir_id) {\n             let substs = self.resolve(&substs, &span);\n-            debug!(\"write_substs_to_tcx({}, {:?})\", node_id, substs);\n+            debug!(\"write_substs_to_tcx({:?}, {:?})\", hir_id, substs);\n             assert!(!substs.needs_infer());\n-            self.tables.node_substs.insert(node_id, substs);\n+            self.tables.node_substs_mut().insert(hir_id, substs);\n         }\n     }\n \n-    fn visit_adjustments(&mut self, span: Span, node_id: ast::NodeId) {\n-        let adjustment = self.fcx.tables.borrow_mut().adjustments.remove(&node_id);\n+    fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n+        let adjustment = self.fcx\n+                             .tables\n+                             .borrow_mut()\n+                             .adjustments_mut()\n+                             .remove(hir_id);\n         match adjustment {\n             None => {\n-                debug!(\"No adjustments for node {}\", node_id);\n+                debug!(\"No adjustments for node {:?}\", hir_id);\n             }\n \n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n-                debug!(\"Adjustments for node {}: {:?}\", node_id, resolved_adjustment);\n-                self.tables.adjustments.insert(node_id, resolved_adjustment);\n+                debug!(\"Adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n+                self.tables.adjustments_mut().insert(hir_id, resolved_adjustment);\n             }\n         }\n     }\n \n     fn visit_liberated_fn_sigs(&mut self) {\n-        for (&node_id, fn_sig) in self.fcx.tables.borrow().liberated_fn_sigs.iter() {\n-            let fn_sig = self.resolve(fn_sig, &node_id);\n-            self.tables.liberated_fn_sigs.insert(node_id, fn_sig.clone());\n+        let fcx_tables = self.fcx.tables.borrow();\n+        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+\n+        for (&local_id, fn_sig) in fcx_tables.liberated_fn_sigs().iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id,\n+            };\n+            let fn_sig = self.resolve(fn_sig, &hir_id);\n+            self.tables.liberated_fn_sigs_mut().insert(hir_id, fn_sig.clone());\n         }\n     }\n \n     fn visit_fru_field_types(&mut self) {\n-        for (&node_id, ftys) in self.fcx.tables.borrow().fru_field_types.iter() {\n-            let ftys = self.resolve(ftys, &node_id);\n-            self.tables.fru_field_types.insert(node_id, ftys);\n+        let fcx_tables = self.fcx.tables.borrow();\n+        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+\n+        for (&local_id, ftys) in fcx_tables.fru_field_types().iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id,\n+            };\n+            let ftys = self.resolve(ftys, &hir_id);\n+            self.tables.fru_field_types_mut().insert(hir_id, ftys);\n         }\n     }\n \n@@ -356,6 +413,20 @@ impl Locatable for ast::NodeId {\n     fn to_span(&self, tcx: &TyCtxt) -> Span { tcx.hir.span(*self) }\n }\n \n+impl Locatable for DefIndex {\n+    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+        let node_id = tcx.hir.def_index_to_node_id(*self);\n+        tcx.hir.span(node_id)\n+    }\n+}\n+\n+impl Locatable for hir::HirId {\n+    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+        let node_id = tcx.hir.definitions().find_node_for_hir_id(*self);\n+        tcx.hir.span(node_id)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth."}, {"sha": "91b41eb33a17d71d6ac22baa06306d408e8a21da", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d12553320150750f41446291d0e19a3ca648c82/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0d12553320150750f41446291d0e19a3ca648c82", "patch": "@@ -1187,7 +1187,8 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeTy(&hir::Ty { node: TyImplTrait(..), .. }) => {\n             let owner = tcx.hir.get_parent_did(node_id);\n-            tcx.typeck_tables_of(owner).node_id_to_type(node_id)\n+            let hir_id = tcx.hir.node_to_hir_id(node_id);\n+            tcx.typeck_tables_of(owner).node_id_to_type(hir_id)\n         }\n \n         x => {\n@@ -1238,8 +1239,8 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ))\n         }\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n-            tcx.typeck_tables_of(def_id).closure_tys[&node_id]\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), hir_id, .. }) => {\n+            tcx.typeck_tables_of(def_id).closure_tys()[hir_id]\n         }\n \n         x => {"}]}