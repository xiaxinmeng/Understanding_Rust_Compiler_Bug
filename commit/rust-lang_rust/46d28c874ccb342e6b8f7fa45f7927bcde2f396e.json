{"sha": "46d28c874ccb342e6b8f7fa45f7927bcde2f396e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZDI4Yzg3NGNjYjM0MmU2YjhmN2ZhNDVmNzkyN2JjZGUyZjM5NmU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-06-24T13:55:33Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-06-27T17:28:17Z"}, "message": "debuginfo: Replaced many instances of @ with &.", "tree": {"sha": "3517b7bb419b7446f3a776164821f3ff53b5770c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3517b7bb419b7446f3a776164821f3ff53b5770c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46d28c874ccb342e6b8f7fa45f7927bcde2f396e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46d28c874ccb342e6b8f7fa45f7927bcde2f396e", "html_url": "https://github.com/rust-lang/rust/commit/46d28c874ccb342e6b8f7fa45f7927bcde2f396e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46d28c874ccb342e6b8f7fa45f7927bcde2f396e/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "168eba9201011e34a70febc8395d5e0808585600", "url": "https://api.github.com/repos/rust-lang/rust/commits/168eba9201011e34a70febc8395d5e0808585600", "html_url": "https://github.com/rust-lang/rust/commit/168eba9201011e34a70febc8395d5e0808585600"}], "stats": {"total": 45, "additions": 23, "deletions": 22}, "files": [{"sha": "a0ba0667f4b4e9b75d8b3c77801390179e4e1982", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/46d28c874ccb342e6b8f7fa45f7927bcde2f396e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d28c874ccb342e6b8f7fa45f7927bcde2f396e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=46d28c874ccb342e6b8f7fa45f7927bcde2f396e", "patch": "@@ -370,7 +370,7 @@ fn create_compile_unit(cx: @mut CrateContext) {\n     }}}}}};\n }\n \n-fn create_file(cx: @mut CrateContext, full_path: &str) -> DIFile {\n+fn create_file(cx: &mut CrateContext, full_path: &str) -> DIFile {\n     match dbg_cx(cx).created_files.find_equiv(&full_path) {\n         Some(file_md) => return *file_md,\n         None => ()\n@@ -440,7 +440,7 @@ fn create_block(bcx: block) -> DILexicalBlock {\n \n \n \n-fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n+fn create_basic_type(cx: &mut CrateContext, t: ty::t, _span: span) -> DIType {\n     let ty_id = ty::type_id(t);\n     match dbg_cx(cx).created_types.find(&ty_id) {\n         Some(ty_md) => return *ty_md,\n@@ -492,7 +492,7 @@ fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n     return ty_md;\n }\n \n-fn create_pointer_type(cx: @mut CrateContext, t: ty::t, _span: span, pointee: DIType) -> DIType {\n+fn create_pointer_type(cx: &mut CrateContext, t: ty::t, _span: span, pointee: DIType) -> DIType {\n     let (size, align) = size_and_align_of(cx, t);\n     let name = ty_to_str(cx.tcx, t);\n     let ptr_md = do as_c_str(name) |name| { unsafe {\n@@ -517,9 +517,9 @@ struct StructContext {\n }\n \n impl StructContext {\n-    fn new(cx: &CrateContext, name: ~str, file: DIFile, line: uint) -> ~StructContext {\n+    fn new(cx: &CrateContext, name: ~str, file: DIFile, line: uint) -> StructContext {\n         debug!(\"StructContext::create: %s\", name);\n-        let scx = ~StructContext {\n+        return StructContext {\n             builder: DIB(cx),\n             file: file,\n             name: name,\n@@ -528,7 +528,6 @@ impl StructContext {\n             total_size: 0,\n             align: 1\n         };\n-        return scx;\n     }\n \n     fn add_member(&mut self, name: &str, line: uint, size: uint, align: uint, ty: DIType) {\n@@ -569,17 +568,19 @@ impl StructContext {\n         //         let size_with_alignment = self.get_total_size_with_alignment();\n \n         //         if st.size != size_with_alignment {\n-        //             ccx.sess.bug(\"StructContext(%s)::verify_against_struct_or_tuple_type: invalid type size. Expected = %u, actual = %u\",\n+        //             ccx.sess.bug(\"StructContext(%s)::verify_against_struct_or_tuple_type:\n+        //                           invalid type size. Expected = %u, actual = %u\",\n         //                          st.size, size_with_alignment);\n         //         }\n \n         //         if st.align != self.align {\n-        //             ccx.sess.bug(\"StructContext(%s)::verify_against_struct_or_tuple_type: invalid type alignment. Expected = %u, actual = %u\",\n+        //             ccx.sess.bug(\"StructContext(%s)::verify_against_struct_or_tuple_type:\n+        //                           invalid type alignment. Expected = %u, actual = %u\",\n         //                          st.align, self.align);\n         //         }\n         //     },\n-        //     _ => ccx.sess.bug(fmt!(\"StructContext(%s)::verify_against_struct_or_tuple_type: called with invalid type %?\",\n-        //                       self.name, t))\n+        //     _ => ccx.sess.bug(fmt!(\"StructContext(%s)::verify_against_struct_or_tuple_type:\n+        //                             called with invalid type %?\", self.name, t))\n         // }\n     //}\n \n@@ -613,14 +614,14 @@ impl StructContext {\n     }\n }\n \n-fn create_struct(cx: @mut CrateContext, struct_type: ty::t, fields: ~[ty::field], span: span)\n+fn create_struct(cx: &mut CrateContext, struct_type: ty::t, fields: ~[ty::field], span: span)\n                 -> DICompositeType {\n     debug!(\"create_struct: %?\", ty::get(struct_type));\n \n     let loc = span_start(cx, span);\n     let file_md = create_file(cx, loc.file.name);\n \n-    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, t), file_md, loc.line);\n+    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, struct_type), file_md, loc.line);\n     for fields.iter().advance |field| {\n         let field_t = field.mt.ty;\n         let ty_md = create_ty(cx, field_t, span);\n@@ -631,7 +632,7 @@ fn create_struct(cx: @mut CrateContext, struct_type: ty::t, fields: ~[ty::field]\n }\n \n // returns (void* type as a ValueRef, size in bytes, align in bytes)\n-fn voidptr(cx: @mut CrateContext) -> (DIDerivedType, uint, uint) {\n+fn voidptr(cx: &mut CrateContext) -> (DIDerivedType, uint, uint) {\n     let size = sys::size_of::<ValueRef>();\n     let align = sys::min_align_of::<ValueRef>();\n     let vp = do as_c_str(\"*void\") |name| { unsafe {\n@@ -645,7 +646,7 @@ fn voidptr(cx: @mut CrateContext) -> (DIDerivedType, uint, uint) {\n     return (vp, size, align);\n }\n \n-fn create_tuple(cx: @mut CrateContext, tuple_type: ty::t, elements: &[ty::t], span: span)\n+fn create_tuple(cx: &mut CrateContext, tuple_type: ty::t, elements: &[ty::t], span: span)\n                 -> DICompositeType {\n     debug!(\"create_tuple: %?\", ty::get(tuple_type));\n \n@@ -662,7 +663,7 @@ fn create_tuple(cx: @mut CrateContext, tuple_type: ty::t, elements: &[ty::t], sp\n     return scx.finalize();\n }\n \n-fn create_boxed_type(cx: @mut CrateContext, contents: ty::t,\n+fn create_boxed_type(cx: &mut CrateContext, contents: ty::t,\n                      span: span, boxed: DIType) -> DICompositeType {\n     debug!(\"create_boxed_type: %?\", ty::get(contents));\n \n@@ -686,7 +687,7 @@ fn create_boxed_type(cx: @mut CrateContext, contents: ty::t,\n     return scx.finalize();\n }\n \n-fn create_fixed_vec(cx: @mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n+fn create_fixed_vec(cx: &mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n                     len: uint, span: span) -> DIType {\n     debug!(\"create_fixed_vec: %?\", ty::get(_vec_t));\n \n@@ -708,7 +709,7 @@ fn create_fixed_vec(cx: @mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n     };\n }\n \n-fn create_boxed_vec(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n+fn create_boxed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n                     vec_ty_span: span) -> DICompositeType {\n     debug!(\"create_boxed_vec: %?\", ty::get(vec_t));\n \n@@ -778,7 +779,7 @@ fn create_boxed_vec(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n     return mdval;\n }\n \n-fn create_vec_slice(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n+fn create_vec_slice(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n                     -> DICompositeType {\n     debug!(\"create_vec_slice: %?\", ty::get(vec_t));\n \n@@ -795,7 +796,7 @@ fn create_vec_slice(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: sp\n     return scx.finalize();\n }\n \n-fn create_fn_ty(cx: @mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n+fn create_fn_ty(cx: &mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n                 span: span) -> DICompositeType {\n     debug!(\"create_fn_ty: %?\", ty::get(_fn_ty));\n \n@@ -815,7 +816,7 @@ fn create_fn_ty(cx: @mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output:\n     };\n }\n \n-fn create_unimpl_ty(cx: @mut CrateContext, t: ty::t) -> DIType {\n+fn create_unimpl_ty(cx: &mut CrateContext, t: ty::t) -> DIType {\n     debug!(\"create_unimpl_ty: %?\", ty::get(t));\n \n     let name = ty_to_str(cx.tcx, t);\n@@ -830,7 +831,7 @@ fn create_unimpl_ty(cx: @mut CrateContext, t: ty::t) -> DIType {\n     return md;\n }\n \n-fn create_ty(cx: @mut CrateContext, t: ty::t, span: span) -> DIType {\n+fn create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n     let ty_id = ty::type_id(t);\n     match dbg_cx(cx).created_types.find(&ty_id) {\n         Some(ty_md) => return *ty_md,\n@@ -951,7 +952,7 @@ fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n     cx.sess.codemap.lookup_char_pos(span.lo)\n }\n \n-fn size_and_align_of(cx: @mut CrateContext, t: ty::t) -> (uint, uint) {\n+fn size_and_align_of(cx: &mut CrateContext, t: ty::t) -> (uint, uint) {\n     let llty = type_of::type_of(cx, t);\n     (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n }"}]}