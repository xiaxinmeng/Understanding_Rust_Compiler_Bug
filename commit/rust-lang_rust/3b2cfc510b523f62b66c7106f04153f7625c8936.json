{"sha": "3b2cfc510b523f62b66c7106f04153f7625c8936", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMmNmYzUxMGI1MjNmNjJiNjZjNzEwNmYwNDE1M2Y3NjI1Yzg5MzY=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-06T19:55:50Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-29T20:57:34Z"}, "message": "Handle inference variables in `nll_relate` and use it for chalk", "tree": {"sha": "64c32c279402820c54d4654d2a5286483eea106d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64c32c279402820c54d4654d2a5286483eea106d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b2cfc510b523f62b66c7106f04153f7625c8936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b2cfc510b523f62b66c7106f04153f7625c8936", "html_url": "https://github.com/rust-lang/rust/commit/3b2cfc510b523f62b66c7106f04153f7625c8936", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b2cfc510b523f62b66c7106f04153f7625c8936/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4478dced472dec4f516cc4ef553a1476e40c09b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4478dced472dec4f516cc4ef553a1476e40c09b8", "html_url": "https://github.com/rust-lang/rust/commit/4478dced472dec4f516cc4ef553a1476e40c09b8"}], "stats": {"total": 510, "additions": 393, "deletions": 117}, "files": [{"sha": "ff79c38680f2525f3e4fa5523c795630735c96a1", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 231, "deletions": 96, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/3b2cfc510b523f62b66c7106f04153f7625c8936/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2cfc510b523f62b66c7106f04153f7625c8936/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=3b2cfc510b523f62b66c7106f04153f7625c8936", "patch": "@@ -11,30 +11,41 @@\n //! This code is kind of an alternate way of doing subtyping,\n //! supertyping, and type equating, distinct from the `combine.rs`\n //! code but very similar in its effect and design. Eventually the two\n-//! ought to be merged. This code is intended for use in NLL.\n+//! ought to be merged. This code is intended for use in NLL and chalk.\n //!\n //! Here are the key differences:\n //!\n-//! - This code generally assumes that there are no unbound type\n-//!   inferences variables, because at NLL\n-//!   time types are fully inferred up-to regions.\n-//!   - Actually, to support user-given type annotations like\n-//!     `Vec<_>`, we do have some measure of support for type\n-//!     inference variables, but we impose some simplifying\n-//!     assumptions on them that would not be suitable for the infer\n-//!     code more generally. This could be fixed.\n+//! - This code may choose to bypass some checks (e.g. the occurs check)\n+//!   in case we know that there are no unbound type inference variables.\n+//!   This is the case for NLL, because at NLL time types are fully inferred\n+//!   up-to regions.\n //! - This code uses \"universes\" to handle higher-ranked regions and\n //!   not the leak-check. This is \"more correct\" than what rustc does\n //!   and we are generally migrating in this direction, but NLL had to\n //!   get there first.\n+//!\n+//! Also, this code assumes that there are no bound type vars at all, not even\n+//! free ones. This is ok because:\n+//! - we are not relating anything quantified over some type variable\n+//! - we will have instantiated all the bound type vars already (the one\n+//!   thing we relate in chalk are basically domain goals and their\n+//!   constituents)\n \n use crate::infer::InferCtxt;\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::Kind;\n use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::error::TypeError;\n+use crate::traits::DomainGoal;\n use rustc_data_structures::fx::FxHashMap;\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum NormalizationStrategy {\n+    Lazy,\n+    Eager,\n+}\n+\n pub struct TypeRelating<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n@@ -75,6 +86,10 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// delegate.\n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n \n+    /// Push a domain goal that will need to be proved for the two types to\n+    /// be related. Used for lazy normalization.\n+    fn push_domain_goal(&mut self, domain_goal: DomainGoal<'tcx>);\n+\n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n \n@@ -105,6 +120,13 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// relate `Foo<'?0>` with `Foo<'a>` (and probably add an outlives\n     /// relation stating that `'?0: 'a`).\n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n+\n+    /// Define the normalization strategy to use, eager or lazy.\n+    fn normalization() -> NormalizationStrategy;\n+\n+    /// Enable some optimizations if we do not expect inference variables\n+    /// in the RHS of the relation.\n+    fn forbid_inference_vars() -> bool;\n }\n \n #[derive(Clone, Debug)]\n@@ -242,15 +264,79 @@ where\n         self.delegate.push_outlives(sup, sub);\n     }\n \n-    /// When we encounter a canonical variable `var` in the output,\n-    /// equate it with `kind`. If the variable has been previously\n-    /// equated, then equate it again.\n-    fn relate_var(&mut self, var_ty: Ty<'tcx>, value_ty: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"equate_var(var_ty={:?}, value_ty={:?})\", var_ty, value_ty);\n+    /// Relate a projection type and some value type lazily. This will always\n+    /// succeed, but we are pushing an additional `ProjectionEq` goal depending\n+    /// on the value type:\n+    /// - if the value type is any type `T` which is not a projection, we push\n+    ///   `ProjectionEq(projection = T)`.\n+    /// - if the value type is another projection `other_projection`, we create\n+    ///   a new inference variable `?U` and push the two goals\n+    ///   `ProjectionEq(projection = ?U)`, `ProjectionEq(other_projection = ?U)`.\n+    fn relate_projection_ty(\n+        &mut self,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        value_ty: ty::Ty<'tcx>\n+    ) -> Ty<'tcx> {\n+        use crate::infer::type_variable::TypeVariableOrigin;\n+        use crate::traits::WhereClause;\n+        use syntax_pos::DUMMY_SP;\n+\n+        match value_ty.sty {\n+            ty::Projection(other_projection_ty) => {\n+                let var = self.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n+                self.relate_projection_ty(projection_ty, var);\n+                self.relate_projection_ty(other_projection_ty, var);\n+                var\n+            }\n+\n+            _ => {\n+                let projection = ty::ProjectionPredicate {\n+                    projection_ty,\n+                    ty: value_ty,\n+                };\n+                self.delegate.push_domain_goal(\n+                    DomainGoal::Holds(WhereClause::ProjectionEq(projection))\n+                );\n+                value_ty\n+            }\n+        }\n+    }\n+\n+    /// Relate a type inference variable with a value type.\n+    fn relate_ty_var(\n+        &mut self,\n+        vid: ty::TyVid,\n+        value_ty: Ty<'tcx>\n+    ) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"relate_ty_var(vid={:?}, value_ty={:?})\", vid, value_ty);\n+\n+        match value_ty.sty {\n+            ty::Infer(ty::TyVar(value_vid)) => {\n+                // Two type variables: just equate them.\n+                self.infcx.type_variables.borrow_mut().equate(vid, value_vid);\n+                return Ok(value_ty);\n+            }\n+\n+            ty::Projection(projection_ty)\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n+                return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_var(vid)));\n+            }\n+\n+            _ => (),\n+        }\n+\n+        let generalized_ty = self.generalize_value(value_ty, vid)?;\n+        debug!(\"relate_ty_var: generalized_ty = {:?}\", generalized_ty);\n+\n+        if D::forbid_inference_vars() {\n+            // In NLL, we don't have type inference variables\n+            // floating around, so we can do this rather imprecise\n+            // variant of the occurs-check.\n+            assert!(!generalized_ty.has_infer_types());\n+        }\n \n-        let generalized_ty = self.generalize_value(value_ty);\n-        self.infcx\n-            .force_instantiate_unchecked(var_ty, generalized_ty);\n+        self.infcx.type_variables.borrow_mut().instantiate(vid, generalized_ty);\n \n         // The generalized values we extract from `canonical_var_values` have\n         // been fully instantiated and hence the set of scopes we have\n@@ -264,22 +350,27 @@ where\n         // Restore the old scopes now.\n         self.a_scopes = old_a_scopes;\n \n-        debug!(\"equate_var: complete, result = {:?}\", result);\n+        debug!(\"relate_ty_var: complete, result = {:?}\", result);\n         result\n     }\n \n-    fn generalize_value<T: Relate<'tcx>>(&mut self, value: T) -> T {\n-        TypeGeneralizer {\n-            tcx: self.infcx.tcx,\n+    fn generalize_value<T: Relate<'tcx>>(\n+        &mut self,\n+        value: T,\n+        for_vid: ty::TyVid\n+    ) -> RelateResult<'tcx, T> {\n+        let universe = self.infcx.probe_ty_var(for_vid).unwrap_err();\n+\n+        let mut generalizer = TypeGeneralizer {\n+            infcx: self.infcx,\n             delegate: &mut self.delegate,\n             first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n+            for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n+            universe,\n+        };\n \n-            // These always correspond to an `_` or `'_` written by\n-            // user, and those are always in the root universe.\n-            universe: ty::UniverseIndex::ROOT,\n-        }.relate(&value, &value)\n-            .unwrap()\n+        generalizer.relate(&value, &value)\n     }\n }\n \n@@ -327,11 +418,35 @@ where\n         Ok(r)\n     }\n \n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    fn tys(&mut self, a: Ty<'tcx>, mut b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let a = self.infcx.shallow_resolve(a);\n-        match a.sty {\n-            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n-                self.relate_var(a.into(), b.into())\n+\n+        if !D::forbid_inference_vars() {\n+            b = self.infcx.shallow_resolve(b);\n+        }\n+\n+        match (&a.sty, &b.sty) {\n+            (_, &ty::Infer(ty::TyVar(vid))) => {\n+                if D::forbid_inference_vars() {\n+                    // Forbid inference variables in the RHS.\n+                    bug!(\"unexpected inference var {:?}\", b)\n+                } else {\n+                    self.relate_ty_var(vid, a)\n+                }\n+            }\n+\n+            (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var(vid, b),\n+\n+            (&ty::Projection(projection_ty), _)\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n+                Ok(self.relate_projection_ty(projection_ty, b))\n+            }\n+\n+            (_, &ty::Projection(projection_ty))\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n+                Ok(self.relate_projection_ty(projection_ty, a))\n             }\n \n             _ => {\n@@ -340,7 +455,8 @@ where\n                     a, b, self.ambient_variance\n                 );\n \n-                relate::super_relate_tys(self, a, b)\n+                // Will also handle unification of `IntVar` and `FloatVar`.\n+                self.infcx.super_combine_tys(self, a, b)\n             }\n         }\n     }\n@@ -551,7 +667,7 @@ struct TypeGeneralizer<'me, 'gcx: 'tcx, 'tcx: 'me, D>\n where\n     D: TypeRelatingDelegate<'tcx> + 'me,\n {\n-    tcx: TyCtxt<'me, 'gcx, 'tcx>,\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n \n     delegate: &'me mut D,\n \n@@ -561,6 +677,14 @@ where\n \n     first_free_index: ty::DebruijnIndex,\n \n+    /// The vid of the type variable that is in the process of being\n+    /// instantiated. If we find this within the value we are folding,\n+    /// that means we would have created a cyclic value.\n+    for_vid_sub_root: ty::TyVid,\n+\n+    /// The universe of the type variable that is in the process of being\n+    /// instantiated. If we find anything that this universe cannot name,\n+    /// we reject the relation.\n     universe: ty::UniverseIndex,\n }\n \n@@ -569,7 +693,7 @@ where\n     D: TypeRelatingDelegate<'tcx>,\n {\n     fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n-        self.tcx\n+        self.infcx.tcx\n     }\n \n     fn tag(&self) -> &'static str {\n@@ -609,17 +733,89 @@ where\n     }\n \n     fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        use crate::infer::type_variable::TypeVariableValue;\n+\n         debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n \n         match a.sty {\n-            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_))\n+                if D::forbid_inference_vars() =>\n+            {\n                 bug!(\n                     \"unexpected inference variable encountered in NLL generalization: {:?}\",\n                     a\n                 );\n             }\n \n-            _ => relate::super_relate_tys(self, a, a),\n+            ty::Infer(ty::TyVar(vid)) => {\n+                let mut variables = self.infcx.type_variables.borrow_mut();\n+                let vid = variables.root_var(vid);\n+                let sub_vid = variables.sub_root_var(vid);\n+                if sub_vid == self.for_vid_sub_root {\n+                    // If sub-roots are equal, then `for_vid` and\n+                    // `vid` are related via subtyping.\n+                    debug!(\"TypeGeneralizer::tys: occurs check failed\");\n+                    return Err(TypeError::Mismatch);\n+                } else {\n+                    match variables.probe(vid) {\n+                        TypeVariableValue::Known { value: u } => {\n+                            drop(variables);\n+                            self.relate(&u, &u)\n+                        }\n+                        TypeVariableValue::Unknown { universe } => {\n+                            if self.universe.cannot_name(universe) {\n+                                debug!(\n+                                    \"TypeGeneralizer::tys: root universe {:?} cannot name\\\n+                                    variable in universe {:?}\",\n+                                    self.universe,\n+                                    universe\n+                                );\n+                                return Err(TypeError::Mismatch);\n+                            }\n+\n+                            if self.ambient_variance == ty::Bivariant {\n+                                // FIXME: we may need a WF predicate (related to #54105).\n+                            }\n+\n+                            let origin = *variables.var_origin(vid);\n+                            let new_var_id = variables.new_var(self.universe, false, origin);\n+                            let u = self.tcx().mk_var(new_var_id);\n+                            debug!(\n+                                \"generalize: replacing original vid={:?} with new={:?}\",\n+                                vid,\n+                                u\n+                            );\n+                            return Ok(u);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ty::Infer(ty::IntVar(_)) |\n+            ty::Infer(ty::FloatVar(_)) => {\n+                // No matter what mode we are in,\n+                // integer/floating-point types must be equal to be\n+                // relatable.\n+                Ok(a)\n+            }\n+\n+            ty::Placeholder(placeholder) => {\n+                if self.universe.cannot_name(placeholder.universe) {\n+                    debug!(\n+                        \"TypeGeneralizer::tys: root universe {:?} cannot name\\\n+                        placeholder in universe {:?}\",\n+                        self.universe,\n+                        placeholder.universe\n+                    );\n+                    Err(TypeError::Mismatch)\n+                } else {\n+                    Ok(a)\n+                }\n+            }\n+\n+            _ => {\n+                relate::super_relate_tys(self, a, a)\n+            }\n         }\n     }\n \n@@ -673,64 +869,3 @@ where\n         Ok(ty::Binder::bind(result))\n     }\n }\n-\n-impl InferCtxt<'_, '_, 'tcx> {\n-    /// A hacky sort of method used by the NLL type-relating code:\n-    ///\n-    /// - `var` must be some unbound type variable.\n-    /// - `value` must be a suitable type to use as its value.\n-    ///\n-    /// `var` will then be equated with `value`. Note that this\n-    /// sidesteps a number of important checks, such as the \"occurs\n-    /// check\" that prevents cyclic types, so it is important not to\n-    /// use this method during regular type-check.\n-    fn force_instantiate_unchecked(&self, var: Ty<'tcx>, value: Ty<'tcx>) {\n-        match (&var.sty, &value.sty) {\n-            (&ty::Infer(ty::TyVar(vid)), _) => {\n-                let mut type_variables = self.type_variables.borrow_mut();\n-\n-                // In NLL, we don't have type inference variables\n-                // floating around, so we can do this rather imprecise\n-                // variant of the occurs-check.\n-                assert!(!value.has_infer_types());\n-\n-                type_variables.instantiate(vid, value);\n-            }\n-\n-            (&ty::Infer(ty::IntVar(vid)), &ty::Int(value)) => {\n-                let mut int_unification_table = self.int_unification_table.borrow_mut();\n-                int_unification_table\n-                    .unify_var_value(vid, Some(ty::IntVarValue::IntType(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n-                    });\n-            }\n-\n-            (&ty::Infer(ty::IntVar(vid)), &ty::Uint(value)) => {\n-                let mut int_unification_table = self.int_unification_table.borrow_mut();\n-                int_unification_table\n-                    .unify_var_value(vid, Some(ty::IntVarValue::UintType(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n-                    });\n-            }\n-\n-            (&ty::Infer(ty::FloatVar(vid)), &ty::Float(value)) => {\n-                let mut float_unification_table = self.float_unification_table.borrow_mut();\n-                float_unification_table\n-                    .unify_var_value(vid, Some(ty::FloatVarValue(value)))\n-                    .unwrap_or_else(|_| {\n-                        bug!(\"failed to unify float var `{:?}` with `{:?}`\", vid, value)\n-                    });\n-            }\n-\n-            _ => {\n-                bug!(\n-                    \"force_instantiate_unchecked invoked with bad combination: var={:?} value={:?}\",\n-                    var,\n-                    value,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "60ad7413cc7fff6d3f35abe97e7ab8bf8fde0927", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b2cfc510b523f62b66c7106f04153f7625c8936/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2cfc510b523f62b66c7106f04153f7625c8936/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=3b2cfc510b523f62b66c7106f04153f7625c8936", "patch": "@@ -371,6 +371,10 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             bug!(\"var types encountered in super_relate_tys\")\n         }\n \n+        (ty::Bound(..), _) | (_, ty::Bound(..)) => {\n+            bug!(\"bound types encountered in super_relate_tys\")\n+        }\n+\n         (&ty::Error, _) | (_, &ty::Error) =>\n         {\n             Ok(tcx.types.err)\n@@ -394,6 +398,10 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(a)\n         }\n \n+        (ty::Placeholder(p1), ty::Placeholder(p2)) if p1 == p2 => {\n+            Ok(a)\n+        }\n+\n         (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n             if a_def == b_def =>\n         {\n@@ -556,8 +564,13 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n-        (&ty::Projection(ref a_data), &ty::Projection(ref b_data)) =>\n-        {\n+        (ty::UnnormalizedProjection(a_data), ty::UnnormalizedProjection(b_data)) => {\n+            let projection_ty = relation.relate(a_data, b_data)?;\n+            Ok(tcx.mk_ty(ty::UnnormalizedProjection(projection_ty)))\n+        }\n+\n+        // these two are already handled downstream in case of lazy normalization\n+        (ty::Projection(a_data), ty::Projection(b_data)) => {\n             let projection_ty = relation.relate(a_data, b_data)?;\n             Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n         }"}, {"sha": "9924b033871322123a72807d1faba9d16090f61b", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b2cfc510b523f62b66c7106f04153f7625c8936/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2cfc510b523f62b66c7106f04153f7625c8936/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=3b2cfc510b523f62b66c7106f04153f7625c8936", "patch": "@@ -10,10 +10,11 @@\n \n use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n-use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n+use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate, NormalizationStrategy};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::mir::ConstraintCategory;\n use rustc::traits::query::Fallible;\n+use rustc::traits::DomainGoal;\n use rustc::ty::relate::TypeRelation;\n use rustc::ty::{self, Ty};\n \n@@ -38,7 +39,7 @@ pub(super) fn relate_types<'tcx>(\n     TypeRelating::new(\n         infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n-        v,\n+        v\n     ).relate(&a, &b)?;\n     Ok(())\n }\n@@ -115,4 +116,16 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, '_, 'tcx> {\n                 });\n         }\n     }\n+\n+    fn push_domain_goal(&mut self, _: DomainGoal<'tcx>) {\n+        // No-op\n+    }\n+\n+    fn normalization() -> NormalizationStrategy {\n+        NormalizationStrategy::Eager\n+    }\n+\n+    fn forbid_inference_vars() -> bool {\n+        true\n+    }\n }"}, {"sha": "e4d93374faa460e52e1ac7dac97315f761fe229c", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3b2cfc510b523f62b66c7106f04153f7625c8936/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2cfc510b523f62b66c7106f04153f7625c8936/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=3b2cfc510b523f62b66c7106f04153f7625c8936", "patch": "@@ -9,13 +9,14 @@\n // except according to those terms.\n \n mod program_clauses;\n+mod unify;\n \n-use chalk_engine::fallible::Fallible as ChalkEngineFallible;\n+use chalk_engine::fallible::{Fallible, NoSolution};\n use chalk_engine::{context, hh::HhGoal, DelayedLiteral, Literal, ExClause};\n use rustc::infer::canonical::{\n-    Canonical, CanonicalVarValues, OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n+    Canonical, CanonicalVarValues, OriginalQueryValues, QueryResponse,\n };\n-use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n use rustc::traits::{\n     DomainGoal,\n     ExClauseFold,\n@@ -30,11 +31,12 @@ use rustc::traits::{\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::{Kind, UnpackedKind};\n use rustc::ty::{self, TyCtxt};\n+use syntax_pos::DUMMY_SP;\n \n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n \n-use syntax_pos::DUMMY_SP;\n+use self::unify::*;\n \n #[derive(Copy, Clone, Debug)]\n crate struct ChalkArenas<'gcx> {\n@@ -55,10 +57,12 @@ crate struct ChalkInferenceContext<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n #[derive(Copy, Clone, Debug)]\n crate struct UniverseMap;\n \n+crate type RegionConstraint<'tcx> = ty::OutlivesPredicate<Kind<'tcx>, ty::Region<'tcx>>;\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n crate struct ConstrainedSubst<'tcx> {\n     subst: CanonicalVarValues<'tcx>,\n-    constraints: Vec<QueryRegionConstraint<'tcx>>,\n+    constraints: Vec<RegionConstraint<'tcx>>,\n }\n \n BraceStructTypeFoldableImpl! {\n@@ -86,7 +90,7 @@ impl context::Context for ChalkArenas<'tcx> {\n \n     type GoalInEnvironment = InEnvironment<'tcx, Goal<'tcx>>;\n \n-    type RegionConstraint = QueryRegionConstraint<'tcx>;\n+    type RegionConstraint = RegionConstraint<'tcx>;\n \n     type Substitution = CanonicalVarValues<'tcx>;\n \n@@ -104,7 +108,7 @@ impl context::Context for ChalkArenas<'tcx> {\n \n     type ProgramClauses = Vec<Clause<'tcx>>;\n \n-    type UnificationResult = InferOk<'tcx, ()>;\n+    type UnificationResult = UnificationResult<'tcx>;\n \n     fn goal_in_environment(\n         env: &Environment<'tcx>,\n@@ -291,7 +295,7 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         _goal: &DomainGoal<'tcx>,\n         _subst: &CanonicalVarValues<'tcx>,\n         _clause: &Clause<'tcx>,\n-    ) -> chalk_engine::fallible::Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n+    ) -> Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n         panic!()\n     }\n \n@@ -301,7 +305,7 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         _selected_goal: &InEnvironment<'tcx, Goal<'tcx>>,\n         _answer_table_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n         _canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n-    ) -> chalk_engine::fallible::Fallible<ChalkExClause<'tcx>> {\n+    ) -> Fallible<ChalkExClause<'tcx>> {\n         panic!()\n     }\n }\n@@ -376,7 +380,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     fn canonicalize_constrained_subst(\n         &mut self,\n         subst: CanonicalVarValues<'tcx>,\n-        constraints: Vec<QueryRegionConstraint<'tcx>>,\n+        constraints: Vec<RegionConstraint<'tcx>>,\n     ) -> Canonical<'gcx, ConstrainedSubst<'gcx>> {\n         self.infcx.canonicalize_response(&ConstrainedSubst { subst, constraints })\n     }\n@@ -400,11 +404,13 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n \n     fn unify_parameters(\n         &mut self,\n-        _environment: &Environment<'tcx>,\n-        _a: &Kind<'tcx>,\n-        _b: &Kind<'tcx>,\n-    ) -> ChalkEngineFallible<InferOk<'tcx, ()>> {\n-        panic!()\n+        environment: &Environment<'tcx>,\n+        a: &Kind<'tcx>,\n+        b: &Kind<'tcx>,\n+    ) -> Fallible<UnificationResult<'tcx>> {\n+        self.infcx.commit_if_ok(|_| {\n+            unify(self.infcx, *environment, a, b).map_err(|_| NoSolution)\n+        })\n     }\n \n     fn sink_answer_subset(\n@@ -421,11 +427,22 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         panic!(\"lift\")\n     }\n \n-    fn into_ex_clause(&mut self, _result: InferOk<'tcx, ()>, _ex_clause: &mut ChalkExClause<'tcx>) {\n-        panic!(\"TBD\")\n+    fn into_ex_clause(\n+        &mut self,\n+        result: UnificationResult<'tcx>,\n+        ex_clause: &mut ChalkExClause<'tcx>\n+    ) {\n+        into_ex_clause(result, ex_clause);\n     }\n }\n \n+crate fn into_ex_clause(result: UnificationResult<'tcx>, ex_clause: &mut ChalkExClause<'tcx>) {\n+    ex_clause.subgoals.extend(\n+        result.goals.into_iter().map(Literal::Positive)\n+    );\n+    ex_clause.constraints.extend(result.constraints);\n+}\n+\n type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n \n type ChalkExClause<'tcx> = ExClause<ChalkArenas<'tcx>>;"}, {"sha": "3a9c3918d137e81d5b85c1565a4f0bd510f4fe86", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3b2cfc510b523f62b66c7106f04153f7625c8936/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2cfc510b523f62b66c7106f04153f7625c8936/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=3b2cfc510b523f62b66c7106f04153f7625c8936", "patch": "@@ -0,0 +1,98 @@\n+use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate, NormalizationStrategy};\n+use rustc::infer::{InferCtxt, RegionVariableOrigin};\n+use rustc::traits::{DomainGoal, Goal, Environment, InEnvironment};\n+use rustc::ty::relate::{Relate, TypeRelation, RelateResult};\n+use rustc::ty;\n+use syntax_pos::DUMMY_SP;\n+\n+crate struct UnificationResult<'tcx> {\n+    crate goals: Vec<InEnvironment<'tcx, Goal<'tcx>>>,\n+    crate constraints: Vec<super::RegionConstraint<'tcx>>,\n+}\n+\n+crate fn unify<'me, 'gcx, 'tcx, T: Relate<'tcx>>(\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    environment: Environment<'tcx>,\n+    a: &T,\n+    b: &T\n+) -> RelateResult<'tcx, UnificationResult<'tcx>> {\n+    let mut delegate = ChalkTypeRelatingDelegate::new(\n+        infcx,\n+        environment\n+    );\n+\n+    TypeRelating::new(\n+        infcx,\n+        &mut delegate,\n+        ty::Variance::Invariant\n+    ).relate(a, b)?;\n+\n+    Ok(UnificationResult {\n+        goals: delegate.goals,\n+        constraints: delegate.constraints,\n+    })\n+}\n+\n+struct ChalkTypeRelatingDelegate<'me, 'gcx: 'tcx, 'tcx: 'me> {\n+    infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+    environment: Environment<'tcx>,\n+    goals: Vec<InEnvironment<'tcx, Goal<'tcx>>>,\n+    constraints: Vec<super::RegionConstraint<'tcx>>,\n+}\n+\n+impl ChalkTypeRelatingDelegate<'me, 'gcx, 'tcx> {\n+    fn new(\n+        infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n+        environment: Environment<'tcx>,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            environment,\n+            goals: Vec::new(),\n+            constraints: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl TypeRelatingDelegate<'tcx> for &mut ChalkTypeRelatingDelegate<'_, '_, 'tcx> {\n+    fn create_next_universe(&mut self) -> ty::UniverseIndex {\n+        self.infcx.create_next_universe()\n+    }\n+\n+    fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n+        self.infcx.next_region_var(RegionVariableOrigin::MiscVariable(DUMMY_SP))\n+    }\n+\n+    fn next_placeholder_region(\n+        &mut self,\n+        placeholder: ty::PlaceholderRegion\n+    ) -> ty::Region<'tcx> {\n+        self.infcx.tcx.mk_region(ty::RePlaceholder(placeholder))\n+    }\n+\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n+        self.infcx.next_region_var_in_universe(\n+            RegionVariableOrigin::MiscVariable(DUMMY_SP),\n+            universe\n+        )\n+    }\n+\n+    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+        self.constraints.push(ty::OutlivesPredicate(sup.into(), sub));\n+    }\n+\n+    fn push_domain_goal(&mut self, domain_goal: DomainGoal<'tcx>) {\n+        let goal = self.environment.with(\n+            self.infcx.tcx.mk_goal(domain_goal.into_goal())\n+        );\n+        self.goals.push(goal);\n+    }\n+\n+    fn normalization() -> NormalizationStrategy {\n+        NormalizationStrategy::Lazy\n+    }\n+\n+    fn forbid_inference_vars() -> bool {\n+        false\n+    }\n+}"}]}