{"sha": "507055bc50258f3e2329fb383495f2a6a05a6cd2", "node_id": "C_kwDOAAsO6NoAKDUwNzA1NWJjNTAyNThmM2UyMzI5ZmIzODM0OTVmMmE2YTA1YTZjZDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-02T08:09:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-02T08:09:48Z"}, "message": "Auto merge of #2911 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "a1649a1fd2e4663b8c5d239354674a387a855ae5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1649a1fd2e4663b8c5d239354674a387a855ae5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/507055bc50258f3e2329fb383495f2a6a05a6cd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/507055bc50258f3e2329fb383495f2a6a05a6cd2", "html_url": "https://github.com/rust-lang/rust/commit/507055bc50258f3e2329fb383495f2a6a05a6cd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/507055bc50258f3e2329fb383495f2a6a05a6cd2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47bf8e734f25e1ed65864263a8795f1335d6dce0", "url": "https://api.github.com/repos/rust-lang/rust/commits/47bf8e734f25e1ed65864263a8795f1335d6dce0", "html_url": "https://github.com/rust-lang/rust/commit/47bf8e734f25e1ed65864263a8795f1335d6dce0"}, {"sha": "be4e05a1906d975ac0e09ca1a5ea2daf6a0018a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/be4e05a1906d975ac0e09ca1a5ea2daf6a0018a0", "html_url": "https://github.com/rust-lang/rust/commit/be4e05a1906d975ac0e09ca1a5ea2daf6a0018a0"}], "stats": {"total": 11114, "additions": 6772, "deletions": 4342}, "files": [{"sha": "210ec72a11e0bc02bed73d36ccda1ec44e67b025", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -578,6 +578,7 @@ jobs:\n       actions: write\n     name: \"try - ${{ matrix.name }}\"\n     env:\n+      DIST_TRY_BUILD: 1\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n       CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse\n       SCCACHE_BUCKET: rust-lang-ci-sccache2"}, {"sha": "2ee63c286ba5cc1c8a2a17254792cf0cdbcc75ae", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -209,7 +209,7 @@ pub enum TargetDataLayoutErrors<'a> {\n     InvalidAddressSpace { addr_space: &'a str, cause: &'a str, err: ParseIntError },\n     InvalidBits { kind: &'a str, bit: &'a str, cause: &'a str, err: ParseIntError },\n     MissingAlignment { cause: &'a str },\n-    InvalidAlignment { cause: &'a str, err: String },\n+    InvalidAlignment { cause: &'a str, err: AlignFromBytesError },\n     InconsistentTargetArchitecture { dl: &'a str, target: &'a str },\n     InconsistentTargetPointerWidth { pointer_size: u64, target: u32 },\n     InvalidBitsSize { err: String },\n@@ -640,30 +640,65 @@ impl fmt::Debug for Align {\n     }\n }\n \n+#[derive(Clone, Copy)]\n+pub enum AlignFromBytesError {\n+    NotPowerOfTwo(u64),\n+    TooLarge(u64),\n+}\n+\n+impl AlignFromBytesError {\n+    pub fn diag_ident(self) -> &'static str {\n+        match self {\n+            Self::NotPowerOfTwo(_) => \"not_power_of_two\",\n+            Self::TooLarge(_) => \"too_large\",\n+        }\n+    }\n+\n+    pub fn align(self) -> u64 {\n+        let (Self::NotPowerOfTwo(align) | Self::TooLarge(align)) = self;\n+        align\n+    }\n+}\n+\n+impl fmt::Debug for AlignFromBytesError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for AlignFromBytesError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AlignFromBytesError::NotPowerOfTwo(align) => write!(f, \"`{align}` is not a power of 2\"),\n+            AlignFromBytesError::TooLarge(align) => write!(f, \"`{align}` is too large\"),\n+        }\n+    }\n+}\n+\n impl Align {\n     pub const ONE: Align = Align { pow2: 0 };\n     pub const MAX: Align = Align { pow2: 29 };\n \n     #[inline]\n-    pub fn from_bits(bits: u64) -> Result<Align, String> {\n+    pub fn from_bits(bits: u64) -> Result<Align, AlignFromBytesError> {\n         Align::from_bytes(Size::from_bits(bits).bytes())\n     }\n \n     #[inline]\n-    pub fn from_bytes(align: u64) -> Result<Align, String> {\n+    pub fn from_bytes(align: u64) -> Result<Align, AlignFromBytesError> {\n         // Treat an alignment of 0 bytes like 1-byte alignment.\n         if align == 0 {\n             return Ok(Align::ONE);\n         }\n \n         #[cold]\n-        fn not_power_of_2(align: u64) -> String {\n-            format!(\"`{}` is not a power of 2\", align)\n+        fn not_power_of_2(align: u64) -> AlignFromBytesError {\n+            AlignFromBytesError::NotPowerOfTwo(align)\n         }\n \n         #[cold]\n-        fn too_large(align: u64) -> String {\n-            format!(\"`{}` is too large\", align)\n+        fn too_large(align: u64) -> AlignFromBytesError {\n+            AlignFromBytesError::TooLarge(align)\n         }\n \n         let tz = align.trailing_zeros();"}, {"sha": "13e346b86bce315387bba6dd6bfeb94c3fed619f", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -279,8 +279,18 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // HACK This bubble is required for this tests to pass:\n         // nested-return-type2-tait2.rs\n         // nested-return-type2-tait3.rs\n-        let infcx =\n-            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n+        // FIXME(-Ztrait-solver=next): We probably should use `DefiningAnchor::Error`\n+        // and prepopulate this `InferCtxt` with known opaque values, rather than\n+        // using the `Bind` anchor here. For now it's fine.\n+        let infcx = self\n+            .tcx\n+            .infer_ctxt()\n+            .with_opaque_type_inference(if self.tcx.trait_solver_next() {\n+                DefiningAnchor::Bind(def_id)\n+            } else {\n+                DefiningAnchor::Bubble\n+            })\n+            .build();\n         let ocx = ObligationCtxt::new(&infcx);\n         // Require the hidden type to be well-formed with only the generics of the opaque type.\n         // Defining use functions may have more bounds than the opaque type, which is ok, as long as the"}, {"sha": "908ff3da5ca0b4388358879094f8b50147678e1c", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -188,9 +188,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n     // FIXME(-Ztrait-solver=next): A bit dubious that we're only registering\n     // predefined opaques in the typeck root.\n-    // FIXME(-Ztrait-solver=next): This is also totally wrong for TAITs, since\n-    // the HIR typeck map defining usages back to their definition params,\n-    // they won't actually match up with the usages in this body...\n     if infcx.tcx.trait_solver_next() && !infcx.tcx.is_typeck_child(body.source.def_id()) {\n         checker.register_predefined_opaques_in_new_solver();\n     }\n@@ -1042,10 +1039,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             .typeck(self.body.source.def_id().expect_local())\n             .concrete_opaque_types\n             .iter()\n-            .map(|(&def_id, &hidden_ty)| {\n-                let substs = ty::InternalSubsts::identity_for_item(self.infcx.tcx, def_id);\n-                (ty::OpaqueTypeKey { def_id, substs }, hidden_ty)\n-            })\n+            .map(|(k, v)| (*k, *v))\n             .collect();\n \n         let renumbered_opaques = self.infcx.tcx.fold_regions(opaques, |_, _| {"}, {"sha": "7243cf6da232e3afe06fe45ae47fded5766c79a9", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -6,6 +6,7 @@ use rustc_index::IndexVec;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n };\n+use rustc_span::source_map::Spanned;\n use rustc_span::SourceFile;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n@@ -495,25 +496,16 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for RevealAllLayoutCx<'tcx> {\n         fn_abi_request: FnAbiRequest<'tcx>,\n     ) -> ! {\n         if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n-            self.0.sess.span_fatal(span, err.to_string())\n+            self.0.sess.emit_fatal(Spanned { span, node: err })\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {\n-                    span_bug!(\n-                        span,\n-                        \"`fn_abi_of_fn_ptr({}, {:?})` failed: {}\",\n-                        sig,\n-                        extra_args,\n-                        err\n-                    );\n+                    span_bug!(span, \"`fn_abi_of_fn_ptr({sig}, {extra_args:?})` failed: {err:?}\");\n                 }\n                 FnAbiRequest::OfInstance { instance, extra_args } => {\n                     span_bug!(\n                         span,\n-                        \"`fn_abi_of_instance({}, {:?})` failed: {}\",\n-                        instance,\n-                        extra_args,\n-                        err\n+                        \"`fn_abi_of_instance({instance}, {extra_args:?})` failed: {err:?}\"\n                     );\n                 }\n             }"}, {"sha": "f9ea0f004564b4a0b1f07801664e33b552c14f46", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -758,7 +758,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n \n         if place.layout.is_zst() {\n-            return OperandRef::new_zst(self, place.layout);\n+            return OperandRef::zero_sized(place.layout);\n         }\n \n         fn scalar_load_metadata<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, load: RValue<'gcc>, scalar: &abi::Scalar) {"}, {"sha": "33e3b0baa9236fedfaf3e4c141cab0e4b2bc4833", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -24,7 +24,7 @@ fn set_global_alignment<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, gv: LValue<'gcc>\n         match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n             Err(err) => {\n-                cx.sess().emit_err(InvalidMinimumAlignment { err });\n+                cx.sess().emit_err(InvalidMinimumAlignment { err: err.to_string() });\n             }\n         }\n     }"}, {"sha": "08507e19652b40433d04e19aa9b1f4ad0f347538", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -477,7 +477,7 @@ impl<'gcc, 'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let LayoutError::SizeOverflow(_) = err {\n-            self.sess().emit_fatal(respan(span, err))\n+            self.sess().emit_fatal(respan(span, err.into_diagnostic()))\n         } else {\n             span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n         }\n@@ -499,21 +499,12 @@ impl<'gcc, 'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {\n-                    span_bug!(\n-                        span,\n-                        \"`fn_abi_of_fn_ptr({}, {:?})` failed: {}\",\n-                        sig,\n-                        extra_args,\n-                        err\n-                    );\n+                    span_bug!(span, \"`fn_abi_of_fn_ptr({sig}, {extra_args:?})` failed: {err:?}\");\n                 }\n                 FnAbiRequest::OfInstance { instance, extra_args } => {\n                     span_bug!(\n                         span,\n-                        \"`fn_abi_of_instance({}, {:?})` failed: {}\",\n-                        instance,\n-                        extra_args,\n-                        err\n+                        \"`fn_abi_of_instance({instance}, {extra_args:?})` failed: {err:?}\"\n                     );\n                 }\n             }"}, {"sha": "30a3fe67b854396011f70fec7c5df0f249c64d41", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -159,8 +159,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n     fn is_gcc_immediate(&self) -> bool {\n         match self.abi {\n             Abi::Scalar(_) | Abi::Vector { .. } => true,\n-            Abi::ScalarPair(..) => false,\n-            Abi::Uninhabited | Abi::Aggregate { .. } => self.is_zst(),\n+            Abi::ScalarPair(..) | Abi::Uninhabited | Abi::Aggregate { .. } => false,\n         }\n     }\n "}, {"sha": "de1622951fed41630fa207eec1de3946e1559b70", "filename": "compiler/rustc_codegen_llvm/messages.ftl", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fmessages.ftl?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -20,8 +20,12 @@ codegen_llvm_error_writing_def_file =\n codegen_llvm_from_llvm_diag = {$message}\n \n codegen_llvm_from_llvm_optimization_diag = {$filename}:{$line}:{$column} {$pass_name} ({$kind}): {$message}\n-codegen_llvm_invalid_minimum_alignment =\n-    invalid minimum global alignment: {$err}\n+\n+codegen_llvm_invalid_minimum_alignment_not_power_of_two =\n+    invalid minimum global alignment: {$align} is not power of 2\n+\n+codegen_llvm_invalid_minimum_alignment_too_large =\n+    invalid minimum global alignment: {$align} is too large\n \n codegen_llvm_load_bitcode = failed to load bitcode of module \"{$name}\"\n codegen_llvm_load_bitcode_with_llvm_err = failed to load bitcode of module \"{$name}\": {$llvm_err}"}, {"sha": "5968e70b1cccef32108b94113ca8ac780ea00153", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n \n         if place.layout.is_zst() {\n-            return OperandRef::new_zst(self, place.layout);\n+            return OperandRef::zero_sized(place.layout);\n         }\n \n         #[instrument(level = \"trace\", skip(bx))]"}, {"sha": "df52f50f86f05f81950d8ad060ebad6faae55068", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,7 +1,9 @@\n use crate::base;\n use crate::common::{self, CodegenCx};\n use crate::debuginfo;\n-use crate::errors::{InvalidMinimumAlignment, SymbolAlreadyDefined};\n+use crate::errors::{\n+    InvalidMinimumAlignmentNotPowerOfTwo, InvalidMinimumAlignmentTooLarge, SymbolAlreadyDefined,\n+};\n use crate::llvm::{self, True};\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n@@ -19,7 +21,9 @@ use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::Lto;\n-use rustc_target::abi::{Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange};\n+use rustc_target::abi::{\n+    Align, AlignFromBytesError, HasDataLayout, Primitive, Scalar, Size, WrappingRange,\n+};\n use std::ops::Range;\n \n pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<'_>) -> &'ll Value {\n@@ -129,9 +133,14 @@ fn set_global_alignment<'ll>(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align:\n     if let Some(min) = cx.sess().target.min_global_align {\n         match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n-            Err(err) => {\n-                cx.sess().emit_err(InvalidMinimumAlignment { err });\n-            }\n+            Err(err) => match err {\n+                AlignFromBytesError::NotPowerOfTwo(align) => {\n+                    cx.sess().emit_err(InvalidMinimumAlignmentNotPowerOfTwo { align });\n+                }\n+                AlignFromBytesError::TooLarge(align) => {\n+                    cx.sess().emit_err(InvalidMinimumAlignmentTooLarge { align });\n+                }\n+            },\n         }\n     }\n     unsafe {"}, {"sha": "ca0f771f5b9e46900a51205cf8f53a522d1a6276", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -969,9 +969,9 @@ impl<'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'_, 'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let LayoutError::SizeOverflow(_) = err {\n-            self.sess().emit_fatal(Spanned { span, node: err })\n+            self.sess().emit_fatal(Spanned { span, node: err.into_diagnostic() })\n         } else {\n-            span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n+            span_bug!(span, \"failed to get layout for `{ty}`: {err:?}\")\n         }\n     }\n }\n@@ -991,21 +991,12 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'_, 'tcx> {\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {\n-                    span_bug!(\n-                        span,\n-                        \"`fn_abi_of_fn_ptr({}, {:?})` failed: {}\",\n-                        sig,\n-                        extra_args,\n-                        err\n-                    );\n+                    span_bug!(span, \"`fn_abi_of_fn_ptr({sig}, {extra_args:?})` failed: {err:?}\",);\n                 }\n                 FnAbiRequest::OfInstance { instance, extra_args } => {\n                     span_bug!(\n                         span,\n-                        \"`fn_abi_of_instance({}, {:?})` failed: {}\",\n-                        instance,\n-                        extra_args,\n-                        err\n+                        \"`fn_abi_of_instance({instance}, {extra_args:?})` failed: {err:?}\",\n                     );\n                 }\n             }"}, {"sha": "44869ced1ae18e08243a248823d854a2a84a9f92", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -50,9 +50,15 @@ pub(crate) struct SymbolAlreadyDefined<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_llvm_invalid_minimum_alignment)]\n-pub(crate) struct InvalidMinimumAlignment {\n-    pub err: String,\n+#[diag(codegen_llvm_invalid_minimum_alignment_not_power_of_two)]\n+pub(crate) struct InvalidMinimumAlignmentNotPowerOfTwo {\n+    pub align: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_invalid_minimum_alignment_too_large)]\n+pub(crate) struct InvalidMinimumAlignmentTooLarge {\n+    pub align: u64,\n }\n \n #[derive(Diagnostic)]"}, {"sha": "a493c9c0548e90f505ba4b2fc092d9676b1d1db7", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -198,8 +198,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     fn is_llvm_immediate(&self) -> bool {\n         match self.abi {\n             Abi::Scalar(_) | Abi::Vector { .. } => true,\n-            Abi::ScalarPair(..) => false,\n-            Abi::Uninhabited | Abi::Aggregate { .. } => self.is_zst(),\n+            Abi::ScalarPair(..) | Abi::Uninhabited | Abi::Aggregate { .. } => false,\n         }\n     }\n "}, {"sha": "242d209b68425db326f234e0f016b90fc87356fe", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -295,7 +295,7 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let (base, info) = match bx.load_operand(src).val {\n                 OperandValue::Pair(base, info) => unsize_ptr(bx, base, src_ty, dst_ty, Some(info)),\n                 OperandValue::Immediate(base) => unsize_ptr(bx, base, src_ty, dst_ty, None),\n-                OperandValue::Ref(..) => bug!(),\n+                OperandValue::Ref(..) | OperandValue::ZeroSized => bug!(),\n             };\n             OperandValue::Pair(base, info).store(bx, dst);\n         }"}, {"sha": "e91f7b86e5ed6399b070dbcbb7803901dfe30432", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -93,8 +93,7 @@ fn push_debuginfo_type_name<'tcx>(\n                     Err(e) => {\n                         // Computing the layout can still fail here, e.g. if the target architecture\n                         // cannot represent the type. See https://github.com/rust-lang/rust/issues/94961.\n-                        // FIXME: migrate once `rustc_middle::mir::interpret::InterpError` is translatable.\n-                        tcx.sess.fatal(format!(\"{}\", e));\n+                        tcx.sess.emit_fatal(e.into_diagnostic());\n                     }\n                 }\n             } else {"}, {"sha": "e0cb26d3ba8667548f844327b1ce084c5fac03fd", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,5 +1,5 @@\n use super::operand::OperandRef;\n-use super::operand::OperandValue::{Immediate, Pair, Ref};\n+use super::operand::OperandValue::{Immediate, Pair, Ref, ZeroSized};\n use super::place::PlaceRef;\n use super::{CachedLlbb, FunctionCx, LocalRef};\n \n@@ -427,6 +427,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         assert_eq!(align, op.layout.align.abi, \"return place is unaligned!\");\n                         llval\n                     }\n+                    ZeroSized => bug!(\"ZST return value shouldn't be in PassMode::Cast\"),\n                 };\n                 let ty = bx.cast_backend_type(cast_ty);\n                 let addr = bx.pointercast(llslot, bx.type_ptr_to(ty));\n@@ -1386,6 +1387,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     (llval, align, true)\n                 }\n             }\n+            ZeroSized => match arg.mode {\n+                PassMode::Indirect { .. } => {\n+                    // Though `extern \"Rust\"` doesn't pass ZSTs, some ABIs pass\n+                    // a pointer for `repr(C)` structs even when empty, so get\n+                    // one from an `alloca` (which can be left uninitialized).\n+                    let scratch = PlaceRef::alloca(bx, arg.layout);\n+                    (scratch.llval, scratch.align, true)\n+                }\n+                _ => bug!(\"ZST {op:?} wasn't ignored, but was passed with abi {arg:?}\"),\n+            },\n         };\n \n         if by_ref && !arg.is_indirect() {"}, {"sha": "4f79c6a3d823c83e912348e0e192a08a754020b0", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -352,6 +352,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.set_var_name(a, &(name.clone() + \".0\"));\n                         bx.set_var_name(b, &(name.clone() + \".1\"));\n                     }\n+                    OperandValue::ZeroSized => {\n+                        // These never have a value to talk about\n+                    }\n                 },\n                 LocalRef::PendingOperand => {}\n             }"}, {"sha": "2809ec2deb550c1926265bc6557aa7290a8f8c59", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -129,16 +129,13 @@ enum LocalRef<'tcx, V> {\n     PendingOperand,\n }\n \n-impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n-    fn new_operand<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n-        bx: &mut Bx,\n-        layout: TyAndLayout<'tcx>,\n-    ) -> LocalRef<'tcx, V> {\n+impl<'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n+    fn new_operand(layout: TyAndLayout<'tcx>) -> LocalRef<'tcx, V> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            LocalRef::Operand(OperandRef::new_zst(bx, layout))\n+            LocalRef::Operand(OperandRef::zero_sized(layout))\n         } else {\n             LocalRef::PendingOperand\n         }\n@@ -249,7 +246,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 }\n             } else {\n                 debug!(\"alloc: {:?} -> operand\", local);\n-                LocalRef::new_operand(&mut start_bx, layout)\n+                LocalRef::new_operand(layout)\n             }\n         };\n \n@@ -355,7 +352,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 let local = |op| LocalRef::Operand(op);\n                 match arg.mode {\n                     PassMode::Ignore => {\n-                        return local(OperandRef::new_zst(bx, arg.layout));\n+                        return local(OperandRef::zero_sized(arg.layout));\n                     }\n                     PassMode::Direct(_) => {\n                         let llarg = bx.get_param(llarg_idx);"}, {"sha": "31c293d7c298ec555eb18e044bc58bb12326fbcc", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -45,6 +45,14 @@ pub enum OperandValue<V> {\n     /// as returned by [`LayoutTypeMethods::scalar_pair_element_backend_type`]\n     /// with `immediate: true`.\n     Pair(V, V),\n+    /// A value taking no bytes, and which therefore needs no LLVM value at all.\n+    ///\n+    /// If you ever need a `V` to pass to something, get a fresh poison value\n+    /// from [`ConstMethods::const_poison`].\n+    ///\n+    /// An `OperandValue` *must* be this variant for any type for which\n+    /// `is_zst` on its `Layout` returns `true`.\n+    ZeroSized,\n }\n \n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n@@ -71,15 +79,9 @@ impl<V: CodegenObject> fmt::Debug for OperandRef<'_, V> {\n }\n \n impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n-    pub fn new_zst<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n-        bx: &mut Bx,\n-        layout: TyAndLayout<'tcx>,\n-    ) -> OperandRef<'tcx, V> {\n+    pub fn zero_sized(layout: TyAndLayout<'tcx>) -> OperandRef<'tcx, V> {\n         assert!(layout.is_zst());\n-        OperandRef {\n-            val: OperandValue::Immediate(bx.const_poison(bx.immediate_backend_type(layout))),\n-            layout,\n-        }\n+        OperandRef { val: OperandValue::ZeroSized, layout }\n     }\n \n     pub fn from_const<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n@@ -97,7 +99,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 let llval = bx.scalar_to_backend(x, scalar, bx.immediate_backend_type(layout));\n                 OperandValue::Immediate(llval)\n             }\n-            ConstValue::ZeroSized => return OperandRef::new_zst(bx, layout),\n+            ConstValue::ZeroSized => return OperandRef::zero_sized(layout),\n             ConstValue::Slice { data, start, end } => {\n                 let Abi::ScalarPair(a_scalar, _) = layout.abi else {\n                     bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout);\n@@ -178,7 +180,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 );\n                 OperandRef { val: OperandValue::Pair(a_val, b_val), layout }\n             }\n-            _ if layout.is_zst() => OperandRef::new_zst(bx, layout),\n+            _ if layout.is_zst() => OperandRef::zero_sized(layout),\n             _ => {\n                 // Neither a scalar nor scalar pair. Load from a place\n                 let init = bx.const_data_from_alloc(alloc);\n@@ -216,6 +218,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             OperandValue::Immediate(llptr) => (llptr, None),\n             OperandValue::Pair(llptr, llextra) => (llptr, Some(llextra)),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self),\n+            OperandValue::ZeroSized => bug!(\"Deref of ZST operand {:?}\", self),\n         };\n         let layout = cx.layout_of(projected_ty);\n         PlaceRef { llval: llptr, llextra, layout, align: layout.align.abi }\n@@ -273,9 +276,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n \n         let mut val = match (self.val, self.layout.abi) {\n             // If the field is ZST, it has no data.\n-            _ if field.is_zst() => {\n-                return OperandRef::new_zst(bx, field);\n-            }\n+            _ if field.is_zst() => OperandValue::ZeroSized,\n \n             // Newtype of a scalar, scalar pair or vector.\n             (OperandValue::Immediate(_) | OperandValue::Pair(..), _)\n@@ -306,6 +307,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n         };\n \n         match (&mut val, field.abi) {\n+            (OperandValue::ZeroSized, _) => {}\n             (\n                 OperandValue::Immediate(llval),\n                 Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. },\n@@ -359,16 +361,18 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n     /// Returns an `OperandValue` that's generally UB to use in any way.\n     ///\n-    /// Depending on the `layout`, returns an `Immediate` or `Pair` containing\n-    /// poison value(s), or a `Ref` containing a poison pointer.\n+    /// Depending on the `layout`, returns `ZeroSized` for ZSTs, an `Immediate` or\n+    /// `Pair` containing poison value(s), or a `Ref` containing a poison pointer.\n     ///\n     /// Supports sized types only.\n     pub fn poison<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyAndLayout<'tcx>,\n     ) -> OperandValue<V> {\n         assert!(layout.is_sized());\n-        if bx.cx().is_backend_immediate(layout) {\n+        if layout.is_zst() {\n+            OperandValue::ZeroSized\n+        } else if bx.cx().is_backend_immediate(layout) {\n             let ibty = bx.cx().immediate_backend_type(layout);\n             OperandValue::Immediate(bx.const_poison(ibty))\n         } else if bx.cx().is_backend_scalar_pair(layout) {\n@@ -421,12 +425,11 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n         flags: MemFlags,\n     ) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n-        // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n-        // value is through `undef`, and store itself is useless.\n-        if dest.layout.is_zst() {\n-            return;\n-        }\n         match self {\n+            OperandValue::ZeroSized => {\n+                // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n+                // value is through `undef`/`poison`, and the store itself is useless.\n+            }\n             OperandValue::Ref(r, None, source_align) => {\n                 if flags.contains(MemFlags::NONTEMPORAL) {\n                     // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n@@ -527,7 +530,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             // checks in `codegen_consume` and `extract_field`.\n                             let elem = o.layout.field(bx.cx(), 0);\n                             if elem.is_zst() {\n-                                o = OperandRef::new_zst(bx, elem);\n+                                o = OperandRef::zero_sized(elem);\n                             } else {\n                                 return None;\n                             }\n@@ -561,7 +564,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // ZSTs don't require any actual memory access.\n         if layout.is_zst() {\n-            return OperandRef::new_zst(bx, layout);\n+            return OperandRef::zero_sized(layout);\n         }\n \n         if let Some(o) = self.maybe_codegen_consume_direct(bx, place_ref) {"}, {"sha": "5241a5aee008e4b09d9de6fca5da74051251668b", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -70,6 +70,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     OperandValue::Ref(_, Some(_), _) => {\n                         bug!(\"unsized coercion on an unsized rvalue\");\n                     }\n+                    OperandValue::ZeroSized => {\n+                        bug!(\"unsized coercion on a ZST rvalue\");\n+                    }\n                 }\n             }\n \n@@ -165,11 +168,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         match src.val {\n-            OperandValue::Ref(..) => {\n+            OperandValue::Ref(..) | OperandValue::ZeroSized => {\n                 span_bug!(\n                     self.mir.span,\n                     \"Operand path should have handled transmute \\\n-                    from `Ref` {src:?} to place {dst:?}\"\n+                    from {src:?} to place {dst:?}\"\n                 );\n             }\n             OperandValue::Immediate(..) | OperandValue::Pair(..) => {\n@@ -220,17 +223,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let fake_place = PlaceRef::new_sized_aligned(cast_ptr, cast, align);\n                 Some(bx.load_operand(fake_place).val)\n             }\n+            OperandValue::ZeroSized => {\n+                let OperandValueKind::ZeroSized = operand_kind else {\n+                    bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n+                };\n+                if let OperandValueKind::ZeroSized = cast_kind {\n+                    Some(OperandValue::ZeroSized)\n+                } else {\n+                    None\n+                }\n+            }\n             OperandValue::Immediate(imm) => {\n                 let OperandValueKind::Immediate(in_scalar) = operand_kind else {\n                     bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n                 };\n-                if let OperandValueKind::Immediate(out_scalar) = cast_kind {\n-                    match (in_scalar, out_scalar) {\n-                        (ScalarOrZst::Zst, ScalarOrZst::Zst) => {\n-                            Some(OperandRef::new_zst(bx, cast).val)\n-                        }\n-                        (ScalarOrZst::Scalar(in_scalar), ScalarOrZst::Scalar(out_scalar))\n-                            if in_scalar.size(self.cx) == out_scalar.size(self.cx) =>\n+                if let OperandValueKind::Immediate(out_scalar) = cast_kind\n+                    && in_scalar.size(self.cx) == out_scalar.size(self.cx)\n                         {\n                             let operand_bty = bx.backend_type(operand.layout);\n                             let cast_bty = bx.backend_type(cast);\n@@ -242,9 +250,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 out_scalar,\n                                 cast_bty,\n                             )))\n-                        }\n-                        _ => None,\n-                    }\n                 } else {\n                     None\n                 }\n@@ -457,6 +462,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             OperandValue::Ref(..) => {\n                                 bug!(\"by-ref operand {:?} in `codegen_rvalue_operand`\", operand);\n                             }\n+                            OperandValue::ZeroSized => {\n+                                bug!(\"zero-sized operand {:?} in `codegen_rvalue_operand`\", operand);\n+                            }\n                         };\n                         let (lldata, llextra) =\n                             base::unsize_ptr(bx, lldata, operand.layout.ty, cast.ty, llextra);\n@@ -490,6 +498,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             OperandValue::Ref(_, _, _) => todo!(),\n                             OperandValue::Immediate(v) => (v, None),\n                             OperandValue::Pair(v, l) => (v, Some(l)),\n+                            OperandValue::ZeroSized => bug!(\"ZST -- which is not PointerLike -- in DynStar\"),\n                         };\n                         let (lldata, llextra) =\n                             base::cast_to_dyn_star(bx, lldata, operand.layout, cast.ty, llextra);\n@@ -718,7 +727,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n                 let ty = rvalue.ty(self.mir, self.cx.tcx());\n-                OperandRef::new_zst(bx, self.cx.layout_of(self.monomorphize(ty)))\n+                OperandRef::zero_sized(self.cx.layout_of(self.monomorphize(ty)))\n             }\n             mir::Rvalue::ShallowInitBox(ref operand, content_ty) => {\n                 let operand = self.codegen_operand(bx, operand);\n@@ -936,6 +945,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // Can always load from a pointer as needed\n                     (OperandValueKind::Ref, _) => true,\n \n+                    // ZST-to-ZST is the easiest thing ever\n+                    (OperandValueKind::ZeroSized, OperandValueKind::ZeroSized) => true,\n+\n+                    // But if only one of them is a ZST the sizes can't match\n+                    (OperandValueKind::ZeroSized, _) | (_, OperandValueKind::ZeroSized) => false,\n+\n                     // Need to generate an `alloc` to get a pointer from an immediate\n                     (OperandValueKind::Immediate(..) | OperandValueKind::Pair(..), OperandValueKind::Ref) => false,\n \n@@ -979,12 +994,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     /// Gets which variant of [`OperandValue`] is expected for a particular type.\n     fn value_kind(&self, layout: TyAndLayout<'tcx>) -> OperandValueKind {\n-        if self.cx.is_backend_immediate(layout) {\n+        if layout.is_zst() {\n+            OperandValueKind::ZeroSized\n+        } else if self.cx.is_backend_immediate(layout) {\n             debug_assert!(!self.cx.is_backend_scalar_pair(layout));\n             OperandValueKind::Immediate(match layout.abi {\n-                abi::Abi::Scalar(s) => ScalarOrZst::Scalar(s),\n-                abi::Abi::Vector { element, .. } => ScalarOrZst::Scalar(element),\n-                _ if layout.is_zst() => ScalarOrZst::Zst,\n+                abi::Abi::Scalar(s) => s,\n+                abi::Abi::Vector { element, .. } => element,\n                 x => span_bug!(self.mir.span, \"Couldn't translate {x:?} as backend immediate\"),\n             })\n         } else if self.cx.is_backend_scalar_pair(layout) {\n@@ -1007,21 +1023,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n #[derive(Debug, Copy, Clone)]\n enum OperandValueKind {\n     Ref,\n-    Immediate(ScalarOrZst),\n+    Immediate(abi::Scalar),\n     Pair(abi::Scalar, abi::Scalar),\n-}\n-\n-#[derive(Debug, Copy, Clone)]\n-enum ScalarOrZst {\n-    Zst,\n-    Scalar(abi::Scalar),\n-}\n-\n-impl ScalarOrZst {\n-    pub fn size(self, cx: &impl abi::HasDataLayout) -> abi::Size {\n-        match self {\n-            ScalarOrZst::Zst => abi::Size::ZERO,\n-            ScalarOrZst::Scalar(s) => s.size(cx),\n-        }\n-    }\n+    ZeroSized,\n }"}, {"sha": "bf660c59cabda8d27cc4a4ff927c852e35b9e1a9", "filename": "compiler/rustc_const_eval/messages.ftl", "status": "modified", "additions": 380, "deletions": 17, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fmessages.ftl?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,28 +1,306 @@\n+const_eval_address_space_full =\n+    there are no more free addresses in the address space\n+const_eval_align_check_failed = accessing memory with alignment {$has}, but alignment {$required} is required\n+const_eval_align_offset_invalid_align =\n+    `align_offset` called with non-power-of-two align: {$target_align}\n+\n+const_eval_alignment_check_failed =\n+    accessing memory with alignment {$has}, but alignment {$required} is required\n+const_eval_already_reported =\n+    an error has already been reported elsewhere (this should not usually be printed)\n+const_eval_assume_false =\n+    `assume` called with `false`\n+\n+const_eval_await_non_const =\n+    cannot convert `{$ty}` into a future in {const_eval_const_context}s\n+const_eval_bounds_check_failed =\n+    indexing out of bounds: the len is {$len} but the index is {$index}\n+const_eval_box_to_mut = {$front_matter}: encountered a box pointing to mutable memory in a constant\n+const_eval_box_to_static = {$front_matter}: encountered a box pointing to a static variable in a constant\n+const_eval_box_to_uninhabited = {$front_matter}: encountered a box pointing to uninhabited type {$ty}\n+const_eval_call_nonzero_intrinsic =\n+    `{$name}` called on 0\n+\n+const_eval_closure_call =\n+    closures need an RFC before allowed to be called in {const_eval_const_context}s\n+const_eval_closure_fndef_not_const =\n+    function defined here, but it is not `const`\n+const_eval_closure_non_const =\n+    cannot call non-const closure in {const_eval_const_context}s\n+const_eval_consider_dereferencing =\n+    consider dereferencing here\n+const_eval_const_accesses_static = constant accesses static\n+\n+const_eval_const_context = {$kind ->\n+    [const] constant\n+    [static] static\n+    [const_fn] constant function\n+    *[other] {\"\"}\n+}\n+\n+const_eval_copy_nonoverlapping_overlapping =\n+    `copy_nonoverlapping` called on overlapping ranges\n+\n+const_eval_dangling_box_no_provenance = {$front_matter}: encountered a dangling box ({$pointer} has no provenance)\n+const_eval_dangling_box_out_of_bounds = {$front_matter}: encountered a dangling box (going beyond the bounds of its allocation)\n+const_eval_dangling_box_use_after_free = {$front_matter}: encountered a dangling box (use-after-free)\n+const_eval_dangling_int_pointer =\n+    {$bad_pointer_message}: {$pointer} is a dangling pointer (it has no provenance)\n+const_eval_dangling_null_pointer =\n+    {$bad_pointer_message}: null pointer is a dangling pointer (it has no provenance)\n+const_eval_dangling_ptr_in_final = encountered dangling pointer in final constant\n+\n+const_eval_dangling_ref_no_provenance = {$front_matter}: encountered a dangling reference ({$pointer} has no provenance)\n+const_eval_dangling_ref_out_of_bounds = {$front_matter}: encountered a dangling reference (going beyond the bounds of its allocation)\n+const_eval_dangling_ref_use_after_free = {$front_matter}: encountered a dangling reference (use-after-free)\n+const_eval_dead_local =\n+    accessing a dead local variable\n+const_eval_dealloc_immutable =\n+    deallocating immutable allocation {$alloc}\n+\n+const_eval_dealloc_incorrect_layout =\n+    incorrect layout on deallocation: {$alloc} has size {$size} and alignment {$align}, but gave size {$size_found} and alignment {$align_found}\n+\n+const_eval_dealloc_kind_mismatch =\n+    deallocating {$alloc}, which is {$alloc_kind} memory, using {$kind} deallocation operation\n+\n+const_eval_deref_coercion_non_const =\n+    cannot perform deref coercion on `{$ty}` in {const_eval_const_context}s\n+    .note = attempting to deref into `{$target_ty}`\n+    .target_note = deref defined here\n+const_eval_deref_function_pointer =\n+    accessing {$allocation} which contains a function\n+const_eval_deref_test = dereferencing pointer failed\n+const_eval_deref_vtable_pointer =\n+    accessing {$allocation} which contains a vtable\n+const_eval_different_allocations =\n+    `{$name}` called on pointers into different allocations\n+\n+const_eval_division_by_zero =\n+    dividing by zero\n+const_eval_division_overflow =\n+    overflow in signed division (dividing MIN by -1)\n+const_eval_double_storage_live =\n+    StorageLive on a local that was already live\n+\n+const_eval_dyn_call_not_a_method =\n+    `dyn` call trying to call something that is not a method\n+\n+const_eval_dyn_call_vtable_mismatch =\n+    `dyn` call on a pointer whose vtable does not match its type\n+\n+const_eval_dyn_star_call_vtable_mismatch =\n+    `dyn*` call on a pointer whose vtable does not match its type\n+\n+const_eval_erroneous_constant =\n+    erroneous constant used\n+\n+const_eval_error = {$error_kind ->\n+    [static] could not evaluate static initializer\n+    [const] evaluation of constant value failed\n+    [const_with_path] evaluation of `{$instance}` failed\n+    *[other] {\"\"}\n+}\n+\n+const_eval_exact_div_has_remainder =\n+    exact_div: {$a} cannot be divided by {$b} without remainder\n+\n+const_eval_expected_non_ptr = {$front_matter}: encountered `{$value}`, but expected plain (non-pointer) bytes\n+const_eval_fn_ptr_call =\n+    function pointers need an RFC before allowed to be called in {const_eval_const_context}s\n+const_eval_for_loop_into_iter_non_const =\n+    cannot convert `{$ty}` into an iterator in {const_eval_const_context}s\n+\n+const_eval_frame_note = {$times ->\n+    [0] {const_eval_frame_note_inner}\n+    *[other] [... {$times} additional calls {const_eval_frame_note_inner} ...]\n+}\n+\n+const_eval_frame_note_inner = inside {$where_ ->\n+    [closure] closure\n+    [instance] `{$instance}`\n+    *[other] {\"\"}\n+}\n+\n+const_eval_in_bounds_test = out-of-bounds pointer use\n+const_eval_incompatible_calling_conventions =\n+    calling a function with calling convention {$callee_conv} using calling convention {$caller_conv}\n+\n+const_eval_incompatible_return_types =\n+    calling a function with return type {$callee_ty} passing return place of type {$caller_ty}\n+\n+const_eval_incompatible_types =\n+    calling a function with argument of type {$callee_ty} passing data of type {$caller_ty}\n+\n const_eval_interior_mutability_borrow =\n     cannot borrow here, since the borrowed element may contain interior mutability\n \n const_eval_interior_mutable_data_refer =\n-    {$kind}s cannot refer to interior mutable data\n+    {const_eval_const_context}s cannot refer to interior mutable data\n     .label = this borrow of an interior mutable value may end up in the final value\n     .help = to fix this, the value can be extracted to a separate `static` item and then referenced\n     .teach_note =\n         A constant containing interior mutable data behind a reference can allow you to modify that data.\n         This would make multiple uses of a constant to be able to see different values and allow circumventing\n         the `Send` and `Sync` requirements for shared mutable data, which is unsound.\n \n+const_eval_invalid_align =\n+    align has to be a power of 2\n+\n+const_eval_invalid_align_details =\n+    invalid align passed to `{$name}`: {$align} is {$err_kind ->\n+        [not_power_of_two] not a power of 2\n+        [too_large] too large\n+        *[other] {\"\"}\n+    }\n+\n+const_eval_invalid_bool =\n+    interpreting an invalid 8-bit value as a bool: 0x{$value}\n+const_eval_invalid_box_meta = {$front_matter}: encountered invalid box metadata: total size is bigger than largest supported object\n+const_eval_invalid_box_slice_meta = {$front_matter}: encountered invalid box metadata: slice is bigger than largest supported object\n+const_eval_invalid_char =\n+    interpreting an invalid 32-bit value as a char: 0x{$value}\n+const_eval_invalid_dealloc =\n+    deallocating {$alloc_id}, which is {$kind ->\n+        [fn] a function\n+        [vtable] a vtable\n+        [static_mem] static memory\n+        *[other] {\"\"}\n+    }\n+\n+const_eval_invalid_enum_tag = {$front_matter}: encountered {$value}, but expected a valid enum tag\n+const_eval_invalid_fn_ptr = {$front_matter}: encountered {$value}, but expected a function pointer\n+const_eval_invalid_function_pointer =\n+    using {$pointer} as function pointer but it does not point to a function\n+const_eval_invalid_meta =\n+    invalid metadata in wide pointer: total size is bigger than largest supported object\n+const_eval_invalid_meta_slice =\n+    invalid metadata in wide pointer: slice is bigger than largest supported object\n+const_eval_invalid_ref_meta = {$front_matter}: encountered invalid reference metadata: total size is bigger than largest supported object\n+const_eval_invalid_ref_slice_meta = {$front_matter}: encountered invalid reference metadata: slice is bigger than largest supported object\n+const_eval_invalid_str =\n+    this string is not valid UTF-8: {$err}\n+const_eval_invalid_tag =\n+    enum value has invalid tag: {$tag}\n+const_eval_invalid_transmute =\n+    transmuting from {$src_bytes}-byte type to {$dest_bytes}-byte type: `{$src}` -> `{$dest}`\n+\n+const_eval_invalid_uninit_bytes =\n+    reading memory at {$alloc}{$access}, but memory is uninitialized at {$uninit}, and this operation requires initialized memory\n+const_eval_invalid_uninit_bytes_unknown =\n+    using uninitialized data, but this operation requires initialized memory\n+const_eval_invalid_value = constructing invalid value\n+const_eval_invalid_value_with_path = constructing invalid value at {$path}\n+## The `front_matter`s here refer to either `middle_invalid_value` or `middle_invalid_value_with_path`.\n+\n+const_eval_invalid_vtable_pointer =\n+    using {$pointer} as vtable pointer but it does not point to a vtable\n+\n+const_eval_invalid_vtable_ptr = {$front_matter}: encountered {$value}, but expected a vtable pointer\n+\n+const_eval_live_drop =\n+    destructor of `{$dropped_ty}` cannot be evaluated at compile-time\n+    .label = the destructor for this type cannot be evaluated in {const_eval_const_context}s\n+    .dropped_at_label = value is dropped here\n+\n+const_eval_long_running =\n+    constant evaluation is taking a long time\n+    .note = this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.\n+        If your compilation actually takes a long time, you can safely allow the lint.\n+    .label = the const evaluator is currently interpreting this expression\n+    .help = the constant being evaluated\n+\n const_eval_max_num_nodes_in_const = maximum number of nodes exceeded in constant {$global_const_id}\n \n+const_eval_memory_access_test = memory access failed\n+const_eval_memory_exhausted =\n+    tried to allocate more memory than available to compiler\n+const_eval_modified_global =\n+    modifying a static's initial value from another static's initializer\n+\n const_eval_mut_deref =\n-    mutation through a reference is not allowed in {$kind}s\n+    mutation through a reference is not allowed in {const_eval_const_context}s\n \n+const_eval_mutable_ref_in_const = {$front_matter}: encountered mutable reference in a `const`\n+const_eval_never_val = {$front_matter}: encountered a value of the never type `!`\n const_eval_non_const_fmt_macro_call =\n-    cannot call non-const formatting macro in {$kind}s\n+    cannot call non-const formatting macro in {const_eval_const_context}s\n \n const_eval_non_const_fn_call =\n-    cannot call non-const fn `{$def_path_str}` in {$kind}s\n+    cannot call non-const fn `{$def_path_str}` in {const_eval_const_context}s\n+\n+const_eval_non_const_impl =\n+    impl defined here, but it is not `const`\n+\n+const_eval_noreturn_asm_returned =\n+    returned from noreturn inline assembly\n+\n+const_eval_not_enough_caller_args =\n+    calling a function with fewer arguments than it requires\n+\n+const_eval_null_box = {$front_matter}: encountered a null box\n+const_eval_null_fn_ptr = {$front_matter}: encountered a null function pointer\n+const_eval_null_ref = {$front_matter}: encountered a null reference\n+const_eval_nullable_ptr_out_of_range = {$front_matter}: encountered a potentially null pointer, but expected something that cannot possibly fail to be {$in_range}\n+const_eval_nullary_intrinsic_fail =\n+    could not evaluate nullary intrinsic\n+\n+const_eval_offset_from_overflow =\n+    `{$name}` called when first pointer is too far ahead of second\n+\n+const_eval_offset_from_test = out-of-bounds `offset_from`\n+const_eval_offset_from_underflow =\n+    `{$name}` called when first pointer is too far before second\n+\n+const_eval_operator_non_const =\n+    cannot call non-const operator in {const_eval_const_context}s\n+const_eval_out_of_range = {$front_matter}: encountered {$value}, but expected something {$in_range}\n+const_eval_overflow =\n+    overflow executing `{$name}`\n+\n+const_eval_overflow_shift =\n+    overflowing shift by {$val} in `{$name}`\n+\n+const_eval_panic =\n+    the evaluated program panicked at '{$msg}', {$file}:{$line}:{$col}\n \n const_eval_panic_non_str = argument to `panic!()` in a const context must have type `&str`\n \n+const_eval_partial_pointer_copy =\n+    unable to copy parts of a pointer from memory at {$ptr}\n+const_eval_partial_pointer_overwrite =\n+    unable to overwrite parts of a pointer in memory at {$ptr}\n+const_eval_pointer_arithmetic_overflow =\n+    overflowing in-bounds pointer arithmetic\n+const_eval_pointer_arithmetic_test = out-of-bounds pointer arithmetic\n+const_eval_pointer_out_of_bounds =\n+    {$bad_pointer_message}: {$alloc_id} has size {$alloc_size}, so pointer to {$ptr_size} {$ptr_size ->\n+        [1] byte\n+        *[many] bytes\n+    } starting at offset {$ptr_offset} is out-of-bounds\n+const_eval_pointer_use_after_free =\n+    pointer to {$allocation} was dereferenced after this allocation got freed\n+const_eval_ptr_as_bytes_1 =\n+    this code performed an operation that depends on the underlying bytes representing a pointer\n+const_eval_ptr_as_bytes_2 =\n+    the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+const_eval_ptr_out_of_range = {$front_matter}: encountered a pointer, but expected something that cannot possibly fail to be {$in_range}\n+const_eval_question_branch_non_const =\n+    `?` cannot determine the branch of `{$ty}` in {const_eval_const_context}s\n+\n+const_eval_question_from_residual_non_const =\n+    `?` cannot convert from residual of `{$ty}` in {const_eval_const_context}s\n+\n+const_eval_range = in the range {$lo}..={$hi}\n+const_eval_range_lower = greater or equal to {$lo}\n+const_eval_range_singular = equal to {$lo}\n+const_eval_range_upper = less or equal to {$hi}\n+const_eval_range_wrapping = less or equal to {$hi}, or greater or equal to {$lo}\n+const_eval_raw_bytes = the raw bytes of the constant (size: {$size}, align: {$align}) {\"{\"}{$bytes}{\"}\"}\n+\n+const_eval_raw_eq_with_provenance =\n+    `raw_eq` on bytes with provenance\n+\n const_eval_raw_ptr_comparison =\n     pointers cannot be reliably compared during const eval\n     .note = see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n@@ -32,44 +310,79 @@ const_eval_raw_ptr_to_int =\n     .note = at compile-time, pointers do not have an integer value\n     .note2 = avoiding this restriction via `transmute`, `union`, or raw pointers leads to compile-time undefined behavior\n \n+const_eval_read_extern_static =\n+    cannot read from extern static ({$did})\n+const_eval_read_pointer_as_bytes =\n+    unable to turn pointer into raw bytes\n+const_eval_realloc_or_alloc_with_offset =\n+    {$kind ->\n+        [dealloc] deallocating\n+        [realloc] reallocating\n+        *[other] {\"\"}\n+    } {$ptr} which does not point to the beginning of an object\n+\n+const_eval_ref_to_mut = {$front_matter}: encountered a reference pointing to mutable memory in a constant\n+const_eval_ref_to_static = {$front_matter}: encountered a reference pointing to a static variable in a constant\n+const_eval_ref_to_uninhabited = {$front_matter}: encountered a reference pointing to uninhabited type {$ty}\n+const_eval_remainder_by_zero =\n+    calculating the remainder with a divisor of zero\n+const_eval_remainder_overflow =\n+    overflow in signed remainder (dividing MIN by -1)\n+const_eval_scalar_size_mismatch =\n+    scalar size mismatch: expected {$target_size} bytes but got {$data_size} bytes instead\n+const_eval_size_of_unsized =\n+    size_of called on unsized type `{$ty}`\n+const_eval_size_overflow =\n+    overflow computing total size of `{$name}`\n+\n+const_eval_stack_frame_limit_reached =\n+    reached the configured maximum number of stack frames\n+\n const_eval_static_access =\n-    {$kind}s cannot refer to statics\n+    {const_eval_const_context}s cannot refer to statics\n     .help = consider extracting the value of the `static` to a `const`, and referring to that\n     .teach_note = `static` and `const` variables can refer to other `const` variables. A `const` variable, however, cannot refer to a `static` variable.\n     .teach_help = To fix this, the value can be extracted to a `const` and then used.\n \n const_eval_thread_local_access =\n     thread-local statics cannot be accessed at compile-time\n \n-const_eval_transient_mut_borrow = mutable references are not allowed in {$kind}s\n+const_eval_thread_local_static =\n+    cannot access thread local static ({$did})\n+const_eval_too_generic =\n+    encountered overly generic constant\n+const_eval_too_many_caller_args =\n+    calling a function with more arguments than it expected\n \n-const_eval_transient_mut_borrow_raw = raw mutable references are not allowed in {$kind}s\n+const_eval_transient_mut_borrow = mutable references are not allowed in {const_eval_const_context}s\n \n-const_eval_unallowed_fn_pointer_call = function pointer calls are not allowed in {$kind}s\n+const_eval_transient_mut_borrow_raw = raw mutable references are not allowed in {const_eval_const_context}s\n+\n+const_eval_try_block_from_output_non_const =\n+    `try` block cannot convert `{$ty}` to the result in {const_eval_const_context}s\n+const_eval_unaligned_box = {$front_matter}: encountered an unaligned box (required {$required_bytes} byte alignment but found {$found_bytes})\n+const_eval_unaligned_ref = {$front_matter}: encountered an unaligned reference (required {$required_bytes} byte alignment but found {$found_bytes})\n+const_eval_unallowed_fn_pointer_call = function pointer calls are not allowed in {const_eval_const_context}s\n \n const_eval_unallowed_heap_allocations =\n-    allocations are not allowed in {$kind}s\n-    .label = allocation not allowed in {$kind}s\n+    allocations are not allowed in {const_eval_const_context}s\n+    .label = allocation not allowed in {const_eval_const_context}s\n     .teach_note =\n         The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.\n \n const_eval_unallowed_inline_asm =\n-    inline assembly is not allowed in {$kind}s\n-\n+    inline assembly is not allowed in {const_eval_const_context}s\n const_eval_unallowed_mutable_refs =\n-    mutable references are not allowed in the final value of {$kind}s\n+    mutable references are not allowed in the final value of {const_eval_const_context}s\n     .teach_note =\n-        References in statics and constants may only refer to immutable values.\n-\n-\n         Statics are shared everywhere, and if they refer to mutable data one might violate memory\n         safety since holding multiple mutable references to shared data is not allowed.\n \n \n         If you really want global mutable state, try using static mut or a global UnsafeCell.\n \n const_eval_unallowed_mutable_refs_raw =\n-    raw mutable references are not allowed in the final value of {$kind}s\n+    raw mutable references are not allowed in the final value of {const_eval_const_context}s\n     .teach_note =\n         References in statics and constants may only refer to immutable values.\n \n@@ -83,9 +396,59 @@ const_eval_unallowed_mutable_refs_raw =\n const_eval_unallowed_op_in_const_context =\n     {$msg}\n \n+const_eval_undefined_behavior =\n+    it is undefined behavior to use this value\n+\n+const_eval_undefined_behavior_note =\n+    The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+const_eval_uninhabited_enum_variant_written =\n+    writing discriminant of an uninhabited enum\n+const_eval_uninhabited_val = {$front_matter}: encountered a value of uninhabited type `{$ty}`\n+const_eval_uninit = {$front_matter}: encountered uninitialized bytes\n+const_eval_uninit_bool = {$front_matter}: encountered uninitialized memory, but expected a boolean\n+const_eval_uninit_box = {$front_matter}: encountered uninitialized memory, but expected a box\n+const_eval_uninit_char = {$front_matter}: encountered uninitialized memory, but expected a unicode scalar value\n+const_eval_uninit_enum_tag = {$front_matter}: encountered uninitialized bytes, but expected a valid enum tag\n+const_eval_uninit_float = {$front_matter}: encountered uninitialized memory, but expected a floating point number\n+const_eval_uninit_fn_ptr = {$front_matter}: encountered uninitialized memory, but expected a function pointer\n+const_eval_uninit_init_scalar = {$front_matter}: encountered uninitialized memory, but expected initialized scalar value\n+const_eval_uninit_int = {$front_matter}: encountered uninitialized memory, but expected an integer\n+const_eval_uninit_raw_ptr = {$front_matter}: encountered uninitialized memory, but expected a raw pointer\n+const_eval_uninit_ref = {$front_matter}: encountered uninitialized memory, but expected a reference\n+const_eval_uninit_str = {$front_matter}: encountered uninitialized data in `str`\n+const_eval_uninit_unsized_local =\n+    unsized local is used while uninitialized\n+const_eval_unreachable = entering unreachable code\n+const_eval_unreachable_unwind =\n+    unwinding past a stack frame that does not allow unwinding\n+\n+const_eval_unsafe_cell = {$front_matter}: encountered `UnsafeCell` in a `const`\n+const_eval_unsigned_offset_from_overflow =\n+    `ptr_offset_from_unsigned` called when first pointer has smaller offset than second: {$a_offset} < {$b_offset}\n+\n const_eval_unstable_const_fn = `{$def_path}` is not yet stable as a const fn\n \n const_eval_unstable_in_stable =\n     const-stable function cannot use `#[feature({$gate})]`\n     .unstable_sugg = if it is not part of the public API, make this function unstably const\n     .bypass_sugg = otherwise `#[rustc_allow_const_fn_unstable]` can be used to bypass stability checks\n+\n+const_eval_unsupported_untyped_pointer = unsupported untyped pointer in constant\n+    .note = memory only reachable via raw pointers is not supported\n+\n+const_eval_unterminated_c_string =\n+    reading a null-terminated string starting at {$pointer} with no null found before end of allocation\n+\n+const_eval_unwind_past_top =\n+    unwinding past the topmost frame of the stack\n+\n+const_eval_upcast_mismatch =\n+    upcast on a pointer whose vtable does not match its type\n+\n+const_eval_validation_invalid_bool = {$front_matter}: encountered {$value}, but expected a boolean\n+const_eval_validation_invalid_char = {$front_matter}: encountered {$value}, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n+const_eval_write_to_read_only =\n+    writing to {$allocation} which is read-only\n+const_eval_zst_pointer_out_of_bounds =\n+    {$bad_pointer_message}: {$alloc_id} has size {$alloc_size}, so pointer at offset {$ptr_offset} is out-of-bounds"}, {"sha": "7890d878d08fe42743af43cd97e8c3b9fa3064cb", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 136, "deletions": 144, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,17 +1,15 @@\n-use std::error::Error;\n-use std::fmt;\n+use std::mem;\n \n-use rustc_errors::Diagnostic;\n+use rustc_errors::{DiagnosticArgValue, DiagnosticMessage, IntoDiagnostic, IntoDiagnosticArg};\n use rustc_middle::mir::AssertKind;\n-use rustc_middle::query::TyCtxtAt;\n+use rustc_middle::ty::TyCtxt;\n use rustc_middle::ty::{layout::LayoutError, ConstInt};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::source_map::Spanned;\n+use rustc_span::{ErrorGuaranteed, Span, Symbol};\n \n use super::InterpCx;\n-use crate::interpret::{\n-    struct_error, ErrorHandled, FrameInfo, InterpError, InterpErrorInfo, Machine, MachineStopType,\n-    UnsupportedOpInfo,\n-};\n+use crate::errors::{self, FrameNote, ReportErrorExt};\n+use crate::interpret::{ErrorHandled, InterpError, InterpErrorInfo, Machine, MachineStopType};\n \n /// The CTFE machine has some custom error kinds.\n #[derive(Clone, Debug)]\n@@ -23,7 +21,35 @@ pub enum ConstEvalErrKind {\n     Abort(String),\n }\n \n-impl MachineStopType for ConstEvalErrKind {}\n+impl MachineStopType for ConstEvalErrKind {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        use ConstEvalErrKind::*;\n+        match self {\n+            ConstAccessesStatic => const_eval_const_accesses_static,\n+            ModifiedGlobal => const_eval_modified_global,\n+            Panic { .. } => const_eval_panic,\n+            AssertFailure(x) => x.diagnostic_message(),\n+            Abort(msg) => msg.to_string().into(),\n+        }\n+    }\n+    fn add_args(\n+        self: Box<Self>,\n+        adder: &mut dyn FnMut(std::borrow::Cow<'static, str>, DiagnosticArgValue<'static>),\n+    ) {\n+        use ConstEvalErrKind::*;\n+        match *self {\n+            ConstAccessesStatic | ModifiedGlobal | Abort(_) => {}\n+            AssertFailure(kind) => kind.add_args(adder),\n+            Panic { msg, line, col, file } => {\n+                adder(\"msg\".into(), msg.into_diagnostic_arg());\n+                adder(\"file\".into(), file.into_diagnostic_arg());\n+                adder(\"line\".into(), line.into_diagnostic_arg());\n+                adder(\"col\".into(), col.into_diagnostic_arg());\n+            }\n+        }\n+    }\n+}\n \n // The errors become `MachineStop` with plain strings when being raised.\n // `ConstEvalErr` (in `librustc_middle/mir/interpret/error.rs`) knows to\n@@ -34,151 +60,117 @@ impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalErrKind {\n     }\n }\n \n-impl fmt::Display for ConstEvalErrKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use self::ConstEvalErrKind::*;\n-        match self {\n-            ConstAccessesStatic => write!(f, \"constant accesses static\"),\n-            ModifiedGlobal => {\n-                write!(f, \"modifying a static's initial value from another static's initializer\")\n-            }\n-            AssertFailure(msg) => write!(f, \"{:?}\", msg),\n-            Panic { msg, line, col, file } => {\n-                write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)\n-            }\n-            Abort(msg) => write!(f, \"{}\", msg),\n-        }\n-    }\n-}\n-\n-impl Error for ConstEvalErrKind {}\n+pub fn get_span_and_frames<'tcx, 'mir, M: Machine<'mir, 'tcx>>(\n+    ecx: &InterpCx<'mir, 'tcx, M>,\n+) -> (Span, Vec<errors::FrameNote>)\n+where\n+    'tcx: 'mir,\n+{\n+    let mut stacktrace = ecx.generate_stacktrace();\n+    // Filter out `requires_caller_location` frames.\n+    stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(*ecx.tcx));\n+    let span = stacktrace.first().map(|f| f.span).unwrap_or(ecx.tcx.span);\n \n-/// When const-evaluation errors, this type is constructed with the resulting information,\n-/// and then used to emit the error as a lint or hard error.\n-#[derive(Debug)]\n-pub(super) struct ConstEvalErr<'tcx> {\n-    pub span: Span,\n-    pub error: InterpError<'tcx>,\n-    pub stacktrace: Vec<FrameInfo<'tcx>>,\n-}\n+    let mut frames = Vec::new();\n \n-impl<'tcx> ConstEvalErr<'tcx> {\n-    /// Turn an interpreter error into something to report to the user.\n-    /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n-    /// Should be called only if the error is actually going to be reported!\n-    pub fn new<'mir, M: Machine<'mir, 'tcx>>(\n-        ecx: &InterpCx<'mir, 'tcx, M>,\n-        error: InterpErrorInfo<'tcx>,\n-        span: Option<Span>,\n-    ) -> ConstEvalErr<'tcx>\n-    where\n-        'tcx: 'mir,\n-    {\n-        error.print_backtrace();\n-        let mut stacktrace = ecx.generate_stacktrace();\n-        // Filter out `requires_caller_location` frames.\n-        stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(*ecx.tcx));\n-        // If `span` is missing, use topmost remaining frame, or else the \"root\" span from `ecx.tcx`.\n-        let span = span.or_else(|| stacktrace.first().map(|f| f.span)).unwrap_or(ecx.tcx.span);\n-        ConstEvalErr { error: error.into_kind(), stacktrace, span }\n-    }\n-\n-    pub(super) fn report(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n-        self.report_decorated(tcx, message, |_| {})\n-    }\n-\n-    #[instrument(level = \"trace\", skip(self, decorate))]\n-    pub(super) fn decorate(&self, err: &mut Diagnostic, decorate: impl FnOnce(&mut Diagnostic)) {\n-        trace!(\"reporting const eval failure at {:?}\", self.span);\n-        // Add some more context for select error types.\n-        match self.error {\n-            InterpError::Unsupported(\n-                UnsupportedOpInfo::ReadPointerAsBytes\n-                | UnsupportedOpInfo::PartialPointerOverwrite(_)\n-                | UnsupportedOpInfo::PartialPointerCopy(_),\n-            ) => {\n-                err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n-                err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n+    // Add notes to the backtrace. Don't print a single-line backtrace though.\n+    if stacktrace.len() > 1 {\n+        // Helper closure to print duplicated lines.\n+        let mut add_frame = |mut frame: errors::FrameNote| {\n+            frames.push(errors::FrameNote { times: 0, ..frame.clone() });\n+            // Don't print [... additional calls ...] if the number of lines is small\n+            if frame.times < 3 {\n+                let times = frame.times;\n+                frame.times = 0;\n+                frames.extend(std::iter::repeat(frame).take(times as usize));\n+            } else {\n+                frames.push(frame);\n             }\n-            _ => {}\n-        }\n-        // Add spans for the stacktrace. Don't print a single-line backtrace though.\n-        if self.stacktrace.len() > 1 {\n-            // Helper closure to print duplicated lines.\n-            let mut flush_last_line = |last_frame: Option<(String, _)>, times| {\n-                if let Some((line, span)) = last_frame {\n-                    err.span_note(span, line.clone());\n-                    // Don't print [... additional calls ...] if the number of lines is small\n-                    if times < 3 {\n-                        for _ in 0..times {\n-                            err.span_note(span, line.clone());\n-                        }\n-                    } else {\n-                        err.span_note(\n-                            span,\n-                            format!(\"[... {} additional calls {} ...]\", times, &line),\n-                        );\n-                    }\n-                }\n-            };\n+        };\n \n-            let mut last_frame = None;\n-            let mut times = 0;\n-            for frame_info in &self.stacktrace {\n-                let frame = (frame_info.to_string(), frame_info.span);\n-                if last_frame.as_ref() == Some(&frame) {\n-                    times += 1;\n-                } else {\n-                    flush_last_line(last_frame, times);\n+        let mut last_frame: Option<errors::FrameNote> = None;\n+        for frame_info in &stacktrace {\n+            let frame = frame_info.as_note(*ecx.tcx);\n+            match last_frame.as_mut() {\n+                Some(last_frame)\n+                    if last_frame.span == frame.span\n+                        && last_frame.where_ == frame.where_\n+                        && last_frame.instance == frame.instance =>\n+                {\n+                    last_frame.times += 1;\n+                }\n+                Some(last_frame) => {\n+                    add_frame(mem::replace(last_frame, frame));\n+                }\n+                None => {\n                     last_frame = Some(frame);\n-                    times = 0;\n                 }\n             }\n-            flush_last_line(last_frame, times);\n         }\n-        // Let the caller attach any additional information it wants.\n-        decorate(err);\n+        if let Some(frame) = last_frame {\n+            add_frame(frame);\n+        }\n     }\n \n-    /// Create a diagnostic for this const eval error.\n-    ///\n-    /// Sets the message passed in via `message` and adds span labels with detailed error\n-    /// information before handing control back to `decorate` to do any final annotations,\n-    /// after which the diagnostic is emitted.\n-    ///\n-    /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n-    /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n-    #[instrument(skip(self, tcx, decorate), level = \"debug\")]\n-    pub(super) fn report_decorated(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        decorate: impl FnOnce(&mut Diagnostic),\n-    ) -> ErrorHandled {\n-        debug!(\"self.error: {:?}\", self.error);\n-        // Special handling for certain errors\n-        match &self.error {\n-            // Don't emit a new diagnostic for these errors\n-            err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n-                ErrorHandled::TooGeneric\n-            }\n-            err_inval!(AlreadyReported(error_reported)) => ErrorHandled::Reported(*error_reported),\n-            err_inval!(Layout(LayoutError::SizeOverflow(_))) => {\n-                // We must *always* hard error on these, even if the caller wants just a lint.\n-                // The `message` makes little sense here, this is a more serious error than the\n-                // caller thinks anyway.\n-                // See <https://github.com/rust-lang/rust/pull/63152>.\n-                let mut err = struct_error(tcx, &self.error.to_string());\n-                self.decorate(&mut err, decorate);\n-                ErrorHandled::Reported(err.emit().into())\n-            }\n-            _ => {\n-                // Report as hard error.\n-                let mut err = struct_error(tcx, message);\n-                err.span_label(self.span, self.error.to_string());\n-                self.decorate(&mut err, decorate);\n-                ErrorHandled::Reported(err.emit().into())\n+    (span, frames)\n+}\n+\n+/// Create a diagnostic for a const eval error.\n+///\n+/// This will use the `mk` function for creating the error which will get passed labels according to\n+/// the `InterpError` and the span and a stacktrace of current execution according to\n+/// `get_span_and_frames`.\n+pub(super) fn report<'tcx, C, F, E>(\n+    tcx: TyCtxt<'tcx>,\n+    error: InterpError<'tcx>,\n+    span: Option<Span>,\n+    get_span_and_frames: C,\n+    mk: F,\n+) -> ErrorHandled\n+where\n+    C: FnOnce() -> (Span, Vec<FrameNote>),\n+    F: FnOnce(Span, Vec<FrameNote>) -> E,\n+    E: IntoDiagnostic<'tcx, ErrorGuaranteed>,\n+{\n+    // Special handling for certain errors\n+    match error {\n+        // Don't emit a new diagnostic for these errors\n+        err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n+            ErrorHandled::TooGeneric\n+        }\n+        err_inval!(AlreadyReported(error_reported)) => ErrorHandled::Reported(error_reported),\n+        err_inval!(Layout(layout_error @ LayoutError::SizeOverflow(_))) => {\n+            // We must *always* hard error on these, even if the caller wants just a lint.\n+            // The `message` makes little sense here, this is a more serious error than the\n+            // caller thinks anyway.\n+            // See <https://github.com/rust-lang/rust/pull/63152>.\n+            let (our_span, frames) = get_span_and_frames();\n+            let span = span.unwrap_or(our_span);\n+            let mut err =\n+                tcx.sess.create_err(Spanned { span, node: layout_error.into_diagnostic() });\n+            err.code(rustc_errors::error_code!(E0080));\n+            let Some((mut err, handler)) = err.into_diagnostic() else {\n+                    panic!(\"did not emit diag\");\n+                };\n+            for frame in frames {\n+                err.eager_subdiagnostic(handler, frame);\n             }\n+\n+            ErrorHandled::Reported(handler.emit_diagnostic(&mut err).unwrap().into())\n+        }\n+        _ => {\n+            // Report as hard error.\n+            let (our_span, frames) = get_span_and_frames();\n+            let span = span.unwrap_or(our_span);\n+            let err = mk(span, frames);\n+            let mut err = tcx.sess.create_err(err);\n+\n+            let msg = error.diagnostic_message();\n+            error.add_args(&tcx.sess.parse_sess.span_diagnostic, &mut err);\n+\n+            // Use *our* span to label the interp error\n+            err.span_label(our_span, msg);\n+            ErrorHandled::Reported(err.emit().into())\n         }\n     }\n }"}, {"sha": "8b8e8ff58e9072015a220d5c38c7f9af6585c39c", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 64, "deletions": 36, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,31 +1,28 @@\n use crate::const_eval::CheckAlignment;\n-use std::borrow::Cow;\n+use crate::errors::ConstEvalError;\n \n use either::{Left, Right};\n \n use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::mir::pretty::display_allocation;\n+use rustc_middle::mir::interpret::{ErrorHandled, InterpErrorInfo};\n+use rustc_middle::mir::pretty::write_allocation_bytes;\n use rustc_middle::traits::Reveal;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::source_map::Span;\n use rustc_target::abi::{self, Abi};\n \n-use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n+use super::{CompileTimeEvalContext, CompileTimeInterpreter};\n+use crate::errors;\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n     Immediate, InternKind, InterpCx, InterpError, InterpResult, MPlaceTy, MemoryKind, OpTy,\n     RefTracking, StackPopCleanup,\n };\n \n-const NOTE_ON_UNDEFINED_BEHAVIOR_ERROR: &str = \"The rules on what exactly is undefined behavior aren't clear, \\\n-     so this check might be overzealous. Please open an issue on the rustc \\\n-     repository if you believe it should not be considered undefined behavior.\";\n-\n // Returns a pointer to where the result lives\n fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n@@ -103,7 +100,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n         tcx,\n         root_span,\n         param_env,\n-        CompileTimeInterpreter::new(tcx.const_eval_limit(), can_access_statics, CheckAlignment::No),\n+        CompileTimeInterpreter::new(can_access_statics, CheckAlignment::No),\n     )\n }\n \n@@ -253,8 +250,14 @@ pub fn eval_to_const_value_raw_provider<'tcx>(\n         };\n         return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs).map_err(|error| {\n             let span = tcx.def_span(def_id);\n-            let error = ConstEvalErr { error: error.into_kind(), stacktrace: vec![], span };\n-            error.report(tcx.at(span), \"could not evaluate nullary intrinsic\")\n+\n+            super::report(\n+                tcx,\n+                error.into_kind(),\n+                Some(span),\n+                || (span, vec![]),\n+                |span, _| errors::NullaryIntrinsicError { span },\n+            )\n         });\n     }\n \n@@ -306,7 +309,6 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n         // Statics (and promoteds inside statics) may access other statics, because unlike consts\n         // they do not have to behave \"as if\" they were evaluated at runtime.\n         CompileTimeInterpreter::new(\n-            tcx.const_eval_limit(),\n             /*can_access_statics:*/ is_static,\n             if tcx.sess.opts.unstable_opts.extra_const_ub_checks {\n                 CheckAlignment::Error\n@@ -319,29 +321,41 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     match res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body)) {\n         Err(error) => {\n-            let err = ConstEvalErr::new(&ecx, error, None);\n-            let msg = if is_static {\n-                Cow::from(\"could not evaluate static initializer\")\n+            let (error, backtrace) = error.into_parts();\n+            backtrace.print_backtrace();\n+\n+            let (kind, instance) = if is_static {\n+                (\"static\", String::new())\n             } else {\n                 // If the current item has generics, we'd like to enrich the message with the\n                 // instance and its substs: to show the actual compile-time values, in addition to\n                 // the expression, leading to the const eval error.\n                 let instance = &key.value.instance;\n                 if !instance.substs.is_empty() {\n                     let instance = with_no_trimmed_paths!(instance.to_string());\n-                    let msg = format!(\"evaluation of `{}` failed\", instance);\n-                    Cow::from(msg)\n+                    (\"const_with_path\", instance)\n                 } else {\n-                    Cow::from(\"evaluation of constant value failed\")\n+                    (\"const\", String::new())\n                 }\n             };\n \n-            Err(err.report(ecx.tcx.at(err.span), &msg))\n+            Err(super::report(\n+                *ecx.tcx,\n+                error,\n+                None,\n+                || super::get_span_and_frames(&ecx),\n+                |span, frames| ConstEvalError {\n+                    span,\n+                    error_kind: kind,\n+                    instance,\n+                    frame_notes: frames,\n+                },\n+            ))\n         }\n         Ok(mplace) => {\n             // Since evaluation had no errors, validate the resulting constant.\n             // This is a separate `try` block to provide more targeted error reporting.\n-            let validation = try {\n+            let validation: Result<_, InterpErrorInfo<'_>> = try {\n                 let mut ref_tracking = RefTracking::new(mplace);\n                 let mut inner = false;\n                 while let Some((mplace, path)) = ref_tracking.todo.pop() {\n@@ -358,23 +372,37 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                 }\n             };\n             let alloc_id = mplace.ptr.provenance.unwrap();\n+\n+            // Validation failed, report an error. This is always a hard error.\n             if let Err(error) = validation {\n-                // Validation failed, report an error. This is always a hard error.\n-                let err = ConstEvalErr::new(&ecx, error, None);\n-                Err(err.report_decorated(\n-                    ecx.tcx,\n-                    \"it is undefined behavior to use this value\",\n-                    |diag| {\n-                        if matches!(err.error, InterpError::UndefinedBehavior(_)) {\n-                            diag.note(NOTE_ON_UNDEFINED_BEHAVIOR_ERROR);\n-                        }\n-                        diag.note(format!(\n-                            \"the raw bytes of the constant ({}\",\n-                            display_allocation(\n-                                *ecx.tcx,\n-                                ecx.tcx.global_alloc(alloc_id).unwrap_memory().inner()\n-                            )\n-                        ));\n+                let (error, backtrace) = error.into_parts();\n+                backtrace.print_backtrace();\n+\n+                let ub_note = matches!(error, InterpError::UndefinedBehavior(_)).then(|| {});\n+\n+                let alloc = ecx.tcx.global_alloc(alloc_id).unwrap_memory().inner();\n+                let mut bytes = String::new();\n+                if alloc.size() != abi::Size::ZERO {\n+                    bytes = \"\\n\".into();\n+                    // FIXME(translation) there might be pieces that are translatable.\n+                    write_allocation_bytes(*ecx.tcx, alloc, &mut bytes, \"    \").unwrap();\n+                }\n+                let raw_bytes = errors::RawBytesNote {\n+                    size: alloc.size().bytes(),\n+                    align: alloc.align.bytes(),\n+                    bytes,\n+                };\n+\n+                Err(super::report(\n+                    *ecx.tcx,\n+                    error,\n+                    None,\n+                    || super::get_span_and_frames(&ecx),\n+                    move |span, frames| errors::UndefinedBehavior {\n+                        span,\n+                        ub_note,\n+                        frames,\n+                        raw_bytes,\n                     },\n                 ))\n             } else {"}, {"sha": "7391f5670400aac056402fe59542f524b3681a99", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 92, "deletions": 27, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -16,25 +16,37 @@ use std::fmt;\n use rustc_ast::Mutability;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::AssertMessage;\n-use rustc_session::Limit;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::{Align, Size};\n use rustc_target::spec::abi::Abi as CallAbi;\n \n+use crate::errors::{LongRunning, LongRunningWarn};\n use crate::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, FnVal, Frame, ImmTy, InterpCx,\n     InterpResult, OpTy, PlaceTy, Pointer, Scalar,\n };\n+use crate::{errors, fluent_generated as fluent};\n \n use super::error::*;\n \n+/// When hitting this many interpreted terminators we emit a deny by default lint\n+/// that notfies the user that their constant takes a long time to evaluate. If that's\n+/// what they intended, they can just allow the lint.\n+const LINT_TERMINATOR_LIMIT: usize = 2_000_000;\n+/// The limit used by `-Z tiny-const-eval-limit`. This smaller limit is useful for internal\n+/// tests not needing to run 30s or more to show some behaviour.\n+const TINY_LINT_TERMINATOR_LIMIT: usize = 20;\n+/// After this many interpreted terminators, we start emitting progress indicators at every\n+/// power of two of interpreted terminators.\n+const PROGRESS_INDICATOR_START: usize = 4_000_000;\n+\n /// Extra machine state for CTFE, and the Machine instance\n pub struct CompileTimeInterpreter<'mir, 'tcx> {\n-    /// For now, the number of terminators that can be evaluated before we throw a resource\n-    /// exhaustion error.\n+    /// The number of terminators that have been evaluated.\n     ///\n-    /// Setting this to `0` disables the limit and allows the interpreter to run forever.\n-    pub(super) steps_remaining: usize,\n+    /// This is used to produce lints informing the user that the compiler is not stuck.\n+    /// Set to `usize::MAX` to never report anything.\n+    pub(super) num_evaluated_steps: usize,\n \n     /// The virtual call stack.\n     pub(super) stack: Vec<Frame<'mir, 'tcx, AllocId, ()>>,\n@@ -72,13 +84,9 @@ impl CheckAlignment {\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n-    pub(crate) fn new(\n-        const_eval_limit: Limit,\n-        can_access_statics: bool,\n-        check_alignment: CheckAlignment,\n-    ) -> Self {\n+    pub(crate) fn new(can_access_statics: bool, check_alignment: CheckAlignment) -> Self {\n         CompileTimeInterpreter {\n-            steps_remaining: const_eval_limit.0,\n+            num_evaluated_steps: 0,\n             stack: Vec::new(),\n             can_access_statics,\n             check_alignment,\n@@ -247,7 +255,10 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n         let target_align = self.read_scalar(&args[1])?.to_target_usize(self)?;\n \n         if !target_align.is_power_of_two() {\n-            throw_ub_format!(\"`align_offset` called with non-power-of-two align: {}\", target_align);\n+            throw_ub_custom!(\n+                fluent::const_eval_align_offset_invalid_align,\n+                target_align = target_align,\n+            );\n         }\n \n         match self.ptr_try_get_alloc_id(ptr) {\n@@ -353,15 +364,18 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 \"`alignment_check_failed` called when no alignment check requested\"\n             ),\n             CheckAlignment::FutureIncompat => {\n-                let err = ConstEvalErr::new(ecx, err, None);\n-                ecx.tcx.struct_span_lint_hir(\n+                let (_, backtrace) = err.into_parts();\n+                backtrace.print_backtrace();\n+                let (span, frames) = super::get_span_and_frames(&ecx);\n+\n+                ecx.tcx.emit_spanned_lint(\n                     INVALID_ALIGNMENT,\n                     ecx.stack().iter().find_map(|frame| frame.lint_root()).unwrap_or(CRATE_HIR_ID),\n-                    err.span,\n-                    err.error.to_string(),\n-                    |db| {\n-                        err.decorate(db, |_| {});\n-                        db\n+                    span,\n+                    errors::AlignmentCheckFailed {\n+                        has: has.bytes(),\n+                        required: required.bytes(),\n+                        frames,\n                     },\n                 );\n                 Ok(())\n@@ -475,7 +489,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n                 let align = match Align::from_bytes(align) {\n                     Ok(a) => a,\n-                    Err(err) => throw_ub_format!(\"align has to be a power of 2, {}\", err),\n+                    Err(err) => throw_ub_custom!(\n+                        fluent::const_eval_invalid_align_details,\n+                        name = \"const_allocate\",\n+                        err_kind = err.diag_ident(),\n+                        align = err.align()\n+                    ),\n                 };\n \n                 let ptr = ecx.allocate_ptr(\n@@ -493,7 +512,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 let size = Size::from_bytes(size);\n                 let align = match Align::from_bytes(align) {\n                     Ok(a) => a,\n-                    Err(err) => throw_ub_format!(\"align has to be a power of 2, {}\", err),\n+                    Err(err) => throw_ub_custom!(\n+                        fluent::const_eval_invalid_align_details,\n+                        name = \"const_deallocate\",\n+                        err_kind = err.diag_ident(),\n+                        align = err.align()\n+                    ),\n                 };\n \n                 // If an allocation is created in an another const,\n@@ -569,13 +593,54 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     fn increment_const_eval_counter(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         // The step limit has already been hit in a previous call to `increment_const_eval_counter`.\n-        if ecx.machine.steps_remaining == 0 {\n-            return Ok(());\n-        }\n \n-        ecx.machine.steps_remaining -= 1;\n-        if ecx.machine.steps_remaining == 0 {\n-            throw_exhaust!(StepLimitReached)\n+        if let Some(new_steps) = ecx.machine.num_evaluated_steps.checked_add(1) {\n+            let (limit, start) = if ecx.tcx.sess.opts.unstable_opts.tiny_const_eval_limit {\n+                (TINY_LINT_TERMINATOR_LIMIT, TINY_LINT_TERMINATOR_LIMIT)\n+            } else {\n+                (LINT_TERMINATOR_LIMIT, PROGRESS_INDICATOR_START)\n+            };\n+\n+            ecx.machine.num_evaluated_steps = new_steps;\n+            // By default, we have a *deny* lint kicking in after some time\n+            // to ensure `loop {}` doesn't just go forever.\n+            // In case that lint got reduced, in particular for `--cap-lint` situations, we also\n+            // have a hard warning shown every now and then for really long executions.\n+            if new_steps == limit {\n+                // By default, we stop after a million steps, but the user can disable this lint\n+                // to be able to run until the heat death of the universe or power loss, whichever\n+                // comes first.\n+                let hir_id = ecx.best_lint_scope();\n+                let is_error = ecx\n+                    .tcx\n+                    .lint_level_at_node(\n+                        rustc_session::lint::builtin::LONG_RUNNING_CONST_EVAL,\n+                        hir_id,\n+                    )\n+                    .0\n+                    .is_error();\n+                let span = ecx.cur_span();\n+                ecx.tcx.emit_spanned_lint(\n+                    rustc_session::lint::builtin::LONG_RUNNING_CONST_EVAL,\n+                    hir_id,\n+                    span,\n+                    LongRunning { item_span: ecx.tcx.span },\n+                );\n+                // If this was a hard error, don't bother continuing evaluation.\n+                if is_error {\n+                    let guard = ecx\n+                        .tcx\n+                        .sess\n+                        .delay_span_bug(span, \"The deny lint should have already errored\");\n+                    throw_inval!(AlreadyReported(guard.into()));\n+                }\n+            } else if new_steps > start && new_steps.is_power_of_two() {\n+                // Only report after a certain number of terminators have been evaluated and the\n+                // current number of evaluated terminators is a power of 2. The latter gives us a cheap\n+                // way to implement exponential backoff.\n+                let span = ecx.cur_span();\n+                ecx.tcx.sess.emit_warning(LongRunningWarn { span, item_span: ecx.tcx.span });\n+            }\n         }\n \n         Ok(())"}, {"sha": "6e462d3a1e983418ed9a963689e6ff4693d5c98b", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 3, "deletions": 49, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -2,10 +2,8 @@\n \n use crate::errors::MaxNumNodesInConstErr;\n use crate::interpret::{\n-    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n-    Scalar,\n+    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, Scalar,\n };\n-use rustc_hir::Mutability;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{EvalToValTreeResult, GlobalId};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -75,17 +73,8 @@ pub(crate) fn eval_to_valtree<'tcx>(\n             let global_const_id = cid.display(tcx);\n             match err {\n                 ValTreeCreationError::NodesOverflow => {\n-                    let msg = format!(\n-                        \"maximum number of nodes exceeded in constant {}\",\n-                        &global_const_id\n-                    );\n-                    let mut diag = match tcx.hir().span_if_local(did) {\n-                        Some(span) => {\n-                            tcx.sess.create_err(MaxNumNodesInConstErr { span, global_const_id })\n-                        }\n-                        None => tcx.sess.struct_err(msg),\n-                    };\n-                    diag.emit();\n+                    let span = tcx.hir().span_if_local(did);\n+                    tcx.sess.emit_err(MaxNumNodesInConstErr { span, global_const_id });\n \n                     Ok(None)\n                 }\n@@ -131,38 +120,3 @@ pub(crate) fn try_destructure_mir_constant<'tcx>(\n \n     Ok(mir::DestructuredConstant { variant, fields })\n }\n-\n-#[instrument(skip(tcx), level = \"debug\")]\n-pub(crate) fn deref_mir_constant<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    val: mir::ConstantKind<'tcx>,\n-) -> mir::ConstantKind<'tcx> {\n-    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n-    let op = ecx.eval_mir_constant(&val, None, None).unwrap();\n-    let mplace = ecx.deref_operand(&op).unwrap();\n-    if let Some(alloc_id) = mplace.ptr.provenance {\n-        assert_eq!(\n-            tcx.global_alloc(alloc_id).unwrap_memory().0.0.mutability,\n-            Mutability::Not,\n-            \"deref_mir_constant cannot be used with mutable allocations as \\\n-            that could allow pattern matching to observe mutable statics\",\n-        );\n-    }\n-\n-    let ty = match mplace.meta {\n-        MemPlaceMeta::None => mplace.layout.ty,\n-        // In case of unsized types, figure out the real type behind.\n-        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n-            ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n-            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_target_usize(&tcx).unwrap()),\n-            _ => bug!(\n-                \"type {} should not have metadata, but had {:?}\",\n-                mplace.layout.ty,\n-                mplace.meta\n-            ),\n-        },\n-    };\n-\n-    mir::ConstantKind::Val(op_to_const(&ecx, &mplace.into()), ty)\n-}"}, {"sha": "eed3091d481e3cf3d601571f69635034d489669a", "filename": "compiler/rustc_const_eval/src/errors.rs", "status": "modified", "additions": 674, "deletions": 2, "changes": 676, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,6 +1,24 @@\n+use rustc_errors::{\n+    DiagnosticArgValue, DiagnosticBuilder, DiagnosticMessage, EmissionGuarantee, Handler,\n+    IntoDiagnostic,\n+};\n use rustc_hir::ConstContext;\n-use rustc_macros::Diagnostic;\n+use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_middle::mir::interpret::{\n+    CheckInAllocMsg, ExpectedKind, InterpError, InvalidMetaKind, InvalidProgramInfo, PointerKind,\n+    ResourceExhaustionInfo, UndefinedBehaviorInfo, UnsupportedOpInfo, ValidationErrorInfo,\n+};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n+use rustc_target::abi::call::AdjustForForeignAbiError;\n+use rustc_target::abi::{Size, WrappingRange};\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_dangling_ptr_in_final)]\n+pub(crate) struct DanglingPtrInFinal {\n+    #[primary_span]\n+    pub span: Span,\n+}\n \n #[derive(Diagnostic)]\n #[diag(const_eval_unstable_in_stable)]\n@@ -92,7 +110,7 @@ pub(crate) struct TransientMutBorrowErrRaw {\n #[diag(const_eval_max_num_nodes_in_const)]\n pub(crate) struct MaxNumNodesInConstErr {\n     #[primary_span]\n-    pub span: Span,\n+    pub span: Option<Span>,\n     pub global_const_id: String,\n }\n \n@@ -175,6 +193,14 @@ pub(crate) struct UnallowedInlineAsm {\n     pub kind: ConstContext,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(const_eval_unsupported_untyped_pointer)]\n+#[note]\n+pub(crate) struct UnsupportedUntypedPointer {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(const_eval_interior_mutable_data_refer, code = \"E0492\")]\n pub(crate) struct InteriorMutableDataRefer {\n@@ -194,3 +220,649 @@ pub(crate) struct InteriorMutabilityBorrow {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[diag(const_eval_long_running)]\n+#[note]\n+pub struct LongRunning {\n+    #[help]\n+    pub item_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_long_running)]\n+pub struct LongRunningWarn {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[help]\n+    pub item_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_erroneous_constant)]\n+pub(crate) struct ErroneousConstUsed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(const_eval_non_const_impl)]\n+pub(crate) struct NonConstImplNote {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic, PartialEq, Eq, Clone)]\n+#[note(const_eval_frame_note)]\n+pub struct FrameNote {\n+    #[primary_span]\n+    pub span: Span,\n+    pub times: i32,\n+    pub where_: &'static str,\n+    pub instance: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(const_eval_raw_bytes)]\n+pub struct RawBytesNote {\n+    pub size: u64,\n+    pub align: u64,\n+    pub bytes: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_for_loop_into_iter_non_const, code = \"E0015\")]\n+pub struct NonConstForLoopIntoIter<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_question_branch_non_const, code = \"E0015\")]\n+pub struct NonConstQuestionBranch<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_question_from_residual_non_const, code = \"E0015\")]\n+pub struct NonConstQuestionFromResidual<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_try_block_from_output_non_const, code = \"E0015\")]\n+pub struct NonConstTryBlockFromOutput<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_await_non_const, code = \"E0015\")]\n+pub struct NonConstAwait<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_closure_non_const, code = \"E0015\")]\n+pub struct NonConstClosure {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[subdiagnostic]\n+    pub note: Option<NonConstClosureNote>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum NonConstClosureNote {\n+    #[note(const_eval_closure_fndef_not_const)]\n+    FnDef {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(const_eval_fn_ptr_call)]\n+    FnPtr,\n+    #[note(const_eval_closure_call)]\n+    Closure,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(const_eval_consider_dereferencing, applicability = \"machine-applicable\")]\n+pub struct ConsiderDereferencing {\n+    pub deref: String,\n+    #[suggestion_part(code = \"{deref}\")]\n+    pub span: Span,\n+    #[suggestion_part(code = \"{deref}\")]\n+    pub rhs_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_operator_non_const, code = \"E0015\")]\n+pub struct NonConstOperator {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[subdiagnostic]\n+    pub sugg: Option<ConsiderDereferencing>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_deref_coercion_non_const, code = \"E0015\")]\n+#[note]\n+pub struct NonConstDerefCoercion<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub kind: ConstContext,\n+    pub target_ty: Ty<'tcx>,\n+    #[note(const_eval_target_note)]\n+    pub deref_target: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_live_drop, code = \"E0493\")]\n+pub struct LiveDrop<'tcx> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    pub dropped_ty: Ty<'tcx>,\n+    #[label(const_eval_dropped_at_label)]\n+    pub dropped_at: Option<Span>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(const_eval_align_check_failed)]\n+pub struct AlignmentCheckFailed {\n+    pub has: u64,\n+    pub required: u64,\n+    #[subdiagnostic]\n+    pub frames: Vec<FrameNote>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_error, code = \"E0080\")]\n+pub struct ConstEvalError {\n+    #[primary_span]\n+    pub span: Span,\n+    /// One of \"const\", \"const_with_path\", and \"static\"\n+    pub error_kind: &'static str,\n+    pub instance: String,\n+    #[subdiagnostic]\n+    pub frame_notes: Vec<FrameNote>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_nullary_intrinsic_fail)]\n+pub struct NullaryIntrinsicError {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(const_eval_undefined_behavior, code = \"E0080\")]\n+pub struct UndefinedBehavior {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note(const_eval_undefined_behavior_note)]\n+    pub ub_note: Option<()>,\n+    #[subdiagnostic]\n+    pub frames: Vec<FrameNote>,\n+    #[subdiagnostic]\n+    pub raw_bytes: RawBytesNote,\n+}\n+\n+pub trait ReportErrorExt {\n+    /// Returns the diagnostic message for this error.\n+    fn diagnostic_message(&self) -> DiagnosticMessage;\n+    fn add_args<G: EmissionGuarantee>(\n+        self,\n+        handler: &Handler,\n+        builder: &mut DiagnosticBuilder<'_, G>,\n+    );\n+\n+    fn debug(self) -> String\n+    where\n+        Self: Sized,\n+    {\n+        ty::tls::with(move |tcx| {\n+            let mut builder = tcx.sess.struct_allow(DiagnosticMessage::Str(String::new().into()));\n+            let handler = &tcx.sess.parse_sess.span_diagnostic;\n+            let message = self.diagnostic_message();\n+            self.add_args(handler, &mut builder);\n+            let s = handler.eagerly_translate_to_string(message, builder.args());\n+            builder.cancel();\n+            s\n+        })\n+    }\n+}\n+\n+fn bad_pointer_message(msg: CheckInAllocMsg, handler: &Handler) -> String {\n+    use crate::fluent_generated::*;\n+\n+    let msg = match msg {\n+        CheckInAllocMsg::DerefTest => const_eval_deref_test,\n+        CheckInAllocMsg::MemoryAccessTest => const_eval_memory_access_test,\n+        CheckInAllocMsg::PointerArithmeticTest => const_eval_pointer_arithmetic_test,\n+        CheckInAllocMsg::OffsetFromTest => const_eval_offset_from_test,\n+        CheckInAllocMsg::InboundsTest => const_eval_in_bounds_test,\n+    };\n+\n+    handler.eagerly_translate_to_string(msg, [].into_iter())\n+}\n+\n+impl<'a> ReportErrorExt for UndefinedBehaviorInfo<'a> {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        use UndefinedBehaviorInfo::*;\n+        match self {\n+            Ub(msg) => msg.clone().into(),\n+            Unreachable => const_eval_unreachable,\n+            BoundsCheckFailed { .. } => const_eval_bounds_check_failed,\n+            DivisionByZero => const_eval_division_by_zero,\n+            RemainderByZero => const_eval_remainder_by_zero,\n+            DivisionOverflow => const_eval_division_overflow,\n+            RemainderOverflow => const_eval_remainder_overflow,\n+            PointerArithOverflow => const_eval_pointer_arithmetic_overflow,\n+            InvalidMeta(InvalidMetaKind::SliceTooBig) => const_eval_invalid_meta_slice,\n+            InvalidMeta(InvalidMetaKind::TooBig) => const_eval_invalid_meta,\n+            UnterminatedCString(_) => const_eval_unterminated_c_string,\n+            PointerUseAfterFree(_) => const_eval_pointer_use_after_free,\n+            PointerOutOfBounds { ptr_size: Size::ZERO, .. } => const_eval_zst_pointer_out_of_bounds,\n+            PointerOutOfBounds { .. } => const_eval_pointer_out_of_bounds,\n+            DanglingIntPointer(0, _) => const_eval_dangling_null_pointer,\n+            DanglingIntPointer(_, _) => const_eval_dangling_int_pointer,\n+            AlignmentCheckFailed { .. } => const_eval_alignment_check_failed,\n+            WriteToReadOnly(_) => const_eval_write_to_read_only,\n+            DerefFunctionPointer(_) => const_eval_deref_function_pointer,\n+            DerefVTablePointer(_) => const_eval_deref_vtable_pointer,\n+            InvalidBool(_) => const_eval_invalid_bool,\n+            InvalidChar(_) => const_eval_invalid_char,\n+            InvalidTag(_) => const_eval_invalid_tag,\n+            InvalidFunctionPointer(_) => const_eval_invalid_function_pointer,\n+            InvalidVTablePointer(_) => const_eval_invalid_vtable_pointer,\n+            InvalidStr(_) => const_eval_invalid_str,\n+            InvalidUninitBytes(None) => const_eval_invalid_uninit_bytes_unknown,\n+            InvalidUninitBytes(Some(_)) => const_eval_invalid_uninit_bytes,\n+            DeadLocal => const_eval_dead_local,\n+            ScalarSizeMismatch(_) => const_eval_scalar_size_mismatch,\n+            UninhabitedEnumVariantWritten => const_eval_uninhabited_enum_variant_written,\n+            Validation(e) => e.diagnostic_message(),\n+            Custom(x) => (x.msg)(),\n+        }\n+    }\n+\n+    fn add_args<G: EmissionGuarantee>(\n+        self,\n+        handler: &Handler,\n+        builder: &mut DiagnosticBuilder<'_, G>,\n+    ) {\n+        use UndefinedBehaviorInfo::*;\n+        match self {\n+            Ub(_)\n+            | Unreachable\n+            | DivisionByZero\n+            | RemainderByZero\n+            | DivisionOverflow\n+            | RemainderOverflow\n+            | PointerArithOverflow\n+            | InvalidMeta(InvalidMetaKind::SliceTooBig)\n+            | InvalidMeta(InvalidMetaKind::TooBig)\n+            | InvalidUninitBytes(None)\n+            | DeadLocal\n+            | UninhabitedEnumVariantWritten => {}\n+            BoundsCheckFailed { len, index } => {\n+                builder.set_arg(\"len\", len);\n+                builder.set_arg(\"index\", index);\n+            }\n+            UnterminatedCString(ptr) | InvalidFunctionPointer(ptr) | InvalidVTablePointer(ptr) => {\n+                builder.set_arg(\"pointer\", ptr);\n+            }\n+            PointerUseAfterFree(allocation) => {\n+                builder.set_arg(\"allocation\", allocation);\n+            }\n+            PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size, msg } => {\n+                builder\n+                    .set_arg(\"alloc_id\", alloc_id)\n+                    .set_arg(\"alloc_size\", alloc_size.bytes())\n+                    .set_arg(\"ptr_offset\", ptr_offset)\n+                    .set_arg(\"ptr_size\", ptr_size.bytes())\n+                    .set_arg(\"bad_pointer_message\", bad_pointer_message(msg, handler));\n+            }\n+            DanglingIntPointer(ptr, msg) => {\n+                if ptr != 0 {\n+                    builder.set_arg(\"pointer\", format!(\"{ptr:#x}[noalloc]\"));\n+                }\n+\n+                builder.set_arg(\"bad_pointer_message\", bad_pointer_message(msg, handler));\n+            }\n+            AlignmentCheckFailed { required, has } => {\n+                builder.set_arg(\"required\", required.bytes());\n+                builder.set_arg(\"has\", has.bytes());\n+            }\n+            WriteToReadOnly(alloc) | DerefFunctionPointer(alloc) | DerefVTablePointer(alloc) => {\n+                builder.set_arg(\"allocation\", alloc);\n+            }\n+            InvalidBool(b) => {\n+                builder.set_arg(\"value\", format!(\"{b:02x}\"));\n+            }\n+            InvalidChar(c) => {\n+                builder.set_arg(\"value\", format!(\"{c:08x}\"));\n+            }\n+            InvalidTag(tag) => {\n+                builder.set_arg(\"tag\", format!(\"{tag:x}\"));\n+            }\n+            InvalidStr(err) => {\n+                builder.set_arg(\"err\", format!(\"{err}\"));\n+            }\n+            InvalidUninitBytes(Some((alloc, info))) => {\n+                builder.set_arg(\"alloc\", alloc);\n+                builder.set_arg(\"access\", info.access);\n+                builder.set_arg(\"uninit\", info.uninit);\n+            }\n+            ScalarSizeMismatch(info) => {\n+                builder.set_arg(\"target_size\", info.target_size);\n+                builder.set_arg(\"data_size\", info.data_size);\n+            }\n+            Validation(e) => e.add_args(handler, builder),\n+            Custom(custom) => {\n+                (custom.add_args)(&mut |name, value| {\n+                    builder.set_arg(name, value);\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> ReportErrorExt for ValidationErrorInfo<'tcx> {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        use rustc_middle::mir::interpret::ValidationErrorKind::*;\n+        match self.kind {\n+            PtrToUninhabited { ptr_kind: PointerKind::Box, .. } => const_eval_box_to_uninhabited,\n+            PtrToUninhabited { ptr_kind: PointerKind::Ref, .. } => const_eval_ref_to_uninhabited,\n+\n+            PtrToStatic { ptr_kind: PointerKind::Box } => const_eval_box_to_static,\n+            PtrToStatic { ptr_kind: PointerKind::Ref } => const_eval_ref_to_static,\n+\n+            PtrToMut { ptr_kind: PointerKind::Box } => const_eval_box_to_mut,\n+            PtrToMut { ptr_kind: PointerKind::Ref } => const_eval_ref_to_mut,\n+\n+            ExpectedNonPtr { .. } => const_eval_expected_non_ptr,\n+            MutableRefInConst => const_eval_mutable_ref_in_const,\n+            NullFnPtr => const_eval_null_fn_ptr,\n+            NeverVal => const_eval_never_val,\n+            NullablePtrOutOfRange { .. } => const_eval_nullable_ptr_out_of_range,\n+            PtrOutOfRange { .. } => const_eval_ptr_out_of_range,\n+            OutOfRange { .. } => const_eval_out_of_range,\n+            UnsafeCell => const_eval_unsafe_cell,\n+            UninhabitedVal { .. } => const_eval_uninhabited_val,\n+            InvalidEnumTag { .. } => const_eval_invalid_enum_tag,\n+            UninitEnumTag => const_eval_uninit_enum_tag,\n+            UninitStr => const_eval_uninit_str,\n+            Uninit { expected: ExpectedKind::Bool } => const_eval_uninit_bool,\n+            Uninit { expected: ExpectedKind::Reference } => const_eval_uninit_ref,\n+            Uninit { expected: ExpectedKind::Box } => const_eval_uninit_box,\n+            Uninit { expected: ExpectedKind::RawPtr } => const_eval_uninit_raw_ptr,\n+            Uninit { expected: ExpectedKind::InitScalar } => const_eval_uninit_init_scalar,\n+            Uninit { expected: ExpectedKind::Char } => const_eval_uninit_char,\n+            Uninit { expected: ExpectedKind::Float } => const_eval_uninit_float,\n+            Uninit { expected: ExpectedKind::Int } => const_eval_uninit_int,\n+            Uninit { expected: ExpectedKind::FnPtr } => const_eval_uninit_fn_ptr,\n+            UninitVal => const_eval_uninit,\n+            InvalidVTablePtr { .. } => const_eval_invalid_vtable_ptr,\n+            InvalidMetaSliceTooLarge { ptr_kind: PointerKind::Box } => {\n+                const_eval_invalid_box_slice_meta\n+            }\n+            InvalidMetaSliceTooLarge { ptr_kind: PointerKind::Ref } => {\n+                const_eval_invalid_ref_slice_meta\n+            }\n+\n+            InvalidMetaTooLarge { ptr_kind: PointerKind::Box } => const_eval_invalid_box_meta,\n+            InvalidMetaTooLarge { ptr_kind: PointerKind::Ref } => const_eval_invalid_ref_meta,\n+            UnalignedPtr { ptr_kind: PointerKind::Ref, .. } => const_eval_unaligned_ref,\n+            UnalignedPtr { ptr_kind: PointerKind::Box, .. } => const_eval_unaligned_box,\n+\n+            NullPtr { ptr_kind: PointerKind::Box } => const_eval_null_box,\n+            NullPtr { ptr_kind: PointerKind::Ref } => const_eval_null_ref,\n+            DanglingPtrNoProvenance { ptr_kind: PointerKind::Box, .. } => {\n+                const_eval_dangling_box_no_provenance\n+            }\n+            DanglingPtrNoProvenance { ptr_kind: PointerKind::Ref, .. } => {\n+                const_eval_dangling_ref_no_provenance\n+            }\n+            DanglingPtrOutOfBounds { ptr_kind: PointerKind::Box } => {\n+                const_eval_dangling_box_out_of_bounds\n+            }\n+            DanglingPtrOutOfBounds { ptr_kind: PointerKind::Ref } => {\n+                const_eval_dangling_ref_out_of_bounds\n+            }\n+            DanglingPtrUseAfterFree { ptr_kind: PointerKind::Box } => {\n+                const_eval_dangling_box_use_after_free\n+            }\n+            DanglingPtrUseAfterFree { ptr_kind: PointerKind::Ref } => {\n+                const_eval_dangling_ref_use_after_free\n+            }\n+            InvalidBool { .. } => const_eval_validation_invalid_bool,\n+            InvalidChar { .. } => const_eval_validation_invalid_char,\n+            InvalidFnPtr { .. } => const_eval_invalid_fn_ptr,\n+        }\n+    }\n+\n+    fn add_args<G: EmissionGuarantee>(self, handler: &Handler, err: &mut DiagnosticBuilder<'_, G>) {\n+        use crate::fluent_generated as fluent;\n+        use rustc_middle::mir::interpret::ValidationErrorKind::*;\n+\n+        let message = if let Some(path) = self.path {\n+            handler.eagerly_translate_to_string(\n+                fluent::const_eval_invalid_value_with_path,\n+                [(\"path\".into(), DiagnosticArgValue::Str(path.into()))].iter().map(|(a, b)| (a, b)),\n+            )\n+        } else {\n+            handler.eagerly_translate_to_string(fluent::const_eval_invalid_value, [].into_iter())\n+        };\n+\n+        err.set_arg(\"front_matter\", message);\n+\n+        fn add_range_arg<G: EmissionGuarantee>(\n+            r: WrappingRange,\n+            max_hi: u128,\n+            handler: &Handler,\n+            err: &mut DiagnosticBuilder<'_, G>,\n+        ) {\n+            let WrappingRange { start: lo, end: hi } = r;\n+            assert!(hi <= max_hi);\n+            let msg = if lo > hi {\n+                fluent::const_eval_range_wrapping\n+            } else if lo == hi {\n+                fluent::const_eval_range_singular\n+            } else if lo == 0 {\n+                assert!(hi < max_hi, \"should not be printing if the range covers everything\");\n+                fluent::const_eval_range_upper\n+            } else if hi == max_hi {\n+                assert!(lo > 0, \"should not be printing if the range covers everything\");\n+                fluent::const_eval_range_lower\n+            } else {\n+                fluent::const_eval_range\n+            };\n+\n+            let args = [\n+                (\"lo\".into(), DiagnosticArgValue::Str(lo.to_string().into())),\n+                (\"hi\".into(), DiagnosticArgValue::Str(hi.to_string().into())),\n+            ];\n+            let args = args.iter().map(|(a, b)| (a, b));\n+            let message = handler.eagerly_translate_to_string(msg, args);\n+            err.set_arg(\"in_range\", message);\n+        }\n+\n+        match self.kind {\n+            PtrToUninhabited { ty, .. } | UninhabitedVal { ty } => {\n+                err.set_arg(\"ty\", ty);\n+            }\n+            ExpectedNonPtr { value }\n+            | InvalidEnumTag { value }\n+            | InvalidVTablePtr { value }\n+            | InvalidBool { value }\n+            | InvalidChar { value }\n+            | InvalidFnPtr { value } => {\n+                err.set_arg(\"value\", value);\n+            }\n+            NullablePtrOutOfRange { range, max_value } | PtrOutOfRange { range, max_value } => {\n+                add_range_arg(range, max_value, handler, err)\n+            }\n+            OutOfRange { range, max_value, value } => {\n+                err.set_arg(\"value\", value);\n+                add_range_arg(range, max_value, handler, err);\n+            }\n+            UnalignedPtr { required_bytes, found_bytes, .. } => {\n+                err.set_arg(\"required_bytes\", required_bytes);\n+                err.set_arg(\"found_bytes\", found_bytes);\n+            }\n+            DanglingPtrNoProvenance { pointer, .. } => {\n+                err.set_arg(\"pointer\", pointer);\n+            }\n+            NullPtr { .. }\n+            | PtrToStatic { .. }\n+            | PtrToMut { .. }\n+            | MutableRefInConst\n+            | NullFnPtr\n+            | NeverVal\n+            | UnsafeCell\n+            | UninitEnumTag\n+            | UninitStr\n+            | Uninit { .. }\n+            | UninitVal\n+            | InvalidMetaSliceTooLarge { .. }\n+            | InvalidMetaTooLarge { .. }\n+            | DanglingPtrUseAfterFree { .. }\n+            | DanglingPtrOutOfBounds { .. } => {}\n+        }\n+    }\n+}\n+\n+impl ReportErrorExt for UnsupportedOpInfo {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        match self {\n+            UnsupportedOpInfo::Unsupported(s) => s.clone().into(),\n+            UnsupportedOpInfo::PartialPointerOverwrite(_) => const_eval_partial_pointer_overwrite,\n+            UnsupportedOpInfo::PartialPointerCopy(_) => const_eval_partial_pointer_copy,\n+            UnsupportedOpInfo::ReadPointerAsBytes => const_eval_read_pointer_as_bytes,\n+            UnsupportedOpInfo::ThreadLocalStatic(_) => const_eval_thread_local_static,\n+            UnsupportedOpInfo::ReadExternStatic(_) => const_eval_read_extern_static,\n+        }\n+    }\n+    fn add_args<G: EmissionGuarantee>(self, _: &Handler, builder: &mut DiagnosticBuilder<'_, G>) {\n+        use crate::fluent_generated::*;\n+\n+        use UnsupportedOpInfo::*;\n+        if let ReadPointerAsBytes | PartialPointerOverwrite(_) | PartialPointerCopy(_) = self {\n+            builder.help(const_eval_ptr_as_bytes_1);\n+            builder.help(const_eval_ptr_as_bytes_2);\n+        }\n+        match self {\n+            Unsupported(_) | ReadPointerAsBytes => {}\n+            PartialPointerOverwrite(ptr) | PartialPointerCopy(ptr) => {\n+                builder.set_arg(\"ptr\", ptr);\n+            }\n+            ThreadLocalStatic(did) | ReadExternStatic(did) => {\n+                builder.set_arg(\"did\", format!(\"{did:?}\"));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> ReportErrorExt for InterpError<'tcx> {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        match self {\n+            InterpError::UndefinedBehavior(ub) => ub.diagnostic_message(),\n+            InterpError::Unsupported(e) => e.diagnostic_message(),\n+            InterpError::InvalidProgram(e) => e.diagnostic_message(),\n+            InterpError::ResourceExhaustion(e) => e.diagnostic_message(),\n+            InterpError::MachineStop(e) => e.diagnostic_message(),\n+        }\n+    }\n+    fn add_args<G: EmissionGuarantee>(\n+        self,\n+        handler: &Handler,\n+        builder: &mut DiagnosticBuilder<'_, G>,\n+    ) {\n+        match self {\n+            InterpError::UndefinedBehavior(ub) => ub.add_args(handler, builder),\n+            InterpError::Unsupported(e) => e.add_args(handler, builder),\n+            InterpError::InvalidProgram(e) => e.add_args(handler, builder),\n+            InterpError::ResourceExhaustion(e) => e.add_args(handler, builder),\n+            InterpError::MachineStop(e) => e.add_args(&mut |name, value| {\n+                builder.set_arg(name, value);\n+            }),\n+        }\n+    }\n+}\n+\n+impl<'tcx> ReportErrorExt for InvalidProgramInfo<'tcx> {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        match self {\n+            InvalidProgramInfo::TooGeneric => const_eval_too_generic,\n+            InvalidProgramInfo::AlreadyReported(_) => const_eval_already_reported,\n+            InvalidProgramInfo::Layout(e) => e.diagnostic_message(),\n+            InvalidProgramInfo::FnAbiAdjustForForeignAbi(_) => {\n+                rustc_middle::error::middle_adjust_for_foreign_abi_error\n+            }\n+            InvalidProgramInfo::SizeOfUnsizedType(_) => const_eval_size_of_unsized,\n+            InvalidProgramInfo::UninitUnsizedLocal => const_eval_uninit_unsized_local,\n+        }\n+    }\n+    fn add_args<G: EmissionGuarantee>(\n+        self,\n+        handler: &Handler,\n+        builder: &mut DiagnosticBuilder<'_, G>,\n+    ) {\n+        match self {\n+            InvalidProgramInfo::TooGeneric\n+            | InvalidProgramInfo::AlreadyReported(_)\n+            | InvalidProgramInfo::UninitUnsizedLocal => {}\n+            InvalidProgramInfo::Layout(e) => {\n+                let diag: DiagnosticBuilder<'_, ()> = e.into_diagnostic().into_diagnostic(handler);\n+                for (name, val) in diag.args() {\n+                    builder.set_arg(name.clone(), val.clone());\n+                }\n+                diag.cancel();\n+            }\n+            InvalidProgramInfo::FnAbiAdjustForForeignAbi(\n+                AdjustForForeignAbiError::Unsupported { arch, abi },\n+            ) => {\n+                builder.set_arg(\"arch\", arch);\n+                builder.set_arg(\"abi\", abi.name());\n+            }\n+            InvalidProgramInfo::SizeOfUnsizedType(ty) => {\n+                builder.set_arg(\"ty\", ty);\n+            }\n+        }\n+    }\n+}\n+\n+impl ReportErrorExt for ResourceExhaustionInfo {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        match self {\n+            ResourceExhaustionInfo::StackFrameLimitReached => const_eval_stack_frame_limit_reached,\n+            ResourceExhaustionInfo::MemoryExhausted => const_eval_memory_exhausted,\n+            ResourceExhaustionInfo::AddressSpaceFull => const_eval_address_space_full,\n+        }\n+    }\n+    fn add_args<G: EmissionGuarantee>(self, _: &Handler, _: &mut DiagnosticBuilder<'_, G>) {}\n+}"}, {"sha": "b4db3dff3ffc2de8bb00a93b7494316a86e0f043", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -14,6 +14,8 @@ use super::{\n     util::ensure_monomorphic_enough, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy,\n };\n \n+use crate::fluent_generated as fluent;\n+\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n         &mut self,\n@@ -138,12 +140,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert!(src.layout.is_sized());\n                 assert!(dest.layout.is_sized());\n                 if src.layout.size != dest.layout.size {\n-                    throw_ub_format!(\n-                        \"transmuting from {}-byte type to {}-byte type: `{}` -> `{}`\",\n-                        src.layout.size.bytes(),\n-                        dest.layout.size.bytes(),\n-                        src.layout.ty,\n-                        dest.layout.ty,\n+                    let src_bytes = src.layout.size.bytes();\n+                    let dest_bytes = dest.layout.size.bytes();\n+                    let src_ty = format!(\"{}\", src.layout.ty);\n+                    let dest_ty = format!(\"{}\", dest.layout.ty);\n+                    throw_ub_custom!(\n+                        fluent::const_eval_invalid_transmute,\n+                        src_bytes = src_bytes,\n+                        dest_bytes = dest_bytes,\n+                        src = src_ty,\n+                        dest = dest_ty,\n                     );\n                 }\n \n@@ -363,7 +369,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let old_vptr = old_vptr.to_pointer(self)?;\n                 let (ty, old_trait) = self.get_ptr_vtable(old_vptr)?;\n                 if old_trait != data_a.principal() {\n-                    throw_ub_format!(\"upcast on a pointer whose vtable does not match its type\");\n+                    throw_ub_custom!(fluent::const_eval_upcast_mismatch);\n                 }\n                 let new_vptr = self.get_vtable_ptr(ty, data_b.principal())?;\n                 self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)"}, {"sha": "36606ff69a6ca7e4649cbd8716660ac26baaf20f", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,13 +1,13 @@\n use std::cell::Cell;\n-use std::fmt;\n-use std::mem;\n+use std::{fmt, mem};\n \n use either::{Either, Left, Right};\n \n+use hir::CRATE_HIR_ID;\n use rustc_hir::{self as hir, def_id::DefId, definitions::DefPathData};\n use rustc_index::IndexVec;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{ErrorHandled, InterpError, ReportedErrorInfo};\n+use rustc_middle::mir::interpret::{ErrorHandled, InterpError, InvalidMetaKind, ReportedErrorInfo};\n use rustc_middle::query::TyCtxtAt;\n use rustc_middle::ty::layout::{\n     self, FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOf, LayoutOfHelpers,\n@@ -24,6 +24,8 @@ use super::{\n     MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, PointerArithmetic, Provenance,\n     Scalar, StackPopJump,\n };\n+use crate::errors::{self, ErroneousConstUsed};\n+use crate::fluent_generated as fluent;\n use crate::util;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -246,6 +248,7 @@ impl<'mir, 'tcx, Prov: Provenance, Extra> Frame<'mir, 'tcx, Prov, Extra> {\n     }\n }\n \n+// FIXME: only used by miri, should be removed once translatable.\n impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         ty::tls::with(|tcx| {\n@@ -263,6 +266,21 @@ impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n     }\n }\n \n+impl<'tcx> FrameInfo<'tcx> {\n+    pub fn as_note(&self, tcx: TyCtxt<'tcx>) -> errors::FrameNote {\n+        let span = self.span;\n+        if tcx.def_key(self.instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+            errors::FrameNote { where_: \"closure\", span, instance: String::new(), times: 0 }\n+        } else {\n+            let instance = format!(\"{}\", self.instance);\n+            // Note: this triggers a `good_path_bug` state, which means that if we ever get here\n+            // we must emit a diagnostic. We should never display a `FrameInfo` unless we\n+            // actually want to emit a warning or error to the user.\n+            errors::FrameNote { where_: \"instance\", span, instance, times: 0 }\n+        }\n+    }\n+}\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n@@ -405,6 +423,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.stack().last().map_or(self.tcx.span, |f| f.current_span())\n     }\n \n+    #[inline(always)]\n+    /// Find the first stack frame that is within the current crate, if any, otherwise return the crate's HirId\n+    pub fn best_lint_scope(&self) -> hir::HirId {\n+        self.stack()\n+            .iter()\n+            .find_map(|frame| frame.body.source.def_id().as_local())\n+            .map_or(CRATE_HIR_ID, |def_id| self.tcx.hir().local_def_id_to_hir_id(def_id))\n+    }\n+\n     #[inline(always)]\n     pub(crate) fn stack(&self) -> &[Frame<'mir, 'tcx, M::Provenance, M::FrameExtra>] {\n         M::stack(self)\n@@ -610,7 +637,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Check if this brought us over the size limit.\n                 if size > self.max_size_of_val() {\n-                    throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n+                    throw_ub!(InvalidMeta(InvalidMetaKind::TooBig));\n                 }\n                 Ok(Some((size, align)))\n             }\n@@ -628,7 +655,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let size = elem.size.bytes().saturating_mul(len); // we rely on `max_size_of_val` being smaller than `u64::MAX`.\n                 let size = Size::from_bytes(size);\n                 if size > self.max_size_of_val() {\n-                    throw_ub!(InvalidMeta(\"slice is bigger than largest supported object\"));\n+                    throw_ub!(InvalidMeta(InvalidMetaKind::SliceTooBig));\n                 }\n                 Ok(Some((size, elem.align.abi)))\n             }\n@@ -736,7 +763,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             mir::UnwindAction::Cleanup(block) => Left(mir::Location { block, statement_index: 0 }),\n             mir::UnwindAction::Continue => Right(self.frame_mut().body.span),\n             mir::UnwindAction::Unreachable => {\n-                throw_ub_format!(\"unwinding past a stack frame that does not allow unwinding\")\n+                throw_ub_custom!(fluent::const_eval_unreachable_unwind);\n             }\n             mir::UnwindAction::Terminate => {\n                 self.frame_mut().loc = Right(self.frame_mut().body.span);\n@@ -775,7 +802,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         );\n         if unwinding && self.frame_idx() == 0 {\n-            throw_ub_format!(\"unwinding past the topmost frame of the stack\");\n+            throw_ub_custom!(fluent::const_eval_unwind_past_top);\n         }\n \n         // Copy return value. Must of course happen *before* we deallocate the locals.\n@@ -863,7 +890,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // StorageLive expects the local to be dead, and marks it live.\n         let old = mem::replace(&mut self.frame_mut().locals[local].value, local_val);\n         if !matches!(old, LocalValue::Dead) {\n-            throw_ub_format!(\"StorageLive on a local that was already live\");\n+            throw_ub_custom!(fluent::const_eval_double_storage_live);\n         }\n         Ok(())\n     }\n@@ -906,7 +933,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ErrorHandled::Reported(err) => {\n                     if !err.is_tainted_by_errors() && let Some(span) = span {\n                         // To make it easier to figure out where this error comes from, also add a note at the current location.\n-                        self.tcx.sess.span_note_without_error(span, \"erroneous constant used\");\n+                        self.tcx.sess.emit_note(ErroneousConstUsed { span });\n                     }\n                     err_inval!(AlreadyReported(err))\n                 }"}, {"sha": "7b11ad33091e4541ad6f94063d054970641cd584", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -28,6 +28,7 @@ use super::{\n     ValueVisitor,\n };\n use crate::const_eval;\n+use crate::errors::{DanglingPtrInFinal, UnsupportedUntypedPointer};\n \n pub trait CompileTimeMachine<'mir, 'tcx, T> = Machine<\n         'mir,\n@@ -320,10 +321,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n     }\n }\n \n+/// How a constant value should be interned.\n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n pub enum InternKind {\n     /// The `mutability` of the static, ignoring the type which may have interior mutability.\n     Static(hir::Mutability),\n+    /// A `const` item\n     Constant,\n     Promoted,\n }\n@@ -388,8 +391,7 @@ pub fn intern_const_alloc_recursive<\n                 ecx.tcx.sess.delay_span_bug(\n                     ecx.tcx.span,\n                     format!(\n-                        \"error during interning should later cause validation failure: {}\",\n-                        error\n+                        \"error during interning should later cause validation failure: {error:?}\"\n                     ),\n                 );\n             }\n@@ -425,14 +427,16 @@ pub fn intern_const_alloc_recursive<\n                     // immutability is so important.\n                     alloc.mutability = Mutability::Not;\n                 }\n+                // If it's a constant, we should not have any \"leftovers\" as everything\n+                // is tracked by const-checking.\n+                // FIXME: downgrade this to a warning? It rejects some legitimate consts,\n+                // such as `const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;`.\n+                //\n+                // NOTE: it looks likes this code path is only reachable when we try to intern\n+                // something that cannot be promoted, which in constants means values that have\n+                // drop glue, such as the example above.\n                 InternKind::Constant => {\n-                    // If it's a constant, we should not have any \"leftovers\" as everything\n-                    // is tracked by const-checking.\n-                    // FIXME: downgrade this to a warning? It rejects some legitimate consts,\n-                    // such as `const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;`.\n-                    ecx.tcx\n-                        .sess\n-                        .span_err(ecx.tcx.span, \"untyped pointers are not allowed in constant\");\n+                    ecx.tcx.sess.emit_err(UnsupportedUntypedPointer { span: ecx.tcx.span });\n                     // For better errors later, mark the allocation as immutable.\n                     alloc.mutability = Mutability::Not;\n                 }\n@@ -447,10 +451,7 @@ pub fn intern_const_alloc_recursive<\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // Codegen does not like dangling pointers, and generally `tcx` assumes that\n             // all allocations referenced anywhere actually exist. So, make sure we error here.\n-            let reported = ecx\n-                .tcx\n-                .sess\n-                .span_err(ecx.tcx.span, \"encountered dangling pointer in final constant\");\n+            let reported = ecx.tcx.sess.emit_err(DanglingPtrInFinal { span: ecx.tcx.span });\n             return Err(reported);\n         } else if ecx.tcx.try_get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't"}, {"sha": "fb24cf48a9a02a7e998ba9a821013a54e64f8fdc", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 43, "deletions": 32, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -22,6 +22,8 @@ use super::{\n     Pointer,\n };\n \n+use crate::fluent_generated as fluent;\n+\n mod caller_location;\n \n fn numeric_intrinsic<Prov>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<Prov> {\n@@ -198,15 +200,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         ty\n                     ),\n                 };\n-                let (nonzero, intrinsic_name) = match intrinsic_name {\n+                let (nonzero, actual_intrinsic_name) = match intrinsic_name {\n                     sym::cttz_nonzero => (true, sym::cttz),\n                     sym::ctlz_nonzero => (true, sym::ctlz),\n                     other => (false, other),\n                 };\n                 if nonzero && bits == 0 {\n-                    throw_ub_format!(\"`{}_nonzero` called on 0\", intrinsic_name);\n+                    throw_ub_custom!(\n+                        fluent::const_eval_call_nonzero_intrinsic,\n+                        name = intrinsic_name,\n+                    );\n                 }\n-                let out_val = numeric_intrinsic(intrinsic_name, bits, kind);\n+                let out_val = numeric_intrinsic(actual_intrinsic_name, bits, kind);\n                 self.write_scalar(out_val, dest)?;\n             }\n             sym::saturating_add | sym::saturating_sub => {\n@@ -253,9 +258,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val = r.to_scalar().to_bits(layout.size)?;\n                     if let sym::unchecked_shl | sym::unchecked_shr = intrinsic_name {\n-                        throw_ub_format!(\"overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n+                        throw_ub_custom!(\n+                            fluent::const_eval_overflow_shift,\n+                            val = r_val,\n+                            name = intrinsic_name\n+                        );\n                     } else {\n-                        throw_ub_format!(\"overflow executing `{}`\", intrinsic_name);\n+                        throw_ub_custom!(fluent::const_eval_overflow, name = intrinsic_name);\n                     }\n                 }\n                 self.write_scalar(val, dest)?;\n@@ -314,17 +323,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         (Err(_), _) | (_, Err(_)) => {\n                             // We managed to find a valid allocation for one pointer, but not the other.\n                             // That means they are definitely not pointing to the same allocation.\n-                            throw_ub_format!(\n-                                \"`{}` called on pointers into different allocations\",\n-                                intrinsic_name\n+                            throw_ub_custom!(\n+                                fluent::const_eval_different_allocations,\n+                                name = intrinsic_name,\n                             );\n                         }\n                         (Ok((a_alloc_id, a_offset, _)), Ok((b_alloc_id, b_offset, _))) => {\n                             // Found allocation for both. They must be into the same allocation.\n                             if a_alloc_id != b_alloc_id {\n-                                throw_ub_format!(\n-                                    \"`{}` called on pointers into different allocations\",\n-                                    intrinsic_name\n+                                throw_ub_custom!(\n+                                    fluent::const_eval_different_allocations,\n+                                    name = intrinsic_name,\n                                 );\n                             }\n                             // Use these offsets for distance calculation.\n@@ -344,21 +353,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     if overflowed {\n                         // a < b\n                         if intrinsic_name == sym::ptr_offset_from_unsigned {\n-                            throw_ub_format!(\n-                                \"`{}` called when first pointer has smaller offset than second: {} < {}\",\n-                                intrinsic_name,\n-                                a_offset,\n-                                b_offset,\n+                            throw_ub_custom!(\n+                                fluent::const_eval_unsigned_offset_from_overflow,\n+                                a_offset = a_offset,\n+                                b_offset = b_offset,\n                             );\n                         }\n                         // The signed form of the intrinsic allows this. If we interpret the\n                         // difference as isize, we'll get the proper signed difference. If that\n                         // seems *positive*, they were more than isize::MAX apart.\n                         let dist = val.to_target_isize(self)?;\n                         if dist >= 0 {\n-                            throw_ub_format!(\n-                                \"`{}` called when first pointer is too far before second\",\n-                                intrinsic_name\n+                            throw_ub_custom!(\n+                                fluent::const_eval_offset_from_underflow,\n+                                name = intrinsic_name,\n                             );\n                         }\n                         dist\n@@ -368,9 +376,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         // If converting to isize produced a *negative* result, we had an overflow\n                         // because they were more than isize::MAX apart.\n                         if dist < 0 {\n-                            throw_ub_format!(\n-                                \"`{}` called when first pointer is too far ahead of second\",\n-                                intrinsic_name\n+                            throw_ub_custom!(\n+                                fluent::const_eval_offset_from_overflow,\n+                                name = intrinsic_name,\n                             );\n                         }\n                         dist\n@@ -513,7 +521,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let op = self.eval_operand(op, None)?;\n                 let cond = self.read_scalar(&op)?.to_bool()?;\n                 if !cond {\n-                    throw_ub_format!(\"`assume` called with `false`\");\n+                    throw_ub_custom!(fluent::const_eval_assume_false);\n                 }\n                 Ok(())\n             }\n@@ -542,7 +550,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let (res, overflow, _ty) = self.overflowing_binary_op(BinOp::Rem, &a, &b)?;\n         assert!(!overflow); // All overflow is UB, so this should never return on overflow.\n         if res.assert_bits(a.layout.size) != 0 {\n-            throw_ub_format!(\"exact_div: {} cannot be divided by {} without remainder\", a, b)\n+            throw_ub_custom!(\n+                fluent::const_eval_exact_div_has_remainder,\n+                a = format!(\"{a}\"),\n+                b = format!(\"{b}\")\n+            )\n         }\n         // `Rem` says this is all right, so we can let `Div` do its job.\n         self.binop_ignore_overflow(BinOp::Div, &a, &b, dest)\n@@ -638,9 +650,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `checked_mul` enforces a too small bound (the correct one would probably be target_isize_max),\n         // but no actual allocation can be big enough for the difference to be noticeable.\n         let size = size.checked_mul(count, self).ok_or_else(|| {\n-            err_ub_format!(\n-                \"overflow computing total size of `{}`\",\n-                if nonoverlapping { \"copy_nonoverlapping\" } else { \"copy\" }\n+            err_ub_custom!(\n+                fluent::const_eval_size_overflow,\n+                name = if nonoverlapping { \"copy_nonoverlapping\" } else { \"copy\" }\n             )\n         })?;\n \n@@ -664,10 +676,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // `checked_mul` enforces a too small bound (the correct one would probably be target_isize_max),\n         // but no actual allocation can be big enough for the difference to be noticeable.\n-        let len = layout\n-            .size\n-            .checked_mul(count, self)\n-            .ok_or_else(|| err_ub_format!(\"overflow computing total size of `write_bytes`\"))?;\n+        let len = layout.size.checked_mul(count, self).ok_or_else(|| {\n+            err_ub_custom!(fluent::const_eval_size_overflow, name = \"write_bytes\")\n+        })?;\n \n         let bytes = std::iter::repeat(byte).take(len.bytes_usize());\n         self.write_bytes_ptr(dst, bytes)\n@@ -691,7 +702,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok(&[]);\n             };\n             if alloc_ref.has_provenance() {\n-                throw_ub_format!(\"`raw_eq` on bytes with provenance\");\n+                throw_ub_custom!(fluent::const_eval_raw_eq_with_provenance);\n             }\n             alloc_ref.get_bytes_strip_provenance()\n         };"}, {"sha": "1125d8d1f0e08927f8868bb561c8ac6f05282412", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use crate::const_eval::CheckAlignment;\n+use crate::fluent_generated as fluent;\n \n use super::{\n     alloc_range, AllocBytes, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg,\n@@ -200,7 +201,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n-        let alloc = Allocation::uninit(size, align, M::PANIC_ON_ALLOC_FAIL)?;\n+        let alloc = if M::PANIC_ON_ALLOC_FAIL {\n+            Allocation::uninit(size, align)\n+        } else {\n+            Allocation::try_uninit(size, align)?\n+        };\n         self.allocate_raw_ptr(alloc, kind)\n     }\n \n@@ -242,9 +247,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let (alloc_id, offset, _prov) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n-            throw_ub_format!(\n-                \"reallocating {:?} which does not point to the beginning of an object\",\n-                ptr\n+            throw_ub_custom!(\n+                fluent::const_eval_realloc_or_alloc_with_offset,\n+                ptr = format!(\"{ptr:?}\"),\n+                kind = \"realloc\"\n             );\n         }\n \n@@ -280,45 +286,62 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"deallocating: {alloc_id:?}\");\n \n         if offset.bytes() != 0 {\n-            throw_ub_format!(\n-                \"deallocating {:?} which does not point to the beginning of an object\",\n-                ptr\n+            throw_ub_custom!(\n+                fluent::const_eval_realloc_or_alloc_with_offset,\n+                ptr = format!(\"{ptr:?}\"),\n+                kind = \"dealloc\",\n             );\n         }\n \n         let Some((alloc_kind, mut alloc)) = self.memory.alloc_map.remove(&alloc_id) else {\n             // Deallocating global memory -- always an error\n             return Err(match self.tcx.try_get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Function(..)) => {\n-                    err_ub_format!(\"deallocating {alloc_id:?}, which is a function\")\n+                    err_ub_custom!(\n+                        fluent::const_eval_invalid_dealloc,\n+                        alloc_id = alloc_id,\n+                        kind = \"fn\",\n+                    )\n                 }\n                 Some(GlobalAlloc::VTable(..)) => {\n-                    err_ub_format!(\"deallocating {alloc_id:?}, which is a vtable\")\n+                    err_ub_custom!(\n+                        fluent::const_eval_invalid_dealloc,\n+                        alloc_id = alloc_id,\n+                        kind = \"vtable\",\n+                    )\n                 }\n                 Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n-                    err_ub_format!(\"deallocating {alloc_id:?}, which is static memory\")\n+                    err_ub_custom!(\n+                        fluent::const_eval_invalid_dealloc,\n+                        alloc_id = alloc_id,\n+                        kind = \"static_mem\"\n+                    )\n                 }\n                 None => err_ub!(PointerUseAfterFree(alloc_id)),\n             }\n             .into());\n         };\n \n         if alloc.mutability.is_not() {\n-            throw_ub_format!(\"deallocating immutable allocation {alloc_id:?}\");\n+            throw_ub_custom!(fluent::const_eval_dealloc_immutable, alloc = alloc_id,);\n         }\n         if alloc_kind != kind {\n-            throw_ub_format!(\n-                \"deallocating {alloc_id:?}, which is {alloc_kind} memory, using {kind} deallocation operation\"\n+            throw_ub_custom!(\n+                fluent::const_eval_dealloc_kind_mismatch,\n+                alloc = alloc_id,\n+                alloc_kind = format!(\"{alloc_kind}\"),\n+                kind = format!(\"{kind}\"),\n             );\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size != alloc.size() || align != alloc.align {\n-                throw_ub_format!(\n-                    \"incorrect layout on deallocation: {alloc_id:?} has size {} and alignment {}, but gave size {} and alignment {}\",\n-                    alloc.size().bytes(),\n-                    alloc.align.bytes(),\n-                    size.bytes(),\n-                    align.bytes(),\n+                throw_ub_custom!(\n+                    fluent::const_eval_dealloc_incorrect_layout,\n+                    alloc = alloc_id,\n+                    size = alloc.size().bytes(),\n+                    align = alloc.align.bytes(),\n+                    size_found = size.bytes(),\n+                    align_found = align.bytes(),\n                 )\n             }\n         }\n@@ -1166,7 +1189,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     if (src_offset <= dest_offset && src_offset + size > dest_offset)\n                         || (dest_offset <= src_offset && dest_offset + size > src_offset)\n                     {\n-                        throw_ub_format!(\"copy_nonoverlapping called on overlapping ranges\")\n+                        throw_ub_custom!(fluent::const_eval_copy_nonoverlapping_overlapping);\n                     }\n                 }\n "}, {"sha": "7269ff8d53cdfb319b8248f134b141f91d7c28da", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -15,6 +15,7 @@ use super::{\n     FnVal, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine, MemoryKind, OpTy, Operand,\n     PlaceTy, Scalar, StackPopCleanup,\n };\n+use crate::fluent_generated as fluent;\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub(super) fn eval_terminator(\n@@ -172,7 +173,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             InlineAsm { template, ref operands, options, destination, .. } => {\n                 M::eval_inline_asm(self, template, operands, options)?;\n                 if options.contains(InlineAsmOptions::NORETURN) {\n-                    throw_ub_format!(\"returned from noreturn inline assembly\");\n+                    throw_ub_custom!(fluent::const_eval_noreturn_asm_returned);\n                 }\n                 self.go_to_block(\n                     destination\n@@ -288,15 +289,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         }\n         // Find next caller arg.\n-        let (caller_arg, caller_abi) = caller_args.next().ok_or_else(|| {\n-            err_ub_format!(\"calling a function with fewer arguments than it requires\")\n-        })?;\n+        let Some((caller_arg, caller_abi)) = caller_args.next() else {\n+            throw_ub_custom!(fluent::const_eval_not_enough_caller_args);\n+        };\n         // Now, check\n         if !Self::check_argument_compat(caller_abi, callee_abi) {\n-            throw_ub_format!(\n-                \"calling a function with argument of type {:?} passing data of type {:?}\",\n-                callee_arg.layout.ty,\n-                caller_arg.layout.ty\n+            let callee_ty = format!(\"{}\", callee_arg.layout.ty);\n+            let caller_ty = format!(\"{}\", caller_arg.layout.ty);\n+            throw_ub_custom!(\n+                fluent::const_eval_incompatible_types,\n+                callee_ty = callee_ty,\n+                caller_ty = caller_ty,\n             )\n         }\n         // Special handling for unsized parameters.\n@@ -398,10 +401,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 if M::enforce_abi(self) {\n                     if caller_fn_abi.conv != callee_fn_abi.conv {\n-                        throw_ub_format!(\n-                            \"calling a function with calling convention {:?} using calling convention {:?}\",\n-                            callee_fn_abi.conv,\n-                            caller_fn_abi.conv\n+                        throw_ub_custom!(\n+                            fluent::const_eval_incompatible_calling_conventions,\n+                            callee_conv = format!(\"{:?}\", callee_fn_abi.conv),\n+                            caller_conv = format!(\"{:?}\", caller_fn_abi.conv),\n                         )\n                     }\n                 }\n@@ -508,15 +511,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         \"mismatch between callee ABI and callee body arguments\"\n                     );\n                     if caller_args.next().is_some() {\n-                        throw_ub_format!(\"calling a function with more arguments than it expected\")\n+                        throw_ub_custom!(fluent::const_eval_too_many_caller_args);\n                     }\n                     // Don't forget to check the return type!\n                     if !Self::check_argument_compat(&caller_fn_abi.ret, &callee_fn_abi.ret) {\n-                        throw_ub_format!(\n-                            \"calling a function with return type {:?} passing \\\n-                                    return place of type {:?}\",\n-                            callee_fn_abi.ret.layout.ty,\n-                            caller_fn_abi.ret.layout.ty,\n+                        let callee_ty = format!(\"{}\", callee_fn_abi.ret.layout.ty);\n+                        let caller_ty = format!(\"{}\", caller_fn_abi.ret.layout.ty);\n+                        throw_ub_custom!(\n+                            fluent::const_eval_incompatible_return_types,\n+                            callee_ty = callee_ty,\n+                            caller_ty = caller_ty,\n                         )\n                     }\n                 };\n@@ -587,9 +591,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let (recv, vptr) = self.unpack_dyn_star(&receiver_place.into())?;\n                     let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n                     if dyn_trait != data.principal() {\n-                        throw_ub_format!(\n-                            \"`dyn*` call on a pointer whose vtable does not match its type\"\n-                        );\n+                        throw_ub_custom!(fluent::const_eval_dyn_star_call_vtable_mismatch);\n                     }\n                     let recv = recv.assert_mem_place(); // we passed an MPlaceTy to `unpack_dyn_star` so we definitely still have one\n \n@@ -609,9 +611,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n                     let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n                     if dyn_trait != data.principal() {\n-                        throw_ub_format!(\n-                            \"`dyn` call on a pointer whose vtable does not match its type\"\n-                        );\n+                        throw_ub_custom!(fluent::const_eval_dyn_call_vtable_mismatch);\n                     }\n \n                     // It might be surprising that we use a pointer as the receiver even if this\n@@ -623,7 +623,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Now determine the actual method to call. We can do that in two different ways and\n                 // compare them to ensure everything fits.\n                 let Some(ty::VtblEntry::Method(fn_inst)) = self.get_vtable_entries(vptr)?.get(idx).copied() else {\n-                    throw_ub_format!(\"`dyn` call trying to call something that is not a method\")\n+                    // FIXME(fee1-dead) these could be variants of the UB info enum instead of this\n+                    throw_ub_custom!(fluent::const_eval_dyn_call_not_a_method);\n                 };\n                 trace!(\"Virtual call dispatches to {fn_inst:#?}\");\n                 if cfg!(debug_assertions) {"}, {"sha": "21c655988a0e183e6615c67db9a7c1b0f8d89d12", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 95, "deletions": 122, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,15 +4,18 @@\n //! That's useful because it means other passes (e.g. promotion) can rely on `const`s\n //! to be const-safe.\n \n-use std::fmt::{Display, Write};\n+use std::fmt::Write;\n use std::num::NonZeroUsize;\n \n use either::{Left, Right};\n \n use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_middle::mir::interpret::InterpError;\n+use rustc_middle::mir::interpret::{\n+    ExpectedKind, InterpError, InvalidMetaKind, PointerKind, ValidationErrorInfo,\n+    ValidationErrorKind, ValidationErrorKind::*,\n+};\n use rustc_middle::ty;\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_span::symbol::{sym, Symbol};\n@@ -30,14 +33,7 @@ use super::{\n };\n \n macro_rules! throw_validation_failure {\n-    ($where:expr, { $( $what_fmt:tt )* } $( expected { $( $expected_fmt:tt )* } )?) => {{\n-        let mut msg = String::new();\n-        msg.push_str(\"encountered \");\n-        write!(&mut msg, $($what_fmt)*).unwrap();\n-        $(\n-            msg.push_str(\", but expected \");\n-            write!(&mut msg, $($expected_fmt)*).unwrap();\n-        )?\n+    ($where:expr, $kind: expr) => {{\n         let where_ = &$where;\n         let path = if !where_.is_empty() {\n             let mut path = String::new();\n@@ -46,7 +42,8 @@ macro_rules! throw_validation_failure {\n         } else {\n             None\n         };\n-        throw_ub!(ValidationFailure { path, msg })\n+\n+        throw_ub!(Validation(ValidationErrorInfo { path, kind: $kind }))\n     }};\n }\n \n@@ -82,22 +79,22 @@ macro_rules! throw_validation_failure {\n ///\n macro_rules! try_validation {\n     ($e:expr, $where:expr,\n-    $( $( $p:pat_param )|+ => { $( $what_fmt:tt )* } $( expected { $( $expected_fmt:tt )* } )? ),+ $(,)?\n+    $( $( $p:pat_param )|+ => $kind: expr ),+ $(,)?\n     ) => {{\n         match $e {\n             Ok(x) => x,\n             // We catch the error and turn it into a validation failure. We are okay with\n             // allocation here as this can only slow down builds that fail anyway.\n-            Err(e) => match e.kind() {\n+            Err(e) => match e.into_parts() {\n                 $(\n-                    InterpError::UndefinedBehavior($($p)|+) =>\n+                    (InterpError::UndefinedBehavior($($p)|+), _) =>\n                        throw_validation_failure!(\n                             $where,\n-                            { $( $what_fmt )* } $( expected { $( $expected_fmt )* } )?\n+                            $kind\n                         )\n                 ),+,\n                 #[allow(unreachable_patterns)]\n-                _ => Err::<!, _>(e)?,\n+                (e, rest) => Err::<!, _>($crate::interpret::InterpErrorInfo::from_parts(e, rest))?,\n             }\n         }\n     }};\n@@ -160,6 +157,7 @@ impl<T: Copy + Eq + Hash + std::fmt::Debug, PATH: Default> RefTracking<T, PATH>\n     }\n }\n \n+// FIXME make this translatable as well?\n /// Format a path\n fn write_path(out: &mut String, path: &[PathElem]) {\n     use self::PathElem::*;\n@@ -185,26 +183,6 @@ fn write_path(out: &mut String, path: &[PathElem]) {\n     }\n }\n \n-// Formats such that a sentence like \"expected something {}\" to mean\n-// \"expected something <in the given range>\" makes sense.\n-fn wrapping_range_format(r: WrappingRange, max_hi: u128) -> String {\n-    let WrappingRange { start: lo, end: hi } = r;\n-    assert!(hi <= max_hi);\n-    if lo > hi {\n-        format!(\"less or equal to {}, or greater or equal to {}\", hi, lo)\n-    } else if lo == hi {\n-        format!(\"equal to {}\", lo)\n-    } else if lo == 0 {\n-        assert!(hi < max_hi, \"should not be printing if the range covers everything\");\n-        format!(\"less or equal to {}\", hi)\n-    } else if hi == max_hi {\n-        assert!(lo > 0, \"should not be printing if the range covers everything\");\n-        format!(\"greater or equal to {}\", lo)\n-    } else {\n-        format!(\"in the range {:?}\", r)\n-    }\n-}\n-\n struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// The `path` may be pushed to, but the part that is present when a function\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n@@ -311,19 +289,19 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn read_immediate(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n-        expected: impl Display,\n+        expected: ExpectedKind,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::Provenance>> {\n         Ok(try_validation!(\n             self.ecx.read_immediate(op),\n             self.path,\n-            InvalidUninitBytes(None) => { \"uninitialized memory\" } expected { \"{expected}\" }\n+            InvalidUninitBytes(None) => Uninit { expected }\n         ))\n     }\n \n     fn read_scalar(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n-        expected: impl Display,\n+        expected: ExpectedKind,\n     ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n         Ok(self.read_immediate(op, expected)?.to_scalar())\n     }\n@@ -342,8 +320,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     self.ecx.get_ptr_vtable(vtable),\n                     self.path,\n                     DanglingIntPointer(..) |\n-                    InvalidVTablePointer(..) =>\n-                        { \"{vtable}\" } expected { \"a vtable pointer\" },\n+                    InvalidVTablePointer(..) => InvalidVTablePtr { value: format!(\"{vtable}\") }\n                 );\n                 // FIXME: check if the type/trait match what ty::Dynamic says?\n             }\n@@ -366,10 +343,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn check_safe_pointer(\n         &mut self,\n         value: &OpTy<'tcx, M::Provenance>,\n-        kind: &str,\n+        ptr_kind: PointerKind,\n     ) -> InterpResult<'tcx> {\n-        let place =\n-            self.ecx.ref_to_mplace(&self.read_immediate(value, format_args!(\"a {kind}\"))?)?;\n+        let place = self.ecx.ref_to_mplace(&self.read_immediate(value, ptr_kind.into())?)?;\n         // Handle wide pointers.\n         // Check metadata early, for better diagnostics\n         if place.layout.is_unsized() {\n@@ -379,7 +355,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let size_and_align = try_validation!(\n             self.ecx.size_and_align_of_mplace(&place),\n             self.path,\n-            InvalidMeta(msg) => { \"invalid {} metadata: {}\", kind, msg },\n+            InvalidMeta(msg) => match msg {\n+                InvalidMetaKind::SliceTooBig => InvalidMetaSliceTooLarge { ptr_kind },\n+                InvalidMetaKind::TooBig => InvalidMetaTooLarge { ptr_kind },\n+            }\n         );\n         let (size, align) = size_and_align\n             // for the purpose of validity, consider foreign types to have\n@@ -395,31 +374,30 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 CheckInAllocMsg::InboundsTest, // will anyway be replaced by validity message\n             ),\n             self.path,\n-            AlignmentCheckFailed { required, has } =>\n-                {\n-                    \"an unaligned {kind} (required {} byte alignment but found {})\",\n-                    required.bytes(),\n-                    has.bytes(),\n-                },\n-            DanglingIntPointer(0, _) =>\n-                { \"a null {kind}\" },\n-            DanglingIntPointer(i, _) =>\n-                {\n-                    \"a dangling {kind} ({pointer} has no provenance)\",\n-                    pointer = Pointer::<Option<AllocId>>::from_addr_invalid(*i),\n-                },\n-            PointerOutOfBounds { .. } =>\n-                { \"a dangling {kind} (going beyond the bounds of its allocation)\" },\n+            AlignmentCheckFailed { required, has } => UnalignedPtr {\n+                ptr_kind,\n+                required_bytes: required.bytes(),\n+                found_bytes: has.bytes()\n+            },\n+            DanglingIntPointer(0, _) => NullPtr { ptr_kind },\n+            DanglingIntPointer(i, _) => DanglingPtrNoProvenance {\n+                ptr_kind,\n+                // FIXME this says \"null pointer\" when null but we need translate\n+                pointer: format!(\"{}\", Pointer::<Option<AllocId>>::from_addr_invalid(i))\n+            },\n+            PointerOutOfBounds { .. } => DanglingPtrOutOfBounds {\n+                ptr_kind\n+            },\n             // This cannot happen during const-eval (because interning already detects\n             // dangling pointers), but it can happen in Miri.\n-            PointerUseAfterFree(..) =>\n-                { \"a dangling {kind} (use-after-free)\" },\n+            PointerUseAfterFree(..) => DanglingPtrUseAfterFree {\n+                ptr_kind,\n+            },\n         );\n         // Do not allow pointers to uninhabited types.\n         if place.layout.abi.is_uninhabited() {\n-            throw_validation_failure!(self.path,\n-                { \"a {kind} pointing to uninhabited type {}\", place.layout.ty }\n-            )\n+            let ty = place.layout.ty;\n+            throw_validation_failure!(self.path, PtrToUninhabited { ptr_kind, ty })\n         }\n         // Recursive checking\n         if let Some(ref_tracking) = self.ref_tracking.as_deref_mut() {\n@@ -441,9 +419,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                             // this check is so important.\n                             // This check is reachable when the const just referenced the static,\n                             // but never read it (so we never entered `before_access_global`).\n-                            throw_validation_failure!(self.path,\n-                                { \"a {} pointing to a static variable in a constant\", kind }\n-                            );\n+                            throw_validation_failure!(self.path, PtrToStatic { ptr_kind });\n                         }\n                         // We skip recursively checking other statics. These statics must be sound by\n                         // themselves, and the only way to get broken statics here is by using\n@@ -464,9 +440,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                             // This should be unreachable, but if someone manages to copy a pointer\n                             // out of a `static`, then that pointer might point to mutable memory,\n                             // and we would catch that here.\n-                            throw_validation_failure!(self.path,\n-                                { \"a {} pointing to mutable memory in a constant\", kind }\n-                            );\n+                            throw_validation_failure!(self.path, PtrToMut { ptr_kind });\n                         }\n                     }\n                     // Nothing to check for these.\n@@ -496,22 +470,24 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let ty = value.layout.ty;\n         match ty.kind() {\n             ty::Bool => {\n-                let value = self.read_scalar(value, \"a boolean\")?;\n+                let value = self.read_scalar(value, ExpectedKind::Bool)?;\n                 try_validation!(\n                     value.to_bool(),\n                     self.path,\n-                    InvalidBool(..) =>\n-                        { \"{:x}\", value } expected { \"a boolean\" },\n+                    InvalidBool(..) => ValidationErrorKind::InvalidBool {\n+                        value: format!(\"{value:x}\"),\n+                    }\n                 );\n                 Ok(true)\n             }\n             ty::Char => {\n-                let value = self.read_scalar(value, \"a unicode scalar value\")?;\n+                let value = self.read_scalar(value, ExpectedKind::Char)?;\n                 try_validation!(\n                     value.to_char(),\n                     self.path,\n-                    InvalidChar(..) =>\n-                        { \"{:x}\", value } expected { \"a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\" },\n+                    InvalidChar(..) => ValidationErrorKind::InvalidChar {\n+                        value: format!(\"{value:x}\"),\n+                    }\n                 );\n                 Ok(true)\n             }\n@@ -521,16 +497,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let value = self.read_scalar(\n                     value,\n                     if matches!(ty.kind(), ty::Float(..)) {\n-                        \"a floating point number\"\n+                        ExpectedKind::Float\n                     } else {\n-                        \"an integer\"\n+                        ExpectedKind::Int\n                     },\n                 )?;\n                 // As a special exception we *do* match on a `Scalar` here, since we truly want\n                 // to know its underlying representation (and *not* cast it to an integer).\n                 if matches!(value, Scalar::Ptr(..)) {\n-                    throw_validation_failure!(self.path,\n-                        { \"{:x}\", value } expected { \"plain (non-pointer) bytes\" }\n+                    throw_validation_failure!(\n+                        self.path,\n+                        ExpectedNonPtr { value: format!(\"{value:x}\") }\n                     )\n                 }\n                 Ok(true)\n@@ -540,7 +517,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n                 let place =\n-                    self.ecx.ref_to_mplace(&self.read_immediate(value, \"a raw pointer\")?)?;\n+                    self.ecx.ref_to_mplace(&self.read_immediate(value, ExpectedKind::RawPtr)?)?;\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n@@ -554,14 +531,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     // a ZST).\n                     let layout = self.ecx.layout_of(*ty)?;\n                     if !layout.is_zst() {\n-                        throw_validation_failure!(self.path, { \"mutable reference in a `const`\" });\n+                        throw_validation_failure!(self.path, MutableRefInConst);\n                     }\n                 }\n-                self.check_safe_pointer(value, \"reference\")?;\n+                self.check_safe_pointer(value, PointerKind::Ref)?;\n                 Ok(true)\n             }\n             ty::FnPtr(_sig) => {\n-                let value = self.read_scalar(value, \"a function pointer\")?;\n+                let value = self.read_scalar(value, ExpectedKind::FnPtr)?;\n \n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n@@ -570,19 +547,20 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,\n                         DanglingIntPointer(..) |\n-                        InvalidFunctionPointer(..) =>\n-                            { \"{ptr}\" } expected { \"a function pointer\" },\n+                        InvalidFunctionPointer(..) => InvalidFnPtr {\n+                            value: format!(\"{ptr}\"),\n+                        },\n                     );\n                     // FIXME: Check if the signature matches\n                 } else {\n                     // Otherwise (for standalone Miri), we have to still check it to be non-null.\n                     if self.ecx.scalar_may_be_null(value)? {\n-                        throw_validation_failure!(self.path, { \"a null function pointer\" });\n+                        throw_validation_failure!(self.path, NullFnPtr);\n                     }\n                 }\n                 Ok(true)\n             }\n-            ty::Never => throw_validation_failure!(self.path, { \"a value of the never type `!`\" }),\n+            ty::Never => throw_validation_failure!(self.path, NeverVal),\n             ty::Foreign(..) | ty::FnDef(..) => {\n                 // Nothing to check.\n                 Ok(true)\n@@ -629,12 +607,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 if start == 1 && end == max_value {\n                     // Only null is the niche. So make sure the ptr is NOT null.\n                     if self.ecx.scalar_may_be_null(scalar)? {\n-                        throw_validation_failure!(self.path,\n-                            { \"a potentially null pointer\" }\n-                            expected {\n-                                \"something that cannot possibly fail to be {}\",\n-                                wrapping_range_format(valid_range, max_value)\n-                            }\n+                        throw_validation_failure!(\n+                            self.path,\n+                            NullablePtrOutOfRange { range: valid_range, max_value }\n                         )\n                     } else {\n                         return Ok(());\n@@ -645,12 +620,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 } else {\n                     // Conservatively, we reject, because the pointer *could* have a bad\n                     // value.\n-                    throw_validation_failure!(self.path,\n-                        { \"a pointer\" }\n-                        expected {\n-                            \"something that cannot possibly fail to be {}\",\n-                            wrapping_range_format(valid_range, max_value)\n-                        }\n+                    throw_validation_failure!(\n+                        self.path,\n+                        PtrOutOfRange { range: valid_range, max_value }\n                     )\n                 }\n             }\n@@ -659,9 +631,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if valid_range.contains(bits) {\n             Ok(())\n         } else {\n-            throw_validation_failure!(self.path,\n-                { \"{}\", bits }\n-                expected { \"something {}\", wrapping_range_format(valid_range, max_value) }\n+            throw_validation_failure!(\n+                self.path,\n+                OutOfRange { value: format!(\"{bits}\"), range: valid_range, max_value }\n             )\n         }\n     }\n@@ -685,10 +657,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             Ok(try_validation!(\n                 this.ecx.read_discriminant(op),\n                 this.path,\n-                InvalidTag(val) =>\n-                    { \"{:x}\", val } expected { \"a valid enum tag\" },\n-                InvalidUninitBytes(None) =>\n-                    { \"uninitialized bytes\" } expected { \"a valid enum tag\" },\n+                InvalidTag(val) => InvalidEnumTag {\n+                    value: format!(\"{val:x}\"),\n+                },\n+\n+                InvalidUninitBytes(None) => UninitEnumTag,\n             )\n             .1)\n         })\n@@ -730,15 +703,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // Special check preventing `UnsafeCell` inside unions in the inner part of constants.\n         if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. })) {\n             if !op.layout.ty.is_freeze(*self.ecx.tcx, self.ecx.param_env) {\n-                throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n+                throw_validation_failure!(self.path, UnsafeCell);\n             }\n         }\n         Ok(())\n     }\n \n     #[inline]\n     fn visit_box(&mut self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx> {\n-        self.check_safe_pointer(op, \"box\")?;\n+        self.check_safe_pointer(op, PointerKind::Box)?;\n         Ok(())\n     }\n \n@@ -756,7 +729,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. }))\n                 && def.is_unsafe_cell()\n             {\n-                throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n+                throw_validation_failure!(self.path, UnsafeCell);\n             }\n         }\n \n@@ -775,14 +748,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // MyNewtype and then the scalar in there).\n         match op.layout.abi {\n             Abi::Uninhabited => {\n-                throw_validation_failure!(self.path,\n-                    { \"a value of uninhabited type {:?}\", op.layout.ty }\n-                );\n+                let ty = op.layout.ty;\n+                throw_validation_failure!(self.path, UninhabitedVal { ty });\n             }\n             Abi::Scalar(scalar_layout) => {\n                 if !scalar_layout.is_uninit_valid() {\n                     // There is something to check here.\n-                    let scalar = self.read_scalar(op, \"initialized scalar value\")?;\n+                    let scalar = self.read_scalar(op, ExpectedKind::InitScalar)?;\n                     self.visit_scalar(scalar, scalar_layout)?;\n                 }\n             }\n@@ -792,7 +764,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // the other must be init.\n                 if !a_layout.is_uninit_valid() && !b_layout.is_uninit_valid() {\n                     let (a, b) =\n-                        self.read_immediate(op, \"initialized scalar value\")?.to_scalar_pair();\n+                        self.read_immediate(op, ExpectedKind::InitScalar)?.to_scalar_pair();\n                     self.visit_scalar(a, a_layout)?;\n                     self.visit_scalar(b, b_layout)?;\n                 }\n@@ -822,7 +794,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 try_validation!(\n                     self.ecx.read_bytes_ptr_strip_provenance(mplace.ptr, Size::from_bytes(len)),\n                     self.path,\n-                    InvalidUninitBytes(..) => { \"uninitialized data in `str`\" },\n+                    InvalidUninitBytes(..) => { UninitStr },\n                 );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)\n@@ -852,7 +824,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Left(mplace) => mplace,\n                     Right(imm) => match *imm {\n                         Immediate::Uninit =>\n-                            throw_validation_failure!(self.path, { \"uninitialized bytes\" }),\n+                            throw_validation_failure!(self.path, UninitVal),\n                         Immediate::Scalar(..) | Immediate::ScalarPair(..) =>\n                             bug!(\"arrays/slices can never have Scalar/ScalarPair layout\"),\n                     }\n@@ -888,7 +860,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                 .unwrap();\n                                 self.path.push(PathElem::ArrayElem(i));\n \n-                                throw_validation_failure!(self.path, { \"uninitialized bytes\" })\n+                                throw_validation_failure!(self.path, UninitVal)\n                             }\n \n                             // Propagate upwards (that will also check for unexpected errors).\n@@ -929,12 +901,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match visitor.visit_value(&op) {\n             Ok(()) => Ok(()),\n             // Pass through validation failures.\n-            Err(err) if matches!(err.kind(), err_ub!(ValidationFailure { .. })) => Err(err),\n+            Err(err) if matches!(err.kind(), err_ub!(Validation { .. })) => Err(err),\n             // Complain about any other kind of UB error -- those are bad because we'd like to\n             // report them in a way that shows *where* in the value the issue lies.\n             Err(err) if matches!(err.kind(), InterpError::UndefinedBehavior(_)) => {\n-                err.print_backtrace();\n-                bug!(\"Unexpected Undefined Behavior error during validation: {}\", err);\n+                let (err, backtrace) = err.into_parts();\n+                backtrace.print_backtrace();\n+                bug!(\"Unexpected Undefined Behavior error during validation: {err:?}\");\n             }\n             // Pass through everything else.\n             Err(err) => Err(err),"}, {"sha": "8314f53ba57bb5d49f3d941c1563fac38fa9de12", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,6 +4,7 @@ Rust MIR: a lowered representation of Rust.\n \n */\n \n+#![deny(rustc::untranslatable_diagnostic)]\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(decl_macro)]\n@@ -33,6 +34,8 @@ pub mod interpret;\n pub mod transform;\n pub mod util;\n \n+pub use errors::ReportErrorExt;\n+\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_fluent_macro::fluent_messages;\n use rustc_middle::query::Providers;\n@@ -56,10 +59,6 @@ pub fn provide(providers: &mut Providers) {\n     providers.valtree_to_const_val = |tcx, (ty, valtree)| {\n         const_eval::valtree_to_const_value(tcx, ty::ParamEnv::empty().and(ty), valtree)\n     };\n-    providers.deref_mir_constant = |tcx, param_env_and_value| {\n-        let (param_env, value) = param_env_and_value.into_parts();\n-        const_eval::deref_mir_constant(tcx, param_env, value)\n-    };\n     providers.check_validity_requirement = |tcx, (init_kind, param_env_and_ty)| {\n         util::check_validity_requirement(tcx, init_kind, param_env_and_ty)\n     };"}, {"sha": "236e43bdfcc71bc12f558f7b7d6285bee2e9789d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 54, "deletions": 79, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -2,9 +2,7 @@\n \n use hir::def_id::LocalDefId;\n use hir::{ConstContext, LangItem};\n-use rustc_errors::{\n-    error_code, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed,\n-};\n+use rustc_errors::{error_code, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -152,7 +150,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n \n                     if let Ok(Some(ImplSource::UserDefined(data))) = implsrc {\n                         let span = tcx.def_span(data.impl_def_id);\n-                        err.span_note(span, \"impl defined here, but it is not `const`\");\n+                        err.subdiagnostic(errors::NonConstImplNote { span });\n                     }\n                 }\n                 _ => {}\n@@ -166,76 +164,62 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n         let mut err = match call_kind {\n             CallKind::Normal { desugaring: Some((kind, self_ty)), .. } => {\n                 macro_rules! error {\n-                    ($fmt:literal) => {\n-                        struct_span_err!(tcx.sess, span, E0015, $fmt, self_ty, ccx.const_kind())\n+                    ($err:ident) => {\n+                        tcx.sess.create_err(errors::$err {\n+                            span,\n+                            ty: self_ty,\n+                            kind: ccx.const_kind(),\n+                        })\n                     };\n                 }\n \n                 let mut err = match kind {\n                     CallDesugaringKind::ForLoopIntoIter => {\n-                        error!(\"cannot convert `{}` into an iterator in {}s\")\n+                        error!(NonConstForLoopIntoIter)\n                     }\n                     CallDesugaringKind::QuestionBranch => {\n-                        error!(\"`?` cannot determine the branch of `{}` in {}s\")\n+                        error!(NonConstQuestionBranch)\n                     }\n                     CallDesugaringKind::QuestionFromResidual => {\n-                        error!(\"`?` cannot convert from residual of `{}` in {}s\")\n+                        error!(NonConstQuestionFromResidual)\n                     }\n                     CallDesugaringKind::TryBlockFromOutput => {\n-                        error!(\"`try` block cannot convert `{}` to the result in {}s\")\n+                        error!(NonConstTryBlockFromOutput)\n                     }\n                     CallDesugaringKind::Await => {\n-                        error!(\"cannot convert `{}` into a future in {}s\")\n+                        error!(NonConstAwait)\n                     }\n                 };\n \n                 diag_trait(&mut err, self_ty, kind.trait_def_id(tcx));\n                 err\n             }\n             CallKind::FnCall { fn_trait_id, self_ty } => {\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0015,\n-                    \"cannot call non-const closure in {}s\",\n-                    ccx.const_kind(),\n-                );\n-\n-                match self_ty.kind() {\n+                let note = match self_ty.kind() {\n                     FnDef(def_id, ..) => {\n                         let span = tcx.def_span(*def_id);\n                         if ccx.tcx.is_const_fn_raw(*def_id) {\n                             span_bug!(span, \"calling const FnDef errored when it shouldn't\");\n                         }\n \n-                        err.span_note(span, \"function defined here, but it is not `const`\");\n-                    }\n-                    FnPtr(..) => {\n-                        err.note(format!(\n-                            \"function pointers need an RFC before allowed to be called in {}s\",\n-                            ccx.const_kind()\n-                        ));\n+                        Some(errors::NonConstClosureNote::FnDef { span })\n                     }\n-                    Closure(..) => {\n-                        err.note(format!(\n-                            \"closures need an RFC before allowed to be called in {}s\",\n-                            ccx.const_kind()\n-                        ));\n-                    }\n-                    _ => {}\n-                }\n+                    FnPtr(..) => Some(errors::NonConstClosureNote::FnPtr),\n+                    Closure(..) => Some(errors::NonConstClosureNote::Closure),\n+                    _ => None,\n+                };\n+\n+                let mut err = tcx.sess.create_err(errors::NonConstClosure {\n+                    span,\n+                    kind: ccx.const_kind(),\n+                    note,\n+                });\n \n                 diag_trait(&mut err, self_ty, fn_trait_id);\n                 err\n             }\n             CallKind::Operator { trait_id, self_ty, .. } => {\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0015,\n-                    \"cannot call non-const operator in {}s\",\n-                    ccx.const_kind()\n-                );\n+                let mut sugg = None;\n \n                 if Some(trait_id) == ccx.tcx.lang_items().eq_trait() {\n                     match (substs[0].unpack(), substs[1].unpack()) {\n@@ -260,41 +244,41 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                                         let rhs_pos =\n                                             span.lo() + BytePos::from_usize(eq_idx + 2 + rhs_idx);\n                                         let rhs_span = span.with_lo(rhs_pos).with_hi(rhs_pos);\n-                                        err.multipart_suggestion(\n-                                            \"consider dereferencing here\",\n-                                            vec![\n-                                                (span.shrink_to_lo(), deref.clone()),\n-                                                (rhs_span, deref),\n-                                            ],\n-                                            Applicability::MachineApplicable,\n-                                        );\n+                                        sugg = Some(errors::ConsiderDereferencing {\n+                                            deref,\n+                                            span: span.shrink_to_lo(),\n+                                            rhs_span,\n+                                        });\n                                     }\n                                 }\n                             }\n                         }\n                         _ => {}\n                     }\n                 }\n-\n+                let mut err = tcx.sess.create_err(errors::NonConstOperator {\n+                    span,\n+                    kind: ccx.const_kind(),\n+                    sugg,\n+                });\n                 diag_trait(&mut err, self_ty, trait_id);\n                 err\n             }\n             CallKind::DerefCoercion { deref_target, deref_target_ty, self_ty } => {\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0015,\n-                    \"cannot perform deref coercion on `{}` in {}s\",\n-                    self_ty,\n-                    ccx.const_kind()\n-                );\n-\n-                err.note(format!(\"attempting to deref into `{}`\", deref_target_ty));\n-\n                 // Check first whether the source is accessible (issue #87060)\n-                if tcx.sess.source_map().is_span_accessible(deref_target) {\n-                    err.span_note(deref_target, \"deref defined here\");\n-                }\n+                let target = if tcx.sess.source_map().is_span_accessible(deref_target) {\n+                    Some(deref_target)\n+                } else {\n+                    None\n+                };\n+\n+                let mut err = tcx.sess.create_err(errors::NonConstDerefCoercion {\n+                    span,\n+                    ty: self_ty,\n+                    kind: ccx.const_kind(),\n+                    target_ty: deref_target_ty,\n+                    deref_target: target,\n+                });\n \n                 diag_trait(&mut err, self_ty, tcx.require_lang_item(LangItem::Deref, Some(span)));\n                 err\n@@ -432,21 +416,12 @@ impl<'tcx> NonConstOp<'tcx> for LiveDrop<'tcx> {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0493,\n-            \"destructor of `{}` cannot be evaluated at compile-time\",\n-            self.dropped_ty,\n-        );\n-        err.span_label(\n+        ccx.tcx.sess.create_err(errors::LiveDrop {\n             span,\n-            format!(\"the destructor for this type cannot be evaluated in {}s\", ccx.const_kind()),\n-        );\n-        if let Some(span) = self.dropped_at {\n-            err.span_label(span, \"value is dropped here\");\n-        }\n-        err\n+            dropped_ty: self.dropped_ty,\n+            kind: ccx.const_kind(),\n+            dropped_at: self.dropped_at,\n+        })\n     }\n }\n "}, {"sha": "29063261adab6e3cad9e3ed385e71f0d991d920b", "filename": "compiler/rustc_const_eval/src/util/check_validity_requirement.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcheck_validity_requirement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcheck_validity_requirement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcheck_validity_requirement.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,6 +1,5 @@\n use rustc_middle::ty::layout::{LayoutCx, LayoutError, LayoutOf, TyAndLayout, ValidityRequirement};\n use rustc_middle::ty::{ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n-use rustc_session::Limit;\n use rustc_target::abi::{Abi, FieldsShape, Scalar, Variants};\n \n use crate::const_eval::{CheckAlignment, CompileTimeInterpreter};\n@@ -45,11 +44,8 @@ fn might_permit_raw_init_strict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     kind: ValidityRequirement,\n ) -> Result<bool, LayoutError<'tcx>> {\n-    let machine = CompileTimeInterpreter::new(\n-        Limit::new(0),\n-        /*can_access_statics:*/ false,\n-        CheckAlignment::Error,\n-    );\n+    let machine =\n+        CompileTimeInterpreter::new(/*can_access_statics:*/ false, CheckAlignment::Error);\n \n     let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);\n "}, {"sha": "25a08237346dd9cb02a42e8e565ecaeb996f45af", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -139,9 +139,14 @@ cfg_if! {\n \n         impl Atomic<bool> {\n             pub fn fetch_or(&self, val: bool, _: Ordering) -> bool {\n-                let result = self.0.get() | val;\n-                self.0.set(val);\n-                result\n+                let old = self.0.get();\n+                self.0.set(val | old);\n+                old\n+            }\n+            pub fn fetch_and(&self, val: bool, _: Ordering) -> bool {\n+                let old = self.0.get();\n+                self.0.set(val & old);\n+                old\n             }\n         }\n "}, {"sha": "f3ee83fd4d218e4c38e6e8ae21a0f2ebe5470135", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -492,6 +492,10 @@ impl MultiSpan {\n         replacements_occurred\n     }\n \n+    pub fn pop_span_label(&mut self) -> Option<(Span, DiagnosticMessage)> {\n+        self.span_labels.pop()\n+    }\n+\n     /// Returns the strings to highlight. We always ensure that there\n     /// is an entry for each of the primary spans -- for each primary\n     /// span `P`, if there is at least one label with span `P`, we return"}, {"sha": "8e8223c3cf8aac8fd5f09f50bb440cd0761fc051", "filename": "compiler/rustc_errors/messages.ftl", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_errors%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_errors%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fmessages.ftl?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -8,7 +8,11 @@ errors_target_invalid_address_space =\n     invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n \n errors_target_invalid_alignment =\n-    invalid alignment for `{$cause}` in \"data-layout\": {$err}\n+    invalid alignment for `{$cause}` in \"data-layout\": `{$align}` is {$err_kind ->\n+        [not_power_of_two] not a power of 2\n+        [too_large] too large\n+        *[other] {\"\"}\n+    }\n \n errors_target_invalid_bits =\n     invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}"}, {"sha": "ed0d06ed0ff77997434f6980801543d8dd98bdcf", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -10,7 +10,7 @@ use rustc_lint_defs::{Applicability, LintExpectationId};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use std::borrow::Cow;\n-use std::fmt;\n+use std::fmt::{self, Debug};\n use std::hash::{Hash, Hasher};\n use std::panic::Location;\n \n@@ -33,7 +33,7 @@ pub type DiagnosticArgName<'source> = Cow<'source, str>;\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n pub enum DiagnosticArgValue<'source> {\n     Str(Cow<'source, str>),\n-    Number(usize),\n+    Number(i128),\n     StrListSepByAnd(Vec<Cow<'source, str>>),\n }\n "}, {"sha": "10fe7fc74a873be7a10dc88eefc6f02442ec2709", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -60,10 +60,8 @@ into_diagnostic_arg_using_display!(\n     u8,\n     i16,\n     u16,\n-    i32,\n     u32,\n     i64,\n-    u64,\n     i128,\n     u128,\n     std::io::Error,\n@@ -80,6 +78,18 @@ into_diagnostic_arg_using_display!(\n     ExitStatus,\n );\n \n+impl IntoDiagnosticArg for i32 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Number(self.into())\n+    }\n+}\n+\n+impl IntoDiagnosticArg for u64 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Number(self.into())\n+    }\n+}\n+\n impl IntoDiagnosticArg for bool {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         if self {\n@@ -134,7 +144,7 @@ impl IntoDiagnosticArg for PathBuf {\n \n impl IntoDiagnosticArg for usize {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Number(self)\n+        DiagnosticArgValue::Number(self as i128)\n     }\n }\n \n@@ -147,9 +157,9 @@ impl IntoDiagnosticArg for PanicStrategy {\n impl IntoDiagnosticArg for hir::ConstContext {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Borrowed(match self {\n-            hir::ConstContext::ConstFn => \"constant function\",\n+            hir::ConstContext::ConstFn => \"const_fn\",\n             hir::ConstContext::Static(_) => \"static\",\n-            hir::ConstContext::Const => \"constant\",\n+            hir::ConstContext::Const => \"const\",\n         }))\n     }\n }\n@@ -254,7 +264,8 @@ impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n             TargetDataLayoutErrors::InvalidAlignment { cause, err } => {\n                 diag = handler.struct_fatal(fluent::errors_target_invalid_alignment);\n                 diag.set_arg(\"cause\", cause);\n-                diag.set_arg(\"err\", err);\n+                diag.set_arg(\"err_kind\", err.diag_ident());\n+                diag.set_arg(\"align\", err.align());\n                 diag\n             }\n             TargetDataLayoutErrors::InconsistentTargetArchitecture { dl, target } => {"}, {"sha": "0170d52e82a2ef1b024708cdf3884af957fe9675", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -131,7 +131,7 @@ declare_features! (\n     /// Allows `crate` in paths.\n     (accepted, crate_in_paths, \"1.30.0\", Some(45477), None),\n     /// Allows using `#[debugger_visualizer]` attribute.\n-    (accepted, debugger_visualizer, \"CURRENT_RUSTC_VERSION\", Some(95939), None),\n+    (accepted, debugger_visualizer, \"1.71.0\", Some(95939), None),\n     /// Allows rustc to inject a default alloc_error_handler\n     (accepted, default_alloc_error_handler, \"1.68.0\", Some(66741), None),\n     /// Allows using assigning a default type to type parameters in algebraic data type definitions.\n@@ -281,7 +281,7 @@ declare_features! (\n     /// Allows use of the postfix `?` operator in expressions.\n     (accepted, question_mark, \"1.13.0\", Some(31436), None),\n     /// Allows the use of raw-dylibs (RFC 2627).\n-    (accepted, raw_dylib, \"CURRENT_RUSTC_VERSION\", Some(58713), None),\n+    (accepted, raw_dylib, \"1.71.0\", Some(58713), None),\n     /// Allows keywords to be escaped for use as identifiers.\n     (accepted, raw_identifiers, \"1.30.0\", Some(48589), None),\n     /// Allows relaxing the coherence rules such that"}, {"sha": "4c53f9d8369fda7fa853908b88f99de47859585b", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -165,7 +165,7 @@ declare_features! (\n     /// Allows the `multiple_supertrait_upcastable` lint.\n     (active, multiple_supertrait_upcastable, \"1.69.0\", None, None),\n     /// Allow negative trait bounds. This is an internal-only feature for testing the trait solver!\n-    (incomplete, negative_bounds, \"CURRENT_RUSTC_VERSION\", None, None),\n+    (incomplete, negative_bounds, \"1.71.0\", None, None),\n     /// Allows using `#[omit_gdb_pretty_printer_section]`.\n     (active, omit_gdb_pretty_printer_section, \"1.5.0\", None, None),\n     /// Allows using `#[prelude_import]` on glob `use` items.\n@@ -314,15 +314,15 @@ declare_features! (\n     /// Allows async functions to be declared, implemented, and used in traits.\n     (active, async_fn_in_trait, \"1.66.0\", Some(91611), None),\n     /// Allows builtin # foo() syntax\n-    (active, builtin_syntax, \"CURRENT_RUSTC_VERSION\", Some(110680), None),\n+    (active, builtin_syntax, \"1.71.0\", Some(110680), None),\n     /// Allows `c\"foo\"` literals.\n-    (active, c_str_literals, \"CURRENT_RUSTC_VERSION\", Some(105723), None),\n+    (active, c_str_literals, \"1.71.0\", Some(105723), None),\n     /// Treat `extern \"C\"` function as nounwind.\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n     /// Allows using C-variadics.\n     (active, c_variadic, \"1.34.0\", Some(44930), None),\n     /// Allows the use of `#[cfg(overflow_checks)` to check if integer overflow behaviour.\n-    (active, cfg_overflow_checks, \"CURRENT_RUSTC_VERSION\", Some(111466), None),\n+    (active, cfg_overflow_checks, \"1.71.0\", Some(111466), None),\n     /// Allows the use of `#[cfg(sanitize = \"option\")]`; set when -Zsanitizer is used.\n     (active, cfg_sanitize, \"1.41.0\", Some(39699), None),\n     /// Allows `cfg(target_abi = \"...\")`.\n@@ -338,7 +338,7 @@ declare_features! (\n     /// Allow conditional compilation depending on rust version\n     (active, cfg_version, \"1.45.0\", Some(64796), None),\n     /// Allows to use the `#[cfi_encoding = \"\"]` attribute.\n-    (active, cfi_encoding, \"CURRENT_RUSTC_VERSION\", Some(89653), None),\n+    (active, cfi_encoding, \"1.71.0\", Some(89653), None),\n     /// Allows `for<...>` on closures and generators.\n     (active, closure_lifetime_binder, \"1.64.0\", Some(97362), None),\n     /// Allows `#[track_caller]` on closures and generators.\n@@ -351,8 +351,6 @@ declare_features! (\n     (active, const_async_blocks, \"1.53.0\", Some(85368), None),\n     /// Allows `const || {}` closures in const contexts.\n     (incomplete, const_closures, \"1.68.0\", Some(106003), None),\n-    /// Allows limiting the evaluation steps of const expressions\n-    (active, const_eval_limit, \"1.43.0\", Some(67217), None),\n     /// Allows the definition of `const extern fn` and `const unsafe extern fn`.\n     (active, const_extern_fn, \"1.40.0\", Some(64926), None),\n     /// Allows basic arithmetic on floating point types in a `const fn`."}, {"sha": "9be28c338f64b80c13956229b1ae3e6eb12a7266", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -355,10 +355,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Limits:\n     ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), FutureWarnFollowing),\n     ungated!(type_length_limit, CrateLevel, template!(NameValueStr: \"N\"), FutureWarnFollowing),\n-    gated!(\n-        const_eval_limit, CrateLevel, template!(NameValueStr: \"N\"), ErrorFollowing,\n-        const_eval_limit, experimental!(const_eval_limit)\n-    ),\n     gated!(\n         move_size_limit, CrateLevel, template!(NameValueStr: \"N\"), ErrorFollowing,\n         large_assignments, experimental!(move_size_limit)"}, {"sha": "ed5d76b861a4905cfd4c4691a2edb3d46ee4c104", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -59,8 +59,10 @@ declare_features! (\n     /// Allows comparing raw pointers during const eval.\n     (removed, const_compare_raw_pointers, \"1.46.0\", Some(53020), None,\n      Some(\"cannot be allowed in const eval in any meaningful way\")),\n+    /// Allows limiting the evaluation steps of const expressions\n+    (removed, const_eval_limit, \"1.43.0\", Some(67217), None, Some(\"removed the limit entirely\")),\n     /// Allows non-trivial generic constants which have to be manually propagated upwards.\n-     (removed, const_evaluatable_checked, \"1.48.0\", Some(76560), None, Some(\"renamed to `generic_const_exprs`\")),\n+    (removed, const_evaluatable_checked, \"1.48.0\", Some(76560), None, Some(\"renamed to `generic_const_exprs`\")),\n     /// Allows the definition of `const` functions with some advanced features.\n     (removed, const_fn, \"1.54.0\", Some(57563), None,\n      Some(\"split into finer-grained feature gates\")),"}, {"sha": "89f96695a2f6913609702a3529e282d006881d70", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -177,7 +177,7 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         }\n         // Generic statics are rejected, but we still reach this case.\n         Err(e) => {\n-            tcx.sess.delay_span_bug(span, e.to_string());\n+            tcx.sess.delay_span_bug(span, format!(\"{e:?}\"));\n             return;\n         }\n     };"}, {"sha": "4d96a7ff4c3d7de99c774c6ce0c1ff6b25787d65", "filename": "compiler/rustc_hir_analysis/src/collect/type_of/opaque.rs", "status": "modified", "additions": 78, "deletions": 33, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,3 +1,4 @@\n+use rustc_errors::StashKey;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{self as hir, Expr, ImplItem, Item, Node, TraitItem};\n@@ -59,7 +60,20 @@ pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: Local\n         }\n     }\n \n-    let Some(hidden) = locator.found else {\n+    if let Some(hidden) = locator.found {\n+        // Only check against typeck if we didn't already error\n+        if !hidden.ty.references_error() {\n+            for concrete_type in locator.typeck_types {\n+                if concrete_type.ty != tcx.erase_regions(hidden.ty)\n+                    && !(concrete_type, hidden).references_error()\n+                {\n+                    hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n+                }\n+            }\n+        }\n+\n+        hidden.ty\n+    } else {\n         let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n             span: tcx.def_span(def_id),\n             name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n@@ -70,21 +84,8 @@ pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: Local\n                 _ => \"item\",\n             },\n         });\n-        return tcx.ty_error(reported);\n-    };\n-\n-    // Only check against typeck if we didn't already error\n-    if !hidden.ty.references_error() {\n-        for concrete_type in locator.typeck_types {\n-            if concrete_type.ty != tcx.erase_regions(hidden.ty)\n-                && !(concrete_type, hidden).references_error()\n-            {\n-                hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n-            }\n-        }\n+        tcx.ty_error(reported)\n     }\n-\n-    hidden.ty\n }\n \n struct TaitConstraintLocator<'tcx> {\n@@ -130,13 +131,28 @@ impl TaitConstraintLocator<'_> {\n             self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n             return;\n         }\n-        let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n+\n+        let mut constrained = false;\n+        for (&opaque_type_key, &hidden_type) in &tables.concrete_opaque_types {\n+            if opaque_type_key.def_id != self.def_id {\n+                continue;\n+            }\n+            constrained = true;\n+            let concrete_type =\n+                self.tcx.erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n+                    opaque_type_key,\n+                    self.tcx,\n+                    true,\n+                ));\n+            if self.typeck_types.iter().all(|prev| prev.ty != concrete_type.ty) {\n+                self.typeck_types.push(concrete_type);\n+            }\n+        }\n+\n+        if !constrained {\n             debug!(\"no constraints in typeck results\");\n             return;\n         };\n-        if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n-            self.typeck_types.push(typeck_hidden_ty);\n-        }\n \n         // Use borrowck to get the type with unerased regions.\n         let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n@@ -190,45 +206,74 @@ impl<'tcx> intravisit::Visitor<'tcx> for TaitConstraintLocator<'tcx> {\n     }\n }\n \n-pub(super) fn find_opaque_ty_constraints_for_rpit(\n-    tcx: TyCtxt<'_>,\n+pub(super) fn find_opaque_ty_constraints_for_rpit<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n     owner_def_id: LocalDefId,\n ) -> Ty<'_> {\n-    let concrete = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n+    let tables = tcx.typeck(owner_def_id);\n+\n+    // Check that all of the opaques we inferred during HIR are compatible.\n+    // FIXME: We explicitly don't check that the types inferred during HIR\n+    // typeck are compatible with the one that we infer during borrowck,\n+    // because that one actually sometimes has consts evaluated eagerly so\n+    // using strict type equality will fail.\n+    let mut hir_opaque_ty: Option<ty::OpaqueHiddenType<'tcx>> = None;\n+    if tables.tainted_by_errors.is_none() {\n+        for (&opaque_type_key, &hidden_type) in &tables.concrete_opaque_types {\n+            if opaque_type_key.def_id != def_id {\n+                continue;\n+            }\n+            let concrete_type = tcx.erase_regions(\n+                hidden_type.remap_generic_params_to_declaration_params(opaque_type_key, tcx, true),\n+            );\n+            if let Some(prev) = &mut hir_opaque_ty {\n+                if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n+                    prev.report_mismatch(&concrete_type, def_id, tcx).stash(\n+                        tcx.def_span(opaque_type_key.def_id),\n+                        StashKey::OpaqueHiddenTypeMismatch,\n+                    );\n+                }\n+            } else {\n+                hir_opaque_ty = Some(concrete_type);\n+            }\n+        }\n+    }\n \n-    if let Some(concrete) = concrete {\n+    let mir_opaque_ty = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n+    if let Some(mir_opaque_ty) = mir_opaque_ty {\n         let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n         debug!(?scope);\n-        let mut locator = RpitConstraintChecker { def_id, tcx, found: concrete };\n+        let mut locator = RpitConstraintChecker { def_id, tcx, found: mir_opaque_ty };\n \n         match tcx.hir().get(scope) {\n             Node::Item(it) => intravisit::walk_item(&mut locator, it),\n             Node::ImplItem(it) => intravisit::walk_impl_item(&mut locator, it),\n             Node::TraitItem(it) => intravisit::walk_trait_item(&mut locator, it),\n             other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n         }\n-    }\n \n-    concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n-        let table = tcx.typeck(owner_def_id);\n-        if let Some(guar) = table.tainted_by_errors {\n-            // Some error in the\n-            // owner fn prevented us from populating\n+        mir_opaque_ty.ty\n+    } else {\n+        if let Some(guar) = tables.tainted_by_errors {\n+            // Some error in the owner fn prevented us from populating\n             // the `concrete_opaque_types` table.\n             tcx.ty_error(guar)\n         } else {\n-            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n+            // Fall back to the RPIT we inferred during HIR typeck\n+            if let Some(hir_opaque_ty) = hir_opaque_ty {\n+                hir_opaque_ty.ty\n+            } else {\n                 // We failed to resolve the opaque type or it\n                 // resolves to itself. We interpret this as the\n                 // no values of the hidden type ever being constructed,\n                 // so we can just make the hidden type be `!`.\n                 // For backwards compatibility reasons, we fall back to\n                 // `()` until we the diverging default is changed.\n                 tcx.mk_diverging_default()\n-            })\n+            }\n         }\n-    })\n+    }\n }\n \n struct RpitConstraintChecker<'tcx> {"}, {"sha": "e19b0664461a964c9ba4d409be4fcf288db90bef", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -874,7 +874,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let found = self.resolve_vars_with_obligations(found);\n \n         let in_loop = self.is_loop(id)\n-            || self.tcx.hir().parent_iter(id).any(|(parent_id, _)| self.is_loop(parent_id));\n+            || self\n+                .tcx\n+                .hir()\n+                .parent_iter(id)\n+                .take_while(|(_, node)| {\n+                    // look at parents until we find the first body owner\n+                    node.body_id().is_none()\n+                })\n+                .any(|(parent_id, _)| self.is_loop(parent_id));\n \n         let in_local_statement = self.is_local_statement(id)\n             || self"}, {"sha": "964acc4eb77ef803a6741f4fce489302da8cd8c9", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -583,19 +583,15 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 continue;\n             }\n \n-            let hidden_type =\n-                self.tcx().erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n-                    opaque_type_key,\n-                    self.tcx(),\n-                    true,\n-                ));\n-\n+            // Here we only detect impl trait definition conflicts when they\n+            // are equal modulo regions.\n             if let Some(last_opaque_ty) = self\n                 .typeck_results\n                 .concrete_opaque_types\n-                .insert(opaque_type_key.def_id, hidden_type)\n+                .insert(opaque_type_key, hidden_type)\n                 && last_opaque_ty.ty != hidden_type.ty\n             {\n+                assert!(!self.tcx().trait_solver_next());\n                 hidden_type\n                     .report_mismatch(&last_opaque_ty, opaque_type_key.def_id, self.tcx())\n                     .stash("}, {"sha": "98fe3821947d5a6b55cab266932ab553e49679eb", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -155,6 +155,8 @@ lint_builtin_unused_doc_comment = unused doc comment\n lint_builtin_while_true = denote infinite loops with `loop {\"{\"} ... {\"}\"}`\n     .suggestion = use `loop`\n \n+lint_cast_ref_to_mut = casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+\n lint_check_name_deprecated = lint name `{$lint_name}` is deprecated and does not have an effect anymore. Use: {$new_name}\n \n lint_check_name_unknown = unknown lint: `{$lint_name}`"}, {"sha": "213e8db66a056527af688d6f96f196a86619a69e", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1317,10 +1317,14 @@ declare_lint! {\n     ///\n     /// ### Explanation\n     ///\n-    /// A bare `pub` visibility may be misleading if the item is not actually\n-    /// publicly exported from the crate. The `pub(crate)` visibility is\n-    /// recommended to be used instead, which more clearly expresses the intent\n-    /// that the item is only visible within its own crate.\n+    /// The `pub` keyword both expresses an intent for an item to be publicly available, and also\n+    /// signals to the compiler to make the item publicly accessible. The intent can only be\n+    /// satisfied, however, if all items which contain this item are *also* publicly accessible.\n+    /// Thus, this lint serves to identify situations where the intent does not match the reality.\n+    ///\n+    /// If you wish the item to be accessible elsewhere within the crate, but not outside it, the\n+    /// `pub(crate)` visibility is recommended to be used instead. This more clearly expresses the\n+    /// intent that the item is only visible within its own crate.\n     ///\n     /// This lint is \"allow\" by default because it will trigger for a large\n     /// amount existing Rust code, and has some false-positives. Eventually it"}, {"sha": "84308d48c10bc28969df2db3fec668f418649eab", "filename": "compiler/rustc_lint/src/cast_ref_to_mut.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint%2Fsrc%2Fcast_ref_to_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint%2Fsrc%2Fcast_ref_to_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcast_ref_to_mut.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,72 @@\n+use rustc_ast::Mutability;\n+use rustc_hir::{Expr, ExprKind, MutTy, TyKind, UnOp};\n+use rustc_middle::ty;\n+use rustc_span::sym;\n+\n+use crate::{lints::CastRefToMutDiag, LateContext, LateLintPass, LintContext};\n+\n+declare_lint! {\n+    /// The `cast_ref_to_mut` lint checks for casts of `&T` to `&mut T`\n+    /// without using interior mutability.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// fn x(r: &i32) {\n+    ///     unsafe {\n+    ///         *(r as *const i32 as *mut i32) += 1;\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Casting `&T` to `&mut T` without using interior mutability is undefined behavior,\n+    /// as it's a violation of Rust reference aliasing requirements.\n+    ///\n+    /// `UnsafeCell` is the only way to obtain aliasable data that is considered\n+    /// mutable.\n+    CAST_REF_TO_MUT,\n+    Deny,\n+    \"casts of `&T` to `&mut T` without interior mutability\"\n+}\n+\n+declare_lint_pass!(CastRefToMut => [CAST_REF_TO_MUT]);\n+\n+impl<'tcx> LateLintPass<'tcx> for CastRefToMut {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        let ExprKind::Unary(UnOp::Deref, e) = &expr.kind else { return; };\n+\n+        let e = e.peel_blocks();\n+        let e = if let ExprKind::Cast(e, t) = e.kind\n+            && let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind {\n+            e\n+        } else if let ExprKind::MethodCall(_, expr, [], _) = e.kind\n+            && let Some(def_id) = cx.typeck_results().type_dependent_def_id(e.hir_id)\n+            && cx.tcx.is_diagnostic_item(sym::ptr_cast_mut, def_id) {\n+            expr\n+        } else {\n+            return;\n+        };\n+\n+        let e = e.peel_blocks();\n+        let e = if let ExprKind::Cast(e, t) = e.kind\n+            && let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind {\n+            e\n+        } else if let ExprKind::Call(path, [arg]) = e.kind\n+            && let ExprKind::Path(ref qpath) = path.kind\n+            && let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id()\n+            && cx.tcx.is_diagnostic_item(sym::ptr_from_ref, def_id) {\n+            arg\n+        } else {\n+            return;\n+        };\n+\n+        let e = e.peel_blocks();\n+        if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind() {\n+            cx.emit_spanned_lint(CAST_REF_TO_MUT, expr.span, CastRefToMutDiag);\n+        }\n+    }\n+}"}, {"sha": "5e3f057d4283428c202a08beab9e3f4f9f2fe959", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -50,6 +50,7 @@ extern crate tracing;\n \n mod array_into_iter;\n pub mod builtin;\n+mod cast_ref_to_mut;\n mod context;\n mod deref_into_dyn_supertrait;\n mod drop_forget_useless;\n@@ -97,6 +98,7 @@ use rustc_span::Span;\n \n use array_into_iter::ArrayIntoIter;\n use builtin::*;\n+use cast_ref_to_mut::*;\n use deref_into_dyn_supertrait::*;\n use drop_forget_useless::*;\n use enum_intrinsics_non_enums::EnumIntrinsicsNonEnums;\n@@ -214,6 +216,7 @@ late_lint_methods!(\n             BoxPointers: BoxPointers,\n             PathStatements: PathStatements,\n             LetUnderscore: LetUnderscore,\n+            CastRefToMut: CastRefToMut,\n             // Depends on referenced function signatures in expressions\n             UnusedResults: UnusedResults,\n             NonUpperCaseGlobals: NonUpperCaseGlobals,"}, {"sha": "fd15f7952023a2fb2b201f65eedb11364e156cf7", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -718,6 +718,11 @@ pub enum InvalidFromUtf8Diag {\n     },\n }\n \n+// cast_ref_to_mut.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_cast_ref_to_mut)]\n+pub struct CastRefToMutDiag;\n+\n // hidden_unicode_codepoints.rs\n #[derive(LintDiagnostic)]\n #[diag(lint_hidden_unicode_codepoints)]"}, {"sha": "eb246c3f93eb04b114261f40d660aefc2c229ccb", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3357,6 +3357,7 @@ declare_lint_pass! {\n         LARGE_ASSIGNMENTS,\n         LATE_BOUND_LIFETIME_ARGUMENTS,\n         LEGACY_DERIVE_HELPERS,\n+        LONG_RUNNING_CONST_EVAL,\n         LOSSY_PROVENANCE_CASTS,\n         MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n         MACRO_USE_EXTERN_CRATE,\n@@ -3426,6 +3427,43 @@ declare_lint_pass! {\n     ]\n }\n \n+declare_lint! {\n+    /// The `long_running_const_eval` lint is emitted when const\n+    /// eval is running for a long time to ensure rustc terminates\n+    /// even if you accidentally wrote an infinite loop.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// const FOO: () = loop {};\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Loops allow const evaluation to compute arbitrary code, but may also\n+    /// cause infinite loops or just very long running computations.\n+    /// Users can enable long running computations by allowing the lint\n+    /// on individual constants or for entire crates.\n+    ///\n+    /// ### Unconditional warnings\n+    ///\n+    /// Note that regardless of whether the lint is allowed or set to warn,\n+    /// the compiler will issue warnings if constant evaluation runs significantly\n+    /// longer than this lint's limit. These warnings are also shown to downstream\n+    /// users from crates.io or similar registries. If you are above the lint's limit,\n+    /// both you and downstream users might be exposed to these warnings.\n+    /// They might also appear on compiler updates, as the compiler makes minor changes\n+    /// about how complexity is measured: staying below the limit ensures that there\n+    /// is enough room, and given that the lint is disabled for people who use your\n+    /// dependency it means you will be the only one to get the warning and can put\n+    /// out an update in your own time.\n+    pub LONG_RUNNING_CONST_EVAL,\n+    Deny,\n+    \"detects long const eval operations\"\n+}\n+\n declare_lint! {\n     /// The `unused_doc_comments` lint detects doc comments that aren't used\n     /// by `rustdoc`."}, {"sha": "2e6e84ad80eb458a7e7ded5a9f199be396e3fcdd", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -14,6 +14,8 @@ use syn::Token;\n use syn::{parse_quote, spanned::Spanned, Attribute, Meta, Path, Type};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n+use super::utils::SubdiagnosticVariant;\n+\n /// What kind of diagnostic is being derived - a fatal/error/warning or a lint?\n #[derive(Clone, PartialEq, Eq)]\n pub(crate) enum DiagnosticDeriveKind {\n@@ -150,19 +152,19 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n     fn parse_subdiag_attribute(\n         &self,\n         attr: &Attribute,\n-    ) -> Result<Option<(SubdiagnosticKind, Path)>, DiagnosticDeriveError> {\n-        let Some((subdiag, slug)) = SubdiagnosticKind::from_attr(attr, self)? else {\n+    ) -> Result<Option<(SubdiagnosticKind, Path, bool)>, DiagnosticDeriveError> {\n+        let Some(subdiag) = SubdiagnosticVariant::from_attr(attr, self)? else {\n             // Some attributes aren't errors - like documentation comments - but also aren't\n             // subdiagnostics.\n             return Ok(None);\n         };\n \n-        if let SubdiagnosticKind::MultipartSuggestion { .. } = subdiag {\n+        if let SubdiagnosticKind::MultipartSuggestion { .. } = subdiag.kind {\n             throw_invalid_attr!(attr, |diag| diag\n                 .help(\"consider creating a `Subdiagnostic` instead\"));\n         }\n \n-        let slug = slug.unwrap_or_else(|| match subdiag {\n+        let slug = subdiag.slug.unwrap_or_else(|| match subdiag.kind {\n             SubdiagnosticKind::Label => parse_quote! { _subdiag::label },\n             SubdiagnosticKind::Note => parse_quote! { _subdiag::note },\n             SubdiagnosticKind::Help => parse_quote! { _subdiag::help },\n@@ -171,7 +173,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n         });\n \n-        Ok(Some((subdiag, slug)))\n+        Ok(Some((subdiag.kind, slug, subdiag.no_span)))\n     }\n \n     /// Establishes state in the `DiagnosticDeriveBuilder` resulting from the struct\n@@ -229,7 +231,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             return Ok(tokens);\n         }\n \n-        let Some((subdiag, slug)) = self.parse_subdiag_attribute(attr)? else {\n+        let Some((subdiag, slug, _no_span)) = self.parse_subdiag_attribute(attr)? else {\n             // Some attributes aren't errors - like documentation comments - but also aren't\n             // subdiagnostics.\n             return Ok(quote! {});\n@@ -380,7 +382,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             _ => (),\n         }\n \n-        let Some((subdiag, slug)) = self.parse_subdiag_attribute(attr)? else {\n+        let Some((subdiag, slug, _no_span)) = self.parse_subdiag_attribute(attr)? else {\n             // Some attributes aren't errors - like documentation comments - but also aren't\n             // subdiagnostics.\n             return Ok(quote! {});"}, {"sha": "e3d9eb96574d10a3f2367612648e52e7e3a99143", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -14,6 +14,8 @@ use quote::{format_ident, quote};\n use syn::{spanned::Spanned, Attribute, Meta, MetaList, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n+use super::utils::SubdiagnosticVariant;\n+\n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n pub(crate) struct SubdiagnosticDeriveBuilder {\n     diag: syn::Ident,\n@@ -180,11 +182,13 @@ impl<'a> FromIterator<&'a SubdiagnosticKind> for KindsStatistics {\n }\n \n impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n-    fn identify_kind(&mut self) -> Result<Vec<(SubdiagnosticKind, Path)>, DiagnosticDeriveError> {\n+    fn identify_kind(\n+        &mut self,\n+    ) -> Result<Vec<(SubdiagnosticKind, Path, bool)>, DiagnosticDeriveError> {\n         let mut kind_slugs = vec![];\n \n         for attr in self.variant.ast().attrs {\n-            let Some((kind, slug)) = SubdiagnosticKind::from_attr(attr, self)? else {\n+            let Some(SubdiagnosticVariant { kind, slug, no_span }) = SubdiagnosticVariant::from_attr(attr, self)? else {\n                 // Some attributes aren't errors - like documentation comments - but also aren't\n                 // subdiagnostics.\n                 continue;\n@@ -202,7 +206,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 );\n             };\n \n-            kind_slugs.push((kind, slug));\n+            kind_slugs.push((kind, slug, no_span));\n         }\n \n         Ok(kind_slugs)\n@@ -487,7 +491,8 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             }\n         };\n \n-        let kind_stats: KindsStatistics = kind_slugs.iter().map(|(kind, _slug)| kind).collect();\n+        let kind_stats: KindsStatistics =\n+            kind_slugs.iter().map(|(kind, _slug, _no_span)| kind).collect();\n \n         let init = if kind_stats.has_multipart_suggestion {\n             quote! { let mut suggestions = Vec::new(); }\n@@ -508,13 +513,17 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         let diag = &self.parent.diag;\n         let f = &self.parent.f;\n         let mut calls = TokenStream::new();\n-        for (kind, slug) in kind_slugs {\n+        for (kind, slug, no_span) in kind_slugs {\n             let message = format_ident!(\"__message\");\n             calls.extend(\n                 quote! { let #message = #f(#diag, crate::fluent_generated::#slug.into()); },\n             );\n \n-            let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n+            let name = format_ident!(\n+                \"{}{}\",\n+                if span_field.is_some() && !no_span { \"span_\" } else { \"\" },\n+                kind\n+            );\n             let call = match kind {\n                 SubdiagnosticKind::Suggestion {\n                     suggestion_kind,\n@@ -566,7 +575,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     }\n                 }\n                 _ => {\n-                    if let Some(span) = span_field {\n+                    if let Some(span) = span_field && !no_span {\n                         quote! { #diag.#name(#span, #message); }\n                     } else {\n                         quote! { #diag.#name(#message); }"}, {"sha": "85dd9f6a3ce3670974da25e49f658c63ff68f85b", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -597,14 +597,20 @@ pub(super) enum SubdiagnosticKind {\n     },\n }\n \n-impl SubdiagnosticKind {\n-    /// Constructs a `SubdiagnosticKind` from a field or type attribute such as `#[note]`,\n-    /// `#[error(parser::add_paren)]` or `#[suggestion(code = \"...\")]`. Returns the\n+pub(super) struct SubdiagnosticVariant {\n+    pub(super) kind: SubdiagnosticKind,\n+    pub(super) slug: Option<Path>,\n+    pub(super) no_span: bool,\n+}\n+\n+impl SubdiagnosticVariant {\n+    /// Constructs a `SubdiagnosticVariant` from a field or type attribute such as `#[note]`,\n+    /// `#[error(parser::add_paren, no_span)]` or `#[suggestion(code = \"...\")]`. Returns the\n     /// `SubdiagnosticKind` and the diagnostic slug, if specified.\n     pub(super) fn from_attr(\n         attr: &Attribute,\n         fields: &impl HasFieldMap,\n-    ) -> Result<Option<(SubdiagnosticKind, Option<Path>)>, DiagnosticDeriveError> {\n+    ) -> Result<Option<SubdiagnosticVariant>, DiagnosticDeriveError> {\n         // Always allow documentation comments.\n         if is_doc_comment(attr) {\n             return Ok(None);\n@@ -679,7 +685,7 @@ impl SubdiagnosticKind {\n                     | SubdiagnosticKind::Help\n                     | SubdiagnosticKind::Warn\n                     | SubdiagnosticKind::MultipartSuggestion { .. } => {\n-                        return Ok(Some((kind, None)));\n+                        return Ok(Some(SubdiagnosticVariant { kind, slug: None, no_span: false }));\n                     }\n                     SubdiagnosticKind::Suggestion { .. } => {\n                         throw_span_err!(span, \"suggestion without `code = \\\"...\\\"`\")\n@@ -696,11 +702,14 @@ impl SubdiagnosticKind {\n \n         let mut first = true;\n         let mut slug = None;\n+        let mut no_span = false;\n \n         list.parse_nested_meta(|nested| {\n             if nested.input.is_empty() || nested.input.peek(Token![,]) {\n                 if first {\n                     slug = Some(nested.path);\n+                } else if nested.path.is_ident(\"no_span\") {\n+                    no_span = true;\n                 } else {\n                     span_err(nested.input.span().unwrap(), \"a diagnostic slug must be the first argument to the attribute\").emit();\n                 }\n@@ -775,19 +784,19 @@ impl SubdiagnosticKind {\n                 (_, SubdiagnosticKind::Suggestion { .. }) => {\n                     span_err(path_span, \"invalid nested attribute\")\n                         .help(\n-                            \"only `style`, `code` and `applicability` are valid nested attributes\",\n+                            \"only `no_span`, `style`, `code` and `applicability` are valid nested attributes\",\n                         )\n                         .emit();\n                     has_errors = true;\n                 }\n                 (_, SubdiagnosticKind::MultipartSuggestion { .. }) => {\n                     span_err(path_span, \"invalid nested attribute\")\n-                        .help(\"only `style` and `applicability` are valid nested attributes\")\n+                        .help(\"only `no_span`, `style` and `applicability` are valid nested attributes\")\n                         .emit();\n                     has_errors = true;\n                 }\n                 _ => {\n-                    span_err(path_span, \"invalid nested attribute\").emit();\n+                    span_err(path_span, \"only `no_span` is a valid nested attribute\").emit();\n                     has_errors = true;\n                 }\n             }\n@@ -831,7 +840,7 @@ impl SubdiagnosticKind {\n             | SubdiagnosticKind::Warn => {}\n         }\n \n-        Ok(Some((kind, slug)))\n+        Ok(Some(SubdiagnosticVariant { kind, slug, no_span }))\n     }\n }\n "}, {"sha": "b3976d756eb0ffdfc3b4d83c09c7d90297b36768", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -365,15 +365,21 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         lib: Library,\n         dep_kind: CrateDepKind,\n         name: Symbol,\n+        private_dep: Option<bool>,\n     ) -> Result<CrateNum, CrateError> {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n \n         let Library { source, metadata } = lib;\n         let crate_root = metadata.get_root();\n         let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash());\n \n-        let private_dep =\n-            self.sess.opts.externs.get(name.as_str()).is_some_and(|e| e.is_private_dep);\n+        let private_dep = self\n+            .sess\n+            .opts\n+            .externs\n+            .get(name.as_str())\n+            .map_or(private_dep.unwrap_or(false), |e| e.is_private_dep)\n+            && private_dep.unwrap_or(true);\n \n         // Claim this crate number and cache it\n         let cnum = self.cstore.intern_stable_crate_id(&crate_root)?;\n@@ -518,15 +524,16 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         if !name.as_str().is_ascii() {\n             return Err(CrateError::NonAsciiName(name));\n         }\n-        let (root, hash, host_hash, extra_filename, path_kind) = match dep {\n+        let (root, hash, host_hash, extra_filename, path_kind, private_dep) = match dep {\n             Some((root, dep)) => (\n                 Some(root),\n                 Some(dep.hash),\n                 dep.host_hash,\n                 Some(&dep.extra_filename[..]),\n                 PathKind::Dependency,\n+                Some(dep.is_private),\n             ),\n-            None => (None, None, None, None, PathKind::Crate),\n+            None => (None, None, None, None, PathKind::Crate, None),\n         };\n         let result = if let Some(cnum) = self.existing_match(name, hash, path_kind) {\n             (LoadResult::Previous(cnum), None)\n@@ -562,10 +569,13 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n                     dep_kind = CrateDepKind::MacrosOnly;\n                 }\n                 data.update_dep_kind(|data_dep_kind| cmp::max(data_dep_kind, dep_kind));\n+                if let Some(private_dep) = private_dep {\n+                    data.update_and_private_dep(private_dep);\n+                }\n                 Ok(cnum)\n             }\n             (LoadResult::Loaded(library), host_library) => {\n-                self.register_crate(host_library, root, library, dep_kind, name)\n+                self.register_crate(host_library, root, library, dep_kind, name, private_dep)\n             }\n             _ => panic!(),\n         }"}, {"sha": "8f883bdcf12b83c7ee67864ec1d6aa4a39fae533", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::owned_slice::OwnedSlice;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{AppendOnlyVec, Lock, Lrc, OnceCell};\n+use rustc_data_structures::sync::{AppendOnlyVec, AtomicBool, Lock, Lrc, OnceCell};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, DeriveProcMacro};\n@@ -40,6 +40,7 @@ use proc_macro::bridge::client::ProcMacro;\n use std::iter::TrustedLen;\n use std::num::NonZeroUsize;\n use std::path::Path;\n+use std::sync::atomic::Ordering;\n use std::{io, iter, mem};\n \n pub(super) use cstore_impl::provide;\n@@ -112,9 +113,10 @@ pub(crate) struct CrateMetadata {\n     dep_kind: Lock<CrateDepKind>,\n     /// Filesystem location of this crate.\n     source: Lrc<CrateSource>,\n-    /// Whether or not this crate should be consider a private dependency\n-    /// for purposes of the 'exported_private_dependencies' lint\n-    private_dep: bool,\n+    /// Whether or not this crate should be consider a private dependency.\n+    /// Used by the 'exported_private_dependencies' lint, and for determining\n+    /// whether to emit suggestions that reference this crate.\n+    private_dep: AtomicBool,\n     /// The hash for the host proc macro. Used to support `-Z dual-proc-macro`.\n     host_hash: Option<Svh>,\n \n@@ -701,12 +703,13 @@ impl MetadataBlob {\n         writeln!(out, \"=External Dependencies=\")?;\n \n         for (i, dep) in root.crate_deps.decode(self).enumerate() {\n-            let CrateDep { name, extra_filename, hash, host_hash, kind } = dep;\n+            let CrateDep { name, extra_filename, hash, host_hash, kind, is_private } = dep;\n             let number = i + 1;\n \n             writeln!(\n                 out,\n-                \"{number} {name}{extra_filename} hash {hash} host_hash {host_hash:?} kind {kind:?}\"\n+                \"{number} {name}{extra_filename} hash {hash} host_hash {host_hash:?} kind {kind:?} {privacy}\",\n+                privacy = if is_private { \"private\" } else { \"public\" }\n             )?;\n         }\n         write!(out, \"\\n\")?;\n@@ -1624,7 +1627,7 @@ impl CrateMetadata {\n             dependencies,\n             dep_kind: Lock::new(dep_kind),\n             source: Lrc::new(source),\n-            private_dep,\n+            private_dep: AtomicBool::new(private_dep),\n             host_hash,\n             extern_crate: Lock::new(None),\n             hygiene_context: Default::default(),\n@@ -1672,6 +1675,10 @@ impl CrateMetadata {\n         self.dep_kind.with_lock(|dep_kind| *dep_kind = f(*dep_kind))\n     }\n \n+    pub(crate) fn update_and_private_dep(&self, private_dep: bool) {\n+        self.private_dep.fetch_and(private_dep, Ordering::SeqCst);\n+    }\n+\n     pub(crate) fn required_panic_strategy(&self) -> Option<PanicStrategy> {\n         self.root.required_panic_strategy\n     }"}, {"sha": "a15307e4345c179c5dc7d7bc0907aa59090ea3c4", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -285,7 +285,13 @@ provide! { tcx, def_id, other, cdata,\n     is_ctfe_mir_available => { cdata.is_ctfe_mir_available(def_id.index) }\n \n     dylib_dependency_formats => { cdata.get_dylib_dependency_formats(tcx) }\n-    is_private_dep => { cdata.private_dep }\n+    is_private_dep => {\n+        // Parallel compiler needs to synchronize type checking and linting (which use this flag)\n+        // so that they happen strictly crate loading. Otherwise, the full list of available\n+        // impls aren't loaded yet.\n+        use std::sync::atomic::Ordering;\n+        cdata.private_dep.load(Ordering::Acquire)\n+    }\n     is_panic_runtime => { cdata.root.panic_runtime }\n     is_compiler_builtins => { cdata.root.compiler_builtins }\n     has_global_allocator => { cdata.root.has_global_allocator }"}, {"sha": "6ceb61e793e534cc2ab71774650d2aa0d49e7bb6", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1883,6 +1883,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     host_hash: self.tcx.crate_host_hash(cnum),\n                     kind: self.tcx.dep_kind(cnum),\n                     extra_filename: self.tcx.extra_filename(cnum).clone(),\n+                    is_private: self.tcx.is_private_dep(cnum),\n                 };\n                 (cnum, dep)\n             })"}, {"sha": "2da888f4468c06e7507f44c9f1c1300f63f6b69c", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -322,6 +322,7 @@ pub(crate) struct CrateDep {\n     pub host_hash: Option<Svh>,\n     pub kind: CrateDepKind,\n     pub extra_filename: String,\n+    pub is_private: bool,\n }\n \n #[derive(MetadataEncodable, MetadataDecodable)]"}, {"sha": "f002d7f97b933b4ffedc7d05b9b0a9690843aa02", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -439,7 +439,7 @@ where\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n     pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(&self, metadata: M, i: I) -> T::Value<'tcx> {\n-        debug!(\"LazyTable::lookup: index={:?} len={:?}\", i, self.encoded_size);\n+        trace!(\"LazyTable::lookup: index={:?} len={:?}\", i, self.encoded_size);\n \n         let start = self.position.get();\n         let bytes = &metadata.blob()[start..start + self.encoded_size];"}, {"sha": "bb7147ac80fbe2e5a8f9df80e2ef183dd761e83c", "filename": "compiler/rustc_middle/messages.ftl", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fmessages.ftl?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,3 +1,38 @@\n+middle_adjust_for_foreign_abi_error =\n+    target architecture {$arch} does not support `extern {$abi}` ABI\n+\n+middle_assert_async_resume_after_panic = `async fn` resumed after panicking\n+\n+middle_assert_async_resume_after_return = `async fn` resumed after completion\n+\n+middle_assert_divide_by_zero =\n+    attempt to divide `{$val}` by zero\n+\n+middle_assert_generator_resume_after_panic = generator resumed after panicking\n+\n+middle_assert_generator_resume_after_return = generator resumed after completion\n+\n+middle_assert_misaligned_ptr_deref =\n+    misaligned pointer dereference: address must be a multiple of {$required} but is {$found}\n+\n+middle_assert_op_overflow =\n+    attempt to compute `{$left} {$op} {$right}`, which would overflow\n+\n+middle_assert_overflow_neg =\n+    attempt to negate `{$val}`, which would overflow\n+\n+middle_assert_remainder_by_zero =\n+    attempt to calculate the remainder of `{$val}` with a divisor of zero\n+\n+middle_assert_shl_overflow =\n+    attempt to shift left by `{$val}`, which would overflow\n+\n+middle_assert_shr_overflow =\n+    attempt to shift right by `{$val}`, which would overflow\n+\n+middle_bounds_check =\n+    index out of bounds: the length is {$len} but the index is {$index}\n+\n middle_cannot_be_normalized =\n     unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized\n "}, {"sha": "57b2de84b47f7cbf51ebdf0f5f814739166d9e2c", "filename": "compiler/rustc_middle/src/error.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ferror.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,3 +1,7 @@\n+use std::borrow::Cow;\n+use std::fmt;\n+\n+use rustc_errors::{DiagnosticArgValue, DiagnosticMessage};\n use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n \n@@ -88,3 +92,54 @@ pub(super) struct ConstNotUsedTraitAlias {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+pub struct CustomSubdiagnostic<'a> {\n+    pub msg: fn() -> DiagnosticMessage,\n+    pub add_args:\n+        Box<dyn FnOnce(&mut dyn FnMut(Cow<'static, str>, DiagnosticArgValue<'static>)) + 'a>,\n+}\n+\n+impl<'a> CustomSubdiagnostic<'a> {\n+    pub fn label(x: fn() -> DiagnosticMessage) -> Self {\n+        Self::label_and_then(x, |_| {})\n+    }\n+    pub fn label_and_then<\n+        F: FnOnce(&mut dyn FnMut(Cow<'static, str>, DiagnosticArgValue<'static>)) + 'a,\n+    >(\n+        msg: fn() -> DiagnosticMessage,\n+        f: F,\n+    ) -> Self {\n+        Self { msg, add_args: Box::new(move |x| f(x)) }\n+    }\n+}\n+\n+impl fmt::Debug for CustomSubdiagnostic<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"CustomSubdiagnostic\").finish_non_exhaustive()\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum LayoutError<'tcx> {\n+    #[diag(middle_unknown_layout)]\n+    Unknown { ty: Ty<'tcx> },\n+\n+    #[diag(middle_values_too_big)]\n+    Overflow { ty: Ty<'tcx> },\n+\n+    #[diag(middle_cannot_be_normalized)]\n+    NormalizationFailure { ty: Ty<'tcx>, failure_ty: String },\n+\n+    #[diag(middle_cycle)]\n+    Cycle,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(middle_adjust_for_foreign_abi_error)]\n+pub struct UnsupportedFnAbi {\n+    pub arch: Symbol,\n+    pub abi: &'static str,\n+}\n+\n+/// Used by `rustc_const_eval`\n+pub use crate::fluent_generated::middle_adjust_for_foreign_abi_error;"}, {"sha": "0d6c2eba06c89dff45beec224592fa4984d77f4c", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -48,6 +48,7 @@\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n #![feature(control_flow_enum)]\n+#![feature(trait_upcasting)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n #![feature(try_reserve_kind)]\n@@ -86,7 +87,7 @@ mod macros;\n \n #[macro_use]\n pub mod arena;\n-pub(crate) mod error;\n+pub mod error;\n pub mod hir;\n pub mod infer;\n pub mod lint;"}, {"sha": "d4f023958d6fda3cc505aa049e48d78dbffd19e1", "filename": "compiler/rustc_middle/src/middle/limits.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,8 +1,7 @@\n //! Registering limits:\n //! * recursion_limit,\n-//! * move_size_limit,\n-//! * type_length_limit, and\n-//! * const_eval_limit\n+//! * move_size_limit, and\n+//! * type_length_limit\n //!\n //! There are various parts of the compiler that must impose arbitrary limits\n //! on how deeply they recurse to prevent stack overflow. Users can override\n@@ -34,12 +33,6 @@ pub fn provide(providers: &mut Providers) {\n             sym::type_length_limit,\n             1048576,\n         ),\n-        const_eval_limit: get_limit(\n-            tcx.hir().krate_attrs(),\n-            tcx.sess,\n-            sym::const_eval_limit,\n-            2_000_000,\n-        ),\n     }\n }\n "}, {"sha": "b8030d9db13c5588ac820b5f6fca124fe5b2fd03", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -296,25 +296,13 @@ impl<Prov: Provenance, Bytes: AllocBytes> Allocation<Prov, (), Bytes> {\n         Allocation::from_bytes(slice, Align::ONE, Mutability::Not)\n     }\n \n-    /// Try to create an Allocation of `size` bytes, failing if there is not enough memory\n-    /// available to the compiler to do so.\n-    ///\n-    /// If `panic_on_fail` is true, this will never return `Err`.\n-    pub fn uninit<'tcx>(size: Size, align: Align, panic_on_fail: bool) -> InterpResult<'tcx, Self> {\n-        let bytes = Bytes::zeroed(size, align).ok_or_else(|| {\n-            // This results in an error that can happen non-deterministically, since the memory\n-            // available to the compiler can change between runs. Normally queries are always\n-            // deterministic. However, we can be non-deterministic here because all uses of const\n-            // evaluation (including ConstProp!) will make compilation fail (via hard error\n-            // or ICE) upon encountering a `MemoryExhausted` error.\n-            if panic_on_fail {\n-                panic!(\"Allocation::uninit called with panic_on_fail had allocation failure\")\n-            }\n-            ty::tls::with(|tcx| {\n-                tcx.sess.delay_span_bug(DUMMY_SP, \"exhausted memory during interpretation\")\n-            });\n-            InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted)\n-        })?;\n+    fn uninit_inner<R>(size: Size, align: Align, fail: impl FnOnce() -> R) -> Result<Self, R> {\n+        // This results in an error that can happen non-deterministically, since the memory\n+        // available to the compiler can change between runs. Normally queries are always\n+        // deterministic. However, we can be non-deterministic here because all uses of const\n+        // evaluation (including ConstProp!) will make compilation fail (via hard error\n+        // or ICE) upon encountering a `MemoryExhausted` error.\n+        let bytes = Bytes::zeroed(size, align).ok_or_else(fail)?;\n \n         Ok(Allocation {\n             bytes,\n@@ -325,6 +313,28 @@ impl<Prov: Provenance, Bytes: AllocBytes> Allocation<Prov, (), Bytes> {\n             extra: (),\n         })\n     }\n+\n+    /// Try to create an Allocation of `size` bytes, failing if there is not enough memory\n+    /// available to the compiler to do so.\n+    pub fn try_uninit<'tcx>(size: Size, align: Align) -> InterpResult<'tcx, Self> {\n+        Self::uninit_inner(size, align, || {\n+            ty::tls::with(|tcx| {\n+                tcx.sess.delay_span_bug(DUMMY_SP, \"exhausted memory during interpretation\")\n+            });\n+            InterpError::ResourceExhaustion(ResourceExhaustionInfo::MemoryExhausted).into()\n+        })\n+    }\n+\n+    /// Try to create an Allocation of `size` bytes, panics if there is not enough memory\n+    /// available to the compiler to do so.\n+    pub fn uninit(size: Size, align: Align) -> Self {\n+        match Self::uninit_inner(size, align, || {\n+            panic!(\"Allocation::uninit called with panic_on_fail had allocation failure\");\n+        }) {\n+            Ok(x) => x,\n+            Err(x) => x,\n+        }\n+    }\n }\n \n impl<Bytes: AllocBytes> Allocation<AllocId, (), Bytes> {"}, {"sha": "2435bc59ec0342e1860060050ba66311c45cc643", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 189, "deletions": 255, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -5,11 +5,15 @@ use crate::query::TyCtxtAt;\n use crate::ty::{layout, tls, Ty, ValTree};\n \n use rustc_data_structures::sync::Lock;\n-use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{\n+    struct_span_err, DiagnosticArgValue, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n+    IntoDiagnosticArg,\n+};\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::{call, Align, Size};\n+use rustc_target::abi::{call, Align, Size, WrappingRange};\n+use std::borrow::Cow;\n use std::{any::Any, backtrace::Backtrace, fmt};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n@@ -91,21 +95,54 @@ pub struct InterpErrorInfo<'tcx>(Box<InterpErrorInfoInner<'tcx>>);\n #[derive(Debug)]\n struct InterpErrorInfoInner<'tcx> {\n     kind: InterpError<'tcx>,\n+    backtrace: InterpErrorBacktrace,\n+}\n+\n+#[derive(Debug)]\n+pub struct InterpErrorBacktrace {\n     backtrace: Option<Box<Backtrace>>,\n }\n \n-impl fmt::Display for InterpErrorInfo<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.0.kind)\n+impl InterpErrorBacktrace {\n+    pub fn new() -> InterpErrorBacktrace {\n+        let capture_backtrace = tls::with_opt(|tcx| {\n+            if let Some(tcx) = tcx {\n+                *Lock::borrow(&tcx.sess.ctfe_backtrace)\n+            } else {\n+                CtfeBacktrace::Disabled\n+            }\n+        });\n+\n+        let backtrace = match capture_backtrace {\n+            CtfeBacktrace::Disabled => None,\n+            CtfeBacktrace::Capture => Some(Box::new(Backtrace::force_capture())),\n+            CtfeBacktrace::Immediate => {\n+                // Print it now.\n+                let backtrace = Backtrace::force_capture();\n+                print_backtrace(&backtrace);\n+                None\n+            }\n+        };\n+\n+        InterpErrorBacktrace { backtrace }\n     }\n-}\n \n-impl<'tcx> InterpErrorInfo<'tcx> {\n     pub fn print_backtrace(&self) {\n-        if let Some(backtrace) = self.0.backtrace.as_ref() {\n+        if let Some(backtrace) = self.backtrace.as_ref() {\n             print_backtrace(backtrace);\n         }\n     }\n+}\n+\n+impl<'tcx> InterpErrorInfo<'tcx> {\n+    pub fn from_parts(kind: InterpError<'tcx>, backtrace: InterpErrorBacktrace) -> Self {\n+        Self(Box::new(InterpErrorInfoInner { kind, backtrace }))\n+    }\n+\n+    pub fn into_parts(self) -> (InterpError<'tcx>, InterpErrorBacktrace) {\n+        let InterpErrorInfo(box InterpErrorInfoInner { kind, backtrace }) = self;\n+        (kind, backtrace)\n+    }\n \n     pub fn into_kind(self) -> InterpError<'tcx> {\n         let InterpErrorInfo(box InterpErrorInfoInner { kind, .. }) = self;\n@@ -130,32 +167,17 @@ impl From<ErrorGuaranteed> for InterpErrorInfo<'_> {\n \n impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     fn from(kind: InterpError<'tcx>) -> Self {\n-        let capture_backtrace = tls::with_opt(|tcx| {\n-            if let Some(tcx) = tcx {\n-                *Lock::borrow(&tcx.sess.ctfe_backtrace)\n-            } else {\n-                CtfeBacktrace::Disabled\n-            }\n-        });\n-\n-        let backtrace = match capture_backtrace {\n-            CtfeBacktrace::Disabled => None,\n-            CtfeBacktrace::Capture => Some(Box::new(Backtrace::force_capture())),\n-            CtfeBacktrace::Immediate => {\n-                // Print it now.\n-                let backtrace = Backtrace::force_capture();\n-                print_backtrace(&backtrace);\n-                None\n-            }\n-        };\n-\n-        InterpErrorInfo(Box::new(InterpErrorInfoInner { kind, backtrace }))\n+        InterpErrorInfo(Box::new(InterpErrorInfoInner {\n+            kind,\n+            backtrace: InterpErrorBacktrace::new(),\n+        }))\n     }\n }\n \n /// Error information for when the program we executed turned out not to actually be a valid\n /// program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp\n /// where we work on generic code or execution does not have all information available.\n+#[derive(Debug)]\n pub enum InvalidProgramInfo<'tcx> {\n     /// Resolution can fail if we are in a too generic context.\n     TooGeneric,\n@@ -174,25 +196,6 @@ pub enum InvalidProgramInfo<'tcx> {\n     UninitUnsizedLocal,\n }\n \n-impl fmt::Display for InvalidProgramInfo<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use InvalidProgramInfo::*;\n-        match self {\n-            TooGeneric => write!(f, \"encountered overly generic constant\"),\n-            AlreadyReported(_) => {\n-                write!(\n-                    f,\n-                    \"an error has already been reported elsewhere (this should not usually be printed)\"\n-                )\n-            }\n-            Layout(ref err) => write!(f, \"{err}\"),\n-            FnAbiAdjustForForeignAbi(ref err) => write!(f, \"{err}\"),\n-            SizeOfUnsizedType(ty) => write!(f, \"size_of called on unsized type `{ty}`\"),\n-            UninitUnsizedLocal => write!(f, \"unsized local is used while uninitialized\"),\n-        }\n-    }\n-}\n-\n /// Details of why a pointer had to be in-bounds.\n #[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub enum CheckInAllocMsg {\n@@ -208,26 +211,25 @@ pub enum CheckInAllocMsg {\n     InboundsTest,\n }\n \n-impl fmt::Display for CheckInAllocMsg {\n-    /// When this is printed as an error the context looks like this:\n-    /// \"{msg}{pointer} is a dangling pointer\".\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"{}\",\n-            match *self {\n-                CheckInAllocMsg::DerefTest => \"dereferencing pointer failed: \",\n-                CheckInAllocMsg::MemoryAccessTest => \"memory access failed: \",\n-                CheckInAllocMsg::PointerArithmeticTest => \"out-of-bounds pointer arithmetic: \",\n-                CheckInAllocMsg::OffsetFromTest => \"out-of-bounds offset_from: \",\n-                CheckInAllocMsg::InboundsTest => \"out-of-bounds pointer use: \",\n-            }\n-        )\n+#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n+pub enum InvalidMetaKind {\n+    /// Size of a `[T]` is too big\n+    SliceTooBig,\n+    /// Size of a DST is too big\n+    TooBig,\n+}\n+\n+impl IntoDiagnosticArg for InvalidMetaKind {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(match self {\n+            InvalidMetaKind::SliceTooBig => \"slice_too_big\",\n+            InvalidMetaKind::TooBig => \"too_big\",\n+        }))\n     }\n }\n \n /// Details of an access to uninitialized bytes where it is not allowed.\n-#[derive(Debug)]\n+#[derive(Debug, Clone, Copy)]\n pub struct UninitBytesAccess {\n     /// Range of the original memory access.\n     pub access: AllocRange,\n@@ -242,17 +244,32 @@ pub struct ScalarSizeMismatch {\n     pub data_size: u64,\n }\n \n+macro_rules! impl_into_diagnostic_arg_through_debug {\n+    ($($ty:ty),*$(,)?) => {$(\n+        impl IntoDiagnosticArg for $ty {\n+            fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+                DiagnosticArgValue::Str(Cow::Owned(format!(\"{self:?}\")))\n+            }\n+        }\n+    )*}\n+}\n+\n+// These types have nice `Debug` output so we can just use them in diagnostics.\n+impl_into_diagnostic_arg_through_debug! {\n+    AllocId,\n+    Pointer,\n+    AllocRange,\n+}\n+\n /// Error information for when the program caused Undefined Behavior.\n-pub enum UndefinedBehaviorInfo {\n-    /// Free-form case. Only for errors that are never caught!\n+#[derive(Debug)]\n+pub enum UndefinedBehaviorInfo<'a> {\n+    /// Free-form case. Only for errors that are never caught! Used by miri\n     Ub(String),\n     /// Unreachable code was executed.\n     Unreachable,\n     /// A slice/array index projection went out-of-bounds.\n-    BoundsCheckFailed {\n-        len: u64,\n-        index: u64,\n-    },\n+    BoundsCheckFailed { len: u64, index: u64 },\n     /// Something was divided by 0 (x / 0).\n     DivisionByZero,\n     /// Something was \"remainded\" by 0 (x % 0).\n@@ -263,8 +280,8 @@ pub enum UndefinedBehaviorInfo {\n     RemainderOverflow,\n     /// Overflowing inbounds pointer arithmetic.\n     PointerArithOverflow,\n-    /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n-    InvalidMeta(&'static str),\n+    /// Invalid metadata in a wide pointer\n+    InvalidMeta(InvalidMetaKind),\n     /// Reading a C string that does not end within its allocation.\n     UnterminatedCString(Pointer),\n     /// Dereferencing a dangling pointer after it got freed.\n@@ -281,25 +298,13 @@ pub enum UndefinedBehaviorInfo {\n     /// Using an integer as a pointer in the wrong way.\n     DanglingIntPointer(u64, CheckInAllocMsg),\n     /// Used a pointer with bad alignment.\n-    AlignmentCheckFailed {\n-        required: Align,\n-        has: Align,\n-    },\n+    AlignmentCheckFailed { required: Align, has: Align },\n     /// Writing to read-only memory.\n     WriteToReadOnly(AllocId),\n-    // Trying to access the data behind a function pointer.\n+    /// Trying to access the data behind a function pointer.\n     DerefFunctionPointer(AllocId),\n-    // Trying to access the data behind a vtable pointer.\n+    /// Trying to access the data behind a vtable pointer.\n     DerefVTablePointer(AllocId),\n-    /// The value validity check found a problem.\n-    /// Should only be thrown by `validity.rs` and always point out which part of the value\n-    /// is the problem.\n-    ValidationFailure {\n-        /// The \"path\" to the value in question, e.g. `.0[5].field` for a struct\n-        /// field in the 6th element of an array that is the first element of a tuple.\n-        path: Option<String>,\n-        msg: String,\n-    },\n     /// Using a non-boolean `u8` as bool.\n     InvalidBool(u8),\n     /// Using a non-character `u32` as character.\n@@ -320,110 +325,100 @@ pub enum UndefinedBehaviorInfo {\n     ScalarSizeMismatch(ScalarSizeMismatch),\n     /// A discriminant of an uninhabited enum variant is written.\n     UninhabitedEnumVariantWritten,\n+    /// Validation error.\n+    Validation(ValidationErrorInfo<'a>),\n+    // FIXME(fee1-dead) these should all be actual variants of the enum instead of dynamically\n+    // dispatched\n+    /// A custom (free-form) error, created by `err_ub_custom!`.\n+    Custom(crate::error::CustomSubdiagnostic<'a>),\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+pub enum PointerKind {\n+    Ref,\n+    Box,\n+}\n+\n+impl IntoDiagnosticArg for PointerKind {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(\n+            match self {\n+                Self::Ref => \"ref\",\n+                Self::Box => \"box\",\n+            }\n+            .into(),\n+        )\n+    }\n }\n \n-impl fmt::Display for UndefinedBehaviorInfo {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use UndefinedBehaviorInfo::*;\n-        match self {\n-            Ub(msg) => write!(f, \"{msg}\"),\n-            Unreachable => write!(f, \"entering unreachable code\"),\n-            BoundsCheckFailed { ref len, ref index } => {\n-                write!(f, \"indexing out of bounds: the len is {len} but the index is {index}\")\n-            }\n-            DivisionByZero => write!(f, \"dividing by zero\"),\n-            RemainderByZero => write!(f, \"calculating the remainder with a divisor of zero\"),\n-            DivisionOverflow => write!(f, \"overflow in signed division (dividing MIN by -1)\"),\n-            RemainderOverflow => write!(f, \"overflow in signed remainder (dividing MIN by -1)\"),\n-            PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n-            InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {msg}\"),\n-            UnterminatedCString(p) => write!(\n-                f,\n-                \"reading a null-terminated string starting at {p:?} with no null found before end of allocation\",\n-            ),\n-            PointerUseAfterFree(a) => {\n-                write!(f, \"pointer to {a:?} was dereferenced after this allocation got freed\")\n-            }\n-            PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size: Size::ZERO, msg } => {\n-                write!(\n-                    f,\n-                    \"{msg}{alloc_id:?} has size {alloc_size}, so pointer at offset {ptr_offset} is out-of-bounds\",\n-                    alloc_size = alloc_size.bytes(),\n-                )\n-            }\n-            PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size, msg } => write!(\n-                f,\n-                \"{msg}{alloc_id:?} has size {alloc_size}, so pointer to {ptr_size} byte{ptr_size_p} starting at offset {ptr_offset} is out-of-bounds\",\n-                alloc_size = alloc_size.bytes(),\n-                ptr_size = ptr_size.bytes(),\n-                ptr_size_p = pluralize!(ptr_size.bytes()),\n-            ),\n-            DanglingIntPointer(i, msg) => {\n-                write!(\n-                    f,\n-                    \"{msg}{pointer} is a dangling pointer (it has no provenance)\",\n-                    pointer = Pointer::<Option<AllocId>>::from_addr_invalid(*i),\n-                )\n-            }\n-            AlignmentCheckFailed { required, has } => write!(\n-                f,\n-                \"accessing memory with alignment {has}, but alignment {required} is required\",\n-                has = has.bytes(),\n-                required = required.bytes()\n-            ),\n-            WriteToReadOnly(a) => write!(f, \"writing to {a:?} which is read-only\"),\n-            DerefFunctionPointer(a) => write!(f, \"accessing {a:?} which contains a function\"),\n-            DerefVTablePointer(a) => write!(f, \"accessing {a:?} which contains a vtable\"),\n-            ValidationFailure { path: None, msg } => {\n-                write!(f, \"constructing invalid value: {msg}\")\n-            }\n-            ValidationFailure { path: Some(path), msg } => {\n-                write!(f, \"constructing invalid value at {path}: {msg}\")\n-            }\n-            InvalidBool(b) => {\n-                write!(f, \"interpreting an invalid 8-bit value as a bool: 0x{b:02x}\")\n-            }\n-            InvalidChar(c) => {\n-                write!(f, \"interpreting an invalid 32-bit value as a char: 0x{c:08x}\")\n-            }\n-            InvalidTag(val) => write!(f, \"enum value has invalid tag: {val:x}\"),\n-            InvalidFunctionPointer(p) => {\n-                write!(f, \"using {p:?} as function pointer but it does not point to a function\")\n-            }\n-            InvalidVTablePointer(p) => {\n-                write!(f, \"using {p:?} as vtable pointer but it does not point to a vtable\")\n-            }\n-            InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {err}\"),\n-            InvalidUninitBytes(Some((alloc, info))) => write!(\n-                f,\n-                \"reading memory at {alloc:?}{access:?}, \\\n-                 but memory is uninitialized at {uninit:?}, \\\n-                 and this operation requires initialized memory\",\n-                access = info.access,\n-                uninit = info.uninit,\n-            ),\n-            InvalidUninitBytes(None) => write!(\n-                f,\n-                \"using uninitialized data, but this operation requires initialized memory\"\n-            ),\n-            DeadLocal => write!(f, \"accessing a dead local variable\"),\n-            ScalarSizeMismatch(self::ScalarSizeMismatch { target_size, data_size }) => write!(\n-                f,\n-                \"scalar size mismatch: expected {target_size} bytes but got {data_size} bytes instead\",\n-            ),\n-            UninhabitedEnumVariantWritten => {\n-                write!(f, \"writing discriminant of an uninhabited enum\")\n-            }\n+#[derive(Debug)]\n+pub struct ValidationErrorInfo<'tcx> {\n+    pub path: Option<String>,\n+    pub kind: ValidationErrorKind<'tcx>,\n+}\n+\n+#[derive(Debug)]\n+pub enum ExpectedKind {\n+    Reference,\n+    Box,\n+    RawPtr,\n+    InitScalar,\n+    Bool,\n+    Char,\n+    Float,\n+    Int,\n+    FnPtr,\n+}\n+\n+impl From<PointerKind> for ExpectedKind {\n+    fn from(x: PointerKind) -> ExpectedKind {\n+        match x {\n+            PointerKind::Box => ExpectedKind::Box,\n+            PointerKind::Ref => ExpectedKind::Reference,\n         }\n     }\n }\n \n+#[derive(Debug)]\n+pub enum ValidationErrorKind<'tcx> {\n+    PtrToUninhabited { ptr_kind: PointerKind, ty: Ty<'tcx> },\n+    PtrToStatic { ptr_kind: PointerKind },\n+    PtrToMut { ptr_kind: PointerKind },\n+    ExpectedNonPtr { value: String },\n+    MutableRefInConst,\n+    NullFnPtr,\n+    NeverVal,\n+    NullablePtrOutOfRange { range: WrappingRange, max_value: u128 },\n+    PtrOutOfRange { range: WrappingRange, max_value: u128 },\n+    OutOfRange { value: String, range: WrappingRange, max_value: u128 },\n+    UnsafeCell,\n+    UninhabitedVal { ty: Ty<'tcx> },\n+    InvalidEnumTag { value: String },\n+    UninitEnumTag,\n+    UninitStr,\n+    Uninit { expected: ExpectedKind },\n+    UninitVal,\n+    InvalidVTablePtr { value: String },\n+    InvalidMetaSliceTooLarge { ptr_kind: PointerKind },\n+    InvalidMetaTooLarge { ptr_kind: PointerKind },\n+    UnalignedPtr { ptr_kind: PointerKind, required_bytes: u64, found_bytes: u64 },\n+    NullPtr { ptr_kind: PointerKind },\n+    DanglingPtrNoProvenance { ptr_kind: PointerKind, pointer: String },\n+    DanglingPtrOutOfBounds { ptr_kind: PointerKind },\n+    DanglingPtrUseAfterFree { ptr_kind: PointerKind },\n+    InvalidBool { value: String },\n+    InvalidChar { value: String },\n+    InvalidFnPtr { value: String },\n+}\n+\n /// Error information for when the program did something that might (or might not) be correct\n /// to do according to the Rust spec, but due to limitations in the interpreter, the\n /// operation could not be carried out. These limitations can differ between CTFE and the\n /// Miri engine, e.g., CTFE does not support dereferencing pointers at integral addresses.\n+#[derive(Debug)]\n pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n+    // FIXME still use translatable diagnostics\n     Unsupported(String),\n     //\n     // The variants below are only reachable from CTFE/const prop, miri will never emit them.\n@@ -442,83 +437,42 @@ pub enum UnsupportedOpInfo {\n     ReadExternStatic(DefId),\n }\n \n-impl fmt::Display for UnsupportedOpInfo {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use UnsupportedOpInfo::*;\n-        match self {\n-            Unsupported(ref msg) => write!(f, \"{msg}\"),\n-            PartialPointerOverwrite(ptr) => {\n-                write!(f, \"unable to overwrite parts of a pointer in memory at {ptr:?}\")\n-            }\n-            PartialPointerCopy(ptr) => {\n-                write!(f, \"unable to copy parts of a pointer from memory at {ptr:?}\")\n-            }\n-            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\"),\n-            ThreadLocalStatic(did) => write!(f, \"cannot access thread local static ({did:?})\"),\n-            ReadExternStatic(did) => write!(f, \"cannot read from extern static ({did:?})\"),\n-        }\n-    }\n-}\n-\n /// Error information for when the program exhausted the resources granted to it\n /// by the interpreter.\n+#[derive(Debug)]\n pub enum ResourceExhaustionInfo {\n     /// The stack grew too big.\n     StackFrameLimitReached,\n-    /// The program ran for too long.\n-    ///\n-    /// The exact limit is set by the `const_eval_limit` attribute.\n-    StepLimitReached,\n     /// There is not enough memory (on the host) to perform an allocation.\n     MemoryExhausted,\n     /// The address space (of the target) is full.\n     AddressSpaceFull,\n }\n \n-impl fmt::Display for ResourceExhaustionInfo {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use ResourceExhaustionInfo::*;\n-        match self {\n-            StackFrameLimitReached => {\n-                write!(f, \"reached the configured maximum number of stack frames\")\n-            }\n-            StepLimitReached => {\n-                write!(f, \"exceeded interpreter step limit (see `#[const_eval_limit]`)\")\n-            }\n-            MemoryExhausted => {\n-                write!(f, \"tried to allocate more memory than available to compiler\")\n-            }\n-            AddressSpaceFull => {\n-                write!(f, \"there are no more free addresses in the address space\")\n-            }\n-        }\n-    }\n-}\n-\n-/// A trait to work around not having trait object upcasting.\n-pub trait AsAny: Any {\n-    fn as_any(&self) -> &dyn Any;\n-}\n-impl<T: Any> AsAny for T {\n-    #[inline(always)]\n-    fn as_any(&self) -> &dyn Any {\n-        self\n-    }\n-}\n-\n /// A trait for machine-specific errors (or other \"machine stop\" conditions).\n-pub trait MachineStopType: AsAny + fmt::Display + Send {}\n+pub trait MachineStopType: Any + fmt::Debug + Send {\n+    /// The diagnostic message for this error\n+    fn diagnostic_message(&self) -> DiagnosticMessage;\n+    /// Add diagnostic arguments by passing name and value pairs to `adder`, which are passed to\n+    /// fluent for formatting the translated diagnostic message.\n+    fn add_args(\n+        self: Box<Self>,\n+        adder: &mut dyn FnMut(Cow<'static, str>, DiagnosticArgValue<'static>),\n+    );\n+}\n \n impl dyn MachineStopType {\n     #[inline(always)]\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n-        self.as_any().downcast_ref()\n+        let x: &dyn Any = self;\n+        x.downcast_ref()\n     }\n }\n \n+#[derive(Debug)]\n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n-    UndefinedBehavior(UndefinedBehaviorInfo),\n+    UndefinedBehavior(UndefinedBehaviorInfo<'tcx>),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n     Unsupported(UnsupportedOpInfo),\n@@ -534,26 +488,6 @@ pub enum InterpError<'tcx> {\n \n pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n \n-impl fmt::Display for InterpError<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use InterpError::*;\n-        match *self {\n-            Unsupported(ref msg) => write!(f, \"{msg}\"),\n-            InvalidProgram(ref msg) => write!(f, \"{msg}\"),\n-            UndefinedBehavior(ref msg) => write!(f, \"{msg}\"),\n-            ResourceExhaustion(ref msg) => write!(f, \"{msg}\"),\n-            MachineStop(ref msg) => write!(f, \"{msg}\"),\n-        }\n-    }\n-}\n-\n-// Forward `Debug` to `Display`, so it does not look awful.\n-impl fmt::Debug for InterpError<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n impl InterpError<'_> {\n     /// Some errors do string formatting even if the error is never printed.\n     /// To avoid performance issues, there are places where we want to be sure to never raise these formatting errors,\n@@ -562,7 +496,7 @@ impl InterpError<'_> {\n         matches!(\n             self,\n             InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n-                | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ValidationFailure { .. })\n+                | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Validation { .. })\n                 | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n         )\n     }"}, {"sha": "2d2cfee1b213bb56659f31a4511167dacd4b63a5", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -89,6 +89,30 @@ macro_rules! throw_machine_stop {\n     ($($tt:tt)*) => { do yeet err_machine_stop!($($tt)*) };\n }\n \n+#[macro_export]\n+macro_rules! err_ub_custom {\n+    ($msg:expr $(, $($name:ident = $value:expr),* $(,)?)?) => {{\n+        $(\n+            let ($($name,)*) = ($($value,)*);\n+        )?\n+        err_ub!(Custom(\n+            rustc_middle::error::CustomSubdiagnostic {\n+                msg: || $msg,\n+                add_args: Box::new(move |mut set_arg| {\n+                    $($(\n+                        set_arg(stringify!($name).into(), rustc_errors::IntoDiagnosticArg::into_diagnostic_arg($name));\n+                    )*)?\n+                })\n+            }\n+        ))\n+    }};\n+}\n+\n+#[macro_export]\n+macro_rules! throw_ub_custom {\n+    ($($tt:tt)*) => { do yeet err_ub_custom!($($tt)*) };\n+}\n+\n mod allocation;\n mod error;\n mod pointer;\n@@ -119,9 +143,10 @@ use crate::ty::{self, Instance, Ty, TyCtxt};\n \n pub use self::error::{\n     struct_error, CheckInAllocMsg, ErrorHandled, EvalToAllocationRawResult, EvalToConstValueResult,\n-    EvalToValTreeResult, InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo,\n-    MachineStopType, ReportedErrorInfo, ResourceExhaustionInfo, ScalarSizeMismatch,\n-    UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n+    EvalToValTreeResult, ExpectedKind, InterpError, InterpErrorInfo, InterpResult, InvalidMetaKind,\n+    InvalidProgramInfo, MachineStopType, PointerKind, ReportedErrorInfo, ResourceExhaustionInfo,\n+    ScalarSizeMismatch, UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n+    ValidationErrorInfo, ValidationErrorKind,\n };\n \n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar};"}, {"sha": "91caf9db336cf04978c9b220c67bab13cda09b3f", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -375,7 +375,8 @@ impl<'tcx, Prov: Provenance> Scalar<Prov> {\n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn assert_bits(self, target_size: Size) -> u128 {\n-        self.to_bits(target_size).unwrap()\n+        self.to_bits(target_size)\n+            .unwrap_or_else(|_| panic!(\"assertion failed: {self:?} fits {target_size:?}\"))\n     }\n \n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {"}, {"sha": "e929240bf3001f5494ed989a93ce1b372c0821a7", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 49, "deletions": 88, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,7 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::interpret::{\n-    AllocRange, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, LitToConstInput, Scalar,\n+    AllocRange, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n use crate::mir::visit::MirVisitable;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -15,7 +15,7 @@ use crate::ty::{AdtDef, InstanceDef, ScalarInt, UserTypeAnnotationIndex};\n use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n \n use rustc_data_structures::captures::Captures;\n-use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::{DiagnosticArgValue, DiagnosticMessage, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_hir::def::{CtorKind, Namespace};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::{self, GeneratorKind, ImplicitSelfKind};\n@@ -1371,55 +1371,61 @@ impl<O> AssertKind<O> {\n             _ => write!(f, \"\\\"{}\\\"\", self.description()),\n         }\n     }\n-}\n \n-impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    pub fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n         use AssertKind::*;\n+\n         match self {\n-            BoundsCheck { ref len, ref index } => write!(\n-                f,\n-                \"index out of bounds: the length is {:?} but the index is {:?}\",\n-                len, index\n-            ),\n-            OverflowNeg(op) => write!(f, \"attempt to negate `{:#?}`, which would overflow\", op),\n-            DivisionByZero(op) => write!(f, \"attempt to divide `{:#?}` by zero\", op),\n-            RemainderByZero(op) => write!(\n-                f,\n-                \"attempt to calculate the remainder of `{:#?}` with a divisor of zero\",\n-                op\n-            ),\n-            Overflow(BinOp::Add, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} + {:#?}`, which would overflow\", l, r)\n-            }\n-            Overflow(BinOp::Sub, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} - {:#?}`, which would overflow\", l, r)\n-            }\n-            Overflow(BinOp::Mul, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} * {:#?}`, which would overflow\", l, r)\n-            }\n-            Overflow(BinOp::Div, l, r) => {\n-                write!(f, \"attempt to compute `{:#?} / {:#?}`, which would overflow\", l, r)\n+            BoundsCheck { .. } => middle_bounds_check,\n+            Overflow(BinOp::Shl, _, _) => middle_assert_shl_overflow,\n+            Overflow(BinOp::Shr, _, _) => middle_assert_shr_overflow,\n+            Overflow(_, _, _) => middle_assert_op_overflow,\n+            OverflowNeg(_) => middle_assert_overflow_neg,\n+            DivisionByZero(_) => middle_assert_divide_by_zero,\n+            RemainderByZero(_) => middle_assert_remainder_by_zero,\n+            ResumedAfterReturn(GeneratorKind::Async(_)) => middle_assert_async_resume_after_return,\n+            ResumedAfterReturn(GeneratorKind::Gen) => middle_assert_generator_resume_after_return,\n+            ResumedAfterPanic(GeneratorKind::Async(_)) => middle_assert_async_resume_after_panic,\n+            ResumedAfterPanic(GeneratorKind::Gen) => middle_assert_generator_resume_after_panic,\n+\n+            MisalignedPointerDereference { .. } => middle_assert_misaligned_ptr_deref,\n+        }\n+    }\n+\n+    pub fn add_args(self, adder: &mut dyn FnMut(Cow<'static, str>, DiagnosticArgValue<'static>))\n+    where\n+        O: fmt::Debug,\n+    {\n+        use AssertKind::*;\n+\n+        macro_rules! add {\n+            ($name: expr, $value: expr) => {\n+                adder($name.into(), $value.into_diagnostic_arg());\n+            };\n+        }\n+\n+        match self {\n+            BoundsCheck { len, index } => {\n+                add!(\"len\", format!(\"{len:?}\"));\n+                add!(\"index\", format!(\"{index:?}\"));\n             }\n-            Overflow(BinOp::Rem, l, r) => write!(\n-                f,\n-                \"attempt to compute the remainder of `{:#?} % {:#?}`, which would overflow\",\n-                l, r\n-            ),\n-            Overflow(BinOp::Shr, _, r) => {\n-                write!(f, \"attempt to shift right by `{:#?}`, which would overflow\", r)\n+            Overflow(BinOp::Shl | BinOp::Shr, _, val)\n+            | DivisionByZero(val)\n+            | RemainderByZero(val)\n+            | OverflowNeg(val) => {\n+                add!(\"val\", format!(\"{val:#?}\"));\n             }\n-            Overflow(BinOp::Shl, _, r) => {\n-                write!(f, \"attempt to shift left by `{:#?}`, which would overflow\", r)\n+            Overflow(binop, left, right) => {\n+                add!(\"op\", binop.to_hir_binop().as_str());\n+                add!(\"left\", format!(\"{left:#?}\"));\n+                add!(\"right\", format!(\"{right:#?}\"));\n             }\n+            ResumedAfterReturn(_) | ResumedAfterPanic(_) => {}\n             MisalignedPointerDereference { required, found } => {\n-                write!(\n-                    f,\n-                    \"misaligned pointer dereference: address must be a multiple of {:?} but is {:?}\",\n-                    required, found\n-                )\n+                add!(\"required\", format!(\"{required:#?}\"));\n+                add!(\"found\", format!(\"{found:#?}\"));\n             }\n-            _ => write!(f, \"{}\", self.description()),\n         }\n     }\n }\n@@ -2461,51 +2467,6 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::Val(val, ty)\n     }\n \n-    #[instrument(skip(tcx), level = \"debug\", ret)]\n-    pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        let body_id = match tcx.hir().get(hir_id) {\n-            hir::Node::AnonConst(ac) => ac.body,\n-            _ => span_bug!(\n-                tcx.def_span(def_id.to_def_id()),\n-                \"from_inline_const can only process anonymous constants\"\n-            ),\n-        };\n-        let expr = &tcx.hir().body(body_id).value;\n-        let ty = tcx.typeck(def_id).node_type(hir_id);\n-\n-        let lit_input = match expr.kind {\n-            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n-            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n-                hir::ExprKind::Lit(ref lit) => {\n-                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        };\n-        if let Some(lit_input) = lit_input {\n-            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n-            // mir.\n-            match tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n-                Ok(c) => return c,\n-                Err(_) => {}\n-            }\n-        }\n-\n-        let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id());\n-        let parent_substs =\n-            tcx.erase_regions(InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n-        let substs =\n-            ty::InlineConstSubsts::new(tcx, ty::InlineConstSubstsParts { parent_substs, ty })\n-                .substs;\n-\n-        let uneval = UnevaluatedConst { def: def_id.to_def_id(), substs, promoted: None };\n-        debug_assert!(!uneval.has_free_regions());\n-\n-        Self::Unevaluated(uneval, ty)\n-    }\n-\n     /// Literals are converted to `ConstantKindVal`, const generic parameters are eagerly\n     /// converted to a constant, everything else becomes `Unevaluated`.\n     #[instrument(skip(tcx), level = \"debug\", ret)]"}, {"sha": "8477722ea393cbc777ca5102aec0445a1da91688", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -846,7 +846,7 @@ fn write_allocation_newline(\n /// The `prefix` argument allows callers to add an arbitrary prefix before each line (even if there\n /// is only one line). Note that your prefix should contain a trailing space as the lines are\n /// printed directly after it.\n-fn write_allocation_bytes<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n+pub fn write_allocation_bytes<'tcx, Prov: Provenance, Extra, Bytes: AllocBytes>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &Allocation<Prov, Extra, Bytes>,\n     w: &mut dyn std::fmt::Write,"}, {"sha": "83f8f00d72ce24895738c84b50b1eade60dd87d6", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -801,7 +801,8 @@ pub enum UnwindAction {\n }\n \n /// Information about an assertion failure.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n+#[derive(Clone, Hash, HashStable, PartialEq, Debug)]\n+#[derive(TyEncodable, TyDecodable, TypeFoldable, TypeVisitable)]\n pub enum AssertKind<O> {\n     BoundsCheck { len: O, index: O },\n     Overflow(BinOp, O, O),"}, {"sha": "0b31c9bbf8149f799efdb3514aa8f948bd997e45", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1081,14 +1081,6 @@ rustc_queries! {\n         desc { \"destructuring MIR constant\"}\n     }\n \n-    /// Dereference a constant reference or raw pointer and turn the result into a constant\n-    /// again.\n-    query deref_mir_constant(\n-        key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n-    ) -> mir::ConstantKind<'tcx> {\n-        desc { \"dereferencing MIR constant\" }\n-    }\n-\n     query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n         desc { \"getting a &core::panic::Location referring to a span\" }\n     }\n@@ -1100,10 +1092,6 @@ rustc_queries! {\n         desc { \"converting literal to const\" }\n     }\n \n-    query lit_to_mir_constant(key: LitToConstInput<'tcx>) -> Result<mir::ConstantKind<'tcx>, LitToConstError> {\n-        desc { \"converting literal to mir constant\" }\n-    }\n-\n     query check_match(key: LocalDefId) -> Result<(), rustc_errors::ErrorGuaranteed> {\n         desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { true }"}, {"sha": "1e43fab457e563a210ff4686b9700d43efb11d24", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,5 +1,6 @@\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_target::abi::Size;\n use std::fmt;\n@@ -113,6 +114,14 @@ impl std::fmt::Debug for ConstInt {\n     }\n }\n \n+impl IntoDiagnosticArg for ConstInt {\n+    // FIXME this simply uses the Debug impl, but we could probably do better by converting both\n+    // to an inherent method that returns `Cow`.\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(format!(\"{self:?}\").into())\n+    }\n+}\n+\n /// The raw bytes of a simple value.\n ///\n /// This is a packed struct in order to allow this type to be optimally embedded in enums"}, {"sha": "b05e791211d10bb3e8c70aef9b93fe522a66e5b7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -82,8 +82,6 @@ use std::iter;\n use std::mem;\n use std::ops::{Bound, Deref};\n \n-const TINY_CONST_EVAL_LIMIT: Limit = Limit(20);\n-\n #[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx> Interner for TyCtxt<'tcx> {\n     type AdtDef = ty::AdtDef<'tcx>;\n@@ -1178,14 +1176,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.limits(()).move_size_limit\n     }\n \n-    pub fn const_eval_limit(self) -> Limit {\n-        if self.sess.opts.unstable_opts.tiny_const_eval_limit {\n-            TINY_CONST_EVAL_LIMIT\n-        } else {\n-            self.limits(()).const_eval_limit\n-        }\n-    }\n-\n     pub fn all_traits(self) -> impl Iterator<Item = DefId> + 'tcx {\n         iter::once(LOCAL_CRATE)\n             .chain(self.crates(()).iter().copied())"}, {"sha": "c5a306fdf1f9a351a3373f2726f1e6ce7594d1c4", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,8 +1,9 @@\n-use crate::fluent_generated as fluent;\n+use crate::error::UnsupportedFnAbi;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::query::TyCtxtAt;\n use crate::ty::normalize_erasing_regions::NormalizationError;\n use crate::ty::{self, ReprOptions, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_error_messages::DiagnosticMessage;\n use rustc_errors::{DiagnosticBuilder, Handler, IntoDiagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -14,7 +15,7 @@ use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::*;\n use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy, Target};\n \n-use std::cmp::{self};\n+use std::cmp;\n use std::fmt;\n use std::num::NonZeroUsize;\n use std::ops::Bound;\n@@ -214,29 +215,29 @@ pub enum LayoutError<'tcx> {\n     Cycle,\n }\n \n-impl IntoDiagnostic<'_, !> for LayoutError<'_> {\n-    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n-        let mut diag = handler.struct_fatal(\"\");\n+impl<'tcx> LayoutError<'tcx> {\n+    pub fn diagnostic_message(&self) -> DiagnosticMessage {\n+        use crate::fluent_generated::*;\n+        use LayoutError::*;\n+        match self {\n+            Unknown(_) => middle_unknown_layout,\n+            SizeOverflow(_) => middle_values_too_big,\n+            NormalizationFailure(_, _) => middle_cannot_be_normalized,\n+            Cycle => middle_cycle,\n+        }\n+    }\n \n+    pub fn into_diagnostic(self) -> crate::error::LayoutError<'tcx> {\n+        use crate::error::LayoutError as E;\n+        use LayoutError::*;\n         match self {\n-            LayoutError::Unknown(ty) => {\n-                diag.set_arg(\"ty\", ty);\n-                diag.set_primary_message(fluent::middle_unknown_layout);\n-            }\n-            LayoutError::SizeOverflow(ty) => {\n-                diag.set_arg(\"ty\", ty);\n-                diag.set_primary_message(fluent::middle_values_too_big);\n-            }\n-            LayoutError::NormalizationFailure(ty, e) => {\n-                diag.set_arg(\"ty\", ty);\n-                diag.set_arg(\"failure_ty\", e.get_type_for_failure());\n-                diag.set_primary_message(fluent::middle_cannot_be_normalized);\n-            }\n-            LayoutError::Cycle => {\n-                diag.set_primary_message(fluent::middle_cycle);\n+            Unknown(ty) => E::Unknown { ty },\n+            SizeOverflow(ty) => E::Overflow { ty },\n+            NormalizationFailure(ty, e) => {\n+                E::NormalizationFailure { ty, failure_ty: e.get_type_for_failure() }\n             }\n+            Cycle => E::Cycle,\n         }\n-        diag\n     }\n }\n \n@@ -330,11 +331,8 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }\n                     _ => bug!(\n-                        \"SizeSkeleton::compute({}): layout errored ({}), yet \\\n-                              tail `{}` is not a type parameter or a projection\",\n-                        ty,\n-                        err,\n-                        tail\n+                        \"SizeSkeleton::compute({ty}): layout errored ({err:?}), yet \\\n+                              tail `{tail}` is not a type parameter or a projection\",\n                     ),\n                 }\n             }\n@@ -940,12 +938,8 @@ where\n             TyMaybeWithLayout::Ty(field_ty) => {\n                 cx.tcx().layout_of(cx.param_env().and(field_ty)).unwrap_or_else(|e| {\n                     bug!(\n-                        \"failed to get layout for `{}`: {},\\n\\\n-                         despite it being a field (#{}) of an existing layout: {:#?}\",\n-                        field_ty,\n-                        e,\n-                        i,\n-                        this\n+                        \"failed to get layout for `{field_ty}`: {e:?},\\n\\\n+                         despite it being a field (#{i}) of an existing layout: {this:#?}\",\n                     )\n                 })\n             }\n@@ -1262,21 +1256,18 @@ impl From<call::AdjustForForeignAbiError> for FnAbiError<'_> {\n     }\n }\n \n-impl<'tcx> fmt::Display for FnAbiError<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+impl<'a, 'b> IntoDiagnostic<'a, !> for FnAbiError<'b> {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, !> {\n         match self {\n-            Self::Layout(err) => err.fmt(f),\n-            Self::AdjustForForeignAbi(err) => err.fmt(f),\n+            Self::Layout(e) => e.into_diagnostic().into_diagnostic(handler),\n+            Self::AdjustForForeignAbi(call::AdjustForForeignAbiError::Unsupported {\n+                arch,\n+                abi,\n+            }) => UnsupportedFnAbi { arch, abi: abi.name() }.into_diagnostic(handler),\n         }\n     }\n }\n \n-impl IntoDiagnostic<'_, !> for FnAbiError<'_> {\n-    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n-        handler.struct_fatal(self.to_string())\n-    }\n-}\n-\n // FIXME(eddyb) maybe use something like this for an unified `fn_abi_of`, not\n // just for error handling.\n #[derive(Debug)]"}, {"sha": "8cbffa14850fac3a5187fb83b6dbf1b6ef5674d5", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -155,11 +155,7 @@ pub struct TypeckResults<'tcx> {\n     /// We also store the type here, so that the compiler can use it as a hint\n     /// for figuring out hidden types, even if they are only set in dead code\n     /// (which doesn't show up in MIR).\n-    ///\n-    /// These types are mapped back to the opaque's identity substitutions\n-    /// (with erased regions), which is why we don't associated substs with any\n-    /// of these usages.\n-    pub concrete_opaque_types: FxIndexMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n+    pub concrete_opaque_types: FxIndexMap<ty::OpaqueTypeKey<'tcx>, ty::OpaqueHiddenType<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "dce2f5545f51d51861a5ff0eee5b3ffc259654c6", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::stable_hasher::{Hash64, HashStable, StableHasher};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_index::{Idx, IndexVec};\n use rustc_macros::HashStable;\n@@ -857,6 +857,26 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => def_kind.article(),\n         }\n     }\n+\n+    /// Return `true` if the supplied `CrateNum` is \"user-visible,\" meaning either a [public]\n+    /// dependency, or a [direct] private dependency. This is used to decide whether the crate can\n+    /// be shown in `impl` suggestions.\n+    ///\n+    /// [public]: TyCtxt::is_private_dep\n+    /// [direct]: rustc_session::cstore::ExternCrate::is_direct\n+    pub fn is_user_visible_dep(self, key: CrateNum) -> bool {\n+        // | Private | Direct | Visible |                    |\n+        // |---------|--------|---------|--------------------|\n+        // | Yes     | Yes    | Yes     | !true || true   |\n+        // | No      | Yes    | Yes     | !false || true  |\n+        // | Yes     | No     | No      | !true || false  |\n+        // | No      | No     | Yes     | !false || false |\n+        !self.is_private_dep(key)\n+            // If `extern_crate` is `None`, then the crate was injected (e.g., by the allocator).\n+            // Treat that kind of crate as \"indirect\", since it's an implementation detail of\n+            // the language.\n+            || self.extern_crate(key.as_def_id()).map_or(false, |e| e.is_direct())\n+    }\n }\n \n struct OpaqueTypeExpander<'tcx> {"}, {"sha": "443791d0af4ba87da5586f4f9723d401522c12fc", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -73,7 +73,7 @@ pub(super) fn vtable_allocation_provider<'tcx>(\n     let ptr_align = tcx.data_layout.pointer_align.abi;\n \n     let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n-    let mut vtable = Allocation::uninit(vtable_size, ptr_align, /* panic_on_fail */ true).unwrap();\n+    let mut vtable = Allocation::uninit(vtable_size, ptr_align);\n \n     // No need to do any alignment checks on the memory accesses below, because we know the\n     // allocation is correctly aligned as we created it above. Also we're only offsetting by"}, {"sha": "73d5eb62750828bc23df6cfd8da9f316bdcdb6be", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -106,7 +106,7 @@ pub fn as_constant_inner<'tcx>(\n }\n \n #[instrument(skip(tcx, lit_input))]\n-pub(crate) fn lit_to_mir_constant<'tcx>(\n+fn lit_to_mir_constant<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n ) -> Result<ConstantKind<'tcx>, LitToConstError> {"}, {"sha": "8f6a069a7db54e365c4f9d6f82ba9d16f6a92877", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,4 +1,3 @@\n-pub(crate) use crate::build::expr::as_constant::lit_to_mir_constant;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n use rustc_apfloat::ieee::{Double, Single};"}, {"sha": "0eaab9b57036cfee0b507b46378bd3b584593b18", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -32,7 +32,6 @@ fluent_messages! { \"../messages.ftl\" }\n pub fn provide(providers: &mut Providers) {\n     providers.check_match = thir::pattern::check_match;\n     providers.lit_to_const = thir::constant::lit_to_const;\n-    providers.lit_to_mir_constant = build::lit_to_mir_constant;\n     providers.mir_built = build::mir_built;\n     providers.thir_check_unsafety = check_unsafety::thir_check_unsafety;\n     providers.thir_body = thir::cx::thir_body;"}, {"sha": "a7be8e3c9033b06aaccf20adbee7c1700fe6bd25", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,6 +3,8 @@ use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::ty::{self, ParamEnv, ScalarInt, TyCtxt};\n use rustc_span::DUMMY_SP;\n \n+use crate::build::parse_float_into_scalar;\n+\n pub(crate) fn lit_to_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n@@ -46,12 +48,28 @@ pub(crate) fn lit_to_const<'tcx>(\n         (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n             ty::ValTree::from_scalar_int((*n).into())\n         }\n+        (ast::LitKind::CStr(data, _), ty::Ref(_, inner_ty, _)) if matches!(inner_ty.kind(), ty::Adt(def, _) if Some(def.did()) == tcx.lang_items().c_str()) =>\n+        {\n+            let bytes = data as &[u8];\n+            ty::ValTree::from_raw_bytes(tcx, bytes)\n+        }\n         (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n             let scalar_int =\n                 trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?;\n             ty::ValTree::from_scalar_int(scalar_int)\n         }\n         (ast::LitKind::Bool(b), ty::Bool) => ty::ValTree::from_scalar_int((*b).into()),\n+        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n+            let bits = parse_float_into_scalar(*n, *fty, neg)\n+                .ok_or_else(|| {\n+                    LitToConstError::Reported(tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        format!(\"couldn't parse float literal: {:?}\", lit_input.lit),\n+                    ))\n+                })?\n+                .assert_int();\n+            ty::ValTree::from_scalar_int(bits)\n+        }\n         (ast::LitKind::Char(c), ty::Char) => ty::ValTree::from_scalar_int((*c).into()),\n         (ast::LitKind::Err, _) => {\n             return Err(LitToConstError::Reported("}, {"sha": "7976b148f75e27ed7c1f9a23df05b15a72d5e5a2", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 165, "deletions": 146, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,13 +1,14 @@\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_index::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n use rustc_middle::mir;\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, ValTree};\n use rustc_session::lint;\n use rustc_span::Span;\n-use rustc_target::abi::FieldIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n \n@@ -29,11 +30,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         cv: mir::ConstantKind<'tcx>,\n         id: hir::HirId,\n         span: Span,\n-        mir_structural_match_violation: bool,\n+        check_body_for_struct_match_violation: Option<DefId>,\n     ) -> Box<Pat<'tcx>> {\n         let infcx = self.tcx.infer_ctxt().build();\n         let mut convert = ConstToPat::new(self, id, span, infcx);\n-        convert.to_pat(cv, mir_structural_match_violation)\n+        convert.to_pat(cv, check_body_for_struct_match_violation)\n     }\n }\n \n@@ -104,7 +105,7 @@ impl<'tcx> ConstToPat<'tcx> {\n     fn to_pat(\n         &mut self,\n         cv: mir::ConstantKind<'tcx>,\n-        mir_structural_match_violation: bool,\n+        check_body_for_struct_match_violation: Option<DefId>,\n     ) -> Box<Pat<'tcx>> {\n         trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n@@ -114,14 +115,44 @@ impl<'tcx> ConstToPat<'tcx> {\n         // once indirect_structural_match is a full fledged error, this\n         // level of indirection can be eliminated\n \n-        let inlined_const_as_pat =\n-            self.recur(cv, mir_structural_match_violation).unwrap_or_else(|_| {\n-                Box::new(Pat {\n-                    span: self.span,\n-                    ty: cv.ty(),\n-                    kind: PatKind::Constant { value: cv },\n-                })\n-            });\n+        let mir_structural_match_violation = check_body_for_struct_match_violation.map(|def_id| {\n+            // `mir_const_qualif` must be called with the `DefId` of the item where the const is\n+            // defined, not where it is declared. The difference is significant for associated\n+            // constants.\n+            self.tcx().mir_const_qualif(def_id).custom_eq\n+        });\n+        debug!(?check_body_for_struct_match_violation, ?mir_structural_match_violation);\n+\n+        let inlined_const_as_pat = match cv {\n+            mir::ConstantKind::Ty(c) => match c.kind() {\n+                ty::ConstKind::Param(_)\n+                | ty::ConstKind::Infer(_)\n+                | ty::ConstKind::Bound(_, _)\n+                | ty::ConstKind::Placeholder(_)\n+                | ty::ConstKind::Unevaluated(_)\n+                | ty::ConstKind::Error(_)\n+                | ty::ConstKind::Expr(_) => {\n+                    span_bug!(self.span, \"unexpected const in `to_pat`: {:?}\", c.kind())\n+                }\n+                ty::ConstKind::Value(valtree) => self\n+                    .recur(valtree, cv.ty(), mir_structural_match_violation.unwrap_or(false))\n+                    .unwrap_or_else(|_| {\n+                        Box::new(Pat {\n+                            span: self.span,\n+                            ty: cv.ty(),\n+                            kind: PatKind::Constant { value: cv },\n+                        })\n+                    }),\n+            },\n+            mir::ConstantKind::Unevaluated(_, _) => {\n+                span_bug!(self.span, \"unevaluated const in `to_pat`: {cv:?}\")\n+            }\n+            mir::ConstantKind::Val(_, _) => Box::new(Pat {\n+                span: self.span,\n+                ty: cv.ty(),\n+                kind: PatKind::Constant { value: cv },\n+            }),\n+        };\n \n         if !self.saw_const_match_error.get() {\n             // If we were able to successfully convert the const to some pat,\n@@ -141,36 +172,78 @@ impl<'tcx> ConstToPat<'tcx> {\n             //\n             // FIXME(#73448): Find a way to bring const qualification into parity with\n             // `search_for_structural_match_violation`.\n-            if structural.is_none() && mir_structural_match_violation {\n+            if structural.is_none() && mir_structural_match_violation.unwrap_or(false) {\n                 warn!(\"MIR const-checker found novel structural match violation. See #73448.\");\n                 return inlined_const_as_pat;\n             }\n \n             if let Some(non_sm_ty) = structural {\n                 if !self.type_may_have_partial_eq_impl(cv.ty()) {\n-                    // fatal avoids ICE from resolution of nonexistent method (rare case).\n-                    self.tcx()\n-                        .sess\n-                        .emit_fatal(TypeNotStructural { span: self.span, non_sm_ty: non_sm_ty });\n-                } else if mir_structural_match_violation && !self.saw_const_match_lint.get() {\n-                    self.tcx().emit_spanned_lint(\n-                        lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n-                        self.id,\n-                        self.span,\n-                        IndirectStructuralMatch { non_sm_ty },\n-                    );\n-                } else {\n-                    debug!(\n-                        \"`search_for_structural_match_violation` found one, but `CustomEq` was \\\n-                          not in the qualifs for that `const`\"\n-                    );\n+                    if let ty::Adt(def, ..) = non_sm_ty.kind() {\n+                        if def.is_union() {\n+                            let err = UnionPattern { span: self.span };\n+                            self.tcx().sess.emit_err(err);\n+                        } else {\n+                            // fatal avoids ICE from resolution of nonexistent method (rare case).\n+                            self.tcx()\n+                                .sess\n+                                .emit_fatal(TypeNotStructural { span: self.span, non_sm_ty });\n+                        }\n+                    } else {\n+                        let err = InvalidPattern { span: self.span, non_sm_ty };\n+                        self.tcx().sess.emit_err(err);\n+                        return Box::new(Pat { span: self.span, ty: cv.ty(), kind: PatKind::Wild });\n+                    }\n+                } else if !self.saw_const_match_lint.get() {\n+                    if let Some(mir_structural_match_violation) = mir_structural_match_violation {\n+                        match non_sm_ty.kind() {\n+                            ty::RawPtr(pointee)\n+                                if pointee.ty.is_sized(self.tcx(), self.param_env) => {}\n+                            ty::FnPtr(..) | ty::RawPtr(..) => {\n+                                self.tcx().emit_spanned_lint(\n+                                    lint::builtin::POINTER_STRUCTURAL_MATCH,\n+                                    self.id,\n+                                    self.span,\n+                                    PointerPattern,\n+                                );\n+                            }\n+                            ty::Adt(..) if mir_structural_match_violation => {\n+                                self.tcx().emit_spanned_lint(\n+                                    lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n+                                    self.id,\n+                                    self.span,\n+                                    IndirectStructuralMatch { non_sm_ty },\n+                                );\n+                            }\n+                            _ => {\n+                                debug!(\n+                                    \"`search_for_structural_match_violation` found one, but `CustomEq` was \\\n+                                  not in the qualifs for that `const`\"\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n+            } else if !self.saw_const_match_lint.get() {\n+                match cv.ty().kind() {\n+                    ty::RawPtr(pointee) if pointee.ty.is_sized(self.tcx(), self.param_env) => {}\n+                    ty::FnPtr(..) | ty::RawPtr(..) => {\n+                        self.tcx().emit_spanned_lint(\n+                            lint::builtin::POINTER_STRUCTURAL_MATCH,\n+                            self.id,\n+                            self.span,\n+                            PointerPattern,\n+                        );\n+                    }\n+                    _ => {}\n                 }\n             }\n         }\n \n         inlined_const_as_pat\n     }\n \n+    #[instrument(level = \"trace\", skip(self), ret)]\n     fn type_may_have_partial_eq_impl(&self, ty: Ty<'tcx>) -> bool {\n         // double-check there even *is* a semantic `PartialEq` to dispatch to.\n         //\n@@ -187,29 +260,19 @@ impl<'tcx> ConstToPat<'tcx> {\n         );\n \n         // FIXME: should this call a `predicate_must_hold` variant instead?\n-        let has_impl = self.infcx.predicate_may_hold(&partial_eq_obligation);\n-\n-        // Note: To fix rust-lang/rust#65466, we could just remove this type\n-        // walk hack for function pointers, and unconditionally error\n-        // if `PartialEq` is not implemented. However, that breaks stable\n-        // code at the moment, because types like `for <'a> fn(&'a ())` do\n-        // not *yet* implement `PartialEq`. So for now we leave this here.\n-        has_impl\n-            || ty.walk().any(|t| match t.unpack() {\n-                ty::subst::GenericArgKind::Lifetime(_) => false,\n-                ty::subst::GenericArgKind::Type(t) => t.is_fn_ptr(),\n-                ty::subst::GenericArgKind::Const(_) => false,\n-            })\n+        self.infcx.predicate_may_hold(&partial_eq_obligation)\n     }\n \n     fn field_pats(\n         &self,\n-        vals: impl Iterator<Item = mir::ConstantKind<'tcx>>,\n+        vals: impl Iterator<Item = (ValTree<'tcx>, Ty<'tcx>)>,\n     ) -> Result<Vec<FieldPat<'tcx>>, FallbackToConstRef> {\n         vals.enumerate()\n-            .map(|(idx, val)| {\n+            .map(|(idx, (val, ty))| {\n                 let field = FieldIdx::new(idx);\n-                Ok(FieldPat { field, pattern: self.recur(val, false)? })\n+                // Patterns can only use monomorphic types.\n+                let ty = self.tcx().normalize_erasing_regions(self.param_env, ty);\n+                Ok(FieldPat { field, pattern: self.recur(val, ty, false)? })\n             })\n             .collect()\n     }\n@@ -218,16 +281,18 @@ impl<'tcx> ConstToPat<'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     fn recur(\n         &self,\n-        cv: mir::ConstantKind<'tcx>,\n+        cv: ValTree<'tcx>,\n+        ty: Ty<'tcx>,\n         mir_structural_match_violation: bool,\n     ) -> Result<Box<Pat<'tcx>>, FallbackToConstRef> {\n         let id = self.id;\n         let span = self.span;\n         let tcx = self.tcx();\n         let param_env = self.param_env;\n \n-        let kind = match cv.ty().kind() {\n+        let kind = match ty.kind() {\n             ty::Float(_) => {\n+                self.saw_const_match_lint.set(true);\n                 tcx.emit_spanned_lint(\n                     lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                     id,\n@@ -236,27 +301,6 @@ impl<'tcx> ConstToPat<'tcx> {\n                 );\n                 return Err(FallbackToConstRef);\n             }\n-            ty::Adt(adt_def, _) if adt_def.is_union() => {\n-                // Matching on union fields is unsafe, we can't hide it in constants\n-                self.saw_const_match_error.set(true);\n-                let err = UnionPattern { span };\n-                tcx.sess.emit_err(err);\n-                PatKind::Wild\n-            }\n-            ty::Adt(..)\n-                if !self.type_may_have_partial_eq_impl(cv.ty())\n-                    // FIXME(#73448): Find a way to bring const qualification into parity with\n-                    // `search_for_structural_match_violation` and then remove this condition.\n-\n-                    // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n-                    // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-                    && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty()) =>\n-            {\n-                self.saw_const_match_error.set(true);\n-                let err = TypeNotStructural { span, non_sm_ty };\n-                tcx.sess.emit_err(err);\n-                PatKind::Wild\n-            }\n             // If the type is not structurally comparable, just emit the constant directly,\n             // causing the pattern match code to treat it opaquely.\n             // FIXME: This code doesn't emit errors itself, the caller emits the errors.\n@@ -266,94 +310,90 @@ impl<'tcx> ConstToPat<'tcx> {\n             // details.\n             // Backwards compatibility hack because we can't cause hard errors on these\n             // types, so we compare them via `PartialEq::eq` at runtime.\n-            ty::Adt(..) if !self.type_marked_structural(cv.ty()) && self.behind_reference.get() => {\n-                if !self.saw_const_match_error.get()\n-                    && !self.saw_const_match_lint.get()\n-                {\n+            ty::Adt(..) if !self.type_marked_structural(ty) && self.behind_reference.get() => {\n+                if !self.saw_const_match_error.get() && !self.saw_const_match_lint.get() {\n                     self.saw_const_match_lint.set(true);\n                     tcx.emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        IndirectStructuralMatch { non_sm_ty: cv.ty() },\n+                        IndirectStructuralMatch { non_sm_ty: ty },\n                     );\n                 }\n                 // Since we are behind a reference, we can just bubble the error up so we get a\n                 // constant at reference type, making it easy to let the fallback call\n                 // `PartialEq::eq` on it.\n                 return Err(FallbackToConstRef);\n             }\n-            ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty()) => {\n-                debug!(\n-                    \"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\",\n-                    adt_def,\n-                    cv.ty()\n-                );\n+            ty::Adt(adt_def, _) if !self.type_marked_structural(ty) => {\n+                debug!(\"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\", adt_def, ty,);\n                 self.saw_const_match_error.set(true);\n-                let err = TypeNotStructural { span, non_sm_ty: cv.ty() };\n+                let err = TypeNotStructural { span, non_sm_ty: ty };\n                 tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let destructured = tcx.destructure_mir_constant(param_env, cv);\n-\n+                let (&variant_index, fields) = cv.unwrap_branch().split_first().unwrap();\n+                let variant_index =\n+                    VariantIdx::from_u32(variant_index.unwrap_leaf().try_to_u32().ok().unwrap());\n                 PatKind::Variant {\n                     adt_def: *adt_def,\n                     substs,\n-                    variant_index: destructured\n-                        .variant\n-                        .expect(\"destructed const of adt without variant id\"),\n-                    subpatterns: self.field_pats(destructured.fields.iter().copied())?,\n+                    variant_index,\n+                    subpatterns: self.field_pats(\n+                        fields.iter().copied().zip(\n+                            adt_def.variants()[variant_index]\n+                                .fields\n+                                .iter()\n+                                .map(|field| field.ty(self.tcx(), substs)),\n+                        ),\n+                    )?,\n                 }\n             }\n-            ty::Tuple(_) | ty::Adt(_, _) => {\n-                let destructured = tcx.destructure_mir_constant(param_env, cv);\n-                PatKind::Leaf { subpatterns: self.field_pats(destructured.fields.iter().copied())? }\n-            }\n-            ty::Array(..) => PatKind::Array {\n-                prefix: tcx\n-                    .destructure_mir_constant(param_env, cv)\n-                    .fields\n+            ty::Tuple(fields) => PatKind::Leaf {\n+                subpatterns: self\n+                    .field_pats(cv.unwrap_branch().iter().copied().zip(fields.iter()))?,\n+            },\n+            ty::Adt(def, substs) => PatKind::Leaf {\n+                subpatterns: self.field_pats(cv.unwrap_branch().iter().copied().zip(\n+                    def.non_enum_variant().fields.iter().map(|field| field.ty(self.tcx(), substs)),\n+                ))?,\n+            },\n+            ty::Array(elem_ty, _) => PatKind::Array {\n+                prefix: cv\n+                    .unwrap_branch()\n                     .iter()\n-                    .map(|val| self.recur(*val, false))\n+                    .map(|val| self.recur(*val, *elem_ty, false))\n                     .collect::<Result<_, _>>()?,\n                 slice: None,\n                 suffix: Box::new([]),\n             },\n             ty::Ref(_, pointee_ty, ..) => match *pointee_ty.kind() {\n-                // These are not allowed and will error elsewhere anyway.\n-                ty::Dynamic(..) => {\n-                    self.saw_const_match_error.set(true);\n-                    let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.emit_err(err);\n-                    PatKind::Wild\n-                }\n-                // `&str` is represented as `ConstValue::Slice`, let's keep using this\n+                // `&str` is represented as a valtree, let's keep using this\n                 // optimization for now.\n-                ty::Str => PatKind::Constant { value: cv },\n+                ty::Str => PatKind::Constant { value: mir::ConstantKind::Ty(tcx.mk_const(cv, ty)) },\n                 // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n                 // matching against references, you can only use byte string literals.\n                 // The typechecker has a special case for byte string literals, by treating them\n                 // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n                 // has no negative effects on pattern matching, even if we're actually matching on\n                 // arrays.\n-                ty::Array(..) if !self.treat_byte_string_as_slice => {\n+                ty::Array(elem_ty, _) if !self.treat_byte_string_as_slice => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n+                    // References have the same valtree representation as their pointee.\n+                    let array = cv;\n                     let val = PatKind::Deref {\n                         subpattern: Box::new(Pat {\n                             kind: PatKind::Array {\n-                                prefix: tcx\n-                                    .destructure_mir_constant(param_env, array)\n-                                    .fields\n+                                prefix: array.unwrap_branch()\n                                     .iter()\n-                                    .map(|val| self.recur(*val, false))\n+                                    .map(|val| self.recur(*val, elem_ty, false))\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: Box::new([]),\n                             },\n                             span,\n-                            ty: *pointee_ty,\n+                            ty: tcx.mk_slice(elem_ty),\n                         }),\n                     };\n                     self.behind_reference.set(old);\n@@ -365,15 +405,14 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // pattern.\n                 ty::Slice(elem_ty) => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n+                    // References have the same valtree representation as their pointee.\n+                    let array = cv;\n                     let val = PatKind::Deref {\n                         subpattern: Box::new(Pat {\n                             kind: PatKind::Slice {\n-                                prefix: tcx\n-                                    .destructure_mir_constant(param_env, array)\n-                                    .fields\n+                                prefix: array.unwrap_branch()\n                                     .iter()\n-                                    .map(|val| self.recur(*val, false))\n+                                    .map(|val| self.recur(*val, elem_ty, false))\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: Box::new([]),\n@@ -418,48 +457,28 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // deref pattern.\n                 _ => {\n                     if !pointee_ty.is_sized(tcx, param_env) {\n-                        // `tcx.deref_mir_constant()` below will ICE with an unsized type\n-                        // (except slices, which are handled in a separate arm above).\n-\n                         let err = UnsizedPattern { span, non_sm_ty: *pointee_ty };\n                         tcx.sess.emit_err(err);\n \n+                        // FIXME: introduce PatKind::Error to silence follow up diagnostics due to unreachable patterns.\n                         PatKind::Wild\n                     } else {\n                         let old = self.behind_reference.replace(true);\n-                        let subpattern = self.recur(tcx.deref_mir_constant(self.param_env.and(cv)), false)?;\n+                        // References have the same valtree representation as their pointee.\n+                        let subpattern = self.recur(cv, *pointee_ty, false)?;\n                         self.behind_reference.set(old);\n                         PatKind::Deref { subpattern }\n                     }\n                 }\n             },\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::FnDef(..) => {\n-                PatKind::Constant { value: cv }\n-            }\n-            ty::RawPtr(pointee) if pointee.ty.is_sized(tcx, param_env) => {\n-                return Err(FallbackToConstRef);\n-            }\n-            // FIXME: these can have very surprising behaviour where optimization levels or other\n-            // compilation choices change the runtime behaviour of the match.\n-            // See https://github.com/rust-lang/rust/issues/70861 for examples.\n-            ty::FnPtr(..) | ty::RawPtr(..) => {\n-                if !self.saw_const_match_error.get()\n-                    && !self.saw_const_match_lint.get()\n-                {\n-                    self.saw_const_match_lint.set(true);\n-                    tcx.emit_spanned_lint(\n-                        lint::builtin::POINTER_STRUCTURAL_MATCH,\n-                        id,\n-                        span,\n-                        PointerPattern\n-                    );\n-                }\n-                return Err(FallbackToConstRef);\n+                PatKind::Constant { value: mir::ConstantKind::Ty(tcx.mk_const(cv, ty)) }\n             }\n+            ty::FnPtr(..) | ty::RawPtr(..) => unreachable!(),\n             _ => {\n                 self.saw_const_match_error.set(true);\n-                let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n-                    tcx.sess.emit_err(err);\n+                let err = InvalidPattern { span, non_sm_ty: ty };\n+                tcx.sess.emit_err(err);\n                 PatKind::Wild\n             }\n         };\n@@ -472,7 +491,7 @@ impl<'tcx> ConstToPat<'tcx> {\n \n             // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n             // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-            && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty())\n+            && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, ty)\n         {\n             self.saw_const_match_lint.set(true);\n             tcx.emit_spanned_lint(\n@@ -483,6 +502,6 @@ impl<'tcx> ConstToPat<'tcx> {\n             );\n         }\n \n-        Ok(Box::new(Pat { span, ty: cv.ty(), kind }))\n+        Ok(Box::new(Pat { span, ty, kind }))\n     }\n }"}, {"sha": "9df6d2f43ad57b8493fc700c8081031853831a83", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -53,11 +53,11 @@ use smallvec::{smallvec, SmallVec};\n use rustc_data_structures::captures::Captures;\n use rustc_hir::{HirId, RangeEnd};\n use rustc_index::Idx;\n+use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::mir;\n use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Ty, TyCtxt, VariantDef};\n-use rustc_middle::{middle::stability::EvalResult, mir::interpret::ConstValue};\n use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{FieldIdx, Integer, Size, VariantIdx, FIRST_VARIANT};\n@@ -140,28 +140,17 @@ impl IntRange {\n         value: mir::ConstantKind<'tcx>,\n     ) -> Option<IntRange> {\n         let ty = value.ty();\n-        if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n-            let val = if let mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) = value {\n-                // For this specific pattern we can skip a lot of effort and go\n-                // straight to the result, after doing a bit of checking. (We\n-                // could remove this branch and just fall through, which\n-                // is more general but much slower.)\n-                scalar.to_bits_or_ptr_internal(target_size).unwrap().left()?\n-            } else {\n-                if let mir::ConstantKind::Ty(c) = value\n-                    && let ty::ConstKind::Value(_) = c.kind()\n-                {\n-                    bug!(\"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\");\n-                }\n+        let (target_size, bias) = Self::integral_size_and_signed_bias(tcx, ty)?;\n+        let val = match value {\n+            mir::ConstantKind::Ty(c) if let ty::ConstKind::Value(valtree) = c.kind() => {\n+                valtree.unwrap_leaf().to_bits(target_size).ok()\n+            },\n+            // This is a more general form of the previous case.\n+            _ => value.try_eval_bits(tcx, param_env, ty),\n+        }?;\n \n-                // This is a more general form of the previous case.\n-                value.try_eval_bits(tcx, param_env, ty)?\n-            };\n-            let val = val ^ bias;\n-            Some(IntRange { range: val..=val, bias })\n-        } else {\n-            None\n-        }\n+        let val = val ^ bias;\n+        Some(IntRange { range: val..=val, bias })\n     }\n \n     #[inline]"}, {"sha": "1bbe7b45c1ed2bc7144c352c25126e434fbb6126", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 90, "deletions": 34, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -18,14 +18,15 @@ use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::Idx;\n use rustc_middle::mir::interpret::{\n-    ConstValue, ErrorHandled, LitToConstError, LitToConstInput, Scalar,\n+    ConstValue, ErrorHandled, GlobalId, LitToConstError, LitToConstInput, Scalar,\n };\n-use rustc_middle::mir::{self, UserTypeProjection};\n+use rustc_middle::mir::{self, ConstantKind, UserTypeProjection};\n use rustc_middle::mir::{BorrowKind, Mutability};\n use rustc_middle::thir::{Ascription, BindingMode, FieldPat, LocalVarId, Pat, PatKind, PatRange};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n-use rustc_middle::ty::{self, AdtDef, ConstKind, Region, Ty, TyCtxt, UserType};\n+use rustc_middle::ty::TypeVisitableExt;\n+use rustc_middle::ty::{self, AdtDef, Region, Ty, TyCtxt, UserType};\n use rustc_span::{Span, Symbol};\n use rustc_target::abi::FieldIdx;\n \n@@ -518,16 +519,24 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n         };\n \n-        // `mir_const_qualif` must be called with the `DefId` of the item where the const is\n-        // defined, not where it is declared. The difference is significant for associated\n-        // constants.\n-        let mir_structural_match_violation = self.tcx.mir_const_qualif(instance.def_id()).custom_eq;\n-        debug!(\"mir_structural_match_violation({:?}) -> {}\", qpath, mir_structural_match_violation);\n-\n-        match self.tcx.const_eval_instance(param_env_reveal_all, instance, Some(span)) {\n-            Ok(literal) => {\n-                let const_ = mir::ConstantKind::Val(literal, ty);\n-                let pattern = self.const_to_pat(const_, id, span, mir_structural_match_violation);\n+        let cid = GlobalId { instance, promoted: None };\n+        // Prefer valtrees over opaque constants.\n+        let const_value = self\n+            .tcx\n+            .const_eval_global_id_for_typeck(param_env_reveal_all, cid, Some(span))\n+            .map(|val| match val {\n+                Some(valtree) => mir::ConstantKind::Ty(self.tcx.mk_const(valtree, ty)),\n+                None => mir::ConstantKind::Val(\n+                    self.tcx\n+                        .const_eval_global_id(param_env_reveal_all, cid, Some(span))\n+                        .expect(\"const_eval_global_id_for_typeck should have already failed\"),\n+                    ty,\n+                ),\n+            });\n+\n+        match const_value {\n+            Ok(const_) => {\n+                let pattern = self.const_to_pat(const_, id, span, Some(instance.def_id()));\n \n                 if !is_associated_const {\n                     return pattern;\n@@ -577,27 +586,69 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         id: hir::HirId,\n         span: Span,\n     ) -> PatKind<'tcx> {\n-        let value = mir::ConstantKind::from_inline_const(self.tcx, anon_const.def_id);\n-\n-        // Evaluate early like we do in `lower_path`.\n-        let value = value.eval(self.tcx, self.param_env);\n-\n-        match value {\n-            mir::ConstantKind::Ty(c) => match c.kind() {\n-                ConstKind::Param(_) => {\n-                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n-                    return PatKind::Wild;\n-                }\n-                ConstKind::Error(_) => {\n-                    return PatKind::Wild;\n+        let tcx = self.tcx;\n+        let def_id = anon_const.def_id;\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let body_id = match tcx.hir().get(hir_id) {\n+            hir::Node::AnonConst(ac) => ac.body,\n+            _ => span_bug!(\n+                tcx.def_span(def_id.to_def_id()),\n+                \"from_inline_const can only process anonymous constants\"\n+            ),\n+        };\n+        let expr = &tcx.hir().body(body_id).value;\n+        let ty = tcx.typeck(def_id).node_type(hir_id);\n+\n+        // Special case inline consts that are just literals. This is solely\n+        // a performance optimization, as we could also just go through the regular\n+        // const eval path below.\n+        // FIXME: investigate the performance impact of removing this.\n+        let lit_input = match expr.kind {\n+            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n+            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n+                hir::ExprKind::Lit(ref lit) => {\n+                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n                 }\n-                _ => bug!(\"Expected ConstKind::Param\"),\n+                _ => None,\n             },\n-            mir::ConstantKind::Val(_, _) => self.const_to_pat(value, id, span, false).kind,\n-            mir::ConstantKind::Unevaluated(..) => {\n-                // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n-                self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n-                return PatKind::Wild;\n+            _ => None,\n+        };\n+        if let Some(lit_input) = lit_input {\n+            match tcx.at(expr.span).lit_to_const(lit_input) {\n+                Ok(c) => return self.const_to_pat(ConstantKind::Ty(c), id, span, None).kind,\n+                // If an error occurred, ignore that it's a literal\n+                // and leave reporting the error up to const eval of\n+                // the unevaluated constant below.\n+                Err(_) => {}\n+            }\n+        }\n+\n+        let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id());\n+        let parent_substs =\n+            tcx.erase_regions(ty::InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n+        let substs =\n+            ty::InlineConstSubsts::new(tcx, ty::InlineConstSubstsParts { parent_substs, ty })\n+                .substs;\n+\n+        let uneval = mir::UnevaluatedConst { def: def_id.to_def_id(), substs, promoted: None };\n+        debug_assert!(!substs.has_free_regions());\n+\n+        let ct = ty::UnevaluatedConst { def: def_id.to_def_id(), substs: substs };\n+        // First try using a valtree in order to destructure the constant into a pattern.\n+        if let Ok(Some(valtree)) =\n+            self.tcx.const_eval_resolve_for_typeck(self.param_env, ct, Some(span))\n+        {\n+            self.const_to_pat(ConstantKind::Ty(self.tcx.mk_const(valtree, ty)), id, span, None).kind\n+        } else {\n+            // If that fails, convert it to an opaque constant pattern.\n+            match tcx.const_eval_resolve(self.param_env, uneval, None) {\n+                Ok(val) => self.const_to_pat(mir::ConstantKind::Val(val, ty), id, span, None).kind,\n+                Err(ErrorHandled::TooGeneric) => {\n+                    // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n+                    self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n+                    PatKind::Wild\n+                }\n+                Err(ErrorHandled::Reported(_)) => PatKind::Wild,\n             }\n         }\n     }\n@@ -626,8 +677,10 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         let lit_input =\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n-        match self.tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n-            Ok(constant) => self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n+        match self.tcx.at(expr.span).lit_to_const(lit_input) {\n+            Ok(constant) => {\n+                self.const_to_pat(ConstantKind::Ty(constant), expr.hir_id, lit.span, None).kind\n+            }\n             Err(LitToConstError::Reported(_)) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n         }\n@@ -806,6 +859,9 @@ pub(crate) fn compare_const_vals<'tcx>(\n                 mir::ConstantKind::Val(ConstValue::Scalar(Scalar::Int(a)), _a_ty),\n                 mir::ConstantKind::Val(ConstValue::Scalar(Scalar::Int(b)), _b_ty),\n             ) => return Some(a.cmp(&b)),\n+            (mir::ConstantKind::Ty(a), mir::ConstantKind::Ty(b)) => {\n+                return Some(a.kind().cmp(&b.kind()));\n+            }\n             _ => {}\n         },\n     }"}, {"sha": "024bea620982a70c99de5645be1836fed795d180", "filename": "compiler/rustc_mir_transform/src/const_goto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -28,7 +28,7 @@ pub struct ConstGoto;\n \n impl<'tcx> MirPass<'tcx> for ConstGoto {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.mir_opt_level() >= 4\n+        sess.mir_opt_level() >= 2\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "1d43dbda0aae4c8c43d6c824651fafe24d627750", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,6 +4,7 @@\n use either::Right;\n \n use rustc_const_eval::const_eval::CheckAlignment;\n+use rustc_const_eval::ReportErrorExt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n@@ -37,14 +38,25 @@ macro_rules! throw_machine_stop_str {\n     ($($tt:tt)*) => {{\n         // We make a new local type for it. The type itself does not carry any information,\n         // but its vtable (for the `MachineStopType` trait) does.\n+        #[derive(Debug)]\n         struct Zst;\n         // Printing this type shows the desired string.\n         impl std::fmt::Display for Zst {\n             fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                 write!(f, $($tt)*)\n             }\n         }\n-        impl rustc_middle::mir::interpret::MachineStopType for Zst {}\n+\n+        impl rustc_middle::mir::interpret::MachineStopType for Zst {\n+            fn diagnostic_message(&self) -> rustc_errors::DiagnosticMessage {\n+                self.to_string().into()\n+            }\n+\n+            fn add_args(\n+                self: Box<Self>,\n+                _: &mut dyn FnMut(std::borrow::Cow<'static, str>, rustc_errors::DiagnosticArgValue<'static>),\n+            ) {}\n+        }\n         throw_machine_stop!(Zst)\n     }};\n }\n@@ -103,7 +115,14 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         // That would require a uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n         let mut optimization_finder = ConstPropagator::new(body, dummy_body, tcx);\n-        optimization_finder.visit_body(body);\n+\n+        // Traverse the body in reverse post-order, to ensure that `FullConstProp` locals are\n+        // assigned before being read.\n+        let postorder = body.basic_blocks.postorder().to_vec();\n+        for bb in postorder.into_iter().rev() {\n+            let data = &mut body.basic_blocks.as_mut_preserves_cfg()[bb];\n+            optimization_finder.visit_basic_block_data(bb, data);\n+        }\n \n         trace!(\"ConstProp done for {:?}\", def_id);\n     }\n@@ -367,7 +386,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 op\n             }\n             Err(e) => {\n-                trace!(\"get_const failed: {}\", e);\n+                trace!(\"get_const failed: {:?}\", e.into_kind().debug());\n                 return None;\n             }\n         };\n@@ -789,12 +808,6 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.tcx\n     }\n \n-    fn visit_body(&mut self, body: &mut Body<'tcx>) {\n-        for (bb, data) in body.basic_blocks.as_mut_preserves_cfg().iter_enumerated_mut() {\n-            self.visit_basic_block_data(bb, data);\n-        }\n-    }\n-\n     fn visit_operand(&mut self, operand: &mut Operand<'tcx>, location: Location) {\n         self.super_operand(operand, location);\n \n@@ -885,14 +898,23 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 }\n             }\n             StatementKind::StorageLive(local) => {\n-                let frame = self.ecx.frame_mut();\n-                frame.locals[local].value =\n-                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n-            }\n-            StatementKind::StorageDead(local) => {\n-                let frame = self.ecx.frame_mut();\n-                frame.locals[local].value = LocalValue::Dead;\n+                Self::remove_const(&mut self.ecx, local);\n             }\n+            // We do not need to mark dead locals as such. For `FullConstProp` locals,\n+            // this allows to propagate the single assigned value in this case:\n+            // ```\n+            // let x = SOME_CONST;\n+            // if a {\n+            //   f(copy x);\n+            //   StorageDead(x);\n+            // } else {\n+            //   g(copy x);\n+            //   StorageDead(x);\n+            // }\n+            // ```\n+            //\n+            // This may propagate a constant where the local would be uninit or dead.\n+            // In both cases, this does not matter, as those reads would be UB anyway.\n             _ => {}\n         }\n     }"}, {"sha": "759650fe4db3a9d095e15d1030ef09855816c642", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -9,6 +9,7 @@ use rustc_const_eval::interpret::Immediate;\n use rustc_const_eval::interpret::{\n     self, InterpCx, InterpResult, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n };\n+use rustc_const_eval::ReportErrorExt;\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n@@ -232,7 +233,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 op\n             }\n             Err(e) => {\n-                trace!(\"get_const failed: {}\", e);\n+                trace!(\"get_const failed: {:?}\", e.into_kind().debug());\n                 return None;\n             }\n         };\n@@ -272,8 +273,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 // dedicated error variants should be introduced instead.\n                 assert!(\n                     !error.kind().formatted_string(),\n-                    \"const-prop encountered formatting error: {}\",\n-                    error\n+                    \"const-prop encountered formatting error: {error:?}\",\n                 );\n                 None\n             }"}, {"sha": "22f71bb08516c0a2b43a57e2e0565efbe1a05e44", "filename": "compiler/rustc_mir_transform/src/errors.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -163,7 +163,14 @@ impl<'a, P: std::fmt::Debug> DecorateLint<'a, ()> for AssertLint<P> {\n         self,\n         diag: &'b mut DiagnosticBuilder<'a, ()>,\n     ) -> &'b mut DiagnosticBuilder<'a, ()> {\n-        diag.span_label(self.span(), format!(\"{:?}\", self.panic()));\n+        let span = self.span();\n+        let assert_kind = self.panic();\n+        let message = assert_kind.diagnostic_message();\n+        assert_kind.add_args(&mut |name, value| {\n+            diag.set_arg(name, value);\n+        });\n+        diag.span_label(span, message);\n+\n         diag\n     }\n \n@@ -191,7 +198,7 @@ impl<P> AssertLint<P> {\n             AssertLint::ArithmeticOverflow(sp, _) | AssertLint::UnconditionalPanic(sp, _) => *sp,\n         }\n     }\n-    pub fn panic(&self) -> &AssertKind<P> {\n+    pub fn panic(self) -> AssertKind<P> {\n         match self {\n             AssertLint::ArithmeticOverflow(_, p) | AssertLint::UnconditionalPanic(_, p) => p,\n         }"}, {"sha": "7d9f6c38e36a40741360e78efa15699dbd392a76", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -559,10 +559,13 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             // inst combine is after MatchBranchSimplification to clean up Ne(_1, false)\n             &multiple_return_terminators::MultipleReturnTerminators,\n             &instsimplify::InstSimplify,\n-            &separate_const_switch::SeparateConstSwitch,\n             &simplify::SimplifyLocals::BeforeConstProp,\n             &copy_prop::CopyProp,\n             &ref_prop::ReferencePropagation,\n+            // Perform `SeparateConstSwitch` after SSA-based analyses, as cloning blocks may\n+            // destroy the SSA property. It should still happen before const-propagation, so the\n+            // latter pass will leverage the created opportunities.\n+            &separate_const_switch::SeparateConstSwitch,\n             &const_prop::ConstProp,\n             &dataflow_const_prop::DataflowConstProp,\n             //"}, {"sha": "243cb463560e4e32246e08db42ff25373976b9e1", "filename": "compiler/rustc_mir_transform/src/required_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -17,8 +17,8 @@ impl<'tcx> Visitor<'tcx> for RequiredConstsVisitor<'_, 'tcx> {\n         let literal = constant.literal;\n         match literal {\n             ConstantKind::Ty(c) => match c.kind() {\n-                ConstKind::Param(_) | ConstKind::Error(_) => {}\n-                _ => bug!(\"only ConstKind::Param should be encountered here, got {:#?}\", c),\n+                ConstKind::Param(_) | ConstKind::Error(_) | ConstKind::Value(_) => {}\n+                _ => bug!(\"only ConstKind::Param/Value should be encountered here, got {:#?}\", c),\n             },\n             ConstantKind::Unevaluated(..) => self.required_consts.push(*constant),\n             ConstantKind::Val(..) => {}"}, {"sha": "f35a5fb42768aca30a85a0758ea13f6f0bae5a0f", "filename": "compiler/rustc_mir_transform/src/separate_const_switch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fseparate_const_switch.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -46,7 +46,7 @@ pub struct SeparateConstSwitch;\n \n impl<'tcx> MirPass<'tcx> for SeparateConstSwitch {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.mir_opt_level() >= 4\n+        sess.mir_opt_level() >= 2\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {"}, {"sha": "e4b3b8b926213a42a5f5e387e85a75f846756445", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -6,23 +6,29 @@ use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{excluded_locals, iter_fields};\n-use rustc_target::abi::FieldIdx;\n+use rustc_target::abi::{FieldIdx, ReprFlags, FIRST_VARIANT};\n \n pub struct ScalarReplacementOfAggregates;\n \n impl<'tcx> MirPass<'tcx> for ScalarReplacementOfAggregates {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        sess.mir_opt_level() >= 3\n+        sess.mir_opt_level() >= 2\n     }\n \n     #[instrument(level = \"debug\", skip(self, tcx, body))]\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         debug!(def_id = ?body.source.def_id());\n+\n+        // Avoid query cycles (generators require optimized MIR for layout).\n+        if tcx.type_of(body.source.def_id()).subst_identity().is_generator() {\n+            return;\n+        }\n+\n         let mut excluded = excluded_locals(body);\n         let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n         loop {\n             debug!(?excluded);\n-            let escaping = escaping_locals(&excluded, body);\n+            let escaping = escaping_locals(tcx, param_env, &excluded, body);\n             debug!(?escaping);\n             let replacements = compute_flattening(tcx, param_env, body, escaping);\n             debug!(?replacements);\n@@ -48,11 +54,45 @@ impl<'tcx> MirPass<'tcx> for ScalarReplacementOfAggregates {\n /// - the locals is a union or an enum;\n /// - the local's address is taken, and thus the relative addresses of the fields are observable to\n ///   client code.\n-fn escaping_locals(excluded: &BitSet<Local>, body: &Body<'_>) -> BitSet<Local> {\n+fn escaping_locals<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    excluded: &BitSet<Local>,\n+    body: &Body<'tcx>,\n+) -> BitSet<Local> {\n+    let is_excluded_ty = |ty: Ty<'tcx>| {\n+        if ty.is_union() || ty.is_enum() {\n+            return true;\n+        }\n+        if let ty::Adt(def, _substs) = ty.kind() {\n+            if def.repr().flags.contains(ReprFlags::IS_SIMD) {\n+                // Exclude #[repr(simd)] types so that they are not de-optimized into an array\n+                return true;\n+            }\n+            // We already excluded unions and enums, so this ADT must have one variant\n+            let variant = def.variant(FIRST_VARIANT);\n+            if variant.fields.len() > 1 {\n+                // If this has more than one field, it cannot be a wrapper that only provides a\n+                // niche, so we do not want to automatically exclude it.\n+                return false;\n+            }\n+            let Ok(layout) = tcx.layout_of(param_env.and(ty)) else {\n+                // We can't get the layout\n+                return true;\n+            };\n+            if layout.layout.largest_niche().is_some() {\n+                // This type has a niche\n+                return true;\n+            }\n+        }\n+        // Default for non-ADTs\n+        false\n+    };\n+\n     let mut set = BitSet::new_empty(body.local_decls.len());\n     set.insert_range(RETURN_PLACE..=Local::from_usize(body.arg_count));\n     for (local, decl) in body.local_decls().iter_enumerated() {\n-        if decl.ty.is_union() || decl.ty.is_enum() || excluded.contains(local) {\n+        if excluded.contains(local) || is_excluded_ty(decl.ty) {\n             set.insert(local);\n         }\n     }"}, {"sha": "09025c1ee3319fe2f07d1fde2a1cb208da233db5", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 13, "deletions": 63, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -179,7 +179,6 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::mir::interpret::{AllocId, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, GlobalAlloc, Scalar};\n use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n@@ -220,78 +219,29 @@ pub struct InliningMap<'tcx> {\n     // The range selects elements within the `targets` vecs.\n     index: FxHashMap<MonoItem<'tcx>, Range<usize>>,\n     targets: Vec<MonoItem<'tcx>>,\n-\n-    // Contains one bit per mono item in the `targets` field. That bit\n-    // is true if that mono item needs to be inlined into every CGU.\n-    inlines: GrowableBitSet<usize>,\n-}\n-\n-/// Struct to store mono items in each collecting and if they should\n-/// be inlined. We call `instantiation_mode` to get their inlining\n-/// status when inserting new elements, which avoids calling it in\n-/// `inlining_map.lock_mut()`. See the `collect_items_rec` implementation\n-/// below.\n-struct MonoItems<'tcx> {\n-    // If this is false, we do not need to compute whether items\n-    // will need to be inlined.\n-    compute_inlining: bool,\n-\n-    // The TyCtxt used to determine whether the a item should\n-    // be inlined.\n-    tcx: TyCtxt<'tcx>,\n-\n-    // The collected mono items. The bool field in each element\n-    // indicates whether this element should be inlined.\n-    items: Vec<(Spanned<MonoItem<'tcx>>, bool /*inlined*/)>,\n }\n \n-impl<'tcx> MonoItems<'tcx> {\n-    #[inline]\n-    fn push(&mut self, item: Spanned<MonoItem<'tcx>>) {\n-        self.extend([item]);\n-    }\n-\n-    #[inline]\n-    fn extend<T: IntoIterator<Item = Spanned<MonoItem<'tcx>>>>(&mut self, iter: T) {\n-        self.items.extend(iter.into_iter().map(|mono_item| {\n-            let inlined = if !self.compute_inlining {\n-                false\n-            } else {\n-                mono_item.node.instantiation_mode(self.tcx) == InstantiationMode::LocalCopy\n-            };\n-            (mono_item, inlined)\n-        }))\n-    }\n-}\n+type MonoItems<'tcx> = Vec<Spanned<MonoItem<'tcx>>>;\n \n impl<'tcx> InliningMap<'tcx> {\n     fn new() -> InliningMap<'tcx> {\n-        InliningMap {\n-            index: FxHashMap::default(),\n-            targets: Vec::new(),\n-            inlines: GrowableBitSet::with_capacity(1024),\n-        }\n+        InliningMap { index: FxHashMap::default(), targets: Vec::new() }\n     }\n \n     fn record_accesses<'a>(\n         &mut self,\n         source: MonoItem<'tcx>,\n-        new_targets: &'a [(Spanned<MonoItem<'tcx>>, bool)],\n+        new_targets: &'a [Spanned<MonoItem<'tcx>>],\n     ) where\n         'tcx: 'a,\n     {\n         let start_index = self.targets.len();\n         let new_items_count = new_targets.len();\n-        let new_items_count_total = new_items_count + self.targets.len();\n \n         self.targets.reserve(new_items_count);\n-        self.inlines.ensure(new_items_count_total);\n \n-        for (i, (Spanned { node: mono_item, .. }, inlined)) in new_targets.into_iter().enumerate() {\n+        for Spanned { node: mono_item, .. } in new_targets.into_iter() {\n             self.targets.push(*mono_item);\n-            if *inlined {\n-                self.inlines.insert(i + start_index);\n-            }\n         }\n \n         let end_index = self.targets.len();\n@@ -300,13 +250,14 @@ impl<'tcx> InliningMap<'tcx> {\n \n     /// Internally iterate over all items referenced by `source` which will be\n     /// made available for inlining.\n-    pub fn with_inlining_candidates<F>(&self, source: MonoItem<'tcx>, mut f: F)\n+    pub fn with_inlining_candidates<F>(&self, tcx: TyCtxt<'tcx>, source: MonoItem<'tcx>, mut f: F)\n     where\n         F: FnMut(MonoItem<'tcx>),\n     {\n         if let Some(range) = self.index.get(&source) {\n-            for (i, candidate) in self.targets[range.clone()].iter().enumerate() {\n-                if self.inlines.contains(range.start + i) {\n+            for candidate in self.targets[range.clone()].iter() {\n+                let is_inlined = candidate.instantiation_mode(tcx) == InstantiationMode::LocalCopy;\n+                if is_inlined {\n                     f(*candidate);\n                 }\n             }\n@@ -367,7 +318,7 @@ pub fn collect_crate_mono_items(\n #[instrument(skip(tcx, mode), level = \"debug\")]\n fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'_>> {\n     debug!(\"collecting roots\");\n-    let mut roots = MonoItems { compute_inlining: false, tcx, items: Vec::new() };\n+    let mut roots = Vec::new();\n \n     {\n         let entry_fn = tcx.entry_fn(());\n@@ -393,9 +344,8 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n     // whose predicates hold. Luckily, items that aren't instantiable\n     // can't actually be used, so we can just skip codegenning them.\n     roots\n-        .items\n         .into_iter()\n-        .filter_map(|(Spanned { node: mono_item, .. }, _)| {\n+        .filter_map(|Spanned { node: mono_item, .. }| {\n             mono_item.is_instantiable(tcx).then_some(mono_item)\n         })\n         .collect()\n@@ -417,7 +367,7 @@ fn collect_items_rec<'tcx>(\n         return;\n     }\n \n-    let mut neighbors = MonoItems { compute_inlining: true, tcx, items: Vec::new() };\n+    let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n     //\n@@ -542,9 +492,9 @@ fn collect_items_rec<'tcx>(\n             formatted_item,\n         });\n     }\n-    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors.items);\n+    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors);\n \n-    for (neighbour, _) in neighbors.items {\n+    for neighbour in neighbors {\n         collect_items_rec(tcx, neighbour, visited, recursion_depths, recursion_limit, inlining_map);\n     }\n "}, {"sha": "015361f8ad5b71d18061e65a13c3d73f44b558a0", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -426,7 +426,7 @@ fn place_inlined_mono_items<'tcx>(\n         // Collect all items that need to be available in this codegen unit.\n         let mut reachable = FxHashSet::default();\n         for root in old_codegen_unit.items().keys() {\n-            follow_inlining(*root, cx.inlining_map, &mut reachable);\n+            follow_inlining(cx.tcx, *root, cx.inlining_map, &mut reachable);\n         }\n \n         let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n@@ -480,6 +480,7 @@ fn place_inlined_mono_items<'tcx>(\n     return mono_item_placements;\n \n     fn follow_inlining<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n         mono_item: MonoItem<'tcx>,\n         inlining_map: &InliningMap<'tcx>,\n         visited: &mut FxHashSet<MonoItem<'tcx>>,\n@@ -488,8 +489,8 @@ fn place_inlined_mono_items<'tcx>(\n             return;\n         }\n \n-        inlining_map.with_inlining_candidates(mono_item, |target| {\n-            follow_inlining(target, inlining_map, visited);\n+        inlining_map.with_inlining_candidates(tcx, mono_item, |target| {\n+            follow_inlining(tcx, target, inlining_map, visited);\n         });\n     }\n }"}, {"sha": "9971bdf45bbf3325b8ceaf2f352f40b170294e83", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -93,7 +93,7 @@ fn dump_layout_of(tcx: TyCtxt<'_>, item_def_id: LocalDefId, attr: &Attribute) {\n \n         Err(layout_error) => {\n             tcx.sess.emit_fatal(Spanned {\n-                node: layout_error,\n+                node: layout_error.into_diagnostic(),\n                 span: tcx.def_span(item_def_id.to_def_id()),\n             });\n         }\n@@ -109,12 +109,7 @@ impl<'tcx> LayoutOfHelpers<'tcx> for UnwrapLayoutCx<'tcx> {\n     type LayoutOfResult = TyAndLayout<'tcx>;\n \n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n-        span_bug!(\n-            span,\n-            \"`#[rustc_layout(..)]` test resulted in `layout_of({}) = Err({})`\",\n-            ty,\n-            err\n-        );\n+        span_bug!(span, \"`#[rustc_layout(..)]` test resulted in `layout_of({ty}) = Err({err})`\",);\n     }\n }\n "}, {"sha": "a433e2371c9d4c4d6db56792357fe90fb2c375de", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -84,6 +84,7 @@ impl SymbolGallery {\n \n /// Construct a diagnostic for a language feature error due to the given `span`.\n /// The `feature`'s `Symbol` is the one you used in `active.rs` and `rustc_span::symbols`.\n+#[track_caller]\n pub fn feature_err(\n     sess: &ParseSess,\n     feature: Symbol,"}, {"sha": "2ebd83540ee15b1e46e9ccfa3a1deed41fdc62ff", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -128,8 +128,6 @@ pub struct Limits {\n     pub move_size_limit: Limit,\n     /// The maximum length of types during monomorphization.\n     pub type_length_limit: Limit,\n-    /// The maximum blocks a const expression can evaluate.\n-    pub const_eval_limit: Limit,\n }\n \n pub struct CompilerIO {"}, {"sha": "0c7e36b3bef740052d5cdf05e8971365cc84f6e1", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1288,7 +1288,7 @@ pub fn decode_expn_id(\n     decode_data: impl FnOnce(ExpnId) -> (ExpnData, ExpnHash),\n ) -> ExpnId {\n     if index == 0 {\n-        debug!(\"decode_expn_id: deserialized root\");\n+        trace!(\"decode_expn_id: deserialized root\");\n         return ExpnId::root();\n     }\n \n@@ -1321,7 +1321,7 @@ pub fn decode_syntax_context<D: Decoder, F: FnOnce(&mut D, u32) -> SyntaxContext\n ) -> SyntaxContext {\n     let raw_id: u32 = Decodable::decode(d);\n     if raw_id == 0 {\n-        debug!(\"decode_syntax_context: deserialized root\");\n+        trace!(\"decode_syntax_context: deserialized root\");\n         // The root is special\n         return SyntaxContext::root();\n     }"}, {"sha": "2f002e424277edafa944b2daf772adc3ae6f4aa6", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1146,6 +1146,8 @@ symbols! {\n         profiler_builtins,\n         profiler_runtime,\n         ptr,\n+        ptr_cast_mut,\n+        ptr_from_ref,\n         ptr_guaranteed_cmp,\n         ptr_mask,\n         ptr_null,"}, {"sha": "a1cb317c50ea6996bfc3a371f08c0de19288e8a5", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -501,7 +501,15 @@ fn encode_ty<'tcx>(\n         ty::Array(ty0, len) => {\n             // A<array-length><element-type>\n             let mut s = String::from(\"A\");\n-            let _ = write!(s, \"{}\", &len.kind().try_to_scalar().unwrap().to_u64().unwrap());\n+            let _ = write!(\n+                s,\n+                \"{}\",\n+                &len.kind()\n+                    .try_to_scalar()\n+                    .unwrap()\n+                    .to_u64()\n+                    .unwrap_or_else(|_| panic!(\"failed to convert length to u64\"))\n+            );\n             s.push_str(&encode_ty(tcx, *ty0, dict, options));\n             compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n             typeid.push_str(&s);\n@@ -786,7 +794,12 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n         }\n \n         ty::Array(ty0, len) => {\n-            let len = len.kind().try_to_scalar().unwrap().to_u64().unwrap();\n+            let len = len\n+                .kind()\n+                .try_to_scalar()\n+                .unwrap()\n+                .to_u64()\n+                .unwrap_or_else(|_| panic!(\"failed to convert length to u64\"));\n             ty = tcx.mk_array(transform_ty(tcx, *ty0, options), len);\n         }\n "}, {"sha": "c4abf6f4b5e4941a38cd81ac116150a485cf26a5", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -2,7 +2,6 @@ use crate::abi::{self, Abi, Align, FieldsShape, Size};\n use crate::abi::{HasDataLayout, TyAbiInterface, TyAndLayout};\n use crate::spec::{self, HasTargetSpec};\n use rustc_span::Symbol;\n-use std::fmt;\n use std::str::FromStr;\n \n mod aarch64;\n@@ -633,16 +632,6 @@ pub enum AdjustForForeignAbiError {\n     Unsupported { arch: Symbol, abi: spec::abi::Abi },\n }\n \n-impl fmt::Display for AdjustForForeignAbiError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::Unsupported { arch, abi } => {\n-                write!(f, \"target architecture {arch:?} does not support `extern {abi}` ABI\")\n-            }\n-        }\n-    }\n-}\n-\n impl<'a, Ty> FnAbi<'a, Ty> {\n     pub fn adjust_for_foreign_abi<C>(\n         &mut self,"}, {"sha": "b9df0046b12bafb9c3d07306ac701789f836123e", "filename": "compiler/rustc_target/src/spec/mips64_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -12,7 +12,7 @@ pub fn target() -> Target {\n             endian: Endian::Big,\n             // NOTE(mips64r2) matches C toolchain\n             cpu: \"mips64r2\".into(),\n-            features: \"+mips64r2\".into(),\n+            features: \"+mips64r2,+xgot\".into(),\n             max_atomic_width: Some(64),\n             mcount: \"_mcount\".into(),\n "}, {"sha": "57ad8c47399b3cacef97d7c4fffdfe4ece82f936", "filename": "compiler/rustc_target/src/spec/mips64el_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -10,7 +10,7 @@ pub fn target() -> Target {\n             abi: \"abi64\".into(),\n             // NOTE(mips64r2) matches C toolchain\n             cpu: \"mips64r2\".into(),\n-            features: \"+mips64r2\".into(),\n+            features: \"+mips64r2,+xgot\".into(),\n             max_atomic_width: Some(64),\n             mcount: \"_mcount\".into(),\n "}, {"sha": "1470dc452a18d24e8acc180859fab56fe6f9ed6b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1776,6 +1776,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     || !trait_pred\n                         .skip_binder()\n                         .is_constness_satisfied_by(self.tcx.constness(def_id))\n+                    || !self.tcx.is_user_visible_dep(def_id.krate)\n                 {\n                     return None;\n                 }"}, {"sha": "048302187cf9f656052292f70bfd23b6c300ed63", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -526,7 +526,7 @@ fn virtual_call_violation_for_method<'tcx>(\n                         // #78372\n                         tcx.sess.delay_span_bug(\n                             tcx.def_span(method.def_id),\n-                            format!(\"error: {}\\n while computing layout for type {:?}\", err, ty),\n+                            format!(\"error: {err}\\n while computing layout for type {ty:?}\"),\n                         );\n                         None\n                     }"}, {"sha": "8c4f6a73d7fea3edf07dd1775f062f7b14aca16b", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -38,7 +38,6 @@ extern \"Rust\" {\n     #[rustc_nounwind]\n     fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n \n-    #[cfg(not(bootstrap))]\n     static __rust_no_alloc_shim_is_unstable: u8;\n }\n \n@@ -96,7 +95,6 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n     unsafe {\n         // Make sure we don't accidentally allow omitting the allocator shim in\n         // stable code until it is actually stabilized.\n-        #[cfg(not(bootstrap))]\n         core::ptr::read_volatile(&__rust_no_alloc_shim_is_unstable);\n \n         __rust_alloc(layout.size(), layout.align())"}, {"sha": "59e3f887b523225948bdd3f14074c7cd19edf5c0", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -2624,7 +2624,7 @@ impl ToString for String {\n }\n \n #[cfg(not(no_global_oom_handling))]\n-#[stable(feature = \"fmt_arguments_to_string_specialization\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"fmt_arguments_to_string_specialization\", since = \"1.71.0\")]\n impl ToString for fmt::Arguments<'_> {\n     #[inline]\n     fn to_string(&self) -> String {"}, {"sha": "799085e9a8307cef532c6169ea1cb4a449dad14a", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -495,8 +495,7 @@ pub trait Into<T>: Sized {\n /// By converting underlying error types to our own custom error type that encapsulates the\n /// underlying error type, we can return a single error type without losing information on the\n /// underlying cause. The '?' operator automatically converts the underlying error type to our\n-/// custom error type by calling `Into<CliError>::into` which is automatically provided when\n-/// implementing `From`. The compiler then infers which implementation of `Into` should be used.\n+/// custom error type with `From::from`.\n ///\n /// ```\n /// use std::fs;"}, {"sha": "50c7516b7fe8dd5464724d5567706b21b17b45a6", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -81,7 +81,7 @@ use crate::str;\n #[derive(Hash)]\n #[stable(feature = \"core_c_str\", since = \"1.64.0\")]\n #[rustc_has_incoherent_inherent_impls]\n-#[cfg_attr(not(bootstrap), lang = \"CStr\")]\n+#[lang = \"CStr\"]\n // FIXME:\n // `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n // on `CStr` being layout-compatible with `[u8]`.\n@@ -531,8 +531,8 @@ impl CStr {\n     /// # }\n     /// ```\n     #[inline]\n-    #[stable(feature = \"cstr_is_empty\", since = \"CURRENT_RUSTC_VERSION\")]\n-    #[rustc_const_stable(feature = \"cstr_is_empty\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"cstr_is_empty\", since = \"1.71.0\")]\n+    #[rustc_const_stable(feature = \"cstr_is_empty\", since = \"1.71.0\")]\n     pub const fn is_empty(&self) -> bool {\n         // SAFETY: We know there is at least one byte; for empty strings it\n         // is the NUL terminator."}, {"sha": "86ea154a8868ea730b6962d1fa7e1df6fbd06fa9", "filename": "library/core/src/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -202,7 +202,7 @@ mod c_long_definition {\n //     would be uninhabited and at least dereferencing such pointers would\n //     be UB.\n #[doc = include_str!(\"c_void.md\")]\n-#[cfg_attr(not(bootstrap), lang = \"c_void\")]\n+#[lang = \"c_void\"]\n #[cfg_attr(not(doc), repr(u8))] // work around https://github.com/rust-lang/rust/issues/90435\n #[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub enum c_void {"}, {"sha": "794a57f09226c035c50fda5d4f157b94f029ca60", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -695,7 +695,7 @@ pub trait BuildHasher {\n     ///     bh.hash_one(&OrderAmbivalentPair(2, 10))\n     /// );\n     /// ```\n-    #[stable(feature = \"build_hasher_simple_hash_one\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[stable(feature = \"build_hasher_simple_hash_one\", since = \"1.71.0\")]\n     fn hash_one<T: Hash>(&self, x: T) -> u64\n     where\n         Self: Sized,"}, {"sha": "6dca1fe1e69615600d11788dc8ab382411155378", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1385,7 +1385,6 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This is not expected to ever be exposed directly to users, rather it\n     /// may eventually be exposed through some more-constrained API.\n-    #[cfg(not(bootstrap))]\n     #[rustc_const_stable(feature = \"const_transmute\", since = \"1.56.0\")]\n     #[rustc_nounwind]\n     pub fn transmute_unchecked<Src, Dst>(src: Src) -> Dst;\n@@ -1425,19 +1424,11 @@ extern \"rust-intrinsic\" {\n     /// returned value will result in undefined behavior.\n     ///\n     /// The stabilized version of this intrinsic is [`pointer::offset`].\n-    #[cfg(not(bootstrap))]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n     #[rustc_nounwind]\n     pub fn offset<Ptr, Delta>(dst: Ptr, offset: Delta) -> Ptr;\n \n-    /// The bootstrap version of this is more restricted.\n-    #[cfg(bootstrap)]\n-    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n-    #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n-    #[rustc_nounwind]\n-    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n-\n     /// Calculates the offset from a pointer, potentially wrapping.\n     ///\n     /// This is implemented as an intrinsic to avoid converting to and from an\n@@ -2260,7 +2251,7 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic can *only* be called where the pointer is a local without\n     /// projections (`read_via_copy(ptr)`, not `read_via_copy(*ptr)`) so that it\n     /// trivially obeys runtime-MIR rules about derefs in operands.\n-    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"1.71.0\")]\n     #[rustc_nounwind]\n     pub fn read_via_copy<T>(ptr: *const T) -> T;\n \n@@ -2270,7 +2261,6 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic can *only* be called where the pointer is a local without\n     /// projections (`write_via_move(ptr, x)`, not `write_via_move(*ptr, x)`) so\n     /// that it trivially obeys runtime-MIR rules about derefs in operands.\n-    #[cfg(not(bootstrap))]\n     #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n     #[rustc_nounwind]\n     pub fn write_via_move<T>(ptr: *mut T, value: T);\n@@ -2832,24 +2822,3 @@ pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n         write_bytes(dst, val, count)\n     }\n }\n-\n-/// Polyfill for bootstrap\n-#[cfg(bootstrap)]\n-pub const unsafe fn transmute_unchecked<Src, Dst>(src: Src) -> Dst {\n-    use crate::mem::*;\n-    // SAFETY: It's a transmute -- the caller promised it's fine.\n-    unsafe { transmute_copy(&ManuallyDrop::new(src)) }\n-}\n-\n-/// Polyfill for bootstrap\n-#[cfg(bootstrap)]\n-pub const unsafe fn write_via_move<T>(ptr: *mut T, value: T) {\n-    use crate::mem::*;\n-    // SAFETY: the caller must guarantee that `dst` is valid for writes.\n-    // `dst` cannot overlap `src` because the caller has mutable access\n-    // to `dst` while `src` is owned by this function.\n-    unsafe {\n-        copy_nonoverlapping::<T>(&value, ptr, 1);\n-        forget(value);\n-    }\n-}"}, {"sha": "2d2d5d491758874f127817bf2c1d64f5a3bb1751", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -971,15 +971,14 @@ pub trait Tuple {}\n pub trait PointerLike {}\n \n /// A marker for types which can be used as types of `const` generic parameters.\n-#[cfg_attr(not(bootstrap), lang = \"const_param_ty\")]\n+#[lang = \"const_param_ty\"]\n #[unstable(feature = \"adt_const_params\", issue = \"95174\")]\n #[rustc_on_unimplemented(message = \"`{Self}` can't be used as a const parameter type\")]\n pub trait ConstParamTy: StructuralEq {}\n \n /// Derive macro generating an impl of the trait `ConstParamTy`.\n #[rustc_builtin_macro]\n #[unstable(feature = \"adt_const_params\", issue = \"95174\")]\n-#[cfg(not(bootstrap))]\n pub macro ConstParamTy($item:item) {\n     /* compiler built-in */\n }"}, {"sha": "39c9a04eea92b36e3bbe6fcfce4554f71188023e", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -968,7 +968,7 @@ pub const fn replace<T>(dest: &mut T, src: T) -> T {\n /// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n ///\n /// ```\n-/// # #![cfg_attr(not(bootstrap), allow(dropping_copy_types))]\n+/// # #![allow(dropping_copy_types)]\n /// #[derive(Copy, Clone)]\n /// struct Foo(u8);\n ///\n@@ -1316,7 +1316,6 @@ impl<T> SizedTypeProperties for T {}\n ///\n /// assert_eq!(mem::offset_of!(NestedA, b.0), 0);\n /// ```\n-#[cfg(not(bootstrap))]\n #[unstable(feature = \"offset_of\", issue = \"106655\")]\n #[allow_internal_unstable(builtin_syntax)]\n pub macro offset_of($Container:ty, $($fields:tt).+ $(,)?) {"}, {"sha": "7f06e170ad0f022d763e1b7434122f3919db0ce4", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -769,8 +769,8 @@ macro_rules! nonzero_signed_operations {\n                 /// ```\n                 #[must_use]\n                 #[inline]\n-                #[stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n+                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n                 pub const fn is_positive(self) -> bool {\n                     self.get().is_positive()\n                 }\n@@ -794,8 +794,8 @@ macro_rules! nonzero_signed_operations {\n                 /// ```\n                 #[must_use]\n                 #[inline]\n-                #[stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n+                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n                 pub const fn is_negative(self) -> bool {\n                     self.get().is_negative()\n                 }\n@@ -819,8 +819,8 @@ macro_rules! nonzero_signed_operations {\n                 /// # }\n                 /// ```\n                 #[inline]\n-                #[stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n+                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n                 pub const fn checked_neg(self) -> Option<$Ty> {\n                     if let Some(result) = self.get().checked_neg() {\n                         // SAFETY: negation of nonzero cannot yield zero values.\n@@ -851,8 +851,8 @@ macro_rules! nonzero_signed_operations {\n                 /// # }\n                 /// ```\n                 #[inline]\n-                #[stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n+                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n                 pub const fn overflowing_neg(self) -> ($Ty, bool) {\n                     let (result, overflow) = self.get().overflowing_neg();\n                     // SAFETY: negation of nonzero cannot yield zero values.\n@@ -884,8 +884,8 @@ macro_rules! nonzero_signed_operations {\n                 /// # }\n                 /// ```\n                 #[inline]\n-                #[stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n+                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n                 pub const fn saturating_neg(self) -> $Ty {\n                     if let Some(result) = self.checked_neg() {\n                         return result;\n@@ -916,16 +916,16 @@ macro_rules! nonzero_signed_operations {\n                 /// # }\n                 /// ```\n                 #[inline]\n-                #[stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n-                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n+                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n                 pub const fn wrapping_neg(self) -> $Ty {\n                     let result = self.get().wrapping_neg();\n                     // SAFETY: negation of nonzero cannot yield zero values.\n                     unsafe { $Ty::new_unchecked(result) }\n                 }\n             }\n \n-            #[stable(feature = \"signed_nonzero_neg\", since = \"CURRENT_RUSTC_VERSION\")]\n+            #[stable(feature = \"signed_nonzero_neg\", since = \"1.71.0\")]\n             impl Neg for $Ty {\n                 type Output = $Ty;\n \n@@ -937,7 +937,7 @@ macro_rules! nonzero_signed_operations {\n             }\n \n             forward_ref_unop! { impl Neg, neg for $Ty,\n-                #[stable(feature = \"signed_nonzero_neg\", since = \"CURRENT_RUSTC_VERSION\")] }\n+                #[stable(feature = \"signed_nonzero_neg\", since = \"1.71.0\")] }\n         )+\n     }\n }"}, {"sha": "926189a17b2046ee44961188f7f3847465b5ed0c", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -104,6 +104,7 @@ impl<T: ?Sized> *const T {\n     /// refactored.\n     #[stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     #[rustc_const_stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n+    #[rustc_diagnostic_item = \"ptr_cast_mut\"]\n     #[inline(always)]\n     pub const fn cast_mut(self) -> *mut T {\n         self as _\n@@ -916,16 +917,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        #[cfg(bootstrap)]\n         // SAFETY: the caller must uphold the safety contract for `offset`.\n-        unsafe {\n-            self.offset(count as isize)\n-        }\n-        #[cfg(not(bootstrap))]\n-        // SAFETY: the caller must uphold the safety contract for `offset`.\n-        unsafe {\n-            intrinsics::offset(self, count)\n-        }\n+        unsafe { intrinsics::offset(self, count) }\n     }\n \n     /// Calculates the offset from a pointer in bytes (convenience for `.byte_offset(count as isize)`).\n@@ -1195,7 +1188,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// [`ptr::read`]: crate::ptr::read()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"1.71.0\")]\n     #[inline]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read(self) -> T\n@@ -1236,7 +1229,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// [`ptr::read_unaligned`]: crate::ptr::read_unaligned()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"1.71.0\")]\n     #[inline]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read_unaligned(self) -> T"}, {"sha": "acc9ca29d41a10feac582bfdb6e1ab76ac7c6e1f", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -698,6 +698,7 @@ where\n #[inline(always)]\n #[must_use]\n #[unstable(feature = \"ptr_from_ref\", issue = \"106116\")]\n+#[rustc_diagnostic_item = \"ptr_from_ref\"]\n pub const fn from_ref<T: ?Sized>(r: &T) -> *const T {\n     r\n }\n@@ -1139,7 +1140,7 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n /// [valid]: self#safety\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[rustc_const_stable(feature = \"const_ptr_read\", since = \"1.71.0\")]\n #[rustc_allow_const_fn_unstable(const_mut_refs, const_maybe_uninit_as_mut_ptr)]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn read<T>(src: *const T) -> T {\n@@ -1256,7 +1257,7 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n /// ```\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n-#[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[rustc_const_stable(feature = \"const_ptr_read\", since = \"1.71.0\")]\n #[rustc_allow_const_fn_unstable(const_mut_refs, const_maybe_uninit_as_mut_ptr)]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn read_unaligned<T>(src: *const T) -> T {"}, {"sha": "c6f43857887c96e02e71bc25caea546a07a6673d", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -473,20 +473,10 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        #[cfg(bootstrap)]\n         // SAFETY: the caller must uphold the safety contract for `offset`.\n         // The obtained pointer is valid for writes since the caller must\n         // guarantee that it points to the same allocated object as `self`.\n-        unsafe {\n-            intrinsics::offset(self, count) as *mut T\n-        }\n-        #[cfg(not(bootstrap))]\n-        // SAFETY: the caller must uphold the safety contract for `offset`.\n-        // The obtained pointer is valid for writes since the caller must\n-        // guarantee that it points to the same allocated object as `self`.\n-        unsafe {\n-            intrinsics::offset(self, count)\n-        }\n+        unsafe { intrinsics::offset(self, count) }\n     }\n \n     /// Calculates the offset from a pointer in bytes.\n@@ -1026,16 +1016,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        #[cfg(bootstrap)]\n-        // SAFETY: the caller must uphold the safety contract for `offset`.\n-        unsafe {\n-            self.offset(count as isize)\n-        }\n-        #[cfg(not(bootstrap))]\n         // SAFETY: the caller must uphold the safety contract for `offset`.\n-        unsafe {\n-            intrinsics::offset(self, count)\n-        }\n+        unsafe { intrinsics::offset(self, count) }\n     }\n \n     /// Calculates the offset from a pointer in bytes (convenience for `.byte_offset(count as isize)`).\n@@ -1305,7 +1287,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// [`ptr::read`]: crate::ptr::read()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"1.71.0\")]\n     #[inline(always)]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read(self) -> T\n@@ -1346,7 +1328,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// [`ptr::read_unaligned`]: crate::ptr::read_unaligned()\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n-    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_ptr_read\", since = \"1.71.0\")]\n     #[inline(always)]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub const unsafe fn read_unaligned(self) -> T"}, {"sha": "c87af35fbc44972314bd69f2875ddc3acb954233", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1854,7 +1854,7 @@ impl<T> [T] {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_slice_split_at_not_mut\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_stable(feature = \"const_slice_split_at_not_mut\", since = \"1.71.0\")]\n     #[rustc_allow_const_fn_unstable(slice_split_at_unchecked)]\n     #[inline]\n     #[track_caller]"}, {"sha": "a1388dfeee643cd2e87b2fde1987d812018aa4da", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -100,7 +100,7 @@ macro_rules! tuple_impls {\n             }\n         }\n \n-        #[stable(feature = \"array_tuple_conv\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"array_tuple_conv\", since = \"1.71.0\")]\n         impl<T> From<[T; ${count(T)}]> for ($(${ignore(T)} T,)+) {\n             #[inline]\n             #[allow(non_snake_case)]\n@@ -110,7 +110,7 @@ macro_rules! tuple_impls {\n             }\n         }\n \n-        #[stable(feature = \"array_tuple_conv\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[stable(feature = \"array_tuple_conv\", since = \"1.71.0\")]\n         impl<T> From<($(${ignore(T)} T,)+)> for [T; ${count(T)}] {\n             #[inline]\n             #[allow(non_snake_case)]"}, {"sha": "64193e115589059a510916ad142c5e7a11d0506f", "filename": "library/core/tests/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Ftests%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Ftests%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fclone.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,5 +1,5 @@\n #[test]\n-#[cfg_attr(not(bootstrap), allow(suspicious_double_ref_op))]\n+#[allow(suspicious_double_ref_op)]\n fn test_borrowed_clone() {\n     let x = 5;\n     let y: &i32 = &x;"}, {"sha": "3e6d31fcd2fb81e1f871f9b1cf4ec52984a14ec4", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -109,7 +109,7 @@\n #![feature(utf8_chunks)]\n #![feature(is_ascii_octdigit)]\n #![feature(get_many_mut)]\n-#![cfg_attr(not(bootstrap), feature(offset_of))]\n+#![feature(offset_of)]\n #![deny(unsafe_op_in_unsafe_fn)]\n #![deny(fuzzy_provenance_casts)]\n "}, {"sha": "5c2e18745ea21d7719bc61b4993613944c31d5e6", "filename": "library/core/tests/mem.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fmem.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -366,7 +366,6 @@ fn const_maybe_uninit() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn offset_of() {\n     #[repr(C)]\n     struct Foo {\n@@ -391,7 +390,7 @@ fn offset_of() {\n     struct Generic<T> {\n         x: u8,\n         y: u32,\n-        z: T\n+        z: T,\n     }\n \n     trait Trait {}\n@@ -409,7 +408,6 @@ fn offset_of() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn offset_of_union() {\n     #[repr(C)]\n     union Foo {\n@@ -429,7 +427,6 @@ fn offset_of_union() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn offset_of_dst() {\n     #[repr(C)]\n     struct Alpha {\n@@ -469,7 +466,6 @@ fn offset_of_dst() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn offset_of_packed() {\n     #[repr(C, packed)]\n     struct Foo {\n@@ -482,7 +478,6 @@ fn offset_of_packed() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn offset_of_projection() {\n     #[repr(C)]\n     struct Foo {\n@@ -503,7 +498,6 @@ fn offset_of_projection() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn offset_of_alias() {\n     #[repr(C)]\n     struct Foo {\n@@ -518,7 +512,6 @@ fn offset_of_alias() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn const_offset_of() {\n     #[repr(C)]\n     struct Foo {\n@@ -534,7 +527,6 @@ fn const_offset_of() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn offset_of_without_const_promotion() {\n     #[repr(C)]\n     struct Foo<SuppressConstPromotion> {\n@@ -555,7 +547,6 @@ fn offset_of_without_const_promotion() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn offset_of_addr() {\n     #[repr(C)]\n     struct Foo {"}, {"sha": "72d910bf957469544561abf0d2865e4633d06c5f", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,3 +1,5 @@\n+cargo-features = [\"public-dependency\"]\n+\n [package]\n name = \"std\"\n version = \"0.0.0\"\n@@ -10,12 +12,12 @@ edition = \"2021\"\n crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n-alloc = { path = \"../alloc\" }\n+alloc = { path = \"../alloc\", public = true }\n cfg-if = { version = \"1.0\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n-core = { path = \"../core\" }\n-libc = { version = \"0.2.143\", default-features = false, features = ['rustc-dep-of-std'] }\n+core = { path = \"../core\", public = true }\n+libc = { version = \"0.2.143\", default-features = false, features = ['rustc-dep-of-std'], public = true }\n compiler_builtins = { version = \"0.1.92\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n@@ -25,7 +27,7 @@ std_detect = { path = \"../stdarch/crates/std_detect\", default-features = false,\n # Dependencies of the `backtrace` crate\n addr2line = { version = \"0.19.0\", optional = true, default-features = false }\n rustc-demangle = { version = \"0.1.21\", features = ['rustc-dep-of-std'] }\n-miniz_oxide = { version = \"0.6.0\", optional = true, default-features = false }\n+miniz_oxide = { version = \"0.6.0\", optional = true, default-features = false, public = false }\n [dependencies.object]\n version = \"0.30.0\"\n optional = true\n@@ -40,7 +42,7 @@ rand_xorshift = \"0.3.0\"\n dlmalloc = { version = \"0.2.3\", features = ['rustc-dep-of-std'] }\n \n [target.x86_64-fortanix-unknown-sgx.dependencies]\n-fortanix-sgx-abi = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n+fortanix-sgx-abi = { version = \"0.5.0\", features = ['rustc-dep-of-std'], public = true }\n \n [target.'cfg(target_os = \"hermit\")'.dependencies]\n hermit-abi = { version = \"0.3.0\", features = ['rustc-dep-of-std'] }"}, {"sha": "274af08a3881c963c7c7ec4ea47f99c9e03ec286", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -437,7 +437,7 @@ impl<T: AsHandle> AsHandle for &mut T {\n     }\n }\n \n-#[stable(feature = \"as_windows_ptrs\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"as_windows_ptrs\", since = \"1.71.0\")]\n /// This impl allows implementing traits that require `AsHandle` on Arc.\n /// ```\n /// # #[cfg(windows)] mod group_cfg {\n@@ -457,15 +457,15 @@ impl<T: AsHandle> AsHandle for crate::sync::Arc<T> {\n     }\n }\n \n-#[stable(feature = \"as_windows_ptrs\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"as_windows_ptrs\", since = \"1.71.0\")]\n impl<T: AsHandle> AsHandle for crate::rc::Rc<T> {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n         (**self).as_handle()\n     }\n }\n \n-#[stable(feature = \"as_windows_ptrs\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"as_windows_ptrs\", since = \"1.71.0\")]\n impl<T: AsHandle> AsHandle for Box<T> {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {"}, {"sha": "6359835cad5d9221888a7f686d2045caf4eb9078", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -254,7 +254,7 @@ impl<T: AsSocket> AsSocket for &mut T {\n     }\n }\n \n-#[stable(feature = \"as_windows_ptrs\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"as_windows_ptrs\", since = \"1.71.0\")]\n /// This impl allows implementing traits that require `AsSocket` on Arc.\n /// ```\n /// # #[cfg(windows)] mod group_cfg {\n@@ -274,15 +274,15 @@ impl<T: AsSocket> AsSocket for crate::sync::Arc<T> {\n     }\n }\n \n-#[stable(feature = \"as_windows_ptrs\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"as_windows_ptrs\", since = \"1.71.0\")]\n impl<T: AsSocket> AsSocket for crate::rc::Rc<T> {\n     #[inline]\n     fn as_socket(&self) -> BorrowedSocket<'_> {\n         (**self).as_socket()\n     }\n }\n \n-#[stable(feature = \"as_windows_ptrs\", since = \"CURRENT_RUSTC_VERSION\")]\n+#[stable(feature = \"as_windows_ptrs\", since = \"1.71.0\")]\n impl<T: AsSocket> AsSocket for Box<T> {\n     #[inline]\n     fn as_socket(&self) -> BorrowedSocket<'_> {"}, {"sha": "1b50c2ea6dd57c2e86b84d2882208be6158ec02a", "filename": "library/std/src/sys/wasi/fd.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -96,7 +96,7 @@ impl WasiFd {\n         unsafe { wasi::fd_sync(self.as_raw_fd() as wasi::Fd).map_err(err2io) }\n     }\n \n-    pub fn advise(&self, offset: u64, len: u64, advice: wasi::Advice) -> io::Result<()> {\n+    pub(crate) fn advise(&self, offset: u64, len: u64, advice: wasi::Advice) -> io::Result<()> {\n         unsafe {\n             wasi::fd_advise(self.as_raw_fd() as wasi::Fd, offset, len, advice).map_err(err2io)\n         }\n@@ -179,7 +179,7 @@ impl WasiFd {\n         }\n     }\n \n-    pub fn filestat_get(&self) -> io::Result<wasi::Filestat> {\n+    pub(crate) fn filestat_get(&self) -> io::Result<wasi::Filestat> {\n         unsafe { wasi::fd_filestat_get(self.as_raw_fd() as wasi::Fd).map_err(err2io) }\n     }\n \n@@ -199,7 +199,7 @@ impl WasiFd {\n         unsafe { wasi::fd_filestat_set_size(self.as_raw_fd() as wasi::Fd, size).map_err(err2io) }\n     }\n \n-    pub fn path_filestat_get(\n+    pub(crate) fn path_filestat_get(\n         &self,\n         flags: wasi::Lookupflags,\n         path: &str,"}, {"sha": "437aae3ae7f7f5808dad81a9eb29d8207749ebce", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -104,7 +104,7 @@ impl FileAttr {\n         Ok(SystemTime::from_wasi_timestamp(self.meta.ctim))\n     }\n \n-    pub fn as_wasi(&self) -> &wasi::Filestat {\n+    pub(crate) fn as_wasi(&self) -> &wasi::Filestat {\n         &self.meta\n     }\n }\n@@ -142,7 +142,7 @@ impl FileType {\n         self.bits == wasi::FILETYPE_SYMBOLIC_LINK\n     }\n \n-    pub fn bits(&self) -> wasi::Filetype {\n+    pub(crate) fn bits(&self) -> wasi::Filetype {\n         self.bits\n     }\n }"}, {"sha": "3fcaaa508e3c89f6bf6039029c798b7ad5b0573d", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -11,6 +11,9 @@ use crate::sys::cvt;\n use crate::sys::handle::Handle;\n use core::str::utf8_char_width;\n \n+#[cfg(test)]\n+mod tests;\n+\n // Don't cache handles but get them fresh for every read/write. This allows us to track changes to\n // the value over time (such as if a process calls `SetStdHandle` while it's running). See #40490.\n pub struct Stdin {\n@@ -383,6 +386,10 @@ fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n     debug_assert!(utf16.len() <= c::c_int::MAX as usize);\n     debug_assert!(utf8.len() <= c::c_int::MAX as usize);\n \n+    if utf16.is_empty() {\n+        return Ok(0);\n+    }\n+\n     let result = unsafe {\n         c::WideCharToMultiByte(\n             c::CP_UTF8,              // CodePage"}, {"sha": "1e53e0bee636978f55f2f27ae9fbe78ea0e26c06", "filename": "library/std/src/sys/windows/stdio/tests.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio%2Ftests.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,6 @@\n+use super::utf16_to_utf8;\n+\n+#[test]\n+fn zero_size_read() {\n+    assert_eq!(utf16_to_utf8(&[], &mut []).unwrap(), 0);\n+}"}, {"sha": "358c2c3f9b2f3971180f6cabd1499ce76a475293", "filename": "library/std/tests/common/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Ftests%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/library%2Fstd%2Ftests%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Ftests%2Fcommon%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -20,15 +20,15 @@ pub(crate) fn test_rng() -> rand_xorshift::XorShiftRng {\n }\n \n // Copied from std::sys_common::io\n-pub struct TempDir(PathBuf);\n+pub(crate) struct TempDir(PathBuf);\n \n impl TempDir {\n-    pub fn join(&self, path: &str) -> PathBuf {\n+    pub(crate) fn join(&self, path: &str) -> PathBuf {\n         let TempDir(ref p) = *self;\n         p.join(path)\n     }\n \n-    pub fn path(&self) -> &Path {\n+    pub(crate) fn path(&self) -> &Path {\n         let TempDir(ref p) = *self;\n         p\n     }\n@@ -49,7 +49,7 @@ impl Drop for TempDir {\n }\n \n #[track_caller] // for `test_rng`\n-pub fn tmpdir() -> TempDir {\n+pub(crate) fn tmpdir() -> TempDir {\n     let p = env::temp_dir();\n     let mut r = test_rng();\n     let ret = p.join(&format!(\"rust-{}\", r.next_u32()));"}, {"sha": "473fdbe1edc27038cf1a7dd1ad46dae0fc60d48d", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -835,7 +835,7 @@ def bootstrap_binary(self):\n         \"\"\"\n         return os.path.join(self.build_dir, \"bootstrap\", \"debug\", \"bootstrap\")\n \n-    def build_bootstrap(self, color, verbose_count):\n+    def build_bootstrap(self, color, warnings, verbose_count):\n         \"\"\"Build bootstrap\"\"\"\n         env = os.environ.copy()\n         if \"GITHUB_ACTIONS\" in env:\n@@ -877,6 +877,12 @@ def build_bootstrap(self, color, verbose_count):\n \n         # preserve existing RUSTFLAGS\n         env.setdefault(\"RUSTFLAGS\", \"\")\n+        # we need to explicitly add +xgot here so that we can successfully bootstrap\n+        # a usable stage1 compiler\n+        # FIXME: remove this if condition on the next bootstrap bump\n+        # cfg(bootstrap)\n+        if self.build_triple().startswith('mips'):\n+            env[\"RUSTFLAGS\"] += \" -Ctarget-feature=+xgot\"\n         target_features = []\n         if self.get_toml(\"crt-static\", build_section) == \"true\":\n             target_features += [\"+crt-static\"]\n@@ -888,7 +894,11 @@ def build_bootstrap(self, color, verbose_count):\n         if target_linker is not None:\n             env[\"RUSTFLAGS\"] += \" -C linker=\" + target_linker\n         env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes\"\n-        if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n+        if warnings == \"default\":\n+            deny_warnings = self.get_toml(\"deny-warnings\", \"rust\") != \"false\"\n+        else:\n+            deny_warnings = warnings == \"deny\"\n+        if deny_warnings:\n             env[\"RUSTFLAGS\"] += \" -Dwarnings\"\n \n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n@@ -912,6 +922,10 @@ def build_bootstrap(self, color, verbose_count):\n             args.append(\"--color=always\")\n         elif color == \"never\":\n             args.append(\"--color=never\")\n+        try:\n+            args += env[\"CARGOFLAGS\"].split()\n+        except KeyError:\n+            pass\n \n         # Run this from the source directory so cargo finds .cargo/config\n         run(args, env=env, verbose=self.verbose, cwd=self.rust_root)\n@@ -977,6 +991,7 @@ def parse_args():\n     parser.add_argument('--color', choices=['always', 'never', 'auto'])\n     parser.add_argument('--clean', action='store_true')\n     parser.add_argument('--json-output', action='store_true')\n+    parser.add_argument('--warnings', choices=['deny', 'warn', 'default'], default='default')\n     parser.add_argument('-v', '--verbose', action='count', default=0)\n \n     return parser.parse_known_args(sys.argv)[0]\n@@ -1042,7 +1057,7 @@ def bootstrap(args):\n     # Fetch/build the bootstrap\n     build.download_toolchain()\n     sys.stdout.flush()\n-    build.build_bootstrap(args.color, verbose_count)\n+    build.build_bootstrap(args.color, args.warnings, verbose_count)\n     sys.stdout.flush()\n \n     # Run the bootstrap"}, {"sha": "6a2409a0fbfc67e4d242ba3ef417563bbcda0a0b", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1009,6 +1009,9 @@ impl Step for PlainSourceTarball {\n                 .arg(builder.src.join(\"./compiler/rustc_codegen_cranelift/Cargo.toml\"))\n                 .arg(\"--sync\")\n                 .arg(builder.src.join(\"./src/bootstrap/Cargo.toml\"))\n+                // Will read the libstd Cargo.toml\n+                // which uses the unstable `public-dependency` feature.\n+                .env(\"RUSTC_BOOTSTRAP\", \"1\")\n                 .current_dir(&plain_dst_src);\n \n             let config = if !builder.config.dry_run() {"}, {"sha": "3b20ceac8759ff74ecef14eb6c7afac2882ee331", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -74,6 +74,9 @@ fn workspace_members(build: &Build) -> impl Iterator<Item = Package> {\n     let collect_metadata = |manifest_path| {\n         let mut cargo = Command::new(&build.initial_cargo);\n         cargo\n+            // Will read the libstd Cargo.toml\n+            // which uses the unstable `public-dependency` feature.\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\")\n             .arg(\"metadata\")\n             .arg(\"--format-version\")\n             .arg(\"1\")"}, {"sha": "eec8c4ad69f2343a002f18c8016be4f9038e7a73", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1704,10 +1704,6 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             cmd.arg(\"--git-hash\");\n         }\n \n-        if let Some(commit) = builder.config.download_rustc_commit() {\n-            cmd.env(\"FAKE_DOWNLOAD_RUSTC_PREFIX\", format!(\"/rustc/{commit}\"));\n-        }\n-\n         builder.ci_env.force_coloring_in_ci(&mut cmd);\n \n         #[cfg(feature = \"build-metrics\")]\n@@ -1776,6 +1772,14 @@ impl Step for BookTest {\n     ///\n     /// This uses the `rustdoc` that sits next to `compiler`.\n     fn run(self, builder: &Builder<'_>) {\n+        let host = self.compiler.host;\n+        let _guard = builder.msg(\n+            Kind::Test,\n+            self.compiler.stage,\n+            &format!(\"book {}\", self.name),\n+            host,\n+            host,\n+        );\n         // External docs are different from local because:\n         // - Some books need pre-processing by mdbook before being tested.\n         // - They need to save their state to toolstate.\n@@ -1967,7 +1971,7 @@ fn markdown_test(builder: &Builder<'_>, compiler: Compiler, markdown: &Path) ->\n         }\n     }\n \n-    builder.info(&format!(\"doc tests for: {}\", markdown.display()));\n+    builder.verbose(&format!(\"doc tests for: {}\", markdown.display()));\n     let mut cmd = builder.rustdoc_cmd(compiler);\n     builder.add_rust_test_threads(&mut cmd);\n     // allow for unstable options such as new editions\n@@ -2503,6 +2507,9 @@ impl Step for Distcheck {\n         let toml = dir.join(\"rust-src/lib/rustlib/src/rust/library/std/Cargo.toml\");\n         builder.run(\n             Command::new(&builder.initial_cargo)\n+                // Will read the libstd Cargo.toml\n+                // which uses the unstable `public-dependency` feature.\n+                .env(\"RUSTC_BOOTSTRAP\", \"1\")\n                 .arg(\"generate-lockfile\")\n                 .arg(\"--manifest-path\")\n                 .arg(&toml)"}, {"sha": "c2fd2e3a91aef6c8c7dc7ce53957608d8f1ab8f8", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2FDockerfile?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -55,7 +55,7 @@ RUN ./build-clang.sh\n ENV CC=clang CXX=clang++\n \n # rustc-perf version from 2023-03-15\n-ENV PERF_COMMIT 9dfaa35193154b690922347ee1141a06ec87a199\n+ENV PERF_COMMIT 8b2ac3042e1ff2c0074455a0a3618adef97156b1\n RUN curl -LS -o perf.zip https://github.com/rust-lang/rustc-perf/archive/$PERF_COMMIT.zip && \\\n     unzip perf.zip && \\\n     mv rustc-perf-$PERF_COMMIT rustc-perf && \\"}, {"sha": "2fe3438e0fe8a81bee3cc56ed10c30010b8162f7", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -264,6 +264,7 @@ docker \\\n   --env RUST_CI_OVERRIDE_RELEASE_CHANNEL \\\n   --env CI_JOB_NAME=\"${CI_JOB_NAME-$IMAGE}\" \\\n   --env BASE_COMMIT=\"$BASE_COMMIT\" \\\n+  --env DIST_TRY_BUILD \\\n   --init \\\n   --rm \\\n   rust-ci \\"}, {"sha": "d3cb6b6ed522031fc7b2ddbc0ba74bf0f782f60b", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -757,6 +757,7 @@ jobs:\n     <<: *base-ci-job\n     name: try - ${{ matrix.name }}\n     env:\n+      DIST_TRY_BUILD: 1\n       <<: [*shared-ci-variables, *prod-variables]\n     if: github.event_name == 'push' && (github.ref == 'refs/heads/try' || github.ref == 'refs/heads/try-perf') && github.repository == 'rust-lang-ci/rust'\n     strategy:"}, {"sha": "4141296bd422ea6b7a93c698c56e15801c011479", "filename": "src/ci/stage-build.py", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fci%2Fstage-build.py", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fci%2Fstage-build.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fstage-build.py?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -48,6 +48,11 @@\n \n LLVM_BOLT_CRATES = LLVM_PGO_CRATES\n \n+\n+def is_try_build() -> bool:\n+    return os.environ.get(\"DIST_TRY_BUILD\", \"0\") != \"0\"\n+\n+\n class Pipeline:\n     # Paths\n     def checkout_path(self) -> Path:\n@@ -175,7 +180,7 @@ def rustc_stage_2(self) -> Path:\n \n     def build_rustc_perf(self):\n         # rustc-perf version from 2023-03-15\n-        perf_commit = \"9dfaa35193154b690922347ee1141a06ec87a199\"\n+        perf_commit = \"8b2ac3042e1ff2c0074455a0a3618adef97156b1\"\n         rustc_perf_zip_path = self.opt_artifacts() / \"perf.zip\"\n \n         def download_rustc_perf():\n@@ -851,6 +856,13 @@ def run(runner: BenchmarkRunner):\n \n     build_args = sys.argv[1:]\n \n+    # Skip components that are not needed for try builds to speed them up\n+    if is_try_build():\n+        LOGGER.info(\"Skipping building of unimportant components for a try build\")\n+        for target in (\"rust-docs\", \"rustc-docs\", \"rust-docs-json\", \"rust-analyzer\",\n+                       \"rustc-src\", \"clippy\", \"miri\", \"rustfmt\"):\n+            build_args.extend([\"--exclude\", target])\n+\n     timer = Timer()\n     pipeline = create_pipeline()\n \n@@ -865,6 +877,7 @@ def run(runner: BenchmarkRunner):\n \n     print_binary_sizes(pipeline)\n \n+\n if __name__ == \"__main__\":\n     runner = DefaultBenchmarkRunner()\n     run(runner)"}, {"sha": "df68e83bcac744e1b5fd4fa99f3b058955b81f99", "filename": "src/doc/unstable-book/src/language-features/const-eval-limit.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-eval-limit.md", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-eval-limit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-eval-limit.md?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,7 +0,0 @@\n-# `const_eval_limit`\n-\n-The tracking issue for this feature is: [#67217]\n-\n-[#67217]: https://github.com/rust-lang/rust/issues/67217\n-\n-The `const_eval_limit` allows someone to limit the evaluation steps the CTFE undertakes to evaluate a `const fn`."}, {"sha": "0807e0492c1134a606d8fd8c0353705f7dae9e62", "filename": "src/etc/pre-push.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fetc%2Fpre-push.sh", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fetc%2Fpre-push.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpre-push.sh?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -14,4 +14,4 @@ ROOT_DIR=\"$(git rev-parse --show-toplevel)\"\n echo \"Running pre-push script $ROOT_DIR/x test tidy\"\n \n cd \"$ROOT_DIR\"\n-CARGOFLAGS=\"--locked\" ./x test tidy\n+./x test tidy --set build.locked-deps=true"}, {"sha": "1c27320024a9f5d3e3347d7ca5cf66058e5376e4", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -381,7 +381,6 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n             Some(Event::Code(text)) => {\n                 trace!(\"saw code {}\", text);\n                 if let Some(link) = self.shortcut_link {\n-                    trace!(\"original text was {}\", link.original_text);\n                     // NOTE: this only replaces if the code block is the *entire* text.\n                     // If only part of the link has code highlighting, the disambiguator will not be removed.\n                     // e.g. [fn@`f`]\n@@ -390,8 +389,11 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n                     // So we could never be sure we weren't replacing too much:\n                     // [fn@my_`f`unc] is treated the same as [my_func()] in that pass.\n                     //\n-                    // NOTE: &[1..len() - 1] is to strip the backticks\n-                    if **text == link.original_text[1..link.original_text.len() - 1] {\n+                    // NOTE: .get(1..len() - 1) is to strip the backticks\n+                    if let Some(link) = self.links.iter().find(|l| {\n+                        l.href == link.href\n+                            && Some(&**text) == l.original_text.get(1..l.original_text.len() - 1)\n+                    }) {\n                         debug!(\"replacing {} with {}\", text, link.new_text);\n                         *text = CowStr::Borrowed(&link.new_text);\n                     }\n@@ -402,9 +404,12 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n             Some(Event::Text(text)) => {\n                 trace!(\"saw text {}\", text);\n                 if let Some(link) = self.shortcut_link {\n-                    trace!(\"original text was {}\", link.original_text);\n                     // NOTE: same limitations as `Event::Code`\n-                    if **text == *link.original_text {\n+                    if let Some(link) = self\n+                        .links\n+                        .iter()\n+                        .find(|l| l.href == link.href && **text == *l.original_text)\n+                    {\n                         debug!(\"replacing {} with {}\", text, link.new_text);\n                         *text = CowStr::Borrowed(&link.new_text);\n                     }"}, {"sha": "054cfe7597ea52fe6d5edcb8b10a4beb5e5d07a1", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1179,6 +1179,10 @@ a.test-arrow:hover {\n \tposition: relative;\n }\n \n+.code-header a.tooltip:hover {\n+\tcolor: var(--link-color);\n+}\n+\n /* placeholder thunk so that the mouse can easily travel from \"(i)\" to popover\n \tthe resulting \"hover tunnel\" is a stepped triangle, approximating\n \thttps://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown */\n@@ -1191,6 +1195,14 @@ a.tooltip:hover::after {\n \tcontent: \"\\00a0\";\n }\n \n+/* This animation is layered onto the mistake-proofing delay for dismissing\n+\ta hovered tooltip, to ensure it feels responsive even with the delay.\n+\t*/\n+.fade-out {\n+\topacity: 0;\n+\ttransition: opacity 0.45s cubic-bezier(0, 0, 0.1, 1.0);\n+}\n+\n .popover.tooltip .content {\n \tmargin: 0.25em 0.5em;\n }"}, {"sha": "6da51ea0a55e7f58675dd0370972d48e3079450d", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 138, "deletions": 10, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,6 +4,13 @@\n \n \"use strict\";\n \n+// The amount of time that the cursor must remain still over a hover target before\n+// revealing a tooltip.\n+//\n+// https://www.nngroup.com/articles/timing-exposing-content/\n+window.RUSTDOC_TOOLTIP_HOVER_MS = 300;\n+window.RUSTDOC_TOOLTIP_HOVER_EXIT_MS = 450;\n+\n // Given a basename (e.g. \"storage\") and an extension (e.g. \".js\"), return a URL\n // for a resource under the root-path, with the resource-suffix.\n function resourcePath(basename, extension) {\n@@ -772,6 +779,13 @@ function preLoadCss(cssUrl) {\n         });\n     });\n \n+    /**\n+     * Show a tooltip immediately.\n+     *\n+     * @param {DOMElement} e - The tooltip's anchor point. The DOM is consulted to figure\n+     *                         out what the tooltip should contain, and where it should be\n+     *                         positioned.\n+     */\n     function showTooltip(e) {\n         const notable_ty = e.getAttribute(\"data-notable-ty\");\n         if (!window.NOTABLE_TRAITS && notable_ty) {\n@@ -782,20 +796,29 @@ function preLoadCss(cssUrl) {\n                 throw new Error(\"showTooltip() called with notable without any notable traits!\");\n             }\n         }\n+        // Make this function idempotent. If the tooltip is already shown, avoid doing extra work\n+        // and leave it alone.\n         if (window.CURRENT_TOOLTIP_ELEMENT && window.CURRENT_TOOLTIP_ELEMENT.TOOLTIP_BASE === e) {\n-            // Make this function idempotent.\n+            clearTooltipHoverTimeout(window.CURRENT_TOOLTIP_ELEMENT);\n             return;\n         }\n         window.hideAllModals(false);\n         const wrapper = document.createElement(\"div\");\n         if (notable_ty) {\n             wrapper.innerHTML = \"<div class=\\\"content\\\">\" +\n                 window.NOTABLE_TRAITS[notable_ty] + \"</div>\";\n-        } else if (e.getAttribute(\"title\") !== undefined) {\n-            const titleContent = document.createElement(\"div\");\n-            titleContent.className = \"content\";\n-            titleContent.appendChild(document.createTextNode(e.getAttribute(\"title\")));\n-            wrapper.appendChild(titleContent);\n+        } else {\n+            // Replace any `title` attribute with `data-title` to avoid double tooltips.\n+            if (e.getAttribute(\"title\") !== null) {\n+                e.setAttribute(\"data-title\", e.getAttribute(\"title\"));\n+                e.removeAttribute(\"title\");\n+            }\n+            if (e.getAttribute(\"data-title\") !== null) {\n+                const titleContent = document.createElement(\"div\");\n+                titleContent.className = \"content\";\n+                titleContent.appendChild(document.createTextNode(e.getAttribute(\"data-title\")));\n+                wrapper.appendChild(titleContent);\n+            }\n         }\n         wrapper.className = \"tooltip popover\";\n         const focusCatcher = document.createElement(\"div\");\n@@ -824,17 +847,77 @@ function preLoadCss(cssUrl) {\n         wrapper.style.visibility = \"\";\n         window.CURRENT_TOOLTIP_ELEMENT = wrapper;\n         window.CURRENT_TOOLTIP_ELEMENT.TOOLTIP_BASE = e;\n+        clearTooltipHoverTimeout(window.CURRENT_TOOLTIP_ELEMENT);\n+        wrapper.onpointerenter = function(ev) {\n+            // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n+            if (ev.pointerType !== \"mouse\") {\n+                return;\n+            }\n+            clearTooltipHoverTimeout(e);\n+        };\n         wrapper.onpointerleave = function(ev) {\n             // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n             if (ev.pointerType !== \"mouse\") {\n                 return;\n             }\n-            if (!e.TOOLTIP_FORCE_VISIBLE && !elemIsInParent(event.relatedTarget, e)) {\n-                hideTooltip(true);\n+            if (!e.TOOLTIP_FORCE_VISIBLE && !elemIsInParent(ev.relatedTarget, e)) {\n+                // See \"Tooltip pointer leave gesture\" below.\n+                setTooltipHoverTimeout(e, false);\n+                addClass(wrapper, \"fade-out\");\n             }\n         };\n     }\n \n+    /**\n+     * Show or hide the tooltip after a timeout. If a timeout was already set before this function\n+     * was called, that timeout gets cleared. If the tooltip is already in the requested state,\n+     * this function will still clear any pending timeout, but otherwise do nothing.\n+     *\n+     * @param {DOMElement} element - The tooltip's anchor point. The DOM is consulted to figure\n+     *                               out what the tooltip should contain, and where it should be\n+     *                               positioned.\n+     * @param {boolean}    show    - If true, the tooltip will be made visible. If false, it will\n+     *                               be hidden.\n+     */\n+    function setTooltipHoverTimeout(element, show) {\n+        clearTooltipHoverTimeout(element);\n+        if (!show && !window.CURRENT_TOOLTIP_ELEMENT) {\n+            // To \"hide\" an already hidden element, just cancel its timeout.\n+            return;\n+        }\n+        if (show && window.CURRENT_TOOLTIP_ELEMENT) {\n+            // To \"show\" an already visible element, just cancel its timeout.\n+            return;\n+        }\n+        if (window.CURRENT_TOOLTIP_ELEMENT &&\n+            window.CURRENT_TOOLTIP_ELEMENT.TOOLTIP_BASE !== element) {\n+            // Don't do anything if another tooltip is already visible.\n+            return;\n+        }\n+        element.TOOLTIP_HOVER_TIMEOUT = setTimeout(() => {\n+            if (show) {\n+                showTooltip(element);\n+            } else if (!element.TOOLTIP_FORCE_VISIBLE) {\n+                hideTooltip(false);\n+            }\n+        }, show ? window.RUSTDOC_TOOLTIP_HOVER_MS : window.RUSTDOC_TOOLTIP_HOVER_EXIT_MS);\n+    }\n+\n+    /**\n+     * If a show/hide timeout was set by `setTooltipHoverTimeout`, cancel it. If none exists,\n+     * do nothing.\n+     *\n+     * @param {DOMElement} element - The tooltip's anchor point,\n+     *                               as passed to `setTooltipHoverTimeout`.\n+     */\n+    function clearTooltipHoverTimeout(element) {\n+        if (element.TOOLTIP_HOVER_TIMEOUT !== undefined) {\n+            removeClass(window.CURRENT_TOOLTIP_ELEMENT, \"fade-out\");\n+            clearTimeout(element.TOOLTIP_HOVER_TIMEOUT);\n+            delete element.TOOLTIP_HOVER_TIMEOUT;\n+        }\n+    }\n+\n     function tooltipBlurHandler(event) {\n         if (window.CURRENT_TOOLTIP_ELEMENT &&\n             !elemIsInParent(document.activeElement, window.CURRENT_TOOLTIP_ELEMENT) &&\n@@ -854,6 +937,12 @@ function preLoadCss(cssUrl) {\n         }\n     }\n \n+    /**\n+     * Hide the current tooltip immediately.\n+     *\n+     * @param {boolean} focus - If set to `true`, move keyboard focus to the tooltip anchor point.\n+     *                          If set to `false`, leave keyboard focus alone.\n+     */\n     function hideTooltip(focus) {\n         if (window.CURRENT_TOOLTIP_ELEMENT) {\n             if (window.CURRENT_TOOLTIP_ELEMENT.TOOLTIP_BASE.TOOLTIP_FORCE_VISIBLE) {\n@@ -864,6 +953,7 @@ function preLoadCss(cssUrl) {\n             }\n             const body = document.getElementsByTagName(\"body\")[0];\n             body.removeChild(window.CURRENT_TOOLTIP_ELEMENT);\n+            clearTooltipHoverTimeout(window.CURRENT_TOOLTIP_ELEMENT);\n             window.CURRENT_TOOLTIP_ELEMENT = null;\n         }\n     }\n@@ -886,7 +976,14 @@ function preLoadCss(cssUrl) {\n             if (ev.pointerType !== \"mouse\") {\n                 return;\n             }\n-            showTooltip(this);\n+            setTooltipHoverTimeout(this, true);\n+        };\n+        e.onpointermove = function(ev) {\n+            // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n+            if (ev.pointerType !== \"mouse\") {\n+                return;\n+            }\n+            setTooltipHoverTimeout(this, true);\n         };\n         e.onpointerleave = function(ev) {\n             // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n@@ -895,7 +992,38 @@ function preLoadCss(cssUrl) {\n             }\n             if (!this.TOOLTIP_FORCE_VISIBLE &&\n                 !elemIsInParent(ev.relatedTarget, window.CURRENT_TOOLTIP_ELEMENT)) {\n-                hideTooltip(true);\n+                // Tooltip pointer leave gesture:\n+                //\n+                // Designing a good hover microinteraction is a matter of guessing user\n+                // intent from what are, literally, vague gestures. In this case, guessing if\n+                // hovering in or out of the tooltip base is intentional or not.\n+                //\n+                // To figure this out, a few different techniques are used:\n+                //\n+                // * When the mouse pointer enters a tooltip anchor point, its hitbox is grown\n+                //   on the bottom, where the popover is/will appear. Search \"hover tunnel\" in\n+                //   rustdoc.css for the implementation.\n+                // * There's a delay when the mouse pointer enters the popover base anchor, in\n+                //   case the mouse pointer was just passing through and the user didn't want\n+                //   to open it.\n+                // * Similarly, a delay is added when exiting the anchor, or the popover\n+                //   itself, before hiding it.\n+                // * A fade-out animation is layered onto the pointer exit delay to immediately\n+                //   inform the user that they successfully dismissed the popover, while still\n+                //   providing a way for them to cancel it if it was a mistake and they still\n+                //   wanted to interact with it.\n+                // * No animation is used for revealing it, because we don't want people to try\n+                //   to interact with an element while it's in the middle of fading in: either\n+                //   they're allowed to interact with it while it's fading in, meaning it can't\n+                //   serve as mistake-proofing for the popover, or they can't, but\n+                //   they might try and be frustrated.\n+                //\n+                // See also:\n+                // * https://www.nngroup.com/articles/timing-exposing-content/\n+                // * https://www.nngroup.com/articles/tooltip-guidelines/\n+                // * https://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown\n+                setTooltipHoverTimeout(e, false);\n+                addClass(window.CURRENT_TOOLTIP_ELEMENT, \"fade-out\");\n             }\n         };\n     });"}, {"sha": "89ad4e0a649c1e56dfdbe8d91eaf4c456cf38915", "filename": "src/stage0.json", "status": "modified", "additions": 408, "deletions": 398, "changes": 806, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fstage0.json", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Fstage0.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.json?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2"}, {"sha": "15f2f81f4079e5b2e88b66809e797f845249c3d1", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_ref_to_mut.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,26 +0,0 @@\n-use clippy_utils::diagnostics::span_lint;\n-use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, MutTy, Mutability, TyKind, UnOp};\n-use rustc_lint::LateContext;\n-use rustc_middle::ty;\n-\n-use super::CAST_REF_TO_MUT;\n-\n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-    if_chain! {\n-        if let ExprKind::Unary(UnOp::Deref, e) = &expr.kind;\n-        if let ExprKind::Cast(e, t) = &e.kind;\n-        if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n-        if let ExprKind::Cast(e, t) = &e.kind;\n-        if let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind;\n-        if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind();\n-        then {\n-            span_lint(\n-                cx,\n-                CAST_REF_TO_MUT,\n-                expr.span,\n-                \"casting `&T` to `&mut T` may cause undefined behavior, consider instead using an `UnsafeCell`\",\n-            );\n-        }\n-    }\n-}"}, {"sha": "0c175372aab83c4c478a991ddd8a0f0f0195ea93", "filename": "src/tools/clippy/clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -9,7 +9,6 @@ mod cast_possible_truncation;\n mod cast_possible_wrap;\n mod cast_precision_loss;\n mod cast_ptr_alignment;\n-mod cast_ref_to_mut;\n mod cast_sign_loss;\n mod cast_slice_different_sizes;\n mod cast_slice_from_raw_parts;\n@@ -330,41 +329,6 @@ declare_clippy_lint! {\n     \"casting a function pointer to any integer type\"\n }\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for casts of `&T` to `&mut T` anywhere in the code.\n-    ///\n-    /// ### Why is this bad?\n-    /// It\u2019s basically guaranteed to be undefined behavior.\n-    /// `UnsafeCell` is the only way to obtain aliasable data that is considered\n-    /// mutable.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// fn x(r: &i32) {\n-    ///     unsafe {\n-    ///         *(r as *const _ as *mut _) += 1;\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// Instead consider using interior mutability types.\n-    ///\n-    /// ```rust\n-    /// use std::cell::UnsafeCell;\n-    ///\n-    /// fn x(r: &UnsafeCell<i32>) {\n-    ///     unsafe {\n-    ///         *r.get() += 1;\n-    ///     }\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.33.0\"]\n-    pub CAST_REF_TO_MUT,\n-    correctness,\n-    \"a cast of reference to a mutable pointer\"\n-}\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for expressions where a character literal is cast\n@@ -680,7 +644,6 @@ impl_lint_pass!(Casts => [\n     CAST_POSSIBLE_TRUNCATION,\n     CAST_POSSIBLE_WRAP,\n     CAST_LOSSLESS,\n-    CAST_REF_TO_MUT,\n     CAST_PTR_ALIGNMENT,\n     CAST_SLICE_DIFFERENT_SIZES,\n     UNNECESSARY_CAST,\n@@ -747,7 +710,6 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             }\n         }\n \n-        cast_ref_to_mut::check(cx, expr);\n         cast_ptr_alignment::check(cx, expr);\n         char_lit_as_u8::check(cx, expr);\n         ptr_as_ptr::check(cx, expr, &self.msrv);"}, {"sha": "212e809d4c564fde2e8488186375c5e067acf6ec", "filename": "src/tools/clippy/clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -81,7 +81,6 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::casts::CAST_POSSIBLE_WRAP_INFO,\n     crate::casts::CAST_PRECISION_LOSS_INFO,\n     crate::casts::CAST_PTR_ALIGNMENT_INFO,\n-    crate::casts::CAST_REF_TO_MUT_INFO,\n     crate::casts::CAST_SIGN_LOSS_INFO,\n     crate::casts::CAST_SLICE_DIFFERENT_SIZES_INFO,\n     crate::casts::CAST_SLICE_FROM_RAW_PARTS_INFO,"}, {"sha": "4cb41830023396982b68f8a40c8c7a9bec0736c6", "filename": "src/tools/clippy/clippy_lints/src/renamed_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -31,6 +31,7 @@ pub static RENAMED_LINTS: &[(&str, &str)] = &[\n     (\"clippy::stutter\", \"clippy::module_name_repetitions\"),\n     (\"clippy::to_string_in_display\", \"clippy::recursive_format_impl\"),\n     (\"clippy::zero_width_space\", \"clippy::invisible_characters\"),\n+    (\"clippy::cast_ref_to_mut\", \"cast_ref_to_mut\"),\n     (\"clippy::clone_double_ref\", \"suspicious_double_ref_op\"),\n     (\"clippy::drop_bounds\", \"drop_bounds\"),\n     (\"clippy::drop_copy\", \"dropping_copy_types\"),"}, {"sha": "c48a734ba32c26874a19c58d8c6d959fe9e7f066", "filename": "src/tools/clippy/tests/ui/cast_ref_to_mut.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_ref_to_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_ref_to_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_ref_to_mut.rs?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,31 +0,0 @@\n-#![warn(clippy::cast_ref_to_mut)]\n-#![allow(clippy::no_effect, clippy::borrow_as_ptr)]\n-\n-extern \"C\" {\n-    // N.B., mutability can be easily incorrect in FFI calls -- as\n-    // in C, the default is mutable pointers.\n-    fn ffi(c: *mut u8);\n-    fn int_ffi(c: *mut i32);\n-}\n-\n-fn main() {\n-    let s = String::from(\"Hello\");\n-    let a = &s;\n-    unsafe {\n-        let num = &3i32;\n-        let mut_num = &mut 3i32;\n-        // Should be warned against\n-        (*(a as *const _ as *mut String)).push_str(\" world\");\n-        *(a as *const _ as *mut _) = String::from(\"Replaced\");\n-        *(a as *const _ as *mut String) += \" world\";\n-        // Shouldn't be warned against\n-        println!(\"{}\", *(num as *const _ as *const i16));\n-        println!(\"{}\", *(mut_num as *mut _ as *mut i16));\n-        ffi(a.as_ptr() as *mut _);\n-        int_ffi(num as *const _ as *mut _);\n-        int_ffi(&3 as *const _ as *mut _);\n-        let mut value = 3;\n-        let value: *const i32 = &mut value;\n-        *(value as *const i16 as *mut i16) = 42;\n-    }\n-}"}, {"sha": "aacd99437d9fc3eadde5b8a60a5b0a11e9de8b30", "filename": "src/tools/clippy/tests/ui/cast_ref_to_mut.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_ref_to_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_ref_to_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_ref_to_mut.stderr?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,22 +0,0 @@\n-error: casting `&T` to `&mut T` may cause undefined behavior, consider instead using an `UnsafeCell`\n-  --> $DIR/cast_ref_to_mut.rs:18:9\n-   |\n-LL |         (*(a as *const _ as *mut String)).push_str(\" world\");\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::cast-ref-to-mut` implied by `-D warnings`\n-\n-error: casting `&T` to `&mut T` may cause undefined behavior, consider instead using an `UnsafeCell`\n-  --> $DIR/cast_ref_to_mut.rs:19:9\n-   |\n-LL |         *(a as *const _ as *mut _) = String::from(\"Replaced\");\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: casting `&T` to `&mut T` may cause undefined behavior, consider instead using an `UnsafeCell`\n-  --> $DIR/cast_ref_to_mut.rs:20:9\n-   |\n-LL |         *(a as *const _ as *mut String) += \" world\";\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "83a76f81d4e78ff448f5acf958f984023b1dc703", "filename": "src/tools/clippy/tests/ui/modulo_one.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmodulo_one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmodulo_one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmodulo_one.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -2,21 +2,21 @@ error: this operation will panic at runtime\n   --> $DIR/modulo_one.rs:11:5\n    |\n LL |     i32::MIN % (-1); // also caught by rustc\n-   |     ^^^^^^^^^^^^^^^ attempt to compute the remainder of `i32::MIN % -1_i32`, which would overflow\n+   |     ^^^^^^^^^^^^^^^ attempt to compute `i32::MIN % -1_i32`, which would overflow\n    |\n    = note: `#[deny(unconditional_panic)]` on by default\n \n error: this operation will panic at runtime\n   --> $DIR/modulo_one.rs:21:5\n    |\n LL |     INT_MIN % NEG_ONE; // also caught by rustc\n-   |     ^^^^^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+   |     ^^^^^^^^^^^^^^^^^ attempt to compute `i64::MIN % -1_i64`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/modulo_one.rs:22:5\n    |\n LL |     INT_MIN % STATIC_NEG_ONE; // ONLY caught by rustc\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ attempt to compute `i64::MIN % -1_i64`, which would overflow\n \n error: any number modulo 1 will be 0\n   --> $DIR/modulo_one.rs:8:5"}, {"sha": "f7854b89ee4ea22962364caaa5835bf8fb97dad1", "filename": "src/tools/clippy/tests/ui/rename.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.fixed?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -29,6 +29,7 @@\n #![allow(clippy::recursive_format_impl)]\n #![allow(clippy::invisible_characters)]\n #![allow(suspicious_double_ref_op)]\n+#![allow(cast_ref_to_mut)]\n #![allow(drop_bounds)]\n #![allow(dropping_copy_types)]\n #![allow(dropping_references)]\n@@ -76,6 +77,7 @@\n #![warn(clippy::module_name_repetitions)]\n #![warn(clippy::recursive_format_impl)]\n #![warn(clippy::invisible_characters)]\n+#![warn(cast_ref_to_mut)]\n #![warn(suspicious_double_ref_op)]\n #![warn(drop_bounds)]\n #![warn(dropping_copy_types)]"}, {"sha": "fa347d395ef5d624722de7bf4bdb0fc16abcb225", "filename": "src/tools/clippy/tests/ui/rename.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -29,6 +29,7 @@\n #![allow(clippy::recursive_format_impl)]\n #![allow(clippy::invisible_characters)]\n #![allow(suspicious_double_ref_op)]\n+#![allow(cast_ref_to_mut)]\n #![allow(drop_bounds)]\n #![allow(dropping_copy_types)]\n #![allow(dropping_references)]\n@@ -76,6 +77,7 @@\n #![warn(clippy::stutter)]\n #![warn(clippy::to_string_in_display)]\n #![warn(clippy::zero_width_space)]\n+#![warn(clippy::cast_ref_to_mut)]\n #![warn(clippy::clone_double_ref)]\n #![warn(clippy::drop_bounds)]\n #![warn(clippy::drop_copy)]"}, {"sha": "9dffe51e5d7d3ca16bc14e69784fc2ef49a0f5b4", "filename": "src/tools/clippy/tests/ui/rename.stderr", "status": "modified", "additions": 56, "deletions": 50, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frename.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,298 +1,304 @@\n error: lint `clippy::almost_complete_letter_range` has been renamed to `clippy::almost_complete_range`\n-  --> $DIR/rename.rs:50:9\n+  --> $DIR/rename.rs:51:9\n    |\n LL | #![warn(clippy::almost_complete_letter_range)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::almost_complete_range`\n    |\n    = note: `-D renamed-and-removed-lints` implied by `-D warnings`\n \n error: lint `clippy::blacklisted_name` has been renamed to `clippy::disallowed_names`\n-  --> $DIR/rename.rs:51:9\n+  --> $DIR/rename.rs:52:9\n    |\n LL | #![warn(clippy::blacklisted_name)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_names`\n \n error: lint `clippy::block_in_if_condition_expr` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:52:9\n+  --> $DIR/rename.rs:53:9\n    |\n LL | #![warn(clippy::block_in_if_condition_expr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::block_in_if_condition_stmt` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:53:9\n+  --> $DIR/rename.rs:54:9\n    |\n LL | #![warn(clippy::block_in_if_condition_stmt)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::box_vec` has been renamed to `clippy::box_collection`\n-  --> $DIR/rename.rs:54:9\n+  --> $DIR/rename.rs:55:9\n    |\n LL | #![warn(clippy::box_vec)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::box_collection`\n \n error: lint `clippy::const_static_lifetime` has been renamed to `clippy::redundant_static_lifetimes`\n-  --> $DIR/rename.rs:55:9\n+  --> $DIR/rename.rs:56:9\n    |\n LL | #![warn(clippy::const_static_lifetime)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::redundant_static_lifetimes`\n \n error: lint `clippy::cyclomatic_complexity` has been renamed to `clippy::cognitive_complexity`\n-  --> $DIR/rename.rs:56:9\n+  --> $DIR/rename.rs:57:9\n    |\n LL | #![warn(clippy::cyclomatic_complexity)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::cognitive_complexity`\n \n error: lint `clippy::derive_hash_xor_eq` has been renamed to `clippy::derived_hash_with_manual_eq`\n-  --> $DIR/rename.rs:57:9\n+  --> $DIR/rename.rs:58:9\n    |\n LL | #![warn(clippy::derive_hash_xor_eq)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::derived_hash_with_manual_eq`\n \n error: lint `clippy::disallowed_method` has been renamed to `clippy::disallowed_methods`\n-  --> $DIR/rename.rs:58:9\n+  --> $DIR/rename.rs:59:9\n    |\n LL | #![warn(clippy::disallowed_method)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_methods`\n \n error: lint `clippy::disallowed_type` has been renamed to `clippy::disallowed_types`\n-  --> $DIR/rename.rs:59:9\n+  --> $DIR/rename.rs:60:9\n    |\n LL | #![warn(clippy::disallowed_type)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_types`\n \n error: lint `clippy::eval_order_dependence` has been renamed to `clippy::mixed_read_write_in_expression`\n-  --> $DIR/rename.rs:60:9\n+  --> $DIR/rename.rs:61:9\n    |\n LL | #![warn(clippy::eval_order_dependence)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::mixed_read_write_in_expression`\n \n error: lint `clippy::identity_conversion` has been renamed to `clippy::useless_conversion`\n-  --> $DIR/rename.rs:61:9\n+  --> $DIR/rename.rs:62:9\n    |\n LL | #![warn(clippy::identity_conversion)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::useless_conversion`\n \n error: lint `clippy::if_let_some_result` has been renamed to `clippy::match_result_ok`\n-  --> $DIR/rename.rs:62:9\n+  --> $DIR/rename.rs:63:9\n    |\n LL | #![warn(clippy::if_let_some_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::match_result_ok`\n \n error: lint `clippy::integer_arithmetic` has been renamed to `clippy::arithmetic_side_effects`\n-  --> $DIR/rename.rs:63:9\n+  --> $DIR/rename.rs:64:9\n    |\n LL | #![warn(clippy::integer_arithmetic)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::arithmetic_side_effects`\n \n error: lint `clippy::logic_bug` has been renamed to `clippy::overly_complex_bool_expr`\n-  --> $DIR/rename.rs:64:9\n+  --> $DIR/rename.rs:65:9\n    |\n LL | #![warn(clippy::logic_bug)]\n    |         ^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::overly_complex_bool_expr`\n \n error: lint `clippy::new_without_default_derive` has been renamed to `clippy::new_without_default`\n-  --> $DIR/rename.rs:65:9\n+  --> $DIR/rename.rs:66:9\n    |\n LL | #![warn(clippy::new_without_default_derive)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::new_without_default`\n \n error: lint `clippy::option_and_then_some` has been renamed to `clippy::bind_instead_of_map`\n-  --> $DIR/rename.rs:66:9\n+  --> $DIR/rename.rs:67:9\n    |\n LL | #![warn(clippy::option_and_then_some)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::bind_instead_of_map`\n \n error: lint `clippy::option_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:67:9\n+  --> $DIR/rename.rs:68:9\n    |\n LL | #![warn(clippy::option_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::option_map_unwrap_or` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:68:9\n+  --> $DIR/rename.rs:69:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:69:9\n+  --> $DIR/rename.rs:70:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:70:9\n+  --> $DIR/rename.rs:71:9\n    |\n LL | #![warn(clippy::option_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::ref_in_deref` has been renamed to `clippy::needless_borrow`\n-  --> $DIR/rename.rs:71:9\n+  --> $DIR/rename.rs:72:9\n    |\n LL | #![warn(clippy::ref_in_deref)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::needless_borrow`\n \n error: lint `clippy::result_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:72:9\n+  --> $DIR/rename.rs:73:9\n    |\n LL | #![warn(clippy::result_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::result_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:73:9\n+  --> $DIR/rename.rs:74:9\n    |\n LL | #![warn(clippy::result_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::result_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:74:9\n+  --> $DIR/rename.rs:75:9\n    |\n LL | #![warn(clippy::result_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::single_char_push_str` has been renamed to `clippy::single_char_add_str`\n-  --> $DIR/rename.rs:75:9\n+  --> $DIR/rename.rs:76:9\n    |\n LL | #![warn(clippy::single_char_push_str)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::single_char_add_str`\n \n error: lint `clippy::stutter` has been renamed to `clippy::module_name_repetitions`\n-  --> $DIR/rename.rs:76:9\n+  --> $DIR/rename.rs:77:9\n    |\n LL | #![warn(clippy::stutter)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::module_name_repetitions`\n \n error: lint `clippy::to_string_in_display` has been renamed to `clippy::recursive_format_impl`\n-  --> $DIR/rename.rs:77:9\n+  --> $DIR/rename.rs:78:9\n    |\n LL | #![warn(clippy::to_string_in_display)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::recursive_format_impl`\n \n error: lint `clippy::zero_width_space` has been renamed to `clippy::invisible_characters`\n-  --> $DIR/rename.rs:78:9\n+  --> $DIR/rename.rs:79:9\n    |\n LL | #![warn(clippy::zero_width_space)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::invisible_characters`\n \n+error: lint `clippy::cast_ref_to_mut` has been renamed to `cast_ref_to_mut`\n+  --> $DIR/rename.rs:80:9\n+   |\n+LL | #![warn(clippy::cast_ref_to_mut)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `cast_ref_to_mut`\n+\n error: lint `clippy::clone_double_ref` has been renamed to `suspicious_double_ref_op`\n-  --> $DIR/rename.rs:79:9\n+  --> $DIR/rename.rs:81:9\n    |\n LL | #![warn(clippy::clone_double_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `suspicious_double_ref_op`\n \n error: lint `clippy::drop_bounds` has been renamed to `drop_bounds`\n-  --> $DIR/rename.rs:80:9\n+  --> $DIR/rename.rs:82:9\n    |\n LL | #![warn(clippy::drop_bounds)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `drop_bounds`\n \n error: lint `clippy::drop_copy` has been renamed to `dropping_copy_types`\n-  --> $DIR/rename.rs:81:9\n+  --> $DIR/rename.rs:83:9\n    |\n LL | #![warn(clippy::drop_copy)]\n    |         ^^^^^^^^^^^^^^^^^ help: use the new name: `dropping_copy_types`\n \n error: lint `clippy::drop_ref` has been renamed to `dropping_references`\n-  --> $DIR/rename.rs:82:9\n+  --> $DIR/rename.rs:84:9\n    |\n LL | #![warn(clippy::drop_ref)]\n    |         ^^^^^^^^^^^^^^^^ help: use the new name: `dropping_references`\n \n error: lint `clippy::for_loop_over_option` has been renamed to `for_loops_over_fallibles`\n-  --> $DIR/rename.rs:83:9\n+  --> $DIR/rename.rs:85:9\n    |\n LL | #![warn(clippy::for_loop_over_option)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `for_loops_over_fallibles`\n \n error: lint `clippy::for_loop_over_result` has been renamed to `for_loops_over_fallibles`\n-  --> $DIR/rename.rs:84:9\n+  --> $DIR/rename.rs:86:9\n    |\n LL | #![warn(clippy::for_loop_over_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `for_loops_over_fallibles`\n \n error: lint `clippy::for_loops_over_fallibles` has been renamed to `for_loops_over_fallibles`\n-  --> $DIR/rename.rs:85:9\n+  --> $DIR/rename.rs:87:9\n    |\n LL | #![warn(clippy::for_loops_over_fallibles)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `for_loops_over_fallibles`\n \n error: lint `clippy::forget_copy` has been renamed to `forgetting_copy_types`\n-  --> $DIR/rename.rs:86:9\n+  --> $DIR/rename.rs:88:9\n    |\n LL | #![warn(clippy::forget_copy)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `forgetting_copy_types`\n \n error: lint `clippy::forget_ref` has been renamed to `forgetting_references`\n-  --> $DIR/rename.rs:87:9\n+  --> $DIR/rename.rs:89:9\n    |\n LL | #![warn(clippy::forget_ref)]\n    |         ^^^^^^^^^^^^^^^^^^ help: use the new name: `forgetting_references`\n \n error: lint `clippy::into_iter_on_array` has been renamed to `array_into_iter`\n-  --> $DIR/rename.rs:88:9\n+  --> $DIR/rename.rs:90:9\n    |\n LL | #![warn(clippy::into_iter_on_array)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `array_into_iter`\n \n error: lint `clippy::invalid_atomic_ordering` has been renamed to `invalid_atomic_ordering`\n-  --> $DIR/rename.rs:89:9\n+  --> $DIR/rename.rs:91:9\n    |\n LL | #![warn(clippy::invalid_atomic_ordering)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_atomic_ordering`\n \n error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n-  --> $DIR/rename.rs:90:9\n+  --> $DIR/rename.rs:92:9\n    |\n LL | #![warn(clippy::invalid_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_value`\n \n error: lint `clippy::invalid_utf8_in_unchecked` has been renamed to `invalid_from_utf8_unchecked`\n-  --> $DIR/rename.rs:91:9\n+  --> $DIR/rename.rs:93:9\n    |\n LL | #![warn(clippy::invalid_utf8_in_unchecked)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_from_utf8_unchecked`\n \n error: lint `clippy::let_underscore_drop` has been renamed to `let_underscore_drop`\n-  --> $DIR/rename.rs:92:9\n+  --> $DIR/rename.rs:94:9\n    |\n LL | #![warn(clippy::let_underscore_drop)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `let_underscore_drop`\n \n error: lint `clippy::mem_discriminant_non_enum` has been renamed to `enum_intrinsics_non_enums`\n-  --> $DIR/rename.rs:93:9\n+  --> $DIR/rename.rs:95:9\n    |\n LL | #![warn(clippy::mem_discriminant_non_enum)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `enum_intrinsics_non_enums`\n \n error: lint `clippy::panic_params` has been renamed to `non_fmt_panics`\n-  --> $DIR/rename.rs:94:9\n+  --> $DIR/rename.rs:96:9\n    |\n LL | #![warn(clippy::panic_params)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `non_fmt_panics`\n \n error: lint `clippy::positional_named_format_parameters` has been renamed to `named_arguments_used_positionally`\n-  --> $DIR/rename.rs:95:9\n+  --> $DIR/rename.rs:97:9\n    |\n LL | #![warn(clippy::positional_named_format_parameters)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `named_arguments_used_positionally`\n \n error: lint `clippy::temporary_cstring_as_ptr` has been renamed to `temporary_cstring_as_ptr`\n-  --> $DIR/rename.rs:96:9\n+  --> $DIR/rename.rs:98:9\n    |\n LL | #![warn(clippy::temporary_cstring_as_ptr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `temporary_cstring_as_ptr`\n \n error: lint `clippy::unknown_clippy_lints` has been renamed to `unknown_lints`\n-  --> $DIR/rename.rs:97:9\n+  --> $DIR/rename.rs:99:9\n    |\n LL | #![warn(clippy::unknown_clippy_lints)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unknown_lints`\n \n error: lint `clippy::unused_label` has been renamed to `unused_labels`\n-  --> $DIR/rename.rs:98:9\n+  --> $DIR/rename.rs:100:9\n    |\n LL | #![warn(clippy::unused_label)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unused_labels`\n \n-error: aborting due to 49 previous errors\n+error: aborting due to 50 previous errors\n "}, {"sha": "923b2e63f2ee5f7c38fc315b917f89bb745d35d8", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1939,6 +1939,17 @@ impl<'test> TestCx<'test> {\n         // Use a single thread for efficiency and a deterministic error message order\n         rustc.arg(\"-Zthreads=1\");\n \n+        // Hide libstd sources from ui tests to make sure we generate the stderr\n+        // output that users will see.\n+        // Without this, we may be producing good diagnostics in-tree but users\n+        // will not see half the information.\n+        //\n+        // This also has the benefit of more effectively normalizing output between different\n+        // compilers, so that we don't have to know the `/rustc/$sha` output to normalize after the\n+        // fact.\n+        rustc.arg(\"-Zsimulate-remapped-rust-src-base=/rustc/FAKE_PREFIX\");\n+        rustc.arg(\"-Ztranslate-remapped-path-to-local-path=no\");\n+\n         // Optionally prevent default --sysroot if specified in test compile-flags.\n         if !self.props.compile_flags.iter().any(|flag| flag.starts_with(\"--sysroot\")) {\n             // In stage 0, make sure we use `stage0-sysroot` instead of the bootstrap sysroot.\n@@ -2014,13 +2025,6 @@ impl<'test> TestCx<'test> {\n                 rustc.arg(\"-Ccodegen-units=1\");\n                 // Hide line numbers to reduce churn\n                 rustc.arg(\"-Zui-testing\");\n-                // Hide libstd sources from ui tests to make sure we generate the stderr\n-                // output that users will see.\n-                // Without this, we may be producing good diagnostics in-tree but users\n-                // will not see half the information.\n-                rustc.arg(\"-Zsimulate-remapped-rust-src-base=/rustc/FAKE_PREFIX\");\n-                rustc.arg(\"-Ztranslate-remapped-path-to-local-path=no\");\n-\n                 rustc.arg(\"-Zdeduplicate-diagnostics=no\");\n                 // FIXME: use this for other modes too, for perf?\n                 rustc.arg(\"-Cstrip=debuginfo\");\n@@ -3732,28 +3736,13 @@ impl<'test> TestCx<'test> {\n             normalize_path(&remapped_parent_dir, \"$DIR\");\n         }\n \n-        let source_bases = &[\n-            // Source base on the current filesystem (calculated as parent of `tests/$suite`):\n-            Some(self.config.src_base.parent().unwrap().parent().unwrap().into()),\n-            // Source base on the sysroot (from the src components downloaded by `download-rustc`):\n-            Some(self.config.sysroot_base.join(\"lib\").join(\"rustlib\").join(\"src\").join(\"rust\")),\n-            // Virtual `/rustc/$sha` remapped paths (if `remap-debuginfo` is enabled):\n-            option_env!(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\").map(PathBuf::from),\n-            // Virtual `/rustc/$sha` coming from download-rustc:\n-            std::env::var_os(\"FAKE_DOWNLOAD_RUSTC_PREFIX\").map(PathBuf::from),\n-            // Tests using -Zsimulate-remapped-rust-src-base should use this fake path\n-            Some(\"/rustc/FAKE_PREFIX\".into()),\n-        ];\n-        for base_dir in source_bases {\n-            if let Some(base_dir) = base_dir {\n-                // Paths into the libstd/libcore\n-                normalize_path(&base_dir.join(\"library\"), \"$SRC_DIR\");\n-                // `ui-fulldeps` tests can show paths to the compiler source when testing macros from\n-                // `rustc_macros`\n-                // eg. /home/user/rust/compiler\n-                normalize_path(&base_dir.join(\"compiler\"), \"$COMPILER_DIR\");\n-            }\n-        }\n+        let base_dir = Path::new(\"/rustc/FAKE_PREFIX\");\n+        // Paths into the libstd/libcore\n+        normalize_path(&base_dir.join(\"library\"), \"$SRC_DIR\");\n+        // `ui-fulldeps` tests can show paths to the compiler source when testing macros from\n+        // `rustc_macros`\n+        // eg. /home/user/rust/compiler\n+        normalize_path(&base_dir.join(\"compiler\"), \"$COMPILER_DIR\");\n \n         // Paths into the build directory\n         let test_build_dir = &self.config.build_base;"}, {"sha": "ee815ae6f8fc07181b09d47a116beecefea3cab5", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1 +1 @@\n-617d3d6d722c432cdcbf210e6db55c3bdeafe381\n+33c3d101280c8eb3cd8af421bfb56a8afcc3881d"}, {"sha": "2a06bd871ef92cb379c2acb40a56df100785f09e", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 57, "deletions": 14, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,6 +3,8 @@ use std::num::NonZeroU64;\n \n use log::trace;\n \n+use rustc_const_eval::ReportErrorExt;\n+use rustc_errors::DiagnosticMessage;\n use rustc_span::{source_map::DUMMY_SP, SpanData, Symbol};\n use rustc_target::abi::{Align, Size};\n \n@@ -83,7 +85,25 @@ impl fmt::Display for TerminationInfo {\n     }\n }\n \n-impl MachineStopType for TerminationInfo {}\n+impl fmt::Debug for TerminationInfo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{self}\")\n+    }\n+}\n+\n+impl MachineStopType for TerminationInfo {\n+    fn diagnostic_message(&self) -> DiagnosticMessage {\n+        self.to_string().into()\n+    }\n+    fn add_args(\n+        self: Box<Self>,\n+        _: &mut dyn FnMut(\n+            std::borrow::Cow<'static, str>,\n+            rustc_errors::DiagnosticArgValue<'static>,\n+        ),\n+    ) {\n+    }\n+}\n \n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n@@ -302,8 +322,31 @@ pub fn report_error<'tcx, 'mir>(\n \n     let stacktrace = ecx.generate_stacktrace();\n     let (stacktrace, was_pruned) = prune_stacktrace(stacktrace, &ecx.machine);\n-    e.print_backtrace();\n-    msg.insert(0, e.to_string());\n+    let (e, backtrace) = e.into_parts();\n+    backtrace.print_backtrace();\n+\n+    // We want to dump the allocation if this is `InvalidUninitBytes`. Since `add_args` consumes\n+    // the `InterpError`, we extract the variables it before that.\n+    let extra = match e {\n+        UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some((alloc_id, access)))) =>\n+            Some((alloc_id, access)),\n+        _ => None,\n+    };\n+\n+    // FIXME(fee1-dead), HACK: we want to use the error as title therefore we can just extract the\n+    // label and arguments from the InterpError.\n+    let e = {\n+        let handler = &ecx.tcx.sess.parse_sess.span_diagnostic;\n+        let mut diag = ecx.tcx.sess.struct_allow(\"\");\n+        let msg = e.diagnostic_message();\n+        e.add_args(handler, &mut diag);\n+        let s = handler.eagerly_translate_to_string(msg, diag.args());\n+        diag.cancel();\n+        s\n+    };\n+\n+    msg.insert(0, e);\n+\n     report_msg(\n         DiagLevel::Error,\n         if let Some(title) = title { format!(\"{title}: {}\", msg[0]) } else { msg[0].clone() },\n@@ -332,15 +375,12 @@ pub fn report_error<'tcx, 'mir>(\n     }\n \n     // Extra output to help debug specific issues.\n-    match e.kind() {\n-        UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some((alloc_id, access)))) => {\n-            eprintln!(\n-                \"Uninitialized memory occurred at {alloc_id:?}{range:?}, in this allocation:\",\n-                range = access.uninit,\n-            );\n-            eprintln!(\"{:?}\", ecx.dump_alloc(*alloc_id));\n-        }\n-        _ => {}\n+    if let Some((alloc_id, access)) = extra {\n+        eprintln!(\n+            \"Uninitialized memory occurred at {alloc_id:?}{range:?}, in this allocation:\",\n+            range = access.uninit,\n+        );\n+        eprintln!(\"{:?}\", ecx.dump_alloc(alloc_id));\n     }\n \n     None\n@@ -438,20 +478,23 @@ pub fn report_msg<'tcx>(\n         // Add visual separator before backtrace.\n         err.note(if extra_span { \"BACKTRACE (of the first span):\" } else { \"BACKTRACE:\" });\n     }\n+\n+    let (mut err, handler) = err.into_diagnostic().unwrap();\n+\n     // Add backtrace\n     for (idx, frame_info) in stacktrace.iter().enumerate() {\n         let is_local = machine.is_local(frame_info);\n         // No span for non-local frames and the first frame (which is the error site).\n         if is_local && idx > 0 {\n-            err.span_note(frame_info.span, frame_info.to_string());\n+            err.eager_subdiagnostic(handler, frame_info.as_note(machine.tcx));\n         } else {\n             let sm = sess.source_map();\n             let span = sm.span_to_embeddable_string(frame_info.span);\n             err.note(format!(\"{frame_info} at {span}\"));\n         }\n     }\n \n-    err.emit();\n+    handler.emit_diagnostic(&mut err);\n }\n \n impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {"}, {"sha": "1e9d48be65ed972b42f3e6e06f72af514f8ace91", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -422,8 +422,9 @@ pub fn eval_entry<'tcx>(\n     let mut ecx = match create_ecx(tcx, entry_id, entry_type, &config) {\n         Ok(v) => v,\n         Err(err) => {\n-            err.print_backtrace();\n-            panic!(\"Miri initialization error: {}\", err.kind())\n+            let (kind, backtrace) = err.into_parts();\n+            backtrace.print_backtrace();\n+            panic!(\"Miri initialization error: {kind:?}\")\n         }\n     };\n "}, {"sha": "befdddfa8c901bdcb422e3a0bb763253cb0de7fe", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -162,11 +162,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let instance = this.resolve_path(path, Namespace::ValueNS);\n         let cid = GlobalId { instance, promoted: None };\n         // We don't give a span -- this isn't actually used directly by the program anyway.\n-        let const_val = this\n-            .eval_global(cid, None)\n-            .unwrap_or_else(|err| panic!(\"failed to evaluate required Rust item: {path:?}\\n{err}\"));\n+        let const_val = this.eval_global(cid, None).unwrap_or_else(|err| {\n+            panic!(\"failed to evaluate required Rust item: {path:?}\\n{err:?}\")\n+        });\n         this.read_scalar(&const_val.into())\n-            .unwrap_or_else(|err| panic!(\"failed to read required Rust item: {path:?}\\n{err}\"))\n+            .unwrap_or_else(|err| panic!(\"failed to read required Rust item: {path:?}\\n{err:?}\"))\n     }\n \n     /// Helper function to get a `libc` constant as a `Scalar`."}, {"sha": "f711f01f3233c08f2a19cfc321f41f3cbbd39b4b", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -43,6 +43,7 @@\n \n extern crate rustc_apfloat;\n extern crate rustc_ast;\n+extern crate rustc_errors;\n #[macro_use]\n extern crate rustc_middle;\n extern crate rustc_const_eval;"}, {"sha": "9c73bdc17bebc6afbf98b7d397864199dbd4440d", "filename": "src/tools/miri/tests/fail/intrinsics/copy_overlapping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -10,6 +10,6 @@ fn main() {\n     unsafe {\n         let a = data.as_mut_ptr();\n         let b = a.wrapping_offset(1) as *mut _;\n-        copy_nonoverlapping(a, b, 2); //~ ERROR: copy_nonoverlapping called on overlapping ranges\n+        copy_nonoverlapping(a, b, 2); //~ ERROR: `copy_nonoverlapping` called on overlapping ranges\n     }\n }"}, {"sha": "13a76aae730450c98c105ca423880a262fe2ec78", "filename": "src/tools/miri/tests/fail/intrinsics/copy_overlapping.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fcopy_overlapping.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: copy_nonoverlapping called on overlapping ranges\n+error: Undefined Behavior: `copy_nonoverlapping` called on overlapping ranges\n   --> $DIR/copy_overlapping.rs:LL:CC\n    |\n LL |         copy_nonoverlapping(a, b, 2);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ copy_nonoverlapping called on overlapping ranges\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `copy_nonoverlapping` called on overlapping ranges\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "0b9cda62b33c2f1afc9a6a6fac62909d0dd8954e", "filename": "src/tools/miri/tests/fail/intrinsics/ptr_offset_from_oob.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fptr_offset_from_oob.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fptr_offset_from_oob.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fptr_offset_from_oob.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: out-of-bounds offset_from: ALLOC has size 4, so pointer at offset 10 is out-of-bounds\n+error: Undefined Behavior: out-of-bounds `offset_from`: ALLOC has size 4, so pointer at offset 10 is out-of-bounds\n   --> $DIR/ptr_offset_from_oob.rs:LL:CC\n    |\n LL |     unsafe { end_ptr.offset_from(end_ptr) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: ALLOC has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: ALLOC has size 4, so pointer at offset 10 is out-of-bounds\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "40ba31dad8f68eebcfd33b78ace19b5d124a2a9c", "filename": "src/tools/miri/tests/fail/modifying_constants.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmodifying_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmodifying_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmodifying_constants.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,6 +1,8 @@\n // This should fail even without validation/SB\n //@compile-flags: -Zmiri-disable-validation -Zmiri-disable-stacked-borrows\n \n+#![allow(cast_ref_to_mut)]\n+\n fn main() {\n     let x = &1; // the `&1` is promoted to a constant, but it used to be that only the pointer is marked static, not the pointee\n     let y = unsafe { &mut *(x as *const i32 as *mut i32) };"}, {"sha": "8cd59b3550dc965d99b1a46611bb54206ad492d9", "filename": "src/tools/miri/tests/fail/stacked_borrows/shr_frozen_violation1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,3 +1,5 @@\n+#![allow(cast_ref_to_mut)]\n+\n fn foo(x: &mut i32) -> i32 {\n     *x = 5;\n     unknown_code(&*x);"}, {"sha": "142b12290194e8a6830534bee92aabcf74bc2134", "filename": "src/tools/rust-analyzer/crates/hir-def/src/builtin_attr.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -195,10 +195,6 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Limits:\n     ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), FutureWarnFollowing),\n     ungated!(type_length_limit, CrateLevel, template!(NameValueStr: \"N\"), FutureWarnFollowing),\n-    gated!(\n-        const_eval_limit, CrateLevel, template!(NameValueStr: \"N\"), ErrorFollowing,\n-        const_eval_limit, experimental!(const_eval_limit)\n-    ),\n     gated!(\n         move_size_limit, CrateLevel, template!(NameValueStr: \"N\"), ErrorFollowing,\n         large_assignments, experimental!(move_size_limit)"}, {"sha": "01e5a00af4a23a69de2be5107810836b0ba7fcc6", "filename": "src/tools/rust-installer/combine-installers.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Frust-installer%2Fcombine-installers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Frust-installer%2Fcombine-installers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fcombine-installers.sh?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -11,5 +11,9 @@ abs_path() {\n     (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n }\n \n+# Running cargo will read the libstd Cargo.toml\n+# which uses the unstable `public-dependency` feature.\n+export RUSTC_BOOTSTRAP=1\n+\n src_dir=\"$(abs_path $(dirname \"$0\"))\"\n $CARGO run --manifest-path=\"$src_dir/Cargo.toml\" -- combine \"$@\""}, {"sha": "cc45b5e0803f762137005a51ce8e959dc4ab2ff5", "filename": "src/tools/rust-installer/gen-installer.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Frust-installer%2Fgen-installer.sh", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Frust-installer%2Fgen-installer.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fgen-installer.sh?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -11,5 +11,9 @@ abs_path() {\n     (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n }\n \n+# Running cargo will read the libstd Cargo.toml\n+# which uses the unstable `public-dependency` feature.\n+export RUSTC_BOOTSTRAP=1\n+\n src_dir=\"$(abs_path $(dirname \"$0\"))\"\n $CARGO run --manifest-path=\"$src_dir/Cargo.toml\" -- generate \"$@\""}, {"sha": "374e103e89ca618e684514fa3d9b1c2fee3f2417", "filename": "src/tools/rust-installer/make-tarballs.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Frust-installer%2Fmake-tarballs.sh", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Frust-installer%2Fmake-tarballs.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fmake-tarballs.sh?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -11,5 +11,9 @@ abs_path() {\n     (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n }\n \n+# Running cargo will read the libstd Cargo.toml\n+# which uses the unstable `public-dependency` feature.\n+export RUSTC_BOOTSTRAP=1\n+\n src_dir=\"$(abs_path $(dirname \"$0\"))\"\n $CARGO run --manifest-path=\"$src_dir/Cargo.toml\" -- tarball \"$@\""}, {"sha": "e21068490b61a501c7c8177db819c60af7d58488", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -16,6 +16,12 @@ use std::sync::atomic::{AtomicBool, Ordering};\n use std::thread::{self, scope, ScopedJoinHandle};\n \n fn main() {\n+    // Running Cargo will read the libstd Cargo.toml\n+    // which uses the unstable `public-dependency` feature.\n+    //\n+    // `setenv` might not be thread safe, so run it before using multiple threads.\n+    env::set_var(\"RUSTC_BOOTSTRAP\", \"1\");\n+\n     let root_path: PathBuf = env::args_os().nth(1).expect(\"need path to root of repo\").into();\n     let cargo: PathBuf = env::args_os().nth(2).expect(\"need path to cargo\").into();\n     let output_directory: PathBuf ="}, {"sha": "27469b22980ab45b124c4fea66f7f0a8538aff3b", "filename": "tests/assembly/asm/mips-types.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fassembly%2Fasm%2Fmips-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fassembly%2Fasm%2Fmips-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fasm%2Fmips-types.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -72,7 +72,7 @@ macro_rules! check_reg { ($func:ident, $ty:ty, $reg:tt, $mov:literal) => {\n \n // mips32-LABEL: sym_static_32:\n // mips32: #APP\n-// mips32: lw $3, %got(extern_static)\n+// mips32: lw $3, %got(extern_static)($gp)\n // mips32: #NO_APP\n #[cfg(mips32)]\n #[no_mangle]\n@@ -82,7 +82,7 @@ pub unsafe fn sym_static_32() {\n \n // mips32-LABEL: sym_fn_32:\n // mips32: #APP\n-// mips32: lw $3, %got(extern_func)\n+// mips32: lw $3, %got(extern_func)($gp)\n // mips32: #NO_APP\n #[cfg(mips32)]\n #[no_mangle]\n@@ -92,7 +92,9 @@ pub unsafe fn sym_fn_32() {\n \n // mips64-LABEL: sym_static_64:\n // mips64: #APP\n-// mips64: ld $3, %got_disp(extern_static)\n+// mips64: lui    $3, %got_hi(extern_static)\n+// mips64: daddu  $3, $3, $gp\n+// mips64: ld     $3, %got_lo(extern_static)($3)\n // mips64: #NO_APP\n #[cfg(mips64)]\n #[no_mangle]\n@@ -102,7 +104,9 @@ pub unsafe fn sym_static_64() {\n \n // mips64-LABEL: sym_fn_64:\n // mips64: #APP\n-// mips64: ld $3, %got_disp(extern_func)\n+// mips64: lui    $3, %got_hi(extern_func)\n+// mips64: daddu  $3, $3, $gp\n+// mips64: ld     $3, %got_lo(extern_func)($3)\n // mips64: #NO_APP\n #[cfg(mips64)]\n #[no_mangle]"}, {"sha": "aa4cf7a64d5ca07f84babf9e9cce77b11ea7c0fd", "filename": "tests/codegen/const_scalar_pair.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fcodegen%2Fconst_scalar_pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fcodegen%2Fconst_scalar_pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fconst_scalar_pair.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -2,6 +2,8 @@\n \n #![feature(inline_const)]\n \n+// Test that we don't generate a memory allocation for the constant\n+// and read the fields from that, but instead just create the value pair directly.\n pub fn foo() -> (i32, i32) {\n     // CHECK: ret { i32, i32 } { i32 1, i32 2 }\n     const { (1, 2) }"}, {"sha": "fe42494000e1704bd40c95d262195428e3cad26b", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -14,10 +14,10 @@ use std::intrinsics::{transmute, transmute_unchecked};\n // Some of these need custom MIR to not get removed by MIR optimizations.\n use std::intrinsics::mir::*;\n \n-enum Never {}\n+pub enum ZstNever {}\n \n #[repr(align(2))]\n-pub struct BigNever(Never, u16, Never);\n+pub struct BigNever(ZstNever, u16, ZstNever);\n \n #[repr(align(8))]\n pub struct Scalar64(i64);\n@@ -56,11 +56,13 @@ pub unsafe fn check_bigger_array(x: [u32; 3]) -> [u32; 7] {\n     transmute_unchecked(x)\n }\n \n-// CHECK-LABEL: @check_to_uninhabited(\n+// CHECK-LABEL: @check_to_empty_array(\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n-pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n+pub unsafe fn check_to_empty_array(x: [u32; 5]) -> [u32; 0] {\n+    // CHECK-NOT: trap\n     // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n     mir!{\n         {\n             RET = CastTransmute(x);\n@@ -69,6 +71,37 @@ pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n     }\n }\n \n+// CHECK-LABEL: @check_from_empty_array(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_from_empty_array(x: [u32; 0]) -> [u32; 5] {\n+    // CHECK-NOT: trap\n+    // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_to_uninhabited(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_to_uninhabited(x: u16) {\n+    // CHECK-NOT: trap\n+    // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n+    mir!{\n+        let temp: BigNever;\n+        {\n+            temp = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n // CHECK-LABEL: @check_from_uninhabited(\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n@@ -366,6 +399,40 @@ pub unsafe fn check_issue_109992(x: ()) -> [(); 1] {\n     }\n }\n \n+// CHECK-LABEL: @check_unit_to_never(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_unit_to_never(x: ()) {\n+    // This uses custom MIR to avoid MIR optimizations having removed ZST ops.\n+\n+    // CHECK-NOT: trap\n+    // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n+    mir!{\n+        let temp: ZstNever;\n+        {\n+            temp = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_unit_from_never(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_unit_from_never(x: ZstNever) -> () {\n+    // This uses custom MIR to avoid MIR optimizations having removed ZST ops.\n+\n+    // CHECK: start\n+    // CHECK-NEXT: ret void\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n // CHECK-LABEL: @check_maybe_uninit_pair(i16 %x.0, i64 %x.1)\n #[no_mangle]\n pub unsafe fn check_maybe_uninit_pair("}, {"sha": "6e0eacfe4002905c2e694dc5bfb8a3266a666a0f", "filename": "tests/codegen/issues/issue-105386-ub-in-debuginfo.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fcodegen%2Fissues%2Fissue-105386-ub-in-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fcodegen%2Fissues%2Fissue-105386-ub-in-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-105386-ub-in-debuginfo.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,4 +1,5 @@\n-// compile-flags: --crate-type=lib -O -Cdebuginfo=2 -Cno-prepopulate-passes\n+// compile-flags: --crate-type=lib -O -Cdebuginfo=2 -Cno-prepopulate-passes -Zmir-enable-passes=-ScalarReplacementOfAggregates\n+// MIR SROA will decompose the closure\n // min-llvm-version: 15.0 # this test uses opaque pointer notation\n #![feature(stmt_expr_attributes)]\n \n@@ -15,8 +16,8 @@ pub fn outer_function(x: S, y: S) -> usize {\n // Check that we do not attempt to load from the spilled arg before it is assigned to\n // when generating debuginfo.\n // CHECK-LABEL: @outer_function\n-// CHECK: [[spill:%.*]] = alloca %\"[closure@{{.*.rs}}:9:23: 9:25]\"\n-// CHECK-NOT: [[ptr_tmp:%.*]] = getelementptr inbounds %\"[closure@{{.*.rs}}:9:23: 9:25]\", ptr [[spill]]\n+// CHECK: [[spill:%.*]] = alloca %\"[closure@{{.*.rs}}:10:23: 10:25]\"\n+// CHECK-NOT: [[ptr_tmp:%.*]] = getelementptr inbounds %\"[closure@{{.*.rs}}:10:23: 10:25]\", ptr [[spill]]\n // CHECK-NOT: [[load:%.*]] = load ptr, ptr\n // CHECK: call void @llvm.lifetime.start{{.*}}({{.*}}, ptr [[spill]])\n // CHECK: [[inner:%.*]] = getelementptr inbounds %\"{{.*}}\", ptr [[spill]]"}, {"sha": "ecb19480d6547112e90a30cfd9bb0be27e64beeb", "filename": "tests/incremental/hashes/match_expressions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fincremental%2Fhashes%2Fmatch_expressions.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -225,8 +225,9 @@ pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n     }\n }\n \n+// Ignore optimized_mir in cfail2, the only change to optimized MIR is a span.\n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner_nodes,typeck\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[rustc_clean(cfg=\"cfail5\", except=\"hir_owner_nodes,optimized_mir,typeck\")]\n #[rustc_clean(cfg=\"cfail6\")]"}, {"sha": "39373da6a9f605ae7a52f85d7d9306f1d6b7b43e", "filename": "tests/incremental/issue-101518.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fincremental%2Fissue-101518.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fincremental%2Fissue-101518.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fincremental%2Fissue-101518.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,27 +1,20 @@\n-// revisions: cfail1\n-// should-ice\n-// error-pattern: forcing query\n-// known-bug: #101518\n+// revisions: cpass\n \n #[derive(PartialEq, Eq)]\n struct Id<'a> {\n     ns: &'a str,\n }\n fn visit_struct() {\n     let id = Id { ns: \"random1\" };\n-    const FLAG: Id<'static> = Id {\n-        ns: \"needs_to_be_the_same\",\n-    };\n+    const FLAG: Id<'static> = Id { ns: \"needs_to_be_the_same\" };\n     match id {\n         FLAG => {}\n         _ => {}\n     }\n }\n fn visit_struct2() {\n     let id = Id { ns: \"random2\" };\n-    const FLAG: Id<'static> = Id {\n-        ns: \"needs_to_be_the_same\",\n-    };\n+    const FLAG: Id<'static> = Id { ns: \"needs_to_be_the_same\" };\n     match id {\n         FLAG => {}\n         _ => {}"}, {"sha": "61ce5e54fdc1af550914715deb88b9e8d3447aff", "filename": "tests/mir-opt/deref-patterns/string.foo.PreCodegen.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -35,7 +35,7 @@ fn foo(_1: Option<String>) -> i32 {\n                                          // + literal: Const { ty: for<'a, 'b> fn(&'a str, &'b str) -> bool {<str as PartialEq>::eq}, val: Value(<ZST>) }\n                                          // mir::Constant\n                                          // + span: $DIR/string.rs:9:14: 9:17\n-                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }\n+                                         // + literal: Const { ty: &str, val: Value(ValTree::Branch(..)) }\n     }\n \n     bb3: {"}, {"sha": "e82e3f1881153f4217b22e53e1b5a1841015413d", "filename": "tests/mir-opt/inline/unchecked_shifts.unchecked_shl_unsigned_smaller.Inline.diff", "status": "modified", "additions": 44, "deletions": 52, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.Inline.diff?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -11,35 +11,33 @@\n +         debug self => _3;                // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n +         debug rhs => _4;                 // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n +         let mut _5: u16;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         let mut _6: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         let mut _7: u32;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n +         scope 2 {\n +             scope 3 (inlined core::num::<impl u16>::unchecked_shl::conv) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                 debug x => _7;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                 let mut _8: std::option::Option<u16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                 let mut _9: std::result::Result<u16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++                 debug x => _4;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++                 let mut _6: std::option::Option<u16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++                 let mut _7: std::result::Result<u16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n +                 scope 4 {\n +                     scope 5 (inlined <u32 as TryInto<u16>>::try_into) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                         debug self => _7; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n++                         debug self => _4; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n +                         scope 6 (inlined convert::num::<impl TryFrom<u32> for u16>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-+                             debug u => _7; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                             let mut _10: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                             let mut _11: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                             let mut _12: u16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++                             debug u => _4; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++                             let mut _8: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++                             let mut _9: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++                             let mut _10: u16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n +                         }\n +                     }\n +                     scope 7 (inlined Result::<u16, TryFromIntError>::ok) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                         debug self => _9; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                         let mut _13: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                         let _14: u16;    // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++                         debug self => _7; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++                         let mut _11: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++                         let _12: u16;    // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n +                         scope 8 {\n-+                             debug x => _14; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n++                             debug x => _12; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n +                         }\n +                     }\n +                     scope 9 (inlined #[track_caller] Option::<u16>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                         debug self => _8; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                         let mut _15: &std::option::Option<u16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                         let mut _16: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++                         debug self => _6; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++                         let mut _13: &std::option::Option<u16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++                         let mut _14: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n +                         scope 10 {\n +                             debug val => _5; // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n +                         }\n@@ -52,7 +50,7 @@\n +                             }\n +                         }\n +                         scope 12 (inlined Option::<u16>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-+                             debug self => _15; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n++                             debug self => _13; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n +                         }\n +                     }\n +                 }\n@@ -70,18 +68,14 @@\n -                                          // + span: $DIR/unchecked_shifts.rs:11:7: 11:20\n -                                          // + literal: Const { ty: unsafe fn(u16, u32) -> u16 {core::num::<impl u16>::unchecked_shl}, val: Value(<ZST>) }\n +         StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_6);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         _6 = (_4,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_7);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         _7 = move (_6.0: u32);           // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageLive(_11);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _11 = const 65535_u32;           // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _10 = Gt(_7, move _11);          // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageDead(_11);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         switchInt(move _10) -> [0: bb3, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageLive(_8);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageLive(_9);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         _9 = const 65535_u32;            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         _8 = Gt(_4, move _9);            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageDead(_9);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         switchInt(move _8) -> [0: bb3, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n       }\n   \n       bb1: {\n@@ -92,30 +86,30 @@\n +     }\n + \n +     bb2: {\n-+         _9 = Result::<u16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         _7 = Result::<u16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n +                                          // mir::Constant\n +                                          // + span: no-location\n +                                          // + literal: Const { ty: TryFromIntError, val: Value(<ZST>) }\n +         goto -> bb4;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n +     }\n + \n +     bb3: {\n-+         StorageLive(_12);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _12 = _7 as u16 (IntToInt);      // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _9 = Result::<u16, TryFromIntError>::Ok(move _12); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageDead(_12);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageLive(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         _10 = _4 as u16 (IntToInt);      // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         _7 = Result::<u16, TryFromIntError>::Ok(move _10); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageDead(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n +         goto -> bb4;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n +     }\n + \n +     bb4: {\n-+         StorageDead(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         _13 = discriminant(_9);          // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         switchInt(move _13) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++         StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageLive(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _11 = discriminant(_7);          // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++         switchInt(move _11) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n +     }\n + \n +     bb5: {\n-+         _8 = Option::<u16>::None;        // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++         _6 = Option::<u16>::None;        // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n +         goto -> bb8;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n +     }\n + \n@@ -124,25 +118,23 @@\n +     }\n + \n +     bb7: {\n-+         _14 = move ((_9 as Ok).0: u16);  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         _8 = Option::<u16>::Some(move _14); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n++         _12 = move ((_7 as Ok).0: u16);  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++         _6 = Option::<u16>::Some(move _12); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n +         goto -> bb8;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n +     }\n + \n +     bb8: {\n-+         StorageDead(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_15);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         _16 = discriminant(_8);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+         switchInt(move _16) -> [1: bb9, otherwise: bb6]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++         StorageDead(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageLive(_13);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _14 = discriminant(_6);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++         switchInt(move _14) -> [1: bb9, otherwise: bb6]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n +     }\n + \n +     bb9: {\n-+         _5 = move ((_8 as Some).0: u16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+         StorageDead(_15);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageDead(_7);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageDead(_6);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _5 = move ((_6 as Some).0: u16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++         StorageDead(_13);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n +         _0 = unchecked_shl::<u16>(_3, move _5) -> [return: bb1, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n +                                          // mir::Constant\n +                                          // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL"}, {"sha": "8fa4fdaa49aed488a982b5c26e9eaf811d5515c0", "filename": "tests/mir-opt/inline/unchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shl_unsigned_smaller.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -7,38 +7,36 @@ fn unchecked_shl_unsigned_smaller(_1: u16, _2: u32) -> u16 {\n     scope 1 (inlined core::num::<impl u16>::unchecked_shl) { // at $DIR/unchecked_shifts.rs:11:7: 11:23\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n         debug rhs => _2;                 // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n-        let mut _3: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        let mut _4: u32;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        let mut _13: u16;                // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        let mut _11: u16;                // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         scope 2 {\n             scope 3 (inlined core::num::<impl u16>::unchecked_shl::conv) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                debug x => _4;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                let mut _8: std::result::Result<u16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                let mut _11: std::option::Option<u16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                debug x => _2;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                let mut _6: std::result::Result<u16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                let mut _9: std::option::Option<u16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n                 scope 4 {\n                     scope 5 (inlined <u32 as TryInto<u16>>::try_into) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _4; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                        debug self => _2; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n                         scope 6 (inlined convert::num::<impl TryFrom<u32> for u16>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                            debug u => _4; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _5: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _6: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _7: u16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            debug u => _2; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _3: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _4: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _5: u16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n                         }\n                     }\n                     scope 7 (inlined Result::<u16, TryFromIntError>::ok) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _8; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-                        let mut _9: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-                        let _10: u16;    // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        debug self => _6; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        let mut _7: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        let _8: u16;     // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n                         scope 8 {\n-                            debug x => _10; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+                            debug x => _8; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n                         }\n                     }\n                     scope 9 (inlined #[track_caller] Option::<u16>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _11; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                        let mut _12: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                        let mut _14: &std::option::Option<u16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        debug self => _9; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        let mut _10: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        let mut _12: &std::option::Option<u16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n                         scope 10 {\n-                            debug val => _13; // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n+                            debug val => _11; // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n                         }\n                         scope 11 {\n                             scope 13 (inlined unreachable_unchecked) { // at $SRC_DIR/core/src/option.rs:LL:COL\n@@ -49,7 +47,7 @@ fn unchecked_shl_unsigned_smaller(_1: u16, _2: u32) -> u16 {\n                             }\n                         }\n                         scope 12 (inlined Option::<u16>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-                            debug self => _14; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n+                            debug self => _12; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n                         }\n                     }\n                 }\n@@ -58,77 +56,71 @@ fn unchecked_shl_unsigned_smaller(_1: u16, _2: u32) -> u16 {\n     }\n \n     bb0: {\n-        StorageLive(_13);                // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _3 = (_2,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _4 = move (_3.0: u32);           // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_11);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_6);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _5 = const 65535_u32;            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _6 = Gt(_4, move _5);            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        switchInt(move _6) -> [0: bb1, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_11);                // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_4);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_3);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _3 = const 65535_u32;            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _4 = Gt(_2, move _3);            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageDead(_3);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        switchInt(move _4) -> [0: bb1, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb1: {\n-        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _7 = _4 as u16 (IntToInt);       // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _8 = Result::<u16, TryFromIntError>::Ok(move _7); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _5 = _2 as u16 (IntToInt);       // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _6 = Result::<u16, TryFromIntError>::Ok(move _5); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageDead(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n         goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb2: {\n-        _8 = Result::<u16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _6 = Result::<u16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: no-location\n                                          // + literal: Const { ty: TryFromIntError, val: Value(<ZST>) }\n         goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb3: {\n-        StorageDead(_6);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _9 = discriminant(_8);           // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        switchInt(move _9) -> [0: bb4, 1: bb5, otherwise: bb9]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        StorageDead(_4);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _7 = discriminant(_6);           // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        switchInt(move _7) -> [0: bb4, 1: bb5, otherwise: bb9]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb4: {\n-        _10 = move ((_8 as Ok).0: u16);  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _11 = Option::<u16>::Some(move _10); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _8 = move ((_6 as Ok).0: u16);   // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _9 = Option::<u16>::Some(move _8); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n         goto -> bb6;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb5: {\n-        _11 = Option::<u16>::None;       // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _9 = Option::<u16>::None;        // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n         goto -> bb6;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb6: {\n-        StorageDead(_10);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _12 = discriminant(_11);         // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        switchInt(move _12) -> [1: bb7, otherwise: bb9]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _10 = discriminant(_9);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        switchInt(move _10) -> [1: bb7, otherwise: bb9]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n     }\n \n     bb7: {\n-        _13 = move ((_11 as Some).0: u16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageDead(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_11);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _0 = unchecked_shl::<u16>(_1, move _13) -> [return: bb8, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        _11 = move ((_9 as Some).0: u16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _0 = unchecked_shl::<u16>(_1, move _11) -> [return: bb8, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u16, u16) -> u16 {unchecked_shl::<u16>}, val: Value(<ZST>) }\n     }\n \n     bb8: {\n-        StorageDead(_13);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        StorageDead(_11);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n         return;                          // scope 0 at $DIR/unchecked_shifts.rs:+2:2: +2:2\n     }\n "}, {"sha": "f20c7da4747c8590456ab0f9a3494e9a1fd128ab", "filename": "tests/mir-opt/inline/unchecked_shifts.unchecked_shr_signed_smaller.Inline.diff", "status": "modified", "additions": 44, "deletions": 52, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.Inline.diff?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -11,35 +11,33 @@\n +         debug self => _3;                // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n +         debug rhs => _4;                 // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n +         let mut _5: i16;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         let mut _6: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         let mut _7: u32;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n +         scope 2 {\n +             scope 3 (inlined core::num::<impl i16>::unchecked_shr::conv) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                 debug x => _7;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                 let mut _8: std::option::Option<i16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                 let mut _9: std::result::Result<i16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++                 debug x => _4;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++                 let mut _6: std::option::Option<i16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++                 let mut _7: std::result::Result<i16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n +                 scope 4 {\n +                     scope 5 (inlined <u32 as TryInto<i16>>::try_into) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                         debug self => _7; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n++                         debug self => _4; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n +                         scope 6 (inlined convert::num::<impl TryFrom<u32> for i16>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-+                             debug u => _7; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                             let mut _10: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                             let mut _11: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+                             let mut _12: i16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++                             debug u => _4; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++                             let mut _8: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++                             let mut _9: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++                             let mut _10: i16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n +                         }\n +                     }\n +                     scope 7 (inlined Result::<i16, TryFromIntError>::ok) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                         debug self => _9; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                         let mut _13: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-+                         let _14: i16;    // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++                         debug self => _7; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++                         let mut _11: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++                         let _12: i16;    // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n +                         scope 8 {\n-+                             debug x => _14; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n++                             debug x => _12; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n +                         }\n +                     }\n +                     scope 9 (inlined #[track_caller] Option::<i16>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+                         debug self => _8; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                         let mut _15: &std::option::Option<i16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+                         let mut _16: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++                         debug self => _6; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++                         let mut _13: &std::option::Option<i16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++                         let mut _14: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n +                         scope 10 {\n +                             debug val => _5; // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n +                         }\n@@ -52,7 +50,7 @@\n +                             }\n +                         }\n +                         scope 12 (inlined Option::<i16>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-+                             debug self => _15; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n++                             debug self => _13; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n +                         }\n +                     }\n +                 }\n@@ -70,18 +68,14 @@\n -                                          // + span: $DIR/unchecked_shifts.rs:17:7: 17:20\n -                                          // + literal: Const { ty: unsafe fn(i16, u32) -> i16 {core::num::<impl i16>::unchecked_shr}, val: Value(<ZST>) }\n +         StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_6);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         _6 = (_4,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_7);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         _7 = move (_6.0: u32);           // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageLive(_11);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _11 = const 32767_u32;           // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _10 = Gt(_7, move _11);          // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageDead(_11);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         switchInt(move _10) -> [0: bb3, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageLive(_8);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageLive(_9);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         _9 = const 32767_u32;            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         _8 = Gt(_4, move _9);            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageDead(_9);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         switchInt(move _8) -> [0: bb3, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n       }\n   \n       bb1: {\n@@ -92,30 +86,30 @@\n +     }\n + \n +     bb2: {\n-+         _9 = Result::<i16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         _7 = Result::<i16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n +                                          // mir::Constant\n +                                          // + span: no-location\n +                                          // + literal: Const { ty: TryFromIntError, val: Value(<ZST>) }\n +         goto -> bb4;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n +     }\n + \n +     bb3: {\n-+         StorageLive(_12);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _12 = _7 as i16 (IntToInt);      // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         _9 = Result::<i16, TryFromIntError>::Ok(move _12); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageDead(_12);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageLive(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         _10 = _4 as i16 (IntToInt);      // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         _7 = Result::<i16, TryFromIntError>::Ok(move _10); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageDead(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n +         goto -> bb4;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n +     }\n + \n +     bb4: {\n-+         StorageDead(_10);                // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-+         StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         _13 = discriminant(_9);          // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         switchInt(move _13) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++         StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n++         StorageLive(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _11 = discriminant(_7);          // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++         switchInt(move _11) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n +     }\n + \n +     bb5: {\n-+         _8 = Option::<i16>::None;        // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++         _6 = Option::<i16>::None;        // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n +         goto -> bb8;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n +     }\n + \n@@ -124,25 +118,23 @@\n +     }\n + \n +     bb7: {\n-+         _14 = move ((_9 as Ok).0: i16);  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         _8 = Option::<i16>::Some(move _14); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n++         _12 = move ((_7 as Ok).0: i16);  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n++         _6 = Option::<i16>::Some(move _12); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n +         goto -> bb8;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n +     }\n + \n +     bb8: {\n-+         StorageDead(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageLive(_15);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         _16 = discriminant(_8);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+         switchInt(move _16) -> [1: bb9, otherwise: bb6]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++         StorageDead(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageLive(_13);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _14 = discriminant(_6);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++         switchInt(move _14) -> [1: bb9, otherwise: bb6]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n +     }\n + \n +     bb9: {\n-+         _5 = move ((_8 as Some).0: i16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-+         StorageDead(_15);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageDead(_7);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-+         StorageDead(_6);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         _5 = move ((_6 as Some).0: i16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n++         StorageDead(_13);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n++         StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n +         _0 = unchecked_shr::<i16>(_3, move _5) -> [return: bb1, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n +                                          // mir::Constant\n +                                          // + span: $SRC_DIR/core/src/num/int_macros.rs:LL:COL"}, {"sha": "7f737abb9360d494b04f745c8f37b36d40a3e9f4", "filename": "tests/mir-opt/inline/unchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funchecked_shifts.unchecked_shr_signed_smaller.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -7,38 +7,36 @@ fn unchecked_shr_signed_smaller(_1: i16, _2: u32) -> i16 {\n     scope 1 (inlined core::num::<impl i16>::unchecked_shr) { // at $DIR/unchecked_shifts.rs:17:7: 17:23\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n         debug rhs => _2;                 // in scope 1 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n-        let mut _3: (u32,);              // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        let mut _4: u32;                 // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        let mut _13: i16;                // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        let mut _11: i16;                // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         scope 2 {\n             scope 3 (inlined core::num::<impl i16>::unchecked_shr::conv) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                debug x => _4;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                let mut _8: std::result::Result<i16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                let mut _11: std::option::Option<i16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                debug x => _2;           // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                let mut _6: std::result::Result<i16, std::num::TryFromIntError>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                let mut _9: std::option::Option<i16>; // in scope 3 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n                 scope 4 {\n                     scope 5 (inlined <u32 as TryInto<i16>>::try_into) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _4; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                        debug self => _2; // in scope 5 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n                         scope 6 (inlined convert::num::<impl TryFrom<u32> for i16>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-                            debug u => _4; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _5: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _6: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-                            let mut _7: i16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            debug u => _2; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _3: u32; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _4: bool; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+                            let mut _5: i16; // in scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n                         }\n                     }\n                     scope 7 (inlined Result::<i16, TryFromIntError>::ok) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _8; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-                        let mut _9: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-                        let _10: i16;    // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        debug self => _6; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        let mut _7: isize; // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+                        let _8: i16;     // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n                         scope 8 {\n-                            debug x => _10; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+                            debug x => _8; // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n                         }\n                     }\n                     scope 9 (inlined #[track_caller] Option::<i16>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-                        debug self => _11; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                        let mut _12: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-                        let mut _14: &std::option::Option<i16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        debug self => _9; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        let mut _10: isize; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+                        let mut _12: &std::option::Option<i16>; // in scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n                         scope 10 {\n-                            debug val => _13; // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n+                            debug val => _11; // in scope 10 at $SRC_DIR/core/src/option.rs:LL:COL\n                         }\n                         scope 11 {\n                             scope 13 (inlined unreachable_unchecked) { // at $SRC_DIR/core/src/option.rs:LL:COL\n@@ -49,7 +47,7 @@ fn unchecked_shr_signed_smaller(_1: i16, _2: u32) -> i16 {\n                             }\n                         }\n                         scope 12 (inlined Option::<i16>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n-                            debug self => _14; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n+                            debug self => _12; // in scope 12 at $SRC_DIR/core/src/option.rs:LL:COL\n                         }\n                     }\n                 }\n@@ -58,77 +56,71 @@ fn unchecked_shr_signed_smaller(_1: i16, _2: u32) -> i16 {\n     }\n \n     bb0: {\n-        StorageLive(_13);                // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _3 = (_2,);                      // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _4 = move (_3.0: u32);           // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_11);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_6);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _5 = const 32767_u32;            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _6 = Gt(_4, move _5);            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        switchInt(move _6) -> [0: bb1, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_11);                // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_4);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_3);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _3 = const 32767_u32;            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _4 = Gt(_2, move _3);            // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageDead(_3);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        switchInt(move _4) -> [0: bb1, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb1: {\n-        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _7 = _4 as i16 (IntToInt);       // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        _8 = Result::<i16, TryFromIntError>::Ok(move _7); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _5 = _2 as i16 (IntToInt);       // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _6 = Result::<i16, TryFromIntError>::Ok(move _5); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageDead(_5);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n         goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb2: {\n-        _8 = Result::<i16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        _6 = Result::<i16, TryFromIntError>::Err(const TryFromIntError(())); // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: no-location\n                                          // + literal: Const { ty: TryFromIntError, val: Value(<ZST>) }\n         goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n     }\n \n     bb3: {\n-        StorageDead(_6);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n-        StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _9 = discriminant(_8);           // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        switchInt(move _9) -> [0: bb4, 1: bb5, otherwise: bb9]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        StorageDead(_4);                 // scope 6 at $SRC_DIR/core/src/convert/num.rs:LL:COL\n+        StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _7 = discriminant(_6);           // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        switchInt(move _7) -> [0: bb4, 1: bb5, otherwise: bb9]; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb4: {\n-        _10 = move ((_8 as Ok).0: i16);  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-        _11 = Option::<i16>::Some(move _10); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _8 = move ((_6 as Ok).0: i16);   // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _9 = Option::<i16>::Some(move _8); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n         goto -> bb6;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb5: {\n-        _11 = Option::<i16>::None;       // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _9 = Option::<i16>::None;        // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n         goto -> bb6;                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb6: {\n-        StorageDead(_10);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n         StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _12 = discriminant(_11);         // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        switchInt(move _12) -> [1: bb7, otherwise: bb9]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _10 = discriminant(_9);          // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        switchInt(move _10) -> [1: bb7, otherwise: bb9]; // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n     }\n \n     bb7: {\n-        _13 = move ((_11 as Some).0: i16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n-        StorageDead(_14);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_11);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_4);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n-        _0 = unchecked_shr::<i16>(_1, move _13) -> [return: bb8, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n+        _11 = move ((_9 as Some).0: i16); // scope 9 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_12);                // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _0 = unchecked_shr::<i16>(_1, move _11) -> [return: bb8, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(i16, i16) -> i16 {unchecked_shr::<i16>}, val: Value(<ZST>) }\n     }\n \n     bb8: {\n-        StorageDead(_13);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n+        StorageDead(_11);                // scope 2 at $SRC_DIR/core/src/num/int_macros.rs:LL:COL\n         return;                          // scope 0 at $DIR/unchecked_shifts.rs:+2:2: +2:2\n     }\n "}, {"sha": "40ddf82f4cf953828cd30ebcb45b6f7f0fdc9d37", "filename": "tests/mir-opt/pre-codegen/chained_comparison.bitand.PreCodegen.after.mir", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.bitand.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.bitand.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.bitand.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,84 @@\n+// MIR for `bitand` after PreCodegen\n+\n+fn bitand(_1: &Blueprint, _2: &Blueprint) -> bool {\n+    debug a => _1;                       // in scope 0 at $DIR/chained_comparison.rs:+0:15: +0:16\n+    debug b => _2;                       // in scope 0 at $DIR/chained_comparison.rs:+0:30: +0:31\n+    let mut _0: bool;                    // return place in scope 0 at $DIR/chained_comparison.rs:+0:48: +0:52\n+    let mut _3: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+1:6: +1:22\n+    let mut _4: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+1:26: +1:42\n+    let mut _5: bool;                    // in scope 0 at $DIR/chained_comparison.rs:+1:5: +1:43\n+    let mut _6: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+2:12: +2:21\n+    let mut _7: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+2:25: +2:34\n+    let mut _8: bool;                    // in scope 0 at $DIR/chained_comparison.rs:+2:11: +2:35\n+    let mut _9: bool;                    // in scope 0 at $DIR/chained_comparison.rs:+1:5: +2:35\n+    let mut _10: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+3:12: +3:28\n+    let mut _11: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+3:32: +3:48\n+    let mut _12: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+3:11: +3:49\n+    let mut _13: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+1:5: +3:49\n+    let mut _14: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+4:12: +4:25\n+    let mut _15: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+4:29: +4:42\n+    let mut _16: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+4:11: +4:43\n+    let mut _17: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+1:5: +4:43\n+    let mut _18: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+5:12: +5:21\n+    let mut _19: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+5:25: +5:34\n+    let mut _20: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+5:11: +5:35\n+\n+    bb0: {\n+        StorageLive(_17);                // scope 0 at $DIR/chained_comparison.rs:+1:5: +4:43\n+        StorageLive(_13);                // scope 0 at $DIR/chained_comparison.rs:+1:5: +3:49\n+        StorageLive(_9);                 // scope 0 at $DIR/chained_comparison.rs:+1:5: +2:35\n+        StorageLive(_5);                 // scope 0 at $DIR/chained_comparison.rs:+1:5: +1:43\n+        StorageLive(_3);                 // scope 0 at $DIR/chained_comparison.rs:+1:6: +1:22\n+        _3 = ((*_1).0: u32);             // scope 0 at $DIR/chained_comparison.rs:+1:6: +1:22\n+        StorageLive(_4);                 // scope 0 at $DIR/chained_comparison.rs:+1:26: +1:42\n+        _4 = ((*_2).0: u32);             // scope 0 at $DIR/chained_comparison.rs:+1:26: +1:42\n+        _5 = Eq(move _3, move _4);       // scope 0 at $DIR/chained_comparison.rs:+1:5: +1:43\n+        StorageDead(_4);                 // scope 0 at $DIR/chained_comparison.rs:+1:42: +1:43\n+        StorageDead(_3);                 // scope 0 at $DIR/chained_comparison.rs:+1:42: +1:43\n+        StorageLive(_8);                 // scope 0 at $DIR/chained_comparison.rs:+2:11: +2:35\n+        StorageLive(_6);                 // scope 0 at $DIR/chained_comparison.rs:+2:12: +2:21\n+        _6 = ((*_1).1: u32);             // scope 0 at $DIR/chained_comparison.rs:+2:12: +2:21\n+        StorageLive(_7);                 // scope 0 at $DIR/chained_comparison.rs:+2:25: +2:34\n+        _7 = ((*_2).1: u32);             // scope 0 at $DIR/chained_comparison.rs:+2:25: +2:34\n+        _8 = Eq(move _6, move _7);       // scope 0 at $DIR/chained_comparison.rs:+2:11: +2:35\n+        StorageDead(_7);                 // scope 0 at $DIR/chained_comparison.rs:+2:34: +2:35\n+        StorageDead(_6);                 // scope 0 at $DIR/chained_comparison.rs:+2:34: +2:35\n+        _9 = BitAnd(move _5, move _8);   // scope 0 at $DIR/chained_comparison.rs:+1:5: +2:35\n+        StorageDead(_8);                 // scope 0 at $DIR/chained_comparison.rs:+2:34: +2:35\n+        StorageDead(_5);                 // scope 0 at $DIR/chained_comparison.rs:+2:34: +2:35\n+        StorageLive(_12);                // scope 0 at $DIR/chained_comparison.rs:+3:11: +3:49\n+        StorageLive(_10);                // scope 0 at $DIR/chained_comparison.rs:+3:12: +3:28\n+        _10 = ((*_1).2: u32);            // scope 0 at $DIR/chained_comparison.rs:+3:12: +3:28\n+        StorageLive(_11);                // scope 0 at $DIR/chained_comparison.rs:+3:32: +3:48\n+        _11 = ((*_2).2: u32);            // scope 0 at $DIR/chained_comparison.rs:+3:32: +3:48\n+        _12 = Eq(move _10, move _11);    // scope 0 at $DIR/chained_comparison.rs:+3:11: +3:49\n+        StorageDead(_11);                // scope 0 at $DIR/chained_comparison.rs:+3:48: +3:49\n+        StorageDead(_10);                // scope 0 at $DIR/chained_comparison.rs:+3:48: +3:49\n+        _13 = BitAnd(move _9, move _12); // scope 0 at $DIR/chained_comparison.rs:+1:5: +3:49\n+        StorageDead(_12);                // scope 0 at $DIR/chained_comparison.rs:+3:48: +3:49\n+        StorageDead(_9);                 // scope 0 at $DIR/chained_comparison.rs:+3:48: +3:49\n+        StorageLive(_16);                // scope 0 at $DIR/chained_comparison.rs:+4:11: +4:43\n+        StorageLive(_14);                // scope 0 at $DIR/chained_comparison.rs:+4:12: +4:25\n+        _14 = ((*_1).3: u32);            // scope 0 at $DIR/chained_comparison.rs:+4:12: +4:25\n+        StorageLive(_15);                // scope 0 at $DIR/chained_comparison.rs:+4:29: +4:42\n+        _15 = ((*_2).3: u32);            // scope 0 at $DIR/chained_comparison.rs:+4:29: +4:42\n+        _16 = Eq(move _14, move _15);    // scope 0 at $DIR/chained_comparison.rs:+4:11: +4:43\n+        StorageDead(_15);                // scope 0 at $DIR/chained_comparison.rs:+4:42: +4:43\n+        StorageDead(_14);                // scope 0 at $DIR/chained_comparison.rs:+4:42: +4:43\n+        _17 = BitAnd(move _13, move _16); // scope 0 at $DIR/chained_comparison.rs:+1:5: +4:43\n+        StorageDead(_16);                // scope 0 at $DIR/chained_comparison.rs:+4:42: +4:43\n+        StorageDead(_13);                // scope 0 at $DIR/chained_comparison.rs:+4:42: +4:43\n+        StorageLive(_20);                // scope 0 at $DIR/chained_comparison.rs:+5:11: +5:35\n+        StorageLive(_18);                // scope 0 at $DIR/chained_comparison.rs:+5:12: +5:21\n+        _18 = ((*_1).4: u32);            // scope 0 at $DIR/chained_comparison.rs:+5:12: +5:21\n+        StorageLive(_19);                // scope 0 at $DIR/chained_comparison.rs:+5:25: +5:34\n+        _19 = ((*_2).4: u32);            // scope 0 at $DIR/chained_comparison.rs:+5:25: +5:34\n+        _20 = Eq(move _18, move _19);    // scope 0 at $DIR/chained_comparison.rs:+5:11: +5:35\n+        StorageDead(_19);                // scope 0 at $DIR/chained_comparison.rs:+5:34: +5:35\n+        StorageDead(_18);                // scope 0 at $DIR/chained_comparison.rs:+5:34: +5:35\n+        _0 = BitAnd(move _17, move _20); // scope 0 at $DIR/chained_comparison.rs:+1:5: +5:35\n+        StorageDead(_20);                // scope 0 at $DIR/chained_comparison.rs:+5:34: +5:35\n+        StorageDead(_17);                // scope 0 at $DIR/chained_comparison.rs:+5:34: +5:35\n+        return;                          // scope 0 at $DIR/chained_comparison.rs:+6:2: +6:2\n+    }\n+}"}, {"sha": "26ce7fda4ed0198690d7b452aa8ec45eaf21bdea", "filename": "tests/mir-opt/pre-codegen/chained_comparison.naive.PreCodegen.after.mir", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.naive.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.naive.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.naive.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,127 @@\n+// MIR for `naive` after PreCodegen\n+\n+fn naive(_1: &Blueprint, _2: &Blueprint) -> bool {\n+    debug a => _1;                       // in scope 0 at $DIR/chained_comparison.rs:+0:14: +0:15\n+    debug b => _2;                       // in scope 0 at $DIR/chained_comparison.rs:+0:29: +0:30\n+    let mut _0: bool;                    // return place in scope 0 at $DIR/chained_comparison.rs:+0:47: +0:51\n+    let mut _3: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+1:6: +1:22\n+    let mut _4: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+1:26: +1:42\n+    let mut _5: bool;                    // in scope 0 at $DIR/chained_comparison.rs:+1:5: +1:43\n+    let mut _6: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+2:13: +2:22\n+    let mut _7: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+2:26: +2:35\n+    let mut _8: bool;                    // in scope 0 at $DIR/chained_comparison.rs:+2:12: +2:36\n+    let mut _9: bool;                    // in scope 0 at $DIR/chained_comparison.rs:+1:5: +2:36\n+    let mut _10: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+3:13: +3:29\n+    let mut _11: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+3:33: +3:49\n+    let mut _12: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+3:12: +3:50\n+    let mut _13: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+1:5: +3:50\n+    let mut _14: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+4:13: +4:26\n+    let mut _15: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+4:30: +4:43\n+    let mut _16: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+4:12: +4:44\n+    let mut _17: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+1:5: +4:44\n+    let mut _18: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+5:13: +5:22\n+    let mut _19: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+5:26: +5:35\n+    let mut _20: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+5:12: +5:36\n+\n+    bb0: {\n+        StorageLive(_17);                // scope 0 at $DIR/chained_comparison.rs:+1:5: +4:44\n+        StorageLive(_13);                // scope 0 at $DIR/chained_comparison.rs:+1:5: +3:50\n+        StorageLive(_9);                 // scope 0 at $DIR/chained_comparison.rs:+1:5: +2:36\n+        StorageLive(_5);                 // scope 0 at $DIR/chained_comparison.rs:+1:5: +1:43\n+        StorageLive(_3);                 // scope 0 at $DIR/chained_comparison.rs:+1:6: +1:22\n+        _3 = ((*_1).0: u32);             // scope 0 at $DIR/chained_comparison.rs:+1:6: +1:22\n+        StorageLive(_4);                 // scope 0 at $DIR/chained_comparison.rs:+1:26: +1:42\n+        _4 = ((*_2).0: u32);             // scope 0 at $DIR/chained_comparison.rs:+1:26: +1:42\n+        _5 = Eq(move _3, move _4);       // scope 0 at $DIR/chained_comparison.rs:+1:5: +1:43\n+        StorageDead(_4);                 // scope 0 at $DIR/chained_comparison.rs:+1:42: +1:43\n+        StorageDead(_3);                 // scope 0 at $DIR/chained_comparison.rs:+1:42: +1:43\n+        switchInt(move _5) -> [0: bb1, otherwise: bb2]; // scope 0 at $DIR/chained_comparison.rs:+1:5: +2:36\n+    }\n+\n+    bb1: {\n+        StorageDead(_8);                 // scope 0 at $DIR/chained_comparison.rs:+2:35: +2:36\n+        StorageDead(_5);                 // scope 0 at $DIR/chained_comparison.rs:+2:35: +2:36\n+        goto -> bb3;                     // scope 0 at $DIR/chained_comparison.rs:+1:5: +2:36\n+    }\n+\n+    bb2: {\n+        StorageLive(_8);                 // scope 0 at $DIR/chained_comparison.rs:+2:12: +2:36\n+        StorageLive(_6);                 // scope 0 at $DIR/chained_comparison.rs:+2:13: +2:22\n+        _6 = ((*_1).1: u32);             // scope 0 at $DIR/chained_comparison.rs:+2:13: +2:22\n+        StorageLive(_7);                 // scope 0 at $DIR/chained_comparison.rs:+2:26: +2:35\n+        _7 = ((*_2).1: u32);             // scope 0 at $DIR/chained_comparison.rs:+2:26: +2:35\n+        _8 = Eq(move _6, move _7);       // scope 0 at $DIR/chained_comparison.rs:+2:12: +2:36\n+        StorageDead(_7);                 // scope 0 at $DIR/chained_comparison.rs:+2:35: +2:36\n+        StorageDead(_6);                 // scope 0 at $DIR/chained_comparison.rs:+2:35: +2:36\n+        _9 = move _8;                    // scope 0 at $DIR/chained_comparison.rs:+1:5: +2:36\n+        StorageDead(_8);                 // scope 0 at $DIR/chained_comparison.rs:+2:35: +2:36\n+        StorageDead(_5);                 // scope 0 at $DIR/chained_comparison.rs:+2:35: +2:36\n+        switchInt(move _9) -> [0: bb3, otherwise: bb4]; // scope 0 at $DIR/chained_comparison.rs:+1:5: +3:50\n+    }\n+\n+    bb3: {\n+        StorageDead(_12);                // scope 0 at $DIR/chained_comparison.rs:+3:49: +3:50\n+        StorageDead(_9);                 // scope 0 at $DIR/chained_comparison.rs:+3:49: +3:50\n+        goto -> bb5;                     // scope 0 at $DIR/chained_comparison.rs:+1:5: +3:50\n+    }\n+\n+    bb4: {\n+        StorageLive(_12);                // scope 0 at $DIR/chained_comparison.rs:+3:12: +3:50\n+        StorageLive(_10);                // scope 0 at $DIR/chained_comparison.rs:+3:13: +3:29\n+        _10 = ((*_1).2: u32);            // scope 0 at $DIR/chained_comparison.rs:+3:13: +3:29\n+        StorageLive(_11);                // scope 0 at $DIR/chained_comparison.rs:+3:33: +3:49\n+        _11 = ((*_2).2: u32);            // scope 0 at $DIR/chained_comparison.rs:+3:33: +3:49\n+        _12 = Eq(move _10, move _11);    // scope 0 at $DIR/chained_comparison.rs:+3:12: +3:50\n+        StorageDead(_11);                // scope 0 at $DIR/chained_comparison.rs:+3:49: +3:50\n+        StorageDead(_10);                // scope 0 at $DIR/chained_comparison.rs:+3:49: +3:50\n+        _13 = move _12;                  // scope 0 at $DIR/chained_comparison.rs:+1:5: +3:50\n+        StorageDead(_12);                // scope 0 at $DIR/chained_comparison.rs:+3:49: +3:50\n+        StorageDead(_9);                 // scope 0 at $DIR/chained_comparison.rs:+3:49: +3:50\n+        switchInt(move _13) -> [0: bb5, otherwise: bb6]; // scope 0 at $DIR/chained_comparison.rs:+1:5: +4:44\n+    }\n+\n+    bb5: {\n+        StorageDead(_16);                // scope 0 at $DIR/chained_comparison.rs:+4:43: +4:44\n+        StorageDead(_13);                // scope 0 at $DIR/chained_comparison.rs:+4:43: +4:44\n+        goto -> bb7;                     // scope 0 at $DIR/chained_comparison.rs:+1:5: +4:44\n+    }\n+\n+    bb6: {\n+        StorageLive(_16);                // scope 0 at $DIR/chained_comparison.rs:+4:12: +4:44\n+        StorageLive(_14);                // scope 0 at $DIR/chained_comparison.rs:+4:13: +4:26\n+        _14 = ((*_1).3: u32);            // scope 0 at $DIR/chained_comparison.rs:+4:13: +4:26\n+        StorageLive(_15);                // scope 0 at $DIR/chained_comparison.rs:+4:30: +4:43\n+        _15 = ((*_2).3: u32);            // scope 0 at $DIR/chained_comparison.rs:+4:30: +4:43\n+        _16 = Eq(move _14, move _15);    // scope 0 at $DIR/chained_comparison.rs:+4:12: +4:44\n+        StorageDead(_15);                // scope 0 at $DIR/chained_comparison.rs:+4:43: +4:44\n+        StorageDead(_14);                // scope 0 at $DIR/chained_comparison.rs:+4:43: +4:44\n+        _17 = move _16;                  // scope 0 at $DIR/chained_comparison.rs:+1:5: +4:44\n+        StorageDead(_16);                // scope 0 at $DIR/chained_comparison.rs:+4:43: +4:44\n+        StorageDead(_13);                // scope 0 at $DIR/chained_comparison.rs:+4:43: +4:44\n+        switchInt(move _17) -> [0: bb7, otherwise: bb8]; // scope 0 at $DIR/chained_comparison.rs:+1:5: +5:36\n+    }\n+\n+    bb7: {\n+        _0 = const false;                // scope 0 at $DIR/chained_comparison.rs:+1:5: +5:36\n+        goto -> bb9;                     // scope 0 at $DIR/chained_comparison.rs:+1:5: +5:36\n+    }\n+\n+    bb8: {\n+        StorageLive(_20);                // scope 0 at $DIR/chained_comparison.rs:+5:12: +5:36\n+        StorageLive(_18);                // scope 0 at $DIR/chained_comparison.rs:+5:13: +5:22\n+        _18 = ((*_1).4: u32);            // scope 0 at $DIR/chained_comparison.rs:+5:13: +5:22\n+        StorageLive(_19);                // scope 0 at $DIR/chained_comparison.rs:+5:26: +5:35\n+        _19 = ((*_2).4: u32);            // scope 0 at $DIR/chained_comparison.rs:+5:26: +5:35\n+        _20 = Eq(move _18, move _19);    // scope 0 at $DIR/chained_comparison.rs:+5:12: +5:36\n+        StorageDead(_19);                // scope 0 at $DIR/chained_comparison.rs:+5:35: +5:36\n+        StorageDead(_18);                // scope 0 at $DIR/chained_comparison.rs:+5:35: +5:36\n+        _0 = move _20;                   // scope 0 at $DIR/chained_comparison.rs:+1:5: +5:36\n+        goto -> bb9;                     // scope 0 at $DIR/chained_comparison.rs:+1:5: +5:36\n+    }\n+\n+    bb9: {\n+        StorageDead(_20);                // scope 0 at $DIR/chained_comparison.rs:+5:35: +5:36\n+        StorageDead(_17);                // scope 0 at $DIR/chained_comparison.rs:+5:35: +5:36\n+        return;                          // scope 0 at $DIR/chained_comparison.rs:+6:2: +6:2\n+    }\n+}"}, {"sha": "7560e1e26cea9ef8105a48eb4e32410389d1ec8b", "filename": "tests/mir-opt/pre-codegen/chained_comparison.returning.PreCodegen.after.mir", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.returning.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.returning.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.returning.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,126 @@\n+// MIR for `returning` after PreCodegen\n+\n+fn returning(_1: &Blueprint, _2: &Blueprint) -> bool {\n+    debug a => _1;                       // in scope 0 at $DIR/chained_comparison.rs:+0:18: +0:19\n+    debug b => _2;                       // in scope 0 at $DIR/chained_comparison.rs:+0:33: +0:34\n+    let mut _0: bool;                    // return place in scope 0 at $DIR/chained_comparison.rs:+0:51: +0:55\n+    let mut _3: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+1:8: +1:24\n+    let mut _4: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+1:28: +1:44\n+    let mut _5: bool;                    // in scope 0 at $DIR/chained_comparison.rs:+1:8: +1:44\n+    let mut _6: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+4:8: +4:17\n+    let mut _7: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+4:21: +4:30\n+    let mut _8: bool;                    // in scope 0 at $DIR/chained_comparison.rs:+4:8: +4:30\n+    let mut _9: u32;                     // in scope 0 at $DIR/chained_comparison.rs:+7:8: +7:24\n+    let mut _10: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+7:28: +7:44\n+    let mut _11: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+7:8: +7:44\n+    let mut _12: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+10:8: +10:21\n+    let mut _13: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+10:25: +10:38\n+    let mut _14: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+10:8: +10:38\n+    let mut _15: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+13:8: +13:17\n+    let mut _16: u32;                    // in scope 0 at $DIR/chained_comparison.rs:+13:21: +13:30\n+    let mut _17: bool;                   // in scope 0 at $DIR/chained_comparison.rs:+13:8: +13:30\n+\n+    bb0: {\n+        StorageLive(_5);                 // scope 0 at $DIR/chained_comparison.rs:+1:8: +1:44\n+        StorageLive(_3);                 // scope 0 at $DIR/chained_comparison.rs:+1:8: +1:24\n+        _3 = ((*_1).0: u32);             // scope 0 at $DIR/chained_comparison.rs:+1:8: +1:24\n+        StorageLive(_4);                 // scope 0 at $DIR/chained_comparison.rs:+1:28: +1:44\n+        _4 = ((*_2).0: u32);             // scope 0 at $DIR/chained_comparison.rs:+1:28: +1:44\n+        _5 = Ne(move _3, move _4);       // scope 0 at $DIR/chained_comparison.rs:+1:8: +1:44\n+        StorageDead(_4);                 // scope 0 at $DIR/chained_comparison.rs:+1:43: +1:44\n+        StorageDead(_3);                 // scope 0 at $DIR/chained_comparison.rs:+1:43: +1:44\n+        switchInt(move _5) -> [0: bb1, otherwise: bb10]; // scope 0 at $DIR/chained_comparison.rs:+1:8: +1:44\n+    }\n+\n+    bb1: {\n+        StorageDead(_5);                 // scope 0 at $DIR/chained_comparison.rs:+3:5: +3:6\n+        StorageLive(_8);                 // scope 0 at $DIR/chained_comparison.rs:+4:8: +4:30\n+        StorageLive(_6);                 // scope 0 at $DIR/chained_comparison.rs:+4:8: +4:17\n+        _6 = ((*_1).1: u32);             // scope 0 at $DIR/chained_comparison.rs:+4:8: +4:17\n+        StorageLive(_7);                 // scope 0 at $DIR/chained_comparison.rs:+4:21: +4:30\n+        _7 = ((*_2).1: u32);             // scope 0 at $DIR/chained_comparison.rs:+4:21: +4:30\n+        _8 = Ne(move _6, move _7);       // scope 0 at $DIR/chained_comparison.rs:+4:8: +4:30\n+        StorageDead(_7);                 // scope 0 at $DIR/chained_comparison.rs:+4:29: +4:30\n+        StorageDead(_6);                 // scope 0 at $DIR/chained_comparison.rs:+4:29: +4:30\n+        switchInt(move _8) -> [0: bb2, otherwise: bb9]; // scope 0 at $DIR/chained_comparison.rs:+4:8: +4:30\n+    }\n+\n+    bb2: {\n+        StorageDead(_8);                 // scope 0 at $DIR/chained_comparison.rs:+6:5: +6:6\n+        StorageLive(_11);                // scope 0 at $DIR/chained_comparison.rs:+7:8: +7:44\n+        StorageLive(_9);                 // scope 0 at $DIR/chained_comparison.rs:+7:8: +7:24\n+        _9 = ((*_1).2: u32);             // scope 0 at $DIR/chained_comparison.rs:+7:8: +7:24\n+        StorageLive(_10);                // scope 0 at $DIR/chained_comparison.rs:+7:28: +7:44\n+        _10 = ((*_2).2: u32);            // scope 0 at $DIR/chained_comparison.rs:+7:28: +7:44\n+        _11 = Ne(move _9, move _10);     // scope 0 at $DIR/chained_comparison.rs:+7:8: +7:44\n+        StorageDead(_10);                // scope 0 at $DIR/chained_comparison.rs:+7:43: +7:44\n+        StorageDead(_9);                 // scope 0 at $DIR/chained_comparison.rs:+7:43: +7:44\n+        switchInt(move _11) -> [0: bb3, otherwise: bb8]; // scope 0 at $DIR/chained_comparison.rs:+7:8: +7:44\n+    }\n+\n+    bb3: {\n+        StorageDead(_11);                // scope 0 at $DIR/chained_comparison.rs:+9:5: +9:6\n+        StorageLive(_14);                // scope 0 at $DIR/chained_comparison.rs:+10:8: +10:38\n+        StorageLive(_12);                // scope 0 at $DIR/chained_comparison.rs:+10:8: +10:21\n+        _12 = ((*_1).3: u32);            // scope 0 at $DIR/chained_comparison.rs:+10:8: +10:21\n+        StorageLive(_13);                // scope 0 at $DIR/chained_comparison.rs:+10:25: +10:38\n+        _13 = ((*_2).3: u32);            // scope 0 at $DIR/chained_comparison.rs:+10:25: +10:38\n+        _14 = Ne(move _12, move _13);    // scope 0 at $DIR/chained_comparison.rs:+10:8: +10:38\n+        StorageDead(_13);                // scope 0 at $DIR/chained_comparison.rs:+10:37: +10:38\n+        StorageDead(_12);                // scope 0 at $DIR/chained_comparison.rs:+10:37: +10:38\n+        switchInt(move _14) -> [0: bb4, otherwise: bb7]; // scope 0 at $DIR/chained_comparison.rs:+10:8: +10:38\n+    }\n+\n+    bb4: {\n+        StorageDead(_14);                // scope 0 at $DIR/chained_comparison.rs:+12:5: +12:6\n+        StorageLive(_17);                // scope 0 at $DIR/chained_comparison.rs:+13:8: +13:30\n+        StorageLive(_15);                // scope 0 at $DIR/chained_comparison.rs:+13:8: +13:17\n+        _15 = ((*_1).4: u32);            // scope 0 at $DIR/chained_comparison.rs:+13:8: +13:17\n+        StorageLive(_16);                // scope 0 at $DIR/chained_comparison.rs:+13:21: +13:30\n+        _16 = ((*_2).4: u32);            // scope 0 at $DIR/chained_comparison.rs:+13:21: +13:30\n+        _17 = Ne(move _15, move _16);    // scope 0 at $DIR/chained_comparison.rs:+13:8: +13:30\n+        StorageDead(_16);                // scope 0 at $DIR/chained_comparison.rs:+13:29: +13:30\n+        StorageDead(_15);                // scope 0 at $DIR/chained_comparison.rs:+13:29: +13:30\n+        switchInt(move _17) -> [0: bb5, otherwise: bb6]; // scope 0 at $DIR/chained_comparison.rs:+13:8: +13:30\n+    }\n+\n+    bb5: {\n+        StorageDead(_17);                // scope 0 at $DIR/chained_comparison.rs:+15:5: +15:6\n+        _0 = const true;                 // scope 0 at $DIR/chained_comparison.rs:+16:5: +16:9\n+        goto -> bb11;                    // scope 0 at $DIR/chained_comparison.rs:+17:2: +17:2\n+    }\n+\n+    bb6: {\n+        _0 = const false;                // scope 0 at $DIR/chained_comparison.rs:+14:16: +14:21\n+        StorageDead(_17);                // scope 0 at $DIR/chained_comparison.rs:+15:5: +15:6\n+        goto -> bb11;                    // scope 0 at no-location\n+    }\n+\n+    bb7: {\n+        _0 = const false;                // scope 0 at $DIR/chained_comparison.rs:+11:16: +11:21\n+        StorageDead(_14);                // scope 0 at $DIR/chained_comparison.rs:+12:5: +12:6\n+        goto -> bb11;                    // scope 0 at no-location\n+    }\n+\n+    bb8: {\n+        _0 = const false;                // scope 0 at $DIR/chained_comparison.rs:+8:16: +8:21\n+        StorageDead(_11);                // scope 0 at $DIR/chained_comparison.rs:+9:5: +9:6\n+        goto -> bb11;                    // scope 0 at no-location\n+    }\n+\n+    bb9: {\n+        _0 = const false;                // scope 0 at $DIR/chained_comparison.rs:+5:16: +5:21\n+        StorageDead(_8);                 // scope 0 at $DIR/chained_comparison.rs:+6:5: +6:6\n+        goto -> bb11;                    // scope 0 at no-location\n+    }\n+\n+    bb10: {\n+        _0 = const false;                // scope 0 at $DIR/chained_comparison.rs:+2:16: +2:21\n+        StorageDead(_5);                 // scope 0 at $DIR/chained_comparison.rs:+3:5: +3:6\n+        goto -> bb11;                    // scope 0 at no-location\n+    }\n+\n+    bb11: {\n+        return;                          // scope 0 at $DIR/chained_comparison.rs:+17:2: +17:2\n+    }\n+}"}, {"sha": "f7879140f812fadfd26d08a715f538649af7994e", "filename": "tests/mir-opt/pre-codegen/chained_comparison.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fchained_comparison.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,51 @@\n+// compile-flags: -O -Zmir-opt-level=2 -Cdebuginfo=2\n+// ignore-debug\n+\n+#![crate_type = \"lib\"]\n+\n+pub struct Blueprint {\n+    pub fuel_tank_size: u32,\n+    pub payload: u32,\n+    pub wheel_diameter: u32,\n+    pub wheel_width: u32,\n+    pub storage: u32,\n+}\n+\n+pub fn naive(a: &Blueprint, b: &Blueprint) -> bool {\n+    (a.fuel_tank_size == b.fuel_tank_size)\n+        && (a.payload == b.payload)\n+        && (a.wheel_diameter == b.wheel_diameter)\n+        && (a.wheel_width == b.wheel_width)\n+        && (a.storage == b.storage)\n+}\n+\n+pub fn bitand(a: &Blueprint, b: &Blueprint) -> bool {\n+    (a.fuel_tank_size == b.fuel_tank_size)\n+        & (a.payload == b.payload)\n+        & (a.wheel_diameter == b.wheel_diameter)\n+        & (a.wheel_width == b.wheel_width)\n+        & (a.storage == b.storage)\n+}\n+\n+pub fn returning(a: &Blueprint, b: &Blueprint) -> bool {\n+    if a.fuel_tank_size != b.fuel_tank_size {\n+        return false;\n+    }\n+    if a.payload != b.payload {\n+        return false;\n+    }\n+    if a.wheel_diameter != b.wheel_diameter {\n+        return false;\n+    }\n+    if a.wheel_width != b.wheel_width {\n+        return false;\n+    }\n+    if a.storage != b.storage {\n+        return false;\n+    }\n+    true\n+}\n+\n+// EMIT_MIR chained_comparison.naive.PreCodegen.after.mir\n+// EMIT_MIR chained_comparison.bitand.PreCodegen.after.mir\n+// EMIT_MIR chained_comparison.returning.PreCodegen.after.mir"}, {"sha": "55945bbc8fcc092415ad454330522ad6cf70dd53", "filename": "tests/mir-opt/pre-codegen/checked_ops.checked_shl.PreCodegen.after.mir", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchecked_ops.checked_shl.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchecked_ops.checked_shl.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fchecked_ops.checked_shl.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,144 @@\n+// MIR for `checked_shl` after PreCodegen\n+\n+fn checked_shl(_1: u32, _2: u32) -> Option<u32> {\n+    debug x => _1;                       // in scope 0 at $DIR/checked_ops.rs:+0:20: +0:21\n+    debug rhs => _2;                     // in scope 0 at $DIR/checked_ops.rs:+0:28: +0:31\n+    let mut _0: std::option::Option<u32>; // return place in scope 0 at $DIR/checked_ops.rs:+0:41: +0:52\n+    scope 1 (inlined core::num::<impl u32>::checked_shl) { // at $DIR/checked_ops.rs:16:7: 16:23\n+        debug self => _1;                // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        debug rhs => _2;                 // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        let mut _11: u32;                // in scope 1 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        let mut _12: bool;               // in scope 1 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        scope 2 {\n+            debug a => _11;              // in scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+            debug b => _10;              // in scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        }\n+        scope 3 (inlined core::num::<impl u32>::overflowing_shl) { // at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+            debug self => _1;            // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+            debug rhs => _2;             // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+            let mut _9: u32;             // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+            let mut _10: bool;           // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+            scope 4 (inlined core::num::<impl u32>::wrapping_shl) { // at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                debug self => _1;        // in scope 4 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                debug rhs => _2;         // in scope 4 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                let mut _3: u32;         // in scope 4 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                let mut _4: u32;         // in scope 4 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                scope 5 {\n+                    scope 6 (inlined core::num::<impl u32>::unchecked_shl) { // at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                        debug self => _1; // in scope 6 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                        debug rhs => _4; // in scope 6 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                        let mut _8: u32; // in scope 6 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                        scope 7 {\n+                            scope 8 (inlined core::num::<impl u32>::unchecked_shl::conv) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                debug x => _4; // in scope 8 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                let mut _5: std::result::Result<u32, std::convert::Infallible>; // in scope 8 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                let mut _7: std::option::Option<u32>; // in scope 8 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                scope 9 {\n+                                    scope 10 (inlined <u32 as TryInto<u32>>::try_into) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                        debug self => _4; // in scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                                        scope 11 (inlined <u32 as TryFrom<u32>>::try_from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                                            debug value => _4; // in scope 11 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                                            scope 21 (inlined <u32 as Into<u32>>::into) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                                                debug self => _4; // in scope 21 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                                                scope 22 (inlined <u32 as From<u32>>::from) { // at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                                                    debug t => _4; // in scope 22 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                                                }\n+                                            }\n+                                        }\n+                                    }\n+                                    scope 12 (inlined Result::<u32, Infallible>::ok) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                        debug self => _5; // in scope 12 at $SRC_DIR/core/src/result.rs:LL:COL\n+                                        let _6: u32; // in scope 12 at $SRC_DIR/core/src/result.rs:LL:COL\n+                                        scope 13 {\n+                                            debug x => _6; // in scope 13 at $SRC_DIR/core/src/result.rs:LL:COL\n+                                        }\n+                                    }\n+                                    scope 14 (inlined #[track_caller] Option::<u32>::unwrap_unchecked) { // at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                        debug self => _7; // in scope 14 at $SRC_DIR/core/src/option.rs:LL:COL\n+                                        let mut _13: &std::option::Option<u32>; // in scope 14 at $SRC_DIR/core/src/option.rs:LL:COL\n+                                        scope 15 {\n+                                            debug val => _8; // in scope 15 at $SRC_DIR/core/src/option.rs:LL:COL\n+                                        }\n+                                        scope 16 {\n+                                            scope 18 (inlined unreachable_unchecked) { // at $SRC_DIR/core/src/option.rs:LL:COL\n+                                                scope 19 {\n+                                                    scope 20 (inlined unreachable_unchecked::runtime) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                                                    }\n+                                                }\n+                                            }\n+                                        }\n+                                        scope 17 (inlined Option::<u32>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n+                                            debug self => _13; // in scope 17 at $SRC_DIR/core/src/option.rs:LL:COL\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_10);                // scope 0 at $DIR/checked_ops.rs:+1:7: +1:23\n+        StorageLive(_11);                // scope 0 at $DIR/checked_ops.rs:+1:7: +1:23\n+        StorageLive(_9);                 // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        StorageLive(_4);                 // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        StorageLive(_3);                 // scope 5 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        _3 = const 31_u32;               // scope 5 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        _4 = BitAnd(_2, move _3);        // scope 5 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        StorageDead(_3);                 // scope 5 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        StorageLive(_8);                 // scope 7 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_7);                 // scope 9 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_5);                 // scope 9 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _5 = Result::<u32, Infallible>::Ok(_4); // scope 11 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+        StorageLive(_6);                 // scope 9 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _6 = move ((_5 as Ok).0: u32);   // scope 12 at $SRC_DIR/core/src/result.rs:LL:COL\n+        _7 = Option::<u32>::Some(move _6); // scope 13 at $SRC_DIR/core/src/result.rs:LL:COL\n+        StorageDead(_6);                 // scope 9 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_5);                 // scope 9 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageLive(_13);                // scope 9 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _8 = move ((_7 as Some).0: u32); // scope 14 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_13);                // scope 9 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        StorageDead(_7);                 // scope 9 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _9 = unchecked_shl::<u32>(_1, move _8) -> [return: bb1, unwind unreachable]; // scope 7 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32, u32) -> u32 {unchecked_shl::<u32>}, val: Value(<ZST>) }\n+    }\n+\n+    bb1: {\n+        StorageDead(_8);                 // scope 7 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        StorageDead(_4);                 // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        _10 = Ge(_2, const _);           // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        _11 = move _9;                   // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        StorageDead(_9);                 // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        StorageLive(_12);                // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+        _12 = unlikely(_10) -> [return: bb2, unwind unreachable]; // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/num/mod.rs:LL:COL\n+                                         // + literal: Const { ty: extern \"rust-intrinsic\" fn(bool) -> bool {unlikely}, val: Value(<ZST>) }\n+    }\n+\n+    bb2: {\n+        switchInt(move _12) -> [0: bb3, otherwise: bb4]; // scope 2 at $SRC_DIR/core/src/num/mod.rs:LL:COL\n+    }\n+\n+    bb3: {\n+        _0 = Option::<u32>::Some(_11);   // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        goto -> bb5;                     // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+    }\n+\n+    bb4: {\n+        _0 = Option::<u32>::None;        // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        goto -> bb5;                     // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+    }\n+\n+    bb5: {\n+        StorageDead(_12);                // scope 2 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        StorageDead(_11);                // scope 0 at $DIR/checked_ops.rs:+1:7: +1:23\n+        StorageDead(_10);                // scope 0 at $DIR/checked_ops.rs:+1:7: +1:23\n+        return;                          // scope 0 at $DIR/checked_ops.rs:+2:2: +2:2\n+    }\n+}"}, {"sha": "dee43b0c6f885052a1855f3a3e91d96659af6453", "filename": "tests/mir-opt/pre-codegen/checked_ops.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchecked_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchecked_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fchecked_ops.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -O -Zmir-opt-level=2 -Cdebuginfo=2\n+// needs-unwind\n+// ignore-debug\n+// only-x86_64\n+\n+#![crate_type = \"lib\"]\n+#![feature(step_trait)]\n+\n+// EMIT_MIR checked_ops.step_forward.PreCodegen.after.mir\n+pub fn step_forward(x: u32, n: usize) -> u32 {\n+    std::iter::Step::forward(x, n)\n+}\n+\n+// EMIT_MIR checked_ops.checked_shl.PreCodegen.after.mir\n+pub fn checked_shl(x: u32, rhs: u32) -> Option<u32> {\n+    x.checked_shl(rhs)\n+}"}, {"sha": "78f68e8ffe67440f0106d87761481c993a35aea0", "filename": "tests/mir-opt/pre-codegen/checked_ops.step_forward.PreCodegen.after.mir", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchecked_ops.step_forward.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fchecked_ops.step_forward.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fchecked_ops.step_forward.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,64 @@\n+// MIR for `step_forward` after PreCodegen\n+\n+fn step_forward(_1: u32, _2: usize) -> u32 {\n+    debug x => _1;                       // in scope 0 at $DIR/checked_ops.rs:+0:21: +0:22\n+    debug n => _2;                       // in scope 0 at $DIR/checked_ops.rs:+0:29: +0:30\n+    let mut _0: u32;                     // return place in scope 0 at $DIR/checked_ops.rs:+0:42: +0:45\n+    scope 1 (inlined <u32 as Step>::forward) { // at $DIR/checked_ops.rs:11:5: 11:35\n+        debug start => _1;               // in scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        debug n => _2;                   // in scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        let _3: std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        let mut _4: &std::option::Option<u32>; // in scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        let mut _7: bool;                // in scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        let mut _8: u32;                 // in scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        scope 2 {\n+        }\n+        scope 3 (inlined Option::<u32>::is_none) { // at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            debug self => _4;            // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+            let mut _6: bool;            // in scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+            scope 4 (inlined Option::<u32>::is_some) { // at $SRC_DIR/core/src/option.rs:LL:COL\n+                debug self => _4;        // in scope 4 at $SRC_DIR/core/src/option.rs:LL:COL\n+                let mut _5: isize;       // in scope 4 at $SRC_DIR/core/src/option.rs:LL:COL\n+            }\n+        }\n+        scope 5 (inlined core::num::<impl u32>::wrapping_add) { // at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            debug self => _1;            // in scope 5 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+            debug rhs => _8;             // in scope 5 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_7);                 // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_4);                 // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_3);                 // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _3 = <u32 as Step>::forward_checked(_1, _2) -> bb1; // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // + literal: Const { ty: fn(u32, usize) -> Option<u32> {<u32 as Step>::forward_checked}, val: Value(<ZST>) }\n+    }\n+\n+    bb1: {\n+        _4 = &_3;                        // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        _5 = discriminant((*_4));        // scope 4 at $SRC_DIR/core/src/option.rs:LL:COL\n+        _6 = Eq(_5, const 1_isize);      // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _7 = Not(move _6);               // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        StorageDead(_3);                 // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_4);                 // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        switchInt(move _7) -> [0: bb3, otherwise: bb2]; // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb2: {\n+        assert(!const true, \"attempt to compute `{} + {}`, which would overflow\", const _, const 1_u32) -> bb3; // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb3: {\n+        StorageDead(_7);                 // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_8);                 // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _8 = _2 as u32 (IntToInt);       // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _0 = Add(_1, _8);                // scope 5 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+        StorageDead(_8);                 // scope 1 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        return;                          // scope 0 at $DIR/checked_ops.rs:+2:2: +2:2\n+    }\n+}"}, {"sha": "dce9feddfc570842eaf0c0f50a41804346187c8a", "filename": "tests/mir-opt/pre-codegen/loops.filter_mapped.PreCodegen.after.mir", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Floops.filter_mapped.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Floops.filter_mapped.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Floops.filter_mapped.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,102 @@\n+// MIR for `filter_mapped` after PreCodegen\n+\n+fn filter_mapped(_1: impl Iterator<Item = T>, _2: impl Fn(T) -> Option<U>) -> () {\n+    debug iter => _1;                    // in scope 0 at $DIR/loops.rs:+0:28: +0:32\n+    debug f => _2;                       // in scope 0 at $DIR/loops.rs:+0:59: +0:60\n+    let mut _0: ();                      // return place in scope 0 at $DIR/loops.rs:+0:87: +0:87\n+    let mut _3: std::iter::FilterMap<impl Iterator<Item = T>, impl Fn(T) -> Option<U>>; // in scope 0 at $DIR/loops.rs:+1:14: +1:32\n+    let mut _4: std::iter::FilterMap<impl Iterator<Item = T>, impl Fn(T) -> Option<U>>; // in scope 0 at $DIR/loops.rs:+1:14: +1:32\n+    let mut _5: std::iter::FilterMap<impl Iterator<Item = T>, impl Fn(T) -> Option<U>>; // in scope 0 at $DIR/loops.rs:+1:14: +1:32\n+    let mut _6: &mut std::iter::FilterMap<impl Iterator<Item = T>, impl Fn(T) -> Option<U>>; // in scope 0 at $DIR/loops.rs:+1:14: +1:32\n+    let mut _9: std::option::Option<U>;  // in scope 0 at $DIR/loops.rs:+1:14: +1:32\n+    let mut _10: isize;                  // in scope 0 at $DIR/loops.rs:+1:5: +3:6\n+    let _12: ();                         // in scope 0 at $DIR/loops.rs:+1:14: +1:32\n+    scope 1 {\n+        debug iter => _5;                // in scope 1 at $DIR/loops.rs:+1:14: +1:32\n+        let _11: U;                      // in scope 1 at $DIR/loops.rs:+1:9: +1:10\n+        scope 2 {\n+            debug x => _11;              // in scope 2 at $DIR/loops.rs:+1:9: +1:10\n+        }\n+        scope 4 (inlined <FilterMap<impl Iterator<Item = T>, impl Fn(T) -> Option<U>> as Iterator>::next) { // at $DIR/loops.rs:20:14: 20:32\n+            debug self => _6;            // in scope 4 at $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+            let mut _7: &mut impl Iterator<Item = T>; // in scope 4 at $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+            let mut _8: &mut impl Fn(T) -> Option<U>; // in scope 4 at $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+        }\n+    }\n+    scope 3 (inlined <FilterMap<impl Iterator<Item = T>, impl Fn(T) -> Option<U>> as IntoIterator>::into_iter) { // at $DIR/loops.rs:20:14: 20:32\n+        debug self => _3;                // in scope 3 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+    }\n+\n+    bb0: {\n+        StorageLive(_4);                 // scope 0 at $DIR/loops.rs:+1:14: +1:32\n+        StorageLive(_3);                 // scope 0 at $DIR/loops.rs:+1:14: +1:32\n+        _3 = <impl Iterator<Item = T> as Iterator>::filter_map::<U, impl Fn(T) -> Option<U>>(move _1, move _2) -> bb1; // scope 0 at $DIR/loops.rs:+1:14: +1:32\n+                                         // mir::Constant\n+                                         // + span: $DIR/loops.rs:20:19: 20:29\n+                                         // + literal: Const { ty: fn(impl Iterator<Item = T>, impl Fn(T) -> Option<U>) -> FilterMap<impl Iterator<Item = T>, impl Fn(T) -> Option<U>> {<impl Iterator<Item = T> as Iterator>::filter_map::<U, impl Fn(T) -> Option<U>>}, val: Value(<ZST>) }\n+    }\n+\n+    bb1: {\n+        _4 = move _3;                    // scope 3 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+        StorageDead(_3);                 // scope 0 at $DIR/loops.rs:+1:31: +1:32\n+        StorageLive(_5);                 // scope 0 at $DIR/loops.rs:+1:14: +1:32\n+        _5 = move _4;                    // scope 0 at $DIR/loops.rs:+1:14: +1:32\n+        goto -> bb2;                     // scope 1 at $DIR/loops.rs:+1:5: +3:6\n+    }\n+\n+    bb2: {\n+        StorageLive(_9);                 // scope 1 at $DIR/loops.rs:+1:14: +1:32\n+        _6 = &mut _5;                    // scope 1 at $DIR/loops.rs:+1:14: +1:32\n+        StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+        _7 = &mut ((*_6).0: impl Iterator<Item = T>); // scope 4 at $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+        StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+        _8 = &mut ((*_6).1: impl Fn(T) -> Option<U>); // scope 4 at $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+        _9 = <impl Iterator<Item = T> as Iterator>::find_map::<U, &mut impl Fn(T) -> Option<U>>(move _7, move _8) -> [return: bb3, unwind: bb9]; // scope 4 at $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+                                         // + literal: Const { ty: for<'a> fn(&'a mut impl Iterator<Item = T>, &mut impl Fn(T) -> Option<U>) -> Option<U> {<impl Iterator<Item = T> as Iterator>::find_map::<U, &mut impl Fn(T) -> Option<U>>}, val: Value(<ZST>) }\n+    }\n+\n+    bb3: {\n+        StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+        StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/iter/adapters/filter_map.rs:LL:COL\n+        _10 = discriminant(_9);          // scope 1 at $DIR/loops.rs:+1:14: +1:32\n+        switchInt(move _10) -> [0: bb4, 1: bb6, otherwise: bb8]; // scope 1 at $DIR/loops.rs:+1:14: +1:32\n+    }\n+\n+    bb4: {\n+        StorageDead(_9);                 // scope 1 at $DIR/loops.rs:+3:5: +3:6\n+        drop(_5) -> bb5;                 // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+    }\n+\n+    bb5: {\n+        StorageDead(_5);                 // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+        StorageDead(_4);                 // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+        return;                          // scope 0 at $DIR/loops.rs:+4:2: +4:2\n+    }\n+\n+    bb6: {\n+        _11 = move ((_9 as Some).0: U);  // scope 1 at $DIR/loops.rs:+1:9: +1:10\n+        _12 = opaque::<U>(move _11) -> [return: bb7, unwind: bb9]; // scope 2 at $DIR/loops.rs:+2:9: +2:18\n+                                         // mir::Constant\n+                                         // + span: $DIR/loops.rs:21:9: 21:15\n+                                         // + literal: Const { ty: fn(U) {opaque::<U>}, val: Value(<ZST>) }\n+    }\n+\n+    bb7: {\n+        StorageDead(_9);                 // scope 1 at $DIR/loops.rs:+3:5: +3:6\n+        goto -> bb2;                     // scope 1 at $DIR/loops.rs:+1:5: +3:6\n+    }\n+\n+    bb8: {\n+        unreachable;                     // scope 1 at $DIR/loops.rs:+1:14: +1:32\n+    }\n+\n+    bb9 (cleanup): {\n+        drop(_5) -> [return: bb10, unwind terminate]; // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+    }\n+\n+    bb10 (cleanup): {\n+        resume;                          // scope 0 at $DIR/loops.rs:+0:1: +4:2\n+    }\n+}"}, {"sha": "a5002cd6afa1324dd6f0b6eb3999b0d9f4d1422d", "filename": "tests/mir-opt/pre-codegen/loops.int_range.PreCodegen.after.mir", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Floops.int_range.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Floops.int_range.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Floops.int_range.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,118 @@\n+// MIR for `int_range` after PreCodegen\n+\n+fn int_range(_1: usize, _2: usize) -> () {\n+    debug start => _1;                   // in scope 0 at $DIR/loops.rs:+0:18: +0:23\n+    debug end => _2;                     // in scope 0 at $DIR/loops.rs:+0:32: +0:35\n+    let mut _0: ();                      // return place in scope 0 at $DIR/loops.rs:+0:44: +0:44\n+    let mut _3: std::ops::Range<usize>;  // in scope 0 at $DIR/loops.rs:+1:14: +1:24\n+    let mut _4: std::ops::Range<usize>;  // in scope 0 at $DIR/loops.rs:+1:14: +1:24\n+    let mut _5: &mut std::ops::Range<usize>; // in scope 0 at $DIR/loops.rs:+1:14: +1:24\n+    let mut _9: std::option::Option<usize>; // in scope 0 at $DIR/loops.rs:+1:14: +1:24\n+    let mut _12: isize;                  // in scope 0 at $DIR/loops.rs:+1:5: +3:6\n+    let _14: ();                         // in scope 0 at $DIR/loops.rs:+1:14: +1:24\n+    scope 1 {\n+        debug iter => _4;                // in scope 1 at $DIR/loops.rs:+1:14: +1:24\n+        let _13: usize;                  // in scope 1 at $DIR/loops.rs:+1:9: +1:10\n+        scope 2 {\n+            debug i => _13;              // in scope 2 at $DIR/loops.rs:+1:9: +1:10\n+        }\n+        scope 4 (inlined iter::range::<impl Iterator for std::ops::Range<usize>>::next) { // at $DIR/loops.rs:8:14: 8:24\n+            debug self => _5;            // in scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            scope 5 (inlined <std::ops::Range<usize> as iter::range::RangeIteratorImpl>::spec_next) { // at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                debug self => _5;        // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _6: &usize;      // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _7: &usize;      // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _8: bool;        // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let _10: usize;          // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _11: usize;      // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                scope 6 {\n+                    debug old => _10;    // in scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                    scope 7 {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    scope 3 (inlined <std::ops::Range<usize> as IntoIterator>::into_iter) { // at $DIR/loops.rs:8:14: 8:24\n+        debug self => _3;                // in scope 3 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+    }\n+\n+    bb0: {\n+        _3 = std::ops::Range::<usize> { start: _1, end: _2 }; // scope 0 at $DIR/loops.rs:+1:14: +1:24\n+        StorageLive(_4);                 // scope 0 at $DIR/loops.rs:+1:14: +1:24\n+        _4 = move _3;                    // scope 0 at $DIR/loops.rs:+1:14: +1:24\n+        goto -> bb1;                     // scope 1 at $DIR/loops.rs:+1:5: +3:6\n+    }\n+\n+    bb1: {\n+        StorageLive(_9);                 // scope 1 at $DIR/loops.rs:+1:14: +1:24\n+        _5 = &mut _4;                    // scope 1 at $DIR/loops.rs:+1:14: +1:24\n+        StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_8);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_6);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _6 = &((*_5).0: usize);          // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_7);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _7 = &((*_5).1: usize);          // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _8 = <usize as PartialOrd>::lt(move _6, move _7) -> bb2; // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // + literal: Const { ty: for<'a, 'b> fn(&'a usize, &'b usize) -> bool {<usize as PartialOrd>::lt}, val: Value(<ZST>) }\n+    }\n+\n+    bb2: {\n+        StorageDead(_7);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_6);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        switchInt(move _8) -> [0: bb3, otherwise: bb4]; // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb3: {\n+        _9 = Option::<usize>::None;      // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        goto -> bb6;                     // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb4: {\n+        _10 = ((*_5).0: usize);          // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_11);                // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _11 = <usize as Step>::forward_unchecked(_10, const 1_usize) -> bb5; // scope 7 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // + literal: Const { ty: unsafe fn(usize, usize) -> usize {<usize as Step>::forward_unchecked}, val: Value(<ZST>) }\n+    }\n+\n+    bb5: {\n+        ((*_5).0: usize) = move _11;     // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_11);                // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _9 = Option::<usize>::Some(_10); // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        goto -> bb6;                     // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb6: {\n+        StorageDead(_8);                 // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_10);                // scope 4 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _12 = discriminant(_9);          // scope 1 at $DIR/loops.rs:+1:14: +1:24\n+        switchInt(move _12) -> [0: bb7, 1: bb8, otherwise: bb10]; // scope 1 at $DIR/loops.rs:+1:14: +1:24\n+    }\n+\n+    bb7: {\n+        StorageDead(_9);                 // scope 1 at $DIR/loops.rs:+3:5: +3:6\n+        StorageDead(_4);                 // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+        return;                          // scope 0 at $DIR/loops.rs:+4:2: +4:2\n+    }\n+\n+    bb8: {\n+        _13 = ((_9 as Some).0: usize);   // scope 1 at $DIR/loops.rs:+1:9: +1:10\n+        _14 = opaque::<usize>(_13) -> bb9; // scope 2 at $DIR/loops.rs:+2:9: +2:18\n+                                         // mir::Constant\n+                                         // + span: $DIR/loops.rs:9:9: 9:15\n+                                         // + literal: Const { ty: fn(usize) {opaque::<usize>}, val: Value(<ZST>) }\n+    }\n+\n+    bb9: {\n+        StorageDead(_9);                 // scope 1 at $DIR/loops.rs:+3:5: +3:6\n+        goto -> bb1;                     // scope 1 at $DIR/loops.rs:+1:5: +3:6\n+    }\n+\n+    bb10: {\n+        unreachable;                     // scope 1 at $DIR/loops.rs:+1:14: +1:24\n+    }\n+}"}, {"sha": "bf1380b30ff2a9b3d9e6394d9a05517f8b81cdf2", "filename": "tests/mir-opt/pre-codegen/loops.mapped.PreCodegen.after.mir", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Floops.mapped.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Floops.mapped.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Floops.mapped.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,91 @@\n+// MIR for `mapped` after PreCodegen\n+\n+fn mapped(_1: impl Iterator<Item = T>, _2: impl Fn(T) -> U) -> () {\n+    debug iter => _1;                    // in scope 0 at $DIR/loops.rs:+0:21: +0:25\n+    debug f => _2;                       // in scope 0 at $DIR/loops.rs:+0:52: +0:53\n+    let mut _0: ();                      // return place in scope 0 at $DIR/loops.rs:+0:72: +0:72\n+    let mut _3: std::iter::Map<impl Iterator<Item = T>, impl Fn(T) -> U>; // in scope 0 at $DIR/loops.rs:+1:14: +1:25\n+    let mut _4: std::iter::Map<impl Iterator<Item = T>, impl Fn(T) -> U>; // in scope 0 at $DIR/loops.rs:+1:14: +1:25\n+    let mut _5: std::iter::Map<impl Iterator<Item = T>, impl Fn(T) -> U>; // in scope 0 at $DIR/loops.rs:+1:14: +1:25\n+    let mut _6: &mut std::iter::Map<impl Iterator<Item = T>, impl Fn(T) -> U>; // in scope 0 at $DIR/loops.rs:+1:14: +1:25\n+    let mut _7: std::option::Option<U>;  // in scope 0 at $DIR/loops.rs:+1:14: +1:25\n+    let mut _8: isize;                   // in scope 0 at $DIR/loops.rs:+1:5: +3:6\n+    let _10: ();                         // in scope 0 at $DIR/loops.rs:+1:14: +1:25\n+    scope 1 {\n+        debug iter => _5;                // in scope 1 at $DIR/loops.rs:+1:14: +1:25\n+        let _9: U;                       // in scope 1 at $DIR/loops.rs:+1:9: +1:10\n+        scope 2 {\n+            debug x => _9;               // in scope 2 at $DIR/loops.rs:+1:9: +1:10\n+        }\n+    }\n+    scope 3 (inlined <Map<impl Iterator<Item = T>, impl Fn(T) -> U> as IntoIterator>::into_iter) { // at $DIR/loops.rs:14:14: 14:25\n+        debug self => _3;                // in scope 3 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+    }\n+\n+    bb0: {\n+        StorageLive(_4);                 // scope 0 at $DIR/loops.rs:+1:14: +1:25\n+        StorageLive(_3);                 // scope 0 at $DIR/loops.rs:+1:14: +1:25\n+        _3 = <impl Iterator<Item = T> as Iterator>::map::<U, impl Fn(T) -> U>(move _1, move _2) -> bb1; // scope 0 at $DIR/loops.rs:+1:14: +1:25\n+                                         // mir::Constant\n+                                         // + span: $DIR/loops.rs:14:19: 14:22\n+                                         // + literal: Const { ty: fn(impl Iterator<Item = T>, impl Fn(T) -> U) -> Map<impl Iterator<Item = T>, impl Fn(T) -> U> {<impl Iterator<Item = T> as Iterator>::map::<U, impl Fn(T) -> U>}, val: Value(<ZST>) }\n+    }\n+\n+    bb1: {\n+        _4 = move _3;                    // scope 3 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+        StorageDead(_3);                 // scope 0 at $DIR/loops.rs:+1:24: +1:25\n+        StorageLive(_5);                 // scope 0 at $DIR/loops.rs:+1:14: +1:25\n+        _5 = move _4;                    // scope 0 at $DIR/loops.rs:+1:14: +1:25\n+        goto -> bb2;                     // scope 1 at $DIR/loops.rs:+1:5: +3:6\n+    }\n+\n+    bb2: {\n+        StorageLive(_7);                 // scope 1 at $DIR/loops.rs:+1:14: +1:25\n+        _6 = &mut _5;                    // scope 1 at $DIR/loops.rs:+1:14: +1:25\n+        _7 = <Map<impl Iterator<Item = T>, impl Fn(T) -> U> as Iterator>::next(_6) -> [return: bb3, unwind: bb9]; // scope 1 at $DIR/loops.rs:+1:14: +1:25\n+                                         // mir::Constant\n+                                         // + span: $DIR/loops.rs:14:14: 14:25\n+                                         // + literal: Const { ty: for<'a> fn(&'a mut Map<impl Iterator<Item = T>, impl Fn(T) -> U>) -> Option<<Map<impl Iterator<Item = T>, impl Fn(T) -> U> as Iterator>::Item> {<Map<impl Iterator<Item = T>, impl Fn(T) -> U> as Iterator>::next}, val: Value(<ZST>) }\n+    }\n+\n+    bb3: {\n+        _8 = discriminant(_7);           // scope 1 at $DIR/loops.rs:+1:14: +1:25\n+        switchInt(move _8) -> [0: bb4, 1: bb6, otherwise: bb8]; // scope 1 at $DIR/loops.rs:+1:14: +1:25\n+    }\n+\n+    bb4: {\n+        StorageDead(_7);                 // scope 1 at $DIR/loops.rs:+3:5: +3:6\n+        drop(_5) -> bb5;                 // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+    }\n+\n+    bb5: {\n+        StorageDead(_5);                 // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+        StorageDead(_4);                 // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+        return;                          // scope 0 at $DIR/loops.rs:+4:2: +4:2\n+    }\n+\n+    bb6: {\n+        _9 = move ((_7 as Some).0: U);   // scope 1 at $DIR/loops.rs:+1:9: +1:10\n+        _10 = opaque::<U>(move _9) -> [return: bb7, unwind: bb9]; // scope 2 at $DIR/loops.rs:+2:9: +2:18\n+                                         // mir::Constant\n+                                         // + span: $DIR/loops.rs:15:9: 15:15\n+                                         // + literal: Const { ty: fn(U) {opaque::<U>}, val: Value(<ZST>) }\n+    }\n+\n+    bb7: {\n+        StorageDead(_7);                 // scope 1 at $DIR/loops.rs:+3:5: +3:6\n+        goto -> bb2;                     // scope 1 at $DIR/loops.rs:+1:5: +3:6\n+    }\n+\n+    bb8: {\n+        unreachable;                     // scope 1 at $DIR/loops.rs:+1:14: +1:25\n+    }\n+\n+    bb9 (cleanup): {\n+        drop(_5) -> [return: bb10, unwind terminate]; // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+    }\n+\n+    bb10 (cleanup): {\n+        resume;                          // scope 0 at $DIR/loops.rs:+0:1: +4:2\n+    }\n+}"}, {"sha": "67f549a511c8a53710bba7d4c56e23a49eb20422", "filename": "tests/mir-opt/pre-codegen/loops.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Floops.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,37 @@\n+// compile-flags: -O -Zmir-opt-level=2 -g\n+// needs-unwind\n+// ignore-debug\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn int_range(start: usize, end: usize) {\n+    for i in start..end {\n+        opaque(i)\n+    }\n+}\n+\n+pub fn mapped<T, U>(iter: impl Iterator<Item = T>, f: impl Fn(T) -> U) {\n+    for x in iter.map(f) {\n+        opaque(x)\n+    }\n+}\n+\n+pub fn filter_mapped<T, U>(iter: impl Iterator<Item = T>, f: impl Fn(T) -> Option<U>) {\n+    for x in iter.filter_map(f) {\n+        opaque(x)\n+    }\n+}\n+\n+pub fn vec_move(mut v: Vec<impl Sized>) {\n+    for x in v {\n+        opaque(x)\n+    }\n+}\n+\n+#[inline(never)]\n+fn opaque(_: impl Sized) {}\n+\n+// EMIT_MIR loops.int_range.PreCodegen.after.mir\n+// EMIT_MIR loops.mapped.PreCodegen.after.mir\n+// EMIT_MIR loops.filter_mapped.PreCodegen.after.mir\n+// EMIT_MIR loops.vec_move.PreCodegen.after.mir"}, {"sha": "6cd5a66de00fcdee05a4e7f4ad4fb21c769e0cb8", "filename": "tests/mir-opt/pre-codegen/loops.vec_move.PreCodegen.after.mir", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Floops.vec_move.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Floops.vec_move.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Floops.vec_move.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,83 @@\n+// MIR for `vec_move` after PreCodegen\n+\n+fn vec_move(_1: Vec<impl Sized>) -> () {\n+    debug v => _1;                       // in scope 0 at $DIR/loops.rs:+0:17: +0:22\n+    let mut _0: ();                      // return place in scope 0 at $DIR/loops.rs:+0:41: +0:41\n+    let mut _2: std::vec::IntoIter<impl Sized>; // in scope 0 at $DIR/loops.rs:+1:14: +1:15\n+    let mut _3: std::vec::IntoIter<impl Sized>; // in scope 0 at $DIR/loops.rs:+1:14: +1:15\n+    let mut _4: &mut std::vec::IntoIter<impl Sized>; // in scope 0 at $DIR/loops.rs:+1:14: +1:15\n+    let mut _5: std::option::Option<impl Sized>; // in scope 0 at $DIR/loops.rs:+1:14: +1:15\n+    let mut _6: isize;                   // in scope 0 at $DIR/loops.rs:+1:5: +3:6\n+    let _8: ();                          // in scope 0 at $DIR/loops.rs:+1:14: +1:15\n+    scope 1 {\n+        debug iter => _3;                // in scope 1 at $DIR/loops.rs:+1:14: +1:15\n+        let _7: impl Sized;              // in scope 1 at $DIR/loops.rs:+1:9: +1:10\n+        scope 2 {\n+            debug x => _7;               // in scope 2 at $DIR/loops.rs:+1:9: +1:10\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/loops.rs:+1:14: +1:15\n+        _2 = <Vec<impl Sized> as IntoIterator>::into_iter(move _1) -> bb1; // scope 0 at $DIR/loops.rs:+1:14: +1:15\n+                                         // mir::Constant\n+                                         // + span: $DIR/loops.rs:26:14: 26:15\n+                                         // + literal: Const { ty: fn(Vec<impl Sized>) -> <Vec<impl Sized> as IntoIterator>::IntoIter {<Vec<impl Sized> as IntoIterator>::into_iter}, val: Value(<ZST>) }\n+    }\n+\n+    bb1: {\n+        StorageLive(_3);                 // scope 0 at $DIR/loops.rs:+1:14: +1:15\n+        _3 = move _2;                    // scope 0 at $DIR/loops.rs:+1:14: +1:15\n+        goto -> bb2;                     // scope 1 at $DIR/loops.rs:+1:5: +3:6\n+    }\n+\n+    bb2: {\n+        StorageLive(_5);                 // scope 1 at $DIR/loops.rs:+1:14: +1:15\n+        _4 = &mut _3;                    // scope 1 at $DIR/loops.rs:+1:14: +1:15\n+        _5 = <std::vec::IntoIter<impl Sized> as Iterator>::next(_4) -> [return: bb3, unwind: bb9]; // scope 1 at $DIR/loops.rs:+1:14: +1:15\n+                                         // mir::Constant\n+                                         // + span: $DIR/loops.rs:26:14: 26:15\n+                                         // + literal: Const { ty: for<'a> fn(&'a mut std::vec::IntoIter<impl Sized>) -> Option<<std::vec::IntoIter<impl Sized> as Iterator>::Item> {<std::vec::IntoIter<impl Sized> as Iterator>::next}, val: Value(<ZST>) }\n+    }\n+\n+    bb3: {\n+        _6 = discriminant(_5);           // scope 1 at $DIR/loops.rs:+1:14: +1:15\n+        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb8]; // scope 1 at $DIR/loops.rs:+1:14: +1:15\n+    }\n+\n+    bb4: {\n+        StorageDead(_5);                 // scope 1 at $DIR/loops.rs:+3:5: +3:6\n+        drop(_3) -> bb5;                 // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+    }\n+\n+    bb5: {\n+        StorageDead(_3);                 // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+        StorageDead(_2);                 // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+        return;                          // scope 0 at $DIR/loops.rs:+4:2: +4:2\n+    }\n+\n+    bb6: {\n+        _7 = move ((_5 as Some).0: impl Sized); // scope 1 at $DIR/loops.rs:+1:9: +1:10\n+        _8 = opaque::<impl Sized>(move _7) -> [return: bb7, unwind: bb9]; // scope 2 at $DIR/loops.rs:+2:9: +2:18\n+                                         // mir::Constant\n+                                         // + span: $DIR/loops.rs:27:9: 27:15\n+                                         // + literal: Const { ty: fn(impl Sized) {opaque::<impl Sized>}, val: Value(<ZST>) }\n+    }\n+\n+    bb7: {\n+        StorageDead(_5);                 // scope 1 at $DIR/loops.rs:+3:5: +3:6\n+        goto -> bb2;                     // scope 1 at $DIR/loops.rs:+1:5: +3:6\n+    }\n+\n+    bb8: {\n+        unreachable;                     // scope 1 at $DIR/loops.rs:+1:14: +1:15\n+    }\n+\n+    bb9 (cleanup): {\n+        drop(_3) -> [return: bb10, unwind terminate]; // scope 0 at $DIR/loops.rs:+3:5: +3:6\n+    }\n+\n+    bb10 (cleanup): {\n+        resume;                          // scope 0 at $DIR/loops.rs:+0:1: +4:2\n+    }\n+}"}, {"sha": "0cf9643dfc224aefdd974e29fb4e6a2c1a41a3e5", "filename": "tests/mir-opt/pre-codegen/mem_replace.mem_replace.PreCodegen.after.mir", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.mem_replace.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.mem_replace.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.mem_replace.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -15,20 +15,18 @@ fn mem_replace(_1: &mut u32, _2: u32) -> u32 {\n                 scope 7 (inlined std::ptr::write::<u32>) { // at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n                     debug dst => _4;     // in scope 7 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n                     debug src => _2;     // in scope 7 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                    let mut _6: *mut u32; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                     scope 8 {\n                         scope 9 (inlined std::ptr::write::runtime::<u32>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                            debug dst => _6; // in scope 9 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                            debug dst => _4; // in scope 9 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                         }\n                     }\n                 }\n             }\n             scope 4 (inlined std::ptr::read::<u32>) { // at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n                 debug src => _3;         // in scope 4 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                let mut _5: *const u32;  // in scope 4 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                 scope 5 {\n                     scope 6 (inlined std::ptr::read::runtime::<u32>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                        debug src => _5; // in scope 6 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                        debug src => _3; // in scope 6 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                     }\n                 }\n             }\n@@ -38,15 +36,11 @@ fn mem_replace(_1: &mut u32, _2: u32) -> u32 {\n     bb0: {\n         StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         _3 = &raw const (*_1);           // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-        StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         _0 = (*_3);                      // scope 5 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         StorageLive(_4);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         _4 = &raw mut (*_1);             // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-        StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         (*_4) = _2;                      // scope 8 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         StorageDead(_4);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n         return;                          // scope 0 at $DIR/mem_replace.rs:+2:2: +2:2\n     }"}, {"sha": "73b5678ce049b90d18a0be5d28ce155e42a5dc89", "filename": "tests/mir-opt/pre-codegen/simple_option_map.ezmap.PreCodegen.after.mir", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fsimple_option_map.ezmap.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fsimple_option_map.ezmap.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fsimple_option_map.ezmap.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,24 +3,21 @@\n fn ezmap(_1: Option<i32>) -> Option<i32> {\n     debug x => _1;                       // in scope 0 at $DIR/simple_option_map.rs:+0:14: +0:15\n     let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/simple_option_map.rs:+0:33: +0:44\n-    let mut _5: i32;                     // in scope 0 at $DIR/simple_option_map.rs:11:25: 11:29\n     scope 1 (inlined map::<i32, i32, [closure@$DIR/simple_option_map.rs:18:12: 18:15]>) { // at $DIR/simple_option_map.rs:18:5: 18:22\n         debug slf => _1;                 // in scope 1 at $DIR/simple_option_map.rs:6:17: 6:20\n         debug f => const ZeroSized: [closure@$DIR/simple_option_map.rs:18:12: 18:15]; // in scope 1 at $DIR/simple_option_map.rs:6:33: 6:34\n         let mut _2: isize;               // in scope 1 at $DIR/simple_option_map.rs:11:9: 11:16\n         let _3: i32;                     // in scope 1 at $DIR/simple_option_map.rs:11:14: 11:15\n-        let mut _4: (i32,);              // in scope 1 at $DIR/simple_option_map.rs:11:25: 11:29\n-        let mut _6: i32;                 // in scope 1 at $DIR/simple_option_map.rs:11:25: 11:29\n+        let mut _4: i32;                 // in scope 1 at $DIR/simple_option_map.rs:11:25: 11:29\n         scope 2 {\n             debug x => _3;               // in scope 2 at $DIR/simple_option_map.rs:11:14: 11:15\n             scope 3 (inlined ezmap::{closure#0}) { // at $DIR/simple_option_map.rs:11:25: 11:29\n-                debug n => _5;           // in scope 3 at $DIR/simple_option_map.rs:+1:13: +1:14\n+                debug n => _3;           // in scope 3 at $DIR/simple_option_map.rs:+1:13: +1:14\n             }\n         }\n     }\n \n     bb0: {\n-        StorageLive(_3);                 // scope 0 at $DIR/simple_option_map.rs:+1:5: +1:22\n         _2 = discriminant(_1);           // scope 1 at $DIR/simple_option_map.rs:10:11: 10:14\n         switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb4]; // scope 1 at $DIR/simple_option_map.rs:10:5: 10:14\n     }\n@@ -32,21 +29,14 @@ fn ezmap(_1: Option<i32>) -> Option<i32> {\n \n     bb2: {\n         _3 = ((_1 as Some).0: i32);      // scope 1 at $DIR/simple_option_map.rs:11:14: 11:15\n-        StorageLive(_6);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n         StorageLive(_4);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n-        _4 = (move _3,);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n-        StorageLive(_5);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n-        _5 = move (_4.0: i32);           // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n-        _6 = Add(_5, const 1_i32);       // scope 3 at $DIR/simple_option_map.rs:+1:16: +1:21\n-        StorageDead(_5);                 // scope 2 at $DIR/simple_option_map.rs:11:25: 11:29\n-        StorageDead(_4);                 // scope 2 at $DIR/simple_option_map.rs:11:28: 11:29\n-        _0 = Option::<i32>::Some(move _6); // scope 2 at $DIR/simple_option_map.rs:11:20: 11:30\n-        StorageDead(_6);                 // scope 2 at $DIR/simple_option_map.rs:11:29: 11:30\n+        _4 = Add(_3, const 1_i32);       // scope 3 at $DIR/simple_option_map.rs:+1:16: +1:21\n+        _0 = Option::<i32>::Some(move _4); // scope 2 at $DIR/simple_option_map.rs:11:20: 11:30\n+        StorageDead(_4);                 // scope 2 at $DIR/simple_option_map.rs:11:29: 11:30\n         goto -> bb3;                     // scope 1 at $DIR/simple_option_map.rs:14:1: 14:2\n     }\n \n     bb3: {\n-        StorageDead(_3);                 // scope 0 at $DIR/simple_option_map.rs:+1:5: +1:22\n         return;                          // scope 0 at $DIR/simple_option_map.rs:+2:2: +2:2\n     }\n "}, {"sha": "aba951acdd08d7d079afa4c0f6edffa26e497fcf", "filename": "tests/mir-opt/pre-codegen/slice_filter.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_filter.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -O -Zmir-opt-level=2 -Cdebuginfo=2\n+// ignore-debug: standard library debug assertions add a panic that breaks this optimization\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn variant_a(input: &[(usize, usize, usize, usize)]) -> usize {\n+    input.iter().filter(|(a, b, c, d)| a <= c && d <= b || c <= a && b <= d).count()\n+}\n+\n+pub fn variant_b(input: &[(usize, usize, usize, usize)]) -> usize {\n+    input.iter().filter(|&&(a, b, c, d)| a <= c && d <= b || c <= a && b <= d).count()\n+}\n+\n+// EMIT_MIR slice_filter.variant_a-{closure#0}.PreCodegen.after.mir\n+// EMIT_MIR slice_filter.variant_b-{closure#0}.PreCodegen.after.mir"}, {"sha": "91c8f299fdb209ee61c4bd4319badbcb69e31a2b", "filename": "tests/mir-opt/pre-codegen/slice_filter.variant_a-{closure#0}.PreCodegen.after.mir", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_filter.variant_a-%7Bclosure%230%7D.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_filter.variant_a-%7Bclosure%230%7D.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_filter.variant_a-%7Bclosure%230%7D.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,228 @@\n+// MIR for `variant_a::{closure#0}` after PreCodegen\n+\n+fn variant_a::{closure#0}(_1: &mut [closure@$DIR/slice_filter.rs:7:25: 7:39], _2: &&(usize, usize, usize, usize)) -> bool {\n+    let mut _0: bool;                    // return place in scope 0 at $DIR/slice_filter.rs:+0:40: +0:40\n+    let mut _3: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n+    let _4: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n+    let mut _5: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n+    let _6: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n+    let mut _7: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n+    let _8: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n+    let mut _9: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n+    let _10: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n+    let mut _11: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:41\n+    let _12: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:45: +0:46\n+    let mut _13: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:45: +0:46\n+    let mut _18: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:46\n+    let mut _19: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:50: +0:51\n+    let _20: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:55: +0:56\n+    let mut _21: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:55: +0:56\n+    let mut _26: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:50: +0:56\n+    let mut _27: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:56\n+    let mut _28: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:61\n+    let _29: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:65: +0:66\n+    let mut _30: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:65: +0:66\n+    let mut _35: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:66\n+    let mut _36: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:76\n+    let mut _37: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:70: +0:71\n+    let _38: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n+    let mut _39: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n+    let mut _44: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:70: +0:76\n+    scope 1 {\n+        debug a => _4;                   // in scope 1 at $DIR/slice_filter.rs:+0:27: +0:28\n+        debug b => _6;                   // in scope 1 at $DIR/slice_filter.rs:+0:30: +0:31\n+        debug c => _8;                   // in scope 1 at $DIR/slice_filter.rs:+0:33: +0:34\n+        debug d => _10;                  // in scope 1 at $DIR/slice_filter.rs:+0:36: +0:37\n+        scope 2 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:7:40: 7:46\n+            debug self => _11;           // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            debug other => _13;          // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            let mut _14: &usize;         // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            let mut _15: &usize;         // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            scope 3 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                debug self => _14;       // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                debug other => _15;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                let mut _16: usize;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                let mut _17: usize;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            }\n+        }\n+        scope 4 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:7:60: 7:66\n+            debug self => _28;           // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            debug other => _30;          // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            let mut _31: &usize;         // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            let mut _32: &usize;         // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            scope 5 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                debug self => _31;       // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                debug other => _32;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                let mut _33: usize;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                let mut _34: usize;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            }\n+        }\n+        scope 6 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:7:50: 7:56\n+            debug self => _19;           // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            debug other => _21;          // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            let mut _22: &usize;         // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            let mut _23: &usize;         // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            scope 7 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                debug self => _22;       // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                debug other => _23;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                let mut _24: usize;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                let mut _25: usize;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            }\n+        }\n+        scope 8 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:7:70: 7:76\n+            debug self => _37;           // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            debug other => _39;          // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            let mut _40: &usize;         // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            let mut _41: &usize;         // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            scope 9 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                debug self => _40;       // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                debug other => _41;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                let mut _42: usize;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+                let mut _43: usize;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+            }\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_4);                 // scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n+        _3 = deref_copy (*_2);           // scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n+        _4 = &((*_3).0: usize);          // scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n+        StorageLive(_6);                 // scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n+        _5 = deref_copy (*_2);           // scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n+        _6 = &((*_5).1: usize);          // scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n+        StorageLive(_8);                 // scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n+        _7 = deref_copy (*_2);           // scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n+        _8 = &((*_7).2: usize);          // scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n+        StorageLive(_10);                // scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n+        _9 = deref_copy (*_2);           // scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n+        _10 = &((*_9).3: usize);         // scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n+        StorageLive(_27);                // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n+        StorageLive(_18);                // scope 1 at $DIR/slice_filter.rs:+0:40: +0:46\n+        StorageLive(_11);                // scope 1 at $DIR/slice_filter.rs:+0:40: +0:41\n+        _11 = &_4;                       // scope 1 at $DIR/slice_filter.rs:+0:40: +0:41\n+        StorageLive(_13);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n+        StorageLive(_12);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n+        _12 = _8;                        // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n+        _13 = &_12;                      // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n+        _14 = deref_copy (*_11);         // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _15 = deref_copy (*_13);         // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageLive(_16);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _16 = (*_14);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageLive(_17);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _17 = (*_15);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _18 = Le(move _16, move _17);    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_17);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_16);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_12);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n+        StorageDead(_13);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n+        StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n+        switchInt(move _18) -> [0: bb1, otherwise: bb2]; // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n+    }\n+\n+    bb1: {\n+        StorageDead(_26);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        StorageDead(_18);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n+    }\n+\n+    bb2: {\n+        StorageLive(_26);                // scope 1 at $DIR/slice_filter.rs:+0:50: +0:56\n+        StorageLive(_19);                // scope 1 at $DIR/slice_filter.rs:+0:50: +0:51\n+        _19 = &_10;                      // scope 1 at $DIR/slice_filter.rs:+0:50: +0:51\n+        StorageLive(_21);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        StorageLive(_20);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        _20 = _6;                        // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        _21 = &_20;                      // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        _22 = deref_copy (*_19);         // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _23 = deref_copy (*_21);         // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageLive(_24);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _24 = (*_22);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageLive(_25);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _25 = (*_23);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _26 = Le(move _24, move _25);    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_25);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_24);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_20);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        StorageDead(_21);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        StorageDead(_19);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        _27 = move _26;                  // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n+        StorageDead(_26);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        StorageDead(_18);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n+        switchInt(move _27) -> [0: bb3, otherwise: bb7]; // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n+    }\n+\n+    bb3: {\n+        StorageLive(_36);                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n+        StorageLive(_35);                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:66\n+        StorageLive(_28);                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:61\n+        _28 = &_8;                       // scope 1 at $DIR/slice_filter.rs:+0:60: +0:61\n+        StorageLive(_30);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n+        StorageLive(_29);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n+        _29 = _4;                        // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n+        _30 = &_29;                      // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n+        _31 = deref_copy (*_28);         // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _32 = deref_copy (*_30);         // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageLive(_33);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _33 = (*_31);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageLive(_34);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _34 = (*_32);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _35 = Le(move _33, move _34);    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_34);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_33);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_29);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n+        StorageDead(_30);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n+        StorageDead(_28);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n+        switchInt(move _35) -> [0: bb4, otherwise: bb5]; // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n+    }\n+\n+    bb4: {\n+        _36 = const false;               // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n+        goto -> bb6;                     // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n+    }\n+\n+    bb5: {\n+        StorageLive(_44);                // scope 1 at $DIR/slice_filter.rs:+0:70: +0:76\n+        StorageLive(_37);                // scope 1 at $DIR/slice_filter.rs:+0:70: +0:71\n+        _37 = &_6;                       // scope 1 at $DIR/slice_filter.rs:+0:70: +0:71\n+        StorageLive(_39);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        StorageLive(_38);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        _38 = _10;                       // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        _39 = &_38;                      // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        _40 = deref_copy (*_37);         // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _41 = deref_copy (*_39);         // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageLive(_42);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _42 = (*_40);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageLive(_43);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _43 = (*_41);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        _44 = Le(move _42, move _43);    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_43);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_42);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n+        StorageDead(_38);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        StorageDead(_39);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        StorageDead(_37);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        _36 = move _44;                  // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n+        goto -> bb6;                     // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n+    }\n+\n+    bb6: {\n+        StorageDead(_44);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        StorageDead(_35);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        _0 = move _36;                   // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n+        goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n+    }\n+\n+    bb7: {\n+        _0 = const true;                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n+        goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n+    }\n+\n+    bb8: {\n+        StorageDead(_36);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        StorageDead(_27);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n+        StorageDead(_10);                // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n+        StorageDead(_8);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n+        StorageDead(_6);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n+        StorageDead(_4);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n+        return;                          // scope 0 at $DIR/slice_filter.rs:+0:76: +0:76\n+    }\n+}"}, {"sha": "9f5fe95a8b4b0d118222f924e293e4a1c56b42a5", "filename": "tests/mir-opt/pre-codegen/slice_filter.variant_b-{closure#0}.PreCodegen.after.mir", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_filter.variant_b-%7Bclosure%230%7D.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_filter.variant_b-%7Bclosure%230%7D.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_filter.variant_b-%7Bclosure%230%7D.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,92 @@\n+// MIR for `variant_b::{closure#0}` after PreCodegen\n+\n+fn variant_b::{closure#0}(_1: &mut [closure@$DIR/slice_filter.rs:11:25: 11:41], _2: &&(usize, usize, usize, usize)) -> bool {\n+    let mut _0: bool;                    // return place in scope 0 at $DIR/slice_filter.rs:+0:42: +0:42\n+    let mut _3: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n+    let _4: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n+    let mut _5: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n+    let _6: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n+    let mut _7: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n+    let _8: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n+    let mut _9: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n+    let _10: usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n+    let mut _11: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:42: +0:48\n+    let mut _12: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:52: +0:58\n+    let mut _13: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:42: +0:58\n+    let mut _14: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:62: +0:68\n+    let mut _15: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:62: +0:78\n+    let mut _16: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:72: +0:78\n+    scope 1 {\n+        debug a => _4;                   // in scope 1 at $DIR/slice_filter.rs:+0:29: +0:30\n+        debug b => _6;                   // in scope 1 at $DIR/slice_filter.rs:+0:32: +0:33\n+        debug c => _8;                   // in scope 1 at $DIR/slice_filter.rs:+0:35: +0:36\n+        debug d => _10;                  // in scope 1 at $DIR/slice_filter.rs:+0:38: +0:39\n+    }\n+\n+    bb0: {\n+        _3 = deref_copy (*_2);           // scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n+        _4 = ((*_3).0: usize);           // scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n+        _5 = deref_copy (*_2);           // scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n+        _6 = ((*_5).1: usize);           // scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n+        _7 = deref_copy (*_2);           // scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n+        _8 = ((*_7).2: usize);           // scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n+        _9 = deref_copy (*_2);           // scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n+        _10 = ((*_9).3: usize);          // scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n+        StorageLive(_13);                // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n+        StorageLive(_11);                // scope 1 at $DIR/slice_filter.rs:+0:42: +0:48\n+        _11 = Le(_4, _8);                // scope 1 at $DIR/slice_filter.rs:+0:42: +0:48\n+        switchInt(move _11) -> [0: bb1, otherwise: bb2]; // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n+    }\n+\n+    bb1: {\n+        StorageDead(_12);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n+        StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n+        goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n+    }\n+\n+    bb2: {\n+        StorageLive(_12);                // scope 1 at $DIR/slice_filter.rs:+0:52: +0:58\n+        _12 = Le(_10, _6);               // scope 1 at $DIR/slice_filter.rs:+0:52: +0:58\n+        _13 = move _12;                  // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n+        StorageDead(_12);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n+        StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n+        switchInt(move _13) -> [0: bb3, otherwise: bb7]; // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n+    }\n+\n+    bb3: {\n+        StorageLive(_15);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n+        StorageLive(_14);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:68\n+        _14 = Le(_8, _4);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:68\n+        switchInt(move _14) -> [0: bb4, otherwise: bb5]; // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n+    }\n+\n+    bb4: {\n+        _15 = const false;               // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n+        goto -> bb6;                     // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n+    }\n+\n+    bb5: {\n+        StorageLive(_16);                // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n+        _16 = Le(_6, _10);               // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n+        _15 = move _16;                  // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n+        goto -> bb6;                     // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n+    }\n+\n+    bb6: {\n+        StorageDead(_16);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n+        StorageDead(_14);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n+        _0 = move _15;                   // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n+        goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n+    }\n+\n+    bb7: {\n+        _0 = const true;                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n+        goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n+    }\n+\n+    bb8: {\n+        StorageDead(_15);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n+        StorageDead(_13);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n+        return;                          // scope 0 at $DIR/slice_filter.rs:+0:78: +0:78\n+    }\n+}"}, {"sha": "6c3062805365cf4e933ee253e940c580949dce47", "filename": "tests/mir-opt/pre-codegen/slice_index.slice_get_mut_usize.PreCodegen.after.mir", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_mut_usize.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_mut_usize.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_mut_usize.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -21,19 +21,17 @@ fn slice_get_mut_usize(_1: &mut [u32], _2: usize) -> Option<&mut u32> {\n                     debug self => _2;    // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                     debug slice => _6;   // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                     let mut _7: *mut u32; // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                    let mut _10: usize;  // in scope 4 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                    let mut _11: *mut [u32]; // in scope 4 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                     scope 5 {\n                         debug this => _2; // in scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                         scope 6 {\n                             scope 7 (inlined <usize as SliceIndex<[T]>>::get_unchecked_mut::runtime::<u32>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                                debug this => _10; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                                debug slice => _11; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                                debug this => _2; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                                debug slice => _6; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                                 scope 8 (inlined ptr::mut_ptr::<impl *mut [u32]>::len) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                                    debug self => _11; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                    let mut _12: *const [u32]; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                    debug self => _6; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                    let mut _10: *const [u32]; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                     scope 9 (inlined std::ptr::metadata::<[u32]>) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                        debug ptr => _12; // in scope 9 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                        debug ptr => _10; // in scope 9 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n                                         scope 10 {\n                                         }\n                                     }\n@@ -81,14 +79,10 @@ fn slice_get_mut_usize(_1: &mut [u32], _2: usize) -> Option<&mut u32> {\n         StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         _6 = &raw mut (*_1);             // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageLive(_10);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_11);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_12);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         _7 = _6 as *mut u32 (PtrToPtr);  // scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n         _8 = Offset(_7, _2);             // scope 13 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n         StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageDead(_12);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageDead(_11);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageDead(_10);                // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         _9 = &mut (*_8);                 // scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL"}, {"sha": "727ccc1de535014e01c609a6afed1b1e1c6f1005", "filename": "tests/mir-opt/pre-codegen/slice_index.slice_get_unchecked_mut_range.PreCodegen.after.mir", "status": "modified", "additions": 54, "deletions": 65, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_unchecked_mut_range.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_unchecked_mut_range.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_index.slice_get_unchecked_mut_range.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,65 +4,63 @@ fn slice_get_unchecked_mut_range(_1: &mut [u32], _2: std::ops::Range<usize>) ->\n     debug slice => _1;                   // in scope 0 at $DIR/slice_index.rs:+0:45: +0:50\n     debug index => _2;                   // in scope 0 at $DIR/slice_index.rs:+0:64: +0:69\n     let mut _0: &mut [u32];              // return place in scope 0 at $DIR/slice_index.rs:+0:88: +0:98\n+    let mut _3: usize;                   // in scope 0 at $DIR/slice_index.rs:+1:29: +1:34\n+    let mut _4: usize;                   // in scope 0 at $DIR/slice_index.rs:+1:29: +1:34\n     scope 1 (inlined core::slice::<impl [u32]>::get_unchecked_mut::<std::ops::Range<usize>>) { // at $DIR/slice_index.rs:26:11: 26:35\n         debug self => _1;                // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        debug index => _2;               // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        let mut _3: *mut [u32];          // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        let mut _15: *mut [u32];         // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        debug index => std::ops::Range<usize>{ .0 => _3, .1 => _4, }; // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        let mut _5: *mut [u32];          // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        let mut _14: *mut [u32];         // in scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         scope 2 {\n             scope 3 (inlined <std::ops::Range<usize> as SliceIndex<[u32]>>::get_unchecked_mut) { // at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-                debug self => _2;        // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                debug slice => _3;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _4: usize;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _5: usize;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                debug self => std::ops::Range<usize>{ .0 => _3, .1 => _4, }; // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                debug slice => _5;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                 let mut _7: *mut u32;    // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _8: usize;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _9: *mut u32;    // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _10: usize;      // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let _16: std::ops::Range<usize>; // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                let mut _17: std::ops::Range<usize>; // in scope 3 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                let mut _18: *mut [u32]; // in scope 3 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                let mut _8: *mut u32;    // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                let mut _9: usize;       // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                let _16: usize;          // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                let _17: usize;          // in scope 3 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                 scope 4 {\n-                    debug this => _16;   // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+                    debug this => std::ops::Range<usize>{ .0 => _16, .1 => _17, }; // in scope 4 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                     scope 5 {\n                         let _6: usize;   // in scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                         scope 6 {\n                             debug new_len => _6; // in scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                             scope 11 (inlined ptr::mut_ptr::<impl *mut [u32]>::as_mut_ptr) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                                debug self => _3; // in scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                debug self => _5; // in scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                             }\n                             scope 12 (inlined ptr::mut_ptr::<impl *mut u32>::add) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                                 debug self => _7; // in scope 12 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                debug count => _8; // in scope 12 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                debug count => _3; // in scope 12 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                 scope 13 {\n                                 }\n                             }\n                             scope 14 (inlined slice_from_raw_parts_mut::<u32>) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                                debug data => _9; // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                                debug len => _10; // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                                let mut _11: *mut (); // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                                debug data => _8; // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                                debug len => _9; // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                                let mut _10: *mut (); // in scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n                                 scope 15 (inlined ptr::mut_ptr::<impl *mut u32>::cast::<()>) { // at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                                    debug self => _9; // in scope 15 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                    debug self => _8; // in scope 15 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                 }\n                                 scope 16 (inlined std::ptr::from_raw_parts_mut::<[u32]>) { // at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-                                    debug data_address => _11; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-                                    debug metadata => _10; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-                                    let mut _12: *const (); // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-                                    let mut _13: std::ptr::metadata::PtrComponents<[u32]>; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-                                    let mut _14: std::ptr::metadata::PtrRepr<[u32]>; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    debug data_address => _10; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    debug metadata => _9; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    let mut _11: *const (); // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    let mut _12: std::ptr::metadata::PtrComponents<[u32]>; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    let mut _13: std::ptr::metadata::PtrRepr<[u32]>; // in scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n                                     scope 17 {\n                                     }\n                                 }\n                             }\n                         }\n                         scope 7 (inlined <std::ops::Range<usize> as SliceIndex<[T]>>::get_unchecked_mut::runtime::<u32>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                            debug this => _17; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                            debug slice => _18; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                            debug this => std::ops::Range<usize>{ .0 => _16, .1 => _17, }; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                            debug slice => _5; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                             scope 8 (inlined ptr::mut_ptr::<impl *mut [u32]>::len) { // at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-                                debug self => _18; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                let mut _19: *const [u32]; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                debug self => _5; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                let mut _15: *const [u32]; // in scope 8 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                 scope 9 (inlined std::ptr::metadata::<[u32]>) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                    debug ptr => _19; // in scope 9 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+                                    debug ptr => _15; // in scope 9 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n                                     scope 10 {\n                                     }\n                                 }\n@@ -75,60 +73,51 @@ fn slice_get_unchecked_mut_range(_1: &mut [u32], _2: std::ops::Range<usize>) ->\n     }\n \n     bb0: {\n+        _3 = move (_2.0: usize);         // scope 0 at $DIR/slice_index.rs:+1:29: +1:34\n+        _4 = move (_2.1: usize);         // scope 0 at $DIR/slice_index.rs:+1:29: +1:34\n+        StorageLive(_14);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _5 = &raw mut (*_1);             // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         StorageLive(_15);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        _3 = &raw mut (*_1);             // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         StorageLive(_16);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         StorageLive(_17);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_18);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageLive(_19);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         StorageLive(_6);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_4);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _4 = (_2.1: usize);              // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_5);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _5 = (_2.0: usize);              // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _6 = unchecked_sub::<usize>(move _4, move _5) -> [return: bb1, unwind unreachable]; // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _6 = unchecked_sub::<usize>(_4, _3) -> [return: bb1, unwind unreachable]; // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/slice/index.rs:LL:COL\n                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(usize, usize) -> usize {unchecked_sub::<usize>}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageDead(_5);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageDead(_4);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_9);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _7 = _3 as *mut u32 (PtrToPtr);  // scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n         StorageLive(_8);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _8 = (_2.0: usize);              // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _9 = Offset(_7, _8);             // scope 13 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-        StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _7 = _5 as *mut u32 (PtrToPtr);  // scope 11 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+        _8 = Offset(_7, _3);             // scope 13 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n         StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_10);                // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        _10 = _6;                        // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageLive(_11);                // scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        _11 = _9 as *mut () (PtrToPtr);  // scope 15 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-        StorageLive(_14);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageLive(_9);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _9 = _6;                         // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageLive(_10);                // scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+        _10 = _8 as *mut () (PtrToPtr);  // scope 15 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n         StorageLive(_13);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n         StorageLive(_12);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        _12 = _11 as *const () (Pointer(MutToConstPointer)); // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        _13 = ptr::metadata::PtrComponents::<[u32]> { data_address: move _12, metadata: _10 }; // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageLive(_11);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        _11 = _10 as *const () (Pointer(MutToConstPointer)); // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        _12 = ptr::metadata::PtrComponents::<[u32]> { data_address: move _11, metadata: _9 }; // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageDead(_11);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        _13 = ptr::metadata::PtrRepr::<[u32]> { const_ptr: move _12 }; // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n         StorageDead(_12);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        _14 = ptr::metadata::PtrRepr::<[u32]> { const_ptr: move _13 }; // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        StorageDead(_13);                // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        _15 = (_14.1: *mut [u32]);       // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        StorageDead(_14);                // scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n-        StorageDead(_11);                // scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-        StorageDead(_10);                // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        _14 = (_13.1: *mut [u32]);       // scope 17 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageDead(_13);                // scope 16 at $SRC_DIR/core/src/ptr/metadata.rs:LL:COL\n+        StorageDead(_10);                // scope 14 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n         StorageDead(_9);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n+        StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n         StorageDead(_6);                 // scope 5 at $SRC_DIR/core/src/slice/index.rs:LL:COL\n-        StorageDead(_19);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageDead(_18);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         StorageDead(_17);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         StorageDead(_16);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        _0 = &mut (*_15);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n-        StorageDead(_15);                // scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_15);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _0 = &mut (*_14);                // scope 2 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_14);                // scope 1 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n         return;                          // scope 0 at $DIR/slice_index.rs:+2:2: +2:2\n     }\n }"}, {"sha": "4dd11c1e529538fa8aa85c792766f556f15cc79f", "filename": "tests/mir-opt/pre-codegen/slice_iter.enumerated_loop.PreCodegen.after.mir", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.enumerated_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.enumerated_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.enumerated_loop.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,213 @@\n+// MIR for `enumerated_loop` after PreCodegen\n+\n+fn enumerated_loop(_1: &[T], _2: impl Fn(usize, &T)) -> () {\n+    debug slice => _1;                   // in scope 0 at $DIR/slice_iter.rs:+0:31: +0:36\n+    debug f => _2;                       // in scope 0 at $DIR/slice_iter.rs:+0:47: +0:48\n+    let mut _0: ();                      // return place in scope 0 at $DIR/slice_iter.rs:+0:70: +0:70\n+    let mut _13: std::slice::Iter<'_, T>; // in scope 0 at $DIR/slice_iter.rs:+1:19: +1:31\n+    let mut _14: std::iter::Enumerate<std::slice::Iter<'_, T>>; // in scope 0 at $DIR/slice_iter.rs:+1:19: +1:43\n+    let mut _15: std::iter::Enumerate<std::slice::Iter<'_, T>>; // in scope 0 at $DIR/slice_iter.rs:+1:19: +1:43\n+    let mut _16: &mut std::iter::Enumerate<std::slice::Iter<'_, T>>; // in scope 0 at $DIR/slice_iter.rs:+1:19: +1:43\n+    let mut _17: std::option::Option<(usize, &T)>; // in scope 0 at $DIR/slice_iter.rs:+1:19: +1:43\n+    let mut _18: isize;                  // in scope 0 at $DIR/slice_iter.rs:+1:5: +3:6\n+    let mut _21: &impl Fn(usize, &T);    // in scope 0 at $DIR/slice_iter.rs:+2:9: +2:10\n+    let mut _22: (usize, &T);            // in scope 0 at $DIR/slice_iter.rs:+2:9: +2:16\n+    let _23: ();                         // in scope 0 at $DIR/slice_iter.rs:+1:19: +1:43\n+    scope 1 {\n+        debug iter => _15;               // in scope 1 at $DIR/slice_iter.rs:+1:19: +1:43\n+        let _19: usize;                  // in scope 1 at $DIR/slice_iter.rs:+1:10: +1:11\n+        let _20: &T;                     // in scope 1 at $DIR/slice_iter.rs:+1:13: +1:14\n+        scope 2 {\n+            debug i => _19;              // in scope 2 at $DIR/slice_iter.rs:+1:10: +1:11\n+            debug x => _20;              // in scope 2 at $DIR/slice_iter.rs:+1:13: +1:14\n+        }\n+    }\n+    scope 3 (inlined core::slice::<impl [T]>::iter) { // at $DIR/slice_iter.rs:42:25: 42:31\n+        debug self => _1;                // in scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        scope 4 (inlined std::slice::Iter::<'_, T>::new) { // at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+            debug slice => _1;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let _4: *const T;            // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _5: bool;            // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _6: usize;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _8: usize;           // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _9: *mut T;          // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _11: std::ptr::NonNull<T>; // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            let mut _12: *const T;       // in scope 4 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+            scope 5 {\n+                debug ptr => _4;         // in scope 5 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                scope 6 {\n+                    let _7: *const T;    // in scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                    scope 7 {\n+                        debug end => _7; // in scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                        scope 13 (inlined NonNull::<T>::new_unchecked) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                            debug ptr => _9; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+                            let mut _10: *const T; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+                            scope 14 {\n+                                scope 15 (inlined NonNull::<T>::new_unchecked::runtime::<T>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                                    debug ptr => _9; // in scope 15 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                                    scope 16 (inlined ptr::mut_ptr::<impl *mut T>::is_null) { // at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+                                        debug self => _9; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                        let mut _24: *mut u8; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                        scope 17 {\n+                                            scope 18 (inlined ptr::mut_ptr::<impl *mut T>::is_null::runtime_impl) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                debug ptr => _24; // in scope 18 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                scope 19 (inlined ptr::mut_ptr::<impl *mut u8>::addr) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                    debug self => _24; // in scope 19 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                    scope 20 {\n+                                                        scope 21 (inlined ptr::mut_ptr::<impl *mut u8>::cast::<()>) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                            debug self => _24; // in scope 21 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                        }\n+                                                    }\n+                                                }\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                    scope 9 (inlined invalid::<T>) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                        debug addr => _8; // in scope 9 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                        scope 10 {\n+                        }\n+                    }\n+                    scope 11 (inlined ptr::const_ptr::<impl *const T>::add) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                        debug self => _4; // in scope 11 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+                        debug count => _6; // in scope 11 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+                        scope 12 {\n+                        }\n+                    }\n+                }\n+            }\n+            scope 8 (inlined core::slice::<impl [T]>::as_ptr) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                debug self => _1;        // in scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+                let mut _3: *const [T];  // in scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+            }\n+        }\n+    }\n+    scope 22 (inlined <std::slice::Iter<'_, T> as Iterator>::enumerate) { // at $DIR/slice_iter.rs:42:32: 42:43\n+        debug self => _13;               // in scope 22 at $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+        scope 23 (inlined Enumerate::<std::slice::Iter<'_, T>>::new) { // at $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+            debug iter => _13;           // in scope 23 at $SRC_DIR/core/src/iter/adapters/enumerate.rs:LL:COL\n+        }\n+    }\n+    scope 24 (inlined <Enumerate<std::slice::Iter<'_, T>> as IntoIterator>::into_iter) { // at $DIR/slice_iter.rs:42:19: 42:43\n+        debug self => _14;               // in scope 24 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+    }\n+\n+    bb0: {\n+        StorageLive(_13);                // scope 0 at $DIR/slice_iter.rs:+1:19: +1:31\n+        StorageLive(_4);                 // scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_3);                 // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _3 = &raw const (*_1);           // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _4 = move _3 as *const T (PtrToPtr); // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageDead(_3);                 // scope 8 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_5);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _5 = const _;                    // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        switchInt(move _5) -> [0: bb1, otherwise: bb2]; // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+    }\n+\n+    bb1: {\n+        StorageLive(_6);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _6 = Len((*_1));                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _7 = Offset(_4, _6);             // scope 12 at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+        StorageDead(_6);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+    }\n+\n+    bb2: {\n+        StorageLive(_8);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _8 = Len((*_1));                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _7 = _8 as *const T (Transmute); // scope 10 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+        StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        goto -> bb3;                     // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+    }\n+\n+    bb3: {\n+        StorageDead(_5);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_11);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_9);                 // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _9 = _4 as *mut T (PtrToPtr);    // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_10);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_24);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _10 = _9 as *const T (Pointer(MutToConstPointer)); // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+        _11 = NonNull::<T> { pointer: _10 }; // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n+        StorageDead(_24);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_10);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_9);                 // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageLive(_12);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _12 = _7;                        // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        _13 = std::slice::Iter::<'_, T> { ptr: move _11, end: move _12, _marker: const ZeroSized: PhantomData<&T> }; // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: no-location\n+                                         // + literal: Const { ty: PhantomData<&T>, val: Value(<ZST>) }\n+                                         // adt\n+                                         // + user_ty: UserType(1)\n+        StorageDead(_12);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_11);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n+        StorageDead(_4);                 // scope 3 at $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+        _14 = Enumerate::<std::slice::Iter<'_, T>> { iter: move _13, count: const 0_usize }; // scope 23 at $SRC_DIR/core/src/iter/adapters/enumerate.rs:LL:COL\n+        StorageDead(_13);                // scope 0 at $DIR/slice_iter.rs:+1:42: +1:43\n+        StorageLive(_15);                // scope 0 at $DIR/slice_iter.rs:+1:19: +1:43\n+        _15 = move _14;                  // scope 0 at $DIR/slice_iter.rs:+1:19: +1:43\n+        goto -> bb4;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +3:6\n+    }\n+\n+    bb4: {\n+        StorageLive(_17);                // scope 1 at $DIR/slice_iter.rs:+1:19: +1:43\n+        _16 = &mut _15;                  // scope 1 at $DIR/slice_iter.rs:+1:19: +1:43\n+        _17 = <Enumerate<std::slice::Iter<'_, T>> as Iterator>::next(_16) -> [return: bb5, unwind: bb11]; // scope 1 at $DIR/slice_iter.rs:+1:19: +1:43\n+                                         // mir::Constant\n+                                         // + span: $DIR/slice_iter.rs:42:19: 42:43\n+                                         // + literal: Const { ty: for<'a> fn(&'a mut Enumerate<std::slice::Iter<'_, T>>) -> Option<<Enumerate<std::slice::Iter<'_, T>> as Iterator>::Item> {<Enumerate<std::slice::Iter<'_, T>> as Iterator>::next}, val: Value(<ZST>) }\n+    }\n+\n+    bb5: {\n+        _18 = discriminant(_17);         // scope 1 at $DIR/slice_iter.rs:+1:19: +1:43\n+        switchInt(move _18) -> [0: bb6, 1: bb8, otherwise: bb10]; // scope 1 at $DIR/slice_iter.rs:+1:19: +1:43\n+    }\n+\n+    bb6: {\n+        StorageDead(_17);                // scope 1 at $DIR/slice_iter.rs:+3:5: +3:6\n+        StorageDead(_15);                // scope 0 at $DIR/slice_iter.rs:+3:5: +3:6\n+        drop(_2) -> bb7;                 // scope 0 at $DIR/slice_iter.rs:+4:1: +4:2\n+    }\n+\n+    bb7: {\n+        return;                          // scope 0 at $DIR/slice_iter.rs:+4:2: +4:2\n+    }\n+\n+    bb8: {\n+        _19 = (((_17 as Some).0: (usize, &T)).0: usize); // scope 1 at $DIR/slice_iter.rs:+1:10: +1:11\n+        _20 = (((_17 as Some).0: (usize, &T)).1: &T); // scope 1 at $DIR/slice_iter.rs:+1:13: +1:14\n+        StorageLive(_21);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:10\n+        _21 = &_2;                       // scope 2 at $DIR/slice_iter.rs:+2:9: +2:10\n+        StorageLive(_22);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:16\n+        _22 = (_19, _20);                // scope 2 at $DIR/slice_iter.rs:+2:9: +2:16\n+        _23 = <impl Fn(usize, &T) as Fn<(usize, &T)>>::call(move _21, move _22) -> [return: bb9, unwind: bb11]; // scope 2 at $DIR/slice_iter.rs:+2:9: +2:16\n+                                         // mir::Constant\n+                                         // + span: $DIR/slice_iter.rs:43:9: 43:10\n+                                         // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(usize, &T), (usize, &T)) -> <impl Fn(usize, &T) as FnOnce<(usize, &T)>>::Output {<impl Fn(usize, &T) as Fn<(usize, &T)>>::call}, val: Value(<ZST>) }\n+    }\n+\n+    bb9: {\n+        StorageDead(_22);                // scope 2 at $DIR/slice_iter.rs:+2:15: +2:16\n+        StorageDead(_21);                // scope 2 at $DIR/slice_iter.rs:+2:15: +2:16\n+        StorageDead(_17);                // scope 1 at $DIR/slice_iter.rs:+3:5: +3:6\n+        goto -> bb4;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +3:6\n+    }\n+\n+    bb10: {\n+        unreachable;                     // scope 1 at $DIR/slice_iter.rs:+1:19: +1:43\n+    }\n+\n+    bb11 (cleanup): {\n+        drop(_2) -> [return: bb12, unwind terminate]; // scope 0 at $DIR/slice_iter.rs:+4:1: +4:2\n+    }\n+\n+    bb12 (cleanup): {\n+        resume;                          // scope 0 at $DIR/slice_iter.rs:+0:1: +4:2\n+    }\n+}"}, {"sha": "0c18fb84bcd74a835ba6166415af7c1d5071250a", "filename": "tests/mir-opt/pre-codegen/slice_iter.forward_loop.PreCodegen.after.mir", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.forward_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.forward_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.forward_loop.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -39,21 +39,20 @@ fn forward_loop(_1: &[T], _2: impl Fn(&T)) -> () {\n                         scope 13 (inlined NonNull::<T>::new_unchecked) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                             debug ptr => _9; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n                             let mut _10: *const T; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-                            let mut _22: *mut T; // in scope 13 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                             scope 14 {\n                                 scope 15 (inlined NonNull::<T>::new_unchecked::runtime::<T>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                                    debug ptr => _22; // in scope 15 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                                    debug ptr => _9; // in scope 15 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                                     scope 16 (inlined ptr::mut_ptr::<impl *mut T>::is_null) { // at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-                                        debug self => _22; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                        let mut _23: *mut u8; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                        debug self => _9; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                        let mut _22: *mut u8; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                         scope 17 {\n                                             scope 18 (inlined ptr::mut_ptr::<impl *mut T>::is_null::runtime_impl) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                                debug ptr => _23; // in scope 18 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                debug ptr => _22; // in scope 18 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                                 scope 19 (inlined ptr::mut_ptr::<impl *mut u8>::addr) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                                    debug self => _23; // in scope 19 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                    debug self => _22; // in scope 19 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                                     scope 20 {\n                                                         scope 21 (inlined ptr::mut_ptr::<impl *mut u8>::cast::<()>) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                                            debug self => _23; // in scope 21 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                            debug self => _22; // in scope 21 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                                         }\n                                                     }\n                                                 }\n@@ -122,10 +121,8 @@ fn forward_loop(_1: &[T], _2: impl Fn(&T)) -> () {\n         _9 = _4 as *mut T (PtrToPtr);    // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         StorageLive(_10);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         StorageLive(_22);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_23);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         _10 = _9 as *const T (Pointer(MutToConstPointer)); // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n         _11 = NonNull::<T> { pointer: _10 }; // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-        StorageDead(_23);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         StorageDead(_22);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         StorageDead(_10);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         StorageDead(_9);                 // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL"}, {"sha": "ca7a4a64f4574243380b3e0257d2decfa743ad55", "filename": "tests/mir-opt/pre-codegen/slice_iter.range_loop.PreCodegen.after.mir", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.range_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.range_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.range_loop.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,155 @@\n+// MIR for `range_loop` after PreCodegen\n+\n+fn range_loop(_1: &[T], _2: impl Fn(usize, &T)) -> () {\n+    debug slice => _1;                   // in scope 0 at $DIR/slice_iter.rs:+0:26: +0:31\n+    debug f => _2;                       // in scope 0 at $DIR/slice_iter.rs:+0:42: +0:43\n+    let mut _0: ();                      // return place in scope 0 at $DIR/slice_iter.rs:+0:65: +0:65\n+    let mut _3: usize;                   // in scope 0 at $DIR/slice_iter.rs:+1:17: +1:28\n+    let mut _4: std::ops::Range<usize>;  // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:28\n+    let mut _5: std::ops::Range<usize>;  // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:28\n+    let mut _6: &mut std::ops::Range<usize>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:28\n+    let mut _10: std::option::Option<usize>; // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:28\n+    let mut _13: isize;                  // in scope 0 at $DIR/slice_iter.rs:+1:5: +4:6\n+    let mut _15: usize;                  // in scope 0 at $DIR/slice_iter.rs:+2:18: +2:26\n+    let mut _16: bool;                   // in scope 0 at $DIR/slice_iter.rs:+2:18: +2:26\n+    let mut _18: &impl Fn(usize, &T);    // in scope 0 at $DIR/slice_iter.rs:+3:9: +3:10\n+    let mut _19: (usize, &T);            // in scope 0 at $DIR/slice_iter.rs:+3:9: +3:16\n+    let _20: ();                         // in scope 0 at $DIR/slice_iter.rs:+1:14: +1:28\n+    scope 1 {\n+        debug iter => _5;                // in scope 1 at $DIR/slice_iter.rs:+1:14: +1:28\n+        let _14: usize;                  // in scope 1 at $DIR/slice_iter.rs:+1:9: +1:10\n+        scope 2 {\n+            debug i => _14;              // in scope 2 at $DIR/slice_iter.rs:+1:9: +1:10\n+            let _17: &T;                 // in scope 2 at $DIR/slice_iter.rs:+2:13: +2:14\n+            scope 3 {\n+                debug x => _17;          // in scope 3 at $DIR/slice_iter.rs:+2:13: +2:14\n+            }\n+        }\n+        scope 5 (inlined iter::range::<impl Iterator for std::ops::Range<usize>>::next) { // at $DIR/slice_iter.rs:49:14: 49:28\n+            debug self => _6;            // in scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+            scope 6 (inlined <std::ops::Range<usize> as iter::range::RangeIteratorImpl>::spec_next) { // at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                debug self => _6;        // in scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _7: &usize;      // in scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _8: &usize;      // in scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _9: bool;        // in scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let _11: usize;          // in scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                let mut _12: usize;      // in scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                scope 7 {\n+                    debug old => _11;    // in scope 7 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                    scope 8 {\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    scope 4 (inlined <std::ops::Range<usize> as IntoIterator>::into_iter) { // at $DIR/slice_iter.rs:49:14: 49:28\n+        debug self => _4;                // in scope 4 at $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+    }\n+\n+    bb0: {\n+        StorageLive(_3);                 // scope 0 at $DIR/slice_iter.rs:+1:17: +1:28\n+        _3 = Len((*_1));                 // scope 0 at $DIR/slice_iter.rs:+1:17: +1:28\n+        _4 = std::ops::Range::<usize> { start: const 0_usize, end: move _3 }; // scope 0 at $DIR/slice_iter.rs:+1:14: +1:28\n+        StorageDead(_3);                 // scope 0 at $DIR/slice_iter.rs:+1:27: +1:28\n+        StorageLive(_5);                 // scope 0 at $DIR/slice_iter.rs:+1:14: +1:28\n+        _5 = move _4;                    // scope 0 at $DIR/slice_iter.rs:+1:14: +1:28\n+        goto -> bb1;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +4:6\n+    }\n+\n+    bb1: {\n+        StorageLive(_10);                // scope 1 at $DIR/slice_iter.rs:+1:14: +1:28\n+        _6 = &mut _5;                    // scope 1 at $DIR/slice_iter.rs:+1:14: +1:28\n+        StorageLive(_11);                // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_9);                 // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_7);                 // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _7 = &((*_6).0: usize);          // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_8);                 // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _8 = &((*_6).1: usize);          // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _9 = <usize as PartialOrd>::lt(move _7, move _8) -> [return: bb2, unwind: bb13]; // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // + literal: Const { ty: for<'a, 'b> fn(&'a usize, &'b usize) -> bool {<usize as PartialOrd>::lt}, val: Value(<ZST>) }\n+    }\n+\n+    bb2: {\n+        StorageDead(_8);                 // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_7);                 // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        switchInt(move _9) -> [0: bb3, otherwise: bb4]; // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb3: {\n+        _10 = Option::<usize>::None;     // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        goto -> bb6;                     // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb4: {\n+        _11 = ((*_6).0: usize);          // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageLive(_12);                // scope 7 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _12 = <usize as Step>::forward_unchecked(_11, const 1_usize) -> [return: bb5, unwind: bb13]; // scope 8 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/core/src/iter/range.rs:LL:COL\n+                                         // + literal: Const { ty: unsafe fn(usize, usize) -> usize {<usize as Step>::forward_unchecked}, val: Value(<ZST>) }\n+    }\n+\n+    bb5: {\n+        ((*_6).0: usize) = move _12;     // scope 7 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_12);                // scope 7 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _10 = Option::<usize>::Some(_11); // scope 7 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        goto -> bb6;                     // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+    }\n+\n+    bb6: {\n+        StorageDead(_9);                 // scope 6 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        StorageDead(_11);                // scope 5 at $SRC_DIR/core/src/iter/range.rs:LL:COL\n+        _13 = discriminant(_10);         // scope 1 at $DIR/slice_iter.rs:+1:14: +1:28\n+        switchInt(move _13) -> [0: bb7, 1: bb9, otherwise: bb12]; // scope 1 at $DIR/slice_iter.rs:+1:14: +1:28\n+    }\n+\n+    bb7: {\n+        StorageDead(_10);                // scope 1 at $DIR/slice_iter.rs:+4:5: +4:6\n+        StorageDead(_5);                 // scope 0 at $DIR/slice_iter.rs:+4:5: +4:6\n+        drop(_2) -> bb8;                 // scope 0 at $DIR/slice_iter.rs:+5:1: +5:2\n+    }\n+\n+    bb8: {\n+        return;                          // scope 0 at $DIR/slice_iter.rs:+5:2: +5:2\n+    }\n+\n+    bb9: {\n+        _14 = ((_10 as Some).0: usize);  // scope 1 at $DIR/slice_iter.rs:+1:9: +1:10\n+        _15 = Len((*_1));                // scope 2 at $DIR/slice_iter.rs:+2:18: +2:26\n+        _16 = Lt(_14, _15);              // scope 2 at $DIR/slice_iter.rs:+2:18: +2:26\n+        assert(move _16, \"index out of bounds: the length is {} but the index is {}\", move _15, _14) -> [success: bb10, unwind: bb13]; // scope 2 at $DIR/slice_iter.rs:+2:18: +2:26\n+    }\n+\n+    bb10: {\n+        _17 = &(*_1)[_14];               // scope 2 at $DIR/slice_iter.rs:+2:17: +2:26\n+        StorageLive(_18);                // scope 3 at $DIR/slice_iter.rs:+3:9: +3:10\n+        _18 = &_2;                       // scope 3 at $DIR/slice_iter.rs:+3:9: +3:10\n+        StorageLive(_19);                // scope 3 at $DIR/slice_iter.rs:+3:9: +3:16\n+        _19 = (_14, _17);                // scope 3 at $DIR/slice_iter.rs:+3:9: +3:16\n+        _20 = <impl Fn(usize, &T) as Fn<(usize, &T)>>::call(move _18, move _19) -> [return: bb11, unwind: bb13]; // scope 3 at $DIR/slice_iter.rs:+3:9: +3:16\n+                                         // mir::Constant\n+                                         // + span: $DIR/slice_iter.rs:51:9: 51:10\n+                                         // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a impl Fn(usize, &T), (usize, &T)) -> <impl Fn(usize, &T) as FnOnce<(usize, &T)>>::Output {<impl Fn(usize, &T) as Fn<(usize, &T)>>::call}, val: Value(<ZST>) }\n+    }\n+\n+    bb11: {\n+        StorageDead(_19);                // scope 3 at $DIR/slice_iter.rs:+3:15: +3:16\n+        StorageDead(_18);                // scope 3 at $DIR/slice_iter.rs:+3:15: +3:16\n+        StorageDead(_10);                // scope 1 at $DIR/slice_iter.rs:+4:5: +4:6\n+        goto -> bb1;                     // scope 1 at $DIR/slice_iter.rs:+1:5: +4:6\n+    }\n+\n+    bb12: {\n+        unreachable;                     // scope 1 at $DIR/slice_iter.rs:+1:14: +1:28\n+    }\n+\n+    bb13 (cleanup): {\n+        drop(_2) -> [return: bb14, unwind terminate]; // scope 0 at $DIR/slice_iter.rs:+5:1: +5:2\n+    }\n+\n+    bb14 (cleanup): {\n+        resume;                          // scope 0 at $DIR/slice_iter.rs:+0:1: +5:2\n+    }\n+}"}, {"sha": "1aa05cbeb97701adbd934f561e509e9962c6eb43", "filename": "tests/mir-opt/pre-codegen/slice_iter.reverse_loop.PreCodegen.after.mir", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.reverse_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.reverse_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.reverse_loop.PreCodegen.after.mir?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -44,21 +44,20 @@ fn reverse_loop(_1: &[T], _2: impl Fn(&T)) -> () {\n                         scope 13 (inlined NonNull::<T>::new_unchecked) { // at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n                             debug ptr => _9; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n                             let mut _10: *const T; // in scope 13 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-                            let mut _24: *mut T; // in scope 13 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                             scope 14 {\n                                 scope 15 (inlined NonNull::<T>::new_unchecked::runtime::<T>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-                                    debug ptr => _24; // in scope 15 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                                    debug ptr => _9; // in scope 15 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n                                     scope 16 (inlined ptr::mut_ptr::<impl *mut T>::is_null) { // at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-                                        debug self => _24; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                        let mut _25: *mut u8; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                        debug self => _9; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                        let mut _24: *mut u8; // in scope 16 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                         scope 17 {\n                                             scope 18 (inlined ptr::mut_ptr::<impl *mut T>::is_null::runtime_impl) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                                debug ptr => _25; // in scope 18 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                debug ptr => _24; // in scope 18 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                                 scope 19 (inlined ptr::mut_ptr::<impl *mut u8>::addr) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                                    debug self => _25; // in scope 19 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                    debug self => _24; // in scope 19 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                                     scope 20 {\n                                                         scope 21 (inlined ptr::mut_ptr::<impl *mut u8>::cast::<()>) { // at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-                                                            debug self => _25; // in scope 21 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+                                                            debug self => _24; // in scope 21 at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n                                                         }\n                                                     }\n                                                 }\n@@ -134,10 +133,8 @@ fn reverse_loop(_1: &[T], _2: impl Fn(&T)) -> () {\n         _9 = _4 as *mut T (PtrToPtr);    // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         StorageLive(_10);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         StorageLive(_24);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n-        StorageLive(_25);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         _10 = _9 as *const T (Pointer(MutToConstPointer)); // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n         _11 = NonNull::<T> { pointer: _10 }; // scope 14 at $SRC_DIR/core/src/ptr/non_null.rs:LL:COL\n-        StorageDead(_25);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         StorageDead(_24);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         StorageDead(_10);                // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL\n         StorageDead(_9);                 // scope 7 at $SRC_DIR/core/src/slice/iter.rs:LL:COL"}, {"sha": "a1cd85e753f6381a8eca106f0d2e6fabe947a493", "filename": "tests/mir-opt/pre-codegen/slice_iter.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fslice_iter.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -36,3 +36,18 @@ pub fn reverse_loop<'a, T>(slice: &'a [T], f: impl Fn(&T)) {\n         f(x)\n     }\n }\n+\n+// EMIT_MIR slice_iter.enumerated_loop.PreCodegen.after.mir\n+pub fn enumerated_loop<'a, T>(slice: &'a [T], f: impl Fn(usize, &T)) {\n+    for (i, x) in slice.iter().enumerate() {\n+        f(i, x)\n+    }\n+}\n+\n+// EMIT_MIR slice_iter.range_loop.PreCodegen.after.mir\n+pub fn range_loop<'a, T>(slice: &'a [T], f: impl Fn(usize, &T)) {\n+    for i in 0..slice.len() {\n+        let x = &slice[i];\n+        f(i, x)\n+    }\n+}"}, {"sha": "7f0e50a23f972f8ab58d957f227276a3a76c06d3", "filename": "tests/mir-opt/separate_const_switch.identity.SeparateConstSwitch.diff", "status": "modified", "additions": 29, "deletions": 49, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -9,70 +9,61 @@\n       let mut _4: std::result::Result<i32, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n       let mut _5: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n       let _6: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-      let mut _7: !;                       // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-      let mut _8: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+      let mut _7: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n+      let _8: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n       scope 1 {\n           debug residual => _6;            // in scope 1 at $DIR/separate_const_switch.rs:+1:9: +1:10\n           scope 2 {\n               scope 8 (inlined #[track_caller] <Result<i32, i32> as FromResidual<Result<Infallible, i32>>>::from_residual) { // at $DIR/separate_const_switch.rs:25:8: 25:10\n-                  debug residual => _8;    // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let _14: i32;            // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _15: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+                  debug residual => _6;    // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+                  let _13: i32;            // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+                  let mut _14: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n                   scope 9 {\n-                      debug e => _14;      // in scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+                      debug e => _13;      // in scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n                       scope 10 (inlined <i32 as From<i32>>::from) { // at $SRC_DIR/core/src/result.rs:LL:COL\n-                          debug t => _14;  // in scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+                          debug t => _13;  // in scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n                       }\n                   }\n               }\n           }\n       }\n       scope 3 {\n-          debug val => _9;                 // in scope 3 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+          debug val => _8;                 // in scope 3 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           scope 4 {\n           }\n       }\n       scope 5 (inlined <Result<i32, i32> as Try>::branch) { // at $DIR/separate_const_switch.rs:25:8: 25:10\n-          debug self => _4;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let mut _10: isize;              // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          debug self => _1;                // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          let mut _9: isize;               // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          let _10: i32;                    // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           let _11: i32;                    // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let _12: i32;                    // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          let mut _13: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          let mut _12: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           scope 6 {\n-              debug v => _11;              // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n+              debug v => _10;              // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n           }\n           scope 7 {\n-              debug e => _12;              // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+              debug e => _11;              // in scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n           }\n       }\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           StorageLive(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n-          _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n+          StorageLive(_10);                // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           StorageLive(_11);                // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          StorageLive(_12);                // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          _10 = discriminant(_4);          // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          switchInt(move _10) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _9 = discriminant(_1);           // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          switchInt(move _9) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   \n       bb1: {\n-          StorageDead(_12);                // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           StorageDead(_11);                // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n+          StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n       }\n   \n       bb2: {\n-          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          _9 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          _2 = _9;                         // scope 4 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          _0 = Result::<i32, i32>::Ok(move _2); // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n-          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:10: +1:11\n+          _8 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+          _0 = Result::<i32, i32>::Ok(_8); // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n           StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/separate_const_switch.rs:+2:2: +2:2\n       }\n@@ -82,30 +73,19 @@\n       }\n   \n       bb4: {\n-          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n           _6 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageLive(_8);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          _8 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageLive(_14);                // scope 2 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          _14 = move ((_8 as Err).0: i32); // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_15);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _15 = move _14;                  // scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-          _0 = Result::<i32, i32>::Err(move _15); // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_15);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_14);                // scope 2 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-          StorageDead(_8);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:10: +1:11\n+          _13 = ((_6 as Err).0: i32);      // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _0 = Result::<i32, i32>::Err(move _13); // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/separate_const_switch.rs:+2:2: +2:2\n       }\n   \n       bb5: {\n-          _12 = move ((_4 as Err).0: i32); // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageLive(_13);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _13 = Result::<Infallible, i32>::Err(move _12); // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _3 = ControlFlow::<Result<Infallible, i32>, i32>::Break(move _13); // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_13);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _11 = ((_1 as Err).0: i32);      // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageLive(_12);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _12 = Result::<Infallible, i32>::Err(move _11); // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _3 = ControlFlow::<Result<Infallible, i32>, i32>::Break(move _12); // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+          StorageDead(_12);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n           goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   \n@@ -114,8 +94,8 @@\n       }\n   \n       bb7: {\n-          _11 = move ((_4 as Ok).0: i32);  // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-          _3 = ControlFlow::<Result<Infallible, i32>, i32>::Continue(move _11); // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _10 = ((_1 as Ok).0: i32);       // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _3 = ControlFlow::<Result<Infallible, i32>, i32>::Continue(move _10); // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n           goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   }"}, {"sha": "f86a96dec4155fd0bf98e025fa53be725c76b7b7", "filename": "tests/mir-opt/separate_const_switch.too_complex.SeparateConstSwitch.diff", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -34,13 +34,8 @@\n       }\n   \n       bb1: {\n-          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+8:17: +8:18\n           _6 = ((_1 as Err).0: usize);     // scope 0 at $DIR/separate_const_switch.rs:+8:17: +8:18\n-          StorageLive(_7);                 // scope 2 at $DIR/separate_const_switch.rs:+8:42: +8:43\n-          _7 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:+8:42: +8:43\n-          _2 = ControlFlow::<usize, i32>::Break(move _7); // scope 2 at $DIR/separate_const_switch.rs:+8:23: +8:44\n-          StorageDead(_7);                 // scope 2 at $DIR/separate_const_switch.rs:+8:43: +8:44\n-          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+8:43: +8:44\n+          _2 = ControlFlow::<usize, i32>::Break(_6); // scope 2 at $DIR/separate_const_switch.rs:+8:23: +8:44\n           goto -> bb4;                     // scope 0 at $DIR/separate_const_switch.rs:+8:43: +8:44\n       }\n   \n@@ -49,13 +44,8 @@\n       }\n   \n       bb3: {\n-          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+7:16: +7:17\n           _4 = ((_1 as Ok).0: i32);        // scope 0 at $DIR/separate_const_switch.rs:+7:16: +7:17\n-          StorageLive(_5);                 // scope 1 at $DIR/separate_const_switch.rs:+7:44: +7:45\n-          _5 = _4;                         // scope 1 at $DIR/separate_const_switch.rs:+7:44: +7:45\n-          _2 = ControlFlow::<usize, i32>::Continue(move _5); // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n-          StorageDead(_5);                 // scope 1 at $DIR/separate_const_switch.rs:+7:45: +7:46\n-          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+7:45: +7:46\n+          _2 = ControlFlow::<usize, i32>::Continue(_4); // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n           goto -> bb4;                     // scope 0 at $DIR/separate_const_switch.rs:+7:45: +7:46\n       }\n   \n@@ -73,13 +63,8 @@\n       }\n   \n       bb6: {\n-          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+11:31: +11:32\n           _9 = ((_2 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:+11:31: +11:32\n-          StorageLive(_10);                // scope 3 at $DIR/separate_const_switch.rs:+11:42: +11:43\n-          _10 = _9;                        // scope 3 at $DIR/separate_const_switch.rs:+11:42: +11:43\n-          _0 = Option::<i32>::Some(move _10); // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n-          StorageDead(_10);                // scope 3 at $DIR/separate_const_switch.rs:+11:43: +11:44\n-          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+11:43: +11:44\n+          _0 = Option::<i32>::Some(_9);    // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n           goto -> bb7;                     // scope 0 at $DIR/separate_const_switch.rs:+11:43: +11:44\n       }\n   "}, {"sha": "be32f40f132277752b6ef37db089881dd66fa2c1", "filename": "tests/mir-opt/slice_filter.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fslice_filter.rs?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,20 +0,0 @@\n-fn main() {\n-    let input = vec![];\n-    let _variant_a_result = variant_a(&input);\n-    let _variant_b_result = variant_b(&input);\n-}\n-\n-pub fn variant_a(input: &[(usize, usize, usize, usize)]) -> usize {\n-    input.iter().filter(|(a, b, c, d)| a <= c && d <= b || c <= a && b <= d).count()\n-}\n-\n-pub fn variant_b(input: &[(usize, usize, usize, usize)]) -> usize {\n-    input.iter().filter(|&&(a, b, c, d)| a <= c && d <= b || c <= a && b <= d).count()\n-}\n-\n-// EMIT_MIR slice_filter.variant_a-{closure#0}.ReferencePropagation.diff\n-// EMIT_MIR slice_filter.variant_a-{closure#0}.CopyProp.diff\n-// EMIT_MIR slice_filter.variant_a-{closure#0}.DestinationPropagation.diff\n-// EMIT_MIR slice_filter.variant_b-{closure#0}.CopyProp.diff\n-// EMIT_MIR slice_filter.variant_b-{closure#0}.ReferencePropagation.diff\n-// EMIT_MIR slice_filter.variant_b-{closure#0}.DestinationPropagation.diff"}, {"sha": "60e5056c7a92609f677aeda7b7a6fac661d753c1", "filename": "tests/mir-opt/slice_filter.variant_a-{closure#0}.CopyProp.diff", "status": "removed", "additions": 0, "deletions": 279, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.CopyProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.CopyProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.CopyProp.diff?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,279 +0,0 @@\n-- // MIR for `variant_a::{closure#0}` before CopyProp\n-+ // MIR for `variant_a::{closure#0}` after CopyProp\n-  \n-  fn variant_a::{closure#0}(_1: &mut [closure@$DIR/slice_filter.rs:8:25: 8:39], _2: &&(usize, usize, usize, usize)) -> bool {\n-      let mut _0: bool;                    // return place in scope 0 at $DIR/slice_filter.rs:+0:40: +0:40\n-      let _3: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n-      let _4: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n-      let _5: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n-      let _6: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n-      let mut _7: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:56\n-      let mut _8: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:46\n-      let mut _9: &&usize;                 // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:41\n-      let mut _10: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:45: +0:46\n-      let _11: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:45: +0:46\n-      let mut _12: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:50: +0:56\n-      let mut _13: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:50: +0:51\n-      let mut _14: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:55: +0:56\n-      let _15: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:55: +0:56\n-      let mut _16: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:76\n-      let mut _17: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:66\n-      let mut _18: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:61\n-      let mut _19: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:65: +0:66\n-      let _20: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:65: +0:66\n-      let mut _21: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:70: +0:76\n-      let mut _22: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:70: +0:71\n-      let mut _23: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n-      let _24: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n-      let mut _25: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _26: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _27: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _28: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _31: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _32: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _37: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _38: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _43: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _44: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _49: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _50: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      scope 1 {\n-          debug a => _3;                   // in scope 1 at $DIR/slice_filter.rs:+0:27: +0:28\n-          debug b => _4;                   // in scope 1 at $DIR/slice_filter.rs:+0:30: +0:31\n-          debug c => _5;                   // in scope 1 at $DIR/slice_filter.rs:+0:33: +0:34\n-          debug d => _6;                   // in scope 1 at $DIR/slice_filter.rs:+0:36: +0:37\n-          scope 2 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:40: 8:46\n-              debug self => _9;            // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              debug other => _10;          // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _29: &usize;         // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _30: &usize;         // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 3 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _31;       // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _32;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => _29;       // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => _30;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _33: usize;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _34: usize;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-          scope 4 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:60: 8:66\n-              debug self => _18;           // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              debug other => _19;          // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _35: &usize;         // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _36: &usize;         // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 5 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _37;       // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _38;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => _35;       // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => _36;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _39: usize;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _40: usize;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-          scope 6 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:50: 8:56\n-              debug self => _13;           // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              debug other => _14;          // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _41: &usize;         // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _42: &usize;         // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 7 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _43;       // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _44;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => _41;       // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => _42;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _45: usize;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _46: usize;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-          scope 8 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:70: 8:76\n-              debug self => _22;           // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              debug other => _23;          // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _47: &usize;         // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _48: &usize;         // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 9 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _49;       // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _50;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => _47;       // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => _48;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _51: usize;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _52: usize;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-      }\n-  \n-      bb0: {\n-          StorageLive(_3);                 // scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n-          _25 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n-          _3 = &((*_25).0: usize);         // scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n-          StorageLive(_4);                 // scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n-          _26 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n-          _4 = &((*_26).1: usize);         // scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n-          StorageLive(_5);                 // scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n-          _27 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n-          _5 = &((*_27).2: usize);         // scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n-          StorageLive(_6);                 // scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n-          _28 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n-          _6 = &((*_28).3: usize);         // scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n-          StorageLive(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-          StorageLive(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:46\n-          StorageLive(_9);                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:41\n-          _9 = &_3;                        // scope 1 at $DIR/slice_filter.rs:+0:40: +0:41\n-          StorageLive(_10);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n-          StorageLive(_11);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n-          _11 = _5;                        // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n-          _10 = &_11;                      // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n-          _29 = deref_copy (*_9);          // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _30 = deref_copy (*_10);         // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_31);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _31 = _29;                       // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_32);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _32 = _30;                       // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_33);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _33 = (*_31);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _33 = (*_29);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_34);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _34 = (*_32);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _34 = (*_30);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _8 = Le(move _33, move _34);     // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_34);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_33);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_32);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_31);                // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n-          StorageDead(_10);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n-          StorageDead(_9);                 // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n-          switchInt(move _8) -> [0: bb4, otherwise: bb5]; // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-      }\n-  \n-      bb1: {\n-          _0 = const true;                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-      }\n-  \n-      bb2: {\n-          StorageLive(_16);                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-          StorageLive(_17);                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:66\n-          StorageLive(_18);                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:61\n-          _18 = &_5;                       // scope 1 at $DIR/slice_filter.rs:+0:60: +0:61\n-          StorageLive(_19);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n-          StorageLive(_20);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n-          _20 = _3;                        // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n-          _19 = &_20;                      // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n-          _35 = deref_copy (*_18);         // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _36 = deref_copy (*_19);         // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_37);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _37 = _35;                       // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_38);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _38 = _36;                       // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_39);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _39 = (*_37);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _39 = (*_35);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_40);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _40 = (*_38);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _40 = (*_36);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _17 = Le(move _39, move _40);    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_40);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_39);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_38);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_37);                // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_20);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n-          StorageDead(_19);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n-          StorageDead(_18);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n-          switchInt(move _17) -> [0: bb6, otherwise: bb7]; // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-      }\n-  \n-      bb3: {\n-          StorageDead(_16);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_6);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_5);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_4);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_3);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n-          return;                          // scope 0 at $DIR/slice_filter.rs:+0:76: +0:76\n-      }\n-  \n-      bb4: {\n-          _7 = const false;                // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-          StorageDead(_12);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          goto -> bb2;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-      }\n-  \n-      bb5: {\n-          StorageLive(_12);                // scope 1 at $DIR/slice_filter.rs:+0:50: +0:56\n-          StorageLive(_13);                // scope 1 at $DIR/slice_filter.rs:+0:50: +0:51\n-          _13 = &_6;                       // scope 1 at $DIR/slice_filter.rs:+0:50: +0:51\n-          StorageLive(_14);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          StorageLive(_15);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          _15 = _4;                        // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          _14 = &_15;                      // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          _41 = deref_copy (*_13);         // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _42 = deref_copy (*_14);         // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_43);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _43 = _41;                       // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_44);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _44 = _42;                       // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_45);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _45 = (*_43);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _45 = (*_41);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_46);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _46 = (*_44);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _46 = (*_42);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _12 = Le(move _45, move _46);    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_46);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_45);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_44);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_43);                // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_15);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          StorageDead(_14);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          StorageDead(_13);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          _7 = move _12;                   // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-          StorageDead(_12);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          switchInt(move _7) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-      }\n-  \n-      bb6: {\n-          _16 = const false;               // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-      }\n-  \n-      bb7: {\n-          StorageLive(_21);                // scope 1 at $DIR/slice_filter.rs:+0:70: +0:76\n-          StorageLive(_22);                // scope 1 at $DIR/slice_filter.rs:+0:70: +0:71\n-          _22 = &_4;                       // scope 1 at $DIR/slice_filter.rs:+0:70: +0:71\n-          StorageLive(_23);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageLive(_24);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          _24 = _6;                        // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          _23 = &_24;                      // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          _47 = deref_copy (*_22);         // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _48 = deref_copy (*_23);         // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_49);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _49 = _47;                       // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageLive(_50);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _50 = _48;                       // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_51);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _51 = (*_49);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _51 = (*_47);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_52);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _52 = (*_50);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _52 = (*_48);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _21 = Le(move _51, move _52);    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_52);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_51);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_50);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_49);                // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_24);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_23);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_22);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          _16 = move _21;                  // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-      }\n-  \n-      bb8: {\n-          StorageDead(_21);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_17);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          _0 = move _16;                   // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-      }\n-  }\n-  "}, {"sha": "afdcf57815f387dd20e15a3c3cc05bdfd645ba13", "filename": "tests/mir-opt/slice_filter.variant_a-{closure#0}.DestinationPropagation.diff", "status": "removed", "additions": 0, "deletions": 165, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.DestinationPropagation.diff?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,165 +0,0 @@\n-- // MIR for `variant_a::{closure#0}` before DestinationPropagation\n-+ // MIR for `variant_a::{closure#0}` after DestinationPropagation\n-  \n-  fn variant_a::{closure#0}(_1: &mut [closure@$DIR/slice_filter.rs:8:25: 8:39], _2: &&(usize, usize, usize, usize)) -> bool {\n-      let mut _0: bool;                    // return place in scope 0 at $DIR/slice_filter.rs:+0:40: +0:40\n-      let mut _3: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:56\n-      let mut _4: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:46\n-      let mut _5: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:50: +0:56\n-      let mut _6: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:76\n-      let mut _7: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:66\n-      let mut _8: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:70: +0:76\n-      let mut _9: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _10: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _11: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _12: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      scope 1 {\n-          debug a => &((*_9).0: usize);    // in scope 1 at $DIR/slice_filter.rs:+0:27: +0:28\n-          debug b => &((*_10).1: usize);   // in scope 1 at $DIR/slice_filter.rs:+0:30: +0:31\n-          debug c => &((*_11).2: usize);   // in scope 1 at $DIR/slice_filter.rs:+0:33: +0:34\n-          debug d => &((*_12).3: usize);   // in scope 1 at $DIR/slice_filter.rs:+0:36: +0:37\n-          scope 2 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:40: 8:46\n-              debug self => &&((*_9).0: usize); // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              debug other => &&((*_11).2: usize); // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 3 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  debug self => &((*_9).0: usize); // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  debug other => &((*_11).2: usize); // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _13: usize;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _14: usize;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-          scope 4 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:60: 8:66\n-              debug self => &&((*_11).2: usize); // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              debug other => &&((*_9).0: usize); // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 5 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  debug self => &((*_11).2: usize); // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  debug other => &((*_9).0: usize); // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _15: usize;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _16: usize;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-          scope 6 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:50: 8:56\n-              debug self => &&((*_12).3: usize); // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              debug other => &&((*_10).1: usize); // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 7 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  debug self => &((*_12).3: usize); // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  debug other => &((*_10).1: usize); // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _17: usize;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _18: usize;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-          scope 8 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:70: 8:76\n-              debug self => &&((*_10).1: usize); // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              debug other => &&((*_12).3: usize); // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 9 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  debug self => &((*_10).1: usize); // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  debug other => &((*_12).3: usize); // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _19: usize;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _20: usize;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-      }\n-  \n-      bb0: {\n-          _9 = deref_copy (*_2);           // scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n-          _10 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n-          _11 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n-          _12 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n--         StorageLive(_3);                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-          StorageLive(_4);                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:46\n-          StorageLive(_13);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _13 = ((*_9).0: usize);          // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_14);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _14 = ((*_11).2: usize);         // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _4 = Le(move _13, move _14);     // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_14);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_13);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          switchInt(move _4) -> [0: bb4, otherwise: bb5]; // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-      }\n-  \n-      bb1: {\n-          _0 = const true;                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-      }\n-  \n-      bb2: {\n--         StorageLive(_6);                 // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-          StorageLive(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:60: +0:66\n-          StorageLive(_15);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _15 = ((*_11).2: usize);         // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_16);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _16 = ((*_9).0: usize);          // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _7 = Le(move _15, move _16);     // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_16);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_15);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          switchInt(move _7) -> [0: bb6, otherwise: bb7]; // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-      }\n-  \n-      bb3: {\n--         StorageDead(_6);                 // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n--         StorageDead(_3);                 // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          return;                          // scope 0 at $DIR/slice_filter.rs:+0:76: +0:76\n-      }\n-  \n-      bb4: {\n--         StorageDead(_5);                 // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          StorageDead(_4);                 // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          goto -> bb2;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-      }\n-  \n-      bb5: {\n--         StorageLive(_5);                 // scope 1 at $DIR/slice_filter.rs:+0:50: +0:56\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:50: +0:56\n-          StorageLive(_17);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _17 = ((*_12).3: usize);         // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_18);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _18 = ((*_10).1: usize);         // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _5 = Le(move _17, move _18);     // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_18);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_17);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _3 = move _5;                    // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n--         StorageDead(_5);                 // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          StorageDead(_4);                 // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n--         switchInt(move _3) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-+         switchInt(move _5) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-      }\n-  \n-      bb6: {\n--         _6 = const false;                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-+         _0 = const false;                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-      }\n-  \n-      bb7: {\n--         StorageLive(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:70: +0:76\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:70: +0:76\n-          StorageLive(_19);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _19 = ((*_10).1: usize);         // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_20);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _20 = ((*_12).3: usize);         // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _8 = Le(move _19, move _20);     // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _0 = Le(move _19, move _20);     // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_20);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_19);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _6 = move _8;                    // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-      }\n-  \n-      bb8: {\n--         StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n--         _0 = move _6;                    // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-      }\n-  }\n-  "}, {"sha": "2534eeef43297c1278ecb8113c8b5775a8ce6d95", "filename": "tests/mir-opt/slice_filter.variant_a-{closure#0}.ReferencePropagation.diff", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.ReferencePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.ReferencePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fslice_filter.variant_a-%7Bclosure%230%7D.ReferencePropagation.diff?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,267 +0,0 @@\n-- // MIR for `variant_a::{closure#0}` before ReferencePropagation\n-+ // MIR for `variant_a::{closure#0}` after ReferencePropagation\n-  \n-  fn variant_a::{closure#0}(_1: &mut [closure@$DIR/slice_filter.rs:8:25: 8:39], _2: &&(usize, usize, usize, usize)) -> bool {\n-      let mut _0: bool;                    // return place in scope 0 at $DIR/slice_filter.rs:+0:40: +0:40\n-      let _3: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n-      let _4: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n-      let _5: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n-      let _6: &usize;                      // in scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n-      let mut _7: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:56\n-      let mut _8: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:46\n-      let mut _9: &&usize;                 // in scope 0 at $DIR/slice_filter.rs:+0:40: +0:41\n-      let mut _10: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:45: +0:46\n-      let _11: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:45: +0:46\n-      let mut _12: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:50: +0:56\n-      let mut _13: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:50: +0:51\n-      let mut _14: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:55: +0:56\n-      let _15: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:55: +0:56\n-      let mut _16: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:76\n-      let mut _17: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:66\n-      let mut _18: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:60: +0:61\n-      let mut _19: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:65: +0:66\n-      let _20: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:65: +0:66\n-      let mut _21: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:70: +0:76\n-      let mut _22: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:70: +0:71\n-      let mut _23: &&usize;                // in scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n-      let _24: &usize;                     // in scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n-      let mut _25: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _26: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _27: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _28: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:38\n-      let mut _31: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _32: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _37: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _38: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _43: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _44: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _49: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      let mut _50: &usize;                 // in scope 0 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-      scope 1 {\n--         debug a => _3;                   // in scope 1 at $DIR/slice_filter.rs:+0:27: +0:28\n--         debug b => _4;                   // in scope 1 at $DIR/slice_filter.rs:+0:30: +0:31\n--         debug c => _5;                   // in scope 1 at $DIR/slice_filter.rs:+0:33: +0:34\n--         debug d => _6;                   // in scope 1 at $DIR/slice_filter.rs:+0:36: +0:37\n-+         debug a => &((*_25).0: usize);   // in scope 1 at $DIR/slice_filter.rs:+0:27: +0:28\n-+         debug b => &((*_26).1: usize);   // in scope 1 at $DIR/slice_filter.rs:+0:30: +0:31\n-+         debug c => &((*_27).2: usize);   // in scope 1 at $DIR/slice_filter.rs:+0:33: +0:34\n-+         debug d => &((*_28).3: usize);   // in scope 1 at $DIR/slice_filter.rs:+0:36: +0:37\n-          scope 2 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:40: 8:46\n--             debug self => _9;            // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--             debug other => _10;          // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+             debug self => &&((*_25).0: usize); // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+             debug other => &&((*_27).2: usize); // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _29: &usize;         // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _30: &usize;         // in scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 3 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _29;       // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _30;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => &((*_25).0: usize); // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => &((*_27).2: usize); // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _33: usize;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _34: usize;      // in scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-          scope 4 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:60: 8:66\n--             debug self => _18;           // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--             debug other => _19;          // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+             debug self => &&((*_27).2: usize); // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+             debug other => &&((*_25).0: usize); // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _35: &usize;         // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _36: &usize;         // in scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 5 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _35;       // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _36;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => &((*_27).2: usize); // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => &((*_25).0: usize); // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _39: usize;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _40: usize;      // in scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-          scope 6 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:50: 8:56\n--             debug self => _13;           // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--             debug other => _14;          // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+             debug self => &&((*_28).3: usize); // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+             debug other => &&((*_26).1: usize); // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _41: &usize;         // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _42: &usize;         // in scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 7 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _41;       // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _42;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => &((*_28).3: usize); // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => &((*_26).1: usize); // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _45: usize;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _46: usize;      // in scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-          scope 8 (inlined cmp::impls::<impl PartialOrd for &usize>::le) { // at $DIR/slice_filter.rs:8:70: 8:76\n--             debug self => _22;           // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--             debug other => _23;          // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+             debug self => &&((*_26).1: usize); // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+             debug other => &&((*_28).3: usize); // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _47: &usize;         // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              let mut _48: &usize;         // in scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              scope 9 (inlined cmp::impls::<impl PartialOrd for usize>::le) { // at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug self => _47;       // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--                 debug other => _48;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug self => &((*_26).1: usize); // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+                 debug other => &((*_28).3: usize); // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _51: usize;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-                  let mut _52: usize;      // in scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-              }\n-          }\n-      }\n-  \n-      bb0: {\n--         StorageLive(_3);                 // scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n-          _25 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n--         _3 = &((*_25).0: usize);         // scope 0 at $DIR/slice_filter.rs:+0:27: +0:28\n--         StorageLive(_4);                 // scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n-          _26 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n--         _4 = &((*_26).1: usize);         // scope 0 at $DIR/slice_filter.rs:+0:30: +0:31\n--         StorageLive(_5);                 // scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n-          _27 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n--         _5 = &((*_27).2: usize);         // scope 0 at $DIR/slice_filter.rs:+0:33: +0:34\n--         StorageLive(_6);                 // scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n-          _28 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n--         _6 = &((*_28).3: usize);         // scope 0 at $DIR/slice_filter.rs:+0:36: +0:37\n-          StorageLive(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-          StorageLive(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:46\n--         StorageLive(_9);                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:41\n--         _9 = &_3;                        // scope 1 at $DIR/slice_filter.rs:+0:40: +0:41\n--         StorageLive(_10);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n--         StorageLive(_11);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n--         _11 = _5;                        // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n--         _10 = &_11;                      // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n--         _29 = deref_copy (*_9);          // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _30 = deref_copy (*_10);         // scope 2 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_33);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _33 = (*_29);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _33 = ((*_25).0: usize);         // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_34);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _34 = (*_30);                    // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _34 = ((*_27).2: usize);         // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _8 = Le(move _33, move _34);     // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_34);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_33);                // scope 3 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n--         StorageDead(_10);                // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n--         StorageDead(_9);                 // scope 1 at $DIR/slice_filter.rs:+0:45: +0:46\n-          switchInt(move _8) -> [0: bb4, otherwise: bb5]; // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-      }\n-  \n-      bb1: {\n-          _0 = const true;                 // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-      }\n-  \n-      bb2: {\n-          StorageLive(_16);                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-          StorageLive(_17);                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:66\n--         StorageLive(_18);                // scope 1 at $DIR/slice_filter.rs:+0:60: +0:61\n--         _18 = &_5;                       // scope 1 at $DIR/slice_filter.rs:+0:60: +0:61\n--         StorageLive(_19);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n--         StorageLive(_20);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n--         _20 = _3;                        // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n--         _19 = &_20;                      // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n--         _35 = deref_copy (*_18);         // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _36 = deref_copy (*_19);         // scope 4 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_39);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _39 = (*_35);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _39 = ((*_27).2: usize);         // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_40);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _40 = (*_36);                    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _40 = ((*_25).0: usize);         // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _17 = Le(move _39, move _40);    // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_40);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_39);                // scope 5 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_20);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n--         StorageDead(_19);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n--         StorageDead(_18);                // scope 1 at $DIR/slice_filter.rs:+0:65: +0:66\n-          switchInt(move _17) -> [0: bb6, otherwise: bb7]; // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-      }\n-  \n-      bb3: {\n-          StorageDead(_16);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n--         StorageDead(_6);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n--         StorageDead(_5);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n--         StorageDead(_4);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n--         StorageDead(_3);                 // scope 0 at $DIR/slice_filter.rs:+0:75: +0:76\n-          return;                          // scope 0 at $DIR/slice_filter.rs:+0:76: +0:76\n-      }\n-  \n-      bb4: {\n-          _7 = const false;                // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-          StorageDead(_12);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          goto -> bb2;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-      }\n-  \n-      bb5: {\n-          StorageLive(_12);                // scope 1 at $DIR/slice_filter.rs:+0:50: +0:56\n--         StorageLive(_13);                // scope 1 at $DIR/slice_filter.rs:+0:50: +0:51\n--         _13 = &_6;                       // scope 1 at $DIR/slice_filter.rs:+0:50: +0:51\n--         StorageLive(_14);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n--         StorageLive(_15);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n--         _15 = _4;                        // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n--         _14 = &_15;                      // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n--         _41 = deref_copy (*_13);         // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _42 = deref_copy (*_14);         // scope 6 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_45);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _45 = (*_41);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _45 = ((*_28).3: usize);         // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_46);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _46 = (*_42);                    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _46 = ((*_26).1: usize);         // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _12 = Le(move _45, move _46);    // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_46);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_45);                // scope 7 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_15);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n--         StorageDead(_14);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n--         StorageDead(_13);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          _7 = move _12;                   // scope 1 at $DIR/slice_filter.rs:+0:40: +0:56\n-          StorageDead(_12);                // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:55: +0:56\n-          switchInt(move _7) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-      }\n-  \n-      bb6: {\n-          _16 = const false;               // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-      }\n-  \n-      bb7: {\n-          StorageLive(_21);                // scope 1 at $DIR/slice_filter.rs:+0:70: +0:76\n--         StorageLive(_22);                // scope 1 at $DIR/slice_filter.rs:+0:70: +0:71\n--         _22 = &_4;                       // scope 1 at $DIR/slice_filter.rs:+0:70: +0:71\n--         StorageLive(_23);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n--         StorageLive(_24);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n--         _24 = _6;                        // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n--         _23 = &_24;                      // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n--         _47 = deref_copy (*_22);         // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _48 = deref_copy (*_23);         // scope 8 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_51);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _51 = (*_47);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _51 = ((*_26).1: usize);         // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageLive(_52);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         _52 = (*_48);                    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-+         _52 = ((*_28).3: usize);         // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          _21 = Le(move _51, move _52);    // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_52);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n-          StorageDead(_51);                // scope 9 at $SRC_DIR/core/src/cmp.rs:LL:COL\n--         StorageDead(_24);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n--         StorageDead(_23);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n--         StorageDead(_22);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          _16 = move _21;                  // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:60: +0:76\n-      }\n-  \n-      bb8: {\n-          StorageDead(_21);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          StorageDead(_17);                // scope 1 at $DIR/slice_filter.rs:+0:75: +0:76\n-          _0 = move _16;                   // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:40: +0:76\n-      }\n-  }\n-  "}, {"sha": "5e4bdbdfa2e2f9683e0b5206db7181c30c81db94", "filename": "tests/mir-opt/slice_filter.variant_b-{closure#0}.CopyProp.diff", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_b-%7Bclosure%230%7D.CopyProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_b-%7Bclosure%230%7D.CopyProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fslice_filter.variant_b-%7Bclosure%230%7D.CopyProp.diff?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,139 +0,0 @@\n-- // MIR for `variant_b::{closure#0}` before CopyProp\n-+ // MIR for `variant_b::{closure#0}` after CopyProp\n-  \n-  fn variant_b::{closure#0}(_1: &mut [closure@$DIR/slice_filter.rs:12:25: 12:41], _2: &&(usize, usize, usize, usize)) -> bool {\n-      let mut _0: bool;                    // return place in scope 0 at $DIR/slice_filter.rs:+0:42: +0:42\n-      let _3: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n-      let _4: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n-      let _5: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n-      let _6: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n-      let mut _7: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:42: +0:58\n-      let mut _8: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:42: +0:48\n-      let mut _9: usize;                   // in scope 0 at $DIR/slice_filter.rs:+0:42: +0:43\n-      let mut _10: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:47: +0:48\n-      let mut _11: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:52: +0:58\n-      let mut _12: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:52: +0:53\n-      let mut _13: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:57: +0:58\n-      let mut _14: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:62: +0:78\n-      let mut _15: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:62: +0:68\n-      let mut _16: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:62: +0:63\n-      let mut _17: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:67: +0:68\n-      let mut _18: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:72: +0:78\n-      let mut _19: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:72: +0:73\n-      let mut _20: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:77: +0:78\n-      let mut _21: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      let mut _22: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      let mut _23: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      let mut _24: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      scope 1 {\n-          debug a => _3;                   // in scope 1 at $DIR/slice_filter.rs:+0:29: +0:30\n-          debug b => _4;                   // in scope 1 at $DIR/slice_filter.rs:+0:32: +0:33\n-          debug c => _5;                   // in scope 1 at $DIR/slice_filter.rs:+0:35: +0:36\n-          debug d => _6;                   // in scope 1 at $DIR/slice_filter.rs:+0:38: +0:39\n-      }\n-  \n-      bb0: {\n--         StorageLive(_3);                 // scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n-          _21 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n-          _3 = ((*_21).0: usize);          // scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n--         StorageLive(_4);                 // scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n-          _22 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n-          _4 = ((*_22).1: usize);          // scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n--         StorageLive(_5);                 // scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n-          _23 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n-          _5 = ((*_23).2: usize);          // scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n--         StorageLive(_6);                 // scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n-          _24 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n-          _6 = ((*_24).3: usize);          // scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n-          StorageLive(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-          StorageLive(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:48\n--         StorageLive(_9);                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:43\n--         _9 = _3;                         // scope 1 at $DIR/slice_filter.rs:+0:42: +0:43\n--         StorageLive(_10);                // scope 1 at $DIR/slice_filter.rs:+0:47: +0:48\n--         _10 = _5;                        // scope 1 at $DIR/slice_filter.rs:+0:47: +0:48\n--         _8 = Le(move _9, move _10);      // scope 1 at $DIR/slice_filter.rs:+0:42: +0:48\n--         StorageDead(_10);                // scope 1 at $DIR/slice_filter.rs:+0:47: +0:48\n--         StorageDead(_9);                 // scope 1 at $DIR/slice_filter.rs:+0:47: +0:48\n-+         _8 = Le(_3, _5);                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:48\n-          switchInt(move _8) -> [0: bb4, otherwise: bb5]; // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-      }\n-  \n-      bb1: {\n-          _0 = const true;                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-      }\n-  \n-      bb2: {\n-          StorageLive(_14);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-          StorageLive(_15);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:68\n--         StorageLive(_16);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:63\n--         _16 = _5;                        // scope 1 at $DIR/slice_filter.rs:+0:62: +0:63\n--         StorageLive(_17);                // scope 1 at $DIR/slice_filter.rs:+0:67: +0:68\n--         _17 = _3;                        // scope 1 at $DIR/slice_filter.rs:+0:67: +0:68\n--         _15 = Le(move _16, move _17);    // scope 1 at $DIR/slice_filter.rs:+0:62: +0:68\n--         StorageDead(_17);                // scope 1 at $DIR/slice_filter.rs:+0:67: +0:68\n--         StorageDead(_16);                // scope 1 at $DIR/slice_filter.rs:+0:67: +0:68\n-+         _15 = Le(_5, _3);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:68\n-          switchInt(move _15) -> [0: bb6, otherwise: bb7]; // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-      }\n-  \n-      bb3: {\n-          StorageDead(_14);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-          StorageDead(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n--         StorageDead(_6);                 // scope 0 at $DIR/slice_filter.rs:+0:77: +0:78\n--         StorageDead(_5);                 // scope 0 at $DIR/slice_filter.rs:+0:77: +0:78\n--         StorageDead(_4);                 // scope 0 at $DIR/slice_filter.rs:+0:77: +0:78\n--         StorageDead(_3);                 // scope 0 at $DIR/slice_filter.rs:+0:77: +0:78\n-          return;                          // scope 0 at $DIR/slice_filter.rs:+0:78: +0:78\n-      }\n-  \n-      bb4: {\n-          _7 = const false;                // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-          StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          goto -> bb2;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-      }\n-  \n-      bb5: {\n-          StorageLive(_11);                // scope 1 at $DIR/slice_filter.rs:+0:52: +0:58\n--         StorageLive(_12);                // scope 1 at $DIR/slice_filter.rs:+0:52: +0:53\n--         _12 = _6;                        // scope 1 at $DIR/slice_filter.rs:+0:52: +0:53\n--         StorageLive(_13);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n--         _13 = _4;                        // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n--         _11 = Le(move _12, move _13);    // scope 1 at $DIR/slice_filter.rs:+0:52: +0:58\n--         StorageDead(_13);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n--         StorageDead(_12);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-+         _11 = Le(_6, _4);                // scope 1 at $DIR/slice_filter.rs:+0:52: +0:58\n-          _7 = move _11;                   // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-          StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          switchInt(move _7) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-      }\n-  \n-      bb6: {\n-          _14 = const false;               // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-      }\n-  \n-      bb7: {\n-          StorageLive(_18);                // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n--         StorageLive(_19);                // scope 1 at $DIR/slice_filter.rs:+0:72: +0:73\n--         _19 = _4;                        // scope 1 at $DIR/slice_filter.rs:+0:72: +0:73\n--         StorageLive(_20);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n--         _20 = _6;                        // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n--         _18 = Le(move _19, move _20);    // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n--         StorageDead(_20);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n--         StorageDead(_19);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-+         _18 = Le(_4, _6);                // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n-          _14 = move _18;                  // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-      }\n-  \n-      bb8: {\n-          StorageDead(_18);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-          StorageDead(_15);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-          _0 = move _14;                   // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-      }\n-  }\n-  "}, {"sha": "45af6600cd4e8ed268756a700123dbe015795fea", "filename": "tests/mir-opt/slice_filter.variant_b-{closure#0}.DestinationPropagation.diff", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_b-%7Bclosure%230%7D.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_b-%7Bclosure%230%7D.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fslice_filter.variant_b-%7Bclosure%230%7D.DestinationPropagation.diff?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,109 +0,0 @@\n-- // MIR for `variant_b::{closure#0}` before DestinationPropagation\n-+ // MIR for `variant_b::{closure#0}` after DestinationPropagation\n-  \n-  fn variant_b::{closure#0}(_1: &mut [closure@$DIR/slice_filter.rs:12:25: 12:41], _2: &&(usize, usize, usize, usize)) -> bool {\n-      let mut _0: bool;                    // return place in scope 0 at $DIR/slice_filter.rs:+0:42: +0:42\n-      let _3: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n-      let _4: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n-      let _5: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n-      let _6: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n-      let mut _7: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:42: +0:58\n-      let mut _8: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:42: +0:48\n-      let mut _9: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:52: +0:58\n-      let mut _10: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:62: +0:78\n-      let mut _11: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:62: +0:68\n-      let mut _12: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:72: +0:78\n-      let mut _13: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      let mut _14: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      let mut _15: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      let mut _16: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      scope 1 {\n-          debug a => _3;                   // in scope 1 at $DIR/slice_filter.rs:+0:29: +0:30\n-          debug b => _4;                   // in scope 1 at $DIR/slice_filter.rs:+0:32: +0:33\n-          debug c => _5;                   // in scope 1 at $DIR/slice_filter.rs:+0:35: +0:36\n-          debug d => _6;                   // in scope 1 at $DIR/slice_filter.rs:+0:38: +0:39\n-      }\n-  \n-      bb0: {\n-          _13 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n-          _3 = ((*_13).0: usize);          // scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n-          _14 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n-          _4 = ((*_14).1: usize);          // scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n-          _15 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n-          _5 = ((*_15).2: usize);          // scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n-          _16 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n-          _6 = ((*_16).3: usize);          // scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n--         StorageLive(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-          StorageLive(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:48\n-          _8 = Le(_3, _5);                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:48\n-          switchInt(move _8) -> [0: bb4, otherwise: bb5]; // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-      }\n-  \n-      bb1: {\n-          _0 = const true;                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-      }\n-  \n-      bb2: {\n--         StorageLive(_10);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-          StorageLive(_11);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:68\n-          _11 = Le(_5, _3);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:68\n-          switchInt(move _11) -> [0: bb6, otherwise: bb7]; // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-      }\n-  \n-      bb3: {\n--         StorageDead(_10);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n--         StorageDead(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-          return;                          // scope 0 at $DIR/slice_filter.rs:+0:78: +0:78\n-      }\n-  \n-      bb4: {\n--         StorageDead(_9);                 // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          goto -> bb2;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-      }\n-  \n-      bb5: {\n--         StorageLive(_9);                 // scope 1 at $DIR/slice_filter.rs:+0:52: +0:58\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:52: +0:58\n-          _9 = Le(_6, _4);                 // scope 1 at $DIR/slice_filter.rs:+0:52: +0:58\n--         _7 = move _9;                    // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n--         StorageDead(_9);                 // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n--         switchInt(move _7) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-+         switchInt(move _9) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-      }\n-  \n-      bb6: {\n--         _10 = const false;               // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-+         _0 = const false;                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-      }\n-  \n-      bb7: {\n--         StorageLive(_12);                // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n--         _12 = Le(_4, _6);                // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n--         _10 = move _12;                  // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n-+         _0 = Le(_4, _6);                 // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-      }\n-  \n-      bb8: {\n--         StorageDead(_12);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-          StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n--         _0 = move _10;                   // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-+         nop;                             // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-      }\n-  }\n-  "}, {"sha": "d1241c6b0245c6869de2a60361509569cc0406d3", "filename": "tests/mir-opt/slice_filter.variant_b-{closure#0}.ReferencePropagation.diff", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_b-%7Bclosure%230%7D.ReferencePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fmir-opt%2Fslice_filter.variant_b-%7Bclosure%230%7D.ReferencePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fslice_filter.variant_b-%7Bclosure%230%7D.ReferencePropagation.diff?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,103 +0,0 @@\n-- // MIR for `variant_b::{closure#0}` before ReferencePropagation\n-+ // MIR for `variant_b::{closure#0}` after ReferencePropagation\n-  \n-  fn variant_b::{closure#0}(_1: &mut [closure@$DIR/slice_filter.rs:12:25: 12:41], _2: &&(usize, usize, usize, usize)) -> bool {\n-      let mut _0: bool;                    // return place in scope 0 at $DIR/slice_filter.rs:+0:42: +0:42\n-      let _3: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n-      let _4: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n-      let _5: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n-      let _6: usize;                       // in scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n-      let mut _7: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:42: +0:58\n-      let mut _8: bool;                    // in scope 0 at $DIR/slice_filter.rs:+0:42: +0:48\n-      let mut _9: usize;                   // in scope 0 at $DIR/slice_filter.rs:+0:42: +0:43\n-      let mut _10: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:47: +0:48\n-      let mut _11: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:52: +0:58\n-      let mut _12: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:52: +0:53\n-      let mut _13: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:57: +0:58\n-      let mut _14: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:62: +0:78\n-      let mut _15: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:62: +0:68\n-      let mut _16: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:62: +0:63\n-      let mut _17: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:67: +0:68\n-      let mut _18: bool;                   // in scope 0 at $DIR/slice_filter.rs:+0:72: +0:78\n-      let mut _19: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:72: +0:73\n-      let mut _20: usize;                  // in scope 0 at $DIR/slice_filter.rs:+0:77: +0:78\n-      let mut _21: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      let mut _22: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      let mut _23: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      let mut _24: &(usize, usize, usize, usize); // in scope 0 at $DIR/slice_filter.rs:+0:26: +0:40\n-      scope 1 {\n-          debug a => _3;                   // in scope 1 at $DIR/slice_filter.rs:+0:29: +0:30\n-          debug b => _4;                   // in scope 1 at $DIR/slice_filter.rs:+0:32: +0:33\n-          debug c => _5;                   // in scope 1 at $DIR/slice_filter.rs:+0:35: +0:36\n-          debug d => _6;                   // in scope 1 at $DIR/slice_filter.rs:+0:38: +0:39\n-      }\n-  \n-      bb0: {\n-          _21 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n-          _3 = ((*_21).0: usize);          // scope 0 at $DIR/slice_filter.rs:+0:29: +0:30\n-          _22 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n-          _4 = ((*_22).1: usize);          // scope 0 at $DIR/slice_filter.rs:+0:32: +0:33\n-          _23 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n-          _5 = ((*_23).2: usize);          // scope 0 at $DIR/slice_filter.rs:+0:35: +0:36\n-          _24 = deref_copy (*_2);          // scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n-          _6 = ((*_24).3: usize);          // scope 0 at $DIR/slice_filter.rs:+0:38: +0:39\n-          StorageLive(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-          StorageLive(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:48\n-          _8 = Le(_3, _5);                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:48\n-          switchInt(move _8) -> [0: bb4, otherwise: bb5]; // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-      }\n-  \n-      bb1: {\n-          _0 = const true;                 // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-      }\n-  \n-      bb2: {\n-          StorageLive(_14);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-          StorageLive(_15);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:68\n-          _15 = Le(_5, _3);                // scope 1 at $DIR/slice_filter.rs:+0:62: +0:68\n-          switchInt(move _15) -> [0: bb6, otherwise: bb7]; // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-      }\n-  \n-      bb3: {\n-          StorageDead(_14);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-          StorageDead(_7);                 // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-          return;                          // scope 0 at $DIR/slice_filter.rs:+0:78: +0:78\n-      }\n-  \n-      bb4: {\n-          _7 = const false;                // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-          StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          goto -> bb2;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-      }\n-  \n-      bb5: {\n-          StorageLive(_11);                // scope 1 at $DIR/slice_filter.rs:+0:52: +0:58\n-          _11 = Le(_6, _4);                // scope 1 at $DIR/slice_filter.rs:+0:52: +0:58\n-          _7 = move _11;                   // scope 1 at $DIR/slice_filter.rs:+0:42: +0:58\n-          StorageDead(_11);                // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          StorageDead(_8);                 // scope 1 at $DIR/slice_filter.rs:+0:57: +0:58\n-          switchInt(move _7) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-      }\n-  \n-      bb6: {\n-          _14 = const false;               // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-      }\n-  \n-      bb7: {\n-          StorageLive(_18);                // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n-          _18 = Le(_4, _6);                // scope 1 at $DIR/slice_filter.rs:+0:72: +0:78\n-          _14 = move _18;                  // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-          goto -> bb8;                     // scope 1 at $DIR/slice_filter.rs:+0:62: +0:78\n-      }\n-  \n-      bb8: {\n-          StorageDead(_18);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-          StorageDead(_15);                // scope 1 at $DIR/slice_filter.rs:+0:77: +0:78\n-          _0 = move _14;                   // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-          goto -> bb3;                     // scope 1 at $DIR/slice_filter.rs:+0:42: +0:78\n-      }\n-  }\n-  "}, {"sha": "7be5e39ba4727f87ee42622bcb84482078794cea", "filename": "tests/rustdoc-gui/codeblock-tooltip.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Frustdoc-gui%2Fcodeblock-tooltip.goml", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Frustdoc-gui%2Fcodeblock-tooltip.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fcodeblock-tooltip.goml?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -40,6 +40,7 @@ define-function: (\n             \"background-color\": |background|,\n             \"border-color\": |border|,\n         })\n+        click: \".docblock .example-wrap.compile_fail .tooltip\"\n \n         // should_panic block\n         assert-css: (\n@@ -71,6 +72,7 @@ define-function: (\n             \"background-color\": |background|,\n             \"border-color\": |border|,\n         })\n+        click: \".docblock .example-wrap.should_panic .tooltip\"\n \n         // ignore block\n         assert-css: ("}, {"sha": "371931d51fccc76ef7207072ee8af87ca70c7c4c", "filename": "tests/rustdoc-gui/notable-trait.goml", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Frustdoc-gui%2Fnotable-trait.goml", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Frustdoc-gui%2Fnotable-trait.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fnotable-trait.goml?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -122,7 +122,7 @@ assert-count: (\"//*[@class='tooltip popover']\", 0)\n // Now check the colors.\n define-function: (\n     \"check-colors\",\n-    (theme, header_color, content_color, type_color, trait_color),\n+    (theme, header_color, content_color, type_color, trait_color, link_color),\n     block {\n         go-to: \"file://\" + |DOC_PATH| + \"/test_docs/struct.NotableStructWithLongName.html\"\n         // This is needed to ensure that the text color is computed.\n@@ -133,8 +133,20 @@ define-function: (\n         // We reload the page so the local storage settings are being used.\n         reload:\n \n+        assert-css: (\n+             \"//*[@id='method.create_an_iterator_from_read']//*[@class='tooltip']\",\n+             {\"color\": |content_color|},\n+             ALL,\n+        )\n+\n         move-cursor-to: \"//*[@id='method.create_an_iterator_from_read']//*[@class='tooltip']\"\n-        assert-count: (\".tooltip.popover\", 1)\n+        wait-for-count: (\".tooltip.popover\", 1)\n+\n+        assert-css: (\n+             \"//*[@id='method.create_an_iterator_from_read']//*[@class='tooltip']\",\n+             {\"color\": |link_color|},\n+             ALL,\n+        )\n \n         assert-css: (\n              \".tooltip.popover h3\",\n@@ -163,6 +175,7 @@ call-function: (\n     \"check-colors\",\n     {\n         \"theme\": \"ayu\",\n+        \"link_color\": \"rgb(57, 175, 215)\",\n         \"content_color\": \"rgb(230, 225, 207)\",\n         \"header_color\": \"rgb(255, 255, 255)\",\n         \"type_color\": \"rgb(255, 160, 165)\",\n@@ -174,6 +187,7 @@ call-function: (\n     \"check-colors\",\n     {\n         \"theme\": \"dark\",\n+        \"link_color\": \"rgb(210, 153, 29)\",\n         \"content_color\": \"rgb(221, 221, 221)\",\n         \"header_color\": \"rgb(221, 221, 221)\",\n         \"type_color\": \"rgb(45, 191, 184)\",\n@@ -185,6 +199,7 @@ call-function: (\n     \"check-colors\",\n     {\n         \"theme\": \"light\",\n+        \"link_color\": \"rgb(56, 115, 173)\",\n         \"content_color\": \"rgb(0, 0, 0)\",\n         \"header_color\": \"rgb(0, 0, 0)\",\n         \"type_color\": \"rgb(173, 55, 138)\","}, {"sha": "42c5b5e6e69e3e08169c6904cb8461ba893fcf04", "filename": "tests/rustdoc-gui/theme-in-history.goml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Frustdoc-gui%2Ftheme-in-history.goml", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Frustdoc-gui%2Ftheme-in-history.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Ftheme-in-history.goml?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -7,21 +7,21 @@ set-local-storage: {\n }\n // We reload the page so the local storage settings are being used.\n reload:\n-assert-css: (\"body\", { \"background-color\": \"rgb(53, 53, 53)\" })\n+assert-css: (\"body\", { \"background-color\": \"#353535\" })\n assert-local-storage: { \"rustdoc-theme\": \"dark\" }\n \n // Now we go to the settings page.\n go-to: \"file://\" + |DOC_PATH| + \"/settings.html\"\n wait-for: \"#settings\"\n // We change the theme to \"light\".\n click: \"#theme-light\"\n-wait-for-css: (\"body\", { \"background-color\": \"rgb(255, 255, 255)\" })\n+wait-for-css: (\"body\", { \"background-color\": \"white\" })\n assert-local-storage: { \"rustdoc-theme\": \"light\" }\n \n // We go back in history.\n history-go-back:\n // Confirm that we're not on the settings page.\n assert-false: \"#settings\"\n // Check that the current theme is still \"light\".\n-assert-css: (\"body\", { \"background-color\": \"rgb(255, 255, 255)\" })\n+assert-css: (\"body\", { \"background-color\": \"white\" })\n assert-local-storage: { \"rustdoc-theme\": \"light\" }"}, {"sha": "eb1c7a05e54097098212a322763d475a010d5267", "filename": "tests/rustdoc/intra-doc/issue-108459.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Frustdoc%2Fintra-doc%2Fissue-108459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Frustdoc%2Fintra-doc%2Fissue-108459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fintra-doc%2Fissue-108459.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,37 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+pub struct S;\n+pub mod char {}\n+\n+// Ensure this doesn't ICE due to trying to slice off non-existent backticks from \"S\"\n+\n+/// See [S] and [`S`]\n+pub struct MyStruct1;\n+\n+// Ensure that link texts are replaced correctly even if there are multiple links with\n+// the same target but different text\n+\n+/// See also [crate::char] and [mod@char] and [prim@char]\n+// @has issue_108459/struct.MyStruct2.html '//*[@href=\"char/index.html\"]' 'crate::char'\n+// @has - '//*[@href=\"char/index.html\"]' 'char'\n+// @has - '//*[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n+pub struct MyStruct2;\n+\n+/// See also [mod@char] and [prim@char] and [crate::char]\n+// @has issue_108459/struct.MyStruct3.html '//*[@href=\"char/index.html\"]' 'crate::char'\n+// @has - '//*[@href=\"char/index.html\"]' 'char'\n+// @has - '//*[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n+pub struct MyStruct3;\n+\n+// Ensure that links are correct even if there are multiple links with the same text but\n+// different targets\n+\n+/// See also [char][mod@char] and [char][prim@char]\n+// @has issue_108459/struct.MyStruct4.html '//*[@href=\"char/index.html\"]' 'char'\n+// @has - '//*[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n+pub struct MyStruct4;\n+\n+/// See also [char][prim@char] and [char][crate::char]\n+// @has issue_108459/struct.MyStruct5.html '//*[@href=\"char/index.html\"]' 'char'\n+// @has - '//*[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n+pub struct MyStruct5;"}, {"sha": "c5a64e42a01248001d5b11eba64c6745307398eb", "filename": "tests/rustdoc/intra-doc/prim-precedence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -12,5 +12,5 @@ pub struct MyString;\n \n /// See also [crate::char] and [mod@char]\n // @has prim_precedence/struct.MyString2.html '//*[@href=\"char/index.html\"]' 'crate::char'\n-// @has - '//*[@href=\"char/index.html\"]' 'mod@char'\n+// @has - '//*[@href=\"char/index.html\"]' 'char'\n pub struct MyString2;"}, {"sha": "ffbefce48d3e50cbac94af6da0031c1725f9c6dc", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -538,15 +538,15 @@ struct LabelWithTrailingPath {\n #[diag(no_crate_example, code = \"E0123\")]\n struct LabelWithTrailingNameValue {\n     #[label(no_crate_label, foo = \"...\")]\n-    //~^ ERROR invalid nested attribute\n+    //~^ ERROR only `no_span` is a valid nested attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n #[diag(no_crate_example, code = \"E0123\")]\n struct LabelWithTrailingList {\n     #[label(no_crate_label, foo(\"...\"))]\n-    //~^ ERROR invalid nested attribute\n+    //~^ ERROR only `no_span` is a valid nested attribute\n     span: Span,\n }\n "}, {"sha": "1398f9c96bf2005d33b1cb560ee52678a67ec34c", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -243,7 +243,7 @@ error: invalid nested attribute\n LL |     #[suggestion(nonsense = \"bar\")]\n    |                  ^^^^^^^^\n    |\n-   = help: only `style`, `code` and `applicability` are valid nested attributes\n+   = help: only `no_span`, `style`, `code` and `applicability` are valid nested attributes\n \n error: suggestion without `code = \"...\"`\n   --> $DIR/diagnostic-derive.rs:234:5\n@@ -257,7 +257,7 @@ error: invalid nested attribute\n LL |     #[suggestion(msg = \"bar\")]\n    |                  ^^^\n    |\n-   = help: only `style`, `code` and `applicability` are valid nested attributes\n+   = help: only `no_span`, `style`, `code` and `applicability` are valid nested attributes\n \n error: suggestion without `code = \"...\"`\n   --> $DIR/diagnostic-derive.rs:243:5\n@@ -335,13 +335,13 @@ error: a diagnostic slug must be the first argument to the attribute\n LL |     #[label(no_crate_label, foo)]\n    |                                ^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/diagnostic-derive.rs:540:29\n    |\n LL |     #[label(no_crate_label, foo = \"...\")]\n    |                             ^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/diagnostic-derive.rs:548:29\n    |\n LL |     #[label(no_crate_label, foo(\"...\"))]"}, {"sha": "38af5b0f9fb1690f2f1421c31188c9e8459ffafe", "filename": "tests/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -85,7 +85,7 @@ struct F {\n \n #[derive(Subdiagnostic)]\n #[label(bug = \"...\")]\n-//~^ ERROR invalid nested attribute\n+//~^ ERROR only `no_span` is a valid nested attribute\n //~| ERROR diagnostic slug must be first argument\n struct G {\n     #[primary_span]\n@@ -104,7 +104,7 @@ struct H {\n \n #[derive(Subdiagnostic)]\n #[label(slug = 4)]\n-//~^ ERROR invalid nested attribute\n+//~^ ERROR only `no_span` is a valid nested attribute\n //~| ERROR diagnostic slug must be first argument\n struct J {\n     #[primary_span]\n@@ -114,7 +114,7 @@ struct J {\n \n #[derive(Subdiagnostic)]\n #[label(slug(\"...\"))]\n-//~^ ERROR invalid nested attribute\n+//~^ ERROR only `no_span` is a valid nested attribute\n //~| ERROR diagnostic slug must be first argument\n struct K {\n     #[primary_span]\n@@ -143,7 +143,7 @@ struct M {\n \n #[derive(Subdiagnostic)]\n #[label(no_crate_example, code = \"...\")]\n-//~^ ERROR invalid nested attribute\n+//~^ ERROR only `no_span` is a valid nested attribute\n struct N {\n     #[primary_span]\n     span: Span,\n@@ -152,7 +152,7 @@ struct N {\n \n #[derive(Subdiagnostic)]\n #[label(no_crate_example, applicability = \"machine-applicable\")]\n-//~^ ERROR invalid nested attribute\n+//~^ ERROR only `no_span` is a valid nested attribute\n struct O {\n     #[primary_span]\n     span: Span,\n@@ -224,7 +224,7 @@ enum T {\n enum U {\n     #[label(code = \"...\")]\n     //~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n-    //~| ERROR invalid nested attribute\n+    //~| ERROR only `no_span` is a valid nested attribute\n     A {\n         #[primary_span]\n         span: Span,"}, {"sha": "5ddc8edd745dbbd42e90f0b6e8e9dab3b95781bd", "filename": "tests/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -26,7 +26,7 @@ error: `#[label = ...]` is not a valid attribute\n LL | #[label = \"...\"]\n    | ^^^^^^^^^^^^^^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:87:9\n    |\n LL | #[label(bug = \"...\")]\n@@ -44,7 +44,7 @@ error: unexpected literal in nested attribute, expected ident\n LL | #[label(\"...\")]\n    |         ^^^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:106:9\n    |\n LL | #[label(slug = 4)]\n@@ -56,7 +56,7 @@ error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n LL | #[label(slug = 4)]\n    | ^^^^^^^^^^^^^^^^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:116:9\n    |\n LL | #[label(slug(\"...\"))]\n@@ -74,13 +74,13 @@ error: unexpected end of input, unexpected token in nested attribute, expected i\n LL | #[label()]\n    |         ^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:145:27\n    |\n LL | #[label(no_crate_example, code = \"...\")]\n    |                           ^^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:154:27\n    |\n LL | #[label(no_crate_example, applicability = \"machine-applicable\")]\n@@ -116,7 +116,7 @@ error: `#[bar(...)]` is not a valid attribute\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n \n-error: invalid nested attribute\n+error: only `no_span` is a valid nested attribute\n   --> $DIR/subdiagnostic-derive.rs:225:13\n    |\n LL |     #[label(code = \"...\")]\n@@ -312,7 +312,7 @@ error: invalid nested attribute\n LL | #[multipart_suggestion(no_crate_example, code = \"...\", applicability = \"machine-applicable\")]\n    |                                          ^^^^\n    |\n-   = help: only `style` and `applicability` are valid nested attributes\n+   = help: only `no_span`, `style` and `applicability` are valid nested attributes\n \n error: multipart suggestion without any `#[suggestion_part(...)]` fields\n   --> $DIR/subdiagnostic-derive.rs:540:1"}, {"sha": "e6d46b02706b1c523c13f4fb2b73e898c397498d", "filename": "tests/ui/chalkify/bugs/async.stderr", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -13,16 +13,9 @@ error: internal compiler error: projection clauses should be implied from elsewh\n LL | async fn foo(x: u32) -> u32 {\n    |                         ^^^query stack during panic:\n #0 [typeck] type-checking `foo`\n-#1 [thir_body] building THIR for `foo`\n-#2 [check_match] match-checking `foo`\n-#3 [mir_built] building MIR for `foo`\n-#4 [unsafety_check_result] unsafety-checking `foo`\n-#5 [mir_const] preparing `foo` for borrow checking\n-#6 [mir_promoted] promoting constants in MIR for `foo`\n-#7 [mir_borrowck] borrow-checking `foo`\n-#8 [type_of] computing type of `foo::{opaque#0}`\n-#9 [check_mod_item_types] checking item types in top-level module\n-#10 [analysis] running analysis passes on this crate\n+#1 [type_of] computing type of `foo::{opaque#0}`\n+#2 [check_mod_item_types] checking item types in top-level module\n+#3 [analysis] running analysis passes on this crate\n end of query stack\n error: aborting due to 2 previous errors\n "}, {"sha": "dc3a400cbaa83098d0a7c2ccd8a40c95dcc20175", "filename": "tests/ui/const-generics/generic_const_exprs/issue-80742.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,4 +1,4 @@\n-error[E0080]: evaluation of `Inline::<dyn std::fmt::Debug>::{constant#0}` failed\n+error[E0080]: evaluation of `Inline::<dyn Debug>::{constant#0}` failed\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n    = note: size_of called on unsized type `dyn Debug`\n@@ -35,7 +35,7 @@ help: consider relaxing the type parameter's implicit `Sized` bound\n LL | impl<T: ?Sized> Inline<T>\n    |       ++++++++\n \n-error[E0080]: evaluation of `Inline::<dyn std::fmt::Debug>::{constant#0}` failed\n+error[E0080]: evaluation of `Inline::<dyn Debug>::{constant#0}` failed\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n    = note: size_of called on unsized type `dyn Debug`"}, {"sha": "9a9d4721c84945256a0cd521024fd789578bbcc5", "filename": "tests/ui/const-generics/issues/issue-100313.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-100313.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-100313.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-100313.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -9,6 +9,7 @@ impl <const B: &'static bool> T<B> {\n         unsafe {\n             *(B as *const bool as *mut bool) = false;\n             //~^ ERROR evaluation of constant value failed [E0080]\n+            //~| ERROR casting `&T` to `&mut T` is undefined behavior\n         }\n     }\n }"}, {"sha": "ffc34a3a41e246a61dd435fb8577a73c0b47ec24", "filename": "tests/ui/const-generics/issues/issue-100313.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-100313.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-100313.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fissues%2Fissue-100313.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,3 +1,11 @@\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/issue-100313.rs:10:13\n+   |\n+LL |             *(B as *const bool as *mut bool) = false;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[deny(cast_ref_to_mut)]` on by default\n+\n error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-100313.rs:10:13\n    |\n@@ -10,11 +18,11 @@ note: inside `T::<&true>::set_false`\n LL |             *(B as *const bool as *mut bool) = false;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `_`\n-  --> $DIR/issue-100313.rs:18:5\n+  --> $DIR/issue-100313.rs:19:5\n    |\n LL |     x.set_false();\n    |     ^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "22c3dfa64febcbf5f45f9e754209600464accdc5", "filename": "tests/ui/const-ptr/forbidden_slices.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-ptr%2Fforbidden_slices.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -54,11 +54,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) };\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n                HEX_DUMP\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:30:1\n@@ -98,7 +98,7 @@ LL |     from_raw_parts(ptr, 1)\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds `offset_from`: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -156,11 +156,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static R5: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n                HEX_DUMP\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:63:1"}, {"sha": "23ba2c2f535165a36b9472454d7981e8c34462a8", "filename": "tests/ui/consts/const-eval/heap/alloc_intrinsic_errors.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_errors.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -2,7 +2,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/alloc_intrinsic_errors.rs:9:17\n    |\n LL |         let _ = intrinsics::const_allocate(4, 3) as *mut i32;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ align has to be a power of 2, `3` is not a power of 2\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid align passed to `const_allocate`: 3 is not a power of 2\n    |\n note: inside `foo`\n   --> $DIR/alloc_intrinsic_errors.rs:9:17"}, {"sha": "9ae906bbb73971d1a96ee48411cd931a8ffbdca7", "filename": "tests/ui/consts/const-eval/heap/alloc_intrinsic_nontransient_fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,11 +4,11 @@\n use std::intrinsics;\n \n const FOO: *const i32 = foo();\n-//~^ ERROR untyped pointers are not allowed in constant\n+//~^ ERROR unsupported untyped pointer in constant\n \n const fn foo() -> &'static i32 {\n     let t = unsafe {\n-        let i = intrinsics::const_allocate(4, 4) as * mut i32;\n+        let i = intrinsics::const_allocate(4, 4) as *mut i32;\n         *i = 20;\n         i\n     };"}, {"sha": "2103f842bd58eb1467d35fb260059e01f4d15ccf", "filename": "tests/ui/consts/const-eval/heap/alloc_intrinsic_nontransient_fail.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_nontransient_fail.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,8 +1,10 @@\n-error: untyped pointers are not allowed in constant\n+error: unsupported untyped pointer in constant\n   --> $DIR/alloc_intrinsic_nontransient_fail.rs:6:1\n    |\n LL | const FOO: *const i32 = foo();\n    | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: memory only reachable via raw pointers is not supported\n \n error: aborting due to previous error\n "}, {"sha": "1354b3c33b31d8565d7df3df0ebff38ec68c879b", "filename": "tests/ui/consts/const-eval/heap/alloc_intrinsic_untyped.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,7 +3,7 @@\n #![feature(const_mut_refs)]\n use std::intrinsics;\n \n-const BAR: *mut i32 = unsafe { intrinsics::const_allocate(4, 4) as *mut i32};\n-//~^ error: untyped pointers are not allowed in constant\n+const BAR: *mut i32 = unsafe { intrinsics::const_allocate(4, 4) as *mut i32 };\n+//~^ error: unsupported untyped pointer in constant\n \n fn main() {}"}, {"sha": "b6276647350be08b7ecad2f4c082f40e77346afd", "filename": "tests/ui/consts/const-eval/heap/alloc_intrinsic_untyped.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_untyped.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,8 +1,10 @@\n-error: untyped pointers are not allowed in constant\n+error: unsupported untyped pointer in constant\n   --> $DIR/alloc_intrinsic_untyped.rs:6:1\n    |\n-LL | const BAR: *mut i32 = unsafe { intrinsics::const_allocate(4, 4) as *mut i32};\n+LL | const BAR: *mut i32 = unsafe { intrinsics::const_allocate(4, 4) as *mut i32 };\n    | ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: memory only reachable via raw pointers is not supported\n \n error: aborting due to previous error\n "}, {"sha": "4c23957a1f80bc1d84559dbce74bb22285bf26c2", "filename": "tests/ui/consts/const-eval/heap/dealloc_intrinsic_incorrect_layout.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Fdealloc_intrinsic_incorrect_layout.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Fdealloc_intrinsic_incorrect_layout.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Fdealloc_intrinsic_incorrect_layout.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -20,7 +20,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/dealloc_intrinsic_incorrect_layout.rs:25:5\n    |\n LL |     intrinsics::const_deallocate(ptr, 4, 3);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ align has to be a power of 2, `3` is not a power of 2\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid align passed to `const_deallocate`: 3 is not a power of 2\n \n error: aborting due to 4 previous errors\n "}, {"sha": "217814906379152092641c435484c2af945aeadf", "filename": "tests/ui/consts/const-eval/infinite_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,8 +4,8 @@ fn main() {\n     let _ = [(); {\n         let mut n = 113383; // #20 in https://oeis.org/A006884\n         while n != 0 {\n-            //~^ ERROR evaluation of constant value failed\n-            n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n+            //~^ ERROR is taking a long time\n+            n = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };\n         }\n         n\n     }];"}, {"sha": "f0434a847cea5b2acfe49a97b08745b248878100", "filename": "tests/ui/consts/const-eval/infinite_loop.stderr", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,12 +1,27 @@\n-error[E0080]: evaluation of constant value failed\n+error: constant evaluation is taking a long time\n   --> $DIR/infinite_loop.rs:6:9\n    |\n LL | /         while n != 0 {\n LL | |\n-LL | |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n+LL | |             n = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };\n LL | |         }\n-   | |_________^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n+   | |_________^\n+   |\n+   = note: this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.\n+           If your compilation actually takes a long time, you can safely allow the lint.\n+help: the constant being evaluated\n+  --> $DIR/infinite_loop.rs:4:18\n+   |\n+LL |       let _ = [(); {\n+   |  __________________^\n+LL | |         let mut n = 113383; // #20 in https://oeis.org/A006884\n+LL | |         while n != 0 {\n+LL | |\n+...  |\n+LL | |         n\n+LL | |     }];\n+   | |_____^\n+   = note: `#[deny(long_running_const_eval)]` on by default\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "ee26d280018b431de90ebc3c52cf15de7c670cb8", "filename": "tests/ui/consts/const-eval/issue-52475.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -2,7 +2,8 @@ fn main() {\n     let _ = [(); {\n         let mut x = &0;\n         let mut n = 0;\n-        while n < 5 { //~ ERROR evaluation of constant value failed [E0080]\n+        while n < 5 {\n+            //~^ ERROR: constant evaluation is taking a long time\n             n = (n + 1) % 5;\n             x = &0; // Materialize a new AllocId\n         }"}, {"sha": "ebf9d12a66ad81f3e1e8d5cbe69c37a4dc8d8086", "filename": "tests/ui/consts/const-eval/issue-52475.stderr", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,12 +1,28 @@\n-error[E0080]: evaluation of constant value failed\n+error: constant evaluation is taking a long time\n   --> $DIR/issue-52475.rs:5:9\n    |\n LL | /         while n < 5 {\n+LL | |\n LL | |             n = (n + 1) % 5;\n LL | |             x = &0; // Materialize a new AllocId\n LL | |         }\n-   | |_________^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n+   | |_________^\n+   |\n+   = note: this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.\n+           If your compilation actually takes a long time, you can safely allow the lint.\n+help: the constant being evaluated\n+  --> $DIR/issue-52475.rs:2:18\n+   |\n+LL |       let _ = [(); {\n+   |  __________________^\n+LL | |         let mut x = &0;\n+LL | |         let mut n = 0;\n+LL | |         while n < 5 {\n+...  |\n+LL | |         0\n+LL | |     }];\n+   | |_____^\n+   = note: `#[deny(long_running_const_eval)]` on by default\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "c8c809a25ed78ba4dd1fd4ae1aca0dbf11cd2e4b", "filename": "tests/ui/consts/const-eval/issue-70723.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-70723.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-70723.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-70723.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,3 +1,3 @@\n-static _X: () = loop {}; //~ ERROR could not evaluate static initializer\n+static _X: () = loop {}; //~ ERROR taking a long time\n \n fn main() {}"}, {"sha": "572a430726fbd184c4fad4be001dcc577bab54ae", "filename": "tests/ui/consts/const-eval/issue-70723.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-70723.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-70723.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fissue-70723.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,9 +1,17 @@\n-error[E0080]: could not evaluate static initializer\n+error: constant evaluation is taking a long time\n   --> $DIR/issue-70723.rs:1:17\n    |\n LL | static _X: () = loop {};\n-   |                 ^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n+   |                 ^^^^^^^\n+   |\n+   = note: this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.\n+           If your compilation actually takes a long time, you can safely allow the lint.\n+help: the constant being evaluated\n+  --> $DIR/issue-70723.rs:1:1\n+   |\n+LL | static _X: () = loop {};\n+   | ^^^^^^^^^^^^^\n+   = note: `#[deny(long_running_const_eval)]` on by default\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "c0ddaceea4ce3f6f1d1b93546e882ccd9499e174", "filename": "tests/ui/consts/const-eval/raw-bytes.32bit.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -35,7 +35,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:44:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type `Never`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 1, align: 1) {\n@@ -290,11 +290,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | const MYSTR_NO_INIT_ISSUE83182: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eALLOC_ID\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:152:1\n@@ -529,11 +529,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, mem::size_of::<&u32>()) };\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:221:1\n@@ -574,11 +574,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static R5: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eALLOC_ID\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:242:1"}, {"sha": "20c905878e07c07c19e6e12697e7f10649ff8a98", "filename": "tests/ui/consts/const-eval/raw-bytes.64bit.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -35,7 +35,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:44:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type `Never`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 1, align: 1) {\n@@ -290,11 +290,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | const MYSTR_NO_INIT_ISSUE83182: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257eALLOC_ID\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:152:1\n@@ -529,11 +529,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, mem::size_of::<&u32>()) };\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:221:1\n@@ -574,11 +574,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | pub static R5: &[u8] = unsafe {\n    | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257eALLOC_ID\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:242:1"}, {"sha": "a30518170ad4236b7785e9a86039059fe19453e2", "filename": "tests/ui/consts/const-eval/stable-metric/ctfe-fn-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-fn-call.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -25,7 +25,7 @@ const fn call_foo() -> u32 {\n     foo();\n     foo();\n     foo();\n-    foo(); //~ ERROR evaluation of constant value failed [E0080]\n+    foo(); //~ ERROR is taking a long time\n     0\n }\n "}, {"sha": "a3fd712ca46080e5f8268c674f69df7ad7895e6c", "filename": "tests/ui/consts/const-eval/stable-metric/ctfe-fn-call.stderr", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-fn-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-fn-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-fn-call.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,20 +1,17 @@\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ctfe-fn-call.rs:28:5\n-   |\n-LL |     foo();\n-   |     ^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n-   |\n-note: inside `call_foo`\n+error: constant evaluation is taking a long time\n   --> $DIR/ctfe-fn-call.rs:28:5\n    |\n LL |     foo();\n    |     ^^^^^\n-note: inside `X`\n-  --> $DIR/ctfe-fn-call.rs:32:16\n+   |\n+   = note: this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.\n+           If your compilation actually takes a long time, you can safely allow the lint.\n+help: the constant being evaluated\n+  --> $DIR/ctfe-fn-call.rs:32:1\n    |\n LL | const X: u32 = call_foo();\n-   |                ^^^^^^^^^^\n+   | ^^^^^^^^^^^^\n+   = note: `#[deny(long_running_const_eval)]` on by default\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "f7cd04568be3c137f99600f720d5213df8ec32d7", "filename": "tests/ui/consts/const-eval/stable-metric/ctfe-labelled-loop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-labelled-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-labelled-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-labelled-loop.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,9 +3,10 @@\n \n const fn labelled_loop(n: u32) -> u32 {\n     let mut i = 0;\n-    'mylabel: loop { //~ ERROR evaluation of constant value failed [E0080]\n+    'mylabel: loop {\n+        //~^ ERROR is taking a long time\n         if i > n {\n-            break 'mylabel\n+            break 'mylabel;\n         }\n         i += 1;\n     }"}, {"sha": "5808ee35a6b4541dc7f11c317c8c168c3af8b5c0", "filename": "tests/ui/consts/const-eval/stable-metric/ctfe-labelled-loop.stderr", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-labelled-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-labelled-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-labelled-loop.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,30 +1,23 @@\n-error[E0080]: evaluation of constant value failed\n+error: constant evaluation is taking a long time\n   --> $DIR/ctfe-labelled-loop.rs:6:5\n    |\n LL | /     'mylabel: loop {\n+LL | |\n LL | |         if i > n {\n-LL | |             break 'mylabel\n-LL | |         }\n-LL | |         i += 1;\n-LL | |     }\n-   | |_____^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n-   |\n-note: inside `labelled_loop`\n-  --> $DIR/ctfe-labelled-loop.rs:6:5\n-   |\n-LL | /     'mylabel: loop {\n-LL | |         if i > n {\n-LL | |             break 'mylabel\n+LL | |             break 'mylabel;\n LL | |         }\n LL | |         i += 1;\n LL | |     }\n    | |_____^\n-note: inside `X`\n-  --> $DIR/ctfe-labelled-loop.rs:15:16\n+   |\n+   = note: this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.\n+           If your compilation actually takes a long time, you can safely allow the lint.\n+help: the constant being evaluated\n+  --> $DIR/ctfe-labelled-loop.rs:16:1\n    |\n LL | const X: u32 = labelled_loop(19);\n-   |                ^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^\n+   = note: `#[deny(long_running_const_eval)]` on by default\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "56a39fc45b0aee869b2862de5bf1e2bbbd3a0642", "filename": "tests/ui/consts/const-eval/stable-metric/ctfe-recursion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-recursion.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,11 +1,12 @@\n // check-fail\n // compile-flags: -Z tiny-const-eval-limit\n \n+#[rustfmt::skip]\n const fn recurse(n: u32) -> u32 {\n     if n == 0 {\n         n\n     } else {\n-        recurse(n - 1) //~ ERROR evaluation of constant value failed [E0080]\n+        recurse(n - 1) //~ ERROR is taking a long time\n     }\n }\n "}, {"sha": "524c8e55426660dfa238bd7c7a3d857c8fbb6173", "filename": "tests/ui/consts/const-eval/stable-metric/ctfe-recursion.stderr", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-recursion.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,25 +1,17 @@\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ctfe-recursion.rs:8:9\n-   |\n-LL |         recurse(n - 1)\n-   |         ^^^^^^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n-   |\n-note: inside `recurse`\n-  --> $DIR/ctfe-recursion.rs:8:9\n+error: constant evaluation is taking a long time\n+  --> $DIR/ctfe-recursion.rs:9:9\n    |\n LL |         recurse(n - 1)\n    |         ^^^^^^^^^^^^^^\n-note: [... 18 additional calls inside `recurse` ...]\n-  --> $DIR/ctfe-recursion.rs:8:9\n    |\n-LL |         recurse(n - 1)\n-   |         ^^^^^^^^^^^^^^\n-note: inside `X`\n-  --> $DIR/ctfe-recursion.rs:12:16\n+   = note: this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.\n+           If your compilation actually takes a long time, you can safely allow the lint.\n+help: the constant being evaluated\n+  --> $DIR/ctfe-recursion.rs:13:1\n    |\n LL | const X: u32 = recurse(19);\n-   |                ^^^^^^^^^^^\n+   | ^^^^^^^^^^^^\n+   = note: `#[deny(long_running_const_eval)]` on by default\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "30550f93ac10d24fc0930f12ba85f37d903cc478", "filename": "tests/ui/consts/const-eval/stable-metric/ctfe-simple-loop.allow.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.allow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.allow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.allow.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,19 @@\n+warning: constant evaluation is taking a long time\n+  --> $DIR/ctfe-simple-loop.rs:9:5\n+   |\n+LL | /     while index < n {\n+LL | |\n+LL | |\n+LL | |\n+LL | |         index = index + 1;\n+LL | |     }\n+   | |_____^ the const evaluator is currently interpreting this expression\n+   |\n+help: the constant being evaluated\n+  --> $DIR/ctfe-simple-loop.rs:19:1\n+   |\n+LL | const Y: u32 = simple_loop(35);\n+   | ^^^^^^^^^^^^\n+\n+warning: 1 warning emitted\n+"}, {"sha": "214f33dfb36c5cf5711fa5651aaa030e9f280c98", "filename": "tests/ui/consts/const-eval/stable-metric/ctfe-simple-loop.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,14 +1,22 @@\n-// check-fail\n+// check-pass\n+// revisions: warn allow\n+#![cfg_attr(warn, warn(long_running_const_eval))]\n+#![cfg_attr(allow, allow(long_running_const_eval))]\n+\n // compile-flags: -Z tiny-const-eval-limit\n const fn simple_loop(n: u32) -> u32 {\n     let mut index = 0;\n-    while index < n { //~ ERROR evaluation of constant value failed [E0080]\n+    while index < n {\n+        //~^ WARN is taking a long time\n+        //[warn]~| WARN is taking a long time\n+        //[warn]~| WARN is taking a long time\n         index = index + 1;\n     }\n     0\n }\n \n const X: u32 = simple_loop(19);\n+const Y: u32 = simple_loop(35);\n \n fn main() {\n     println!(\"{X}\");"}, {"sha": "83ff275de70491a318af4c69f0904a3b53807f50", "filename": "tests/ui/consts/const-eval/stable-metric/ctfe-simple-loop.stderr", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.stderr?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,24 +0,0 @@\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/ctfe-simple-loop.rs:5:5\n-   |\n-LL | /     while index < n {\n-LL | |         index = index + 1;\n-LL | |     }\n-   | |_____^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n-   |\n-note: inside `simple_loop`\n-  --> $DIR/ctfe-simple-loop.rs:5:5\n-   |\n-LL | /     while index < n {\n-LL | |         index = index + 1;\n-LL | |     }\n-   | |_____^\n-note: inside `X`\n-  --> $DIR/ctfe-simple-loop.rs:11:16\n-   |\n-LL | const X: u32 = simple_loop(19);\n-   |                ^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "40fc4a876e9e5ef3198f7db05890cb0e454362d4", "filename": "tests/ui/consts/const-eval/stable-metric/ctfe-simple-loop.warn.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.warn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.warn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fstable-metric%2Fctfe-simple-loop.warn.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,62 @@\n+warning: constant evaluation is taking a long time\n+  --> $DIR/ctfe-simple-loop.rs:9:5\n+   |\n+LL | /     while index < n {\n+LL | |\n+LL | |\n+LL | |\n+LL | |         index = index + 1;\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.\n+           If your compilation actually takes a long time, you can safely allow the lint.\n+help: the constant being evaluated\n+  --> $DIR/ctfe-simple-loop.rs:18:1\n+   |\n+LL | const X: u32 = simple_loop(19);\n+   | ^^^^^^^^^^^^\n+note: the lint level is defined here\n+  --> $DIR/ctfe-simple-loop.rs:3:24\n+   |\n+LL | #![cfg_attr(warn, warn(long_running_const_eval))]\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: constant evaluation is taking a long time\n+  --> $DIR/ctfe-simple-loop.rs:9:5\n+   |\n+LL | /     while index < n {\n+LL | |\n+LL | |\n+LL | |\n+LL | |         index = index + 1;\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: this lint makes sure the compiler doesn't get stuck due to infinite loops in const eval.\n+           If your compilation actually takes a long time, you can safely allow the lint.\n+help: the constant being evaluated\n+  --> $DIR/ctfe-simple-loop.rs:19:1\n+   |\n+LL | const Y: u32 = simple_loop(35);\n+   | ^^^^^^^^^^^^\n+\n+warning: constant evaluation is taking a long time\n+  --> $DIR/ctfe-simple-loop.rs:9:5\n+   |\n+LL | /     while index < n {\n+LL | |\n+LL | |\n+LL | |\n+LL | |         index = index + 1;\n+LL | |     }\n+   | |_____^ the const evaluator is currently interpreting this expression\n+   |\n+help: the constant being evaluated\n+  --> $DIR/ctfe-simple-loop.rs:19:1\n+   |\n+LL | const Y: u32 = simple_loop(35);\n+   | ^^^^^^^^^^^^\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "1810600b7851492ada96392551904286c04dbccb", "filename": "tests/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -86,7 +86,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type `Never`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n@@ -108,7 +108,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:96:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n-   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type Never\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type `Never`\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:98:77"}, {"sha": "fb40babb0b9c3ac248c5ac12f5f960c7c02ce309", "filename": "tests/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -86,7 +86,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type `Never`\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n@@ -108,7 +108,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:96:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n-   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type Never\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type `Never`\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:98:77"}, {"sha": "f1ad0f04d3dbe00bf4623cdaed2868bbf2b625a7", "filename": "tests/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -2,7 +2,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-uninhabit.rs:16:35\n    |\n LL | const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Bar\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type `Bar`\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:19:1\n@@ -19,7 +19,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-uninhabit.rs:22:42\n    |\n LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type Bar\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type `Bar`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "b423edbdcec8df30781b2ed7df19579e9f6888f9", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -28,7 +28,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/validate_uninhabited_zsts.rs:21:42\n    |\n LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type empty::Void\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type `Void`\n \n warning: the type `empty::Empty` does not permit zero-initialization\n   --> $DIR/validate_uninhabited_zsts.rs:21:42"}, {"sha": "b423edbdcec8df30781b2ed7df19579e9f6888f9", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -28,7 +28,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/validate_uninhabited_zsts.rs:21:42\n    |\n LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type empty::Void\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type `Void`\n \n warning: the type `empty::Empty` does not permit zero-initialization\n   --> $DIR/validate_uninhabited_zsts.rs:21:42"}, {"sha": "629d1f02a30f3d88f4db73470e3b0289a80fe3a4", "filename": "tests/ui/consts/const_limit/const_eval_limit_not_reached.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_not_reached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_not_reached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_not_reached.rs?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,20 +0,0 @@\n-// check-pass\n-\n-#![feature(const_eval_limit)]\n-\n-// This needs to be higher than the number of loop iterations since each pass through the loop may\n-// hit more than one terminator.\n-#![const_eval_limit=\"4000\"]\n-\n-const X: usize = {\n-    let mut x = 0;\n-    while x != 1000 {\n-        x += 1;\n-    }\n-\n-    x\n-};\n-\n-fn main() {\n-    assert_eq!(X, 1000);\n-}"}, {"sha": "1c49593cd53fa399bc8d6451b60d70e13825b3c5", "filename": "tests/ui/consts/const_limit/const_eval_limit_overflow.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_overflow.rs?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,15 +0,0 @@\n-#![feature(const_eval_limit)]\n-#![const_eval_limit=\"18_446_744_073_709_551_615\"]\n-//~^ ERROR `limit` must be a non-negative integer\n-\n-const CONSTANT: usize = limit();\n-\n-fn main() {\n-    assert_eq!(CONSTANT, 1764);\n-}\n-\n-const fn limit() -> usize {\n-    let x = 42;\n-\n-    x * 42\n-}"}, {"sha": "7f5d5e6cd4c5ac07714a5d2a977d89dbbbc0506d", "filename": "tests/ui/consts/const_limit/const_eval_limit_overflow.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_overflow.stderr?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,10 +0,0 @@\n-error: `limit` must be a non-negative integer\n-  --> $DIR/const_eval_limit_overflow.rs:2:1\n-   |\n-LL | #![const_eval_limit=\"18_446_744_073_709_551_615\"]\n-   | ^^^^^^^^^^^^^^^^^^^^----------------------------^\n-   |                     |\n-   |                     not a valid integer\n-\n-error: aborting due to previous error\n-"}, {"sha": "3ce038c1d3f772e86da1665b571c702d8ac5c890", "filename": "tests/ui/consts/const_limit/const_eval_limit_reached.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.rs?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,16 +0,0 @@\n-#![feature(const_eval_limit)]\n-#![const_eval_limit = \"500\"]\n-\n-const X: usize = {\n-    let mut x = 0;\n-    while x != 1000 {\n-        //~^ ERROR evaluation of constant value failed\n-        x += 1;\n-    }\n-\n-    x\n-};\n-\n-fn main() {\n-    assert_eq!(X, 1000);\n-}"}, {"sha": "a8e8ae9bb088a07737324dd98aeaf9a3ad2762df", "filename": "tests/ui/consts/const_limit/const_eval_limit_reached.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,12 +0,0 @@\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/const_eval_limit_reached.rs:6:5\n-   |\n-LL | /     while x != 1000 {\n-LL | |\n-LL | |         x += 1;\n-LL | |     }\n-   | |_____^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "61119d7511d49262fc41355eea7720d7155d9eb4", "filename": "tests/ui/consts/const_limit/feature-gate-const_eval_limit.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Ffeature-gate-const_eval_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Ffeature-gate-const_eval_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_limit%2Ffeature-gate-const_eval_limit.rs?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,14 +0,0 @@\n-#![const_eval_limit=\"42\"]\n-//~^ ERROR the `#[const_eval_limit]` attribute is an experimental feature [E0658]\n-\n-const CONSTANT: usize = limit();\n-\n-fn main() {\n-    assert_eq!(CONSTANT, 1764);\n-}\n-\n-const fn limit() -> usize {\n-    let x = 42;\n-\n-    x * 42\n-}"}, {"sha": "5bd29c7dfd22b8f116a5119e53ed15fa871c6543", "filename": "tests/ui/consts/const_limit/feature-gate-const_eval_limit.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Ffeature-gate-const_eval_limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47bf8e734f25e1ed65864263a8795f1335d6dce0/tests%2Fui%2Fconsts%2Fconst_limit%2Ffeature-gate-const_eval_limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_limit%2Ffeature-gate-const_eval_limit.stderr?ref=47bf8e734f25e1ed65864263a8795f1335d6dce0", "patch": "@@ -1,12 +0,0 @@\n-error[E0658]: the `#[const_eval_limit]` attribute is an experimental feature\n-  --> $DIR/feature-gate-const_eval_limit.rs:1:1\n-   |\n-LL | #![const_eval_limit=\"42\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #67217 <https://github.com/rust-lang/rust/issues/67217> for more information\n-   = help: add `#![feature(const_eval_limit)]` to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "2fe84245b3ef80bf1355a2b2db834f96e7ae0c84", "filename": "tests/ui/consts/issue-64506.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fissue-64506.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fissue-64506.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-64506.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -2,7 +2,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-64506.rs:16:22\n    |\n LL |     let x = unsafe { Foo { b: () }.a };\n-   |                      ^^^^^^^^^^^^^^^ constructing invalid value at .inner: encountered a value of uninhabited type AnonPipe\n+   |                      ^^^^^^^^^^^^^^^ constructing invalid value at .inner: encountered a value of uninhabited type `AnonPipe`\n \n error: aborting due to previous error\n "}, {"sha": "ca4e0f7aa02397b2eddf053780cd778b26e152d1", "filename": "tests/ui/consts/issue-83182.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fissue-83182.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fissue-83182.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-83182.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,11 +4,11 @@ error[E0080]: it is undefined behavior to use this value\n LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n                HEX_DUMP\n            }\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: aborting due to previous error\n "}, {"sha": "67797e6fb5a85331d398fb8b39a510864b00884b", "filename": "tests/ui/consts/issue-miri-1910.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,8 +3,6 @@ error[E0080]: evaluation of constant value failed\n    |\n    = note: unable to turn pointer into raw bytes\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n note: inside `std::ptr::read::<u8>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n note: inside `ptr::const_ptr::<impl *const u8>::read`\n@@ -14,6 +12,8 @@ note: inside `C`\n    |\n LL |     (&foo as *const _ as *const u8).add(one_and_a_half_pointers).read();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: aborting due to previous error\n "}, {"sha": "d97097d352a6430122c8dec09f2f3501eb1e46c3", "filename": "tests/ui/consts/miri_unleashed/assoc_const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,4 +1,4 @@\n-error[E0080]: evaluation of `<std::string::String as Bar<std::vec::Vec<u32>, std::string::String>>::F` failed\n+error[E0080]: evaluation of `<String as Bar<Vec<u32>, String>>::F` failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n    = note: calling non-const function `<Vec<u32> as Drop>::drop`"}, {"sha": "adb1f8bf3ec55d1703a26823f14c12a247a8d82a", "filename": "tests/ui/consts/miri_unleashed/raw_mutable_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,6 +3,6 @@\n use std::cell::UnsafeCell;\n \n const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n-//~^ ERROR: untyped pointers are not allowed in constant\n+//~^ ERROR: unsupported untyped pointer in constant\n \n fn main() {}"}, {"sha": "5acdcdd95e8e35e52a455a48971f9d39a61633b0", "filename": "tests/ui/consts/miri_unleashed/raw_mutable_const.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmiri_unleashed%2Fraw_mutable_const.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,8 +1,10 @@\n-error: untyped pointers are not allowed in constant\n+error: unsupported untyped pointer in constant\n   --> $DIR/raw_mutable_const.rs:5:1\n    |\n LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: memory only reachable via raw pointers is not supported\n \n warning: skipping const checks\n    |"}, {"sha": "fcfb9fbb3f8c0fb4ebd45293aa02e4058406d6a9", "filename": "tests/ui/consts/missing_span_in_backtrace.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fmissing_span_in_backtrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fmissing_span_in_backtrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fmissing_span_in_backtrace.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,8 +3,6 @@ error[E0080]: evaluation of constant value failed\n    |\n    = note: unable to copy parts of a pointer from memory at ALLOC_ID\n    |\n-   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n-   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n note: inside `std::ptr::read::<MaybeUninit<MaybeUninit<u8>>>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n note: inside `mem::swap_simple::<MaybeUninit<MaybeUninit<u8>>>`\n@@ -22,6 +20,8 @@ note: inside `X`\n 20 | |             mem::size_of::<&i32>(),\n 21 | |         );\n    | |_________^\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: aborting due to previous error\n "}, {"sha": "97ff6efdd791c4eb9e3cb4af5b2cfc97ccaaeb98", "filename": "tests/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -27,31 +27,31 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:37:14\n    |\n LL |     unsafe { ptr_offset_from(ptr, ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:44:14\n    |\n LL |     unsafe { ptr_offset_from(ptr2, ptr1) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: 0x8[noalloc] is a dangling pointer (it has no provenance)\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: 0x8[noalloc] is a dangling pointer (it has no provenance)\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:53:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc17 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: alloc17 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:62:14\n    |\n LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc20 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: alloc20 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:70:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc23 has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds `offset_from`: alloc23 has size 4, so pointer at offset 10 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:79:14\n@@ -86,7 +86,7 @@ LL |     unsafe { ptr_offset_from_unsigned(ptr2, ptr1) }\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds `offset_from`: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset_from`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n@@ -99,7 +99,7 @@ LL |     unsafe { ptr2.offset_from(ptr1) }\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-   = note: out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   = note: out-of-bounds `offset_from`: null pointer is a dangling pointer (it has no provenance)\n    |\n note: inside `ptr::const_ptr::<impl *const u8>::offset_from`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL"}, {"sha": "fc774be54dff3814b3a09083cf900a4237f26331", "filename": "tests/ui/consts/raw-ptr-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fraw-ptr-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fraw-ptr-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fraw-ptr-const.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,6 +3,6 @@\n // could also be allowed.\n \n const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;\n-//~^ ERROR untyped pointers are not allowed in constant\n+//~^ ERROR unsupported untyped pointer in constant\n \n fn main() {}"}, {"sha": "82f782fab7f548bb68c2fd7e070ecd65562d461e", "filename": "tests/ui/consts/raw-ptr-const.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fraw-ptr-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fconsts%2Fraw-ptr-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fraw-ptr-const.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,8 +1,10 @@\n-error: untyped pointers are not allowed in constant\n+error: unsupported untyped pointer in constant\n   --> $DIR/raw-ptr-const.rs:5:1\n    |\n LL | const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: memory only reachable via raw pointers is not supported\n \n error: aborting due to previous error\n "}, {"sha": "408abecc30d4426929f583034ecf1b58a6c246ca", "filename": "tests/ui/dyn-star/param-env-infer.next.stderr", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -13,41 +13,6 @@ error[E0391]: cycle detected when computing type of `make_dyn_star::{opaque#0}`\n LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n    |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires borrow-checking `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires promoting constants in MIR for `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires preparing `make_dyn_star` for borrow checking...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires match-checking `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building THIR for `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `make_dyn_star`...\n   --> $DIR/param-env-infer.rs:11:1\n    |"}, {"sha": "c0c4cd5013e5fffaafe68a0f581fcd36b7d43cd5", "filename": "tests/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,41 +4,6 @@ error[E0391]: cycle detected when computing type of `cycle1::{opaque#0}`\n LL | fn cycle1() -> impl Clone {\n    |                ^^^^^^^^^^\n    |\n-note: ...which requires borrow-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires promoting constants in MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires preparing `cycle1` for borrow checking...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires match-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building THIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle1`...\n   --> $DIR/auto-trait-leak.rs:14:5\n    |\n@@ -50,41 +15,6 @@ note: ...which requires computing type of `cycle2::{opaque#0}`...\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n-note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires promoting constants in MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires preparing `cycle2` for borrow checking...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires match-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building THIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle2`...\n   --> $DIR/auto-trait-leak.rs:20:5\n    |"}, {"sha": "86661153a0d098a57e985b87256b0eb6e6d3e41a", "filename": "tests/ui/impl-trait/multiple-defining-usages-in-body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,9 +4,9 @@ impl Trait for () {}\n fn foo<T: Trait, U: Trait>() -> impl Trait {\n     //~^ WARN function cannot return without recursing [unconditional_recursion]\n     let a: T = foo::<T, U>();\n-    //~^ ERROR concrete type differs from previous defining opaque type use\n     loop {}\n     let _: T = foo::<U, T>();\n+    //~^ ERROR concrete type differs from previous defining opaque type use\n }\n \n fn main() {}"}, {"sha": "f3c090408b42e804f89fde74ab66b82fb7d35d2f", "filename": "tests/ui/impl-trait/multiple-defining-usages-in-body.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -11,15 +11,15 @@ LL |     let a: T = foo::<T, U>();\n    = note: `#[warn(unconditional_recursion)]` on by default\n \n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/multiple-defining-usages-in-body.rs:6:16\n+  --> $DIR/multiple-defining-usages-in-body.rs:8:16\n    |\n-LL |     let a: T = foo::<T, U>();\n-   |                ^^^^^^^^^^^^^ expected `U`, got `T`\n+LL |     let _: T = foo::<U, T>();\n+   |                ^^^^^^^^^^^^^ expected `T`, got `U`\n    |\n note: previous use here\n-  --> $DIR/multiple-defining-usages-in-body.rs:9:16\n+  --> $DIR/multiple-defining-usages-in-body.rs:6:16\n    |\n-LL |     let _: T = foo::<U, T>();\n+LL |     let a: T = foo::<T, U>();\n    |                ^^^^^^^^^^^^^\n \n error: aborting due to previous error; 1 warning emitted"}, {"sha": "5661db4a2530dafa64c5d12cdca07f181052a2ab", "filename": "tests/ui/inline-const/elided-lifetime-being-infer-vars.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Finline-const%2Felided-lifetime-being-infer-vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Finline-const%2Felided-lifetime-being-infer-vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finline-const%2Felided-lifetime-being-infer-vars.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#![feature(inline_const)]\n+\n+fn main() {\n+    let _my_usize = const {\n+        let a = 10_usize;\n+        let b: &'_ usize = &a;\n+        *b\n+    };\n+}"}, {"sha": "745d7070143662010359fc38d4cdb6273bead131", "filename": "tests/ui/lint/cast_ref_to_mut.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Flint%2Fcast_ref_to_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Flint%2Fcast_ref_to_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fcast_ref_to_mut.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,50 @@\n+// check-fail\n+\n+#![feature(ptr_from_ref)]\n+\n+extern \"C\" {\n+    // N.B., mutability can be easily incorrect in FFI calls -- as\n+    // in C, the default is mutable pointers.\n+    fn ffi(c: *mut u8);\n+    fn int_ffi(c: *mut i32);\n+}\n+\n+fn main() {\n+    let s = String::from(\"Hello\");\n+    let a = &s;\n+    unsafe {\n+        let num = &3i32;\n+        let mut_num = &mut 3i32;\n+\n+        (*(a as *const _ as *mut String)).push_str(\" world\");\n+        //~^ ERROR casting `&T` to `&mut T` is undefined behavior\n+        *(a as *const _ as *mut _) = String::from(\"Replaced\");\n+        //~^ ERROR casting `&T` to `&mut T` is undefined behavior\n+        *(a as *const _ as *mut String) += \" world\";\n+        //~^ ERROR casting `&T` to `&mut T` is undefined behavior\n+        let _num = &mut *(num as *const i32 as *mut i32);\n+        //~^ ERROR casting `&T` to `&mut T` is undefined behavior\n+        let _num = &mut *(num as *const i32).cast_mut();\n+        //~^ ERROR casting `&T` to `&mut T` is undefined behavior\n+        let _num = *{ num as *const i32 }.cast_mut();\n+        //~^ ERROR casting `&T` to `&mut T` is undefined behavior\n+        *std::ptr::from_ref(num).cast_mut() += 1;\n+        //~^ ERROR casting `&T` to `&mut T` is undefined behavior\n+        *std::ptr::from_ref({ num }).cast_mut() += 1;\n+        //~^ ERROR casting `&T` to `&mut T` is undefined behavior\n+        *{ std::ptr::from_ref(num) }.cast_mut() += 1;\n+        //~^ ERROR casting `&T` to `&mut T` is undefined behavior\n+        *(std::ptr::from_ref({ num }) as *mut i32) += 1;\n+        //~^ ERROR casting `&T` to `&mut T` is undefined behavior\n+\n+        // Shouldn't be warned against\n+        println!(\"{}\", *(num as *const _ as *const i16));\n+        println!(\"{}\", *(mut_num as *mut _ as *mut i16));\n+        ffi(a.as_ptr() as *mut _);\n+        int_ffi(num as *const _ as *mut _);\n+        int_ffi(&3 as *const _ as *mut _);\n+        let mut value = 3;\n+        let value: *const i32 = &mut value;\n+        *(value as *const i16 as *mut i16) = 42;\n+    }\n+}"}, {"sha": "baff00d6c04196ccbd2b58266f082218de583efa", "filename": "tests/ui/lint/cast_ref_to_mut.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Flint%2Fcast_ref_to_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Flint%2Fcast_ref_to_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fcast_ref_to_mut.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,64 @@\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/cast_ref_to_mut.rs:19:9\n+   |\n+LL |         (*(a as *const _ as *mut String)).push_str(\" world\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[deny(cast_ref_to_mut)]` on by default\n+\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/cast_ref_to_mut.rs:21:9\n+   |\n+LL |         *(a as *const _ as *mut _) = String::from(\"Replaced\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/cast_ref_to_mut.rs:23:9\n+   |\n+LL |         *(a as *const _ as *mut String) += \" world\";\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/cast_ref_to_mut.rs:25:25\n+   |\n+LL |         let _num = &mut *(num as *const i32 as *mut i32);\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/cast_ref_to_mut.rs:27:25\n+   |\n+LL |         let _num = &mut *(num as *const i32).cast_mut();\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/cast_ref_to_mut.rs:29:20\n+   |\n+LL |         let _num = *{ num as *const i32 }.cast_mut();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/cast_ref_to_mut.rs:31:9\n+   |\n+LL |         *std::ptr::from_ref(num).cast_mut() += 1;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/cast_ref_to_mut.rs:33:9\n+   |\n+LL |         *std::ptr::from_ref({ num }).cast_mut() += 1;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/cast_ref_to_mut.rs:35:9\n+   |\n+LL |         *{ std::ptr::from_ref(num) }.cast_mut() += 1;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n+  --> $DIR/cast_ref_to_mut.rs:37:9\n+   |\n+LL |         *(std::ptr::from_ref({ num }) as *mut i32) += 1;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "b46ba89e81d7f7c31af50ca113dd0621a05fa579", "filename": "tests/ui/loops/dont-suggest-break-thru-item.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,55 @@\n+// edition:2021\n+\n+#![feature(inline_const)]\n+\n+fn closure() {\n+    loop {\n+        let closure = || {\n+            if true {\n+                Err(1)\n+                //~^ ERROR mismatched types\n+            }\n+\n+            Ok(())\n+        };\n+    }\n+}\n+\n+fn async_block() {\n+    loop {\n+        let fut = async {\n+            if true {\n+                Err(1)\n+                //~^ ERROR mismatched types\n+            }\n+\n+            Ok(())\n+        };\n+    }\n+}\n+\n+fn fn_item() {\n+    let _ = loop {\n+        fn foo() -> Result<(), ()> {\n+            if true {\n+                Err(1)\n+                //~^ ERROR mismatched types\n+            }\n+            Err(())\n+        }\n+    };\n+}\n+\n+fn const_block() {\n+    let _ = loop {\n+        const {\n+            if true {\n+                Err(1)\n+                //~^ ERROR mismatched types\n+            }\n+            Err(())\n+        };\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "4fce4715119047f7633686ad3663fac051f7600e", "filename": "tests/ui/loops/dont-suggest-break-thru-item.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,55 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dont-suggest-break-thru-item.rs:9:17\n+   |\n+LL | /             if true {\n+LL | |                 Err(1)\n+   | |                 ^^^^^^ expected `()`, found `Result<_, {integer}>`\n+LL | |\n+LL | |             }\n+   | |_____________- expected this to be `()`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<_, {integer}>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dont-suggest-break-thru-item.rs:22:17\n+   |\n+LL | /             if true {\n+LL | |                 Err(1)\n+   | |                 ^^^^^^ expected `()`, found `Result<_, {integer}>`\n+LL | |\n+LL | |             }\n+   | |_____________- expected this to be `()`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<_, {integer}>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dont-suggest-break-thru-item.rs:35:17\n+   |\n+LL | /             if true {\n+LL | |                 Err(1)\n+   | |                 ^^^^^^ expected `()`, found `Result<_, {integer}>`\n+LL | |\n+LL | |             }\n+   | |_____________- expected this to be `()`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<_, {integer}>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dont-suggest-break-thru-item.rs:47:17\n+   |\n+LL | /             if true {\n+LL | |                 Err(1)\n+   | |                 ^^^^^^ expected `()`, found `Result<_, {integer}>`\n+LL | |\n+LL | |             }\n+   | |_____________- expected this to be `()`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<_, {integer}>`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "df28c474ab0a2012c95ae24fce475dfcdbedc1d2", "filename": "tests/ui/match/issue-70972-dyn-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let a: &dyn Send = &7u32;\n     match a {\n         F => panic!(),\n-        //~^ ERROR `&dyn Send` cannot be used in patterns\n+        //~^ ERROR `dyn Send` cannot be used in patterns\n         _ => {}\n     }\n }"}, {"sha": "f4dc910c34a6596eb3bc659705897c3425b51a58", "filename": "tests/ui/match/issue-70972-dyn-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,4 +1,4 @@\n-error: `&dyn Send` cannot be used in patterns\n+error: `dyn Send` cannot be used in patterns\n   --> $DIR/issue-70972-dyn-trait.rs:6:9\n    |\n LL |         F => panic!(),"}, {"sha": "2fba94d07401c5994b4db8e82f964e68f94247f6", "filename": "tests/ui/numbers-arithmetic/issue-8460-const.noopt.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.noopt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.noopt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.noopt.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -76,37 +76,37 @@ error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:35:36\n    |\n LL |     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^^ attempt to compute the remainder of `isize::MIN % -1_isize`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^^ attempt to compute `isize::MIN % -1_isize`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:37:36\n    |\n LL |     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^ attempt to compute the remainder of `i8::MIN % -1_i8`, which would overflow\n+   |                                    ^^^^^^^^^^^^ attempt to compute `i8::MIN % -1_i8`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:39:36\n    |\n LL |     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i16::MIN % -1_i16`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i16::MIN % -1_i16`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:41:36\n    |\n LL |     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i32::MIN % -1_i32`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i32::MIN % -1_i32`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:43:36\n    |\n LL |     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i64::MIN % -1_i64`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:45:36\n    |\n LL |     assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^ attempt to compute the remainder of `i128::MIN % -1_i128`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^ attempt to compute `i128::MIN % -1_i128`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:47:36"}, {"sha": "2fba94d07401c5994b4db8e82f964e68f94247f6", "filename": "tests/ui/numbers-arithmetic/issue-8460-const.opt.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -76,37 +76,37 @@ error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:35:36\n    |\n LL |     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^^ attempt to compute the remainder of `isize::MIN % -1_isize`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^^ attempt to compute `isize::MIN % -1_isize`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:37:36\n    |\n LL |     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^ attempt to compute the remainder of `i8::MIN % -1_i8`, which would overflow\n+   |                                    ^^^^^^^^^^^^ attempt to compute `i8::MIN % -1_i8`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:39:36\n    |\n LL |     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i16::MIN % -1_i16`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i16::MIN % -1_i16`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:41:36\n    |\n LL |     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i32::MIN % -1_i32`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i32::MIN % -1_i32`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:43:36\n    |\n LL |     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i64::MIN % -1_i64`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:45:36\n    |\n LL |     assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^ attempt to compute the remainder of `i128::MIN % -1_i128`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^ attempt to compute `i128::MIN % -1_i128`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:47:36"}, {"sha": "2fba94d07401c5994b4db8e82f964e68f94247f6", "filename": "tests/ui/numbers-arithmetic/issue-8460-const.opt_with_overflow_checks.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt_with_overflow_checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt_with_overflow_checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnumbers-arithmetic%2Fissue-8460-const.opt_with_overflow_checks.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -76,37 +76,37 @@ error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:35:36\n    |\n LL |     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^^ attempt to compute the remainder of `isize::MIN % -1_isize`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^^ attempt to compute `isize::MIN % -1_isize`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:37:36\n    |\n LL |     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^ attempt to compute the remainder of `i8::MIN % -1_i8`, which would overflow\n+   |                                    ^^^^^^^^^^^^ attempt to compute `i8::MIN % -1_i8`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:39:36\n    |\n LL |     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i16::MIN % -1_i16`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i16::MIN % -1_i16`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:41:36\n    |\n LL |     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i32::MIN % -1_i32`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i32::MIN % -1_i32`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:43:36\n    |\n LL |     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^ attempt to compute the remainder of `i64::MIN % -1_i64`, which would overflow\n+   |                                    ^^^^^^^^^^^^^ attempt to compute `i64::MIN % -1_i64`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:45:36\n    |\n LL |     assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n-   |                                    ^^^^^^^^^^^^^^ attempt to compute the remainder of `i128::MIN % -1_i128`, which would overflow\n+   |                                    ^^^^^^^^^^^^^^ attempt to compute `i128::MIN % -1_i128`, which would overflow\n \n error: this operation will panic at runtime\n   --> $DIR/issue-8460-const.rs:47:36"}, {"sha": "21edb26de082eb4d0c7d43519db3751e7453b055", "filename": "tests/ui/pattern/issue-72565.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fpattern%2Fissue-72565.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fpattern%2Fissue-72565.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-72565.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -3,6 +3,6 @@ const F: &'static dyn PartialEq<u32> = &7u32;\n fn main() {\n     let a: &dyn PartialEq<u32> = &7u32;\n     match a {\n-        F => panic!(), //~ ERROR: `&dyn PartialEq<u32>` cannot be used in patterns\n+        F => panic!(), //~ ERROR: `dyn PartialEq<u32>` cannot be used in patterns\n     }\n }"}, {"sha": "0519720694d70b25aead81d4d840976def03f898", "filename": "tests/ui/pattern/issue-72565.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fpattern%2Fissue-72565.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fpattern%2Fissue-72565.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-72565.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -1,4 +1,4 @@\n-error: `&dyn PartialEq<u32>` cannot be used in patterns\n+error: `dyn PartialEq<u32>` cannot be used in patterns\n   --> $DIR/issue-72565.rs:6:9\n    |\n LL |         F => panic!(),"}, {"sha": "9260930473fa83a80029ff47826dce436e6a0bbb", "filename": "tests/ui/statics/uninhabited-static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fstatics%2Funinhabited-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fstatics%2Funinhabited-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstatics%2Funinhabited-static.stderr?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -47,7 +47,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/uninhabited-static.rs:12:31\n    |\n LL | static VOID2: Void = unsafe { std::mem::transmute(()) };\n-   |                               ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Void\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type `Void`\n \n warning: the type `Void` does not permit zero-initialization\n   --> $DIR/uninhabited-static.rs:12:31\n@@ -66,7 +66,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/uninhabited-static.rs:16:32\n    |\n LL | static NEVER2: Void = unsafe { std::mem::transmute(()) };\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Void\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type `Void`\n \n warning: the type `Void` does not permit zero-initialization\n   --> $DIR/uninhabited-static.rs:16:32"}, {"sha": "745fdef154632c355143f8db9fcbb32422b2f1c2", "filename": "tests/ui/suggestions/issue-88696.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fsuggestions%2Fissue-88696.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507055bc50258f3e2329fb383495f2a6a05a6cd2/tests%2Fui%2Fsuggestions%2Fissue-88696.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-88696.rs?ref=507055bc50258f3e2329fb383495f2a6a05a6cd2", "patch": "@@ -0,0 +1,14 @@\n+// This test case should ensure that miniz_oxide isn't\n+// suggested, since it's not a direct dependency.\n+\n+fn a() -> Result<u64, i32> {\n+    Err(1)\n+}\n+\n+fn b() -> Result<u32, i32> {\n+    a().into() //~ERROR [E0277]\n+}\n+\n+fn main() {\n+    let _ = dbg!(b());\n+}"}]}