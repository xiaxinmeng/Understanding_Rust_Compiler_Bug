{"sha": "f5d604f0c371b17c8d65b471463b819798c88b4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZDYwNGYwYzM3MWIxN2M4ZDY1YjQ3MTQ2M2I4MTk3OThjODhiNGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-08T21:53:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-08T22:07:14Z"}, "message": "Decode types across multiple crates. Closes #632", "tree": {"sha": "f7ddfdfbc70899781b6f1e8d5c2da3bd489bf50c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7ddfdfbc70899781b6f1e8d5c2da3bd489bf50c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5d604f0c371b17c8d65b471463b819798c88b4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5d604f0c371b17c8d65b471463b819798c88b4c", "html_url": "https://github.com/rust-lang/rust/commit/f5d604f0c371b17c8d65b471463b819798c88b4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5d604f0c371b17c8d65b471463b819798c88b4c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33ce1164e20d8f0f87cc19eed7281786de72a424", "url": "https://api.github.com/repos/rust-lang/rust/commits/33ce1164e20d8f0f87cc19eed7281786de72a424", "html_url": "https://github.com/rust-lang/rust/commit/33ce1164e20d8f0f87cc19eed7281786de72a424"}], "stats": {"total": 98, "additions": 71, "deletions": 27}, "files": [{"sha": "f1ce33eff0db00d10cecf6cab871e868ab792051", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f5d604f0c371b17c8d65b471463b819798c88b4c/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d604f0c371b17c8d65b471463b819798c88b4c/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=f5d604f0c371b17c8d65b471463b819798c88b4c", "patch": "@@ -3,6 +3,14 @@\n import syntax::ast;\n import middle::ty;\n import std::io;\n+import std::option;\n+import driver::session;\n+\n+export get_symbol;\n+export get_type_param_count;\n+export lookup_defs;\n+export get_tag_variants;\n+export get_type;\n \n fn get_symbol(&cstore::cstore cstore, ast::def_id def) -> str {\n     auto cnum = def._0;\n@@ -11,31 +19,61 @@ fn get_symbol(&cstore::cstore cstore, ast::def_id def) -> str {\n     ret decoder::get_symbol(cdata, node_id);\n }\n \n-fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> ty::variant_info[] {\n-    auto cstore = tcx.sess.get_cstore();\n+fn get_type_param_count(&cstore::cstore cstore, &ast::def_id def) -> uint {\n     auto cnum = def._0;\n+    auto node_id = def._1;\n     auto cdata = cstore::get_crate_data(cstore, cnum).data;\n-    ret decoder::get_tag_variants(cdata, def, tcx)\n+    ret decoder::get_type_param_count(cdata, node_id);\n }\n \n-fn get_type(ty::ctxt tcx, ast::def_id def) -> ty::ty_param_count_and_ty {\n+fn lookup_defs(&cstore::cstore cstore, ast::crate_num cnum,\n+               vec[ast::ident] path) -> vec[ast::def] {\n+    auto cdata = cstore::get_crate_data(cstore, cnum).data;\n+    ret decoder::lookup_defs(cdata, cnum, path);\n+}\n+\n+fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> ty::variant_info[] {\n     auto cstore = tcx.sess.get_cstore();\n     auto cnum = def._0;\n     auto cdata = cstore::get_crate_data(cstore, cnum).data;\n-    decoder::get_type(cdata, def, tcx)\n+    auto resolver = bind translate_def_id(tcx.sess, cnum, _);\n+    ret decoder::get_tag_variants(cdata, def, tcx, resolver)\n }\n \n-fn get_type_param_count(&cstore::cstore cstore, &ast::def_id def) -> uint {\n+fn get_type(ty::ctxt tcx, ast::def_id def) -> ty::ty_param_count_and_ty {\n+    auto cstore = tcx.sess.get_cstore();\n     auto cnum = def._0;\n-    auto node_id = def._1;\n     auto cdata = cstore::get_crate_data(cstore, cnum).data;\n-    ret decoder::get_type_param_count(cdata, node_id);\n+    auto resolver = bind translate_def_id(tcx.sess, cnum, _);\n+    decoder::get_type(cdata, def, tcx, resolver)\n }\n \n-fn lookup_defs(&cstore::cstore cstore, ast::crate_num cnum,\n-               vec[ast::ident] path) -> vec[ast::def] {\n-    auto cdata = cstore::get_crate_data(cstore, cnum).data;\n-    ret decoder::lookup_defs(cdata, cnum, path);\n+// Translates a def_id from an external crate to a def_id for the current\n+// compilation environment. We use this when trying to load types from\n+// external crates - if those types further refer to types in other crates\n+// then we must translate the crate number from that encoded in the external\n+// crate to the correct local crate number.\n+fn translate_def_id(&session::session sess,\n+                    ast::crate_num searched_crate,\n+                    &ast::def_id def_id) -> ast::def_id {\n+\n+    auto ext_cnum = def_id._0;\n+    auto node_id = def_id._1;\n+\n+    assert searched_crate != ast::local_crate;\n+    assert ext_cnum != ast::local_crate;\n+\n+    auto cstore = sess.get_cstore();\n+    auto cmeta = cstore::get_crate_data(cstore, searched_crate);\n+\n+    auto local_cnum = alt (cmeta.cnum_map.find(ext_cnum)) {\n+        case (option::some(?n)) { n }\n+        case (option::none) {\n+            sess.bug(\"didn't find a crate in the cnum_map\")\n+        }\n+    };\n+\n+    ret tup(local_cnum, node_id);\n }\n \n // Local Variables:"}, {"sha": "dfa44909ce22dacb720248883cd8281ec9dc4705", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5d604f0c371b17c8d65b471463b819798c88b4c/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d604f0c371b17c8d65b471463b819798c88b4c/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=f5d604f0c371b17c8d65b471463b819798c88b4c", "patch": "@@ -85,7 +85,6 @@ fn add_use_stmt_cnum(&cstore cstore, ast::node_id use_id,\n     cstore.use_crate_map.insert(use_id, cnum);\n }\n \n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "eab90d929d75db1275c245b6b8dc257840ab6a17", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f5d604f0c371b17c8d65b471463b819798c88b4c/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5d604f0c371b17c8d65b471463b819798c88b4c/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=f5d604f0c371b17c8d65b471463b819798c88b4c", "patch": "@@ -26,6 +26,14 @@ export get_crate_attributes;\n export list_crate_metadata;\n export crate_dep;\n export get_crate_deps;\n+export external_resolver;\n+\n+// A function that takes a def_id relative to the crate being searched and\n+// returns a def_id relative to the compilation environment, i.e. if we hit a\n+// def_id for an item defined in another crate, somebody needs to figure out\n+// what crate that's in and give us a def_id that makes sense for the current\n+// build.\n+type external_resolver = fn(&ast::def_id def_id) -> ast::def_id;\n \n fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool  eq_fn, uint hash) ->\n    vec[ebml::doc] {\n@@ -85,8 +93,10 @@ fn variant_tag_id(&ebml::doc d) -> ast::def_id {\n }\n \n fn item_type(&ebml::doc item, ast::crate_num this_cnum,\n-             ty::ctxt tcx) -> ty::t {\n-    fn parse_external_def_id(ast::crate_num this_cnum, str s) -> ast::def_id {\n+             ty::ctxt tcx, &external_resolver extres) -> ty::t {\n+    fn parse_external_def_id(ast::crate_num this_cnum,\n+                             &external_resolver extres,\n+                             str s) -> ast::def_id {\n         auto buf = str::bytes(s);\n         auto external_def_id = parse_def_id(buf);\n \n@@ -95,17 +105,13 @@ fn item_type(&ebml::doc item, ast::crate_num this_cnum,\n         if (external_def_id._0 == ast::local_crate) {\n             ret tup(this_cnum, external_def_id._1);\n         } else {\n-            // FIXME: This is completely wrong when linking against a crate\n-            // that, in turn, links against another crate. We need a mapping\n-            // from crate ID to crate \"meta\" attributes as part of the crate\n-            // metadata:\n-            fail \"trying to load type info from a crate that is \\\n-                  defined in a different crate\";\n+            ret extres(external_def_id);\n         }\n     }\n     auto tp = ebml::get_doc(item, tag_items_data_item_type);\n+    auto def_parser = bind parse_external_def_id(this_cnum, extres, _);\n     ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n-                      bind parse_external_def_id(this_cnum, _), tcx);\n+                      def_parser, tcx);\n }\n \n fn item_ty_param_count(&ebml::doc item) -> uint {\n@@ -180,12 +186,12 @@ fn lookup_def(ast::crate_num cnum, vec[u8] data,\n     ret def;\n }\n \n-fn get_type(&vec[u8] data, ast::def_id def,\n-            &ty::ctxt tcx) -> ty::ty_param_count_and_ty {\n+fn get_type(&vec[u8] data, ast::def_id def, &ty::ctxt tcx,\n+            &external_resolver extres) -> ty::ty_param_count_and_ty {\n     auto this_cnum = def._0;\n     auto node_id = def._1;\n     auto item = lookup_item(node_id, data);\n-    auto t = item_type(item, this_cnum, tcx);\n+    auto t = item_type(item, this_cnum, tcx, extres);\n     auto tp_count;\n     auto kind_ch = item_kind(item);\n     auto has_ty_params = kind_has_type_params(kind_ch);\n@@ -204,7 +210,8 @@ fn get_symbol(&vec[u8] data, ast::node_id id) -> str {\n }\n \n fn get_tag_variants(&vec[u8] data, ast::def_id def,\n-                    &ty::ctxt tcx) -> ty::variant_info[] {\n+                    &ty::ctxt tcx,\n+                    &external_resolver extres) -> ty::variant_info[] {\n     auto external_crate_id = def._0;\n     auto data = cstore::get_crate_data(tcx.sess.get_cstore(),\n                                        external_crate_id).data;\n@@ -214,7 +221,7 @@ fn get_tag_variants(&vec[u8] data, ast::def_id def,\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n     for (ast::def_id did in variant_ids) {\n         auto item = find_item(did._1, items);\n-        auto ctor_ty = item_type(item, external_crate_id, tcx);\n+        auto ctor_ty = item_type(item, external_crate_id, tcx, extres);\n         let ty::t[] arg_tys = ~[];\n         alt (ty::struct(tcx, ctor_ty)) {\n             case (ty::ty_fn(_, ?args, _, _, _)) {"}]}