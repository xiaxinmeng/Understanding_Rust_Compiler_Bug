{"sha": "6c2748211565773c297560f2edcd762565f1933a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMjc0ODIxMTU2NTc3M2MyOTc1NjBmMmVkY2Q3NjI1NjVmMTkzM2E=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-06-03T06:41:37Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-06-03T06:41:37Z"}, "message": "Merge commit '3ae8faff4d46ad92f194c2a4b941c3152a701b31' into clippyup", "tree": {"sha": "ea7c9f33926e8df2be4f551514090d804651acb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea7c9f33926e8df2be4f551514090d804651acb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c2748211565773c297560f2edcd762565f1933a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2748211565773c297560f2edcd762565f1933a", "html_url": "https://github.com/rust-lang/rust/commit/6c2748211565773c297560f2edcd762565f1933a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c2748211565773c297560f2edcd762565f1933a/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91aa82174531ef408c81325e0d31b508c1f26e0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/91aa82174531ef408c81325e0d31b508c1f26e0b", "html_url": "https://github.com/rust-lang/rust/commit/91aa82174531ef408c81325e0d31b508c1f26e0b"}], "stats": {"total": 4042, "additions": 2552, "deletions": 1490}, "files": [{"sha": "41af8e190ddf3581503dc5cd0b902f68cb1e0f20", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -2493,6 +2493,7 @@ Released 2018-09-13\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or\n [`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n+[`manual_str_repeat`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`manual_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_unwrap_or\n@@ -2622,6 +2623,7 @@ Released 2018-09-13\n [`redundant_pub_crate`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pub_crate\n [`redundant_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_slicing\n [`redundant_static_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_static_lifetimes\n+[`ref_binding_to_reference`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_binding_to_reference\n [`ref_in_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_in_deref\n [`ref_option_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_option_ref\n [`regex_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#regex_macro\n@@ -2670,6 +2672,7 @@ Released 2018-09-13\n [`suspicious_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_map\n [`suspicious_op_assign_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_op_assign_impl\n [`suspicious_operation_groupings`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_operation_groupings\n+[`suspicious_splitn`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_splitn\n [`suspicious_unary_op_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_unary_op_formatting\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment"}, {"sha": "238c919b69d6b41522f43178381aba48be058e6e", "filename": "COPYRIGHT", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-Copyright 2014-2020 The Rust Project Developers\n+Copyright 2014-2021 The Rust Project Developers\n \n Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n http://www.apache.org/licenses/LICENSE-2.0> or the MIT license"}, {"sha": "b003b15a11d750553db593179b658ae375bf6464", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -33,12 +33,13 @@ tempfile = { version = \"3.1.0\", optional = true }\n cargo_metadata = \"0.12\"\n compiletest_rs = { version = \"0.6.0\", features = [\"tmp\"] }\n tester = \"0.9\"\n-clippy-mini-macro-test = { version = \"0.2\", path = \"mini-macro\" }\n serde = { version = \"1.0\", features = [\"derive\"] }\n derive-new = \"0.5\"\n regex = \"1.4\"\n quote = \"1\"\n syn = { version = \"1\", features = [\"full\"] }\n+# This is used by the `collect-metadata` alias.\n+filetime = \"0.2\"\n \n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`"}, {"sha": "04169a42b8be8337d55f7732e7ff26fd9b7032b1", "filename": "LICENSE-APACHE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/LICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/LICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSE-APACHE?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -186,7 +186,7 @@ APPENDIX: How to apply the Apache License to your work.\n    same \"printed page\" as the copyright notice for easier\n    identification within third-party archives.\n \n-Copyright 2014-2020 The Rust Project Developers\n+Copyright 2014-2021 The Rust Project Developers\n \n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License."}, {"sha": "90a2d3950d19b07323204ca4b3a1dedcb608a89f", "filename": "LICENSE-MIT", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/LICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/LICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSE-MIT?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,6 +1,6 @@\n MIT License\n \n-Copyright (c) 2014-2020 The Rust Project Developers\n+Copyright (c) 2014-2021 The Rust Project Developers\n \n Permission is hereby granted, free of charge, to any\n person obtaining a copy of this software and associated"}, {"sha": "6c556f579ca4f96cdc9e984663d2a3af00e8c364", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -147,6 +147,7 @@ Some lints can be configured in a TOML file named `clippy.toml` or `.clippy.toml\n value` mapping eg.\n \n ```toml\n+avoid-breaking-exported-api = false\n blacklisted-names = [\"toto\", \"tata\", \"titi\"]\n cognitive-complexity-threshold = 30\n ```\n@@ -236,7 +237,7 @@ If you want to contribute to Clippy, you can find more information in [CONTRIBUT\n \n ## License\n \n-Copyright 2014-2020 The Rust Project Developers\n+Copyright 2014-2021 The Rust Project Developers\n \n Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n [https://www.apache.org/licenses/LICENSE-2.0](https://www.apache.org/licenses/LICENSE-2.0)> or the MIT license"}, {"sha": "b5484bec3c8b8dca5dc0a00930d846e60533d4a7", "filename": "build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -14,6 +14,6 @@ fn main() {\n     );\n     println!(\n         \"cargo:rustc-env=RUSTC_RELEASE_CHANNEL={}\",\n-        rustc_tools_util::get_channel().unwrap_or_default()\n+        rustc_tools_util::get_channel()\n     );\n }"}, {"sha": "cda8d17eed44c7cdb9e9fc1609d90e71a146fdfa", "filename": "clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy.toml?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1 @@\n+avoid-breaking-exported-api = false"}, {"sha": "49d4350123f4bac9b61f43bc4eff71b25e2dc913", "filename": "clippy_lints/src/absurd_extreme_comparisons.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -3,9 +3,8 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n-use crate::consts::{constant, Constant};\n-\n use clippy_utils::comparisons::{normalize_comparison, Rel};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_isize_or_usize;"}, {"sha": "24c2a9728111f2c7d8a484c9abec9570a3497742", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::constant_simple;\n+use clippy_utils::consts::constant_simple;\n use clippy_utils::diagnostics::span_lint;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};"}, {"sha": "5235b2642d18c3236d1ba10629f5dec4d12a0fad", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call};\n@@ -63,7 +63,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n                 &format!(\"`assert!(false, {})` should probably be replaced\", panic_message),\n                 None,\n                 &format!(\"use `panic!({})` or `unreachable!({})`\", panic_message, panic_message),\n-            )\n+            );\n         };\n \n         if let Some(debug_assert_span) = is_expn_of(e.span, \"debug_assert\") {"}, {"sha": "932cd58bf6259c5783ac210af6814232a746913b", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -273,7 +273,7 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n         if is_relevant_item(cx, item) {\n-            check_attrs(cx, item.span, item.ident.name, attrs)\n+            check_attrs(cx, item.span, item.ident.name, attrs);\n         }\n         match item.kind {\n             ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n@@ -343,13 +343,13 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if is_relevant_impl(cx, item) {\n-            check_attrs(cx, item.span, item.ident.name, cx.tcx.hir().attrs(item.hir_id()))\n+            check_attrs(cx, item.span, item.ident.name, cx.tcx.hir().attrs(item.hir_id()));\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n         if is_relevant_trait(cx, item) {\n-            check_attrs(cx, item.span, item.ident.name, cx.tcx.hir().attrs(item.hir_id()))\n+            check_attrs(cx, item.span, item.ident.name, cx.tcx.hir().attrs(item.hir_id()));\n         }\n     }\n }"}, {"sha": "991ed94572c7e87172d883de71502a0178f22049", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n@@ -115,9 +115,9 @@ impl<'tcx> LateLintPass<'tcx> for BitMask {\n         if let ExprKind::Binary(cmp, left, right) = &e.kind {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n-                    check_compare(cx, left, cmp.node, cmp_opt, e.span)\n+                    check_compare(cx, left, cmp.node, cmp_opt, e.span);\n                 } else if let Some(cmp_val) = fetch_int_literal(cx, left) {\n-                    check_compare(cx, right, invert_cmp(cmp.node), cmp_val, e.span)\n+                    check_compare(cx, right, invert_cmp(cmp.node), cmp_val, e.span);\n                 }\n             }\n         }\n@@ -171,7 +171,7 @@ fn check_compare(cx: &LateContext<'_>, bit_op: &Expr<'_>, cmp_op: BinOpKind, cmp\n         }\n         fetch_int_literal(cx, right)\n             .or_else(|| fetch_int_literal(cx, left))\n-            .map_or((), |mask| check_bit_mask(cx, op.node, cmp_op, mask, cmp_value, span))\n+            .map_or((), |mask| check_bit_mask(cx, op.node, cmp_op, mask, cmp_value, span));\n     }\n }\n "}, {"sha": "e72399af232b5f399cfe283126ac528383626fc2", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for NonminimalBool {\n         _: Span,\n         _: HirId,\n     ) {\n-        NonminimalBoolVisitor { cx }.visit_body(body)\n+        NonminimalBoolVisitor { cx }.visit_body(body);\n     }\n }\n \n@@ -184,7 +184,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                 Term(n) => {\n                     let terminal = self.terminals[n as usize];\n                     if let Some(str) = simplify_not(self.cx, terminal) {\n-                        self.output.push_str(&str)\n+                        self.output.push_str(&str);\n                     } else {\n                         self.output.push('!');\n                         let snip = snippet_opt(self.cx, terminal.span)?;\n@@ -452,7 +452,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n         }\n         match &e.kind {\n             ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => {\n-                self.bool_expr(e)\n+                self.bool_expr(e);\n             },\n             ExprKind::Unary(UnOp::Not, inner) => {\n                 if self.cx.typeck_results().node_types()[inner.hir_id].is_bool() {"}, {"sha": "c9c111a2847af31f2d568b65b7ff30d7f36e92a0", "filename": "clippy_lints/src/casts/cast_sign_loss.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::{method_chain_args, sext};\n use if_chain::if_chain;"}, {"sha": "6e9507382390893306eac97b90bf159286d93a52", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -92,7 +92,7 @@ declare_lint_pass!(CollapsibleIf => [COLLAPSIBLE_IF, COLLAPSIBLE_ELSE_IF]);\n impl EarlyLintPass for CollapsibleIf {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         if !expr.span.from_expansion() {\n-            check_if(cx, expr)\n+            check_if(cx, expr);\n         }\n     }\n }"}, {"sha": "b6999bef6e72657f5c0a13a6799dc13864c3f469", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n             \"`if` chain can be rewritten with `match`\",\n             None,\n             \"consider rewriting the `if` chain to use `cmp` and `match`\",\n-        )\n+        );\n     }\n }\n "}, {"sha": "7e87f53e3fba7d2a7c8b739689d9dc416b77810e", "filename": "clippy_lints/src/consts.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91aa82174531ef408c81325e0d31b508c1f26e0b/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91aa82174531ef408c81325e0d31b508c1f26e0b/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=91aa82174531ef408c81325e0d31b508c1f26e0b", "patch": "@@ -1 +0,0 @@\n-pub use clippy_utils::consts::*;"}, {"sha": "376a14b8181ff6eb739fbb6f9040f377949246c1", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -476,7 +476,7 @@ fn emit_branches_sharing_code_lint(\n         }\n \n         suggestions.push((\"end\", span, suggestion.to_string()));\n-        add_expr_note = !cx.typeck_results().expr_ty(if_expr).is_unit()\n+        add_expr_note = !cx.typeck_results().expr_ty(if_expr).is_unit();\n     }\n \n     let add_optional_msgs = |diag: &mut DiagnosticBuilder<'_>| {"}, {"sha": "759f7d4062d448ba64e3218b6435c65841fb864a", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -181,9 +181,9 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n         match stmt.kind {\n             StmtKind::Local(local) => {\n                 if local.ty.is_some() {\n-                    self.ty_bounds.push(TyBound::Any)\n+                    self.ty_bounds.push(TyBound::Any);\n                 } else {\n-                    self.ty_bounds.push(TyBound::Nothing)\n+                    self.ty_bounds.push(TyBound::Nothing);\n                 }\n             },\n "}, {"sha": "04f3d77464f98aa764a9549279bbb9d0e63c741c", "filename": "clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -141,3 +141,22 @@ declare_deprecated_lint! {\n     pub FILTER_MAP,\n     \"this lint has been replaced by `manual_filter_map`, a more specific lint\"\n }\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** The `avoid_breaking_exported_api` config option was added, which\n+    /// enables the `enum_variant_names` lint for public items.\n+    /// ```\n+    pub PUB_ENUM_VARIANT_NAMES,\n+    \"set the `avoid_breaking_exported_api` config option to `false` to enable the `enum_variant_names` lint for public items\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** The `avoid_breaking_exported_api` config option was added, which\n+    /// enables the `wrong_self_conversion` lint for public items.\n+    pub WRONG_PUB_SELF_CONVENTION,\n+    \"set the `avoid_breaking_exported_api` config option to `false` to enable the `wrong_self_convention` lint for public items\"\n+}"}, {"sha": "4966638cb1b96b7353658f1a6636acf687c8fbc6", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -70,16 +70,16 @@ impl<'tcx> DoubleComparisons {\n         #[rustfmt::skip]\n         match (op, lkind, rkind) {\n             (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Lt) | (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Eq) => {\n-                lint_double_comparison!(<=)\n+                lint_double_comparison!(<=);\n             },\n             (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Eq) => {\n-                lint_double_comparison!(>=)\n+                lint_double_comparison!(>=);\n             },\n             (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Lt) => {\n-                lint_double_comparison!(!=)\n+                lint_double_comparison!(!=);\n             },\n             (BinOpKind::And, BinOpKind::Le, BinOpKind::Ge) | (BinOpKind::And, BinOpKind::Ge, BinOpKind::Le) => {\n-                lint_double_comparison!(==)\n+                lint_double_comparison!(==);\n             },\n             _ => (),\n         };"}, {"sha": "94b09bf717372532cafa2f35e6a3e96e2cd6cacf", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -7,7 +7,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n \n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::paths;\n "}, {"sha": "2eb8b1422ed8a4292091f41d526a5f7a21f2f963", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -469,7 +469,7 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n                     let mut is_map_used = self.is_map_used;\n                     for arm in arms {\n                         if let Some(Guard::If(guard) | Guard::IfLet(_, guard)) = arm.guard {\n-                            self.visit_non_tail_expr(guard)\n+                            self.visit_non_tail_expr(guard);\n                         }\n                         is_map_used |= self.visit_cond_arm(arm.body);\n                     }"}, {"sha": "021136ac5e019d8bd1dfe54ffc7195b07fad49db", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,7 +1,7 @@\n //! lint on C-like enums that are `repr(isize/usize)` and have values that\n //! don't fit into an `i32`\n \n-use crate::consts::{miri_to_const, Constant};\n+use clippy_utils::consts::{miri_to_const, Constant};\n use clippy_utils::diagnostics::span_lint;\n use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};"}, {"sha": "b1a105a51c106974b39710be3b241142cd30991f", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 29, "deletions": 51, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -3,8 +3,8 @@\n use clippy_utils::camel_case;\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::source::is_present_in_source;\n-use rustc_ast::ast::{EnumDef, Item, ItemKind, VisibilityKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass, Lint};\n+use rustc_hir::{EnumDef, Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n@@ -39,36 +39,6 @@ declare_clippy_lint! {\n     \"enums where all variants share a prefix/postfix\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Detects public enumeration variants that are\n-    /// prefixed or suffixed by the same characters.\n-    ///\n-    /// **Why is this bad?** Public enumeration variant names should specify their variant,\n-    /// not repeat the enumeration name.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// pub enum Cake {\n-    ///     BlackForestCake,\n-    ///     HummingbirdCake,\n-    ///     BattenbergCake,\n-    /// }\n-    /// ```\n-    /// Could be written as:\n-    /// ```rust\n-    /// pub enum Cake {\n-    ///     BlackForest,\n-    ///     Hummingbird,\n-    ///     Battenberg,\n-    /// }\n-    /// ```\n-    pub PUB_ENUM_VARIANT_NAMES,\n-    pedantic,\n-    \"public enums where all variants share a prefix/postfix\"\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Detects type names that are prefixed or suffixed by the\n     /// containing module's name.\n@@ -127,21 +97,22 @@ declare_clippy_lint! {\n pub struct EnumVariantNames {\n     modules: Vec<(Symbol, String)>,\n     threshold: u64,\n+    avoid_breaking_exported_api: bool,\n }\n \n impl EnumVariantNames {\n     #[must_use]\n-    pub fn new(threshold: u64) -> Self {\n+    pub fn new(threshold: u64, avoid_breaking_exported_api: bool) -> Self {\n         Self {\n             modules: Vec::new(),\n             threshold,\n+            avoid_breaking_exported_api,\n         }\n     }\n }\n \n impl_lint_pass!(EnumVariantNames => [\n     ENUM_VARIANT_NAMES,\n-    PUB_ENUM_VARIANT_NAMES,\n     MODULE_NAME_REPETITIONS,\n     MODULE_INCEPTION\n ]);\n@@ -167,33 +138,42 @@ fn partial_rmatch(post: &str, name: &str) -> usize {\n }\n \n fn check_variant(\n-    cx: &EarlyContext<'_>,\n+    cx: &LateContext<'_>,\n     threshold: u64,\n-    def: &EnumDef,\n+    def: &EnumDef<'_>,\n     item_name: &str,\n     item_name_chars: usize,\n     span: Span,\n-    lint: &'static Lint,\n ) {\n     if (def.variants.len() as u64) < threshold {\n         return;\n     }\n-    for var in &def.variants {\n+    for var in def.variants {\n         let name = var.ident.name.as_str();\n         if partial_match(item_name, &name) == item_name_chars\n             && name.chars().nth(item_name_chars).map_or(false, |c| !c.is_lowercase())\n             && name.chars().nth(item_name_chars + 1).map_or(false, |c| !c.is_numeric())\n         {\n-            span_lint(cx, lint, var.span, \"variant name starts with the enum's name\");\n+            span_lint(\n+                cx,\n+                ENUM_VARIANT_NAMES,\n+                var.span,\n+                \"variant name starts with the enum's name\",\n+            );\n         }\n         if partial_rmatch(item_name, &name) == item_name_chars {\n-            span_lint(cx, lint, var.span, \"variant name ends with the enum's name\");\n+            span_lint(\n+                cx,\n+                ENUM_VARIANT_NAMES,\n+                var.span,\n+                \"variant name ends with the enum's name\",\n+            );\n         }\n     }\n     let first = &def.variants[0].ident.name.as_str();\n     let mut pre = &first[..camel_case::until(&*first)];\n     let mut post = &first[camel_case::from(&*first)..];\n-    for var in &def.variants {\n+    for var in def.variants {\n         let name = var.ident.name.as_str();\n \n         let pre_match = partial_match(pre, &name);\n@@ -226,7 +206,7 @@ fn check_variant(\n     };\n     span_lint_and_help(\n         cx,\n-        lint,\n+        ENUM_VARIANT_NAMES,\n         span,\n         &format!(\"all variants have the same {}fix: `{}`\", what, value),\n         None,\n@@ -261,14 +241,14 @@ fn to_camel_case(item_name: &str) -> String {\n     s\n }\n \n-impl EarlyLintPass for EnumVariantNames {\n-    fn check_item_post(&mut self, _cx: &EarlyContext<'_>, _item: &Item) {\n+impl LateLintPass<'_> for EnumVariantNames {\n+    fn check_item_post(&mut self, _cx: &LateContext<'_>, _item: &Item<'_>) {\n         let last = self.modules.pop();\n         assert!(last.is_some());\n     }\n \n     #[allow(clippy::similar_names)]\n-    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         let item_name = item.ident.name.as_str();\n         let item_name_chars = item_name.chars().count();\n         let item_camel = to_camel_case(&item_name);\n@@ -286,7 +266,7 @@ impl EarlyLintPass for EnumVariantNames {\n                             );\n                         }\n                     }\n-                    if item.vis.kind.is_pub() {\n+                    if item.vis.node.is_pub() {\n                         let matching = partial_match(mod_camel, &item_camel);\n                         let rmatching = partial_rmatch(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();\n@@ -317,11 +297,9 @@ impl EarlyLintPass for EnumVariantNames {\n             }\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n-            let lint = match item.vis.kind {\n-                VisibilityKind::Public => PUB_ENUM_VARIANT_NAMES,\n-                _ => ENUM_VARIANT_NAMES,\n-            };\n-            check_variant(cx, self.threshold, def, &item_name, item_name_chars, item.span, lint);\n+            if !(self.avoid_breaking_exported_api && cx.access_levels.is_exported(item.hir_id())) {\n+                check_variant(cx, self.threshold, def, &item_name, item_name_chars, item.span);\n+            }\n         }\n         self.modules.push((item.ident.name, item_camel));\n     }"}, {"sha": "a3a8e748d99a0f5a261f3bf8806c3063607cd50b", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -156,7 +156,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                                         vec![(left.span, lsnip), (right.span, rsnip)],\n                                     );\n                                 },\n-                            )\n+                            );\n                         } else if lcpy\n                             && !rcpy\n                             && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n@@ -175,7 +175,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                                         Applicability::MaybeIncorrect, // FIXME #2597\n                                     );\n                                 },\n-                            )\n+                            );\n                         } else if !lcpy\n                             && rcpy\n                             && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n@@ -194,7 +194,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                                         Applicability::MaybeIncorrect, // FIXME #2597\n                                     );\n                                 },\n-                            )\n+                            );\n                         }\n                     },\n                     // &foo == bar\n@@ -218,7 +218,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                                         Applicability::MaybeIncorrect, // FIXME #2597\n                                     );\n                                 },\n-                            )\n+                            );\n                         }\n                     },\n                     // foo == &bar\n@@ -236,7 +236,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                                     rsnip,\n                                     Applicability::MaybeIncorrect, // FIXME #2597\n                                 );\n-                            })\n+                            });\n                         }\n                     },\n                     _ => {},"}, {"sha": "4aa9c25b1b0b0586ab623cb654d025ef476158c4", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,11 +1,10 @@\n+use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-use crate::consts::{constant_simple, Constant};\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for erasing operations, e.g., `x * 0`.\n     ///"}, {"sha": "8d066f305ee85e44b8dab91d14b04516fe195f87", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n                 for arg in args {\n                     // skip `foo(macro!())`\n                     if arg.span.ctxt() == expr.span.ctxt() {\n-                        check_closure(cx, arg)\n+                        check_closure(cx, arg);\n                     }\n                 }\n             },\n@@ -92,17 +92,19 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         let ex = &body.value;\n \n         if ex.span.ctxt() != expr.span.ctxt() {\n-            if let Some(VecArgs::Vec(&[])) = higher::vec_macro(cx, ex) {\n-                // replace `|| vec![]` with `Vec::new`\n-                span_lint_and_sugg(\n-                    cx,\n-                    REDUNDANT_CLOSURE,\n-                    expr.span,\n-                    \"redundant closure\",\n-                    \"replace the closure with `Vec::new`\",\n-                    \"std::vec::Vec::new\".into(),\n-                    Applicability::MachineApplicable,\n-                );\n+            if decl.inputs.is_empty() {\n+                if let Some(VecArgs::Vec(&[])) = higher::vec_macro(cx, ex) {\n+                    // replace `|| vec![]` with `Vec::new`\n+                    span_lint_and_sugg(\n+                        cx,\n+                        REDUNDANT_CLOSURE,\n+                        expr.span,\n+                        \"redundant closure\",\n+                        \"replace the closure with `Vec::new`\",\n+                        \"std::vec::Vec::new\".into(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n             }\n             // skip `foo(|| macro!())`\n             return;\n@@ -188,9 +190,10 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_a\n     cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n         //a type may implicitly implement other type's methods (e.g. Deref)\n         if match_types(expected_type_of_self, actual_type_of_self) {\n-            return Some(get_type_name(cx, actual_type_of_self));\n+            Some(get_type_name(cx, actual_type_of_self))\n+        } else {\n+            None\n         }\n-        None\n     })\n }\n "}, {"sha": "5fdf5bc9e9d118d366f2a2ebaeafb8767a1fb40b", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n                 self.visit_expr(e);\n                 for arm in arms {\n                     if let Some(Guard::If(if_expr)) = arm.guard {\n-                        self.visit_expr(if_expr)\n+                        self.visit_expr(if_expr);\n                     }\n                     // make sure top level arm expressions aren't linted\n                     self.maybe_walk_expr(&*arm.body);"}, {"sha": "e38384b01d4147e245cbea30d64b1d7ef3f067e6", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{\n+use clippy_utils::consts::{\n     constant, constant_simple, Constant,\n     Constant::{Int, F32, F64},\n };"}, {"sha": "7f4fb68cf2f6f16be8c4725809ad3c8ad05ae3d9", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -240,7 +240,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                 }\n             },\n             Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target) => {\n-                self.mutates_static |= is_mutated_static(target)\n+                self.mutates_static |= is_mutated_static(target);\n             },\n             _ => {},\n         }"}, {"sha": "af759a48e10ca117d2f41aa62732df586d0b0723", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n                     self.cx,\n                     NOT_UNSAFE_PTR_ARG_DEREF,\n                     ptr.span,\n-                    \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n+                    \"this public function might dereference a raw pointer but is not marked `unsafe`\",\n                 );\n             }\n         }"}, {"sha": "a666fee1a4ad507a7f1d74dde33fb2d708c44948", "filename": "clippy_lints/src/functions/too_many_lines.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -4,7 +4,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_span::Span;\n \n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::snippet_opt;\n \n use super::TOO_MANY_LINES;\n \n@@ -13,15 +13,25 @@ pub(super) fn check_fn(cx: &LateContext<'_>, span: Span, body: &'tcx hir::Body<'\n         return;\n     }\n \n-    let code_snippet = snippet(cx, body.value.span, \"..\");\n+    let code_snippet = match snippet_opt(cx, body.value.span) {\n+        Some(s) => s,\n+        _ => return,\n+    };\n     let mut line_count: u64 = 0;\n     let mut in_comment = false;\n     let mut code_in_line;\n \n-    // Skip the surrounding function decl.\n-    let start_brace_idx = code_snippet.find('{').map_or(0, |i| i + 1);\n-    let end_brace_idx = code_snippet.rfind('}').unwrap_or_else(|| code_snippet.len());\n-    let function_lines = code_snippet[start_brace_idx..end_brace_idx].lines();\n+    let function_lines = if matches!(body.value.kind, hir::ExprKind::Block(..))\n+        && code_snippet.as_bytes().first().copied() == Some(b'{')\n+        && code_snippet.as_bytes().last().copied() == Some(b'}')\n+    {\n+        // Removing the braces from the enclosing block\n+        &code_snippet[1..code_snippet.len() - 1]\n+    } else {\n+        &code_snippet\n+    }\n+    .trim() // Remove leading and trailing blank lines\n+    .lines();\n \n     for mut line in function_lines {\n         code_in_line = false;\n@@ -63,6 +73,6 @@ pub(super) fn check_fn(cx: &LateContext<'_>, span: Span, body: &'tcx hir::Body<'\n                 \"this function has too many lines ({}/{})\",\n                 line_count, too_many_lines_threshold\n             ),\n-        )\n+        );\n     }\n }"}, {"sha": "515b8887453b92a0d49cebab5f245a4c3d8a4a4b", "filename": "clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -102,7 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                                         ));\n                                     }\n                                 }\n-                            })\n+                            });\n                         },\n                     );\n                 }"}, {"sha": "99c461930e4c1eaa69ab965219f5d922a07f02b4", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-use crate::consts::{constant_simple, Constant};\n+use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::{clip, unsext};\n "}, {"sha": "f2f830ca5c09e51a6dec78fd166f515801d8c377", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -67,7 +67,7 @@ fn lint_break(cx: &LateContext<'_>, break_span: Span, expr_span: Span) {\n         \"change `break` to `return` as shown\",\n         format!(\"return {}\", snip),\n         app,\n-    )\n+    );\n }\n \n #[derive(Clone, Copy, PartialEq, Eq)]"}, {"sha": "bfa284f333a1ad922a28d38f74a7bb58225411d1", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,6 +1,6 @@\n //! lint on indexing and slicing operations\n \n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::higher;\n use rustc_ast::ast::RangeLimits;"}, {"sha": "6b887da263034267fd85ebe355b2c177dacc79f4", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for InfiniteIter {\n                 return;\n             },\n         };\n-        span_lint(cx, lint, expr.span, msg)\n+        span_lint(cx, lint, expr.span, msg);\n     }\n }\n "}, {"sha": "37011f5578dc84a9eeae50e35133f0c4d95544bf", "filename": "clippy_lints/src/invalid_upcast_comparisons.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -7,9 +7,8 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n use rustc_target::abi::LayoutOf;\n \n-use crate::consts::{constant, Constant};\n-\n use clippy_utils::comparisons::Rel;\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::source::snippet;\n use clippy_utils::{comparisons, sext};\n@@ -177,7 +176,7 @@ fn upcast_comparison_bounds_err<'tcx>(\n                 },\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n-                err_upcast_comparison(cx, span, lhs, true)\n+                err_upcast_comparison(cx, span, lhs, true);\n             } else if match rel {\n                 Rel::Lt => {\n                     if invert {\n@@ -195,7 +194,7 @@ fn upcast_comparison_bounds_err<'tcx>(\n                 },\n                 Rel::Eq | Rel::Ne => unreachable!(),\n             } {\n-                err_upcast_comparison(cx, span, lhs, false)\n+                err_upcast_comparison(cx, span, lhs, false);\n             }\n         }\n     }"}, {"sha": "583514b22f9bf65a01897fa38618d25d910913be", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -380,9 +380,9 @@ fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>\n             }\n         }\n \n-        check_len(cx, span, method_path.ident.name, args, &lit.node, op, compare_to)\n+        check_len(cx, span, method_path.ident.name, args, &lit.node, op, compare_to);\n     } else {\n-        check_empty_expr(cx, span, method, lit, op)\n+        check_empty_expr(cx, span, method, lit, op);\n     }\n }\n "}, {"sha": "e627b1385bc7dd4ebcb1bba97a9426db413334bd", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -135,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         None,\n                         \"consider using an underscore-prefixed named \\\n                             binding or dropping explicitly with `std::mem::drop`\"\n-                    )\n+                    );\n                 } else if init_ty.needs_drop(cx.tcx, cx.param_env) {\n                     span_lint_and_help(\n                         cx,\n@@ -145,7 +145,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         None,\n                         \"consider using an underscore-prefixed named \\\n                             binding or dropping explicitly with `std::mem::drop`\"\n-                    )\n+                    );\n                 } else if is_must_use_ty(cx, cx.typeck_results().expr_ty(init)) {\n                     span_lint_and_help(\n                         cx,\n@@ -154,7 +154,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         \"non-binding let on an expression with `#[must_use]` type\",\n                         None,\n                         \"consider explicitly using expression value\"\n-                    )\n+                    );\n                 } else if is_must_use_func_call(cx, init) {\n                     span_lint_and_help(\n                         cx,\n@@ -163,7 +163,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         \"non-binding let on a result of a `#[must_use]` function\",\n                         None,\n                         \"consider explicitly using function result\"\n-                    )\n+                    );\n                 }\n             }\n         }"}, {"sha": "e7dd3952b3ac96b19bf7aae3ad288730663deb2f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 499, "deletions": 506, "changes": 1005, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -41,6 +41,9 @@ extern crate rustc_target;\n extern crate rustc_trait_selection;\n extern crate rustc_typeck;\n \n+#[macro_use]\n+extern crate clippy_utils;\n+\n use clippy_utils::parse_msrv;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_lint::LintId;\n@@ -145,25 +148,9 @@ macro_rules! declare_clippy_lint {\n     };\n }\n \n-#[macro_export]\n-macro_rules! sym {\n-    ( $($x:tt)* ) => { clippy_utils::sym!($($x)*) }\n-}\n-\n-#[macro_export]\n-macro_rules! unwrap_cargo_metadata {\n-    ( $($x:tt)* ) => { clippy_utils::unwrap_cargo_metadata!($($x)*) }\n-}\n-\n-macro_rules! extract_msrv_attr {\n-    ( $($x:tt)* ) => { clippy_utils::extract_msrv_attr!($($x)*); }\n-}\n-\n-mod consts;\n-#[macro_use]\n-mod utils;\n #[cfg(feature = \"metadata-collector-lint\")]\n mod deprecated_lints;\n+mod utils;\n \n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n mod absurd_extreme_comparisons;\n@@ -405,7 +392,6 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore) {\n \n #[doc(hidden)]\n pub fn read_conf(sess: &Session) -> Conf {\n-    use std::path::Path;\n     let file_name = match utils::conf::lookup_conf_file() {\n         Ok(Some(path)) => path,\n         Ok(None) => return Conf::default(),\n@@ -416,16 +402,6 @@ pub fn read_conf(sess: &Session) -> Conf {\n         },\n     };\n \n-    let file_name = if file_name.is_relative() {\n-        sess.local_crate_source_file\n-            .as_deref()\n-            .and_then(Path::parent)\n-            .unwrap_or_else(|| Path::new(\"\"))\n-            .join(file_name)\n-    } else {\n-        file_name\n-    };\n-\n     let TryConf { conf, errors } = utils::conf::read(&file_name);\n     // all conf errors are non-fatal, we just use the default conf in case of error\n     for error in errors {\n@@ -505,6 +481,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         \"clippy::filter_map\",\n         \"this lint has been replaced by `manual_filter_map`, a more specific lint\",\n     );\n+    store.register_removed(\n+        \"clippy::pub_enum_variant_names\",\n+        \"set the `avoid_breaking_exported_api` config option to `false` to enable the `enum_variant_names` lint for public items\",\n+    );\n+    store.register_removed(\n+        \"clippy::wrong_pub_self_convention\",\n+        \"set the `avoid_breaking_exported_api` config option to `false` to enable the `wrong_self_convention` lint for public items\",\n+    );\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n     // begin register lints, do not remove this comment, it\u2019s used in `update_lints`\n@@ -618,7 +602,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         enum_variants::ENUM_VARIANT_NAMES,\n         enum_variants::MODULE_INCEPTION,\n         enum_variants::MODULE_NAME_REPETITIONS,\n-        enum_variants::PUB_ENUM_VARIANT_NAMES,\n         eq_op::EQ_OP,\n         eq_op::OP_REF,\n         erasing_op::ERASING_OP,\n@@ -779,6 +762,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::MANUAL_FILTER_MAP,\n         methods::MANUAL_FIND_MAP,\n         methods::MANUAL_SATURATING_ARITHMETIC,\n+        methods::MANUAL_STR_REPEAT,\n         methods::MAP_COLLECT_RESULT_UNIT,\n         methods::MAP_FLATTEN,\n         methods::MAP_UNWRAP_OR,\n@@ -796,13 +780,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::SKIP_WHILE_NEXT,\n         methods::STRING_EXTEND_CHARS,\n         methods::SUSPICIOUS_MAP,\n+        methods::SUSPICIOUS_SPLITN,\n         methods::UNINIT_ASSUMED_INIT,\n         methods::UNNECESSARY_FILTER_MAP,\n         methods::UNNECESSARY_FOLD,\n         methods::UNNECESSARY_LAZY_EVALUATIONS,\n         methods::UNWRAP_USED,\n         methods::USELESS_ASREF,\n-        methods::WRONG_PUB_SELF_CONVENTION,\n         methods::WRONG_SELF_CONVENTION,\n         methods::ZST_OFFSET,\n         minmax::MIN_MAX,\n@@ -841,6 +825,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         needless_bool::BOOL_COMPARISON,\n         needless_bool::NEEDLESS_BOOL,\n         needless_borrow::NEEDLESS_BORROW,\n+        needless_borrow::REF_BINDING_TO_REFERENCE,\n         needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n         needless_continue::NEEDLESS_CONTINUE,\n         needless_for_each::NEEDLESS_FOR_EACH,\n@@ -995,457 +980,171 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n \n-    // all the internal lints\n-    #[cfg(feature = \"internal-lints\")]\n-    {\n-        store.register_early_pass(|| box utils::internal_lints::ClippyLintsInternal);\n-        store.register_early_pass(|| box utils::internal_lints::ProduceIce);\n-        store.register_late_pass(|| box utils::inspector::DeepCodeInspector);\n-        store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n-        store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n-        store.register_late_pass(|| box utils::internal_lints::IfChainStyle);\n-        store.register_late_pass(|| box utils::internal_lints::InvalidPaths);\n-        store.register_late_pass(|| box utils::internal_lints::InterningDefinedSymbol::default());\n-        store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n-        store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n-        store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n-    }\n-    #[cfg(feature = \"metadata-collector-lint\")]\n-    {\n-        if std::env::var(\"ENABLE_METADATA_COLLECTION\").eq(&Ok(\"1\".to_string())) {\n-            store.register_late_pass(|| box utils::internal_lints::metadata_collector::MetadataCollector::new());\n-        }\n-    }\n+    store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n+        LintId::of(arithmetic::FLOAT_ARITHMETIC),\n+        LintId::of(arithmetic::INTEGER_ARITHMETIC),\n+        LintId::of(as_conversions::AS_CONVERSIONS),\n+        LintId::of(asm_syntax::INLINE_ASM_X86_ATT_SYNTAX),\n+        LintId::of(asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n+        LintId::of(create_dir::CREATE_DIR),\n+        LintId::of(dbg_macro::DBG_MACRO),\n+        LintId::of(default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK),\n+        LintId::of(else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n+        LintId::of(exhaustive_items::EXHAUSTIVE_ENUMS),\n+        LintId::of(exhaustive_items::EXHAUSTIVE_STRUCTS),\n+        LintId::of(exit::EXIT),\n+        LintId::of(float_literal::LOSSY_FLOAT_LITERAL),\n+        LintId::of(if_then_some_else_none::IF_THEN_SOME_ELSE_NONE),\n+        LintId::of(implicit_return::IMPLICIT_RETURN),\n+        LintId::of(indexing_slicing::INDEXING_SLICING),\n+        LintId::of(inherent_impl::MULTIPLE_INHERENT_IMPL),\n+        LintId::of(integer_division::INTEGER_DIVISION),\n+        LintId::of(let_underscore::LET_UNDERSCORE_MUST_USE),\n+        LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n+        LintId::of(map_err_ignore::MAP_ERR_IGNORE),\n+        LintId::of(matches::REST_PAT_IN_FULLY_BOUND_STRUCTS),\n+        LintId::of(matches::WILDCARD_ENUM_MATCH_ARM),\n+        LintId::of(mem_forget::MEM_FORGET),\n+        LintId::of(methods::CLONE_ON_REF_PTR),\n+        LintId::of(methods::EXPECT_USED),\n+        LintId::of(methods::FILETYPE_IS_FILE),\n+        LintId::of(methods::GET_UNWRAP),\n+        LintId::of(methods::UNWRAP_USED),\n+        LintId::of(misc::FLOAT_CMP_CONST),\n+        LintId::of(misc_early::UNNEEDED_FIELD_PATTERN),\n+        LintId::of(missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS),\n+        LintId::of(missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS),\n+        LintId::of(modulo_arithmetic::MODULO_ARITHMETIC),\n+        LintId::of(panic_in_result_fn::PANIC_IN_RESULT_FN),\n+        LintId::of(panic_unimplemented::PANIC),\n+        LintId::of(panic_unimplemented::TODO),\n+        LintId::of(panic_unimplemented::UNIMPLEMENTED),\n+        LintId::of(panic_unimplemented::UNREACHABLE),\n+        LintId::of(pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n+        LintId::of(shadow::SHADOW_REUSE),\n+        LintId::of(shadow::SHADOW_SAME),\n+        LintId::of(strings::STRING_ADD),\n+        LintId::of(strings::STRING_TO_STRING),\n+        LintId::of(strings::STR_TO_STRING),\n+        LintId::of(types::RC_BUFFER),\n+        LintId::of(unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS),\n+        LintId::of(unwrap_in_result::UNWRAP_IN_RESULT),\n+        LintId::of(verbose_file_reads::VERBOSE_FILE_READS),\n+        LintId::of(write::PRINT_STDERR),\n+        LintId::of(write::PRINT_STDOUT),\n+        LintId::of(write::USE_DEBUG),\n+    ]);\n \n-    store.register_late_pass(|| box utils::author::Author);\n-    store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n-    store.register_late_pass(|| box serde_api::SerdeApi);\n-    let vec_box_size_threshold = conf.vec_box_size_threshold;\n-    let type_complexity_threshold = conf.type_complexity_threshold;\n-    store.register_late_pass(move || box types::Types::new(vec_box_size_threshold, type_complexity_threshold));\n-    store.register_late_pass(|| box booleans::NonminimalBool);\n-    store.register_late_pass(|| box needless_bitwise_bool::NeedlessBitwiseBool);\n-    store.register_late_pass(|| box eq_op::EqOp);\n-    store.register_late_pass(|| box enum_clike::UnportableVariant);\n-    store.register_late_pass(|| box float_literal::FloatLiteral);\n-    let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n-    store.register_late_pass(move || box bit_mask::BitMask::new(verbose_bit_mask_threshold));\n-    store.register_late_pass(|| box ptr::Ptr);\n-    store.register_late_pass(|| box ptr_eq::PtrEq);\n-    store.register_late_pass(|| box needless_bool::NeedlessBool);\n-    store.register_late_pass(|| box needless_bool::BoolComparison);\n-    store.register_late_pass(|| box needless_for_each::NeedlessForEach);\n-    store.register_late_pass(|| box approx_const::ApproxConstant);\n-    store.register_late_pass(|| box misc::MiscLints);\n-    store.register_late_pass(|| box eta_reduction::EtaReduction);\n-    store.register_late_pass(|| box identity_op::IdentityOp);\n-    store.register_late_pass(|| box erasing_op::ErasingOp);\n-    store.register_late_pass(|| box mut_mut::MutMut);\n-    store.register_late_pass(|| box mut_reference::UnnecessaryMutPassed);\n-    store.register_late_pass(|| box len_zero::LenZero);\n-    store.register_late_pass(|| box attrs::Attributes);\n-    store.register_late_pass(|| box blocks_in_if_conditions::BlocksInIfConditions);\n-    store.register_late_pass(|| box collapsible_match::CollapsibleMatch);\n-    store.register_late_pass(|| box unicode::Unicode);\n-    store.register_late_pass(|| box unit_return_expecting_ord::UnitReturnExpectingOrd);\n-    store.register_late_pass(|| box strings::StringAdd);\n-    store.register_late_pass(|| box implicit_return::ImplicitReturn);\n-    store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n-    store.register_late_pass(|| box default_numeric_fallback::DefaultNumericFallback);\n-    store.register_late_pass(|| box inconsistent_struct_constructor::InconsistentStructConstructor);\n-    store.register_late_pass(|| box non_octal_unix_permissions::NonOctalUnixPermissions);\n-    store.register_early_pass(|| box unnecessary_self_imports::UnnecessarySelfImports);\n+    store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n+        LintId::of(attrs::INLINE_ALWAYS),\n+        LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n+        LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n+        LintId::of(bit_mask::VERBOSE_BIT_MASK),\n+        LintId::of(bytecount::NAIVE_BYTECOUNT),\n+        LintId::of(case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n+        LintId::of(casts::CAST_LOSSLESS),\n+        LintId::of(casts::CAST_POSSIBLE_TRUNCATION),\n+        LintId::of(casts::CAST_POSSIBLE_WRAP),\n+        LintId::of(casts::CAST_PRECISION_LOSS),\n+        LintId::of(casts::CAST_PTR_ALIGNMENT),\n+        LintId::of(casts::CAST_SIGN_LOSS),\n+        LintId::of(casts::PTR_AS_PTR),\n+        LintId::of(checked_conversions::CHECKED_CONVERSIONS),\n+        LintId::of(copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n+        LintId::of(copy_iterator::COPY_ITERATOR),\n+        LintId::of(default::DEFAULT_TRAIT_ACCESS),\n+        LintId::of(dereference::EXPLICIT_DEREF_METHODS),\n+        LintId::of(derive::EXPL_IMPL_CLONE_ON_COPY),\n+        LintId::of(derive::UNSAFE_DERIVE_DESERIALIZE),\n+        LintId::of(doc::DOC_MARKDOWN),\n+        LintId::of(doc::MISSING_ERRORS_DOC),\n+        LintId::of(doc::MISSING_PANICS_DOC),\n+        LintId::of(empty_enum::EMPTY_ENUM),\n+        LintId::of(enum_variants::MODULE_NAME_REPETITIONS),\n+        LintId::of(eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS),\n+        LintId::of(excessive_bools::FN_PARAMS_EXCESSIVE_BOOLS),\n+        LintId::of(excessive_bools::STRUCT_EXCESSIVE_BOOLS),\n+        LintId::of(functions::MUST_USE_CANDIDATE),\n+        LintId::of(functions::TOO_MANY_LINES),\n+        LintId::of(if_not_else::IF_NOT_ELSE),\n+        LintId::of(implicit_hasher::IMPLICIT_HASHER),\n+        LintId::of(implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n+        LintId::of(inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR),\n+        LintId::of(infinite_iter::MAYBE_INFINITE_ITER),\n+        LintId::of(invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS),\n+        LintId::of(items_after_statements::ITEMS_AFTER_STATEMENTS),\n+        LintId::of(large_stack_arrays::LARGE_STACK_ARRAYS),\n+        LintId::of(let_underscore::LET_UNDERSCORE_DROP),\n+        LintId::of(literal_representation::LARGE_DIGIT_GROUPS),\n+        LintId::of(literal_representation::UNREADABLE_LITERAL),\n+        LintId::of(loops::EXPLICIT_INTO_ITER_LOOP),\n+        LintId::of(loops::EXPLICIT_ITER_LOOP),\n+        LintId::of(macro_use::MACRO_USE_IMPORTS),\n+        LintId::of(manual_ok_or::MANUAL_OK_OR),\n+        LintId::of(match_on_vec_items::MATCH_ON_VEC_ITEMS),\n+        LintId::of(matches::MATCH_BOOL),\n+        LintId::of(matches::MATCH_SAME_ARMS),\n+        LintId::of(matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n+        LintId::of(matches::MATCH_WILD_ERR_ARM),\n+        LintId::of(matches::SINGLE_MATCH_ELSE),\n+        LintId::of(methods::CLONED_INSTEAD_OF_COPIED),\n+        LintId::of(methods::FILTER_MAP_NEXT),\n+        LintId::of(methods::FLAT_MAP_OPTION),\n+        LintId::of(methods::IMPLICIT_CLONE),\n+        LintId::of(methods::INEFFICIENT_TO_STRING),\n+        LintId::of(methods::MAP_FLATTEN),\n+        LintId::of(methods::MAP_UNWRAP_OR),\n+        LintId::of(misc::USED_UNDERSCORE_BINDING),\n+        LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n+        LintId::of(mut_mut::MUT_MUT),\n+        LintId::of(needless_bitwise_bool::NEEDLESS_BITWISE_BOOL),\n+        LintId::of(needless_borrow::REF_BINDING_TO_REFERENCE),\n+        LintId::of(needless_continue::NEEDLESS_CONTINUE),\n+        LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n+        LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n+        LintId::of(non_expressive_names::SIMILAR_NAMES),\n+        LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n+        LintId::of(pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n+        LintId::of(pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n+        LintId::of(ranges::RANGE_MINUS_ONE),\n+        LintId::of(ranges::RANGE_PLUS_ONE),\n+        LintId::of(redundant_else::REDUNDANT_ELSE),\n+        LintId::of(ref_option_ref::REF_OPTION_REF),\n+        LintId::of(semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED),\n+        LintId::of(shadow::SHADOW_UNRELATED),\n+        LintId::of(strings::STRING_ADD_ASSIGN),\n+        LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n+        LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n+        LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n+        LintId::of(types::LINKEDLIST),\n+        LintId::of(types::OPTION_OPTION),\n+        LintId::of(unicode::NON_ASCII_LITERAL),\n+        LintId::of(unicode::UNICODE_NOT_NFC),\n+        LintId::of(unit_types::LET_UNIT_VALUE),\n+        LintId::of(unnecessary_wraps::UNNECESSARY_WRAPS),\n+        LintId::of(unnested_or_patterns::UNNESTED_OR_PATTERNS),\n+        LintId::of(unused_async::UNUSED_ASYNC),\n+        LintId::of(unused_self::UNUSED_SELF),\n+        LintId::of(wildcard_imports::ENUM_GLOB_USE),\n+        LintId::of(wildcard_imports::WILDCARD_IMPORTS),\n+        LintId::of(zero_sized_map_values::ZERO_SIZED_MAP_VALUES),\n+    ]);\n \n-    let msrv = conf.msrv.as_ref().and_then(|s| {\n-        parse_msrv(s, None, None).or_else(|| {\n-            sess.err(&format!(\"error reading Clippy's configuration file. `{}` is not a valid Rust version\", s));\n-            None\n-        })\n-    });\n-\n-    store.register_late_pass(move || box methods::Methods::new(msrv));\n-    store.register_late_pass(move || box matches::Matches::new(msrv));\n-    store.register_early_pass(move || box manual_non_exhaustive::ManualNonExhaustive::new(msrv));\n-    store.register_late_pass(move || box manual_strip::ManualStrip::new(msrv));\n-    store.register_early_pass(move || box redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv));\n-    store.register_early_pass(move || box redundant_field_names::RedundantFieldNames::new(msrv));\n-    store.register_late_pass(move || box checked_conversions::CheckedConversions::new(msrv));\n-    store.register_late_pass(move || box mem_replace::MemReplace::new(msrv));\n-    store.register_late_pass(move || box ranges::Ranges::new(msrv));\n-    store.register_late_pass(move || box from_over_into::FromOverInto::new(msrv));\n-    store.register_late_pass(move || box use_self::UseSelf::new(msrv));\n-    store.register_late_pass(move || box missing_const_for_fn::MissingConstForFn::new(msrv));\n-    store.register_late_pass(move || box needless_question_mark::NeedlessQuestionMark);\n-    store.register_late_pass(move || box casts::Casts::new(msrv));\n-    store.register_early_pass(move || box unnested_or_patterns::UnnestedOrPatterns::new(msrv));\n-\n-    store.register_late_pass(|| box size_of_in_element_count::SizeOfInElementCount);\n-    store.register_late_pass(|| box map_clone::MapClone);\n-    store.register_late_pass(|| box map_err_ignore::MapErrIgnore);\n-    store.register_late_pass(|| box shadow::Shadow);\n-    store.register_late_pass(|| box unit_types::UnitTypes);\n-    store.register_late_pass(|| box loops::Loops);\n-    store.register_late_pass(|| box main_recursion::MainRecursion::default());\n-    store.register_late_pass(|| box lifetimes::Lifetimes);\n-    store.register_late_pass(|| box entry::HashMapPass);\n-    store.register_late_pass(|| box minmax::MinMaxPass);\n-    store.register_late_pass(|| box open_options::OpenOptions);\n-    store.register_late_pass(|| box zero_div_zero::ZeroDiv);\n-    store.register_late_pass(|| box mutex_atomic::Mutex);\n-    store.register_late_pass(|| box needless_update::NeedlessUpdate);\n-    store.register_late_pass(|| box needless_borrow::NeedlessBorrow::default());\n-    store.register_late_pass(|| box needless_borrowed_ref::NeedlessBorrowedRef);\n-    store.register_late_pass(|| box no_effect::NoEffect);\n-    store.register_late_pass(|| box temporary_assignment::TemporaryAssignment);\n-    store.register_late_pass(|| box transmute::Transmute);\n-    let cognitive_complexity_threshold = conf.cognitive_complexity_threshold;\n-    store.register_late_pass(move || box cognitive_complexity::CognitiveComplexity::new(cognitive_complexity_threshold));\n-    let too_large_for_stack = conf.too_large_for_stack;\n-    store.register_late_pass(move || box escape::BoxedLocal{too_large_for_stack});\n-    store.register_late_pass(move || box vec::UselessVec{too_large_for_stack});\n-    store.register_late_pass(|| box panic_unimplemented::PanicUnimplemented);\n-    store.register_late_pass(|| box strings::StringLitAsBytes);\n-    store.register_late_pass(|| box derive::Derive);\n-    store.register_late_pass(|| box get_last_with_len::GetLastWithLen);\n-    store.register_late_pass(|| box drop_forget_ref::DropForgetRef);\n-    store.register_late_pass(|| box empty_enum::EmptyEnum);\n-    store.register_late_pass(|| box absurd_extreme_comparisons::AbsurdExtremeComparisons);\n-    store.register_late_pass(|| box invalid_upcast_comparisons::InvalidUpcastComparisons);\n-    store.register_late_pass(|| box regex::Regex::default());\n-    store.register_late_pass(|| box copies::CopyAndPaste);\n-    store.register_late_pass(|| box copy_iterator::CopyIterator);\n-    store.register_late_pass(|| box format::UselessFormat);\n-    store.register_late_pass(|| box swap::Swap);\n-    store.register_late_pass(|| box overflow_check_conditional::OverflowCheckConditional);\n-    store.register_late_pass(|| box new_without_default::NewWithoutDefault::default());\n-    let blacklisted_names = conf.blacklisted_names.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || box blacklisted_name::BlacklistedName::new(blacklisted_names.clone()));\n-    let too_many_arguments_threshold = conf.too_many_arguments_threshold;\n-    let too_many_lines_threshold = conf.too_many_lines_threshold;\n-    store.register_late_pass(move || box functions::Functions::new(too_many_arguments_threshold, too_many_lines_threshold));\n-    let doc_valid_idents = conf.doc_valid_idents.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || box doc::DocMarkdown::new(doc_valid_idents.clone()));\n-    store.register_late_pass(|| box neg_multiply::NegMultiply);\n-    store.register_late_pass(|| box mem_discriminant::MemDiscriminant);\n-    store.register_late_pass(|| box mem_forget::MemForget);\n-    store.register_late_pass(|| box arithmetic::Arithmetic::default());\n-    store.register_late_pass(|| box assign_ops::AssignOps);\n-    store.register_late_pass(|| box let_if_seq::LetIfSeq);\n-    store.register_late_pass(|| box eval_order_dependence::EvalOrderDependence);\n-    store.register_late_pass(|| box missing_doc::MissingDoc::new());\n-    store.register_late_pass(|| box missing_inline::MissingInline);\n-    store.register_late_pass(move || box exhaustive_items::ExhaustiveItems);\n-    store.register_late_pass(|| box if_let_some_result::OkIfLet);\n-    store.register_late_pass(|| box partialeq_ne_impl::PartialEqNeImpl);\n-    store.register_late_pass(|| box unused_io_amount::UnusedIoAmount);\n-    let enum_variant_size_threshold = conf.enum_variant_size_threshold;\n-    store.register_late_pass(move || box large_enum_variant::LargeEnumVariant::new(enum_variant_size_threshold));\n-    store.register_late_pass(|| box explicit_write::ExplicitWrite);\n-    store.register_late_pass(|| box needless_pass_by_value::NeedlessPassByValue);\n-    let pass_by_ref_or_value = pass_by_ref_or_value::PassByRefOrValue::new(\n-        conf.trivial_copy_size_limit,\n-        conf.pass_by_value_size_limit,\n-        &sess.target,\n-    );\n-    store.register_late_pass(move || box pass_by_ref_or_value);\n-    store.register_late_pass(|| box ref_option_ref::RefOptionRef);\n-    store.register_late_pass(|| box try_err::TryErr);\n-    store.register_late_pass(|| box bytecount::ByteCount);\n-    store.register_late_pass(|| box infinite_iter::InfiniteIter);\n-    store.register_late_pass(|| box inline_fn_without_body::InlineFnWithoutBody);\n-    store.register_late_pass(|| box useless_conversion::UselessConversion::default());\n-    store.register_late_pass(|| box implicit_hasher::ImplicitHasher);\n-    store.register_late_pass(|| box fallible_impl_from::FallibleImplFrom);\n-    store.register_late_pass(|| box double_comparison::DoubleComparisons);\n-    store.register_late_pass(|| box question_mark::QuestionMark);\n-    store.register_early_pass(|| box suspicious_operation_groupings::SuspiciousOperationGroupings);\n-    store.register_late_pass(|| box suspicious_trait_impl::SuspiciousImpl);\n-    store.register_late_pass(|| box map_unit_fn::MapUnit);\n-    store.register_late_pass(|| box inherent_impl::MultipleInherentImpl);\n-    store.register_late_pass(|| box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n-    store.register_late_pass(|| box unwrap::Unwrap);\n-    store.register_late_pass(|| box duration_subsec::DurationSubsec);\n-    store.register_late_pass(|| box indexing_slicing::IndexingSlicing);\n-    store.register_late_pass(|| box non_copy_const::NonCopyConst);\n-    store.register_late_pass(|| box ptr_offset_with_cast::PtrOffsetWithCast);\n-    store.register_late_pass(|| box redundant_clone::RedundantClone);\n-    store.register_late_pass(|| box slow_vector_initialization::SlowVectorInit);\n-    store.register_late_pass(|| box unnecessary_sort_by::UnnecessarySortBy);\n-    store.register_late_pass(|| box unnecessary_wraps::UnnecessaryWraps);\n-    store.register_late_pass(|| box assertions_on_constants::AssertionsOnConstants);\n-    store.register_late_pass(|| box transmuting_null::TransmutingNull);\n-    store.register_late_pass(|| box path_buf_push_overwrite::PathBufPushOverwrite);\n-    store.register_late_pass(|| box integer_division::IntegerDivision);\n-    store.register_late_pass(|| box inherent_to_string::InherentToString);\n-    let max_trait_bounds = conf.max_trait_bounds;\n-    store.register_late_pass(move || box trait_bounds::TraitBounds::new(max_trait_bounds));\n-    store.register_late_pass(|| box comparison_chain::ComparisonChain);\n-    store.register_late_pass(|| box mut_key::MutableKeyType);\n-    store.register_late_pass(|| box modulo_arithmetic::ModuloArithmetic);\n-    store.register_early_pass(|| box reference::DerefAddrOf);\n-    store.register_early_pass(|| box reference::RefInDeref);\n-    store.register_early_pass(|| box double_parens::DoubleParens);\n-    store.register_late_pass(|| box to_string_in_display::ToStringInDisplay::new());\n-    store.register_early_pass(|| box unsafe_removed_from_name::UnsafeNameRemoval);\n-    store.register_early_pass(|| box if_not_else::IfNotElse);\n-    store.register_early_pass(|| box else_if_without_else::ElseIfWithoutElse);\n-    store.register_early_pass(|| box int_plus_one::IntPlusOne);\n-    store.register_early_pass(|| box formatting::Formatting);\n-    store.register_early_pass(|| box misc_early::MiscEarlyLints);\n-    store.register_early_pass(|| box redundant_closure_call::RedundantClosureCall);\n-    store.register_late_pass(|| box redundant_closure_call::RedundantClosureCall);\n-    store.register_early_pass(|| box unused_unit::UnusedUnit);\n-    store.register_late_pass(|| box returns::Return);\n-    store.register_early_pass(|| box collapsible_if::CollapsibleIf);\n-    store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n-    store.register_early_pass(|| box precedence::Precedence);\n-    store.register_early_pass(|| box needless_continue::NeedlessContinue);\n-    store.register_early_pass(|| box redundant_else::RedundantElse);\n-    store.register_late_pass(|| box create_dir::CreateDir);\n-    store.register_early_pass(|| box needless_arbitrary_self_type::NeedlessArbitrarySelfType);\n-    let cargo_ignore_publish = conf.cargo_ignore_publish;\n-    store.register_late_pass(move || box cargo_common_metadata::CargoCommonMetadata::new(cargo_ignore_publish));\n-    store.register_late_pass(|| box multiple_crate_versions::MultipleCrateVersions);\n-    store.register_late_pass(|| box wildcard_dependencies::WildcardDependencies);\n-    let literal_representation_lint_fraction_readability = conf.unreadable_literal_lint_fractions;\n-    store.register_early_pass(move || box literal_representation::LiteralDigitGrouping::new(literal_representation_lint_fraction_readability));\n-    let literal_representation_threshold = conf.literal_representation_threshold;\n-    store.register_early_pass(move || box literal_representation::DecimalLiteralRepresentation::new(literal_representation_threshold));\n-    let enum_variant_name_threshold = conf.enum_variant_name_threshold;\n-    store.register_early_pass(move || box enum_variants::EnumVariantNames::new(enum_variant_name_threshold));\n-    store.register_early_pass(|| box tabs_in_doc_comments::TabsInDocComments);\n-    let upper_case_acronyms_aggressive = conf.upper_case_acronyms_aggressive;\n-    store.register_early_pass(move || box upper_case_acronyms::UpperCaseAcronyms::new(upper_case_acronyms_aggressive));\n-    store.register_late_pass(|| box default::Default::default());\n-    store.register_late_pass(|| box unused_self::UnusedSelf);\n-    store.register_late_pass(|| box mutable_debug_assertion::DebugAssertWithMutCall);\n-    store.register_late_pass(|| box exit::Exit);\n-    store.register_late_pass(|| box to_digit_is_some::ToDigitIsSome);\n-    let array_size_threshold = conf.array_size_threshold;\n-    store.register_late_pass(move || box large_stack_arrays::LargeStackArrays::new(array_size_threshold));\n-    store.register_late_pass(move || box large_const_arrays::LargeConstArrays::new(array_size_threshold));\n-    store.register_late_pass(|| box floating_point_arithmetic::FloatingPointArithmetic);\n-    store.register_early_pass(|| box as_conversions::AsConversions);\n-    store.register_late_pass(|| box let_underscore::LetUnderscore);\n-    store.register_late_pass(|| box atomic_ordering::AtomicOrdering);\n-    store.register_early_pass(|| box single_component_path_imports::SingleComponentPathImports);\n-    let max_fn_params_bools = conf.max_fn_params_bools;\n-    let max_struct_bools = conf.max_struct_bools;\n-    store.register_early_pass(move || box excessive_bools::ExcessiveBools::new(max_struct_bools, max_fn_params_bools));\n-    store.register_early_pass(|| box option_env_unwrap::OptionEnvUnwrap);\n-    let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n-    store.register_late_pass(move || box wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports));\n-    store.register_late_pass(|| box verbose_file_reads::VerboseFileReads);\n-    store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n-    store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n-    store.register_late_pass(|| box dereference::Dereferencing::default());\n-    store.register_late_pass(|| box option_if_let_else::OptionIfLetElse);\n-    store.register_late_pass(|| box future_not_send::FutureNotSend);\n-    store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n-    store.register_late_pass(|| box mut_mutex_lock::MutMutexLock);\n-    store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n-    store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n-    store.register_late_pass(|| box vec_resize_to_zero::VecResizeToZero);\n-    store.register_late_pass(|| box panic_in_result_fn::PanicInResultFn);\n-    let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n-    store.register_early_pass(move || box non_expressive_names::NonExpressiveNames {\n-        single_char_binding_names_threshold,\n-    });\n-    store.register_late_pass(|| box macro_use::MacroUseImports::default());\n-    store.register_late_pass(|| box map_identity::MapIdentity);\n-    store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n-    store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n-    store.register_late_pass(|| box repeat_once::RepeatOnce);\n-    store.register_late_pass(|| box unwrap_in_result::UnwrapInResult);\n-    store.register_late_pass(|| box self_assignment::SelfAssignment);\n-    store.register_late_pass(|| box manual_unwrap_or::ManualUnwrapOr);\n-    store.register_late_pass(|| box manual_ok_or::ManualOkOr);\n-    store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n-    store.register_late_pass(|| box semicolon_if_nothing_returned::SemicolonIfNothingReturned);\n-    store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n-    let disallowed_methods = conf.disallowed_methods.iter().cloned().collect::<FxHashSet<_>>();\n-    store.register_late_pass(move || box disallowed_method::DisallowedMethod::new(&disallowed_methods));\n-    store.register_early_pass(|| box asm_syntax::InlineAsmX86AttSyntax);\n-    store.register_early_pass(|| box asm_syntax::InlineAsmX86IntelSyntax);\n-    store.register_late_pass(|| box undropped_manually_drops::UndroppedManuallyDrops);\n-    store.register_late_pass(|| box strings::StrToString);\n-    store.register_late_pass(|| box strings::StringToString);\n-    store.register_late_pass(|| box zero_sized_map_values::ZeroSizedMapValues);\n-    store.register_late_pass(|| box vec_init_then_push::VecInitThenPush::default());\n-    store.register_late_pass(|| box case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons);\n-    store.register_late_pass(|| box redundant_slicing::RedundantSlicing);\n-    store.register_late_pass(|| box from_str_radix_10::FromStrRadix10);\n-    store.register_late_pass(|| box manual_map::ManualMap);\n-    store.register_late_pass(move || box if_then_some_else_none::IfThenSomeElseNone::new(msrv));\n-    store.register_early_pass(|| box bool_assert_comparison::BoolAssertComparison);\n-    store.register_late_pass(|| box unused_async::UnusedAsync);\n-\n-    store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n-        LintId::of(arithmetic::FLOAT_ARITHMETIC),\n-        LintId::of(arithmetic::INTEGER_ARITHMETIC),\n-        LintId::of(as_conversions::AS_CONVERSIONS),\n-        LintId::of(asm_syntax::INLINE_ASM_X86_ATT_SYNTAX),\n-        LintId::of(asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n-        LintId::of(create_dir::CREATE_DIR),\n-        LintId::of(dbg_macro::DBG_MACRO),\n-        LintId::of(default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK),\n-        LintId::of(else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n-        LintId::of(exhaustive_items::EXHAUSTIVE_ENUMS),\n-        LintId::of(exhaustive_items::EXHAUSTIVE_STRUCTS),\n-        LintId::of(exit::EXIT),\n-        LintId::of(float_literal::LOSSY_FLOAT_LITERAL),\n-        LintId::of(if_then_some_else_none::IF_THEN_SOME_ELSE_NONE),\n-        LintId::of(implicit_return::IMPLICIT_RETURN),\n-        LintId::of(indexing_slicing::INDEXING_SLICING),\n-        LintId::of(inherent_impl::MULTIPLE_INHERENT_IMPL),\n-        LintId::of(integer_division::INTEGER_DIVISION),\n-        LintId::of(let_underscore::LET_UNDERSCORE_MUST_USE),\n-        LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n-        LintId::of(map_err_ignore::MAP_ERR_IGNORE),\n-        LintId::of(matches::REST_PAT_IN_FULLY_BOUND_STRUCTS),\n-        LintId::of(matches::WILDCARD_ENUM_MATCH_ARM),\n-        LintId::of(mem_forget::MEM_FORGET),\n-        LintId::of(methods::CLONE_ON_REF_PTR),\n-        LintId::of(methods::EXPECT_USED),\n-        LintId::of(methods::FILETYPE_IS_FILE),\n-        LintId::of(methods::GET_UNWRAP),\n-        LintId::of(methods::UNWRAP_USED),\n-        LintId::of(methods::WRONG_PUB_SELF_CONVENTION),\n-        LintId::of(misc::FLOAT_CMP_CONST),\n-        LintId::of(misc_early::UNNEEDED_FIELD_PATTERN),\n-        LintId::of(missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS),\n-        LintId::of(missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS),\n-        LintId::of(modulo_arithmetic::MODULO_ARITHMETIC),\n-        LintId::of(panic_in_result_fn::PANIC_IN_RESULT_FN),\n-        LintId::of(panic_unimplemented::PANIC),\n-        LintId::of(panic_unimplemented::TODO),\n-        LintId::of(panic_unimplemented::UNIMPLEMENTED),\n-        LintId::of(panic_unimplemented::UNREACHABLE),\n-        LintId::of(pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n-        LintId::of(semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED),\n-        LintId::of(shadow::SHADOW_REUSE),\n-        LintId::of(shadow::SHADOW_SAME),\n-        LintId::of(strings::STRING_ADD),\n-        LintId::of(strings::STRING_TO_STRING),\n-        LintId::of(strings::STR_TO_STRING),\n-        LintId::of(types::RC_BUFFER),\n-        LintId::of(unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS),\n-        LintId::of(unwrap_in_result::UNWRAP_IN_RESULT),\n-        LintId::of(verbose_file_reads::VERBOSE_FILE_READS),\n-        LintId::of(write::PRINT_STDERR),\n-        LintId::of(write::PRINT_STDOUT),\n-        LintId::of(write::USE_DEBUG),\n-    ]);\n-\n-    store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n-        LintId::of(attrs::INLINE_ALWAYS),\n-        LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n-        LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n-        LintId::of(bit_mask::VERBOSE_BIT_MASK),\n-        LintId::of(bytecount::NAIVE_BYTECOUNT),\n-        LintId::of(case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n-        LintId::of(casts::CAST_LOSSLESS),\n-        LintId::of(casts::CAST_POSSIBLE_TRUNCATION),\n-        LintId::of(casts::CAST_POSSIBLE_WRAP),\n-        LintId::of(casts::CAST_PRECISION_LOSS),\n-        LintId::of(casts::CAST_PTR_ALIGNMENT),\n-        LintId::of(casts::CAST_SIGN_LOSS),\n-        LintId::of(casts::PTR_AS_PTR),\n-        LintId::of(checked_conversions::CHECKED_CONVERSIONS),\n-        LintId::of(copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n-        LintId::of(copy_iterator::COPY_ITERATOR),\n-        LintId::of(default::DEFAULT_TRAIT_ACCESS),\n-        LintId::of(dereference::EXPLICIT_DEREF_METHODS),\n-        LintId::of(derive::EXPL_IMPL_CLONE_ON_COPY),\n-        LintId::of(derive::UNSAFE_DERIVE_DESERIALIZE),\n-        LintId::of(doc::DOC_MARKDOWN),\n-        LintId::of(doc::MISSING_ERRORS_DOC),\n-        LintId::of(doc::MISSING_PANICS_DOC),\n-        LintId::of(empty_enum::EMPTY_ENUM),\n-        LintId::of(enum_variants::MODULE_NAME_REPETITIONS),\n-        LintId::of(enum_variants::PUB_ENUM_VARIANT_NAMES),\n-        LintId::of(eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS),\n-        LintId::of(excessive_bools::FN_PARAMS_EXCESSIVE_BOOLS),\n-        LintId::of(excessive_bools::STRUCT_EXCESSIVE_BOOLS),\n-        LintId::of(functions::MUST_USE_CANDIDATE),\n-        LintId::of(functions::TOO_MANY_LINES),\n-        LintId::of(if_not_else::IF_NOT_ELSE),\n-        LintId::of(implicit_hasher::IMPLICIT_HASHER),\n-        LintId::of(implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n-        LintId::of(inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR),\n-        LintId::of(infinite_iter::MAYBE_INFINITE_ITER),\n-        LintId::of(invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS),\n-        LintId::of(items_after_statements::ITEMS_AFTER_STATEMENTS),\n-        LintId::of(large_stack_arrays::LARGE_STACK_ARRAYS),\n-        LintId::of(let_underscore::LET_UNDERSCORE_DROP),\n-        LintId::of(literal_representation::LARGE_DIGIT_GROUPS),\n-        LintId::of(literal_representation::UNREADABLE_LITERAL),\n-        LintId::of(loops::EXPLICIT_INTO_ITER_LOOP),\n-        LintId::of(loops::EXPLICIT_ITER_LOOP),\n-        LintId::of(macro_use::MACRO_USE_IMPORTS),\n-        LintId::of(manual_ok_or::MANUAL_OK_OR),\n-        LintId::of(match_on_vec_items::MATCH_ON_VEC_ITEMS),\n-        LintId::of(matches::MATCH_BOOL),\n-        LintId::of(matches::MATCH_SAME_ARMS),\n-        LintId::of(matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n-        LintId::of(matches::MATCH_WILD_ERR_ARM),\n-        LintId::of(matches::SINGLE_MATCH_ELSE),\n-        LintId::of(methods::CLONED_INSTEAD_OF_COPIED),\n-        LintId::of(methods::FILTER_MAP_NEXT),\n-        LintId::of(methods::FLAT_MAP_OPTION),\n-        LintId::of(methods::IMPLICIT_CLONE),\n-        LintId::of(methods::INEFFICIENT_TO_STRING),\n-        LintId::of(methods::MAP_FLATTEN),\n-        LintId::of(methods::MAP_UNWRAP_OR),\n-        LintId::of(misc::USED_UNDERSCORE_BINDING),\n-        LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n-        LintId::of(mut_mut::MUT_MUT),\n-        LintId::of(needless_bitwise_bool::NEEDLESS_BITWISE_BOOL),\n-        LintId::of(needless_continue::NEEDLESS_CONTINUE),\n-        LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n-        LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n-        LintId::of(non_expressive_names::SIMILAR_NAMES),\n-        LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n-        LintId::of(pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n-        LintId::of(pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n-        LintId::of(ranges::RANGE_MINUS_ONE),\n-        LintId::of(ranges::RANGE_PLUS_ONE),\n-        LintId::of(redundant_else::REDUNDANT_ELSE),\n-        LintId::of(ref_option_ref::REF_OPTION_REF),\n-        LintId::of(shadow::SHADOW_UNRELATED),\n-        LintId::of(strings::STRING_ADD_ASSIGN),\n-        LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n-        LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n-        LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n-        LintId::of(types::LINKEDLIST),\n-        LintId::of(types::OPTION_OPTION),\n-        LintId::of(unicode::NON_ASCII_LITERAL),\n-        LintId::of(unicode::UNICODE_NOT_NFC),\n-        LintId::of(unit_types::LET_UNIT_VALUE),\n-        LintId::of(unnecessary_wraps::UNNECESSARY_WRAPS),\n-        LintId::of(unnested_or_patterns::UNNESTED_OR_PATTERNS),\n-        LintId::of(unused_async::UNUSED_ASYNC),\n-        LintId::of(unused_self::UNUSED_SELF),\n-        LintId::of(wildcard_imports::ENUM_GLOB_USE),\n-        LintId::of(wildcard_imports::WILDCARD_IMPORTS),\n-        LintId::of(zero_sized_map_values::ZERO_SIZED_MAP_VALUES),\n-    ]);\n-\n-    #[cfg(feature = \"internal-lints\")]\n-    store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n-        LintId::of(utils::internal_lints::CLIPPY_LINTS_INTERNAL),\n-        LintId::of(utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n-        LintId::of(utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n-        LintId::of(utils::internal_lints::DEFAULT_LINT),\n-        LintId::of(utils::internal_lints::IF_CHAIN_STYLE),\n-        LintId::of(utils::internal_lints::INTERNING_DEFINED_SYMBOL),\n-        LintId::of(utils::internal_lints::INVALID_PATHS),\n-        LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n-        LintId::of(utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n-        LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n-        LintId::of(utils::internal_lints::PRODUCE_ICE),\n-        LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n-    ]);\n+    #[cfg(feature = \"internal-lints\")]\n+    store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n+        LintId::of(utils::internal_lints::CLIPPY_LINTS_INTERNAL),\n+        LintId::of(utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n+        LintId::of(utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n+        LintId::of(utils::internal_lints::DEFAULT_LINT),\n+        LintId::of(utils::internal_lints::IF_CHAIN_STYLE),\n+        LintId::of(utils::internal_lints::INTERNING_DEFINED_SYMBOL),\n+        LintId::of(utils::internal_lints::INVALID_PATHS),\n+        LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n+        LintId::of(utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n+        LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n+        LintId::of(utils::internal_lints::PRODUCE_ICE),\n+        LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n+    ]);\n \n     store.register_group(true, \"clippy::all\", Some(\"clippy\"), vec![\n         LintId::of(absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS),\n@@ -1600,6 +1299,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n         LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n+        LintId::of(methods::MANUAL_STR_REPEAT),\n         LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n         LintId::of(methods::NEW_RET_NO_SELF),\n         LintId::of(methods::OK_EXPECT),\n@@ -1615,6 +1315,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::SKIP_WHILE_NEXT),\n         LintId::of(methods::STRING_EXTEND_CHARS),\n         LintId::of(methods::SUSPICIOUS_MAP),\n+        LintId::of(methods::SUSPICIOUS_SPLITN),\n         LintId::of(methods::UNINIT_ASSUMED_INIT),\n         LintId::of(methods::UNNECESSARY_FILTER_MAP),\n         LintId::of(methods::UNNECESSARY_FOLD),\n@@ -1644,6 +1345,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n         LintId::of(needless_bool::BOOL_COMPARISON),\n         LintId::of(needless_bool::NEEDLESS_BOOL),\n+        LintId::of(needless_borrow::NEEDLESS_BORROW),\n         LintId::of(needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n         LintId::of(needless_question_mark::NEEDLESS_QUESTION_MARK),\n         LintId::of(needless_update::NEEDLESS_UPDATE),\n@@ -1690,7 +1392,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n         LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n         LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n-        LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n         LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(swap::ALMOST_SWAPPED),\n@@ -1827,6 +1528,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(misc_early::REDUNDANT_PATTERN),\n         LintId::of(mut_mutex_lock::MUT_MUTEX_LOCK),\n         LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n+        LintId::of(needless_borrow::NEEDLESS_BORROW),\n         LintId::of(neg_multiply::NEG_MULTIPLY),\n         LintId::of(new_without_default::NEW_WITHOUT_DEFAULT),\n         LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),\n@@ -1843,7 +1545,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(returns::LET_AND_RETURN),\n         LintId::of(returns::NEEDLESS_RETURN),\n         LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n-        LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n         LintId::of(tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n         LintId::of(to_digit_is_some::TO_DIGIT_IS_SOME),\n         LintId::of(try_err::TRY_ERR),\n@@ -1991,6 +1692,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n         LintId::of(methods::CLONE_DOUBLE_REF),\n         LintId::of(methods::ITERATOR_STEP_BY_ZERO),\n+        LintId::of(methods::SUSPICIOUS_SPLITN),\n         LintId::of(methods::UNINIT_ASSUMED_INIT),\n         LintId::of(methods::ZST_OFFSET),\n         LintId::of(minmax::MIN_MAX),\n@@ -2035,6 +1737,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(loops::NEEDLESS_COLLECT),\n         LintId::of(methods::EXPECT_FUN_CALL),\n         LintId::of(methods::ITER_NTH),\n+        LintId::of(methods::MANUAL_STR_REPEAT),\n         LintId::of(methods::OR_FUN_CALL),\n         LintId::of(methods::SINGLE_CHAR_PATTERN),\n         LintId::of(misc::CMP_OWNED),\n@@ -2048,32 +1751,322 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(vec_init_then_push::VEC_INIT_THEN_PUSH),\n     ]);\n \n-    store.register_group(true, \"clippy::cargo\", Some(\"clippy_cargo\"), vec![\n-        LintId::of(cargo_common_metadata::CARGO_COMMON_METADATA),\n-        LintId::of(multiple_crate_versions::MULTIPLE_CRATE_VERSIONS),\n-        LintId::of(wildcard_dependencies::WILDCARD_DEPENDENCIES),\n-    ]);\n+    store.register_group(true, \"clippy::cargo\", Some(\"clippy_cargo\"), vec![\n+        LintId::of(cargo_common_metadata::CARGO_COMMON_METADATA),\n+        LintId::of(multiple_crate_versions::MULTIPLE_CRATE_VERSIONS),\n+        LintId::of(wildcard_dependencies::WILDCARD_DEPENDENCIES),\n+    ]);\n+\n+    store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n+        LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n+        LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n+        LintId::of(disallowed_method::DISALLOWED_METHOD),\n+        LintId::of(fallible_impl_from::FALLIBLE_IMPL_FROM),\n+        LintId::of(floating_point_arithmetic::IMPRECISE_FLOPS),\n+        LintId::of(floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n+        LintId::of(future_not_send::FUTURE_NOT_SEND),\n+        LintId::of(let_if_seq::USELESS_LET_IF_SEQ),\n+        LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n+        LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n+        LintId::of(mutex_atomic::MUTEX_INTEGER),\n+        LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n+        LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n+        LintId::of(regex::TRIVIAL_REGEX),\n+        LintId::of(strings::STRING_LIT_AS_BYTES),\n+        LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n+        LintId::of(transmute::USELESS_TRANSMUTE),\n+        LintId::of(use_self::USE_SELF),\n+    ]);\n+\n+    #[cfg(feature = \"metadata-collector-lint\")]\n+    {\n+        if std::env::var(\"ENABLE_METADATA_COLLECTION\").eq(&Ok(\"1\".to_string())) {\n+            store.register_late_pass(|| box utils::internal_lints::metadata_collector::MetadataCollector::new());\n+            return;\n+        }\n+    }\n+\n+    // all the internal lints\n+    #[cfg(feature = \"internal-lints\")]\n+    {\n+        store.register_early_pass(|| box utils::internal_lints::ClippyLintsInternal);\n+        store.register_early_pass(|| box utils::internal_lints::ProduceIce);\n+        store.register_late_pass(|| box utils::inspector::DeepCodeInspector);\n+        store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n+        store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n+        store.register_late_pass(|| box utils::internal_lints::IfChainStyle);\n+        store.register_late_pass(|| box utils::internal_lints::InvalidPaths);\n+        store.register_late_pass(|| box utils::internal_lints::InterningDefinedSymbol::default());\n+        store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n+        store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n+        store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n+    }\n+\n+    store.register_late_pass(|| box utils::author::Author);\n+    store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n+    store.register_late_pass(|| box serde_api::SerdeApi);\n+    let vec_box_size_threshold = conf.vec_box_size_threshold;\n+    let type_complexity_threshold = conf.type_complexity_threshold;\n+    store.register_late_pass(move || box types::Types::new(vec_box_size_threshold, type_complexity_threshold));\n+    store.register_late_pass(|| box booleans::NonminimalBool);\n+    store.register_late_pass(|| box needless_bitwise_bool::NeedlessBitwiseBool);\n+    store.register_late_pass(|| box eq_op::EqOp);\n+    store.register_late_pass(|| box enum_clike::UnportableVariant);\n+    store.register_late_pass(|| box float_literal::FloatLiteral);\n+    let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n+    store.register_late_pass(move || box bit_mask::BitMask::new(verbose_bit_mask_threshold));\n+    store.register_late_pass(|| box ptr::Ptr);\n+    store.register_late_pass(|| box ptr_eq::PtrEq);\n+    store.register_late_pass(|| box needless_bool::NeedlessBool);\n+    store.register_late_pass(|| box needless_bool::BoolComparison);\n+    store.register_late_pass(|| box needless_for_each::NeedlessForEach);\n+    store.register_late_pass(|| box approx_const::ApproxConstant);\n+    store.register_late_pass(|| box misc::MiscLints);\n+    store.register_late_pass(|| box eta_reduction::EtaReduction);\n+    store.register_late_pass(|| box identity_op::IdentityOp);\n+    store.register_late_pass(|| box erasing_op::ErasingOp);\n+    store.register_late_pass(|| box mut_mut::MutMut);\n+    store.register_late_pass(|| box mut_reference::UnnecessaryMutPassed);\n+    store.register_late_pass(|| box len_zero::LenZero);\n+    store.register_late_pass(|| box attrs::Attributes);\n+    store.register_late_pass(|| box blocks_in_if_conditions::BlocksInIfConditions);\n+    store.register_late_pass(|| box collapsible_match::CollapsibleMatch);\n+    store.register_late_pass(|| box unicode::Unicode);\n+    store.register_late_pass(|| box unit_return_expecting_ord::UnitReturnExpectingOrd);\n+    store.register_late_pass(|| box strings::StringAdd);\n+    store.register_late_pass(|| box implicit_return::ImplicitReturn);\n+    store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n+    store.register_late_pass(|| box default_numeric_fallback::DefaultNumericFallback);\n+    store.register_late_pass(|| box inconsistent_struct_constructor::InconsistentStructConstructor);\n+    store.register_late_pass(|| box non_octal_unix_permissions::NonOctalUnixPermissions);\n+    store.register_early_pass(|| box unnecessary_self_imports::UnnecessarySelfImports);\n+\n+    let msrv = conf.msrv.as_ref().and_then(|s| {\n+        parse_msrv(s, None, None).or_else(|| {\n+            sess.err(&format!(\"error reading Clippy's configuration file. `{}` is not a valid Rust version\", s));\n+            None\n+        })\n+    });\n+\n+    let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n+    store.register_late_pass(move || box methods::Methods::new(avoid_breaking_exported_api, msrv));\n+    store.register_late_pass(move || box matches::Matches::new(msrv));\n+    store.register_early_pass(move || box manual_non_exhaustive::ManualNonExhaustive::new(msrv));\n+    store.register_late_pass(move || box manual_strip::ManualStrip::new(msrv));\n+    store.register_early_pass(move || box redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv));\n+    store.register_early_pass(move || box redundant_field_names::RedundantFieldNames::new(msrv));\n+    store.register_late_pass(move || box checked_conversions::CheckedConversions::new(msrv));\n+    store.register_late_pass(move || box mem_replace::MemReplace::new(msrv));\n+    store.register_late_pass(move || box ranges::Ranges::new(msrv));\n+    store.register_late_pass(move || box from_over_into::FromOverInto::new(msrv));\n+    store.register_late_pass(move || box use_self::UseSelf::new(msrv));\n+    store.register_late_pass(move || box missing_const_for_fn::MissingConstForFn::new(msrv));\n+    store.register_late_pass(move || box needless_question_mark::NeedlessQuestionMark);\n+    store.register_late_pass(move || box casts::Casts::new(msrv));\n+    store.register_early_pass(move || box unnested_or_patterns::UnnestedOrPatterns::new(msrv));\n+\n+    store.register_late_pass(|| box size_of_in_element_count::SizeOfInElementCount);\n+    store.register_late_pass(|| box map_clone::MapClone);\n+    store.register_late_pass(|| box map_err_ignore::MapErrIgnore);\n+    store.register_late_pass(|| box shadow::Shadow);\n+    store.register_late_pass(|| box unit_types::UnitTypes);\n+    store.register_late_pass(|| box loops::Loops);\n+    store.register_late_pass(|| box main_recursion::MainRecursion::default());\n+    store.register_late_pass(|| box lifetimes::Lifetimes);\n+    store.register_late_pass(|| box entry::HashMapPass);\n+    store.register_late_pass(|| box minmax::MinMaxPass);\n+    store.register_late_pass(|| box open_options::OpenOptions);\n+    store.register_late_pass(|| box zero_div_zero::ZeroDiv);\n+    store.register_late_pass(|| box mutex_atomic::Mutex);\n+    store.register_late_pass(|| box needless_update::NeedlessUpdate);\n+    store.register_late_pass(|| box needless_borrow::NeedlessBorrow::default());\n+    store.register_late_pass(|| box needless_borrowed_ref::NeedlessBorrowedRef);\n+    store.register_late_pass(|| box no_effect::NoEffect);\n+    store.register_late_pass(|| box temporary_assignment::TemporaryAssignment);\n+    store.register_late_pass(|| box transmute::Transmute);\n+    let cognitive_complexity_threshold = conf.cognitive_complexity_threshold;\n+    store.register_late_pass(move || box cognitive_complexity::CognitiveComplexity::new(cognitive_complexity_threshold));\n+    let too_large_for_stack = conf.too_large_for_stack;\n+    store.register_late_pass(move || box escape::BoxedLocal{too_large_for_stack});\n+    store.register_late_pass(move || box vec::UselessVec{too_large_for_stack});\n+    store.register_late_pass(|| box panic_unimplemented::PanicUnimplemented);\n+    store.register_late_pass(|| box strings::StringLitAsBytes);\n+    store.register_late_pass(|| box derive::Derive);\n+    store.register_late_pass(|| box get_last_with_len::GetLastWithLen);\n+    store.register_late_pass(|| box drop_forget_ref::DropForgetRef);\n+    store.register_late_pass(|| box empty_enum::EmptyEnum);\n+    store.register_late_pass(|| box absurd_extreme_comparisons::AbsurdExtremeComparisons);\n+    store.register_late_pass(|| box invalid_upcast_comparisons::InvalidUpcastComparisons);\n+    store.register_late_pass(|| box regex::Regex::default());\n+    store.register_late_pass(|| box copies::CopyAndPaste);\n+    store.register_late_pass(|| box copy_iterator::CopyIterator);\n+    store.register_late_pass(|| box format::UselessFormat);\n+    store.register_late_pass(|| box swap::Swap);\n+    store.register_late_pass(|| box overflow_check_conditional::OverflowCheckConditional);\n+    store.register_late_pass(|| box new_without_default::NewWithoutDefault::default());\n+    let blacklisted_names = conf.blacklisted_names.iter().cloned().collect::<FxHashSet<_>>();\n+    store.register_late_pass(move || box blacklisted_name::BlacklistedName::new(blacklisted_names.clone()));\n+    let too_many_arguments_threshold = conf.too_many_arguments_threshold;\n+    let too_many_lines_threshold = conf.too_many_lines_threshold;\n+    store.register_late_pass(move || box functions::Functions::new(too_many_arguments_threshold, too_many_lines_threshold));\n+    let doc_valid_idents = conf.doc_valid_idents.iter().cloned().collect::<FxHashSet<_>>();\n+    store.register_late_pass(move || box doc::DocMarkdown::new(doc_valid_idents.clone()));\n+    store.register_late_pass(|| box neg_multiply::NegMultiply);\n+    store.register_late_pass(|| box mem_discriminant::MemDiscriminant);\n+    store.register_late_pass(|| box mem_forget::MemForget);\n+    store.register_late_pass(|| box arithmetic::Arithmetic::default());\n+    store.register_late_pass(|| box assign_ops::AssignOps);\n+    store.register_late_pass(|| box let_if_seq::LetIfSeq);\n+    store.register_late_pass(|| box eval_order_dependence::EvalOrderDependence);\n+    store.register_late_pass(|| box missing_doc::MissingDoc::new());\n+    store.register_late_pass(|| box missing_inline::MissingInline);\n+    store.register_late_pass(move || box exhaustive_items::ExhaustiveItems);\n+    store.register_late_pass(|| box if_let_some_result::OkIfLet);\n+    store.register_late_pass(|| box partialeq_ne_impl::PartialEqNeImpl);\n+    store.register_late_pass(|| box unused_io_amount::UnusedIoAmount);\n+    let enum_variant_size_threshold = conf.enum_variant_size_threshold;\n+    store.register_late_pass(move || box large_enum_variant::LargeEnumVariant::new(enum_variant_size_threshold));\n+    store.register_late_pass(|| box explicit_write::ExplicitWrite);\n+    store.register_late_pass(|| box needless_pass_by_value::NeedlessPassByValue);\n+    let pass_by_ref_or_value = pass_by_ref_or_value::PassByRefOrValue::new(\n+        conf.trivial_copy_size_limit,\n+        conf.pass_by_value_size_limit,\n+        conf.avoid_breaking_exported_api,\n+        &sess.target,\n+    );\n+    store.register_late_pass(move || box pass_by_ref_or_value);\n+    store.register_late_pass(|| box ref_option_ref::RefOptionRef);\n+    store.register_late_pass(|| box try_err::TryErr);\n+    store.register_late_pass(|| box bytecount::ByteCount);\n+    store.register_late_pass(|| box infinite_iter::InfiniteIter);\n+    store.register_late_pass(|| box inline_fn_without_body::InlineFnWithoutBody);\n+    store.register_late_pass(|| box useless_conversion::UselessConversion::default());\n+    store.register_late_pass(|| box implicit_hasher::ImplicitHasher);\n+    store.register_late_pass(|| box fallible_impl_from::FallibleImplFrom);\n+    store.register_late_pass(|| box double_comparison::DoubleComparisons);\n+    store.register_late_pass(|| box question_mark::QuestionMark);\n+    store.register_early_pass(|| box suspicious_operation_groupings::SuspiciousOperationGroupings);\n+    store.register_late_pass(|| box suspicious_trait_impl::SuspiciousImpl);\n+    store.register_late_pass(|| box map_unit_fn::MapUnit);\n+    store.register_late_pass(|| box inherent_impl::MultipleInherentImpl);\n+    store.register_late_pass(|| box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n+    store.register_late_pass(|| box unwrap::Unwrap);\n+    store.register_late_pass(|| box duration_subsec::DurationSubsec);\n+    store.register_late_pass(|| box indexing_slicing::IndexingSlicing);\n+    store.register_late_pass(|| box non_copy_const::NonCopyConst);\n+    store.register_late_pass(|| box ptr_offset_with_cast::PtrOffsetWithCast);\n+    store.register_late_pass(|| box redundant_clone::RedundantClone);\n+    store.register_late_pass(|| box slow_vector_initialization::SlowVectorInit);\n+    store.register_late_pass(|| box unnecessary_sort_by::UnnecessarySortBy);\n+    store.register_late_pass(move || box unnecessary_wraps::UnnecessaryWraps::new(avoid_breaking_exported_api));\n+    store.register_late_pass(|| box assertions_on_constants::AssertionsOnConstants);\n+    store.register_late_pass(|| box transmuting_null::TransmutingNull);\n+    store.register_late_pass(|| box path_buf_push_overwrite::PathBufPushOverwrite);\n+    store.register_late_pass(|| box integer_division::IntegerDivision);\n+    store.register_late_pass(|| box inherent_to_string::InherentToString);\n+    let max_trait_bounds = conf.max_trait_bounds;\n+    store.register_late_pass(move || box trait_bounds::TraitBounds::new(max_trait_bounds));\n+    store.register_late_pass(|| box comparison_chain::ComparisonChain);\n+    store.register_late_pass(|| box mut_key::MutableKeyType);\n+    store.register_late_pass(|| box modulo_arithmetic::ModuloArithmetic);\n+    store.register_early_pass(|| box reference::DerefAddrOf);\n+    store.register_early_pass(|| box reference::RefInDeref);\n+    store.register_early_pass(|| box double_parens::DoubleParens);\n+    store.register_late_pass(|| box to_string_in_display::ToStringInDisplay::new());\n+    store.register_early_pass(|| box unsafe_removed_from_name::UnsafeNameRemoval);\n+    store.register_early_pass(|| box if_not_else::IfNotElse);\n+    store.register_early_pass(|| box else_if_without_else::ElseIfWithoutElse);\n+    store.register_early_pass(|| box int_plus_one::IntPlusOne);\n+    store.register_early_pass(|| box formatting::Formatting);\n+    store.register_early_pass(|| box misc_early::MiscEarlyLints);\n+    store.register_early_pass(|| box redundant_closure_call::RedundantClosureCall);\n+    store.register_late_pass(|| box redundant_closure_call::RedundantClosureCall);\n+    store.register_early_pass(|| box unused_unit::UnusedUnit);\n+    store.register_late_pass(|| box returns::Return);\n+    store.register_early_pass(|| box collapsible_if::CollapsibleIf);\n+    store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n+    store.register_early_pass(|| box precedence::Precedence);\n+    store.register_early_pass(|| box needless_continue::NeedlessContinue);\n+    store.register_early_pass(|| box redundant_else::RedundantElse);\n+    store.register_late_pass(|| box create_dir::CreateDir);\n+    store.register_early_pass(|| box needless_arbitrary_self_type::NeedlessArbitrarySelfType);\n+    let cargo_ignore_publish = conf.cargo_ignore_publish;\n+    store.register_late_pass(move || box cargo_common_metadata::CargoCommonMetadata::new(cargo_ignore_publish));\n+    store.register_late_pass(|| box multiple_crate_versions::MultipleCrateVersions);\n+    store.register_late_pass(|| box wildcard_dependencies::WildcardDependencies);\n+    let literal_representation_lint_fraction_readability = conf.unreadable_literal_lint_fractions;\n+    store.register_early_pass(move || box literal_representation::LiteralDigitGrouping::new(literal_representation_lint_fraction_readability));\n+    let literal_representation_threshold = conf.literal_representation_threshold;\n+    store.register_early_pass(move || box literal_representation::DecimalLiteralRepresentation::new(literal_representation_threshold));\n+    let enum_variant_name_threshold = conf.enum_variant_name_threshold;\n+    store.register_late_pass(move || box enum_variants::EnumVariantNames::new(enum_variant_name_threshold, avoid_breaking_exported_api));\n+    store.register_early_pass(|| box tabs_in_doc_comments::TabsInDocComments);\n+    let upper_case_acronyms_aggressive = conf.upper_case_acronyms_aggressive;\n+    store.register_late_pass(move || box upper_case_acronyms::UpperCaseAcronyms::new(avoid_breaking_exported_api, upper_case_acronyms_aggressive));\n+    store.register_late_pass(|| box default::Default::default());\n+    store.register_late_pass(|| box unused_self::UnusedSelf);\n+    store.register_late_pass(|| box mutable_debug_assertion::DebugAssertWithMutCall);\n+    store.register_late_pass(|| box exit::Exit);\n+    store.register_late_pass(|| box to_digit_is_some::ToDigitIsSome);\n+    let array_size_threshold = conf.array_size_threshold;\n+    store.register_late_pass(move || box large_stack_arrays::LargeStackArrays::new(array_size_threshold));\n+    store.register_late_pass(move || box large_const_arrays::LargeConstArrays::new(array_size_threshold));\n+    store.register_late_pass(|| box floating_point_arithmetic::FloatingPointArithmetic);\n+    store.register_early_pass(|| box as_conversions::AsConversions);\n+    store.register_late_pass(|| box let_underscore::LetUnderscore);\n+    store.register_late_pass(|| box atomic_ordering::AtomicOrdering);\n+    store.register_early_pass(|| box single_component_path_imports::SingleComponentPathImports);\n+    let max_fn_params_bools = conf.max_fn_params_bools;\n+    let max_struct_bools = conf.max_struct_bools;\n+    store.register_early_pass(move || box excessive_bools::ExcessiveBools::new(max_struct_bools, max_fn_params_bools));\n+    store.register_early_pass(|| box option_env_unwrap::OptionEnvUnwrap);\n+    let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n+    store.register_late_pass(move || box wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports));\n+    store.register_late_pass(|| box verbose_file_reads::VerboseFileReads);\n+    store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n+    store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n+    store.register_late_pass(|| box dereference::Dereferencing::default());\n+    store.register_late_pass(|| box option_if_let_else::OptionIfLetElse);\n+    store.register_late_pass(|| box future_not_send::FutureNotSend);\n+    store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n+    store.register_late_pass(|| box mut_mutex_lock::MutMutexLock);\n+    store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n+    store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n+    store.register_late_pass(|| box vec_resize_to_zero::VecResizeToZero);\n+    store.register_late_pass(|| box panic_in_result_fn::PanicInResultFn);\n+    let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n+    store.register_early_pass(move || box non_expressive_names::NonExpressiveNames {\n+        single_char_binding_names_threshold,\n+    });\n+    store.register_late_pass(|| box macro_use::MacroUseImports::default());\n+    store.register_late_pass(|| box map_identity::MapIdentity);\n+    store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n+    store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n+    store.register_late_pass(|| box repeat_once::RepeatOnce);\n+    store.register_late_pass(|| box unwrap_in_result::UnwrapInResult);\n+    store.register_late_pass(|| box self_assignment::SelfAssignment);\n+    store.register_late_pass(|| box manual_unwrap_or::ManualUnwrapOr);\n+    store.register_late_pass(|| box manual_ok_or::ManualOkOr);\n+    store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n+    store.register_late_pass(|| box semicolon_if_nothing_returned::SemicolonIfNothingReturned);\n+    store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n+    let disallowed_methods = conf.disallowed_methods.iter().cloned().collect::<FxHashSet<_>>();\n+    store.register_late_pass(move || box disallowed_method::DisallowedMethod::new(&disallowed_methods));\n+    store.register_early_pass(|| box asm_syntax::InlineAsmX86AttSyntax);\n+    store.register_early_pass(|| box asm_syntax::InlineAsmX86IntelSyntax);\n+    store.register_late_pass(|| box undropped_manually_drops::UndroppedManuallyDrops);\n+    store.register_late_pass(|| box strings::StrToString);\n+    store.register_late_pass(|| box strings::StringToString);\n+    store.register_late_pass(|| box zero_sized_map_values::ZeroSizedMapValues);\n+    store.register_late_pass(|| box vec_init_then_push::VecInitThenPush::default());\n+    store.register_late_pass(|| box case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons);\n+    store.register_late_pass(|| box redundant_slicing::RedundantSlicing);\n+    store.register_late_pass(|| box from_str_radix_10::FromStrRadix10);\n+    store.register_late_pass(|| box manual_map::ManualMap);\n+    store.register_late_pass(move || box if_then_some_else_none::IfThenSomeElseNone::new(msrv));\n+    store.register_early_pass(|| box bool_assert_comparison::BoolAssertComparison);\n+    store.register_late_pass(|| box unused_async::UnusedAsync);\n \n-    store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n-        LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n-        LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n-        LintId::of(disallowed_method::DISALLOWED_METHOD),\n-        LintId::of(fallible_impl_from::FALLIBLE_IMPL_FROM),\n-        LintId::of(floating_point_arithmetic::IMPRECISE_FLOPS),\n-        LintId::of(floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n-        LintId::of(future_not_send::FUTURE_NOT_SEND),\n-        LintId::of(let_if_seq::USELESS_LET_IF_SEQ),\n-        LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n-        LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n-        LintId::of(mutex_atomic::MUTEX_INTEGER),\n-        LintId::of(needless_borrow::NEEDLESS_BORROW),\n-        LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n-        LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n-        LintId::of(regex::TRIVIAL_REGEX),\n-        LintId::of(strings::STRING_LIT_AS_BYTES),\n-        LintId::of(transmute::USELESS_TRANSMUTE),\n-        LintId::of(use_self::USE_SELF),\n-    ]);\n }\n \n #[rustfmt::skip]"}, {"sha": "5ae68ba5b2fe76a8c6fe8f69ed5623fa58d69e3b", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -205,7 +205,7 @@ fn could_use_elision<'tcx>(\n         output_visitor.visit_ty(ty);\n     }\n     for lt in named_generics {\n-        input_visitor.visit_generic_param(lt)\n+        input_visitor.visit_generic_param(lt);\n     }\n \n     if input_visitor.abort() || output_visitor.abort() {\n@@ -463,7 +463,7 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n         // `'b` in `'a: 'b` is useless unless used elsewhere in\n         // a non-lifetime bound\n         if let GenericParamKind::Type { .. } = param.kind {\n-            walk_generic_param(self, param)\n+            walk_generic_param(self, param);\n         }\n     }\n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "e0c5578bd603f5cb3c84c020929ddc31495e95ca", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -231,7 +231,7 @@ impl EarlyLintPass for LiteralDigitGrouping {\n         }\n \n         if let ExprKind::Lit(ref lit) = expr.kind {\n-            self.check_lit(cx, lit)\n+            self.check_lit(cx, lit);\n         }\n     }\n }\n@@ -294,7 +294,7 @@ impl LiteralDigitGrouping {\n                         }\n                     };\n                     if should_warn {\n-                        warning_type.display(num_lit.format(), cx, lit.span)\n+                        warning_type.display(num_lit.format(), cx, lit.span);\n                     }\n                 }\n             }\n@@ -424,7 +424,7 @@ impl EarlyLintPass for DecimalLiteralRepresentation {\n         }\n \n         if let ExprKind::Lit(ref lit) = expr.kind {\n-            self.check_lit(cx, lit)\n+            self.check_lit(cx, lit);\n         }\n     }\n }\n@@ -446,7 +446,7 @@ impl DecimalLiteralRepresentation {\n                 let hex = format!(\"{:#X}\", val);\n                 let num_lit = NumericLiteral::new(&hex, num_lit.suffix, false);\n                 let _ = Self::do_lint(num_lit.integer).map_err(|warning_type| {\n-                    warning_type.display(num_lit.format(), cx, lit.span)\n+                    warning_type.display(num_lit.format(), cx, lit.span);\n                 });\n             }\n         }"}, {"sha": "f0327b5d7777e13efccba67e78ea0266597bb83e", "filename": "clippy_lints/src/loops/explicit_iter_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -43,7 +43,7 @@ pub(super) fn check(cx: &LateContext<'_>, self_arg: &Expr<'_>, arg: &Expr<'_>, m\n         \"to write this more concisely, try\",\n         format!(\"&{}{}\", muta, object),\n         applicability,\n-    )\n+    );\n }\n \n /// Returns `true` if the type of expr is one that provides `IntoIterator` impls"}, {"sha": "d07b5a93b67c0505a6bda0238e287cda8a7ee4ca", "filename": "clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -88,10 +88,10 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n         if let ty::BorrowKind::MutBorrow = bk {\n             if let PlaceBase::Local(id) = cmt.place.base {\n                 if Some(id) == self.hir_id_low {\n-                    self.span_low = Some(self.cx.tcx.hir().span(diag_expr_id))\n+                    self.span_low = Some(self.cx.tcx.hir().span(diag_expr_id));\n                 }\n                 if Some(id) == self.hir_id_high {\n-                    self.span_high = Some(self.cx.tcx.hir().span(diag_expr_id))\n+                    self.span_high = Some(self.cx.tcx.hir().span(diag_expr_id));\n                 }\n             }\n         }\n@@ -100,10 +100,10 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n     fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>, diag_expr_id: HirId) {\n         if let PlaceBase::Local(id) = cmt.place.base {\n             if Some(id) == self.hir_id_low {\n-                self.span_low = Some(self.cx.tcx.hir().span(diag_expr_id))\n+                self.span_low = Some(self.cx.tcx.hir().span(diag_expr_id));\n             }\n             if Some(id) == self.hir_id_high {\n-                self.span_high = Some(self.cx.tcx.hir().span(diag_expr_id))\n+                self.span_high = Some(self.cx.tcx.hir().span(diag_expr_id));\n             }\n         }\n     }"}, {"sha": "eb82c9c27c3e192306bb34e502f9b41556ba2468", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,5 +1,5 @@\n use super::NEEDLESS_COLLECT;\n-use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n@@ -116,9 +116,10 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                     // Suggest replacing iter_call with iter_replacement, and removing stmt\n                     let mut span = MultiSpan::from_span(collect_span);\n                     span.push_span_label(iter_call.span, \"the iterator could be used here instead\".into());\n-                    span_lint_and_then(\n+                    span_lint_hir_and_then(\n                         cx,\n                         super::NEEDLESS_COLLECT,\n+                        init_expr.hir_id,\n                         span,\n                         NEEDLESS_COLLECT_MSG,\n                         |diag| {"}, {"sha": "0f6cd5de761f9d394402900b5079fa9ea8ee6ff6", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -35,7 +35,7 @@ pub(super) fn check<'tcx>(\n                 \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n                 item_str, vec_str, item_str\n             ),\n-        )\n+        );\n     }\n \n     if !matches!(pat.kind, PatKind::Wild) {"}, {"sha": "2f7360210ba4de7918204c49434a6cf0a5ecd8f3", "filename": "clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -80,10 +80,10 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                         }\n                     },\n                     ExprKind::Assign(lhs, _, _) if lhs.hir_id == expr.hir_id => {\n-                        *state = IncrementVisitorVarState::DontWarn\n+                        *state = IncrementVisitorVarState::DontWarn;\n                     },\n                     ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n-                        *state = IncrementVisitorVarState::DontWarn\n+                        *state = IncrementVisitorVarState::DontWarn;\n                     },\n                     _ => (),\n                 }\n@@ -207,7 +207,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n                         }\n                     },\n                     ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n-                        self.state = InitializeVisitorState::DontWarn\n+                        self.state = InitializeVisitorState::DontWarn;\n                     },\n                     _ => (),\n                 }\n@@ -292,7 +292,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n                 return;\n             }\n         }\n-        walk_pat(self, pat)\n+        walk_pat(self, pat);\n     }\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "5f9ebad25e893614ccc22ae9b31836949b3187ea", "filename": "clippy_lints/src/loops/while_immutable_condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,5 +1,5 @@\n use super::WHILE_IMMUTABLE_CONDITION;\n-use crate::consts::constant;\n+use clippy_utils::consts::constant;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::usage::mutated_variables;\n use if_chain::if_chain;"}, {"sha": "66479ae264e4fe32a2fbe23e183cf3ca8d7ba41c", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -212,9 +212,9 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n         let mut suggestions = vec![];\n         for ((root, span), path) in used {\n             if path.len() == 1 {\n-                suggestions.push((span, format!(\"{}::{}\", root, path[0])))\n+                suggestions.push((span, format!(\"{}::{}\", root, path[0])));\n             } else {\n-                suggestions.push((span, format!(\"{}::{{{}}}\", root, path.join(\", \"))))\n+                suggestions.push((span, format!(\"{}::{{{}}}\", root, path.join(\", \"))));\n             }\n         }\n \n@@ -231,7 +231,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n                     \"remove the attribute and import the macro directly, try\",\n                     help,\n                     Applicability::MaybeIncorrect,\n-                )\n+                );\n             }\n         }\n     }"}, {"sha": "61b5fe81fa9e64d5be38b40046bb2dbfc74a4330", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::usage::mutated_variables;\n@@ -123,7 +123,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n                                           kind_word,\n                                           snippet(cx, pattern.span, \"..\")))]\n                             .into_iter().chain(strippings.into_iter().map(|span| (span, \"<stripped>\".into()))),\n-                        )\n+                        );\n                     });\n                 }\n             }"}, {"sha": "18038dd7819430e004b547a5670b6b8a1a4b0af8", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::constant_simple;\n+use clippy_utils::consts::constant_simple;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;"}, {"sha": "e1f80ab025c0a35ff447e2ca2ea7cd0500814186", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -125,7 +125,7 @@ fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n         \"remove the `map` call\",\n         String::new(),\n         Applicability::MachineApplicable,\n-    )\n+    );\n }\n \n fn lint(cx: &LateContext<'_>, replace: Span, root: Span, copied: bool) {\n@@ -142,7 +142,7 @@ fn lint(cx: &LateContext<'_>, replace: Span, root: Span, copied: bool) {\n                 snippet_with_applicability(cx, root, \"..\", &mut applicability)\n             ),\n             applicability,\n-        )\n+        );\n     } else {\n         span_lint_and_sugg(\n             cx,\n@@ -155,6 +155,6 @@ fn lint(cx: &LateContext<'_>, replace: Span, root: Span, copied: bool) {\n                 snippet_with_applicability(cx, root, \"..\", &mut applicability)\n             ),\n             applicability,\n-        )\n+        );\n     }\n }"}, {"sha": "cd3e3b97928af8cffc423b9961c21e1ade38d351", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, miri_to_const, Constant};\n+use clippy_utils::consts::{constant, miri_to_const, Constant};\n use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n@@ -1144,7 +1144,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n                 \"try this\",\n                 suggestions.join(\" | \"),\n                 Applicability::MaybeIncorrect,\n-            )\n+            );\n         },\n     };\n }\n@@ -1242,7 +1242,7 @@ fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n                     cast,\n                 ),\n                 applicability,\n-            )\n+            );\n         }\n     }\n }\n@@ -1494,7 +1494,7 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n                     \"consider using the scrutinee and body instead\",\n                     sugg,\n                     applicability,\n-                )\n+                );\n             } else {\n                 span_lint_and_sugg(\n                     cx,\n@@ -1747,7 +1747,7 @@ mod redundant_pattern_match {\n             match match_source {\n                 MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n                 MatchSource::IfLetDesugar { contains_else_clause } => {\n-                    find_sugg_for_if_let(cx, expr, op, &arms[0], \"if\", *contains_else_clause)\n+                    find_sugg_for_if_let(cx, expr, op, &arms[0], \"if\", *contains_else_clause);\n                 },\n                 MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, &arms[0], \"while\", false),\n                 _ => {},\n@@ -1876,7 +1876,7 @@ mod redundant_pattern_match {\n                             {\n                                 self.res = true;\n                             } else {\n-                                self.visit_expr(self_arg)\n+                                self.visit_expr(self_arg);\n                             }\n                         }\n                         args.iter().for_each(|arg| self.visit_expr(arg));"}, {"sha": "aca96e06ef2e779c9be14100770758b1ed88781e", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -7,7 +7,6 @@ use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use std::iter;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for calls of `mem::discriminant()` on a non-enum type.\n@@ -67,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for MemDiscriminant {\n                                 }\n                             }\n \n-                            let derefs: String = iter::repeat('*').take(derefs_needed).collect();\n+                            let derefs = \"*\".repeat(derefs_needed);\n                             diag.span_suggestion(\n                                 param.span,\n                                 \"try dereferencing\","}, {"sha": "da428a7b4879b955d4e6937a3dcf4039185f28a6", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -135,7 +135,7 @@ pub(crate) trait BindInsteadOfMap {\n                         .into_iter()\n                         .map(|(span1, span2)| (span1, snippet(cx, span2, \"_\").into())),\n                 ),\n-            )\n+            );\n         });\n         true\n     }"}, {"sha": "1a32af5dc7a386fdd5e03c3832e8c105d6fc47f8", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -8,7 +8,6 @@ use rustc_hir::{BindingAnnotation, Expr, ExprKind, MatchSource, Node, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, adjustment::Adjust};\n use rustc_span::symbol::{sym, Symbol};\n-use std::iter;\n \n use super::CLONE_DOUBLE_REF;\n use super::CLONE_ON_COPY;\n@@ -54,8 +53,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol,\n                             ty = inner;\n                             n += 1;\n                         }\n-                        let refs: String = iter::repeat('&').take(n + 1).collect();\n-                        let derefs: String = iter::repeat('*').take(n).collect();\n+                        let refs = \"&\".repeat(n + 1);\n+                        let derefs = \"*\".repeat(n);\n                         let explicit = format!(\"<{}{}>::clone({})\", refs, ty, snip);\n                         diag.span_suggestion(\n                             expr.span,"}, {"sha": "f5b4b6bf8ea2475e5e98b12d1dfe3b1c876e1fff", "filename": "clippy_lints/src/methods/cloned_instead_of_copied.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -41,5 +41,5 @@ pub fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span,\n         \"try\",\n         \"copied\".into(),\n         Applicability::MachineApplicable,\n-    )\n+    );\n }"}, {"sha": "32d40d97bf419debd6b7ee1bc9f7728e835a79c2", "filename": "clippy_lints/src/methods/flat_map_option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_option.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -30,5 +30,5 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, arg\n         \"try\",\n         \"filter_map\".into(),\n         Applicability::MachineApplicable,\n-    )\n+    );\n }"}, {"sha": "b4188d9ed3095324a415fd7d501dabb97dccbb1c", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -37,30 +37,43 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Exp\n }\n \n fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -> String {\n+    fn strip_angle_brackets(s: &str) -> Option<&str> {\n+        s.strip_prefix('<')?.strip_suffix('>')\n+    }\n+\n     let call_site = expr.span.source_callsite();\n     if_chain! {\n         if let Ok(snippet) = cx.sess().source_map().span_to_snippet(call_site);\n         let snippet_split = snippet.split(\"::\").collect::<Vec<_>>();\n         if let Some((_, elements)) = snippet_split.split_last();\n \n         then {\n-            // is there a type specifier? (i.e.: like `<u32>` in `collections::BTreeSet::<u32>::`)\n-            if let Some(type_specifier) = snippet_split.iter().find(|e| e.starts_with('<') && e.ends_with('>')) {\n-                // remove the type specifier from the path elements\n-                let without_ts = elements.iter().filter_map(|e| {\n-                    if e == type_specifier { None } else { Some((*e).to_string()) }\n-                }).collect::<Vec<_>>();\n-                // join and add the type specifier at the end (i.e.: `collections::BTreeSet<u32>`)\n-                format!(\"{}{}\", without_ts.join(\"::\"), type_specifier)\n-            } else {\n-                // type is not explicitly specified so wildcards are needed\n-                // i.e.: 2 wildcards in `std::collections::BTreeMap<&i32, &char>`\n-                let ty_str = ty.to_string();\n-                let start = ty_str.find('<').unwrap_or(0);\n-                let end = ty_str.find('>').unwrap_or_else(|| ty_str.len());\n-                let nb_wildcard = ty_str[start..end].split(',').count();\n-                let wildcards = format!(\"_{}\", \", _\".repeat(nb_wildcard - 1));\n-                format!(\"{}<{}>\", elements.join(\"::\"), wildcards)\n+            if_chain! {\n+                if let [type_specifier, _] = snippet_split.as_slice();\n+                if let Some(type_specifier) = strip_angle_brackets(type_specifier);\n+                if let Some((type_specifier, ..)) = type_specifier.split_once(\" as \");\n+                then {\n+                    type_specifier.to_string()\n+                } else {\n+                    // is there a type specifier? (i.e.: like `<u32>` in `collections::BTreeSet::<u32>::`)\n+                    if let Some(type_specifier) = snippet_split.iter().find(|e| strip_angle_brackets(e).is_some()) {\n+                        // remove the type specifier from the path elements\n+                        let without_ts = elements.iter().filter_map(|e| {\n+                            if e == type_specifier { None } else { Some((*e).to_string()) }\n+                        }).collect::<Vec<_>>();\n+                        // join and add the type specifier at the end (i.e.: `collections::BTreeSet<u32>`)\n+                        format!(\"{}{}\", without_ts.join(\"::\"), type_specifier)\n+                    } else {\n+                        // type is not explicitly specified so wildcards are needed\n+                        // i.e.: 2 wildcards in `std::collections::BTreeMap<&i32, &char>`\n+                        let ty_str = ty.to_string();\n+                        let start = ty_str.find('<').unwrap_or(0);\n+                        let end = ty_str.find('>').unwrap_or_else(|| ty_str.len());\n+                        let nb_wildcard = ty_str[start..end].split(',').count();\n+                        let wildcards = format!(\"_{}\", \", _\".repeat(nb_wildcard - 1));\n+                        format!(\"{}<{}>\", elements.join(\"::\"), wildcards)\n+                    }\n+                }\n             }\n         } else {\n             ty.to_string()"}, {"sha": "68d906c3ea3999823796a7d89d8c894e85703d0b", "filename": "clippy_lints/src/methods/iter_nth_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::is_trait_method;\n use clippy_utils::source::snippet_with_applicability;"}, {"sha": "64c09214a7683a9df109dbac6d1c1afc98ffe159", "filename": "clippy_lints/src/methods/iterator_step_by_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::is_trait_method;\n use rustc_hir as hir;"}, {"sha": "919e2628c523cf2c75da29f965a066c4b1da15b2", "filename": "clippy_lints/src/methods/manual_str_repeat.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,99 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n+use clippy_utils::{is_expr_path_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, LangItem};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_span::symbol::sym;\n+use std::borrow::Cow;\n+\n+use super::MANUAL_STR_REPEAT;\n+\n+enum RepeatKind {\n+    String,\n+    Char(char),\n+}\n+\n+fn get_ty_param(ty: Ty<'_>) -> Option<Ty<'_>> {\n+    if let ty::Adt(_, subs) = ty.kind() {\n+        subs.types().next()\n+    } else {\n+        None\n+    }\n+}\n+\n+fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n+    if let ExprKind::Lit(lit) = &e.kind {\n+        match lit.node {\n+            LitKind::Str(..) => Some(RepeatKind::String),\n+            LitKind::Char(c) => Some(RepeatKind::Char(c)),\n+            _ => None,\n+        }\n+    } else {\n+        let ty = cx.typeck_results().expr_ty(e);\n+        if is_type_diagnostic_item(cx, ty, sym::string_type)\n+            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, TyS::is_str))\n+            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, TyS::is_str))\n+        {\n+            Some(RepeatKind::String)\n+        } else {\n+            let ty = ty.peel_refs();\n+            (ty.is_str() || is_type_diagnostic_item(cx, ty, sym::string_type)).then(|| RepeatKind::String)\n+        }\n+    }\n+}\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    collect_expr: &Expr<'_>,\n+    take_expr: &Expr<'_>,\n+    take_self_arg: &Expr<'_>,\n+    take_arg: &Expr<'_>,\n+) {\n+    if_chain! {\n+        if let ExprKind::Call(repeat_fn, [repeat_arg]) = take_self_arg.kind;\n+        if is_expr_path_def_path(cx, repeat_fn, &paths::ITER_REPEAT);\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(collect_expr), sym::string_type);\n+        if let Some(collect_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id);\n+        if let Some(take_id) = cx.typeck_results().type_dependent_def_id(take_expr.hir_id);\n+        if let Some(iter_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+        if cx.tcx.trait_of_item(collect_id) == Some(iter_trait_id);\n+        if cx.tcx.trait_of_item(take_id) == Some(iter_trait_id);\n+        if let Some(repeat_kind) = parse_repeat_arg(cx, repeat_arg);\n+        let ctxt = collect_expr.span.ctxt();\n+        if ctxt == take_expr.span.ctxt();\n+        if ctxt == take_self_arg.span.ctxt();\n+        then {\n+            let mut app = Applicability::MachineApplicable;\n+            let count_snip = snippet_with_context(cx, take_arg.span, ctxt, \"..\", &mut app).0;\n+\n+            let val_str = match repeat_kind {\n+                RepeatKind::Char(_) if repeat_arg.span.ctxt() != ctxt => return,\n+                RepeatKind::Char('\\'') => r#\"\"'\"\"#.into(),\n+                RepeatKind::Char('\"') => r#\"\"\\\"\"\"#.into(),\n+                RepeatKind::Char(_) =>\n+                    match snippet_with_applicability(cx, repeat_arg.span, \"..\", &mut app) {\n+                        Cow::Owned(s) => Cow::Owned(format!(\"\\\"{}\\\"\", &s[1..s.len() - 1])),\n+                        s @ Cow::Borrowed(_) => s,\n+                    },\n+                RepeatKind::String =>\n+                    Sugg::hir_with_context(cx, repeat_arg, ctxt, \"..\", &mut app).maybe_par().to_string().into(),\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_STR_REPEAT,\n+                collect_expr.span,\n+                \"manual implementation of `str::repeat` using iterators\",\n+                \"try this\",\n+                format!(\"{}.repeat({})\", val_str, count_snip),\n+                app\n+            )\n+        }\n+    }\n+}"}, {"sha": "c8ae972f18ca62a5d4ba0f3e19ca803fa4169f7a", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 79, "deletions": 36, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -32,6 +32,7 @@ mod iter_nth_zero;\n mod iter_skip_next;\n mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n+mod manual_str_repeat;\n mod map_collect_result_unit;\n mod map_flatten;\n mod map_unwrap_or;\n@@ -48,6 +49,7 @@ mod single_char_push_string;\n mod skip_while_next;\n mod string_extend_chars;\n mod suspicious_map;\n+mod suspicious_splitn;\n mod uninit_assumed_init;\n mod unnecessary_filter_map;\n mod unnecessary_fold;\n@@ -61,7 +63,7 @@ mod zst_offset;\n use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, paths, return_ty};\n+use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -282,30 +284,6 @@ declare_clippy_lint! {\n     \"defining a method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** This is the same as\n-    /// [`wrong_self_convention`](#wrong_self_convention), but for public items.\n-    ///\n-    /// **Why is this bad?** See [`wrong_self_convention`](#wrong_self_convention).\n-    ///\n-    /// **Known problems:** Actually *renaming* the function may break clients if\n-    /// the function is part of the public interface. In that case, be mindful of\n-    /// the stability guarantees you've given your users.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # struct X;\n-    /// impl<'a> X {\n-    ///     pub fn as_str(self) -> &'a str {\n-    ///         \"foo\"\n-    ///     }\n-    /// }\n-    /// ```\n-    pub WRONG_PUB_SELF_CONVENTION,\n-    restriction,\n-    \"defining a public method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\"\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `ok().expect(..)`.\n     ///\n@@ -1657,14 +1635,69 @@ declare_clippy_lint! {\n     \"replace `.iter().count()` with `.len()`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to [`splitn`]\n+    /// (https://doc.rust-lang.org/std/primitive.str.html#method.splitn) and\n+    /// related functions with either zero or one splits.\n+    ///\n+    /// **Why is this bad?** These calls don't actually split the value and are\n+    /// likely to be intended as a different number.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// let s = \"\";\n+    /// for x in s.splitn(1, \":\") {\n+    ///     // use x\n+    /// }\n+    ///\n+    /// // Good\n+    /// let s = \"\";\n+    /// for x in s.splitn(2, \":\") {\n+    ///     // use x\n+    /// }\n+    /// ```\n+    pub SUSPICIOUS_SPLITN,\n+    correctness,\n+    \"checks for `.splitn(0, ..)` and `.splitn(1, ..)`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for manual implementations of `str::repeat`\n+    ///\n+    /// **Why is this bad?** These are both harder to read, as well as less performant.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// let x: String = std::iter::repeat('x').take(10).collect();\n+    ///\n+    /// // Good\n+    /// let x: String = \"x\".repeat(10);\n+    /// ```\n+    pub MANUAL_STR_REPEAT,\n+    perf,\n+    \"manual implementation of `str::repeat`\"\n+}\n+\n pub struct Methods {\n+    avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n }\n \n impl Methods {\n     #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n+    pub fn new(avoid_breaking_exported_api: bool, msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            avoid_breaking_exported_api,\n+            msrv,\n+        }\n     }\n }\n \n@@ -1673,7 +1706,6 @@ impl_lint_pass!(Methods => [\n     EXPECT_USED,\n     SHOULD_IMPLEMENT_TRAIT,\n     WRONG_SELF_CONVENTION,\n-    WRONG_PUB_SELF_CONVENTION,\n     OK_EXPECT,\n     MAP_UNWRAP_OR,\n     RESULT_MAP_OR_INTO_OPTION,\n@@ -1726,7 +1758,9 @@ impl_lint_pass!(Methods => [\n     MAP_COLLECT_RESULT_UNIT,\n     FROM_ITER_INSTEAD_OF_COLLECT,\n     INSPECT_FOR_EACH,\n-    IMPLICIT_CLONE\n+    IMPLICIT_CLONE,\n+    SUSPICIOUS_SPLITN,\n+    MANUAL_STR_REPEAT\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -1838,11 +1872,13 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     }\n                 }\n \n-                if sig.decl.implicit_self.has_implicit_self() {\n+                if sig.decl.implicit_self.has_implicit_self()\n+                    && !(self.avoid_breaking_exported_api\n+                        && cx.access_levels.is_exported(impl_item.hir_id()))\n+                {\n                     wrong_self_convention::check(\n                         cx,\n                         &name,\n-                        item.vis.node.is_pub(),\n                         self_ty,\n                         first_arg_ty,\n                         first_arg.pat.span,\n@@ -1915,7 +1951,6 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 wrong_self_convention::check(\n                     cx,\n                     &item.ident.name.as_str(),\n-                    false,\n                     self_ty,\n                     first_arg_ty,\n                     first_arg_span,\n@@ -1951,7 +1986,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n     if let Some((name, [recv, args @ ..], span)) = method_call!(expr) {\n         match (name, args) {\n             (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [recv, _]) => {\n-                zst_offset::check(cx, expr, recv)\n+                zst_offset::check(cx, expr, recv);\n             },\n             (\"and_then\", [arg]) => {\n                 let biom_option_linted = bind_instead_of_map::OptionAndThenSome::check(cx, expr, recv, arg);\n@@ -1969,6 +2004,11 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 Some((\"map\", [m_recv, m_arg], _)) => {\n                     map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n                 },\n+                Some((\"take\", [take_self_arg, take_arg], _)) => {\n+                    if meets_msrv(msrv, &msrvs::STR_REPEAT) {\n+                        manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n+                    }\n+                },\n                 _ => {},\n             },\n             (\"count\", []) => match method_call!(recv) {\n@@ -2012,7 +2052,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                         (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, msrv),\n                         (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, msrv),\n                         (\"filter\", [f_arg]) => {\n-                            filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, false)\n+                            filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, false);\n                         },\n                         (\"find\", [f_arg]) => filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, true),\n                         _ => {},\n@@ -2044,6 +2084,9 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n                 }\n             },\n+            (\"splitn\" | \"splitn_mut\" | \"rsplitn\" | \"rsplitn_mut\", [count_arg, _]) => {\n+                suspicious_splitn::check(cx, name, expr, recv, count_arg);\n+            },\n             (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n             (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n                 implicit_clone::check(cx, name, expr, recv, span);\n@@ -2058,7 +2101,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                 },\n                 Some((\"map\", [m_recv, m_arg], span)) => {\n-                    option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span)\n+                    option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span);\n                 },\n                 _ => {},\n             },\n@@ -2073,7 +2116,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n \n fn check_is_some_is_none(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, is_some: bool) {\n     if let Some((name @ (\"find\" | \"position\" | \"rposition\"), [f_recv, arg], span)) = method_call!(recv) {\n-        search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span)\n+        search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span);\n     }\n }\n "}, {"sha": "a271df60572a22f0969910f22a5bc1c1828dabca", "filename": "clippy_lints/src/methods/suspicious_splitn.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,56 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use if_chain::if_chain;\n+use rustc_ast::LitKind;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Spanned;\n+\n+use super::SUSPICIOUS_SPLITN;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    method_name: &str,\n+    expr: &Expr<'_>,\n+    self_arg: &Expr<'_>,\n+    count_arg: &Expr<'_>,\n+) {\n+    if_chain! {\n+        if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg);\n+        if count <= 1;\n+        if let Some(call_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(impl_id) = cx.tcx.impl_of_method(call_id);\n+        let lang_items = cx.tcx.lang_items();\n+        if lang_items.slice_impl() == Some(impl_id) || lang_items.str_impl() == Some(impl_id);\n+        then {\n+            // Ignore empty slice and string literals when used with a literal count.\n+            if (matches!(self_arg.kind, ExprKind::Array([]))\n+                || matches!(self_arg.kind, ExprKind::Lit(Spanned { node: LitKind::Str(s, _), .. }) if s.is_empty())\n+            ) && matches!(count_arg.kind, ExprKind::Lit(_))\n+            {\n+                return;\n+            }\n+\n+            let (msg, note_msg) = if count == 0 {\n+                (format!(\"`{}` called with `0` splits\", method_name),\n+                \"the resulting iterator will always return `None`\")\n+            } else {\n+                (format!(\"`{}` called with `1` split\", method_name),\n+                if lang_items.slice_impl() == Some(impl_id) {\n+                    \"the resulting iterator will always return the entire slice followed by `None`\"\n+                } else {\n+                    \"the resulting iterator will always return the entire string followed by `None`\"\n+                })\n+            };\n+\n+            span_lint_and_note(\n+                cx,\n+                SUSPICIOUS_SPLITN,\n+                expr.span,\n+                &msg,\n+                None,\n+                note_msg,\n+            );\n+        }\n+    }\n+}"}, {"sha": "4c4034437da51601337af3aec9c36ca57a237ab0", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -87,7 +87,7 @@ pub(super) fn check(\n             ast::LitKind::Bool(true) => check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::And, \"all\", true),\n             ast::LitKind::Int(0, _) => check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::Add, \"sum\", false),\n             ast::LitKind::Int(1, _) => {\n-                check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::Mul, \"product\", false)\n+                check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::Mul, \"product\", false);\n             },\n             _ => (),\n         }"}, {"sha": "a2e09e5ecec1f3334766d163236dfac3b1a01524", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -6,7 +6,6 @@ use rustc_middle::ty::TyS;\n use rustc_span::source_map::Span;\n use std::fmt;\n \n-use super::WRONG_PUB_SELF_CONVENTION;\n use super::WRONG_SELF_CONVENTION;\n \n #[rustfmt::skip]\n@@ -21,9 +20,9 @@ const CONVENTIONS: [(&[Convention], &[SelfKind]); 9] = [\n \n     // Conversion using `to_` can use borrowed (non-Copy types) or owned (Copy types).\n     // Source: https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n-    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(false), \n+    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(false),\n     Convention::IsTraitItem(false), Convention::ImplementsTrait(false)], &[SelfKind::Ref]),\n-    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(true), \n+    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(true),\n     Convention::IsTraitItem(false), Convention::ImplementsTrait(false)], &[SelfKind::Value]),\n ];\n \n@@ -85,18 +84,12 @@ impl fmt::Display for Convention {\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     item_name: &str,\n-    is_pub: bool,\n     self_ty: &'tcx TyS<'tcx>,\n     first_arg_ty: &'tcx TyS<'tcx>,\n     first_arg_span: Span,\n     implements_trait: bool,\n     is_trait_item: bool,\n ) {\n-    let lint = if is_pub {\n-        WRONG_PUB_SELF_CONVENTION\n-    } else {\n-        WRONG_SELF_CONVENTION\n-    };\n     if let Some((conventions, self_kinds)) = &CONVENTIONS.iter().find(|(convs, _)| {\n         convs\n             .iter()\n@@ -142,7 +135,7 @@ pub(super) fn check<'tcx>(\n \n             span_lint_and_help(\n                 cx,\n-                lint,\n+                WRONG_SELF_CONVENTION,\n                 first_arg_span,\n                 &format!(\n                     \"{} usually take {}\","}, {"sha": "ff3473b744e476e1a58df01393b52d4849c4a961", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant_simple, Constant};\n+use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::{match_def_path, match_trait_method, paths};\n use if_chain::if_chain;"}, {"sha": "804c04fe1b838894926bdfe1d1b54713b70667b4", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -17,7 +17,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{ExpnKind, Span};\n use rustc_span::symbol::sym;\n \n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n     expr_path_res, get_item_name, get_parent_expr, higher, in_constant, is_diag_trait_item, is_integer_const,\n@@ -355,8 +355,10 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             if binop.node == BinOpKind::And || binop.node == BinOpKind::Or;\n             if let Some(sugg) = Sugg::hir_opt(cx, a);\n             then {\n-                span_lint_and_then(cx,\n+                span_lint_hir_and_then(\n+                    cx,\n                     SHORT_CIRCUIT_STATEMENT,\n+                    expr.hir_id,\n                     stmt.span,\n                     \"boolean short circuit operator in statement may be clearer using an explicit test\",\n                     |diag| {"}, {"sha": "050b6805b7c98ddacdfde159d89ffce30ac5d825", "filename": "clippy_lints/src/misc_early/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -310,7 +310,7 @@ impl EarlyLintPass for MiscEarlyLints {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        double_neg::check(cx, expr)\n+        double_neg::check(cx, expr);\n     }\n }\n \n@@ -334,15 +334,15 @@ impl MiscEarlyLints {\n             };\n             unseparated_literal_suffix::check(cx, lit, &lit_snip, suffix, \"integer\");\n             if lit_snip.starts_with(\"0x\") {\n-                mixed_case_hex_literals::check(cx, lit, suffix, &lit_snip)\n+                mixed_case_hex_literals::check(cx, lit, suffix, &lit_snip);\n             } else if lit_snip.starts_with(\"0b\") || lit_snip.starts_with(\"0o\") {\n-                /* nothing to do */\n+                // nothing to do\n             } else if value != 0 && lit_snip.starts_with('0') {\n-                zero_prefixed_literal::check(cx, lit, &lit_snip)\n+                zero_prefixed_literal::check(cx, lit, &lit_snip);\n             }\n         } else if let LitKind::Float(_, LitFloatType::Suffixed(float_ty)) = lit.kind {\n             let suffix = float_ty.name_str();\n-            unseparated_literal_suffix::check(cx, lit, &lit_snip, suffix, \"float\")\n+            unseparated_literal_suffix::check(cx, lit, &lit_snip, suffix, \"float\");\n         }\n     }\n }"}, {"sha": "ec1572c26c262acc21ace9b4e95479828d4d86cd", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -93,9 +93,9 @@ impl MissingDoc {\n             return;\n         }\n \n-        let has_doc = attrs.iter().any(|a| {\n-            a.is_doc_comment() || a.doc_str().is_some() || a.value_str().is_some() || Self::has_include(a.meta())\n-        });\n+        let has_doc = attrs\n+            .iter()\n+            .any(|a| a.doc_str().is_some() || Self::has_include(a.meta()));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "1414fdc1b114d6fcccc2a93a9e1ae2eb97b3e5ac", "filename": "clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::sext;\n use if_chain::if_chain;"}, {"sha": "6efe8ffcde03616bb11c2662ee0520e9ada8602a", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                 let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n-                check_arguments(cx, arguments, method_type, &path.ident.as_str(), \"method\")\n+                check_arguments(cx, arguments, method_type, &path.ident.as_str(), \"method\");\n             },\n             _ => (),\n         }"}, {"sha": "25645a0e7a2715545e3a91da60a3e3cc079e35b4", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n             _ if !self.found => self.expr_span = Some(expr.span),\n             _ => return,\n         }\n-        walk_expr(self, expr)\n+        walk_expr(self, expr);\n     }\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "fe3c4455be5e210821463f7628fdcb5dcc950279", "filename": "clippy_lints/src/needless_arbitrary_self_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -121,15 +121,15 @@ impl EarlyLintPass for NeedlessArbitrarySelfType {\n         match &p.ty.kind {\n             TyKind::Path(None, path) => {\n                 if let PatKind::Ident(BindingMode::ByValue(mutbl), _, _) = p.pat.kind {\n-                    check_param_inner(cx, path, p.span.to(p.ty.span), &Mode::Value, mutbl)\n+                    check_param_inner(cx, path, p.span.to(p.ty.span), &Mode::Value, mutbl);\n                 }\n             },\n             TyKind::Rptr(lifetime, mut_ty) => {\n                 if_chain! {\n                 if let TyKind::Path(None, path) = &mut_ty.ty.kind;\n                 if let PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, _) = p.pat.kind;\n                     then {\n-                        check_param_inner(cx, path, p.span.to(p.ty.span), &Mode::Ref(*lifetime), mut_ty.mutbl)\n+                        check_param_inner(cx, path, p.span.to(p.ty.span), &Mode::Ref(*lifetime), mut_ty.mutbl);\n                     }\n                 }\n             },"}, {"sha": "3b3736fd3a19114601421a34cd60e8cd0993f5b9", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -82,7 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                 }\n \n                 if is_else_clause(cx.tcx, e) {\n-                    snip = snip.blockify()\n+                    snip = snip.blockify();\n                 }\n \n                 span_lint_and_sugg(\n@@ -144,15 +144,15 @@ impl<'tcx> LateLintPass<'tcx> for BoolComparison {\n                         |h: Sugg<'_>| !h,\n                         \"equality checks against false can be replaced by a negation\",\n                     ));\n-                    check_comparison(cx, e, true_case, false_case, true_case, false_case, ignore_no_literal)\n+                    check_comparison(cx, e, true_case, false_case, true_case, false_case, ignore_no_literal);\n                 },\n                 BinOpKind::Ne => {\n                     let true_case = Some((\n                         |h: Sugg<'_>| !h,\n                         \"inequality checks against true can be replaced by a negation\",\n                     ));\n                     let false_case = Some((|h| h, \"inequality checks against false are unnecessary\"));\n-                    check_comparison(cx, e, true_case, false_case, true_case, false_case, ignore_no_literal)\n+                    check_comparison(cx, e, true_case, false_case, true_case, false_case, ignore_no_literal);\n                 },\n                 BinOpKind::Lt => check_comparison(\n                     cx,\n@@ -251,22 +251,22 @@ fn check_comparison<'a, 'tcx>(\n                             snippet_with_applicability(cx, expression_info.right_span, \"..\", &mut applicability)\n                         ),\n                         applicability,\n-                    )\n+                    );\n                 }\n             }\n \n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => left_true.map_or((), |(h, m)| {\n-                    suggest_bool_comparison(cx, e, right_side, applicability, m, h)\n+                    suggest_bool_comparison(cx, e, right_side, applicability, m, h);\n                 }),\n                 (Other, Bool(true)) => right_true.map_or((), |(h, m)| {\n-                    suggest_bool_comparison(cx, e, left_side, applicability, m, h)\n+                    suggest_bool_comparison(cx, e, left_side, applicability, m, h);\n                 }),\n                 (Bool(false), Other) => left_false.map_or((), |(h, m)| {\n-                    suggest_bool_comparison(cx, e, right_side, applicability, m, h)\n+                    suggest_bool_comparison(cx, e, right_side, applicability, m, h);\n                 }),\n                 (Other, Bool(false)) => right_false.map_or((), |(h, m)| {\n-                    suggest_bool_comparison(cx, e, left_side, applicability, m, h)\n+                    suggest_bool_comparison(cx, e, left_side, applicability, m, h);\n                 }),\n                 (Other, Other) => no_literal.map_or((), |(h, m)| {\n                     let left_side = Sugg::hir_with_applicability(cx, left_side, \"..\", &mut applicability);\n@@ -279,7 +279,7 @@ fn check_comparison<'a, 'tcx>(\n                         \"try simplifying it as shown\",\n                         h(left_side, right_side).to_string(),\n                         applicability,\n-                    )\n+                    );\n                 }),\n                 _ => (),\n             }"}, {"sha": "dd1dfa2bdfbcf6464e271653e98b2c57ebce99c9", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 176, "deletions": 43, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -3,16 +3,18 @@\n //! This lint is **warn** by default\n \n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::is_automatically_derived;\n-use clippy_utils::source::snippet_opt;\n+use clippy_utils::source::{snippet_opt, snippet_with_applicability, snippet_with_context};\n+use clippy_utils::{get_parent_expr, in_macro, path_to_local};\n use if_chain::if_chain;\n+use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, BorrowKind, Expr, ExprKind, Item, Mutability, Pat, PatKind};\n+use rustc_hir::{BindingAnnotation, Body, BodyId, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::def_id::LocalDefId;\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -32,20 +34,70 @@ declare_clippy_lint! {\n     /// let x: &i32 = &5;\n     /// ```\n     pub NEEDLESS_BORROW,\n-    nursery,\n+    style,\n     \"taking a reference that is going to be automatically dereferenced\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `ref` bindings which create a reference to a reference.\n+    ///\n+    /// **Why is this bad?** The address-of operator at the use site is clearer about the need for a reference.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let x = Some(\"\");\n+    /// if let Some(ref x) = x {\n+    ///     // use `x` here\n+    /// }\n+    ///\n+    /// // Good\n+    /// let x = Some(\"\");\n+    /// if let Some(x) = x {\n+    ///     // use `&x` here\n+    /// }\n+    /// ```\n+    pub REF_BINDING_TO_REFERENCE,\n+    pedantic,\n+    \"`ref` binding to a reference\"\n+}\n+\n+impl_lint_pass!(NeedlessBorrow => [NEEDLESS_BORROW, REF_BINDING_TO_REFERENCE]);\n #[derive(Default)]\n pub struct NeedlessBorrow {\n-    derived_item: Option<LocalDefId>,\n+    /// The body the first local was found in. Used to emit lints when the traversal of the body has\n+    /// been finished. Note we can't lint at the end of every body as they can be nested within each\n+    /// other.\n+    current_body: Option<BodyId>,\n+    /// The list of locals currently being checked by the lint.\n+    /// If the value is `None`, then the binding has been seen as a ref pattern, but is not linted.\n+    /// This is needed for or patterns where one of the branches can be linted, but another can not\n+    /// be.\n+    ///\n+    /// e.g. `m!(x) | Foo::Bar(ref x)`\n+    ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n }\n \n-impl_lint_pass!(NeedlessBorrow => [NEEDLESS_BORROW]);\n+struct RefPat {\n+    /// Whether every usage of the binding is dereferenced.\n+    always_deref: bool,\n+    /// The spans of all the ref bindings for this local.\n+    spans: Vec<Span>,\n+    /// The applicability of this suggestion.\n+    app: Applicability,\n+    /// All the replacements which need to be made.\n+    replacements: Vec<(Span, String)>,\n+}\n \n impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if e.span.from_expansion() || self.derived_item.is_some() {\n+        if let Some(local) = path_to_local(e) {\n+            self.check_local_usage(cx, e, local);\n+        }\n+\n+        if e.span.from_expansion() {\n             return;\n         }\n         if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = e.kind {\n@@ -85,50 +137,131 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n             }\n         }\n     }\n+\n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if pat.span.from_expansion() || self.derived_item.is_some() {\n-            return;\n+        if let PatKind::Binding(BindingAnnotation::Ref, id, name, _) = pat.kind {\n+            if let Some(opt_prev_pat) = self.ref_locals.get_mut(&id) {\n+                // This binding id has been seen before. Add this pattern to the list of changes.\n+                if let Some(prev_pat) = opt_prev_pat {\n+                    if in_macro(pat.span) {\n+                        // Doesn't match the context of the previous pattern. Can't lint here.\n+                        *opt_prev_pat = None;\n+                    } else {\n+                        prev_pat.spans.push(pat.span);\n+                        prev_pat.replacements.push((\n+                            pat.span,\n+                            snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut prev_pat.app)\n+                                .0\n+                                .into(),\n+                        ));\n+                    }\n+                }\n+                return;\n+            }\n+\n+            if_chain! {\n+                if !in_macro(pat.span);\n+                if let ty::Ref(_, tam, _) = *cx.typeck_results().pat_ty(pat).kind();\n+                // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n+                if let ty::Ref(_, _, Mutability::Not) = *tam.kind();\n+                then {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let snip = snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut app).0;\n+                    self.current_body = self.current_body.or(cx.enclosing_body);\n+                    self.ref_locals.insert(\n+                        id,\n+                        Some(RefPat {\n+                            always_deref: true,\n+                            spans: vec![pat.span],\n+                            app,\n+                            replacements: vec![(pat.span, snip.into())],\n+                        }),\n+                    );\n+                }\n+            }\n         }\n-        if_chain! {\n-            if let PatKind::Binding(BindingAnnotation::Ref, .., name, _) = pat.kind;\n-            if let ty::Ref(_, tam, mutbl) = *cx.typeck_results().pat_ty(pat).kind();\n-            if mutbl == Mutability::Not;\n-            if let ty::Ref(_, _, mutbl) = *tam.kind();\n-            // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n-            if mutbl == Mutability::Not;\n-            then {\n+    }\n+\n+    fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n+        if Some(body.id()) == self.current_body {\n+            for pat in self.ref_locals.drain(..).filter_map(|(_, x)| x) {\n+                let replacements = pat.replacements;\n+                let app = pat.app;\n                 span_lint_and_then(\n                     cx,\n-                    NEEDLESS_BORROW,\n-                    pat.span,\n+                    if pat.always_deref {\n+                        NEEDLESS_BORROW\n+                    } else {\n+                        REF_BINDING_TO_REFERENCE\n+                    },\n+                    pat.spans,\n                     \"this pattern creates a reference to a reference\",\n                     |diag| {\n-                        if let Some(snippet) = snippet_opt(cx, name.span) {\n-                            diag.span_suggestion(\n-                                pat.span,\n-                                \"change this to\",\n-                                snippet,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    }\n-                )\n+                        diag.multipart_suggestion(\"try this\", replacements, app);\n+                    },\n+                );\n             }\n+            self.current_body = None;\n         }\n     }\n-\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        if is_automatically_derived(attrs) {\n-            debug_assert!(self.derived_item.is_none());\n-            self.derived_item = Some(item.def_id);\n-        }\n-    }\n-\n-    fn check_item_post(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let Some(id) = self.derived_item {\n-            if item.def_id == id {\n-                self.derived_item = None;\n+}\n+impl NeedlessBorrow {\n+    fn check_local_usage(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, local: HirId) {\n+        if let Some(outer_pat) = self.ref_locals.get_mut(&local) {\n+            if let Some(pat) = outer_pat {\n+                // Check for auto-deref\n+                if !matches!(\n+                    cx.typeck_results().expr_adjustments(e),\n+                    [\n+                        Adjustment {\n+                            kind: Adjust::Deref(_),\n+                            ..\n+                        },\n+                        Adjustment {\n+                            kind: Adjust::Deref(_),\n+                            ..\n+                        },\n+                        ..\n+                    ]\n+                ) {\n+                    match get_parent_expr(cx, e) {\n+                        // Field accesses are the same no matter the number of references.\n+                        Some(Expr {\n+                            kind: ExprKind::Field(..),\n+                            ..\n+                        }) => (),\n+                        Some(&Expr {\n+                            span,\n+                            kind: ExprKind::Unary(UnOp::Deref, _),\n+                            ..\n+                        }) if !in_macro(span) => {\n+                            // Remove explicit deref.\n+                            let snip = snippet_with_context(cx, e.span, span.ctxt(), \"..\", &mut pat.app).0;\n+                            pat.replacements.push((span, snip.into()));\n+                        },\n+                        Some(parent) if !in_macro(parent.span) => {\n+                            // Double reference might be needed at this point.\n+                            if parent.precedence().order() == PREC_POSTFIX {\n+                                // Parentheses would be needed here, don't lint.\n+                                *outer_pat = None;\n+                            } else {\n+                                pat.always_deref = false;\n+                                let snip = snippet_with_context(cx, e.span, parent.span.ctxt(), \"..\", &mut pat.app).0;\n+                                pat.replacements.push((e.span, format!(\"&{}\", snip)));\n+                            }\n+                        },\n+                        _ if !in_macro(e.span) => {\n+                            // Double reference might be needed at this point.\n+                            pat.always_deref = false;\n+                            let snip = snippet_with_applicability(cx, e.span, \"..\", &mut pat.app);\n+                            pat.replacements.push((e.span, format!(\"&{}\", snip)));\n+                        },\n+                        // Edge case for macros. The span of the identifier will usually match the context of the\n+                        // binding, but not if the identifier was created in a macro. e.g. `concat_idents` and proc\n+                        // macros\n+                        _ => *outer_pat = None,\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "a723a472a25feabd9be2c0cacb534ddae36f8466", "filename": "clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -142,10 +142,10 @@ impl<'tcx> Visitor<'tcx> for RetCollector {\n         match expr.kind {\n             ExprKind::Ret(..) => {\n                 if self.loop_depth > 0 && !self.ret_in_loop {\n-                    self.ret_in_loop = true\n+                    self.ret_in_loop = true;\n                 }\n \n-                self.spans.push(expr.span)\n+                self.spans.push(expr.span);\n             },\n \n             ExprKind::Loop(..) => {"}, {"sha": "c824f6f54b5cc08759a1de7cf9024de7f1925b2b", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n                         types produces code that is hard to read and refactor, please \\\n                         consider using the `partial_cmp` method instead, to make it \\\n                         clear that the two values could be incomparable\"\n-                    )\n+                    );\n                 }\n             }\n         }"}, {"sha": "d5e1ea6d242deb787074e85963d050e3c947860f", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,12 +1,11 @@\n+use clippy_utils::consts::{self, Constant};\n use clippy_utils::diagnostics::span_lint;\n use if_chain::if_chain;\n use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-use crate::consts::{self, Constant};\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for multiplication by -1 as a form of negation.\n     ///"}, {"sha": "b2206a822088e01e9d6798a451585e533a0b1b6f", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::diagnostics::{span_lint_hir, span_lint_hir_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::has_drop;\n use rustc_errors::Applicability;\n@@ -92,7 +92,7 @@ impl<'tcx> LateLintPass<'tcx> for NoEffect {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Semi(expr) = stmt.kind {\n             if has_no_effect(cx, expr) {\n-                span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n+                span_lint_hir(cx, NO_EFFECT, expr.hir_id, stmt.span, \"statement with no effect\");\n             } else if let Some(reduced) = reduce_expression(cx, expr) {\n                 let mut snippet = String::new();\n                 for e in reduced {\n@@ -106,14 +106,15 @@ impl<'tcx> LateLintPass<'tcx> for NoEffect {\n                         return;\n                     }\n                 }\n-                span_lint_and_sugg(\n+                span_lint_hir_and_then(\n                     cx,\n                     UNNECESSARY_OPERATION,\n+                    expr.hir_id,\n                     stmt.span,\n                     \"statement can be reduced\",\n-                    \"replace it with\",\n-                    snippet,\n-                    Applicability::MachineApplicable,\n+                    |diag| {\n+                        diag.span_suggestion(stmt.span, \"replace it with\", snippet, Applicability::MachineApplicable);\n+                    },\n                 );\n             }\n         }"}, {"sha": "5292af5f076554b32aa862b0c3854d47d4bde616", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -126,6 +126,7 @@ const ALLOWED_TO_BE_SIMILAR: &[&[&str]] = &[\n     &[\"args\", \"arms\"],\n     &[\"qpath\", \"path\"],\n     &[\"lit\", \"lint\"],\n+    &[\"wparam\", \"lparam\"],\n ];\n \n struct SimilarNamesNameVisitor<'a, 'tcx, 'b>(&'b mut SimilarNamesLocalVisitor<'a, 'tcx>);"}, {"sha": "fded48038e39fb25a1eecf859bd77efa2d4e6c57", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -123,7 +123,7 @@ fn check_open_options(cx: &LateContext<'_>, options: &[(OpenOption, Argument)],\n                         \"the method `create` is called more than once\",\n                     );\n                 } else {\n-                    create = true\n+                    create = true;\n                 }\n                 create_arg = create_arg || (arg == Argument::True);\n             },\n@@ -136,7 +136,7 @@ fn check_open_options(cx: &LateContext<'_>, options: &[(OpenOption, Argument)],\n                         \"the method `append` is called more than once\",\n                     );\n                 } else {\n-                    append = true\n+                    append = true;\n                 }\n                 append_arg = append_arg || (arg == Argument::True);\n             },\n@@ -149,7 +149,7 @@ fn check_open_options(cx: &LateContext<'_>, options: &[(OpenOption, Argument)],\n                         \"the method `truncate` is called more than once\",\n                     );\n                 } else {\n-                    truncate = true\n+                    truncate = true;\n                 }\n                 truncate_arg = truncate_arg || (arg == Argument::True);\n             },\n@@ -162,7 +162,7 @@ fn check_open_options(cx: &LateContext<'_>, options: &[(OpenOption, Argument)],\n                         \"the method `read` is called more than once\",\n                     );\n                 } else {\n-                    read = true\n+                    read = true;\n                 }\n                 read_arg = read_arg || (arg == Argument::True);\n             },\n@@ -175,7 +175,7 @@ fn check_open_options(cx: &LateContext<'_>, options: &[(OpenOption, Argument)],\n                         \"the method `write` is called more than once\",\n                     );\n                 } else {\n-                    write = true\n+                    write = true;\n                 }\n                 write_arg = write_arg || (arg == Argument::True);\n             },"}, {"sha": "f6a704785598ee44372878a9a7ab846081ec9403", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -102,10 +102,16 @@ declare_clippy_lint! {\n pub struct PassByRefOrValue {\n     ref_min_size: u64,\n     value_max_size: u64,\n+    avoid_breaking_exported_api: bool,\n }\n \n impl<'tcx> PassByRefOrValue {\n-    pub fn new(ref_min_size: Option<u64>, value_max_size: u64, target: &Target) -> Self {\n+    pub fn new(\n+        ref_min_size: Option<u64>,\n+        value_max_size: u64,\n+        avoid_breaking_exported_api: bool,\n+        target: &Target,\n+    ) -> Self {\n         let ref_min_size = ref_min_size.unwrap_or_else(|| {\n             let bit_width = u64::from(target.pointer_width);\n             // Cap the calculated bit width at 32-bits to reduce\n@@ -120,10 +126,14 @@ impl<'tcx> PassByRefOrValue {\n         Self {\n             ref_min_size,\n             value_max_size,\n+            avoid_breaking_exported_api,\n         }\n     }\n \n     fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, hir_id: HirId, decl: &FnDecl<'_>, span: Option<Span>) {\n+        if self.avoid_breaking_exported_api && cx.access_levels.is_exported(hir_id) {\n+            return;\n+        }\n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n \n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n@@ -184,7 +194,6 @@ impl<'tcx> PassByRefOrValue {\n                     }\n \n                     if_chain! {\n-                        if !cx.access_levels.is_exported(hir_id);\n                         if is_copy(cx, ty);\n                         if !is_self_ty(input);\n                         if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());"}, {"sha": "12c44436874e1dbdff49142e105f4ef49275f82a", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -211,7 +211,7 @@ fn check_invalid_ptr_usage<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     ];\n \n     if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let ExprKind::Call(fun, args) = expr.kind;\n         if let ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n         let fun_def_path = cx.get_def_path(fun_def_id).into_iter().map(Symbol::to_ident_string).collect::<Vec<_>>();"}, {"sha": "d66bac5224360baea2acc2729d8717a42f9dc19b", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -88,7 +88,7 @@ impl QuestionMark {\n                         \"replace it with\",\n                         replacement_str,\n                         applicability,\n-                    )\n+                    );\n                 }\n             }\n         }\n@@ -129,7 +129,7 @@ impl QuestionMark {\n                     \"replace it with\",\n                     replacement,\n                     applicability,\n-                )\n+                );\n             }\n         }\n     }"}, {"sha": "ae5f0627fd65a41d5d271f895d5bd1622b48a5be", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;"}, {"sha": "8f56a21ac5b3d2a27b2da662c672fbd691f4d386", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -57,7 +57,7 @@ impl<'ast> ast_visit::Visitor<'ast> for ReturnVisitor {\n             self.found_return = true;\n         }\n \n-        ast_visit::walk_expr(self, ex)\n+        ast_visit::walk_expr(self, ex);\n     }\n }\n "}, {"sha": "05f9e01acb44b45154f9c103a07b4821bd830d76", "filename": "clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n                                 Applicability::MachineApplicable,\n                             );\n                         },\n-                    )\n+                    );\n                 }\n             }\n         }"}, {"sha": "751511674542dc8dd02032629f9e9602019193e1", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant, Constant};\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;"}, {"sha": "b479c40bca6cd48511707d660aacb33de06055c2", "filename": "clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frepeat_once.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant_context, Constant};\n+use clippy_utils::consts::{constant_context, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::in_macro;\n use clippy_utils::source::snippet;"}, {"sha": "251d527c265221348e81548b6d4e7062bda4a8cf", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n                 } else {\n                     RetReplacement::Empty\n                 };\n-                check_final_expr(cx, &body.value, Some(body.value.span), replacement)\n+                check_final_expr(cx, &body.value, Some(body.value.span), replacement);\n             },\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 if let ExprKind::Block(block, _) = body.value.kind {\n@@ -241,7 +241,7 @@ fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, inner_span: Option<Spa\n                 if let Some(snippet) = snippet_opt(cx, inner_span) {\n                     diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n                 }\n-            })\n+            });\n         },\n         None => match replacement {\n             RetReplacement::Empty => {"}, {"sha": "16e4d73851fb4e89b67cb68ff184880254d4cee1", "filename": "clippy_lints/src/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -8,11 +8,11 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n-    /// **What it does:** Looks for blocks of expressions and fires if the last expression returns `()`\n-    /// but is not followed by a semicolon.\n+    /// **What it does:** Looks for blocks of expressions and fires if the last expression returns\n+    /// `()` but is not followed by a semicolon.\n     ///\n-    /// **Why is this bad?** The semicolon might be optional but when\n-    /// extending the block with new code, it doesn't require a change in previous last line.\n+    /// **Why is this bad?** The semicolon might be optional but when extending the block with new\n+    /// code, it doesn't require a change in previous last line.\n     ///\n     /// **Known problems:** None.\n     ///\n@@ -30,7 +30,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub SEMICOLON_IF_NOTHING_RETURNED,\n-    restriction,\n+    pedantic,\n     \"add a semicolon if nothing is returned\"\n }\n "}, {"sha": "ac3f7ebd14bd83be17cf7c374dcbdd8916b3b46a", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -120,7 +120,7 @@ fn check_fn<'tcx>(cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'_>, body: &'tcx Bo\n     let mut bindings = Vec::with_capacity(decl.inputs.len());\n     for arg in iter_input_pats(decl, body) {\n         if let PatKind::Binding(.., ident, _) = arg.pat.kind {\n-            bindings.push((ident.name, ident.span))\n+            bindings.push((ident.name, ident.span));\n         }\n     }\n     check_expr(cx, &body.value, &mut bindings);\n@@ -156,7 +156,7 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n         ..\n     } = *local;\n     if let Some(t) = *ty {\n-        check_ty(cx, t, bindings)\n+        check_ty(cx, t, bindings);\n     }\n     if let Some(o) = *init {\n         check_expr(cx, o, bindings);\n@@ -324,14 +324,14 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n     }\n     match expr.kind {\n         ExprKind::Unary(_, e) | ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) | ExprKind::Box(e) => {\n-            check_expr(cx, e, bindings)\n+            check_expr(cx, e, bindings);\n         },\n         ExprKind::Block(block, _) | ExprKind::Loop(block, ..) => check_block(cx, block, bindings),\n         // ExprKind::Call\n         // ExprKind::MethodCall\n         ExprKind::Array(v) | ExprKind::Tup(v) => {\n             for e in v {\n-                check_expr(cx, e, bindings)\n+                check_expr(cx, e, bindings);\n             }\n         },\n         ExprKind::If(cond, then, ref otherwise) => {\n@@ -374,7 +374,7 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(\n         TyKind::Ptr(MutTy { ty: mty, .. }) | TyKind::Rptr(_, MutTy { ty: mty, .. }) => check_ty(cx, mty, bindings),\n         TyKind::Tup(tup) => {\n             for t in tup {\n-                check_ty(cx, t, bindings)\n+                check_ty(cx, t, bindings);\n             }\n         },\n         TyKind::Typeof(ref anon_const) => check_expr(cx, &cx.tcx.hir().body(anon_const.body).value, bindings),"}, {"sha": "1eaad438237ec16f4831806b7f5588e527cc151e", "filename": "clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -70,7 +70,7 @@ fn check_mod(cx: &EarlyContext<'_>, items: &[P<Item>]) {\n     for item in items {\n         track_uses(\n             cx,\n-            &item,\n+            item,\n             &mut imports_reused_with_self,\n             &mut single_use_usages,\n             &mut macros,\n@@ -117,7 +117,7 @@ fn track_uses(\n \n     match &item.kind {\n         ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) => {\n-            check_mod(cx, &items);\n+            check_mod(cx, items);\n         },\n         ItemKind::MacroDef(MacroDef { macro_rules: true, .. }) => {\n             macros.push(item.ident.name);"}, {"sha": "e5c58d70b603e60318b90fb45bc65a20add965bf", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -158,7 +158,7 @@ impl SlowVectorInit {\n     ) {\n         match initialization {\n             InitializationType::Extend(e) | InitializationType::Resize(e) => {\n-                Self::emit_lint(cx, e, vec_alloc, \"slow zero-filling initialization\")\n+                Self::emit_lint(cx, e, vec_alloc, \"slow zero-filling initialization\");\n             },\n         };\n     }\n@@ -290,7 +290,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n     fn visit_block(&mut self, block: &'tcx Block<'_>) {\n         if self.initialization_found {\n             if let Some(s) = block.stmts.get(0) {\n-                self.visit_stmt(s)\n+                self.visit_stmt(s);\n             }\n \n             self.initialization_found = false;"}, {"sha": "bb707f78fccd843f000ff582ba70348e50cde58d", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -59,7 +59,7 @@ declare_clippy_lint! {\n     /// }\n     /// ```\n     pub SUSPICIOUS_OPERATION_GROUPINGS,\n-    style,\n+    nursery,\n     \"groupings of binary operations that look suspiciously like typos\"\n }\n \n@@ -266,7 +266,7 @@ fn emit_suggestion(cx: &EarlyContext<'_>, span: Span, sugg: String, applicabilit\n         \"did you mean\",\n         sugg,\n         applicability,\n-    )\n+    );\n }\n \n fn ident_swap_sugg(\n@@ -475,7 +475,7 @@ impl Add for IdentLocation {\n \n impl AddAssign for IdentLocation {\n     fn add_assign(&mut self, other: Self) {\n-        *self = *self + other\n+        *self = *self + other;\n     }\n }\n \n@@ -506,7 +506,7 @@ impl Add for IdentDifference {\n \n impl AddAssign for IdentDifference {\n     fn add_assign(&mut self, other: Self) {\n-        *self = *self + other\n+        *self = *self + other;\n     }\n }\n "}, {"sha": "74a94db1800060c0bb3136895e004e709b6b64a1", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -3,6 +3,7 @@ use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::{in_macro, SpanlessHash};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::{def::Res, GenericBound, Generics, ParamName, Path, QPath, TyKind, WherePredicate};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -100,7 +101,7 @@ impl TraitBounds {\n             hasher.hash_ty(ty);\n             hasher.finish()\n         };\n-        let mut map = FxHashMap::default();\n+        let mut map: UnhashMap<u64, Vec<&GenericBound<'_>>> = UnhashMap::default();\n         let mut applicability = Applicability::MaybeIncorrect;\n         for bound in gen.where_clause.predicates {\n             if_chain! {"}, {"sha": "b57d158293db6cdb3ec64b8d16ef74ce6a655ad8", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant_context, Constant};\n+use clippy_utils::consts::{constant_context, Constant};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::{is_expr_path_def_path, paths};\n use if_chain::if_chain;"}, {"sha": "70b9e8adef884e56cf34f215cd9d7e442c21455b", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -306,7 +306,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n         match item.kind {\n             TraitItemKind::Const(ty, _) | TraitItemKind::Type(_, Some(ty)) => {\n-                self.check_ty(cx, ty, CheckTyContext::default())\n+                self.check_ty(cx, ty, CheckTyContext::default());\n             },\n             TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, sig.decl, CheckTyContext::default()),\n             TraitItemKind::Type(..) => (),\n@@ -433,7 +433,7 @@ impl Types {\n             },\n             TyKind::Slice(ty) | TyKind::Array(ty, _) | TyKind::Ptr(MutTy { ty, .. }) => {\n                 context.is_nested_call = true;\n-                self.check_ty(cx, ty, context)\n+                self.check_ty(cx, ty, context);\n             },\n             TyKind::Tup(tys) => {\n                 context.is_nested_call = true;"}, {"sha": "45291a120ed59b51df71bb3f28fc57ab0438d8b7", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -71,7 +71,7 @@ impl LateLintPass<'_> for Unicode {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n         if let ExprKind::Lit(ref lit) = expr.kind {\n             if let LitKind::Str(_, _) = lit.node {\n-                check_str(cx, lit.span, expr.hir_id)\n+                check_str(cx, lit.span, expr.hir_id);\n             }\n         }\n     }\n@@ -82,7 +82,7 @@ fn escape<T: Iterator<Item = char>>(s: T) -> String {\n     for c in s {\n         if c as u32 > 0x7F {\n             for d in c.escape_unicode() {\n-                result.push(d)\n+                result.push(d);\n             }\n         } else {\n             result.push(c);"}, {"sha": "a85ffa6aa950507c823738e77be58eb397ea0d4f", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::LangItem::{OptionSome, ResultOk};\n use rustc_hir::{Body, ExprKind, FnDecl, HirId, Impl, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -52,7 +52,19 @@ declare_clippy_lint! {\n     \"functions that only return `Ok` or `Some`\"\n }\n \n-declare_lint_pass!(UnnecessaryWraps => [UNNECESSARY_WRAPS]);\n+pub struct UnnecessaryWraps {\n+    avoid_breaking_exported_api: bool,\n+}\n+\n+impl_lint_pass!(UnnecessaryWraps => [UNNECESSARY_WRAPS]);\n+\n+impl UnnecessaryWraps {\n+    pub fn new(avoid_breaking_exported_api: bool) -> Self {\n+        Self {\n+            avoid_breaking_exported_api,\n+        }\n+    }\n+}\n \n impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n     fn check_fn(\n@@ -66,13 +78,12 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n     ) {\n         // Abort if public function/method or closure.\n         match fn_kind {\n-            FnKind::ItemFn(.., visibility) | FnKind::Method(.., Some(visibility)) => {\n-                if visibility.node.is_pub() {\n+            FnKind::ItemFn(..) | FnKind::Method(..) => {\n+                if self.avoid_breaking_exported_api && cx.access_levels.is_exported(hir_id) {\n                     return;\n                 }\n             },\n             FnKind::Closure => return,\n-            FnKind::Method(..) => (),\n         }\n \n         // Abort if the method is implementing a trait or of it a trait method."}, {"sha": "ee082d30d936b11fa97d3252ed4b13ab820c3e23", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n \n fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     let mut call = call;\n-    while let hir::ExprKind::MethodCall(ref path, _, ref args, _) = call.kind {\n+    while let hir::ExprKind::MethodCall(path, _, args, _) = call.kind {\n         if matches!(&*path.ident.as_str(), \"or\" | \"or_else\" | \"ok\") {\n             call = &args[0];\n         } else {"}, {"sha": "0b58c6c0917ca025433ddbd853521edc190b4abc", "filename": "clippy_lints/src/upper_case_acronyms.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fupper_case_acronyms.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use itertools::Itertools;\n-use rustc_ast::ast::{Item, ItemKind, VisibilityKind};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_hir::{Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::Ident;\n@@ -38,12 +38,14 @@ declare_clippy_lint! {\n \n #[derive(Default)]\n pub struct UpperCaseAcronyms {\n+    avoid_breaking_exported_api: bool,\n     upper_case_acronyms_aggressive: bool,\n }\n \n impl UpperCaseAcronyms {\n-    pub fn new(aggressive: bool) -> Self {\n+    pub fn new(avoid_breaking_exported_api: bool, aggressive: bool) -> Self {\n         Self {\n+            avoid_breaking_exported_api,\n             upper_case_acronyms_aggressive: aggressive,\n         }\n     }\n@@ -72,7 +74,7 @@ fn correct_ident(ident: &str) -> String {\n     ident\n }\n \n-fn check_ident(cx: &EarlyContext<'_>, ident: &Ident, be_aggressive: bool) {\n+fn check_ident(cx: &LateContext<'_>, ident: &Ident, be_aggressive: bool) {\n     let span = ident.span;\n     let ident = &ident.as_str();\n     let corrected = correct_ident(ident);\n@@ -92,27 +94,31 @@ fn check_ident(cx: &EarlyContext<'_>, ident: &Ident, be_aggressive: bool) {\n             \"consider making the acronym lowercase, except the initial letter\",\n             corrected,\n             Applicability::MaybeIncorrect,\n-        )\n+        );\n     }\n }\n \n-impl EarlyLintPass for UpperCaseAcronyms {\n-    fn check_item(&mut self, cx: &EarlyContext<'_>, it: &Item) {\n+impl LateLintPass<'_> for UpperCaseAcronyms {\n+    fn check_item(&mut self, cx: &LateContext<'_>, it: &Item<'_>) {\n         // do not lint public items or in macros\n-        if !in_external_macro(cx.sess(), it.span) && !matches!(it.vis.kind, VisibilityKind::Public) {\n-            if matches!(\n-                it.kind,\n-                ItemKind::TyAlias(..) | ItemKind::Struct(..) | ItemKind::Trait(..)\n-            ) {\n+        if in_external_macro(cx.sess(), it.span)\n+            || (self.avoid_breaking_exported_api && cx.access_levels.is_exported(it.hir_id()))\n+        {\n+            return;\n+        }\n+        match it.kind {\n+            ItemKind::TyAlias(..) | ItemKind::Struct(..) | ItemKind::Trait(..) => {\n                 check_ident(cx, &it.ident, self.upper_case_acronyms_aggressive);\n-            } else if let ItemKind::Enum(ref enumdef, _) = it.kind {\n+            },\n+            ItemKind::Enum(ref enumdef, _) => {\n                 // check enum variants seperately because again we only want to lint on private enums and\n                 // the fn check_variant does not know about the vis of the enum of its variants\n                 enumdef\n                     .variants\n                     .iter()\n                     .for_each(|variant| check_ident(cx, &variant.ident, self.upper_case_acronyms_aggressive));\n-            }\n+            },\n+            _ => {},\n         }\n     }\n }"}, {"sha": "254b104bdefb10ef088732d2fbf20c3f4ecefeb8", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -356,7 +356,7 @@ impl<'tcx> Visitor<'tcx> for SkipTyCollector {\n     fn visit_ty(&mut self, hir_ty: &hir::Ty<'_>) {\n         self.types_to_skip.push(hir_ty.hir_id);\n \n-        walk_ty(self, hir_ty)\n+        walk_ty(self, hir_ty);\n     }\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n@@ -385,7 +385,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LintTyCollector<'a, 'tcx> {\n             }\n         }\n \n-        walk_ty(self, hir_ty)\n+        walk_ty(self, hir_ty);\n     }\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "39ef170ae36d5d007d7792ad449db6364736fc18", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -292,7 +292,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     LitKind::Str(ref text, _) => {\n                         let str_pat = self.next(\"s\");\n                         println!(\"    if let LitKind::Str(ref {}, _) = {}.node;\", str_pat, lit_pat);\n-                        println!(\"    if {}.as_str() == {:?}\", str_pat, &*text.as_str())\n+                        println!(\"    if {}.as_str() == {:?}\", str_pat, &*text.as_str());\n                     },\n                 }\n             },"}, {"sha": "0e33ae740d946cd00e6c2903d56094a53e9bb441", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -122,7 +122,9 @@ macro_rules! define_Conf {\n \n // N.B., this macro is parsed by util/lintlib.py\n define_Conf! {\n-    /// Lint: CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE. The minimum rust version that the project supports\n+    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION. Suppress lints whenever the suggested change would cause breakage for other crates.\n+    (avoid_breaking_exported_api: bool = true),\n+    /// Lint: MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE. The minimum rust version that the project supports\n     (msrv: Option<String> = None),\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses\n     (blacklisted_names: Vec<String> = [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),\n@@ -208,15 +210,13 @@ pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n         .map_or_else(|| PathBuf::from(\".\"), PathBuf::from);\n     loop {\n         for config_file_name in &CONFIG_FILE_NAMES {\n-            let config_file = current.join(config_file_name);\n-            match fs::metadata(&config_file) {\n-                // Only return if it's a file to handle the unlikely situation of a directory named\n-                // `clippy.toml`.\n-                Ok(ref md) if !md.is_dir() => return Ok(Some(config_file)),\n-                // Return the error if it's something other than `NotFound`; otherwise we didn't\n-                // find the project file yet, and continue searching.\n-                Err(e) if e.kind() != io::ErrorKind::NotFound => return Err(e),\n-                _ => {},\n+            if let Ok(config_file) = current.join(config_file_name).canonicalize() {\n+                match fs::metadata(&config_file) {\n+                    Err(e) if e.kind() == io::ErrorKind::NotFound => {},\n+                    Err(e) => return Err(e),\n+                    Ok(md) if md.is_dir() => {},\n+                    Ok(_) => return Ok(Some(config_file)),\n+                }\n             }\n         }\n "}, {"sha": "b1523e032af29a05906a64548e3c42491961a3a4", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant_simple, Constant};\n+use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n@@ -1100,7 +1100,7 @@ impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n                 IF_CHAIN_STYLE,\n                 if_chain_local_span(cx, local, if_chain_span),\n                 \"`let` expression should be inside `then { .. }`\",\n-            )\n+            );\n         }\n     }\n \n@@ -1141,7 +1141,7 @@ impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n         if is_first_if_chain_expr(cx, expr.hir_id, if_chain_span)\n             && is_if_chain_then(then_block.stmts, then_block.expr, if_chain_span)\n         {\n-            span_lint(cx, IF_CHAIN_STYLE, expr.span, \"`if_chain!` only has one `if`\")\n+            span_lint(cx, IF_CHAIN_STYLE, expr.span, \"`if_chain!` only has one `if`\");\n         }\n     }\n }"}, {"sha": "46af03663b86be540a341d0a00c3111a3b6d2efc", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -379,7 +379,7 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n     /// }\n     /// ```\n     fn check_item(&mut self, cx: &LateContext<'hir>, item: &'hir Item<'_>) {\n-        if let ItemKind::Static(ref ty, Mutability::Not, _) = item.kind {\n+        if let ItemKind::Static(ty, Mutability::Not, _) = item.kind {\n             // Normal lint\n             if_chain! {\n                 // item validation\n@@ -489,7 +489,7 @@ fn extract_attr_docs(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n         .hir()\n         .attrs(item.hir_id())\n         .iter()\n-        .filter_map(|ref x| x.doc_str().map(|sym| sym.as_str().to_string()))\n+        .filter_map(|x| x.doc_str().map(|sym| sym.as_str().to_string()))\n         .reduce(|mut acc, sym| {\n             acc.push_str(&sym);\n             acc.push('\\n');\n@@ -596,7 +596,7 @@ fn extract_emission_info<'hir>(\n     let mut multi_part = false;\n \n     for arg in args {\n-        let (arg_ty, _) = walk_ptrs_ty_depth(cx.typeck_results().expr_ty(&arg));\n+        let (arg_ty, _) = walk_ptrs_ty_depth(cx.typeck_results().expr_ty(arg));\n \n         if match_type(cx, arg_ty, &paths::LINT) {\n             // If we found the lint arg, extract the lint name\n@@ -671,7 +671,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for LintResolver<'a, 'hir> {\n             if let ExprKind::Path(qpath) = &expr.kind;\n             if let QPath::Resolved(_, path) = qpath;\n \n-            let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&expr));\n+            let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(expr));\n             if match_type(self.cx, expr_ty, &paths::LINT);\n             then {\n                 if let hir::def::Res::Def(DefKind::Static, _) = path.res {\n@@ -730,7 +730,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityResolver<'a, 'hir> {\n     }\n \n     fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n-        let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&expr));\n+        let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(expr));\n \n         if_chain! {\n             if match_type(self.cx, expr_ty, &paths::APPLICABILITY);\n@@ -818,7 +818,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for IsMultiSpanScanner<'a, 'hir> {\n                     .any(|func_path| match_function_call(self.cx, fn_expr, func_path).is_some());\n                 if found_function {\n                     // These functions are all multi part suggestions\n-                    self.add_single_span_suggestion()\n+                    self.add_single_span_suggestion();\n                 }\n             },\n             ExprKind::MethodCall(path, _path_span, arg, _arg_span) => {"}, {"sha": "1d5b7c98d31416acc3dd78c667c3b614f29f2def", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,5 +1,5 @@\n-use crate::consts::{constant, Constant};\n use crate::rustc_target::abi::LayoutOf;\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;"}, {"sha": "3ab68df2b6d7cb1bf42c9fc13d172929bd747080", "filename": "clippy_lints/src/verbose_file_reads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for VerboseFileReads {\n                 \"use of `File::read_to_string`\",\n                 None,\n                 \"consider using `fs::read_to_string` instead\",\n-            )\n+            );\n         }\n     }\n }"}, {"sha": "5229a7058659c201ad361bbb112c4cd58ba379d3", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -300,7 +300,7 @@ impl EarlyLintPass for Write {\n                                 Applicability::MachineApplicable,\n                             );\n                         },\n-                    )\n+                    );\n                 }\n             }\n         } else if mac.path == sym!(writeln) {"}, {"sha": "a1ea743ba804d5ef52d0b5ffafb132f9584a5be4", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant_simple, Constant};\n+use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n use if_chain::if_chain;\n use rustc_hir::{BinOpKind, Expr, ExprKind};"}, {"sha": "0318c483959f2182a47f996dba7f88f6d584fc04", "filename": "clippy_utils/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fattrs.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -115,7 +115,7 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n     for attr in get_attr(sess, attrs, name) {\n         if let Some(ref value) = attr.value_str() {\n             if let Ok(value) = FromStr::from_str(&value.as_str()) {\n-                f(value)\n+                f(value);\n             } else {\n                 sess.span_err(attr.span, \"not a number\");\n             }"}, {"sha": "0d7fdeeb920f2c6897f172cf0f239fbf7d6c207b", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -229,25 +229,25 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n     pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n         match e.kind {\n             ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n-            ExprKind::Block(ref block, _) => self.block(block),\n+            ExprKind::Block(block, _) => self.block(block),\n             ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n-            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n-            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprKind::Repeat(ref value, _) => {\n+            ExprKind::Array(vec) => self.multi(vec).map(Constant::Vec),\n+            ExprKind::Tup(tup) => self.multi(tup).map(Constant::Tuple),\n+            ExprKind::Repeat(value, _) => {\n                 let n = match self.typeck_results.expr_ty(e).kind() {\n                     ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n             },\n-            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n+            ExprKind::Unary(op, operand) => self.expr(operand).and_then(|o| match op {\n                 UnOp::Not => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n                 UnOp::Neg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n                 UnOp::Deref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n             }),\n-            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n-            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n-            ExprKind::Call(ref callee, ref args) => {\n+            ExprKind::If(cond, then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n+            ExprKind::Binary(op, left, right) => self.binop(op, left, right),\n+            ExprKind::Call(callee, args) => {\n                 // We only handle a few const functions for now.\n                 if_chain! {\n                     if args.is_empty();\n@@ -273,8 +273,8 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                     }\n                 }\n             },\n-            ExprKind::Index(ref arr, ref index) => self.index(arr, index),\n-            ExprKind::AddrOf(_, _, ref inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n+            ExprKind::Index(arr, index) => self.index(arr, index),\n+            ExprKind::AddrOf(_, _, inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n             // TODO: add other expressions.\n             _ => None,\n         }\n@@ -349,7 +349,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                     )\n                     .ok()\n                     .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n-                let result = miri_to_const(&result);\n+                let result = miri_to_const(result);\n                 if result.is_some() {\n                     self.needed_resolution = true;\n                 }"}, {"sha": "7c94474cb35d2f8cbee0a217b491df2a13be515a", "filename": "clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -167,7 +167,7 @@ pub fn span_lint_hir_and_then(\n     cx: &LateContext<'_>,\n     lint: &'static Lint,\n     hir_id: HirId,\n-    sp: Span,\n+    sp: impl Into<MultiSpan>,\n     msg: &str,\n     f: impl FnOnce(&mut DiagnosticBuilder<'_>),\n ) {\n@@ -223,7 +223,7 @@ pub fn multispan_sugg<I>(diag: &mut DiagnosticBuilder<'_>, help_msg: &str, sugg:\n where\n     I: IntoIterator<Item = (Span, String)>,\n {\n-    multispan_sugg_with_applicability(diag, help_msg, Applicability::Unspecified, sugg)\n+    multispan_sugg_with_applicability(diag, help_msg, Applicability::Unspecified, sugg);\n }\n \n /// Create a suggestion made from several `span \u2192 replacement`."}, {"sha": "8be36756b3332a295963c89aa3dace545fd5570d", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -58,7 +58,7 @@ pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n     }\n \n     match expr.kind {\n-        hir::ExprKind::Call(ref path, ref args)\n+        hir::ExprKind::Call(path, args)\n             if matches!(\n                 path.kind,\n                 hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n@@ -70,7 +70,7 @@ pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n                 limits: ast::RangeLimits::Closed,\n             })\n         },\n-        hir::ExprKind::Struct(ref path, ref fields, None) => match path {\n+        hir::ExprKind::Struct(path, fields, None) => match path {\n             hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n                 start: None,\n                 end: None,\n@@ -112,7 +112,7 @@ pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n     // }\n     // ```\n     if_chain! {\n-        if let Some(ref expr) = local.init;\n+        if let Some(expr) = local.init;\n         if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n         then {\n             return true;\n@@ -140,14 +140,14 @@ pub fn for_loop<'tcx>(\n     expr: &'tcx hir::Expr<'tcx>,\n ) -> Option<(&hir::Pat<'_>, &'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>, Span)> {\n     if_chain! {\n-        if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n+        if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n+        if let hir::ExprKind::Call(_, iterargs) = iterexpr.kind;\n         if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprKind::Loop(ref block, ..) = arms[0].body.kind;\n+        if let hir::ExprKind::Loop(block, ..) = arms[0].body.kind;\n         if block.expr.is_none();\n         if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-        if let hir::StmtKind::Local(ref local) = let_stmt.kind;\n-        if let hir::StmtKind::Expr(ref expr) = body.kind;\n+        if let hir::StmtKind::Local(local) = let_stmt.kind;\n+        if let hir::StmtKind::Expr(expr) = body.kind;\n         then {\n             return Some((&*local.pat, &iterargs[0], expr, arms[0].span));\n         }\n@@ -182,7 +182,7 @@ pub enum VecArgs<'a> {\n /// from `vec!`.\n pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<VecArgs<'e>> {\n     if_chain! {\n-        if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let hir::ExprKind::Call(fun, args) = expr.kind;\n         if let hir::ExprKind::Path(ref qpath) = fun.kind;\n         if is_expn_of(fun.span, \"vec\").is_some();\n         if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n@@ -194,8 +194,8 @@ pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<Ve\n             else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n                 // `vec![a, b, c]` case\n                 if_chain! {\n-                    if let hir::ExprKind::Box(ref boxed) = args[0].kind;\n-                    if let hir::ExprKind::Array(ref args) = boxed.kind;\n+                    if let hir::ExprKind::Box(boxed) = args[0].kind;\n+                    if let hir::ExprKind::Array(args) = boxed.kind;\n                     then {\n                         return Some(VecArgs::Vec(&*args));\n                     }\n@@ -227,7 +227,7 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n     /// compared\n     fn ast_matchblock(matchblock_expr: &'tcx Expr<'tcx>) -> Option<Vec<&Expr<'_>>> {\n         if_chain! {\n-            if let ExprKind::Match(ref headerexpr, _, _) = &matchblock_expr.kind;\n+            if let ExprKind::Match(headerexpr, _, _) = &matchblock_expr.kind;\n             if let ExprKind::Tup([lhs, rhs]) = &headerexpr.kind;\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, lhs) = lhs.kind;\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, rhs) = rhs.kind;\n@@ -238,12 +238,12 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n         None\n     }\n \n-    if let ExprKind::Block(ref block, _) = e.kind {\n+    if let ExprKind::Block(block, _) = e.kind {\n         if block.stmts.len() == 1 {\n-            if let StmtKind::Semi(ref matchexpr) = block.stmts.get(0)?.kind {\n+            if let StmtKind::Semi(matchexpr) = block.stmts.get(0)?.kind {\n                 // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n                 if_chain! {\n-                    if let ExprKind::If(ref clause, _, _)  = matchexpr.kind;\n+                    if let ExprKind::If(clause, _, _)  = matchexpr.kind;\n                     if let ExprKind::Unary(UnOp::Not, condition) = clause.kind;\n                     then {\n                         return Some(vec![condition]);\n@@ -252,16 +252,16 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n \n                 // debug macros with two args: `debug_assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n                 if_chain! {\n-                    if let ExprKind::Block(ref matchblock,_) = matchexpr.kind;\n-                    if let Some(ref matchblock_expr) = matchblock.expr;\n+                    if let ExprKind::Block(matchblock,_) = matchexpr.kind;\n+                    if let Some(matchblock_expr) = matchblock.expr;\n                     then {\n                         return ast_matchblock(matchblock_expr);\n                     }\n                 }\n             }\n         } else if let Some(matchblock_expr) = block.expr {\n             // macros with two args: `assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n-            return ast_matchblock(&matchblock_expr);\n+            return ast_matchblock(matchblock_expr);\n         }\n     }\n     None"}, {"sha": "a21ad42c0617edcee3dc1b615bcc8317a85efe12", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 111, "deletions": 156, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -2,20 +2,19 @@ use crate::consts::{constant_context, constant_simple};\n use crate::differing_macro_contexts;\n use crate::source::snippet_opt;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::fx::FxHasher;\n use rustc_hir::def::Res;\n use rustc_hir::HirIdMap;\n use rustc_hir::{\n-    BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprField, ExprKind, FnRetTy, GenericArg,\n-    GenericArgs, Guard, HirId, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    BinOpKind, Block, BodyId, Expr, ExprField, ExprKind, FnRetTy, GenericArg, GenericArgs, Guard, HirId,\n+    InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path, PathSegment, QPath, Stmt,\n+    StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ich::StableHashingContextProvider;\n use rustc_middle::ty::TypeckResults;\n use rustc_span::Symbol;\n-use std::hash::Hash;\n+use std::hash::{Hash, Hasher};\n \n /// Type used to check whether two ast are the same. This is different from the\n /// operator\n@@ -95,12 +94,12 @@ pub struct HirEqInterExpr<'a, 'b, 'tcx> {\n impl HirEqInterExpr<'_, '_, '_> {\n     pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n-            (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n+            (&StmtKind::Local(l), &StmtKind::Local(r)) => {\n                 // This additional check ensures that the type of the locals are equivalent even if the init\n                 // expression or type have some inferred parts.\n                 if let Some(typeck) = self.inner.maybe_typeck_results {\n-                    let l_ty = typeck.pat_ty(&l.pat);\n-                    let r_ty = typeck.pat_ty(&r.pat);\n+                    let l_ty = typeck.pat_ty(l.pat);\n+                    let r_ty = typeck.pat_ty(r.pat);\n                     if !rustc_middle::ty::TyS::same_type(l_ty, r_ty) {\n                         return false;\n                     }\n@@ -110,11 +109,9 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 // these only get added if the init and type is equal.\n                 both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n                     && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r))\n-                    && self.eq_pat(&l.pat, &r.pat)\n-            },\n-            (&StmtKind::Expr(ref l), &StmtKind::Expr(ref r)) | (&StmtKind::Semi(ref l), &StmtKind::Semi(ref r)) => {\n-                self.eq_expr(l, r)\n+                    && self.eq_pat(l.pat, r.pat)\n             },\n+            (&StmtKind::Expr(l), &StmtKind::Expr(r)) | (&StmtKind::Semi(l), &StmtKind::Semi(r)) => self.eq_expr(l, r),\n             _ => false,\n         }\n     }\n@@ -165,12 +162,18 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 left.eq(right)\n             },\n             _ => {\n-                over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n+                over(left.stmts, right.stmts, |l, r| self.eq_stmt(l, r))\n                     && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n             },\n         }\n     }\n \n+    pub fn eq_body(&mut self, left: BodyId, right: BodyId) -> bool {\n+        let cx = self.inner.cx;\n+        let eval_const = |body| constant_context(cx, cx.tcx.typeck_body(body)).expr(&cx.tcx.hir().body(body).value);\n+        eval_const(left) == eval_const(right)\n+    }\n+\n     #[allow(clippy::similar_names)]\n     pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n         if !self.inner.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n@@ -192,20 +195,20 @@ impl HirEqInterExpr<'_, '_, '_> {\n             &reduce_exprkind(self.inner.cx, &left.kind),\n             &reduce_exprkind(self.inner.cx, &right.kind),\n         ) {\n-            (&ExprKind::AddrOf(lb, l_mut, ref le), &ExprKind::AddrOf(rb, r_mut, ref re)) => {\n+            (&ExprKind::AddrOf(lb, l_mut, le), &ExprKind::AddrOf(rb, r_mut, re)) => {\n                 lb == rb && l_mut == r_mut && self.eq_expr(le, re)\n             },\n             (&ExprKind::Continue(li), &ExprKind::Continue(ri)) => {\n                 both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n             },\n-            (&ExprKind::Assign(ref ll, ref lr, _), &ExprKind::Assign(ref rl, ref rr, _)) => {\n+            (&ExprKind::Assign(ll, lr, _), &ExprKind::Assign(rl, rr, _)) => {\n                 self.inner.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n-            (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n+            (&ExprKind::AssignOp(ref lo, ll, lr), &ExprKind::AssignOp(ref ro, rl, rr)) => {\n                 self.inner.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n-            (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n-            (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n+            (&ExprKind::Block(l, _), &ExprKind::Block(r, _)) => self.eq_block(l, r),\n+            (&ExprKind::Binary(l_op, ll, lr), &ExprKind::Binary(r_op, rl, rr)) => {\n                 l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                     || swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n                         l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n@@ -215,58 +218,50 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n                     && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n-            (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n+            (&ExprKind::Box(l), &ExprKind::Box(r)) => self.eq_expr(l, r),\n             (&ExprKind::Call(l_fun, l_args), &ExprKind::Call(r_fun, r_args)) => {\n                 self.inner.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt))\n-            | (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => {\n+            (&ExprKind::Cast(lx, lt), &ExprKind::Cast(rx, rt)) | (&ExprKind::Type(lx, lt), &ExprKind::Type(rx, rt)) => {\n                 self.eq_expr(lx, rx) && self.eq_ty(lt, rt)\n             },\n-            (&ExprKind::Field(ref l_f_exp, ref l_f_ident), &ExprKind::Field(ref r_f_exp, ref r_f_ident)) => {\n+            (&ExprKind::Field(l_f_exp, ref l_f_ident), &ExprKind::Field(r_f_exp, ref r_f_ident)) => {\n                 l_f_ident.name == r_f_ident.name && self.eq_expr(l_f_exp, r_f_exp)\n             },\n-            (&ExprKind::Index(ref la, ref li), &ExprKind::Index(ref ra, ref ri)) => {\n-                self.eq_expr(la, ra) && self.eq_expr(li, ri)\n-            },\n-            (&ExprKind::If(ref lc, ref lt, ref le), &ExprKind::If(ref rc, ref rt, ref re)) => {\n+            (&ExprKind::Index(la, li), &ExprKind::Index(ra, ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n+            (&ExprKind::If(lc, lt, ref le), &ExprKind::If(rc, rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n-            (&ExprKind::Loop(ref lb, ref ll, ref lls, _), &ExprKind::Loop(ref rb, ref rl, ref rls, _)) => {\n+            (&ExprKind::Loop(lb, ref ll, ref lls, _), &ExprKind::Loop(rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n             },\n-            (&ExprKind::Match(ref le, ref la, ref ls), &ExprKind::Match(ref re, ref ra, ref rs)) => {\n+            (&ExprKind::Match(le, la, ref ls), &ExprKind::Match(re, ra, ref rs)) => {\n                 ls == rs\n                     && self.eq_expr(le, re)\n                     && over(la, ra, |l, r| {\n-                        self.eq_pat(&l.pat, &r.pat)\n+                        self.eq_pat(l.pat, r.pat)\n                             && both(&l.guard, &r.guard, |l, r| self.eq_guard(l, r))\n-                            && self.eq_expr(&l.body, &r.body)\n+                            && self.eq_expr(l.body, r.body)\n                     })\n             },\n             (&ExprKind::MethodCall(l_path, _, l_args, _), &ExprKind::MethodCall(r_path, _, r_args, _)) => {\n                 self.inner.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n-                let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(ll_id.body));\n-                let ll = celcx.expr(&self.inner.cx.tcx.hir().body(ll_id.body).value);\n-                let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(rl_id.body));\n-                let rl = celcx.expr(&self.inner.cx.tcx.hir().body(rl_id.body).value);\n-\n-                self.eq_expr(le, re) && ll == rl\n+            (&ExprKind::Repeat(le, ref ll_id), &ExprKind::Repeat(re, ref rl_id)) => {\n+                self.eq_expr(le, re) && self.eq_body(ll_id.body, rl_id.body)\n             },\n             (&ExprKind::Ret(ref l), &ExprKind::Ret(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprKind::Path(ref l), &ExprKind::Path(ref r)) => self.eq_qpath(l, r),\n-            (&ExprKind::Struct(ref l_path, ref lf, ref lo), &ExprKind::Struct(ref r_path, ref rf, ref ro)) => {\n+            (&ExprKind::Struct(l_path, lf, ref lo), &ExprKind::Struct(r_path, rf, ref ro)) => {\n                 self.eq_qpath(l_path, r_path)\n                     && both(lo, ro, |l, r| self.eq_expr(l, r))\n                     && over(lf, rf, |l, r| self.eq_expr_field(l, r))\n             },\n             (&ExprKind::Tup(l_tup), &ExprKind::Tup(r_tup)) => self.eq_exprs(l_tup, r_tup),\n-            (&ExprKind::Unary(l_op, ref le), &ExprKind::Unary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n+            (&ExprKind::Unary(l_op, le), &ExprKind::Unary(r_op, re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprKind::Array(l), &ExprKind::Array(r)) => self.eq_exprs(l, r),\n-            (&ExprKind::DropTemps(ref le), &ExprKind::DropTemps(ref re)) => self.eq_expr(le, re),\n+            (&ExprKind::DropTemps(le), &ExprKind::DropTemps(re)) => self.eq_expr(le, re),\n             _ => false,\n         };\n         is_eq || self.inner.expr_fallback.as_mut().map_or(false, |f| f(left, right))\n@@ -277,7 +272,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n     }\n \n     fn eq_expr_field(&mut self, left: &ExprField<'_>, right: &ExprField<'_>) -> bool {\n-        left.ident.name == right.ident.name && self.eq_expr(&left.expr, &right.expr)\n+        left.ident.name == right.ident.name && self.eq_expr(left.expr, right.expr)\n     }\n \n     fn eq_guard(&mut self, left: &Guard<'_>, right: &Guard<'_>) -> bool {\n@@ -290,6 +285,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n \n     fn eq_generic_arg(&mut self, left: &GenericArg<'_>, right: &GenericArg<'_>) -> bool {\n         match (left, right) {\n+            (GenericArg::Const(l), GenericArg::Const(r)) => self.eq_body(l.value.body, r.value.body),\n             (GenericArg::Lifetime(l_lt), GenericArg::Lifetime(r_lt)) => Self::eq_lifetime(l_lt, r_lt),\n             (GenericArg::Type(l_ty), GenericArg::Type(r_ty)) => self.eq_ty(l_ty, r_ty),\n             _ => false,\n@@ -308,11 +304,11 @@ impl HirEqInterExpr<'_, '_, '_> {\n     /// Checks whether two patterns are the same.\n     fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n-            (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n-            (&PatKind::Struct(ref lp, ref la, ..), &PatKind::Struct(ref rp, ref ra, ..)) => {\n+            (&PatKind::Box(l), &PatKind::Box(r)) => self.eq_pat(l, r),\n+            (&PatKind::Struct(ref lp, la, ..), &PatKind::Struct(ref rp, ra, ..)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat_field(l, r))\n             },\n-            (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n+            (&PatKind::TupleStruct(ref lp, la, ls), &PatKind::TupleStruct(ref rp, ra, rs)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             },\n             (&PatKind::Binding(lb, li, _, ref lp), &PatKind::Binding(rb, ri, _, ref rp)) => {\n@@ -323,15 +319,13 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 eq\n             },\n             (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n-            (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n-            (&PatKind::Tuple(ref l, ls), &PatKind::Tuple(ref r, rs)) => {\n-                ls == rs && over(l, r, |l, r| self.eq_pat(l, r))\n-            },\n+            (&PatKind::Lit(l), &PatKind::Lit(r)) => self.eq_expr(l, r),\n+            (&PatKind::Tuple(l, ls), &PatKind::Tuple(r, rs)) => ls == rs && over(l, r, |l, r| self.eq_pat(l, r)),\n             (&PatKind::Range(ref ls, ref le, li), &PatKind::Range(ref rs, ref re, ri)) => {\n                 both(ls, rs, |a, b| self.eq_expr(a, b)) && both(le, re, |a, b| self.eq_expr(a, b)) && (li == ri)\n             },\n-            (&PatKind::Ref(ref le, ref lm), &PatKind::Ref(ref re, ref rm)) => lm == rm && self.eq_pat(le, re),\n-            (&PatKind::Slice(ref ls, ref li, ref le), &PatKind::Slice(ref rs, ref ri, ref re)) => {\n+            (&PatKind::Ref(le, ref lm), &PatKind::Ref(re, ref rm)) => lm == rm && self.eq_pat(le, re),\n+            (&PatKind::Slice(ls, ref li, le), &PatKind::Slice(rs, ref ri, re)) => {\n                 over(ls, rs, |l, r| self.eq_pat(l, r))\n                     && over(le, re, |l, r| self.eq_pat(l, r))\n                     && both(li, ri, |l, r| self.eq_pat(l, r))\n@@ -344,10 +338,10 @@ impl HirEqInterExpr<'_, '_, '_> {\n     #[allow(clippy::similar_names)]\n     fn eq_qpath(&mut self, left: &QPath<'_>, right: &QPath<'_>) -> bool {\n         match (left, right) {\n-            (&QPath::Resolved(ref lty, ref lpath), &QPath::Resolved(ref rty, ref rpath)) => {\n+            (&QPath::Resolved(ref lty, lpath), &QPath::Resolved(ref rty, rpath)) => {\n                 both(lty, rty, |l, r| self.eq_ty(l, r)) && self.eq_path(lpath, rpath)\n             },\n-            (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n+            (&QPath::TypeRelative(lty, lseg), &QPath::TypeRelative(rty, rseg)) => {\n                 self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n             },\n             (&QPath::LangItem(llang_item, _), &QPath::LangItem(rlang_item, _)) => llang_item == rlang_item,\n@@ -359,14 +353,14 @@ impl HirEqInterExpr<'_, '_, '_> {\n         match (left.res, right.res) {\n             (Res::Local(l), Res::Local(r)) => l == r || self.locals.get(&l) == Some(&r),\n             (Res::Local(_), _) | (_, Res::Local(_)) => false,\n-            _ => over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r)),\n+            _ => over(left.segments, right.segments, |l, r| self.eq_path_segment(l, r)),\n         }\n     }\n \n     fn eq_path_parameters(&mut self, left: &GenericArgs<'_>, right: &GenericArgs<'_>) -> bool {\n         if !(left.parenthesized || right.parenthesized) {\n-            over(&left.args, &right.args, |l, r| self.eq_generic_arg(l, r)) // FIXME(flip1995): may not work\n-                && over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n+            over(left.args, right.args, |l, r| self.eq_generic_arg(l, r)) // FIXME(flip1995): may not work\n+                && over(left.bindings, right.bindings, |l, r| self.eq_type_binding(l, r))\n         } else if left.parenthesized && right.parenthesized {\n             over(left.inputs(), right.inputs(), |l, r| self.eq_ty(l, r))\n                 && both(&Some(&left.bindings[0].ty()), &Some(&right.bindings[0].ty()), |l, r| {\n@@ -390,12 +384,9 @@ impl HirEqInterExpr<'_, '_, '_> {\n     #[allow(clippy::similar_names)]\n     fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n-            (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n-            (&TyKind::Array(ref lt, ref ll_id), &TyKind::Array(ref rt, ref rl_id)) => {\n-                let cx = self.inner.cx;\n-                let eval_const =\n-                    |body| constant_context(cx, cx.tcx.typeck_body(body)).expr(&cx.tcx.hir().body(body).value);\n-                self.eq_ty(lt, rt) && eval_const(ll_id.body) == eval_const(rl_id.body)\n+            (&TyKind::Slice(l_vec), &TyKind::Slice(r_vec)) => self.eq_ty(l_vec, r_vec),\n+            (&TyKind::Array(lt, ref ll_id), &TyKind::Array(rt, ref rl_id)) => {\n+                self.eq_ty(lt, rt) && self.eq_body(ll_id.body, rl_id.body)\n             },\n             (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n                 l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty)\n@@ -404,14 +395,14 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             },\n             (&TyKind::Path(ref l), &TyKind::Path(ref r)) => self.eq_qpath(l, r),\n-            (&TyKind::Tup(ref l), &TyKind::Tup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n+            (&TyKind::Tup(l), &TyKind::Tup(r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyKind::Infer, &TyKind::Infer) => true,\n             _ => false,\n         }\n     }\n \n     fn eq_type_binding(&mut self, left: &TypeBinding<'_>, right: &TypeBinding<'_>) -> bool {\n-        left.ident.name == right.ident.name && self.eq_ty(&left.ty(), &right.ty())\n+        left.ident.name == right.ident.name && self.eq_ty(left.ty(), right.ty())\n     }\n }\n \n@@ -519,15 +510,15 @@ pub struct SpanlessHash<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'tcx>,\n     maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n-    s: StableHasher,\n+    s: FxHasher,\n }\n \n impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n             maybe_typeck_results: cx.maybe_typeck_results(),\n-            s: StableHasher::new(),\n+            s: FxHasher::default(),\n         }\n     }\n \n@@ -540,17 +531,11 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             self.hash_stmt(s);\n         }\n \n-        if let Some(ref e) = b.expr {\n+        if let Some(e) = b.expr {\n             self.hash_expr(e);\n         }\n \n-        match b.rules {\n-            BlockCheckMode::DefaultBlock => 0,\n-            BlockCheckMode::UnsafeBlock(_) => 1,\n-            BlockCheckMode::PushUnsafeBlock(_) => 2,\n-            BlockCheckMode::PopUnsafeBlock(_) => 3,\n-        }\n-        .hash(&mut self.s);\n+        std::mem::discriminant(&b.rules).hash(&mut self.s);\n     }\n \n     #[allow(clippy::many_single_char_names, clippy::too_many_lines)]\n@@ -561,21 +546,16 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n         // const hashing may result in the same hash as some unrelated node, so add a sort of\n         // discriminant depending on which path we're choosing next\n-        simple_const.is_some().hash(&mut self.s);\n-\n-        if let Some(e) = simple_const {\n-            return e.hash(&mut self.s);\n+        simple_const.hash(&mut self.s);\n+        if simple_const.is_some() {\n+            return;\n         }\n \n         std::mem::discriminant(&e.kind).hash(&mut self.s);\n \n         match e.kind {\n-            ExprKind::AddrOf(kind, m, ref e) => {\n-                match kind {\n-                    BorrowKind::Ref => 0,\n-                    BorrowKind::Raw => 1,\n-                }\n-                .hash(&mut self.s);\n+            ExprKind::AddrOf(kind, m, e) => {\n+                std::mem::discriminant(&kind).hash(&mut self.s);\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n@@ -584,62 +564,56 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprKind::Assign(ref l, ref r, _) => {\n+            ExprKind::Assign(l, r, _) => {\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprKind::AssignOp(ref o, ref l, ref r) => {\n-                o.node\n-                    .hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+            ExprKind::AssignOp(ref o, l, r) => {\n+                std::mem::discriminant(&o.node).hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprKind::Block(ref b, _) => {\n+            ExprKind::Block(b, _) => {\n                 self.hash_block(b);\n             },\n-            ExprKind::Binary(op, ref l, ref r) => {\n-                op.node\n-                    .hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+            ExprKind::Binary(op, l, r) => {\n+                std::mem::discriminant(&op.node).hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n             ExprKind::Break(i, ref j) => {\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n                 }\n-                if let Some(ref j) = *j {\n+                if let Some(j) = *j {\n                     self.hash_expr(&*j);\n                 }\n             },\n-            ExprKind::Box(ref e) | ExprKind::DropTemps(ref e) | ExprKind::Yield(ref e, _) => {\n+            ExprKind::Box(e) | ExprKind::DropTemps(e) | ExprKind::Yield(e, _) => {\n                 self.hash_expr(e);\n             },\n-            ExprKind::Call(ref fun, args) => {\n+            ExprKind::Call(fun, args) => {\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n             },\n-            ExprKind::Cast(ref e, ref ty) | ExprKind::Type(ref e, ref ty) => {\n+            ExprKind::Cast(e, ty) | ExprKind::Type(e, ty) => {\n                 self.hash_expr(e);\n                 self.hash_ty(ty);\n             },\n             ExprKind::Closure(cap, _, eid, _, _) => {\n-                match cap {\n-                    CaptureBy::Value => 0,\n-                    CaptureBy::Ref => 1,\n-                }\n-                .hash(&mut self.s);\n+                std::mem::discriminant(&cap).hash(&mut self.s);\n                 // closures inherit TypeckResults\n                 self.hash_expr(&self.cx.tcx.hir().body(eid).value);\n             },\n-            ExprKind::Field(ref e, ref f) => {\n+            ExprKind::Field(e, ref f) => {\n                 self.hash_expr(e);\n                 self.hash_name(f.name);\n             },\n-            ExprKind::Index(ref a, ref i) => {\n+            ExprKind::Index(a, i) => {\n                 self.hash_expr(a);\n                 self.hash_expr(i);\n             },\n-            ExprKind::InlineAsm(ref asm) => {\n+            ExprKind::InlineAsm(asm) => {\n                 for piece in asm.template {\n                     match piece {\n                         InlineAsmTemplatePiece::String(s) => s.hash(&mut self.s),\n@@ -694,62 +668,60 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             ExprKind::Lit(ref l) => {\n                 l.node.hash(&mut self.s);\n             },\n-            ExprKind::Loop(ref b, ref i, ..) => {\n+            ExprKind::Loop(b, ref i, ..) => {\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprKind::If(ref cond, ref then, ref else_opt) => {\n-                let c: fn(_, _, _) -> _ = ExprKind::If;\n-                c.hash(&mut self.s);\n+            ExprKind::If(cond, then, ref else_opt) => {\n                 self.hash_expr(cond);\n-                self.hash_expr(&**then);\n-                if let Some(ref e) = *else_opt {\n+                self.hash_expr(then);\n+                if let Some(e) = *else_opt {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprKind::Match(ref e, arms, ref s) => {\n+            ExprKind::Match(e, arms, ref s) => {\n                 self.hash_expr(e);\n \n                 for arm in arms {\n                     self.hash_pat(arm.pat);\n                     if let Some(ref e) = arm.guard {\n                         self.hash_guard(e);\n                     }\n-                    self.hash_expr(&arm.body);\n+                    self.hash_expr(arm.body);\n                 }\n \n                 s.hash(&mut self.s);\n             },\n-            ExprKind::MethodCall(ref path, ref _tys, args, ref _fn_span) => {\n+            ExprKind::MethodCall(path, ref _tys, args, ref _fn_span) => {\n                 self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },\n             ExprKind::ConstBlock(ref l_id) => {\n                 self.hash_body(l_id.body);\n             },\n-            ExprKind::Repeat(ref e, ref l_id) => {\n+            ExprKind::Repeat(e, ref l_id) => {\n                 self.hash_expr(e);\n                 self.hash_body(l_id.body);\n             },\n             ExprKind::Ret(ref e) => {\n-                if let Some(ref e) = *e {\n+                if let Some(e) = *e {\n                     self.hash_expr(e);\n                 }\n             },\n             ExprKind::Path(ref qpath) => {\n                 self.hash_qpath(qpath);\n             },\n-            ExprKind::Struct(ref path, fields, ref expr) => {\n+            ExprKind::Struct(path, fields, ref expr) => {\n                 self.hash_qpath(path);\n \n                 for f in fields {\n                     self.hash_name(f.ident.name);\n-                    self.hash_expr(&f.expr);\n+                    self.hash_expr(f.expr);\n                 }\n \n-                if let Some(ref e) = *expr {\n+                if let Some(e) = *expr {\n                     self.hash_expr(e);\n                 }\n             },\n@@ -759,8 +731,8 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             ExprKind::Array(v) => {\n                 self.hash_exprs(v);\n             },\n-            ExprKind::Unary(lop, ref le) => {\n-                lop.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+            ExprKind::Unary(lop, le) => {\n+                std::mem::discriminant(&lop).hash(&mut self.s);\n                 self.hash_expr(le);\n             },\n         }\n@@ -773,19 +745,19 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_name(&mut self, n: Symbol) {\n-        n.as_str().hash(&mut self.s);\n+        n.hash(&mut self.s);\n     }\n \n     pub fn hash_qpath(&mut self, p: &QPath<'_>) {\n         match *p {\n-            QPath::Resolved(_, ref path) => {\n+            QPath::Resolved(_, path) => {\n                 self.hash_path(path);\n             },\n-            QPath::TypeRelative(_, ref path) => {\n+            QPath::TypeRelative(_, path) => {\n                 self.hash_name(path.ident.name);\n             },\n             QPath::LangItem(lang_item, ..) => {\n-                lang_item.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                std::mem::discriminant(&lang_item).hash(&mut self.s);\n             },\n         }\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n@@ -795,7 +767,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         std::mem::discriminant(&pat.kind).hash(&mut self.s);\n         match pat.kind {\n             PatKind::Binding(ann, _, _, pat) => {\n-                ann.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                std::mem::discriminant(&ann).hash(&mut self.s);\n                 if let Some(pat) = pat {\n                     self.hash_pat(pat);\n                 }\n@@ -815,11 +787,11 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 if let Some(e) = e {\n                     self.hash_expr(e);\n                 }\n-                i.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                std::mem::discriminant(&i).hash(&mut self.s);\n             },\n-            PatKind::Ref(pat, m) => {\n+            PatKind::Ref(pat, mu) => {\n                 self.hash_pat(pat);\n-                m.hash(&mut self.s);\n+                std::mem::discriminant(&mu).hash(&mut self.s);\n             },\n             PatKind::Slice(l, m, r) => {\n                 for pat in l {\n@@ -838,7 +810,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_name(f.ident.name);\n                     self.hash_pat(f.pat);\n                 }\n-                e.hash(&mut self.s)\n+                e.hash(&mut self.s);\n             },\n             PatKind::Tuple(pats, e) => {\n                 for pat in pats {\n@@ -864,6 +836,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             _ => {\n                 for seg in path.segments {\n                     self.hash_name(seg.ident.name);\n+                    self.hash_generic_args(seg.args().args);\n                 }\n             },\n         }\n@@ -875,7 +848,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         match &b.kind {\n             StmtKind::Local(local) => {\n                 self.hash_pat(local.pat);\n-                if let Some(ref init) = local.init {\n+                if let Some(init) = local.init {\n                     self.hash_expr(init);\n                 }\n             },\n@@ -888,7 +861,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_guard(&mut self, g: &Guard<'_>) {\n         match g {\n-            Guard::If(ref expr) | Guard::IfLet(_, ref expr) => {\n+            Guard::If(expr) | Guard::IfLet(_, expr) => {\n                 self.hash_expr(expr);\n             },\n         }\n@@ -921,25 +894,24 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_body(anon_const.body);\n             },\n             TyKind::Ptr(ref mut_ty) => {\n-                self.hash_ty(&mut_ty.ty);\n+                self.hash_ty(mut_ty.ty);\n                 mut_ty.mutbl.hash(&mut self.s);\n             },\n             TyKind::Rptr(lifetime, ref mut_ty) => {\n                 self.hash_lifetime(lifetime);\n-                self.hash_ty(&mut_ty.ty);\n+                self.hash_ty(mut_ty.ty);\n                 mut_ty.mutbl.hash(&mut self.s);\n             },\n             TyKind::BareFn(bfn) => {\n                 bfn.unsafety.hash(&mut self.s);\n                 bfn.abi.hash(&mut self.s);\n                 for arg in bfn.decl.inputs {\n-                    self.hash_ty(&arg);\n+                    self.hash_ty(arg);\n                 }\n+                std::mem::discriminant(&bfn.decl.output).hash(&mut self.s);\n                 match bfn.decl.output {\n-                    FnRetTy::DefaultReturn(_) => {\n-                        ().hash(&mut self.s);\n-                    },\n-                    FnRetTy::Return(ref ty) => {\n+                    FnRetTy::DefaultReturn(_) => {},\n+                    FnRetTy::Return(ty) => {\n                         self.hash_ty(ty);\n                     },\n                 }\n@@ -950,24 +922,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_ty(ty);\n                 }\n             },\n-            TyKind::Path(ref qpath) => match qpath {\n-                QPath::Resolved(ref maybe_ty, ref path) => {\n-                    if let Some(ref ty) = maybe_ty {\n-                        self.hash_ty(ty);\n-                    }\n-                    for segment in path.segments {\n-                        segment.ident.name.hash(&mut self.s);\n-                        self.hash_generic_args(segment.args().args);\n-                    }\n-                },\n-                QPath::TypeRelative(ref ty, ref segment) => {\n-                    self.hash_ty(ty);\n-                    segment.ident.name.hash(&mut self.s);\n-                },\n-                QPath::LangItem(lang_item, ..) => {\n-                    lang_item.hash(&mut self.s);\n-                },\n-            },\n+            TyKind::Path(ref qpath) => self.hash_qpath(qpath),\n             TyKind::OpaqueDef(_, arg_list) => {\n                 self.hash_generic_args(arg_list);\n             },"}, {"sha": "769836aaf18ed6c54c3773c5c4e052e8528f96c5", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -63,7 +63,7 @@ use std::hash::BuildHasherDefault;\n \n use if_chain::if_chain;\n use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -328,7 +328,7 @@ pub fn is_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol)\n \n /// Checks if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n-    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n+    if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind {\n         if let [p] = path.segments {\n             return p.ident.name == var;\n         }\n@@ -338,8 +338,8 @@ pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n \n pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     match *path {\n-        QPath::Resolved(_, ref path) => path.segments.last().expect(\"A path must have at least one segment\"),\n-        QPath::TypeRelative(_, ref seg) => seg,\n+        QPath::Resolved(_, path) => path.segments.last().expect(\"A path must have at least one segment\"),\n+        QPath::TypeRelative(_, seg) => seg,\n         QPath::LangItem(..) => panic!(\"last_path_segment: lang item has no path segments\"),\n     }\n }\n@@ -367,8 +367,8 @@ pub fn get_qpath_generic_tys(path: &QPath<'tcx>) -> impl Iterator<Item = &'tcx h\n \n pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n     match *path {\n-        QPath::Resolved(_, ref path) => path.segments.get(0),\n-        QPath::TypeRelative(_, ref seg) => Some(seg),\n+        QPath::Resolved(_, path) => path.segments.get(0),\n+        QPath::TypeRelative(_, seg) => Some(seg),\n         QPath::LangItem(..) => None,\n     }\n }\n@@ -388,8 +388,8 @@ pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment\n /// ```\n pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n     match *path {\n-        QPath::Resolved(_, ref path) => match_path(path, segments),\n-        QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n+        QPath::Resolved(_, path) => match_path(path, segments),\n+        QPath::TypeRelative(ty, segment) => match ty.kind {\n             TyKind::Path(ref inner_path) => {\n                 if let [prefix @ .., end] = segments {\n                     if match_qpath(inner_path, prefix) {\n@@ -457,7 +457,7 @@ pub fn match_path(path: &Path<'_>, segments: &[&str]) -> bool {\n \n /// If the expression is a path to a local, returns the canonical `HirId` of the local.\n pub fn path_to_local(expr: &Expr<'_>) -> Option<HirId> {\n-    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n+    if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind {\n         if let Res::Local(id) = path.res {\n             return Some(id);\n         }\n@@ -661,13 +661,13 @@ pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprKind::MethodCall(ref path, _, ref args, _) = current.kind {\n+        if let ExprKind::MethodCall(path, _, args, _) = current.kind {\n             if path.ident.name.as_str() == *method_name {\n                 if args.iter().any(|e| e.span.from_expansion()) {\n                     return None;\n                 }\n-                matched.push(&**args); // build up `matched` backwards\n-                current = &args[0] // go to parent expression\n+                matched.push(args); // build up `matched` backwards\n+                current = &args[0]; // go to parent expression\n             } else {\n                 return None;\n             }\n@@ -712,7 +712,7 @@ pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n     match pat.kind {\n         PatKind::Binding(.., ref spname, _) => Some(spname.name),\n         PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n-        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n+        PatKind::Box(p) | PatKind::Ref(p, _) => get_pat_name(&*p),\n         _ => None,\n     }\n }\n@@ -854,7 +854,7 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n             kind: ImplItemKind::Fn(_, eid),\n             ..\n         }) => match cx.tcx.hir().body(eid).value.kind {\n-            ExprKind::Block(ref block, _) => Some(block),\n+            ExprKind::Block(block, _) => Some(block),\n             _ => None,\n         },\n         _ => None,\n@@ -1028,7 +1028,7 @@ pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId) -> Ty<'tcx>\n \n /// Checks if an expression is constructing a tuple-like enum variant or struct\n pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Call(ref fun, _) = expr.kind {\n+    if let ExprKind::Call(fun, _) = expr.kind {\n         if let ExprKind::Path(ref qp) = fun.kind {\n             let res = cx.qpath_res(qp, fun.hir_id);\n             return match res {\n@@ -1058,21 +1058,21 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n     match pat.kind {\n         PatKind::Wild => false,\n         PatKind::Binding(_, _, _, pat) => pat.map_or(false, |pat| is_refutable(cx, pat)),\n-        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n+        PatKind::Box(pat) | PatKind::Ref(pat, _) => is_refutable(cx, pat),\n         PatKind::Lit(..) | PatKind::Range(..) => true,\n         PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.hir_id),\n-        PatKind::Or(ref pats) => {\n+        PatKind::Or(pats) => {\n             // TODO: should be the honest check, that pats is exhaustive set\n             are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n-        PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n-        PatKind::Struct(ref qpath, ref fields, _) => {\n+        PatKind::Tuple(pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n+        PatKind::Struct(ref qpath, fields, _) => {\n             is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, fields.iter().map(|field| &*field.pat))\n         },\n-        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n+        PatKind::TupleStruct(ref qpath, pats, _) => {\n             is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n-        PatKind::Slice(ref head, ref middle, ref tail) => {\n+        PatKind::Slice(head, ref middle, tail) => {\n             match &cx.typeck_results().node_type(pat.hir_id).kind() {\n                 rustc_ty::Slice(..) => {\n                     // [..] is the only irrefutable slice pattern.\n@@ -1094,9 +1094,9 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n /// the function once on the given pattern.\n pub fn recurse_or_patterns<'tcx, F: FnMut(&'tcx Pat<'tcx>)>(pat: &'tcx Pat<'tcx>, mut f: F) {\n     if let PatKind::Or(pats) = pat.kind {\n-        pats.iter().copied().for_each(f)\n+        pats.iter().copied().for_each(f);\n     } else {\n-        f(pat)\n+        f(pat);\n     }\n }\n \n@@ -1111,7 +1111,7 @@ pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n /// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n /// themselves.\n pub fn remove_blocks<'tcx>(mut expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n-    while let ExprKind::Block(ref block, ..) = expr.kind {\n+    while let ExprKind::Block(block, ..) = expr.kind {\n         match (block.stmts.is_empty(), block.expr.as_ref()) {\n             (true, Some(e)) => expr = e,\n             _ => break,\n@@ -1130,7 +1130,7 @@ pub fn is_self(slf: &Param<'_>) -> bool {\n \n pub fn is_self_ty(slf: &hir::Ty<'_>) -> bool {\n     if_chain! {\n-        if let TyKind::Path(QPath::Resolved(None, ref path)) = slf.kind;\n+        if let TyKind::Path(QPath::Resolved(None, path)) = slf.kind;\n         if let Res::SelfTy(..) = path.res;\n         then {\n             return true\n@@ -1148,7 +1148,7 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl<'_>, body: &'tcx Body<'_>) -> impl It\n pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     fn is_ok(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n         if_chain! {\n-            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n+            if let PatKind::TupleStruct(ref path, pat, None) = arm.pat.kind;\n             if is_lang_ctor(cx, path, ResultOk);\n             if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n             if path_to_local_id(arm.body, hir_id);\n@@ -1167,7 +1167,7 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n         }\n     }\n \n-    if let ExprKind::Match(_, ref arms, ref source) = expr.kind {\n+    if let ExprKind::Match(_, arms, ref source) = expr.kind {\n         // desugared from a `?` operator\n         if let MatchSource::TryDesugar = *source {\n             return Some(expr);\n@@ -1254,12 +1254,12 @@ pub fn match_function_call<'tcx>(\n     path: &[&str],\n ) -> Option<&'tcx [Expr<'tcx>]> {\n     if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let ExprKind::Call(fun, args) = expr.kind;\n         if let ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n         if match_def_path(cx, fun_def_id, path);\n         then {\n-            return Some(&args)\n+            return Some(args)\n         }\n     };\n     None\n@@ -1316,15 +1316,15 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n     let mut conds = Vec::new();\n     let mut blocks: Vec<&Block<'_>> = Vec::new();\n \n-    while let ExprKind::If(ref cond, ref then_expr, ref else_expr) = expr.kind {\n-        conds.push(&**cond);\n-        if let ExprKind::Block(ref block, _) = then_expr.kind {\n+    while let ExprKind::If(cond, then_expr, ref else_expr) = expr.kind {\n+        conds.push(cond);\n+        if let ExprKind::Block(block, _) = then_expr.kind {\n             blocks.push(block);\n         } else {\n             panic!(\"ExprKind::If node is not an ExprKind::Block\");\n         }\n \n-        if let Some(ref else_expr) = *else_expr {\n+        if let Some(else_expr) = *else_expr {\n             expr = else_expr;\n         } else {\n             break;\n@@ -1333,8 +1333,8 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n \n     // final `else {..}`\n     if !blocks.is_empty() {\n-        if let ExprKind::Block(ref block, _) = expr.kind {\n-            blocks.push(&**block);\n+        if let ExprKind::Block(block, _) = expr.kind {\n+            blocks.push(block);\n         }\n     }\n \n@@ -1383,7 +1383,7 @@ pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n // check if expr is calling method or function with #[must_use] attribute\n pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let did = match expr.kind {\n-        ExprKind::Call(ref path, _) => if_chain! {\n+        ExprKind::Call(path, _) => if_chain! {\n             if let ExprKind::Path(ref qpath) = path.kind;\n             if let def::Res::Def(_, did) = cx.qpath_res(qpath, path.hir_id);\n             then {\n@@ -1396,7 +1396,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         _ => None,\n     };\n \n-    did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n+    did.map_or(false, |did| must_use_attr(cx.tcx.get_attrs(did)).is_some())\n }\n \n /// Gets the node where an expression is either used, or it's type is unified with another branch.\n@@ -1572,14 +1572,16 @@ where\n     Hash: Fn(&T) -> u64,\n     Eq: Fn(&T, &T) -> bool,\n {\n-    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n-        return vec![(&exprs[0], &exprs[1])];\n+    match exprs {\n+        [a, b] if eq(a, b) => return vec![(a, b)],\n+        _ if exprs.len() <= 2 => return vec![],\n+        _ => {},\n     }\n \n     let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n \n-    let mut map: FxHashMap<_, Vec<&_>> =\n-        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n+    let mut map: UnhashMap<u64, Vec<&_>> =\n+        UnhashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n \n     for expr in exprs {\n         match map.entry(hash(expr)) {"}, {"sha": "4a9c4fd0276b378074b0b9895512f22a2e5a65d1", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -26,4 +26,5 @@ msrv_aliases! {\n     1,34,0 { TRY_FROM }\n     1,30,0 { ITERATOR_FIND_MAP }\n     1,17,0 { FIELD_INIT_SHORTHAND, STATIC_IN_CONST }\n+    1,16,0 { STR_REPEAT }\n }"}, {"sha": "546706d51d7b597c3f6d03b90a1448152533d37b", "filename": "clippy_utils/src/numeric_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -52,7 +52,7 @@ impl<'a> NumericLiteral<'a> {\n \n     pub fn from_lit_kind(src: &'a str, lit_kind: &LitKind) -> Option<NumericLiteral<'a>> {\n         if lit_kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n-            let (unsuffixed, suffix) = split_suffix(&src, lit_kind);\n+            let (unsuffixed, suffix) = split_suffix(src, lit_kind);\n             let float = matches!(lit_kind, LitKind::Float(..));\n             Some(NumericLiteral::new(unsuffixed, suffix, float))\n         } else {"}, {"sha": "791688cd194a997a75461edc103998525e434df4", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         if self.abort {\n             return;\n         }\n-        if let ExprKind::MethodCall(ref seg, _, ref args, _) = expr.kind {\n+        if let ExprKind::MethodCall(seg, _, args, _) = expr.kind {\n             if args.len() == 1 && match_var(&args[0], self.name) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     self.abort = true;\n@@ -79,5 +79,5 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n }\n \n fn get_binding_name(arg: &Param<'_>) -> Option<Symbol> {\n-    get_pat_name(&arg.pat)\n+    get_pat_name(arg.pat)\n }"}, {"sha": "0e6ead675c24754d4515618e48c3ac8b11706acf", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -255,7 +255,7 @@ fn check_place(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &Body<'t\n         cursor = proj_base;\n         match elem {\n             ProjectionElem::Field(..) => {\n-                let base_ty = Place::ty_from(place.local, &proj_base, body, tcx).ty;\n+                let base_ty = Place::ty_from(place.local, proj_base, body, tcx).ty;\n                 if let Some(def) = base_ty.ty_adt_def() {\n                     // No union field accesses in `const fn`\n                     if def.is_union() {"}, {"sha": "efc0ec50fdc947f9d209be2256d8c41ecf1f906b", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -2,15 +2,15 @@\n #![deny(clippy::missing_docs_in_private_items)]\n \n use crate::higher;\n-use crate::source::{snippet, snippet_opt, snippet_with_macro_callsite};\n+use crate::source::{snippet, snippet_opt, snippet_with_context, snippet_with_macro_callsite};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{ast, token};\n use rustc_ast_pretty::pprust::token_kind_to_string;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{EarlyContext, LateContext, LintContext};\n use rustc_span::source_map::{CharPos, Span};\n-use rustc_span::{BytePos, Pos};\n+use rustc_span::{BytePos, Pos, SyntaxContext};\n use std::borrow::Cow;\n use std::convert::TryInto;\n use std::fmt::Display;\n@@ -90,6 +90,29 @@ impl<'a> Sugg<'a> {\n         Self::hir_from_snippet(expr, snippet)\n     }\n \n+    /// Same as `hir`, but first walks the span up to the given context. This will result in the\n+    /// macro call, rather then the expansion, if the span is from a child context. If the span is\n+    /// not from a child context, it will be used directly instead.\n+    ///\n+    /// e.g. Given the expression `&vec![]`, getting a snippet from the span for `vec![]` as a HIR\n+    /// node would result in `box []`. If given the context of the address of expression, this\n+    /// function will correctly get a snippet of `vec![]`.\n+    pub fn hir_with_context(\n+        cx: &LateContext<'_>,\n+        expr: &hir::Expr<'_>,\n+        ctxt: SyntaxContext,\n+        default: &'a str,\n+        applicability: &mut Applicability,\n+    ) -> Self {\n+        let (snippet, in_macro) = snippet_with_context(cx, expr.span, ctxt, default, applicability);\n+\n+        if in_macro {\n+            Sugg::NonParen(snippet)\n+        } else {\n+            Self::hir_from_snippet(expr, snippet)\n+        }\n+    }\n+\n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n     fn hir_from_snippet(expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n@@ -684,7 +707,7 @@ impl<T: LintContext> DiagnosticBuilderExt<T> for rustc_errors::DiagnosticBuilder\n \n             if let Some(non_whitespace_offset) = non_whitespace_offset {\n                 remove_span = remove_span\n-                    .with_hi(remove_span.hi() + BytePos(non_whitespace_offset.try_into().expect(\"offset too large\")))\n+                    .with_hi(remove_span.hi() + BytePos(non_whitespace_offset.try_into().expect(\"offset too large\")));\n             }\n         }\n "}, {"sha": "a92d3be5d3cf2b595d831769b6efbe142ccc15b6", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -142,21 +142,18 @@ pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n // Returns whether the type has #[must_use] attribute\n pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n-        ty::Adt(ref adt, _) => must_use_attr(&cx.tcx.get_attrs(adt.did)).is_some(),\n-        ty::Foreign(ref did) => must_use_attr(&cx.tcx.get_attrs(*did)).is_some(),\n-        ty::Slice(ref ty)\n-        | ty::Array(ref ty, _)\n-        | ty::RawPtr(ty::TypeAndMut { ref ty, .. })\n-        | ty::Ref(_, ref ty, _) => {\n+        ty::Adt(adt, _) => must_use_attr(cx.tcx.get_attrs(adt.did)).is_some(),\n+        ty::Foreign(ref did) => must_use_attr(cx.tcx.get_attrs(*did)).is_some(),\n+        ty::Slice(ty) | ty::Array(ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n             // for the Array case we don't need to care for the len == 0 case\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n         },\n-        ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n+        ty::Tuple(substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n                 if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n-                    if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n+                    if must_use_attr(cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n                         return true;\n                     }\n                 }\n@@ -166,7 +163,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Dynamic(binder, _) => {\n             for predicate in binder.iter() {\n                 if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n-                    if must_use_attr(&cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n+                    if must_use_attr(cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n                         return true;\n                     }\n                 }\n@@ -305,7 +302,7 @@ pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bo\n /// Returns the base type for HIR references and pointers.\n pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n     match ty.kind {\n-        TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n+        TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(mut_ty.ty),\n         _ => ty,\n     }\n }"}, {"sha": "2c55021ac88374f0c8fe450e8d8d3bbd75127b6d", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> MutVarsDelegate {\n                 //FIXME: This causes false negatives. We can't get the `NodeId` from\n                 //`Categorization::Upvar(_)`. So we search for any `Upvar`s in the\n                 //`while`-body, not just the ones in the condition.\n-                self.skip = true\n+                self.skip = true;\n             },\n             _ => {},\n         }\n@@ -71,12 +71,12 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n \n     fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n-            self.update(&cmt)\n+            self.update(cmt);\n         }\n     }\n \n     fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId) {\n-        self.update(&cmt)\n+        self.update(cmt);\n     }\n \n     fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _: HirId) {}"}, {"sha": "ce00106dd4d8087afc501f234cfd442ca73c1047", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -87,7 +87,7 @@ where\n         }\n \n         fn visit_stmt(&mut self, stmt: &'hir hir::Stmt<'_>) {\n-            intravisit::walk_stmt(&mut *self.inside_stmt(true), stmt)\n+            intravisit::walk_stmt(&mut *self.inside_stmt(true), stmt);\n         }\n \n         fn visit_expr(&mut self, expr: &'hir hir::Expr<'_>) {\n@@ -189,34 +189,21 @@ impl<'v> Visitor<'v> for LocalUsedVisitor<'v> {\n     }\n }\n \n+/// A type which can be visited.\n pub trait Visitable<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V);\n+    /// Calls the corresponding `visit_*` function on the visitor.\n+    fn visit<V: Visitor<'tcx>>(self, visitor: &mut V);\n }\n-impl Visitable<'tcx> for &'tcx Expr<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n-        v.visit_expr(self)\n-    }\n-}\n-impl Visitable<'tcx> for &'tcx Block<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n-        v.visit_block(self)\n-    }\n-}\n-impl<'tcx> Visitable<'tcx> for &'tcx Stmt<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n-        v.visit_stmt(self)\n-    }\n-}\n-impl<'tcx> Visitable<'tcx> for &'tcx Body<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n-        v.visit_body(self)\n-    }\n-}\n-impl<'tcx> Visitable<'tcx> for &'tcx Arm<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n-        v.visit_arm(self)\n-    }\n+macro_rules! visitable_ref {\n+    ($t:ident, $f:ident) => {\n+        impl Visitable<'tcx> for &'tcx $t<'tcx> {\n+            fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n+                visitor.$f(self);\n+            }\n+        }\n+    };\n }\n+visitable_ref!(Block, visit_block);\n \n /// Calls the given function for each break expression.\n pub fn visit_break_exprs<'tcx>(\n@@ -232,7 +219,7 @@ pub fn visit_break_exprs<'tcx>(\n \n         fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n             if let ExprKind::Break(dest, sub_expr) = e.kind {\n-                self.0(e, dest, sub_expr)\n+                self.0(e, dest, sub_expr);\n             }\n             walk_expr(self, e);\n         }\n@@ -264,7 +251,7 @@ pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n                     self.found = true;\n                 }\n             } else {\n-                walk_expr(self, e)\n+                walk_expr(self, e);\n             }\n         }\n     }"}, {"sha": "e0af9bf0625721a82c59fc63bb000bcd34a253f5", "filename": "doc/release.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/doc%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/doc%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frelease.md?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -94,7 +94,7 @@ After finding the Clippy commit, it can be tagged with the release number.\n # Assuming the current directory corresponds to the Clippy repository\n $ git checkout $SHA\n $ git tag rust-1.XX.0               # XX should be exchanged with the corresponding version\n-$ git push upstream master --tags   # `upstream` is the `rust-lang/rust-clippy` remote\n+$ git push upstream rust-1.XX.0     # `upstream` is the `rust-lang/rust-clippy` remote\n ```\n \n After this, the release should be available on the Clippy [release page]."}, {"sha": "0d95c86aef0308ac39fd81f24cfdfe5cea4ac0d2", "filename": "mini-macro/Cargo.toml", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91aa82174531ef408c81325e0d31b508c1f26e0b/mini-macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/91aa82174531ef408c81325e0d31b508c1f26e0b/mini-macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mini-macro%2FCargo.toml?ref=91aa82174531ef408c81325e0d31b508c1f26e0b", "patch": "@@ -1,14 +0,0 @@\n-[package]\n-name = \"clippy-mini-macro-test\"\n-version = \"0.2.0\"\n-authors = [\"The Rust Clippy Developers\"]\n-license = \"MIT OR Apache-2.0\"\n-description = \"A macro to test clippy's procedural macro checks\"\n-repository = \"https://github.com/rust-lang/rust-clippy\"\n-edition = \"2018\"\n-\n-[lib]\n-name = \"clippy_mini_macro_test\"\n-proc-macro = true\n-\n-[dependencies]"}, {"sha": "2b793589049ba7b7d16dffb9156115d2cdd52ced", "filename": "mini-macro/src/lib.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/91aa82174531ef408c81325e0d31b508c1f26e0b/mini-macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91aa82174531ef408c81325e0d31b508c1f26e0b/mini-macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mini-macro%2Fsrc%2Flib.rs?ref=91aa82174531ef408c81325e0d31b508c1f26e0b", "patch": "@@ -1,29 +0,0 @@\n-#![feature(proc_macro_quote)]\n-#![deny(rust_2018_idioms)]\n-// FIXME: Remove this attribute once the weird failure is gone.\n-#![allow(unused_extern_crates)]\n-extern crate proc_macro;\n-\n-use proc_macro::{quote, TokenStream};\n-\n-#[proc_macro_derive(ClippyMiniMacroTest)]\n-/// # Panics\n-///\n-/// Panics if the macro derivation fails\n-pub fn mini_macro(_: TokenStream) -> TokenStream {\n-    quote!(\n-        #[allow(unused)]\n-        fn needless_take_by_value(s: String) {\n-            println!(\"{}\", s.len());\n-        }\n-        #[allow(unused)]\n-        fn needless_loop(items: &[u8]) {\n-            for i in 0..items.len() {\n-                println!(\"{}\", items[i]);\n-            }\n-        }\n-        fn line_wrapper() {\n-            println!(\"{}\", line!());\n-        }\n-    )\n-}"}, {"sha": "e3863c46288c2e3587445dc494a4c14d6ffa023d", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-05-20\"\n+channel = \"nightly-2021-06-03\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "5f289918a7c1306e8d908c7456e0c922dd36ef37", "filename": "rustc_tools_util/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/rustc_tools_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/rustc_tools_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tools_util%2Fsrc%2Flib.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -100,9 +100,9 @@ pub fn get_commit_date() -> Option<String> {\n }\n \n #[must_use]\n-pub fn get_channel() -> Option<String> {\n+pub fn get_channel() -> String {\n     match env::var(\"CFG_RELEASE_CHANNEL\") {\n-        Ok(channel) => Some(channel),\n+        Ok(channel) => channel,\n         Err(_) => {\n             // if that failed, try to ask rustc -V, do some parsing and find out\n             match std::process::Command::new(\"rustc\")\n@@ -113,16 +113,16 @@ pub fn get_channel() -> Option<String> {\n             {\n                 Some(rustc_output) => {\n                     if rustc_output.contains(\"beta\") {\n-                        Some(String::from(\"beta\"))\n+                        String::from(\"beta\")\n                     } else if rustc_output.contains(\"stable\") {\n-                        Some(String::from(\"stable\"))\n+                        String::from(\"stable\")\n                     } else {\n                         // default to nightly if we fail to parse\n-                        Some(String::from(\"nightly\"))\n+                        String::from(\"nightly\")\n                     }\n                 },\n                 // default to nightly\n-                None => Some(String::from(\"nightly\")),\n+                None => String::from(\"nightly\"),\n             }\n         },\n     }"}, {"sha": "5eb7ac03541982f7f36a590b7c8f41df7d756108", "filename": "tests/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fclippy.toml?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1 @@\n+# default config for tests, overrides clippy.toml at the project root"}, {"sha": "7d266a36bb666387803a921db506712d073720b4", "filename": "tests/compile-test.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -4,8 +4,8 @@\n use compiletest_rs as compiletest;\n use compiletest_rs::common::Mode as TestMode;\n \n-use std::env::{self, set_var, var};\n-use std::ffi::OsStr;\n+use std::env::{self, remove_var, set_var, var_os};\n+use std::ffi::{OsStr, OsString};\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n@@ -88,9 +88,11 @@ fn default_config() -> compiletest::Config {\n     config\n }\n \n-fn run_mode(cfg: &mut compiletest::Config) {\n+fn run_ui(cfg: &mut compiletest::Config) {\n     cfg.mode = TestMode::Ui;\n     cfg.src_base = Path::new(\"tests\").join(\"ui\");\n+    // use tests/clippy.toml\n+    let _g = VarGuard::set(\"CARGO_MANIFEST_DIR\", std::fs::canonicalize(\"tests\").unwrap());\n     compiletest::run_tests(cfg);\n }\n \n@@ -114,7 +116,7 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n                 continue;\n             }\n             let dir_path = dir.path();\n-            set_var(\"CARGO_MANIFEST_DIR\", &dir_path);\n+            let _g = VarGuard::set(\"CARGO_MANIFEST_DIR\", &dir_path);\n             for file in fs::read_dir(&dir_path)? {\n                 let file = file?;\n                 let file_path = file.path();\n@@ -145,9 +147,7 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n \n     let tests = compiletest::make_tests(config);\n \n-    let manifest_dir = var(\"CARGO_MANIFEST_DIR\").unwrap_or_default();\n     let res = run_tests(config, tests);\n-    set_var(\"CARGO_MANIFEST_DIR\", &manifest_dir);\n     match res {\n         Ok(true) => {},\n         Ok(false) => panic!(\"Some tests failed\"),\n@@ -208,7 +208,7 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n                         Some(\"main.rs\") => {},\n                         _ => continue,\n                     }\n-                    set_var(\"CLIPPY_CONF_DIR\", case.path());\n+                    let _g = VarGuard::set(\"CLIPPY_CONF_DIR\", case.path());\n                     let paths = compiletest::common::TestPaths {\n                         file: file_path,\n                         base: config.src_base.clone(),\n@@ -236,10 +236,8 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n     let tests = compiletest::make_tests(config);\n \n     let current_dir = env::current_dir().unwrap();\n-    let conf_dir = var(\"CLIPPY_CONF_DIR\").unwrap_or_default();\n     let res = run_tests(config, &config.filters, tests);\n     env::set_current_dir(current_dir).unwrap();\n-    set_var(\"CLIPPY_CONF_DIR\", conf_dir);\n \n     match res {\n         Ok(true) => {},\n@@ -260,8 +258,32 @@ fn prepare_env() {\n fn compile_test() {\n     prepare_env();\n     let mut config = default_config();\n-    run_mode(&mut config);\n+    run_ui(&mut config);\n     run_ui_toml(&mut config);\n     run_ui_cargo(&mut config);\n     run_internal_tests(&mut config);\n }\n+\n+/// Restores an env var on drop\n+#[must_use]\n+struct VarGuard {\n+    key: &'static str,\n+    value: Option<OsString>,\n+}\n+\n+impl VarGuard {\n+    fn set(key: &'static str, val: impl AsRef<OsStr>) -> Self {\n+        let value = var_os(key);\n+        set_var(key, val);\n+        Self { key, value }\n+    }\n+}\n+\n+impl Drop for VarGuard {\n+    fn drop(&mut self) {\n+        match self.value.as_deref() {\n+            None => remove_var(self.key),\n+            Some(value) => set_var(self.key, value),\n+        }\n+    }\n+}"}, {"sha": "7de130c7dbefa6e3b7f3a0d7300289f1d7cc62b3", "filename": "tests/dogfood.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -179,8 +179,39 @@ fn dogfood_subprojects() {\n #[ignore]\n #[cfg(feature = \"metadata-collector-lint\")]\n fn run_metadata_collection_lint() {\n+    use std::fs::File;\n+    use std::time::SystemTime;\n+\n+    // Setup for validation\n+    let metadata_output_path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"util/gh-pages/metadata_collection.json\");\n+    let start_time = SystemTime::now();\n+\n+    // Run collection as is\n     std::env::set_var(\"ENABLE_METADATA_COLLECTION\", \"1\");\n     run_clippy_for_project(\"clippy_lints\");\n+\n+    // Check if cargo caching got in the way\n+    if let Ok(file) = File::open(metadata_output_path) {\n+        if let Ok(metadata) = file.metadata() {\n+            if let Ok(last_modification) = metadata.modified() {\n+                if last_modification > start_time {\n+                    // The output file has been modified. Most likely by a hungry\n+                    // metadata collection monster. So We'll return.\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    // Force cargo to invalidate the caches\n+    filetime::set_file_mtime(\n+        PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"clippy_lints/src/lib.rs\"),\n+        filetime::FileTime::now(),\n+    )\n+    .unwrap();\n+\n+    // Running the collection again\n+    run_clippy_for_project(\"clippy_lints\");\n }\n \n fn run_clippy_for_project(project: &str) {"}, {"sha": "a7be00426c41c4896cea47a60f534b172db1e648", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "4b7b7fec78fe8dd7dc9e1941c3871976c60de176", "filename": "tests/ui/auxiliary/proc_macro_derive.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -53,3 +53,22 @@ pub fn derive_use_self(_input: TokenStream) -> proc_macro::TokenStream {\n         }\n     }\n }\n+\n+#[proc_macro_derive(ClippyMiniMacroTest)]\n+pub fn mini_macro(_: TokenStream) -> TokenStream {\n+    quote!(\n+        #[allow(unused)]\n+        fn needless_take_by_value(s: String) {\n+            println!(\"{}\", s.len());\n+        }\n+        #[allow(unused)]\n+        fn needless_loop(items: &[u8]) {\n+            for i in 0..items.len() {\n+                println!(\"{}\", items[i]);\n+            }\n+        }\n+        fn line_wrapper() {\n+            println!(\"{}\", line!());\n+        }\n+    )\n+}"}, {"sha": "780797e3c6aa42291af2d15e66e988a6a9e160e9", "filename": "tests/ui/crashes/auxiliary/ice-7272-aux.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fcrashes%2Fauxiliary%2Fice-7272-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fcrashes%2Fauxiliary%2Fice-7272-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fauxiliary%2Fice-7272-aux.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,14 @@\n+pub fn warn<T>(_: T) {}\n+\n+macro_rules! define_macro {\n+    ($d:tt $lower:ident $upper:ident) => {\n+        #[macro_export]\n+        macro_rules! $upper {\n+            ($arg:tt) => {\n+                $crate::$lower($arg)\n+            };\n+        }\n+    };\n+}\n+\n+define_macro! {$ warn  WARNING}"}, {"sha": "57ab6ca14f86a3608ee7f0b202e3767480b5209f", "filename": "tests/ui/crashes/ice-7272.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fcrashes%2Fice-7272.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fcrashes%2Fice-7272.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7272.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,12 @@\n+// aux-build:ice-7272-aux.rs\n+\n+#![allow(clippy::no_effect)]\n+\n+extern crate ice_7272_aux;\n+\n+use ice_7272_aux::*;\n+\n+pub fn main() {\n+    || WARNING!(\"Style changed!\");\n+    || \"}{\";\n+}"}, {"sha": "c7468493380c8eb3f994279c32102242fd477fc3", "filename": "tests/ui/crashes/procedural_macro.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/91aa82174531ef408c81325e0d31b508c1f26e0b/tests%2Fui%2Fcrashes%2Fprocedural_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91aa82174531ef408c81325e0d31b508c1f26e0b/tests%2Fui%2Fcrashes%2Fprocedural_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fprocedural_macro.rs?ref=91aa82174531ef408c81325e0d31b508c1f26e0b", "patch": "@@ -1,11 +0,0 @@\n-#[macro_use]\n-extern crate clippy_mini_macro_test;\n-\n-#[deny(warnings)]\n-fn main() {\n-    let x = Foo;\n-    println!(\"{:?}\", x);\n-}\n-\n-#[derive(ClippyMiniMacroTest, Debug)]\n-struct Foo;"}, {"sha": "cba7666c2d8a7c9b8039fe08c7a0f429f49420d2", "filename": "tests/ui/def_id_nocore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fdef_id_nocore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fdef_id_nocore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdef_id_nocore.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -20,7 +20,7 @@ fn start(_argc: isize, _argv: *const *const u8) -> isize {\n     0\n }\n \n-pub struct A;\n+struct A;\n \n impl A {\n     pub fn as_ref(self) -> &'static str {"}, {"sha": "4ba9f0c1fcfff3f81a53f7aed583846abcba43e8", "filename": "tests/ui/deprecated.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -12,5 +12,7 @@\n #[warn(clippy::unknown_clippy_lints)]\n #[warn(clippy::find_map)]\n #[warn(clippy::filter_map)]\n+#[warn(clippy::pub_enum_variant_names)]\n+#[warn(clippy::wrong_pub_self_convention)]\n \n fn main() {}"}, {"sha": "03c9f438891363fe3250e951db20ad94299e0365", "filename": "tests/ui/deprecated.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fdeprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fdeprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -84,5 +84,17 @@ error: lint `clippy::filter_map` has been removed: this lint has been replaced b\n LL | #[warn(clippy::filter_map)]\n    |        ^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 14 previous errors\n+error: lint `clippy::pub_enum_variant_names` has been removed: set the `avoid_breaking_exported_api` config option to `false` to enable the `enum_variant_names` lint for public items\n+  --> $DIR/deprecated.rs:15:8\n+   |\n+LL | #[warn(clippy::pub_enum_variant_names)]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: lint `clippy::wrong_pub_self_convention` has been removed: set the `avoid_breaking_exported_api` config option to `false` to enable the `wrong_self_convention` lint for public items\n+  --> $DIR/deprecated.rs:16:8\n+   |\n+LL | #[warn(clippy::wrong_pub_self_convention)]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 16 previous errors\n "}, {"sha": "083f5143e6e4d75c662975f2f847b63d83ea41bb", "filename": "tests/ui/enum_variants.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fenum_variants.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,5 +1,4 @@\n-#![feature(non_ascii_idents)]\n-#![warn(clippy::enum_variant_names, clippy::pub_enum_variant_names)]\n+#![warn(clippy::enum_variant_names)]\n #![allow(non_camel_case_types, clippy::upper_case_acronyms)]\n \n enum FakeCallType {\n@@ -97,8 +96,8 @@ pub enum PubSeall {\n     WithOut,\n }\n \n-#[allow(clippy::pub_enum_variant_names)]\n-mod allowed {\n+#[allow(clippy::enum_variant_names)]\n+pub mod allowed {\n     pub enum PubAllowed {\n         SomeThis,\n         SomeThat,"}, {"sha": "447fbb9e1bff3440c35200354408ccdeb9fe60b1", "filename": "tests/ui/enum_variants.stderr", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fenum_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fenum_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fenum_variants.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,31 +1,31 @@\n error: variant name ends with the enum's name\n-  --> $DIR/enum_variants.rs:16:5\n+  --> $DIR/enum_variants.rs:15:5\n    |\n LL |     cFoo,\n    |     ^^^^\n    |\n    = note: `-D clippy::enum-variant-names` implied by `-D warnings`\n \n error: variant name starts with the enum's name\n-  --> $DIR/enum_variants.rs:27:5\n+  --> $DIR/enum_variants.rs:26:5\n    |\n LL |     FoodGood,\n    |     ^^^^^^^^\n \n error: variant name starts with the enum's name\n-  --> $DIR/enum_variants.rs:28:5\n+  --> $DIR/enum_variants.rs:27:5\n    |\n LL |     FoodMiddle,\n    |     ^^^^^^^^^^\n \n error: variant name starts with the enum's name\n-  --> $DIR/enum_variants.rs:29:5\n+  --> $DIR/enum_variants.rs:28:5\n    |\n LL |     FoodBad,\n    |     ^^^^^^^\n \n error: all variants have the same prefix: `Food`\n-  --> $DIR/enum_variants.rs:26:1\n+  --> $DIR/enum_variants.rs:25:1\n    |\n LL | / enum Food {\n LL | |     FoodGood,\n@@ -37,7 +37,7 @@ LL | | }\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n error: all variants have the same prefix: `CallType`\n-  --> $DIR/enum_variants.rs:36:1\n+  --> $DIR/enum_variants.rs:35:1\n    |\n LL | / enum BadCallType {\n LL | |     CallTypeCall,\n@@ -49,7 +49,7 @@ LL | | }\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n error: all variants have the same prefix: `Constant`\n-  --> $DIR/enum_variants.rs:48:1\n+  --> $DIR/enum_variants.rs:47:1\n    |\n LL | / enum Consts {\n LL | |     ConstantInt,\n@@ -61,7 +61,7 @@ LL | | }\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n error: all variants have the same prefix: `With`\n-  --> $DIR/enum_variants.rs:82:1\n+  --> $DIR/enum_variants.rs:81:1\n    |\n LL | / enum Seallll {\n LL | |     WithOutCake,\n@@ -73,7 +73,7 @@ LL | | }\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n error: all variants have the same prefix: `Prefix`\n-  --> $DIR/enum_variants.rs:88:1\n+  --> $DIR/enum_variants.rs:87:1\n    |\n LL | / enum NonCaps {\n LL | |     Prefix\u7684,\n@@ -84,21 +84,8 @@ LL | | }\n    |\n    = help: remove the prefixes and use full paths to the variants instead of glob imports\n \n-error: all variants have the same prefix: `With`\n-  --> $DIR/enum_variants.rs:94:1\n-   |\n-LL | / pub enum PubSeall {\n-LL | |     WithOutCake,\n-LL | |     WithOutTea,\n-LL | |     WithOut,\n-LL | | }\n-   | |_^\n-   |\n-   = note: `-D clippy::pub-enum-variant-names` implied by `-D warnings`\n-   = help: remove the prefixes and use full paths to the variants instead of glob imports\n-\n error: all variants have the same postfix: `IData`\n-  --> $DIR/enum_variants.rs:137:1\n+  --> $DIR/enum_variants.rs:136:1\n    |\n LL | / enum IDataRequest {\n LL | |     PutIData(String),\n@@ -110,7 +97,7 @@ LL | | }\n    = help: remove the postfixes and use full paths to the variants instead of glob imports\n \n error: all variants have the same postfix: `HIData`\n-  --> $DIR/enum_variants.rs:143:1\n+  --> $DIR/enum_variants.rs:142:1\n    |\n LL | / enum HIDataRequest {\n LL | |     PutHIData(String),\n@@ -121,5 +108,5 @@ LL | | }\n    |\n    = help: remove the postfixes and use full paths to the variants instead of glob imports\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "9e752311c67785c55478511712db79a6a003109d", "filename": "tests/ui/eta.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.fixed?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -48,6 +48,9 @@ fn main() {\n     // See #515\n     let a: Option<Box<dyn (::std::ops::Deref<Target = [i32]>)>> =\n         Some(vec![1i32, 2]).map(|v| -> Box<dyn (::std::ops::Deref<Target = [i32]>)> { Box::new(v) });\n+\n+    // issue #7224\n+    let _: Option<Vec<u32>> = Some(0).map(|_| vec![]);\n }\n \n trait TestTrait {"}, {"sha": "44be4628cbd34227eb51118c6698aa38f9d67efd", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -48,6 +48,9 @@ fn main() {\n     // See #515\n     let a: Option<Box<dyn (::std::ops::Deref<Target = [i32]>)>> =\n         Some(vec![1i32, 2]).map(|v| -> Box<dyn (::std::ops::Deref<Target = [i32]>)> { Box::new(v) });\n+\n+    // issue #7224\n+    let _: Option<Vec<u32>> = Some(0).map(|_| vec![]);\n }\n \n trait TestTrait {"}, {"sha": "8795d3b42c65af72146bf63c1d110246d81347f0", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -33,51 +33,51 @@ LL |     let e = Some(1u8).map(|a| generic(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `generic`\n \n error: redundant closure\n-  --> $DIR/eta.rs:89:51\n+  --> $DIR/eta.rs:92:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n    |                                                   ^^^^^^^^^^^ help: replace the closure with the method itself: `TestStruct::foo`\n    |\n    = note: `-D clippy::redundant-closure-for-method-calls` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:91:51\n+  --> $DIR/eta.rs:94:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n    |                                                   ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `TestTrait::trait_foo`\n \n error: redundant closure\n-  --> $DIR/eta.rs:94:42\n+  --> $DIR/eta.rs:97:42\n    |\n LL |     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n    |                                          ^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::vec::Vec::clear`\n \n error: redundant closure\n-  --> $DIR/eta.rs:99:29\n+  --> $DIR/eta.rs:102:29\n    |\n LL |     let e = Some(\"str\").map(|s| s.to_string());\n    |                             ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::string::ToString::to_string`\n \n error: redundant closure\n-  --> $DIR/eta.rs:101:27\n+  --> $DIR/eta.rs:104:27\n    |\n LL |     let e = Some('a').map(|s| s.to_uppercase());\n    |                           ^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:104:65\n+  --> $DIR/eta.rs:107:65\n    |\n LL |     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n    |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_ascii_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:187:27\n+  --> $DIR/eta.rs:190:27\n    |\n LL |     let a = Some(1u8).map(|a| foo_ptr(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo_ptr`\n \n error: redundant closure\n-  --> $DIR/eta.rs:192:27\n+  --> $DIR/eta.rs:195:27\n    |\n LL |     let a = Some(1u8).map(|a| closure(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `closure`"}, {"sha": "12db43b534361feb524ebaf57dd1c656eebd0040", "filename": "tests/ui/from_iter_instead_of_collect.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Ffrom_iter_instead_of_collect.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Ffrom_iter_instead_of_collect.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_iter_instead_of_collect.fixed?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -6,6 +6,20 @@\n use std::collections::{BTreeMap, BTreeSet, HashMap, VecDeque};\n use std::iter::FromIterator;\n \n+struct Foo(Vec<bool>);\n+\n+impl FromIterator<bool> for Foo {\n+    fn from_iter<T: IntoIterator<Item = bool>>(_: T) -> Self {\n+        todo!()\n+    }\n+}\n+\n+impl<'a> FromIterator<&'a bool> for Foo {\n+    fn from_iter<T: IntoIterator<Item = &'a bool>>(iter: T) -> Self {\n+        iter.into_iter().copied().collect::<Self>()\n+    }\n+}\n+\n fn main() {\n     let iter_expr = std::iter::repeat(5).take(5);\n     let _ = iter_expr.collect::<Vec<_>>();"}, {"sha": "f5ec190e0cdc512eaadb8c931c55d7df3e947c5e", "filename": "tests/ui/from_iter_instead_of_collect.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_iter_instead_of_collect.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -6,6 +6,20 @@\n use std::collections::{BTreeMap, BTreeSet, HashMap, VecDeque};\n use std::iter::FromIterator;\n \n+struct Foo(Vec<bool>);\n+\n+impl FromIterator<bool> for Foo {\n+    fn from_iter<T: IntoIterator<Item = bool>>(_: T) -> Self {\n+        todo!()\n+    }\n+}\n+\n+impl<'a> FromIterator<&'a bool> for Foo {\n+    fn from_iter<T: IntoIterator<Item = &'a bool>>(iter: T) -> Self {\n+        <Self as FromIterator<bool>>::from_iter(iter.into_iter().copied())\n+    }\n+}\n+\n fn main() {\n     let iter_expr = std::iter::repeat(5).take(5);\n     let _ = Vec::from_iter(iter_expr);"}, {"sha": "8f08ac8c3ff43c9686ddd479899c4ef3ce7a8380", "filename": "tests/ui/from_iter_instead_of_collect.stderr", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Ffrom_iter_instead_of_collect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Ffrom_iter_instead_of_collect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_iter_instead_of_collect.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,88 +1,94 @@\n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:11:13\n+  --> $DIR/from_iter_instead_of_collect.rs:19:9\n    |\n-LL |     let _ = Vec::from_iter(iter_expr);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `iter_expr.collect::<Vec<_>>()`\n+LL |         <Self as FromIterator<bool>>::from_iter(iter.into_iter().copied())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `iter.into_iter().copied().collect::<Self>()`\n    |\n    = note: `-D clippy::from-iter-instead-of-collect` implied by `-D warnings`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:13:13\n+  --> $DIR/from_iter_instead_of_collect.rs:25:13\n+   |\n+LL |     let _ = Vec::from_iter(iter_expr);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `iter_expr.collect::<Vec<_>>()`\n+\n+error: usage of `FromIterator::from_iter`\n+  --> $DIR/from_iter_instead_of_collect.rs:27:13\n    |\n LL |     let _ = HashMap::<usize, &i8>::from_iter(vec![5, 5, 5, 5].iter().enumerate());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `vec![5, 5, 5, 5].iter().enumerate().collect::<HashMap<usize, &i8>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:18:19\n+  --> $DIR/from_iter_instead_of_collect.rs:32:19\n    |\n LL |     assert_eq!(a, Vec::from_iter(0..3));\n    |                   ^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `(0..3).collect::<Vec<_>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:19:19\n+  --> $DIR/from_iter_instead_of_collect.rs:33:19\n    |\n LL |     assert_eq!(a, Vec::<i32>::from_iter(0..3));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `(0..3).collect::<Vec<i32>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:21:17\n+  --> $DIR/from_iter_instead_of_collect.rs:35:17\n    |\n LL |     let mut b = VecDeque::from_iter(0..3);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `(0..3).collect::<VecDeque<_>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:24:17\n+  --> $DIR/from_iter_instead_of_collect.rs:38:17\n    |\n LL |     let mut b = VecDeque::<i32>::from_iter(0..3);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `(0..3).collect::<VecDeque<i32>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:29:21\n+  --> $DIR/from_iter_instead_of_collect.rs:43:21\n    |\n LL |         let mut b = collections::VecDeque::<i32>::from_iter(0..3);\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `(0..3).collect::<collections::VecDeque<i32>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:34:14\n+  --> $DIR/from_iter_instead_of_collect.rs:48:14\n    |\n LL |     let bm = BTreeMap::from_iter(values.iter().cloned());\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `values.iter().cloned().collect::<BTreeMap<_, _>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:35:19\n+  --> $DIR/from_iter_instead_of_collect.rs:49:19\n    |\n LL |     let mut bar = BTreeMap::from_iter(bm.range(0..2));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `bm.range(0..2).collect::<BTreeMap<_, _>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:38:19\n+  --> $DIR/from_iter_instead_of_collect.rs:52:19\n    |\n LL |     let mut bts = BTreeSet::from_iter(0..3);\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `(0..3).collect::<BTreeSet<_>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:42:17\n+  --> $DIR/from_iter_instead_of_collect.rs:56:17\n    |\n LL |         let _ = collections::BTreeSet::from_iter(0..3);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `(0..3).collect::<collections::BTreeSet<_>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:43:17\n+  --> $DIR/from_iter_instead_of_collect.rs:57:17\n    |\n LL |         let _ = collections::BTreeSet::<u32>::from_iter(0..3);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `(0..3).collect::<collections::BTreeSet<u32>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:46:15\n+  --> $DIR/from_iter_instead_of_collect.rs:60:15\n    |\n LL |     for _i in Vec::from_iter([1, 2, 3].iter()) {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `[1, 2, 3].iter().collect::<Vec<_>>()`\n \n error: usage of `FromIterator::from_iter`\n-  --> $DIR/from_iter_instead_of_collect.rs:47:15\n+  --> $DIR/from_iter_instead_of_collect.rs:61:15\n    |\n LL |     for _i in Vec::<&i32>::from_iter([1, 2, 3].iter()) {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `.collect()` instead of `::from_iter()`: `[1, 2, 3].iter().collect::<Vec<&i32>>()`\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 15 previous errors\n "}, {"sha": "a2b8c2a384b03ac89d2593f0ccc22b6432d20357", "filename": "tests/ui/functions.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Ffunctions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Ffunctions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffunctions.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -30,57 +30,57 @@ error: this function has too many arguments (8/7)\n LL |     fn bad_method(_one: u32, _two: u32, _three: &str, _four: bool, _five: f32, _six: f32, _seven: bool, _eight: ()) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: this public function dereferences a raw pointer but is not marked `unsafe`\n+error: this public function might dereference a raw pointer but is not marked `unsafe`\n   --> $DIR/functions.rs:63:34\n    |\n LL |         println!(\"{}\", unsafe { *p });\n    |                                  ^\n    |\n    = note: `-D clippy::not-unsafe-ptr-arg-deref` implied by `-D warnings`\n \n-error: this public function dereferences a raw pointer but is not marked `unsafe`\n+error: this public function might dereference a raw pointer but is not marked `unsafe`\n   --> $DIR/functions.rs:64:35\n    |\n LL |         println!(\"{:?}\", unsafe { p.as_ref() });\n    |                                   ^\n \n-error: this public function dereferences a raw pointer but is not marked `unsafe`\n+error: this public function might dereference a raw pointer but is not marked `unsafe`\n   --> $DIR/functions.rs:65:33\n    |\n LL |         unsafe { std::ptr::read(p) };\n    |                                 ^\n \n-error: this public function dereferences a raw pointer but is not marked `unsafe`\n+error: this public function might dereference a raw pointer but is not marked `unsafe`\n   --> $DIR/functions.rs:76:30\n    |\n LL |     println!(\"{}\", unsafe { *p });\n    |                              ^\n \n-error: this public function dereferences a raw pointer but is not marked `unsafe`\n+error: this public function might dereference a raw pointer but is not marked `unsafe`\n   --> $DIR/functions.rs:77:31\n    |\n LL |     println!(\"{:?}\", unsafe { p.as_ref() });\n    |                               ^\n \n-error: this public function dereferences a raw pointer but is not marked `unsafe`\n+error: this public function might dereference a raw pointer but is not marked `unsafe`\n   --> $DIR/functions.rs:78:29\n    |\n LL |     unsafe { std::ptr::read(p) };\n    |                             ^\n \n-error: this public function dereferences a raw pointer but is not marked `unsafe`\n+error: this public function might dereference a raw pointer but is not marked `unsafe`\n   --> $DIR/functions.rs:87:34\n    |\n LL |         println!(\"{}\", unsafe { *p });\n    |                                  ^\n \n-error: this public function dereferences a raw pointer but is not marked `unsafe`\n+error: this public function might dereference a raw pointer but is not marked `unsafe`\n   --> $DIR/functions.rs:88:35\n    |\n LL |         println!(\"{:?}\", unsafe { p.as_ref() });\n    |                                   ^\n \n-error: this public function dereferences a raw pointer but is not marked `unsafe`\n+error: this public function might dereference a raw pointer but is not marked `unsafe`\n   --> $DIR/functions.rs:89:33\n    |\n LL |         unsafe { std::ptr::read(p) };"}, {"sha": "70d49d9f2c4ae1edd8497e9133f3598369431148", "filename": "tests/ui/macro_use_imports.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmacro_use_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmacro_use_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.fixed?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,6 +1,7 @@\n // compile-flags: --edition 2018\n // aux-build:macro_rules.rs\n // aux-build:macro_use_helper.rs\n+// aux-build:proc_macro_derive.rs\n // run-rustfix\n // ignore-32bit\n \n@@ -12,7 +13,7 @@\n extern crate macro_use_helper as mac;\n \n #[macro_use]\n-extern crate clippy_mini_macro_test as mini_mac;\n+extern crate proc_macro_derive as mini_mac;\n \n mod a {\n     use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro};"}, {"sha": "68370023861145dc15a29d4a6696138e06910d05", "filename": "tests/ui/macro_use_imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmacro_use_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmacro_use_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,6 +1,7 @@\n // compile-flags: --edition 2018\n // aux-build:macro_rules.rs\n // aux-build:macro_use_helper.rs\n+// aux-build:proc_macro_derive.rs\n // run-rustfix\n // ignore-32bit\n \n@@ -12,7 +13,7 @@\n extern crate macro_use_helper as mac;\n \n #[macro_use]\n-extern crate clippy_mini_macro_test as mini_mac;\n+extern crate proc_macro_derive as mini_mac;\n \n mod a {\n     #[macro_use]"}, {"sha": "49314b7506d336187642b16deee4aad13d34f342", "filename": "tests/ui/macro_use_imports.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmacro_use_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmacro_use_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,28 +1,28 @@\n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:18:5\n+  --> $DIR/macro_use_imports.rs:19:5\n    |\n LL |     #[macro_use]\n    |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro};`\n    |\n    = note: `-D clippy::macro-use-imports` implied by `-D warnings`\n \n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:20:5\n+  --> $DIR/macro_use_imports.rs:25:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mini_mac::ClippyMiniMacroTest;`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner::nested::string_add;`\n \n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:22:5\n+  --> $DIR/macro_use_imports.rs:21:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{inner::foofoo, inner::try_err};`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mini_mac::ClippyMiniMacroTest;`\n \n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:24:5\n+  --> $DIR/macro_use_imports.rs:23:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner::nested::string_add;`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{inner::foofoo, inner::try_err};`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "dc140257f32108c9c4c48d84578481b54d641dcf", "filename": "tests/ui/manual_str_repeat.fixed", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmanual_str_repeat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmanual_str_repeat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_str_repeat.fixed?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,66 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_str_repeat)]\n+\n+use std::borrow::Cow;\n+use std::iter::{repeat, FromIterator};\n+\n+fn main() {\n+    let _: String = \"test\".repeat(10);\n+    let _: String = \"x\".repeat(10);\n+    let _: String = \"'\".repeat(10);\n+    let _: String = \"\\\"\".repeat(10);\n+\n+    let x = \"test\";\n+    let count = 10;\n+    let _ = x.repeat(count + 2);\n+\n+    macro_rules! m {\n+        ($e:expr) => {{ $e }};\n+    }\n+    // FIXME: macro args are fine\n+    let _: String = repeat(m!(\"test\")).take(m!(count)).collect();\n+\n+    let x = &x;\n+    let _: String = (*x).repeat(count);\n+\n+    macro_rules! repeat_m {\n+        ($e:expr) => {{ repeat($e) }};\n+    }\n+    // Don't lint, repeat is from a macro.\n+    let _: String = repeat_m!(\"test\").take(count).collect();\n+\n+    let x: Box<str> = Box::from(\"test\");\n+    let _: String = x.repeat(count);\n+\n+    #[derive(Clone)]\n+    struct S;\n+    impl FromIterator<Box<S>> for String {\n+        fn from_iter<T: IntoIterator<Item = Box<S>>>(_: T) -> Self {\n+            Self::new()\n+        }\n+    }\n+    // Don't lint, wrong box type\n+    let _: String = repeat(Box::new(S)).take(count).collect();\n+\n+    let _: String = Cow::Borrowed(\"test\").repeat(count);\n+\n+    let x = \"x\".to_owned();\n+    let _: String = x.repeat(count);\n+\n+    let x = 'x';\n+    // Don't lint, not char literal\n+    let _: String = repeat(x).take(count).collect();\n+}\n+\n+fn _msrv_1_15() {\n+    #![clippy::msrv = \"1.15\"]\n+    // `str::repeat` was stabilized in 1.16. Do not lint this\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n+}\n+\n+fn _msrv_1_16() {\n+    #![clippy::msrv = \"1.16\"]\n+    let _: String = \"test\".repeat(10);\n+}"}, {"sha": "0d69c989b2ed84a0b616f773aa963e9ca30c9d14", "filename": "tests/ui/manual_str_repeat.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_str_repeat.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,66 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_str_repeat)]\n+\n+use std::borrow::Cow;\n+use std::iter::{repeat, FromIterator};\n+\n+fn main() {\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n+    let _: String = std::iter::repeat('x').take(10).collect();\n+    let _: String = std::iter::repeat('\\'').take(10).collect();\n+    let _: String = std::iter::repeat('\"').take(10).collect();\n+\n+    let x = \"test\";\n+    let count = 10;\n+    let _ = repeat(x).take(count + 2).collect::<String>();\n+\n+    macro_rules! m {\n+        ($e:expr) => {{ $e }};\n+    }\n+    // FIXME: macro args are fine\n+    let _: String = repeat(m!(\"test\")).take(m!(count)).collect();\n+\n+    let x = &x;\n+    let _: String = repeat(*x).take(count).collect();\n+\n+    macro_rules! repeat_m {\n+        ($e:expr) => {{ repeat($e) }};\n+    }\n+    // Don't lint, repeat is from a macro.\n+    let _: String = repeat_m!(\"test\").take(count).collect();\n+\n+    let x: Box<str> = Box::from(\"test\");\n+    let _: String = repeat(x).take(count).collect();\n+\n+    #[derive(Clone)]\n+    struct S;\n+    impl FromIterator<Box<S>> for String {\n+        fn from_iter<T: IntoIterator<Item = Box<S>>>(_: T) -> Self {\n+            Self::new()\n+        }\n+    }\n+    // Don't lint, wrong box type\n+    let _: String = repeat(Box::new(S)).take(count).collect();\n+\n+    let _: String = repeat(Cow::Borrowed(\"test\")).take(count).collect();\n+\n+    let x = \"x\".to_owned();\n+    let _: String = repeat(x).take(count).collect();\n+\n+    let x = 'x';\n+    // Don't lint, not char literal\n+    let _: String = repeat(x).take(count).collect();\n+}\n+\n+fn _msrv_1_15() {\n+    #![clippy::msrv = \"1.15\"]\n+    // `str::repeat` was stabilized in 1.16. Do not lint this\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n+}\n+\n+fn _msrv_1_16() {\n+    #![clippy::msrv = \"1.16\"]\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n+}"}, {"sha": "c65116897164409e7b4ecb3862bfce925418b6c9", "filename": "tests/ui/manual_str_repeat.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmanual_str_repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmanual_str_repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_str_repeat.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,64 @@\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:10:21\n+   |\n+LL |     let _: String = std::iter::repeat(\"test\").take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"test\".repeat(10)`\n+   |\n+   = note: `-D clippy::manual-str-repeat` implied by `-D warnings`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:11:21\n+   |\n+LL |     let _: String = std::iter::repeat('x').take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"x\".repeat(10)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:12:21\n+   |\n+LL |     let _: String = std::iter::repeat('/'').take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"'\".repeat(10)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:13:21\n+   |\n+LL |     let _: String = std::iter::repeat('\"').take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"/\"\".repeat(10)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:17:13\n+   |\n+LL |     let _ = repeat(x).take(count + 2).collect::<String>();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.repeat(count + 2)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:26:21\n+   |\n+LL |     let _: String = repeat(*x).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(*x).repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:35:21\n+   |\n+LL |     let _: String = repeat(x).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:47:21\n+   |\n+LL |     let _: String = repeat(Cow::Borrowed(\"test\")).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Cow::Borrowed(\"test\").repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:50:21\n+   |\n+LL |     let _: String = repeat(x).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:65:21\n+   |\n+LL |     let _: String = std::iter::repeat(\"test\").take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"test\".repeat(10)`\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "bfa9ef01b0e9535e4f19fabe9ed0e8113b513695", "filename": "tests/ui/missing-doc-impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmissing-doc-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmissing-doc-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing-doc-impl.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -67,7 +67,10 @@ impl PubFoo {\n     pub fn foo() {}\n     /// dox\n     pub fn foo1() {}\n-    fn foo2() {}\n+    #[must_use = \"yep\"]\n+    fn foo2() -> u32 {\n+        1\n+    }\n     #[allow(clippy::missing_docs_in_private_items)]\n     pub fn foo3() {}\n }"}, {"sha": "d33d512475b2389ec8bbd926ba28c132deb6a268", "filename": "tests/ui/missing-doc-impl.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmissing-doc-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmissing-doc-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing-doc-impl.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -94,10 +94,12 @@ LL |     pub fn foo() {}\n    |     ^^^^^^^^^^^^^^^\n \n error: missing documentation for an associated function\n-  --> $DIR/missing-doc-impl.rs:70:5\n+  --> $DIR/missing-doc-impl.rs:71:5\n    |\n-LL |     fn foo2() {}\n-   |     ^^^^^^^^^^^^\n+LL | /     fn foo2() -> u32 {\n+LL | |         1\n+LL | |     }\n+   | |_____^\n \n error: aborting due to 15 previous errors\n "}, {"sha": "f5908cb5701fbe9a3e62a1779951aad18baf6af6", "filename": "tests/ui/module_name_repetitions.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmodule_name_repetitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fmodule_name_repetitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmodule_name_repetitions.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -15,12 +15,4 @@ mod foo {\n     pub struct Foobar;\n }\n \n-#[cfg(test)]\n-mod test {\n-    #[test]\n-    fn it_works() {\n-        assert_eq!(2 + 2, 4);\n-    }\n-}\n-\n fn main() {}"}, {"sha": "a87171dc3f24d80a8abf684916ac58e39bd29e80", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -18,7 +18,6 @@ fn main() {\n     let vec = Vec::new();\n     let vec_val = g(&vec); // should not error, because `&Vec<T>` derefs to `&[T]`\n     h(&\"foo\"); // should not error, because the `&&str` is required, due to `&Trait`\n-    if let Some(cake) = Some(&5) {}\n     let garbl = match 42 {\n         44 => &a,\n         45 => {\n@@ -43,19 +42,3 @@ trait Trait {}\n impl<'a> Trait for &'a str {}\n \n fn h(_: &dyn Trait) {}\n-#[warn(clippy::needless_borrow)]\n-#[allow(dead_code)]\n-fn issue_1432() {\n-    let mut v = Vec::<String>::new();\n-    let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n-    let _ = v.iter().filter(|&a| a.is_empty());\n-\n-    let _ = v.iter().filter(|&a| a.is_empty());\n-}\n-\n-#[allow(dead_code)]\n-#[warn(clippy::needless_borrow)]\n-#[derive(Debug)]\n-enum Foo<'a> {\n-    Str(&'a str),\n-}"}, {"sha": "059dc8ceac31a1521aabc2928d80b9b129d7b003", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -18,7 +18,6 @@ fn main() {\n     let vec = Vec::new();\n     let vec_val = g(&vec); // should not error, because `&Vec<T>` derefs to `&[T]`\n     h(&\"foo\"); // should not error, because the `&&str` is required, due to `&Trait`\n-    if let Some(ref cake) = Some(&5) {}\n     let garbl = match 42 {\n         44 => &a,\n         45 => {\n@@ -43,19 +42,3 @@ trait Trait {}\n impl<'a> Trait for &'a str {}\n \n fn h(_: &dyn Trait) {}\n-#[warn(clippy::needless_borrow)]\n-#[allow(dead_code)]\n-fn issue_1432() {\n-    let mut v = Vec::<String>::new();\n-    let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n-    let _ = v.iter().filter(|&ref a| a.is_empty());\n-\n-    let _ = v.iter().filter(|&a| a.is_empty());\n-}\n-\n-#[allow(dead_code)]\n-#[warn(clippy::needless_borrow)]\n-#[derive(Debug)]\n-enum Foo<'a> {\n-    Str(&'a str),\n-}"}, {"sha": "6eddf26db068f8fa58f3f89894f2ca3cd6d02978", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -6,23 +6,11 @@ LL |     let c = x(&&a);\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n-error: this pattern creates a reference to a reference\n-  --> $DIR/needless_borrow.rs:21:17\n-   |\n-LL |     if let Some(ref cake) = Some(&5) {}\n-   |                 ^^^^^^^^ help: change this to: `cake`\n-\n error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:28:15\n+  --> $DIR/needless_borrow.rs:27:15\n    |\n LL |         46 => &&a,\n    |               ^^^ help: change this to: `&a`\n \n-error: this pattern creates a reference to a reference\n-  --> $DIR/needless_borrow.rs:51:31\n-   |\n-LL |     let _ = v.iter().filter(|&ref a| a.is_empty());\n-   |                               ^^^^^ help: change this to: `a`\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "f0926220755a2006f061657a43aad2188e932a38", "filename": "tests/ui/needless_borrow_pat.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_borrow_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_borrow_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow_pat.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,151 @@\n+// edition:2018\n+// FIXME: run-rustfix waiting on multi-span suggestions\n+\n+#![warn(clippy::needless_borrow)]\n+#![allow(clippy::needless_borrowed_reference)]\n+\n+fn f1(_: &str) {}\n+macro_rules! m1 {\n+    ($e:expr) => {\n+        f1($e);\n+    };\n+}\n+macro_rules! m3 {\n+    ($i:ident) => {\n+        Some(ref $i)\n+    };\n+}\n+macro_rules! if_chain {\n+    (if $e:expr; $($rest:tt)*) => {\n+        if $e {\n+            if_chain!($($rest)*)\n+        }\n+    };\n+\n+    (if let $p:pat = $e:expr; $($rest:tt)*) => {\n+        if let $p = $e {\n+            if_chain!($($rest)*)\n+        }\n+    };\n+\n+    (then $b:block) => {\n+        $b\n+    };\n+}\n+\n+#[allow(dead_code)]\n+fn main() {\n+    let x = String::new();\n+\n+    // Ok, reference to a String.\n+    let _: &String = match Some(x.clone()) {\n+        Some(ref x) => x,\n+        None => return,\n+    };\n+\n+    // Ok, reference to a &mut String\n+    let _: &&mut String = match Some(&mut x.clone()) {\n+        Some(ref x) => x,\n+        None => return,\n+    };\n+\n+    // Ok, the pattern is from a macro\n+    let _: &String = match Some(&x) {\n+        m3!(x) => x,\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    let _: &String = match Some(&x) {\n+        Some(ref x) => x,\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String.\n+    let _: &String = match Some(&x) {\n+        Some(ref x) => *x,\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    let _: &String = match Some(&x) {\n+        Some(ref x) => {\n+            f1(x);\n+            f1(*x);\n+            x\n+        },\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    match Some(&x) {\n+        Some(ref x) => m1!(x),\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    let _ = |&ref x: &&String| {\n+        let _: &String = x;\n+    };\n+\n+    // Err, reference to a &String\n+    let (ref y,) = (&x,);\n+    let _: &String = *y;\n+\n+    let y = &&x;\n+    // Ok, different y\n+    let _: &String = *y;\n+\n+    let x = (0, 0);\n+    // Err, reference to a &u32. Don't suggest adding a reference to the field access.\n+    let _: u32 = match Some(&x) {\n+        Some(ref x) => x.0,\n+        None => return,\n+    };\n+\n+    enum E {\n+        A(&'static u32),\n+        B(&'static u32),\n+    }\n+    // Err, reference to &u32.\n+    let _: &u32 = match E::A(&0) {\n+        E::A(ref x) | E::B(ref x) => *x,\n+    };\n+\n+    // Err, reference to &String.\n+    if_chain! {\n+        if true;\n+        if let Some(ref x) = Some(&String::new());\n+        then {\n+            f1(x);\n+        }\n+    }\n+}\n+\n+// Err, reference to a &String\n+fn f2<'a>(&ref x: &&'a String) -> &'a String {\n+    let _: &String = x;\n+    *x\n+}\n+\n+trait T1 {\n+    // Err, reference to a &String\n+    fn f(&ref x: &&String) {\n+        let _: &String = x;\n+    }\n+}\n+\n+struct S;\n+impl T1 for S {\n+    // Err, reference to a &String\n+    fn f(&ref x: &&String) {\n+        let _: &String = *x;\n+    }\n+}\n+\n+// Ok - used to error due to rustc bug\n+#[allow(dead_code)]\n+#[derive(Debug)]\n+enum Foo<'a> {\n+    Str(&'a str),\n+}"}, {"sha": "32913d59f7ae89075354b675f4f5afc58da5308c", "filename": "tests/ui/needless_borrow_pat.stderr", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_borrow_pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_borrow_pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow_pat.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,112 @@\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:60:14\n+   |\n+LL |         Some(ref x) => x,\n+   |              ^^^^^ help: try this: `x`\n+   |\n+   = note: `-D clippy::needless-borrow` implied by `-D warnings`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:66:14\n+   |\n+LL |         Some(ref x) => *x,\n+   |              ^^^^^\n+   |\n+help: try this\n+   |\n+LL |         Some(x) => x,\n+   |              ^     ^\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:72:14\n+   |\n+LL |         Some(ref x) => {\n+   |              ^^^^^\n+   |\n+help: try this\n+   |\n+LL |         Some(x) => {\n+LL |             f1(x);\n+LL |             f1(x);\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:82:14\n+   |\n+LL |         Some(ref x) => m1!(x),\n+   |              ^^^^^ help: try this: `x`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:87:15\n+   |\n+LL |     let _ = |&ref x: &&String| {\n+   |               ^^^^^ help: try this: `x`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:92:10\n+   |\n+LL |     let (ref y,) = (&x,);\n+   |          ^^^^^\n+   |\n+help: try this\n+   |\n+LL |     let (y,) = (&x,);\n+LL |     let _: &String = y;\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:102:14\n+   |\n+LL |         Some(ref x) => x.0,\n+   |              ^^^^^ help: try this: `x`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:112:14\n+   |\n+LL |         E::A(ref x) | E::B(ref x) => *x,\n+   |              ^^^^^         ^^^^^\n+   |\n+help: try this\n+   |\n+LL |         E::A(x) | E::B(x) => x,\n+   |              ^         ^     ^\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:118:21\n+   |\n+LL |         if let Some(ref x) = Some(&String::new());\n+   |                     ^^^^^ help: try this: `x`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:126:12\n+   |\n+LL | fn f2<'a>(&ref x: &&'a String) -> &'a String {\n+   |            ^^^^^\n+   |\n+help: try this\n+   |\n+LL | fn f2<'a>(&x: &&'a String) -> &'a String {\n+LL |     let _: &String = x;\n+LL |     x\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:133:11\n+   |\n+LL |     fn f(&ref x: &&String) {\n+   |           ^^^^^ help: try this: `x`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:141:11\n+   |\n+LL |     fn f(&ref x: &&String) {\n+   |           ^^^^^\n+   |\n+help: try this\n+   |\n+LL |     fn f(&x: &&String) {\n+LL |         let _: &String = x;\n+   |\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "2c94235b8f533279ba502e12a95c88c1372fb9c9", "filename": "tests/ui/needless_collect_indirect.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::{BinaryHeap, HashMap, LinkedList, VecDeque};\n+use std::collections::{BinaryHeap, HashMap, HashSet, LinkedList, VecDeque};\n \n fn main() {\n     let sample = [1; 5];\n@@ -75,3 +75,9 @@ mod issue7110 {\n         buffer.len()\n     }\n }\n+\n+fn allow_test() {\n+    #[allow(clippy::needless_collect)]\n+    let v = [1].iter().collect::<Vec<_>>();\n+    v.into_iter().collect::<HashSet<_>>();\n+}"}, {"sha": "7ec845adfaacf6d290e4d4be2011f3b0917d2621", "filename": "tests/ui/no_effect.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fno_effect.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -91,6 +91,9 @@ fn main() {\n     let s: String = \"foo\".into();\n     FooString { s: s };\n \n+    #[allow(clippy::no_effect)]\n+    0;\n+\n     // Do not warn\n     get_number();\n     unsafe { unsafe_fn() };"}, {"sha": "c7235e1c221057528a40b310a372971cf0201f87", "filename": "tests/ui/ref_binding_to_reference.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fref_binding_to_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fref_binding_to_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fref_binding_to_reference.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,76 @@\n+// edition:2018\n+// FIXME: run-rustfix waiting on multi-span suggestions\n+\n+#![warn(clippy::ref_binding_to_reference)]\n+#![allow(clippy::needless_borrowed_reference)]\n+\n+fn f1(_: &str) {}\n+macro_rules! m2 {\n+    ($e:expr) => {\n+        f1(*$e);\n+    };\n+}\n+macro_rules! m3 {\n+    ($i:ident) => {\n+        Some(ref $i)\n+    };\n+}\n+\n+#[allow(dead_code)]\n+fn main() {\n+    let x = String::new();\n+\n+    // Ok, the pattern is from a macro\n+    let _: &&String = match Some(&x) {\n+        m3!(x) => x,\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    let _: &&String = match Some(&x) {\n+        Some(ref x) => x,\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    let _: &&String = match Some(&x) {\n+        Some(ref x) => {\n+            f1(x);\n+            f1(*x);\n+            x\n+        },\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    match Some(&x) {\n+        Some(ref x) => m2!(x),\n+        None => return,\n+    }\n+\n+    // Err, reference to a &String\n+    let _ = |&ref x: &&String| {\n+        let _: &&String = x;\n+    };\n+}\n+\n+// Err, reference to a &String\n+fn f2<'a>(&ref x: &&'a String) -> &'a String {\n+    let _: &&String = x;\n+    *x\n+}\n+\n+trait T1 {\n+    // Err, reference to a &String\n+    fn f(&ref x: &&String) {\n+        let _: &&String = x;\n+    }\n+}\n+\n+struct S;\n+impl T1 for S {\n+    // Err, reference to a &String\n+    fn f(&ref x: &&String) {\n+        let _: &&String = x;\n+    }\n+}"}, {"sha": "00aeff4fefa32536d43acb6bc3ae9261c0e603fb", "filename": "tests/ui/ref_binding_to_reference.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fref_binding_to_reference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fref_binding_to_reference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fref_binding_to_reference.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,88 @@\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:31:14\n+   |\n+LL |         Some(ref x) => x,\n+   |              ^^^^^\n+   |\n+   = note: `-D clippy::ref-binding-to-reference` implied by `-D warnings`\n+help: try this\n+   |\n+LL |         Some(x) => &x,\n+   |              ^     ^^\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:37:14\n+   |\n+LL |         Some(ref x) => {\n+   |              ^^^^^\n+   |\n+help: try this\n+   |\n+LL |         Some(x) => {\n+LL |             f1(x);\n+LL |             f1(x);\n+LL |             &x\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:47:14\n+   |\n+LL |         Some(ref x) => m2!(x),\n+   |              ^^^^^\n+   |\n+help: try this\n+   |\n+LL |         Some(x) => m2!(&x),\n+   |              ^         ^^\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:52:15\n+   |\n+LL |     let _ = |&ref x: &&String| {\n+   |               ^^^^^\n+   |\n+help: try this\n+   |\n+LL |     let _ = |&x: &&String| {\n+LL |         let _: &&String = &x;\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:58:12\n+   |\n+LL | fn f2<'a>(&ref x: &&'a String) -> &'a String {\n+   |            ^^^^^\n+   |\n+help: try this\n+   |\n+LL | fn f2<'a>(&x: &&'a String) -> &'a String {\n+LL |     let _: &&String = &x;\n+LL |     x\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:65:11\n+   |\n+LL |     fn f(&ref x: &&String) {\n+   |           ^^^^^\n+   |\n+help: try this\n+   |\n+LL |     fn f(&x: &&String) {\n+LL |         let _: &&String = &x;\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:73:11\n+   |\n+LL |     fn f(&ref x: &&String) {\n+   |           ^^^^^\n+   |\n+help: try this\n+   |\n+LL |     fn f(&x: &&String) {\n+LL |         let _: &&String = &x;\n+   |\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "2b1bc1f48595977245d7de1c62932ff2cc2eda8c", "filename": "tests/ui/similar_names.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsimilar_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsimilar_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsimilar_names.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -72,6 +72,10 @@ fn main() {\n     let rx1: i32;\n     let tx_cake: i32;\n     let rx_cake: i32;\n+\n+    // names often used in win32 code (for example WindowProc)\n+    let wparam: i32;\n+    let lparam: i32;\n }\n \n fn foo() {"}, {"sha": "a7eb2be077802795983125ccaa4bc02c8fd9c0a0", "filename": "tests/ui/similar_names.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsimilar_names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsimilar_names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsimilar_names.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -92,13 +92,13 @@ LL |     let parsee: i32;\n    |         ^^^^^^\n \n error: binding's name is too similar to existing binding\n-  --> $DIR/similar_names.rs:81:16\n+  --> $DIR/similar_names.rs:85:16\n    |\n LL |         bpple: sprang,\n    |                ^^^^^^\n    |\n note: existing binding defined here\n-  --> $DIR/similar_names.rs:80:16\n+  --> $DIR/similar_names.rs:84:16\n    |\n LL |         apple: spring,\n    |                ^^^^^^"}, {"sha": "1abd2b7883df0bd06f0fd5e456c4f29c6d350060", "filename": "tests/ui/single_char_pattern.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsingle_char_pattern.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsingle_char_pattern.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_pattern.fixed?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -25,8 +25,8 @@ fn main() {\n     x.rsplit('x');\n     x.split_terminator('x');\n     x.rsplit_terminator('x');\n-    x.splitn(0, 'x');\n-    x.rsplitn(0, 'x');\n+    x.splitn(2, 'x');\n+    x.rsplitn(2, 'x');\n     x.matches('x');\n     x.rmatches('x');\n     x.match_indices('x');"}, {"sha": "e662bf34be2ceffb5ba409fe03613bbdb3710494", "filename": "tests/ui/single_char_pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_pattern.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -25,8 +25,8 @@ fn main() {\n     x.rsplit(\"x\");\n     x.split_terminator(\"x\");\n     x.rsplit_terminator(\"x\");\n-    x.splitn(0, \"x\");\n-    x.rsplitn(0, \"x\");\n+    x.splitn(2, \"x\");\n+    x.rsplitn(2, \"x\");\n     x.matches(\"x\");\n     x.rmatches(\"x\");\n     x.match_indices(\"x\");"}, {"sha": "22d4b2d460fb047e217091ac1ff741c4a20e93bf", "filename": "tests/ui/single_char_pattern.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsingle_char_pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsingle_char_pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_pattern.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -75,13 +75,13 @@ LL |     x.rsplit_terminator(\"x\");\n error: single-character string constant used as pattern\n   --> $DIR/single_char_pattern.rs:28:17\n    |\n-LL |     x.splitn(0, \"x\");\n+LL |     x.splitn(2, \"x\");\n    |                 ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n   --> $DIR/single_char_pattern.rs:29:18\n    |\n-LL |     x.rsplitn(0, \"x\");\n+LL |     x.rsplitn(2, \"x\");\n    |                  ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern"}, {"sha": "a21d94cf20bb1238195c5ffd451b68200d7da0dd", "filename": "tests/ui/suspicious_splitn.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_splitn.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,20 @@\n+#![warn(clippy::suspicious_splitn)]\n+\n+fn main() {\n+    let _ = \"a,b,c\".splitn(3, ',');\n+    let _ = [0, 1, 2, 1, 3].splitn(3, |&x| x == 1);\n+    let _ = \"\".splitn(0, ',');\n+    let _ = [].splitn(0, |&x: &u32| x == 1);\n+\n+    let _ = \"a,b\".splitn(0, ',');\n+    let _ = \"a,b\".rsplitn(0, ',');\n+    let _ = \"a,b\".splitn(1, ',');\n+    let _ = [0, 1, 2].splitn(0, |&x| x == 1);\n+    let _ = [0, 1, 2].splitn_mut(0, |&x| x == 1);\n+    let _ = [0, 1, 2].splitn(1, |&x| x == 1);\n+    let _ = [0, 1, 2].rsplitn_mut(1, |&x| x == 1);\n+\n+    const X: usize = 0;\n+    let _ = \"a,b\".splitn(X + 1, ',');\n+    let _ = \"a,b\".splitn(X, ',');\n+}"}, {"sha": "b6220ae239339fbd0c162c03d0c9f905facbab89", "filename": "tests/ui/suspicious_splitn.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsuspicious_splitn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fsuspicious_splitn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_splitn.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -0,0 +1,75 @@\n+error: `splitn` called with `0` splits\n+  --> $DIR/suspicious_splitn.rs:9:13\n+   |\n+LL |     let _ = \"a,b\".splitn(0, ',');\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::suspicious-splitn` implied by `-D warnings`\n+   = note: the resulting iterator will always return `None`\n+\n+error: `rsplitn` called with `0` splits\n+  --> $DIR/suspicious_splitn.rs:10:13\n+   |\n+LL |     let _ = \"a,b\".rsplitn(0, ',');\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the resulting iterator will always return `None`\n+\n+error: `splitn` called with `1` split\n+  --> $DIR/suspicious_splitn.rs:11:13\n+   |\n+LL |     let _ = \"a,b\".splitn(1, ',');\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the resulting iterator will always return the entire string followed by `None`\n+\n+error: `splitn` called with `0` splits\n+  --> $DIR/suspicious_splitn.rs:12:13\n+   |\n+LL |     let _ = [0, 1, 2].splitn(0, |&x| x == 1);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the resulting iterator will always return `None`\n+\n+error: `splitn_mut` called with `0` splits\n+  --> $DIR/suspicious_splitn.rs:13:13\n+   |\n+LL |     let _ = [0, 1, 2].splitn_mut(0, |&x| x == 1);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the resulting iterator will always return `None`\n+\n+error: `splitn` called with `1` split\n+  --> $DIR/suspicious_splitn.rs:14:13\n+   |\n+LL |     let _ = [0, 1, 2].splitn(1, |&x| x == 1);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the resulting iterator will always return the entire slice followed by `None`\n+\n+error: `rsplitn_mut` called with `1` split\n+  --> $DIR/suspicious_splitn.rs:15:13\n+   |\n+LL |     let _ = [0, 1, 2].rsplitn_mut(1, |&x| x == 1);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the resulting iterator will always return the entire slice followed by `None`\n+\n+error: `splitn` called with `1` split\n+  --> $DIR/suspicious_splitn.rs:18:13\n+   |\n+LL |     let _ = \"a,b\".splitn(X + 1, ',');\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the resulting iterator will always return the entire string followed by `None`\n+\n+error: `splitn` called with `0` splits\n+  --> $DIR/suspicious_splitn.rs:19:13\n+   |\n+LL |     let _ = \"a,b\".splitn(X, ',');\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the resulting iterator will always return `None`\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "2b0005bbff1db6911305327e40e40799a604ede9", "filename": "tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -88,12 +88,6 @@ error: this argument (N byte) is passed by reference, but would be more efficien\n LL |     fn trait_method(&self, _foo: &Foo);\n    |                                  ^^^^ help: consider passing by value instead: `Foo`\n \n-error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n-  --> $DIR/trivially_copy_pass_by_ref.rs:80:37\n-   |\n-LL |     fn trait_method2(&self, _color: &Color);\n-   |                                     ^^^^^^ help: consider passing by value instead: `Color`\n-\n error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n   --> $DIR/trivially_copy_pass_by_ref.rs:108:21\n    |\n@@ -106,5 +100,5 @@ error: this argument (N byte) is passed by reference, but would be more efficien\n LL |     fn foo(x: &i32) {\n    |               ^^^^ help: consider passing by value instead: `i32`\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "63648ef5826f6e1f2c5009050393c4b884e9a735", "filename": "tests/ui/unnecessary_wraps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_wraps.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -65,7 +65,7 @@ fn func10() -> Option<()> {\n     unimplemented!()\n }\n \n-struct A;\n+pub struct A;\n \n impl A {\n     // should not be linted"}, {"sha": "f0c2ba7ccdfa0d1a7de8e7cb0cd243015e428159", "filename": "tests/ui/unseparated_prefix_literals.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Funseparated_prefix_literals.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Funseparated_prefix_literals.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funseparated_prefix_literals.fixed?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,10 +1,11 @@\n // run-rustfix\n+// aux-build:proc_macro_derive.rs\n \n #![warn(clippy::unseparated_literal_suffix)]\n #![allow(dead_code)]\n \n #[macro_use]\n-extern crate clippy_mini_macro_test;\n+extern crate proc_macro_derive;\n \n // Test for proc-macro attribute\n #[derive(ClippyMiniMacroTest)]"}, {"sha": "f44880b414756d2deb1d480ab19b168504192408", "filename": "tests/ui/unseparated_prefix_literals.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Funseparated_prefix_literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Funseparated_prefix_literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funseparated_prefix_literals.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,10 +1,11 @@\n // run-rustfix\n+// aux-build:proc_macro_derive.rs\n \n #![warn(clippy::unseparated_literal_suffix)]\n #![allow(dead_code)]\n \n #[macro_use]\n-extern crate clippy_mini_macro_test;\n+extern crate proc_macro_derive;\n \n // Test for proc-macro attribute\n #[derive(ClippyMiniMacroTest)]"}, {"sha": "ab2f75e0c56deca65bfc00e8762e536827bcb7d0", "filename": "tests/ui/unseparated_prefix_literals.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Funseparated_prefix_literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Funseparated_prefix_literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funseparated_prefix_literals.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,49 +1,49 @@\n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:23:18\n+  --> $DIR/unseparated_prefix_literals.rs:24:18\n    |\n LL |     let _fail1 = 1234i32;\n    |                  ^^^^^^^ help: add an underscore: `1234_i32`\n    |\n    = note: `-D clippy::unseparated-literal-suffix` implied by `-D warnings`\n \n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:24:18\n+  --> $DIR/unseparated_prefix_literals.rs:25:18\n    |\n LL |     let _fail2 = 1234u32;\n    |                  ^^^^^^^ help: add an underscore: `1234_u32`\n \n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:25:18\n+  --> $DIR/unseparated_prefix_literals.rs:26:18\n    |\n LL |     let _fail3 = 1234isize;\n    |                  ^^^^^^^^^ help: add an underscore: `1234_isize`\n \n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:26:18\n+  --> $DIR/unseparated_prefix_literals.rs:27:18\n    |\n LL |     let _fail4 = 1234usize;\n    |                  ^^^^^^^^^ help: add an underscore: `1234_usize`\n \n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:27:18\n+  --> $DIR/unseparated_prefix_literals.rs:28:18\n    |\n LL |     let _fail5 = 0x123isize;\n    |                  ^^^^^^^^^^ help: add an underscore: `0x123_isize`\n \n error: float type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:31:19\n+  --> $DIR/unseparated_prefix_literals.rs:32:19\n    |\n LL |     let _failf1 = 1.5f32;\n    |                   ^^^^^^ help: add an underscore: `1.5_f32`\n \n error: float type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:32:19\n+  --> $DIR/unseparated_prefix_literals.rs:33:19\n    |\n LL |     let _failf2 = 1f32;\n    |                   ^^^^ help: add an underscore: `1_f32`\n \n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:15:9\n+  --> $DIR/unseparated_prefix_literals.rs:16:9\n    |\n LL |         42usize\n    |         ^^^^^^^ help: add an underscore: `42_usize`\n@@ -54,7 +54,7 @@ LL |     let _ = lit_from_macro!();\n    = note: this error originates in the macro `lit_from_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:40:16\n+  --> $DIR/unseparated_prefix_literals.rs:41:16\n    |\n LL |     assert_eq!(4897u32, 32223);\n    |                ^^^^^^^ help: add an underscore: `4897_u32`"}, {"sha": "151dd0c27d57dbab4f7b4e98f485eb3993e10b3b", "filename": "tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,6 +1,5 @@\n // edition:2018\n #![warn(clippy::wrong_self_convention)]\n-#![warn(clippy::wrong_pub_self_convention)]\n #![allow(dead_code)]\n \n fn main() {}"}, {"sha": "ce23317abf651f59f66ca971aeb15e1520355cfa", "filename": "tests/ui/wrong_self_convention.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,5 +1,5 @@\n error: methods called `from_*` usually take no `self`\n-  --> $DIR/wrong_self_convention.rs:18:17\n+  --> $DIR/wrong_self_convention.rs:17:17\n    |\n LL |     fn from_i32(self) {}\n    |                 ^^^^\n@@ -8,183 +8,183 @@ LL |     fn from_i32(self) {}\n    = help: consider choosing a less ambiguous name\n \n error: methods called `from_*` usually take no `self`\n-  --> $DIR/wrong_self_convention.rs:24:21\n+  --> $DIR/wrong_self_convention.rs:23:21\n    |\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `as_*` usually take `self` by reference or `self` by mutable reference\n-  --> $DIR/wrong_self_convention.rs:36:15\n+  --> $DIR/wrong_self_convention.rs:35:15\n    |\n LL |     fn as_i32(self) {}\n    |               ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `into_*` usually take `self` by value\n-  --> $DIR/wrong_self_convention.rs:38:17\n+  --> $DIR/wrong_self_convention.rs:37:17\n    |\n LL |     fn into_i32(&self) {}\n    |                 ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `is_*` usually take `self` by reference or no `self`\n-  --> $DIR/wrong_self_convention.rs:40:15\n+  --> $DIR/wrong_self_convention.rs:39:15\n    |\n LL |     fn is_i32(self) {}\n    |               ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\n-  --> $DIR/wrong_self_convention.rs:42:15\n+  --> $DIR/wrong_self_convention.rs:41:15\n    |\n LL |     fn to_i32(self) {}\n    |               ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `from_*` usually take no `self`\n-  --> $DIR/wrong_self_convention.rs:44:17\n+  --> $DIR/wrong_self_convention.rs:43:17\n    |\n LL |     fn from_i32(self) {}\n    |                 ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `as_*` usually take `self` by reference or `self` by mutable reference\n-  --> $DIR/wrong_self_convention.rs:46:19\n+  --> $DIR/wrong_self_convention.rs:45:19\n    |\n LL |     pub fn as_i64(self) {}\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `into_*` usually take `self` by value\n-  --> $DIR/wrong_self_convention.rs:47:21\n+  --> $DIR/wrong_self_convention.rs:46:21\n    |\n LL |     pub fn into_i64(&self) {}\n    |                     ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `is_*` usually take `self` by reference or no `self`\n-  --> $DIR/wrong_self_convention.rs:48:19\n+  --> $DIR/wrong_self_convention.rs:47:19\n    |\n LL |     pub fn is_i64(self) {}\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\n-  --> $DIR/wrong_self_convention.rs:49:19\n+  --> $DIR/wrong_self_convention.rs:48:19\n    |\n LL |     pub fn to_i64(self) {}\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `from_*` usually take no `self`\n-  --> $DIR/wrong_self_convention.rs:50:21\n+  --> $DIR/wrong_self_convention.rs:49:21\n    |\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `as_*` usually take `self` by reference or `self` by mutable reference\n-  --> $DIR/wrong_self_convention.rs:95:19\n+  --> $DIR/wrong_self_convention.rs:94:19\n    |\n LL |         fn as_i32(self) {}\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `into_*` usually take `self` by value\n-  --> $DIR/wrong_self_convention.rs:98:25\n+  --> $DIR/wrong_self_convention.rs:97:25\n    |\n LL |         fn into_i32_ref(&self) {}\n    |                         ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `is_*` usually take `self` by reference or no `self`\n-  --> $DIR/wrong_self_convention.rs:100:19\n+  --> $DIR/wrong_self_convention.rs:99:19\n    |\n LL |         fn is_i32(self) {}\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `from_*` usually take no `self`\n-  --> $DIR/wrong_self_convention.rs:104:21\n+  --> $DIR/wrong_self_convention.rs:103:21\n    |\n LL |         fn from_i32(self) {}\n    |                     ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `as_*` usually take `self` by reference or `self` by mutable reference\n-  --> $DIR/wrong_self_convention.rs:119:19\n+  --> $DIR/wrong_self_convention.rs:118:19\n    |\n LL |         fn as_i32(self);\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `into_*` usually take `self` by value\n-  --> $DIR/wrong_self_convention.rs:122:25\n+  --> $DIR/wrong_self_convention.rs:121:25\n    |\n LL |         fn into_i32_ref(&self);\n    |                         ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `is_*` usually take `self` by reference or no `self`\n-  --> $DIR/wrong_self_convention.rs:124:19\n+  --> $DIR/wrong_self_convention.rs:123:19\n    |\n LL |         fn is_i32(self);\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `from_*` usually take no `self`\n-  --> $DIR/wrong_self_convention.rs:128:21\n+  --> $DIR/wrong_self_convention.rs:127:21\n    |\n LL |         fn from_i32(self);\n    |                     ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `into_*` usually take `self` by value\n-  --> $DIR/wrong_self_convention.rs:146:25\n+  --> $DIR/wrong_self_convention.rs:145:25\n    |\n LL |         fn into_i32_ref(&self);\n    |                         ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods called `from_*` usually take no `self`\n-  --> $DIR/wrong_self_convention.rs:152:21\n+  --> $DIR/wrong_self_convention.rs:151:21\n    |\n LL |         fn from_i32(self);\n    |                     ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\n-  --> $DIR/wrong_self_convention.rs:176:22\n+  --> $DIR/wrong_self_convention.rs:175:22\n    |\n LL |         fn to_u64_v2(&self) -> u64 {\n    |                      ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n error: methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\n-  --> $DIR/wrong_self_convention.rs:185:19\n+  --> $DIR/wrong_self_convention.rs:184:19\n    |\n LL |         fn to_u64(self) -> u64 {\n    |                   ^^^^"}, {"sha": "501bc1e6a85cbae27b04ebc7234644d4bbc12f0d", "filename": "tests/ui/wrong_self_convention2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fwrong_self_convention2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fwrong_self_convention2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention2.rs?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,6 +1,5 @@\n // edition:2018\n #![warn(clippy::wrong_self_convention)]\n-#![warn(clippy::wrong_pub_self_convention)]\n #![allow(dead_code)]\n \n fn main() {}"}, {"sha": "0e0d066d656b56a174ff00a9190927ca16abbf70", "filename": "tests/ui/wrong_self_convention2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fwrong_self_convention2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2748211565773c297560f2edcd762565f1933a/tests%2Fui%2Fwrong_self_convention2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention2.stderr?ref=6c2748211565773c297560f2edcd762565f1933a", "patch": "@@ -1,5 +1,5 @@\n error: methods called `from_*` usually take no `self`\n-  --> $DIR/wrong_self_convention2.rs:56:29\n+  --> $DIR/wrong_self_convention2.rs:55:29\n    |\n LL |         pub fn from_be_self(self) -> Self {\n    |                             ^^^^\n@@ -8,7 +8,7 @@ LL |         pub fn from_be_self(self) -> Self {\n    = help: consider choosing a less ambiguous name\n \n error: methods called `from_*` usually take no `self`\n-  --> $DIR/wrong_self_convention2.rs:65:25\n+  --> $DIR/wrong_self_convention2.rs:64:25\n    |\n LL |         fn from_be_self(self) -> Self;\n    |                         ^^^^"}, {"sha": "3f9a6b06f7255d4aaa201a129c895de2e588f326", "filename": "util/cov.sh", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/91aa82174531ef408c81325e0d31b508c1f26e0b/util%2Fcov.sh", "raw_url": "https://github.com/rust-lang/rust/raw/91aa82174531ef408c81325e0d31b508c1f26e0b/util%2Fcov.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fcov.sh?ref=91aa82174531ef408c81325e0d31b508c1f26e0b", "patch": "@@ -1,37 +0,0 @@\n-#!/usr/bin/bash\n-\n-# This run `kcov` on Clippy. The coverage report will be at\n-# `./target/cov/index.html`.\n-# `compile-test` is special. `kcov` does not work directly on it so these files\n-# are compiled manually.\n-\n-tests=$(find tests/ -maxdepth 1 -name '*.rs' ! -name compile-test.rs -exec basename {} .rs \\;)\n-tmpdir=$(mktemp -d)\n-\n-cargo test --no-run --verbose\n-\n-for t in $tests; do\n-  kcov \\\n-    --verify \\\n-    --include-path=\"$(pwd)/src,$(pwd)/clippy_lints/src\" \\\n-    \"$tmpdir/$t\" \\\n-    cargo test --test \"$t\"\n-done\n-\n-for t in ./tests/compile-fail/*.rs; do\n-  kcov \\\n-    --verify \\\n-    --include-path=\"$(pwd)/src,$(pwd)/clippy_lints/src\" \\\n-    \"$tmpdir/compile-fail-$(basename \"$t\")\" \\\n-    cargo run -- -L target/debug -L target/debug/deps -Z no-trans \"$t\"\n-done\n-\n-for t in ./tests/run-pass/*.rs; do\n-  kcov \\\n-    --verify \\\n-    --include-path=\"$(pwd)/src,$(pwd)/clippy_lints/src\" \\\n-    \"$tmpdir/run-pass-$(basename \"$t\")\" \\\n-    cargo run -- -L target/debug -L target/debug/deps -Z no-trans \"$t\"\n-done\n-\n-kcov --verify --merge target/cov \"$tmpdir\"/*"}]}