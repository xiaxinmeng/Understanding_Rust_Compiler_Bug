{"sha": "06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YmFkNmE0NDFmOWFiMWY4YjgxMzljNDkzNGRhNGFjMmM3YmI5ZGY=", "commit": {"author": {"name": "1011X", "email": "1011XXXXX@gmail.com", "date": "2018-03-06T19:35:12Z"}, "committer": {"name": "1011X", "email": "1011XXXXX@gmail.com", "date": "2018-03-06T19:35:12Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust", "tree": {"sha": "bea44300758a38b475ce2c6380aa262a65768218", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bea44300758a38b475ce2c6380aa262a65768218"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "html_url": "https://github.com/rust-lang/rust/commit/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/comments", "author": {"login": "1011X", "id": 1851619, "node_id": "MDQ6VXNlcjE4NTE2MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1851619?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1011X", "html_url": "https://github.com/1011X", "followers_url": "https://api.github.com/users/1011X/followers", "following_url": "https://api.github.com/users/1011X/following{/other_user}", "gists_url": "https://api.github.com/users/1011X/gists{/gist_id}", "starred_url": "https://api.github.com/users/1011X/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1011X/subscriptions", "organizations_url": "https://api.github.com/users/1011X/orgs", "repos_url": "https://api.github.com/users/1011X/repos", "events_url": "https://api.github.com/users/1011X/events{/privacy}", "received_events_url": "https://api.github.com/users/1011X/received_events", "type": "User", "site_admin": false}, "committer": {"login": "1011X", "id": 1851619, "node_id": "MDQ6VXNlcjE4NTE2MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1851619?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1011X", "html_url": "https://github.com/1011X", "followers_url": "https://api.github.com/users/1011X/followers", "following_url": "https://api.github.com/users/1011X/following{/other_user}", "gists_url": "https://api.github.com/users/1011X/gists{/gist_id}", "starred_url": "https://api.github.com/users/1011X/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1011X/subscriptions", "organizations_url": "https://api.github.com/users/1011X/orgs", "repos_url": "https://api.github.com/users/1011X/repos", "events_url": "https://api.github.com/users/1011X/events{/privacy}", "received_events_url": "https://api.github.com/users/1011X/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa1ded9286d7ff5bdc0c9b389fc10d564c23c4db", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1ded9286d7ff5bdc0c9b389fc10d564c23c4db", "html_url": "https://github.com/rust-lang/rust/commit/aa1ded9286d7ff5bdc0c9b389fc10d564c23c4db"}, {"sha": "2789b067da2ac921b86199bde21dd231ace1da39", "url": "https://api.github.com/repos/rust-lang/rust/commits/2789b067da2ac921b86199bde21dd231ace1da39", "html_url": "https://github.com/rust-lang/rust/commit/2789b067da2ac921b86199bde21dd231ace1da39"}], "stats": {"total": 3747, "additions": 2360, "deletions": 1387}, "files": [{"sha": "5e7909ff43552a8a08b7f34ef307862e65d0341f", "filename": "src/Cargo.lock", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -2585,6 +2585,11 @@ dependencies = [\n [[package]]\n name = \"tidy\"\n version = \"0.1.0\"\n+dependencies = [\n+ \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n \n [[package]]\n name = \"time\""}, {"sha": "aa0a7c52246ba89e00e40c7eb3b459adc6a2cd7f", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -810,6 +810,7 @@ impl Step for Src {\n             \"src/libterm\",\n             \"src/jemalloc\",\n             \"src/libprofiler_builtins\",\n+            \"src/stdsimd\",\n         ];\n         let std_src_dirs_exclude = [\n             \"src/libcompiler_builtins/compiler-rt/test\","}, {"sha": "48490493525f971708c1781b4a2fb1a984a1c0ba", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -528,6 +528,7 @@ impl Step for Tidy {\n         println!(\"tidy check ({})\", host);\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(build.src.join(\"src\"));\n+        cmd.arg(&build.initial_cargo);\n         if !build.config.vendor {\n             cmd.arg(\"--no-vendor\");\n         }"}, {"sha": "ac2223f4acef3052d32d35689b90eb1227ca4a19", "filename": "src/etc/sugarise-doc-comments.py", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/aa1ded9286d7ff5bdc0c9b389fc10d564c23c4db/src%2Fetc%2Fsugarise-doc-comments.py", "raw_url": "https://github.com/rust-lang/rust/raw/aa1ded9286d7ff5bdc0c9b389fc10d564c23c4db/src%2Fetc%2Fsugarise-doc-comments.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsugarise-doc-comments.py?ref=aa1ded9286d7ff5bdc0c9b389fc10d564c23c4db", "patch": "@@ -1,93 +0,0 @@\n-#!/usr/bin/env python\n-#\n-# Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-#\n-# this script attempts to turn doc comment attributes (#[doc = \"...\"])\n-# into sugared-doc-comments (/** ... */ and /// ...)\n-#\n-# it sugarises all .rs/.rc files underneath the working directory\n-#\n-\n-import sys\n-import os\n-import fnmatch\n-import re\n-\n-\n-DOC_PATTERN = '^(?P<indent>[\\\\t ]*)#\\\\[(\\\\s*)doc(\\\\s*)=' + \\\n-              '(\\\\s*)\"(?P<text>(\\\\\"|[^\"])*?)\"(\\\\s*)\\\\]' + \\\n-              '(?P<semi>;)?'\n-\n-ESCAPES = [(\"\\\\'\", \"'\"),\n-           ('\\\\\"', '\"'),\n-           (\"\\\\n\", \"\\n\"),\n-           (\"\\\\r\", \"\\r\"),\n-           (\"\\\\t\", \"\\t\")]\n-\n-\n-def unescape(s):\n-    for (find, repl) in ESCAPES:\n-        s = s.replace(find, repl)\n-    return s\n-\n-\n-def block_trim(s):\n-    lns = s.splitlines()\n-\n-    # remove leading/trailing whitespace-lines\n-    while lns and not lns[0].strip():\n-        lns = lns[1:]\n-    while lns and not lns[-1].strip():\n-        lns = lns[:-1]\n-\n-    # remove leading horizontal whitespace\n-    n = sys.maxsize\n-    for ln in lns:\n-        if ln.strip():\n-            n = min(n, len(re.search('^\\s*', ln).group()))\n-    if n != sys.maxsize:\n-        lns = [ln[n:] for ln in lns]\n-\n-    # strip trailing whitespace\n-    lns = [ln.rstrip() for ln in lns]\n-\n-    return lns\n-\n-\n-def replace_doc(m):\n-    indent = m.group('indent')\n-    text = block_trim(unescape(m.group('text')))\n-\n-    if len(text) > 1:\n-        inner = '!' if m.group('semi') else '*'\n-        starify = lambda s: indent + ' *' + (' ' + s if s else '')\n-        text = '\\n'.join(map(starify, text))\n-        repl = indent + '/*' + inner + '\\n' + text + '\\n' + indent + ' */'\n-    else:\n-        inner = '!' if m.group('semi') else '/'\n-        repl = indent + '//' + inner + ' ' + text[0]\n-\n-    return repl\n-\n-\n-def sugarise_file(path):\n-    s = open(path).read()\n-\n-    r = re.compile(DOC_PATTERN, re.MULTILINE | re.DOTALL)\n-    ns = re.sub(r, replace_doc, s)\n-\n-    if s != ns:\n-        open(path, 'w').write(ns)\n-\n-for (dirpath, dirnames, filenames) in os.walk('.'):\n-    for name in fnmatch.filter(filenames, '*.r[sc]'):\n-        sugarise_file(os.path.join(dirpath, name))"}, {"sha": "8aaac5d6e08a53d9f908b81c845a4bced2ec79ca", "filename": "src/liballoc/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbinary_heap.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -964,7 +964,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n /// An owning iterator over the elements of a `BinaryHeap`.\n@@ -1019,7 +1019,7 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n /// A draining iterator over the elements of a `BinaryHeap`.\n@@ -1065,7 +1065,7 @@ impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: 'a> FusedIterator for Drain<'a, T> {}\n \n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]"}, {"sha": "b776556d59f11b033500d34cafd1ec13b4cf4435", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -722,7 +722,7 @@ impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n \n "}, {"sha": "ed9c8c18f0d6db7059d65d77a78b59af9b3a1b72", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1156,7 +1156,7 @@ impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Iter<'a, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1235,7 +1235,7 @@ impl<'a, K: 'a, V: 'a> ExactSizeIterator for IterMut<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1365,7 +1365,7 @@ impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for IntoIter<K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1395,7 +1395,7 @@ impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1432,7 +1432,7 @@ impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Values<'a, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1482,7 +1482,7 @@ impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}\n \n \n@@ -1561,7 +1561,7 @@ impl<'a, K, V> Range<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Range<'a, K, V> {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n@@ -1630,7 +1630,7 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for RangeMut<'a, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {"}, {"sha": "2e3157147a085b9a8086c4ad48fd83584a87662c", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -946,7 +946,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -971,7 +971,7 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n@@ -997,7 +997,7 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Range<'a, T> {}\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n@@ -1044,7 +1044,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: Ord> FusedIterator for Difference<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1078,7 +1078,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: Ord> FusedIterator for SymmetricDifference<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1116,7 +1116,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: Ord> FusedIterator for Intersection<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1150,5 +1150,5 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: Ord> FusedIterator for Union<'a, T> {}"}, {"sha": "3f3067845588a49f98849cf1c65f4045b1c37ec2", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -96,7 +96,6 @@\n #![feature(fmt_internals)]\n #![feature(from_ref)]\n #![feature(fundamental)]\n-#![feature(fused)]\n #![feature(generic_param_attrs)]\n #![feature(i128_type)]\n #![feature(inclusive_range)]\n@@ -124,8 +123,9 @@\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n #![feature(exact_chunks)]\n+#![feature(pointer_methods)]\n \n-#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n+#![cfg_attr(not(test), feature(fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]\n \n // Allow testing this library"}, {"sha": "097d2e414f5cc953fedd04808278f5637fc64abe", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -897,7 +897,7 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -946,7 +946,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n impl<'a, T> IterMut<'a, T> {\n@@ -1117,7 +1117,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "14d5e96d2e73a87853ea103a9abe18bd768c1b40", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -43,6 +43,7 @@ use core::str as core_str;\n use core::str::pattern::Pattern;\n use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n+use core::ptr;\n use core::iter::FusedIterator;\n use std_unicode::str::{UnicodeStr, Utf16Encoder};\n \n@@ -171,7 +172,7 @@ impl<'a> Iterator for EncodeUtf16<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for EncodeUtf16<'a> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2066,9 +2067,59 @@ impl str {\n     /// ```\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {\n-        let mut s = String::with_capacity(self.len() * n);\n-        s.extend((0..n).map(|_| self));\n-        s\n+        if n == 0 {\n+            return String::new();\n+        }\n+\n+        // If `n` is larger than zero, it can be split as\n+        // `n = 2^expn + rem (2^expn > rem, expn >= 0, rem >= 0)`.\n+        // `2^expn` is the number represented by the leftmost '1' bit of `n`,\n+        // and `rem` is the remaining part of `n`.\n+\n+        // Using `Vec` to access `set_len()`.\n+        let mut buf = Vec::with_capacity(self.len() * n);\n+\n+        // `2^expn` repetition is done by doubling `buf` `expn`-times.\n+        buf.extend(self.as_bytes());\n+        {\n+            let mut m = n >> 1;\n+            // If `m > 0`, there are remaining bits up to the leftmost '1'.\n+            while m > 0 {\n+                // `buf.extend(buf)`:\n+                unsafe {\n+                    ptr::copy_nonoverlapping(\n+                        buf.as_ptr(),\n+                        (buf.as_mut_ptr() as *mut u8).add(buf.len()),\n+                        buf.len(),\n+                    );\n+                    // `buf` has capacity of `self.len() * n`.\n+                    let buf_len = buf.len();\n+                    buf.set_len(buf_len * 2);\n+                }\n+\n+                m >>= 1;\n+            }\n+        }\n+\n+        // `rem` (`= n - 2^expn`) repetition is done by copying\n+        // first `rem` repetitions from `buf` itself.\n+        let rem_len = self.len() * n - buf.len(); // `self.len() * rem`\n+        if rem_len > 0 {\n+            // `buf.extend(buf[0 .. rem_len])`:\n+            unsafe {\n+                // This is non-overlapping since `2^expn > rem`.\n+                ptr::copy_nonoverlapping(\n+                    buf.as_ptr(),\n+                    (buf.as_mut_ptr() as *mut u8).add(buf.len()),\n+                    rem_len,\n+                );\n+                // `buf.len() + rem_len` equals to `buf.capacity()` (`= self.len() * n`).\n+                let buf_cap = buf.capacity();\n+                buf.set_len(buf_cap);\n+            }\n+        }\n+\n+        unsafe { String::from_utf8_unchecked(buf) }\n     }\n \n     /// Checks if all characters in this string are within the ASCII range."}, {"sha": "370fb6b4e890f27d3c6565ec5fbf2393251bb3e7", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -2254,5 +2254,5 @@ impl<'a> DoubleEndedIterator for Drain<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for Drain<'a> {}"}, {"sha": "2f57c53a6d8342c5c7e2be50fc95a379f7b8ef91", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -2273,7 +2273,7 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -2379,7 +2379,7 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Drain<'a, T> {}\n \n /// A place for insertion at the back of a `Vec`."}, {"sha": "68add3cbd51f8ac24801140b3ef5e4f6d919d4b7", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1991,7 +1991,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n \n@@ -2084,7 +2084,7 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n /// An owning iterator over the elements of a `VecDeque`.\n@@ -2140,7 +2140,7 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n /// A draining iterator over the elements of a `VecDeque`.\n@@ -2247,7 +2247,7 @@ impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T: 'a> FusedIterator for Drain<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "1372151b75369d5010a2c0266a38ce4992881c3c", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -10,6 +10,24 @@\n \n //! Shareable mutable containers.\n //!\n+//! Rust memory safety is based on this rule: Given an object `T`, it is only possible to\n+//! have one of the following:\n+//!\n+//! - Having several immutable references (`&T`) to the object (also known as **aliasing**).\n+//! - Having one mutable reference (`&mut T`) to the object (also known as **mutability**).\n+//!\n+//! This is enforced by the Rust compiler. However, there are situations where this rule is not\n+//! flexible enough. Sometimes it is required to have multiple references to an object and yet\n+//! mutate it.\n+//!\n+//! Shareable mutable containers exist to permit mutability in a controlled manner, even in the\n+//! presence of aliasing. Both `Cell<T>` and `RefCell<T>` allows to do this in a single threaded\n+//! way. However, neither `Cell<T>` nor `RefCell<T>` are thread safe (they do not implement\n+//! `Sync`). If you need to do aliasing and mutation between multiple threads it is possible to\n+//! use [`Mutex`](../../std/sync/struct.Mutex.html),\n+//! [`RwLock`](../../std/sync/struct.RwLock.html) or\n+//! [`atomic`](../../core/sync/atomic/index.html) types.\n+//!\n //! Values of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e.\n //! the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`)\n //! references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast"}, {"sha": "1638f9710f597a973abd466b8a071970c543c4a3", "filename": "src/libcore/char.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -79,7 +79,7 @@ pub const MAX: char = '\\u{10ffff}';\n \n /// Converts a `u32` to a `char`.\n ///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be casted to one with\n+/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n /// [`as`]:\n ///\n /// ```\n@@ -131,7 +131,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n \n /// Converts a `u32` to a `char`, ignoring validity.\n ///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be casted to one with\n+/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n /// [`as`]:\n ///\n /// ```\n@@ -643,7 +643,7 @@ impl ExactSizeIterator for EscapeUnicode {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeUnicode {}\n \n #[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n@@ -756,7 +756,7 @@ impl ExactSizeIterator for EscapeDefault {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDefault {}\n \n #[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n@@ -790,7 +790,7 @@ impl Iterator for EscapeDebug {\n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n impl ExactSizeIterator for EscapeDebug { }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDebug {}\n \n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n@@ -904,5 +904,5 @@ impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n impl<I: FusedIterator<Item = u8>> FusedIterator for DecodeUtf8<I> {}"}, {"sha": "830ebad065427fa3954552f99f90595702e96ff2", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1292,6 +1292,10 @@ extern \"rust-intrinsic\" {\n     /// Reverses the bytes in an integer type `T`.\n     pub fn bswap<T>(x: T) -> T;\n \n+    /// Reverses the bits in an integer type `T`.\n+    #[cfg(not(stage0))]\n+    pub fn bitreverse<T>(x: T) -> T;\n+\n     /// Performs checked integer addition.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,"}, {"sha": "2cfbc09229342b46c404134db13b77b1ca4e749d", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1180,26 +1180,27 @@ pub trait Iterator {\n     ///\n     /// // this iterator sequence is complex.\n     /// let sum = a.iter()\n-    ///             .cloned()\n-    ///             .filter(|&x| x % 2 == 0)\n-    ///             .fold(0, |sum, i| sum + i);\n+    ///     .cloned()\n+    ///     .filter(|x| x % 2 == 0)\n+    ///     .fold(0, |sum, i| sum + i);\n     ///\n     /// println!(\"{}\", sum);\n     ///\n     /// // let's add some inspect() calls to investigate what's happening\n     /// let sum = a.iter()\n-    ///             .cloned()\n-    ///             .inspect(|x| println!(\"about to filter: {}\", x))\n-    ///             .filter(|&x| x % 2 == 0)\n-    ///             .inspect(|x| println!(\"made it through filter: {}\", x))\n-    ///             .fold(0, |sum, i| sum + i);\n+    ///     .cloned()\n+    ///     .inspect(|x| println!(\"about to filter: {}\", x))\n+    ///     .filter(|x| x % 2 == 0)\n+    ///     .inspect(|x| println!(\"made it through filter: {}\", x))\n+    ///     .fold(0, |sum, i| sum + i);\n     ///\n     /// println!(\"{}\", sum);\n     /// ```\n     ///\n     /// This will print:\n     ///\n     /// ```text\n+    /// 6\n     /// about to filter: 1\n     /// about to filter: 4\n     /// made it through filter: 4\n@@ -1230,8 +1231,7 @@ pub trait Iterator {\n     ///\n     /// let iter = a.into_iter();\n     ///\n-    /// let sum: i32 = iter.take(5)\n-    ///                    .fold(0, |acc, &i| acc + i );\n+    /// let sum: i32 = iter.take(5).fold(0, |acc, i| acc + i );\n     ///\n     /// assert_eq!(sum, 6);\n     ///\n@@ -1245,9 +1245,7 @@ pub trait Iterator {\n     /// let mut iter = a.into_iter();\n     ///\n     /// // instead, we add in a .by_ref()\n-    /// let sum: i32 = iter.by_ref()\n-    ///                    .take(2)\n-    ///                    .fold(0, |acc, &i| acc + i );\n+    /// let sum: i32 = iter.by_ref().take(2).fold(0, |acc, i| acc + i );\n     ///\n     /// assert_eq!(sum, 3);\n     ///\n@@ -1304,9 +1302,7 @@ pub trait Iterator {\n     ///\n     /// let a = [1, 2, 3];\n     ///\n-    /// let doubled: VecDeque<i32> = a.iter()\n-    ///                               .map(|&x| x * 2)\n-    ///                               .collect();\n+    /// let doubled: VecDeque<i32> = a.iter().map(|&x| x * 2).collect();\n     ///\n     /// assert_eq!(2, doubled[0]);\n     /// assert_eq!(4, doubled[1]);\n@@ -1318,9 +1314,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// let doubled = a.iter()\n-    ///                .map(|&x| x * 2)\n-    ///                .collect::<Vec<i32>>();\n+    /// let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n     ///\n     /// assert_eq!(vec![2, 4, 6], doubled);\n     /// ```\n@@ -1331,9 +1325,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// let doubled = a.iter()\n-    ///                .map(|&x| x * 2)\n-    ///                .collect::<Vec<_>>();\n+    /// let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n     ///\n     /// assert_eq!(vec![2, 4, 6], doubled);\n     /// ```\n@@ -1344,9 +1336,9 @@ pub trait Iterator {\n     /// let chars = ['g', 'd', 'k', 'k', 'n'];\n     ///\n     /// let hello: String = chars.iter()\n-    ///                          .map(|&x| x as u8)\n-    ///                          .map(|x| (x + 1) as char)\n-    ///                          .collect();\n+    ///     .map(|&x| x as u8)\n+    ///     .map(|x| (x + 1) as char)\n+    ///     .collect();\n     ///\n     /// assert_eq!(\"hello\", hello);\n     /// ```\n@@ -1393,8 +1385,9 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// let (even, odd): (Vec<i32>, Vec<i32>) = a.into_iter()\n-    ///                                          .partition(|&n| n % 2 == 0);\n+    /// let (even, odd): (Vec<i32>, Vec<i32>) = a\n+    ///     .into_iter()\n+    ///     .partition(|&n| n % 2 == 0);\n     ///\n     /// assert_eq!(even, vec![2]);\n     /// assert_eq!(odd, vec![1, 3]);\n@@ -1457,8 +1450,7 @@ pub trait Iterator {\n     /// let a = [1, 2, 3];\n     ///\n     /// // the checked sum of all of the elements of the array\n-    /// let sum = a.iter()\n-    ///            .try_fold(0i8, |acc, &x| acc.checked_add(x));\n+    /// let sum = a.iter().try_fold(0i8, |acc, &x| acc.checked_add(x));\n     ///\n     /// assert_eq!(sum, Some(6));\n     /// ```\n@@ -1556,8 +1548,7 @@ pub trait Iterator {\n     /// let a = [1, 2, 3];\n     ///\n     /// // the sum of all of the elements of the array\n-    /// let sum = a.iter()\n-    ///            .fold(0, |acc, &x| acc + x);\n+    /// let sum = a.iter().fold(0, |acc, x| acc + x);\n     ///\n     /// assert_eq!(sum, 6);\n     /// ```"}, {"sha": "a6802d606ca8cbbc849e6c5bf468bed73763347b", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -344,7 +344,7 @@ pub use self::sources::{Once, once};\n pub use self::traits::{FromIterator, IntoIterator, DoubleEndedIterator, Extend};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::{ExactSizeIterator, Sum, Product};\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n pub use self::traits::FusedIterator;\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub use self::traits::TrustedLen;\n@@ -506,7 +506,7 @@ impl<I> ExactSizeIterator for Rev<I>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Rev<I>\n     where I: FusedIterator + DoubleEndedIterator {}\n \n@@ -589,7 +589,7 @@ impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n     where I: FusedIterator<Item=&'a T>, T: Clone\n {}\n@@ -662,7 +662,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n \n /// An iterator for stepping iterators by a custom amount.\n@@ -1002,7 +1002,7 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n }\n \n // Note: *both* must be fused to handle double-ended iterators.\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A, B> FusedIterator for Chain<A, B>\n     where A: FusedIterator,\n           B: FusedIterator<Item=A::Item>,\n@@ -1262,7 +1262,7 @@ unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A, B> FusedIterator for Zip<A, B>\n     where A: FusedIterator, B: FusedIterator, {}\n \n@@ -1404,7 +1404,7 @@ impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n     where F: FnMut(I::Item) -> B {}\n \n@@ -1553,7 +1553,7 @@ impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator, P> FusedIterator for Filter<I, P>\n     where P: FnMut(&I::Item) -> bool {}\n \n@@ -1663,7 +1663,7 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F>\n     where F: FnMut(I::Item) -> Option<B> {}\n \n@@ -1818,7 +1818,7 @@ unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1938,7 +1938,7 @@ impl<I: Iterator> Iterator for Peekable<I> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n \n impl<I: Iterator> Peekable<I> {\n@@ -2072,7 +2072,7 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, P> FusedIterator for SkipWhile<I, P>\n     where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n \n@@ -2151,7 +2151,7 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, P> FusedIterator for TakeWhile<I, P>\n     where I: FusedIterator, P: FnMut(&I::Item) -> bool {}\n \n@@ -2290,7 +2290,7 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n \n /// An iterator that only iterates over the first `n` iterations of `iter`.\n@@ -2371,7 +2371,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -2517,7 +2517,7 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n     where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n \n@@ -2605,7 +2605,7 @@ impl<I, U> DoubleEndedIterator for Flatten<I>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, U> FusedIterator for Flatten<I>\n     where I: FusedIterator, U: Iterator,\n           I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n@@ -2765,7 +2765,7 @@ pub struct Fuse<I> {\n     done: bool\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2896,7 +2896,7 @@ unsafe impl<I> TrustedRandomAccess for Fuse<I>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> Iterator for Fuse<I> where I: FusedIterator {\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> {\n@@ -2938,7 +2938,7 @@ impl<I> Iterator for Fuse<I> where I: FusedIterator {\n     }\n }\n \n-#[unstable(feature = \"fused\", reason = \"recently added\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> DoubleEndedIterator for Fuse<I>\n     where I: DoubleEndedIterator + FusedIterator\n {\n@@ -3082,6 +3082,6 @@ impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>\n     where F: FnMut(&I::Item) {}"}, {"sha": "9a3fd215dcfebde7a7745b10a5a7a6fbc8040de6", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -295,7 +295,7 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::Range<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -322,7 +322,7 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeFrom<A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -463,5 +463,5 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}"}, {"sha": "0fc1a3aa8ac06c988764ef758a04198e9b1c5a37", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -41,7 +41,7 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Clone> FusedIterator for Repeat<A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -135,7 +135,7 @@ impl<A, F: FnMut() -> A> DoubleEndedIterator for RepeatWith<F> {\n     fn next_back(&mut self) -> Option<A> { self.next() }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n impl<A, F: FnMut() -> A> FusedIterator for RepeatWith<F> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -259,7 +259,7 @@ impl<T> ExactSizeIterator for Empty<T> {\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<T> TrustedLen for Empty<T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Empty<T> {}\n \n // not #[derive] because that adds a Clone bound on T,\n@@ -340,7 +340,7 @@ impl<T> ExactSizeIterator for Once<T> {\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<T> TrustedLen for Once<T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Once<T> {}\n \n /// Creates an iterator that yields an element exactly once."}, {"sha": "0267fcd375453cbcdd24f9f6e330ebdb3a65787f", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -959,10 +959,10 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n /// [`Iterator::fuse`]: ../../std/iter/trait.Iterator.html#method.fuse\n /// [`Fuse`]: ../../std/iter/struct.Fuse.html\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n pub trait FusedIterator: Iterator {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, I: FusedIterator + ?Sized> FusedIterator for &'a mut I {}\n \n /// An iterator that reports an accurate length using size_hint."}, {"sha": "a46ac2b5f0fee1d9af082f160b6c84218592e763", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -321,6 +321,33 @@ $EndFeature, \"\n             (self as $UnsignedT).swap_bytes() as Self\n         }\n \n+        /// Reverses the bit pattern of the integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `i16` is used here.\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(reverse_bits)]\n+        ///\n+        /// let n: i16 = 0b0000000_01010101;\n+        /// assert_eq!(n, 85);\n+        ///\n+        /// let m = n.reverse_bits();\n+        ///\n+        /// assert_eq!(m as u16, 0b10101010_00000000);\n+        /// assert_eq!(m, -22016);\n+        /// ```\n+        #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        pub fn reverse_bits(self) -> Self {\n+            (self as $UnsignedT).reverse_bits() as Self\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts an integer from big endian to the target's endianness.\n \n@@ -1773,6 +1800,33 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n             unsafe { intrinsics::bswap(self as $ActualT) as Self }\n         }\n \n+        /// Reverses the bit pattern of the integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u16` is used here.\n+        ///\n+        /// ```\n+        /// #![feature(reverse_bits)]\n+        ///\n+        /// let n: u16 = 0b0000000_01010101;\n+        /// assert_eq!(n, 85);\n+        ///\n+        /// let m = n.reverse_bits();\n+        ///\n+        /// assert_eq!(m, 0b10101010_00000000);\n+        /// assert_eq!(m, 43520);\n+        /// ```\n+        #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        pub fn reverse_bits(self) -> Self {\n+            unsafe { intrinsics::bitreverse(self as $ActualT) as Self }\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts an integer from big endian to the target's endianness.\n "}, {"sha": "25f57d8c0f71802a631d66742b50f1876fee75c6", "filename": "src/libcore/option.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -233,11 +233,11 @@ impl<T> Option<T> {\n     /// [`usize`]: ../../std/primitive.usize.html\n     ///\n     /// ```\n-    /// let num_as_str: Option<String> = Some(\"10\".to_string());\n+    /// let text: Option<String> = Some(\"Hello, world!\".to_string());\n     /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n-    /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n-    /// let num_as_int: Option<usize> = num_as_str.as_ref().map(|n| n.len());\n-    /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n+    /// // then consume *that* with `map`, leaving `text` on the stack.\n+    /// let text_length: Option<usize> = text.as_ref().map(|s| s.len());\n+    /// println!(\"still can print text: {:?}\", text);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1051,7 +1051,7 @@ impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, A> FusedIterator for Iter<'a, A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1096,7 +1096,7 @@ impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, A> FusedIterator for IterMut<'a, A> {}\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, A> TrustedLen for IterMut<'a, A> {}\n@@ -1133,7 +1133,7 @@ impl<A> DoubleEndedIterator for IntoIter<A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> ExactSizeIterator for IntoIter<A> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A> FusedIterator for IntoIter<A> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]"}, {"sha": "c152d4979b90e3c880e3fd5c7f35aa52b11701be", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1038,7 +1038,7 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1082,7 +1082,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1125,7 +1125,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]"}, {"sha": "19fe4dd36b683feadf660a688f3595e2e4db9fad", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1455,7 +1455,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1583,7 +1583,7 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1731,7 +1731,7 @@ impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T, P> FusedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {}\n \n /// An iterator over the subslices of the vector which are separated\n@@ -1829,7 +1829,7 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T, P> FusedIterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n \n /// An iterator over subslices separated by elements that match a predicate\n@@ -1886,7 +1886,6 @@ impl<'a, T, P> SplitIter for RSplit<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n }\n \n-//#[unstable(feature = \"fused\", issue = \"35602\")]\n #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n impl<'a, T, P> FusedIterator for RSplit<'a, T, P> where P: FnMut(&T) -> bool {}\n \n@@ -1945,7 +1944,6 @@ impl<'a, T, P> DoubleEndedIterator for RSplitMut<'a, T, P> where\n     }\n }\n \n-//#[unstable(feature = \"fused\", issue = \"35602\")]\n #[unstable(feature = \"slice_rsplit\", issue = \"41020\")]\n impl<'a, T, P> FusedIterator for RSplitMut<'a, T, P> where P: FnMut(&T) -> bool {}\n \n@@ -2082,7 +2080,7 @@ macro_rules! forward_iterator {\n             }\n         }\n \n-        #[unstable(feature = \"fused\", issue = \"35602\")]\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n         impl<'a, $elem, P> FusedIterator for $name<'a, $elem, P>\n             where P: FnMut(&T) -> bool {}\n     }\n@@ -2188,7 +2186,7 @@ impl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Windows<'a, T> {}\n \n #[doc(hidden)]\n@@ -2307,7 +2305,7 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Chunks<'a, T> {}\n \n #[doc(hidden)]\n@@ -2423,7 +2421,7 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for ChunksMut<'a, T> {}\n \n #[doc(hidden)]\n@@ -2533,7 +2531,7 @@ impl<'a, T> ExactSizeIterator for ExactChunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n impl<'a, T> FusedIterator for ExactChunks<'a, T> {}\n \n #[doc(hidden)]\n@@ -2630,7 +2628,7 @@ impl<'a, T> ExactSizeIterator for ExactChunksMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n impl<'a, T> FusedIterator for ExactChunksMut<'a, T> {}\n \n #[doc(hidden)]"}, {"sha": "e225c9522bc063792df442def0f3ad19a66016a8", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -609,7 +609,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for Chars<'a> {}\n \n impl<'a> Chars<'a> {\n@@ -702,7 +702,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for CharIndices<'a> {}\n \n impl<'a> CharIndices<'a> {\n@@ -817,7 +817,7 @@ impl<'a> ExactSizeIterator for Bytes<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for Bytes<'a> {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -977,10 +977,10 @@ macro_rules! generate_pattern_iterators {\n             }\n         }\n \n-        #[unstable(feature = \"fused\", issue = \"35602\")]\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n         impl<'a, P: Pattern<'a>> FusedIterator for $forward_iterator<'a, P> {}\n \n-        #[unstable(feature = \"fused\", issue = \"35602\")]\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n         impl<'a, P: Pattern<'a>> FusedIterator for $reverse_iterator<'a, P>\n             where P::Searcher: ReverseSearcher<'a> {}\n \n@@ -1337,7 +1337,7 @@ impl<'a> DoubleEndedIterator for Lines<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for Lines<'a> {}\n \n /// Created with the method [`lines_any`].\n@@ -1403,7 +1403,7 @@ impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n #[allow(deprecated)]\n impl<'a> FusedIterator for LinesAny<'a> {}\n "}, {"sha": "a9c5683e0ef7b376847563ccc25b19c2c0309856", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -46,6 +46,7 @@\n #![feature(try_trait)]\n #![feature(exact_chunks)]\n #![feature(atomic_nand)]\n+#![feature(reverse_bits)]\n \n extern crate core;\n extern crate test;"}, {"sha": "ca6906f731047c62e0091c3a3212756cff2b5c23", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -97,6 +97,17 @@ mod tests {\n         assert_eq!(_1.swap_bytes(), _1);\n     }\n \n+    #[test]\n+    fn test_reverse_bits() {\n+        assert_eq!(A.reverse_bits().reverse_bits(), A);\n+        assert_eq!(B.reverse_bits().reverse_bits(), B);\n+        assert_eq!(C.reverse_bits().reverse_bits(), C);\n+\n+        // Swapping these should make no difference\n+        assert_eq!(_0.reverse_bits(), _0);\n+        assert_eq!(_1.reverse_bits(), _1);\n+    }\n+\n     #[test]\n     fn test_le() {\n         assert_eq!($T::from_le(A.to_le()), A);"}, {"sha": "84fdeba4ab3ccbe3742c52c591f306490979484b", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -436,6 +436,9 @@ impl DepKind {\n }\n \n define_dep_nodes!( <'tcx>\n+    // We use this for most things when incr. comp. is turned off.\n+    [] Null,\n+\n     // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n     // distinct from the krate module). This is basically a hash of\n     // the entire krate, so if you read from `Krate` (e.g., by calling\n@@ -553,7 +556,7 @@ define_dep_nodes!( <'tcx>\n     [] RvaluePromotableMap(DefId),\n     [] ImplParent(DefId),\n     [] TraitOfItem(DefId),\n-    [] IsExportedSymbol(DefId),\n+    [] IsReachableNonGeneric(DefId),\n     [] IsMirAvailable(DefId),\n     [] ItemAttrs(DefId),\n     [] FnArgNames(DefId),\n@@ -571,7 +574,7 @@ define_dep_nodes!( <'tcx>\n     [] GetPanicStrategy(CrateNum),\n     [] IsNoBuiltins(CrateNum),\n     [] ImplDefaultness(DefId),\n-    [] ExportedSymbolIds(CrateNum),\n+    [] ReachableNonGenerics(CrateNum),\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),\n     [] DeriveRegistrarFn(CrateNum),\n@@ -605,8 +608,8 @@ define_dep_nodes!( <'tcx>\n     [input] MissingExternCrateItem(CrateNum),\n     [input] UsedCrateSource(CrateNum),\n     [input] PostorderCnums,\n-    [input] HasCloneClosures(CrateNum),\n-    [input] HasCopyClosures(CrateNum),\n+    [] HasCloneClosures(CrateNum),\n+    [] HasCopyClosures(CrateNum),\n \n     // This query is not expected to have inputs -- as a result, it's\n     // not a good candidate for \"replay\" because it's essentially a\n@@ -630,8 +633,6 @@ define_dep_nodes!( <'tcx>\n     [] CompileCodegenUnit(InternedString),\n     [input] OutputFilenames,\n     [anon] NormalizeTy,\n-    // We use this for most things when incr. comp. is turned off.\n-    [] Null,\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n \n@@ -642,6 +643,7 @@ define_dep_nodes!( <'tcx>\n \n     [] GetSymbolExportLevel(DefId),\n \n+    [input] Features,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "877027a21a22189a1721f20e8ecb1a31e457eace", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -550,7 +550,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n-        self.is_collecting_in_band_lifetimes = self.sess.features.borrow().in_band_lifetimes;\n+        self.is_collecting_in_band_lifetimes = self.sess.features_untracked().in_band_lifetimes;\n \n         assert!(self.in_band_ty_params.is_empty());\n \n@@ -964,7 +964,7 @@ impl<'a> LoweringContext<'a> {\n                 let span = t.span;\n                 match itctx {\n                     ImplTraitContext::Existential => {\n-                        let has_feature = self.sess.features.borrow().conservative_impl_trait;\n+                        let has_feature = self.sess.features_untracked().conservative_impl_trait;\n                         if !t.span.allows_unstable() && !has_feature {\n                             emit_feature_err(&self.sess.parse_sess, \"conservative_impl_trait\",\n                                              t.span, GateIssue::Language,\n@@ -988,7 +988,7 @@ impl<'a> LoweringContext<'a> {\n                         }, lifetimes)\n                     },\n                     ImplTraitContext::Universal(def_id) => {\n-                        let has_feature = self.sess.features.borrow().universal_impl_trait;\n+                        let has_feature = self.sess.features_untracked().universal_impl_trait;\n                         if !t.span.allows_unstable() && !has_feature {\n                             emit_feature_err(&self.sess.parse_sess, \"universal_impl_trait\",\n                                              t.span, GateIssue::Language,\n@@ -3713,7 +3713,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn maybe_lint_bare_trait(&self, span: Span, id: NodeId, is_global: bool) {\n-        if self.sess.features.borrow().dyn_trait {\n+        if self.sess.features_untracked().dyn_trait {\n             self.sess.buffer_lint_with_diagnostic(\n                 builtin::BARE_TRAIT_OBJECT, id, span,\n                 \"trait objects without an explicit `dyn` are deprecated\","}, {"sha": "d91aa3a385193b25924e54f18c7fae9037c212af", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -2208,13 +2208,8 @@ impl<'a> State<'a> {\n         if self.next_comment().is_none() {\n             self.s.hardbreak()?;\n         }\n-        loop {\n-            match self.next_comment() {\n-                Some(ref cmnt) => {\n-                    self.print_comment(cmnt)?;\n-                }\n-                _ => break,\n-            }\n+        while let Some(ref cmnt) = self.next_comment() {\n+            self.print_comment(cmnt)?\n         }\n         Ok(())\n     }"}, {"sha": "f935cbfcde992d394f95f844e86d8f2f2a4b74e3", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -17,6 +17,7 @@ use std::hash as std_hash;\n use std::mem;\n \n use syntax::ast;\n+use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::symbol::InternedString;\n use syntax::tokenstream;\n@@ -460,3 +461,21 @@ fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n \n     (pos.0 - filemap_start.0, width as u32)\n }\n+\n+\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for feature_gate::Features {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        // Unfortunately we cannot exhaustively list fields here, since the\n+        // struct is macro generated.\n+        self.declared_stable_lang_features.hash_stable(hcx, hasher);\n+        self.declared_lib_features.hash_stable(hcx, hasher);\n+\n+        self.walk_feature_fields(|feature_name, value| {\n+            feature_name.hash_stable(hcx, hasher);\n+            value.hash_stable(hcx, hasher);\n+        });\n+    }\n+}"}, {"sha": "559b2720076f447030d042710fa0a698c55ddc3a", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 467, "deletions": 370, "changes": 837, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -56,7 +56,7 @@\n //! time of error detection.\n \n use infer;\n-use super::{InferCtxt, TypeTrace, SubregionOrigin, RegionVariableOrigin, ValuePairs};\n+use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n use super::region_constraints::GenericKind;\n use super::lexical_region_resolve::RegionResolutionError;\n \n@@ -81,54 +81,22 @@ mod need_type_info;\n pub mod nice_region_error;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn note_and_explain_region(self,\n-                                   region_scope_tree: &region::ScopeTree,\n-                                   err: &mut DiagnosticBuilder,\n-                                   prefix: &str,\n-                                   region: ty::Region<'tcx>,\n-                                   suffix: &str) {\n-        fn item_scope_tag(item: &hir::Item) -> &'static str {\n-            match item.node {\n-                hir::ItemImpl(..) => \"impl\",\n-                hir::ItemStruct(..) => \"struct\",\n-                hir::ItemUnion(..) => \"union\",\n-                hir::ItemEnum(..) => \"enum\",\n-                hir::ItemTrait(..) => \"trait\",\n-                hir::ItemFn(..) => \"function body\",\n-                _ => \"item\"\n-            }\n-        }\n-\n-        fn trait_item_scope_tag(item: &hir::TraitItem) -> &'static str {\n-            match item.node {\n-                hir::TraitItemKind::Method(..) => \"method body\",\n-                hir::TraitItemKind::Const(..) |\n-                hir::TraitItemKind::Type(..) => \"associated item\"\n-            }\n-        }\n-\n-        fn impl_item_scope_tag(item: &hir::ImplItem) -> &'static str {\n-            match item.node {\n-                hir::ImplItemKind::Method(..) => \"method body\",\n-                hir::ImplItemKind::Const(..) |\n-                hir::ImplItemKind::Type(_) => \"associated item\"\n-            }\n-        }\n-\n-        fn explain_span<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        heading: &str, span: Span)\n-                                        -> (String, Option<Span>) {\n-            let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo());\n-            (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1),\n-             Some(span))\n-        }\n-\n+    pub fn note_and_explain_region(\n+        self,\n+        region_scope_tree: &region::ScopeTree,\n+        err: &mut DiagnosticBuilder,\n+        prefix: &str,\n+        region: ty::Region<'tcx>,\n+        suffix: &str,\n+    ) {\n         let (description, span) = match *region {\n             ty::ReScope(scope) => {\n                 let new_string;\n                 let unknown_scope = || {\n-                    format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n-                            prefix, scope, suffix)\n+                    format!(\n+                        \"{}unknown scope: {:?}{}.  Please report a bug.\",\n+                        prefix, scope, suffix\n+                    )\n                 };\n                 let span = scope.span(self, region_scope_tree);\n                 let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n@@ -137,90 +105,40 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         hir::ExprCall(..) => \"call\",\n                         hir::ExprMethodCall(..) => \"method call\",\n                         hir::ExprMatch(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                        hir::ExprMatch(.., hir::MatchSource::WhileLetDesugar) =>  \"while let\",\n-                        hir::ExprMatch(.., hir::MatchSource::ForLoopDesugar) =>  \"for\",\n+                        hir::ExprMatch(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n+                        hir::ExprMatch(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n                         hir::ExprMatch(..) => \"match\",\n                         _ => \"expression\",\n                     },\n                     Some(hir_map::NodeStmt(_)) => \"statement\",\n-                    Some(hir_map::NodeItem(it)) => item_scope_tag(&it),\n-                    Some(hir_map::NodeTraitItem(it)) => trait_item_scope_tag(&it),\n-                    Some(hir_map::NodeImplItem(it)) => impl_item_scope_tag(&it),\n+                    Some(hir_map::NodeItem(it)) => Self::item_scope_tag(&it),\n+                    Some(hir_map::NodeTraitItem(it)) => Self::trait_item_scope_tag(&it),\n+                    Some(hir_map::NodeImplItem(it)) => Self::impl_item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n                     }\n                 };\n                 let scope_decorated_tag = match scope.data() {\n                     region::ScopeData::Node(_) => tag,\n-                    region::ScopeData::CallSite(_) => {\n-                        \"scope of call-site for function\"\n-                    }\n-                    region::ScopeData::Arguments(_) => {\n-                        \"scope of function body\"\n-                    }\n+                    region::ScopeData::CallSite(_) => \"scope of call-site for function\",\n+                    region::ScopeData::Arguments(_) => \"scope of function body\",\n                     region::ScopeData::Destruction(_) => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n                     region::ScopeData::Remainder(r) => {\n-                        new_string = format!(\"block suffix following statement {}\",\n-                                             r.first_statement_index.index());\n+                        new_string = format!(\n+                            \"block suffix following statement {}\",\n+                            r.first_statement_index.index()\n+                        );\n                         &new_string[..]\n                     }\n                 };\n-                explain_span(self, scope_decorated_tag, span)\n+                self.explain_span(scope_decorated_tag, span)\n             }\n \n-            ty::ReEarlyBound(_) |\n-            ty::ReFree(_) => {\n-                let scope = region.free_region_binding_scope(self);\n-                let node = self.hir.as_local_node_id(scope)\n-                                   .unwrap_or(DUMMY_NODE_ID);\n-                let unknown;\n-                let tag = match self.hir.find(node) {\n-                    Some(hir_map::NodeBlock(_)) |\n-                    Some(hir_map::NodeExpr(_)) => \"body\",\n-                    Some(hir_map::NodeItem(it)) => item_scope_tag(&it),\n-                    Some(hir_map::NodeTraitItem(it)) => trait_item_scope_tag(&it),\n-                    Some(hir_map::NodeImplItem(it)) => impl_item_scope_tag(&it),\n-\n-                    // this really should not happen, but it does:\n-                    // FIXME(#27942)\n-                    Some(_) => {\n-                        unknown = format!(\"unexpected node ({}) for scope {:?}.  \\\n-                                           Please report a bug.\",\n-                                          self.hir.node_to_string(node), scope);\n-                        &unknown\n-                    }\n-                    None => {\n-                        unknown = format!(\"unknown node for scope {:?}.  \\\n-                                           Please report a bug.\", scope);\n-                        &unknown\n-                    }\n-                };\n-                let (prefix, span) = match *region {\n-                    ty::ReEarlyBound(ref br) => {\n-                        (format!(\"the lifetime {} as defined on\", br.name),\n-                         self.sess.codemap().def_span(self.hir.span(node)))\n-                    }\n-                    ty::ReFree(ref fr) => {\n-                        match fr.bound_region {\n-                            ty::BrAnon(idx) => {\n-                                (format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                                 self.hir.span(node))\n-                            }\n-                            ty::BrFresh(_) => (\"an anonymous lifetime defined on\".to_owned(),\n-                                               self.hir.span(node)),\n-                            _ => (format!(\"the lifetime {} as defined on\", fr.bound_region),\n-                                  self.sess.codemap().def_span(self.hir.span(node))),\n-                        }\n-                    }\n-                    _ => bug!()\n-                };\n-                let (msg, opt_span) = explain_span(self, tag, span);\n-                (format!(\"{} {}\", prefix, msg), opt_span)\n-            }\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => self.msg_span_from_free_region(region),\n \n             ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n \n@@ -231,59 +149,168 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             //\n             // We shouldn't really be having unification failures with ReVar\n             // and ReLateBound though.\n-            ty::ReSkolemized(..) |\n-            ty::ReVar(_) |\n-            ty::ReLateBound(..) |\n-            ty::ReErased => {\n+            ty::ReSkolemized(..) | ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n                 (format!(\"lifetime {:?}\", region), None)\n             }\n \n             // We shouldn't encounter an error message with ReClosureBound.\n             ty::ReClosureBound(..) => {\n-                bug!(\n-                    \"encountered unexpected ReClosureBound: {:?}\",\n-                    region,\n+                bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n+            }\n+        };\n+\n+        TyCtxt::emit_msg_span(err, prefix, description, span, suffix);\n+    }\n+\n+    pub fn note_and_explain_free_region(\n+        self,\n+        err: &mut DiagnosticBuilder,\n+        prefix: &str,\n+        region: ty::Region<'tcx>,\n+        suffix: &str,\n+    ) {\n+        let (description, span) = self.msg_span_from_free_region(region);\n+\n+        TyCtxt::emit_msg_span(err, prefix, description, span, suffix);\n+    }\n+\n+    fn msg_span_from_free_region(self, region: ty::Region<'tcx>) -> (String, Option<Span>) {\n+        let scope = region.free_region_binding_scope(self);\n+        let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n+        let unknown;\n+        let tag = match self.hir.find(node) {\n+            Some(hir_map::NodeBlock(_)) | Some(hir_map::NodeExpr(_)) => \"body\",\n+            Some(hir_map::NodeItem(it)) => Self::item_scope_tag(&it),\n+            Some(hir_map::NodeTraitItem(it)) => Self::trait_item_scope_tag(&it),\n+            Some(hir_map::NodeImplItem(it)) => Self::impl_item_scope_tag(&it),\n+\n+            // this really should not happen, but it does:\n+            // FIXME(#27942)\n+            Some(_) => {\n+                unknown = format!(\n+                    \"unexpected node ({}) for scope {:?}.  \\\n+                     Please report a bug.\",\n+                    self.hir.node_to_string(node),\n+                    scope\n+                );\n+                &unknown\n+            }\n+            None => {\n+                unknown = format!(\n+                    \"unknown node for scope {:?}.  \\\n+                     Please report a bug.\",\n+                    scope\n                 );\n+                &unknown\n             }\n         };\n+        let (prefix, span) = match *region {\n+            ty::ReEarlyBound(ref br) => (\n+                format!(\"the lifetime {} as defined on\", br.name),\n+                self.sess.codemap().def_span(self.hir.span(node)),\n+            ),\n+            ty::ReFree(ref fr) => match fr.bound_region {\n+                ty::BrAnon(idx) => (\n+                    format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n+                    self.hir.span(node),\n+                ),\n+                ty::BrFresh(_) => (\n+                    \"an anonymous lifetime defined on\".to_owned(),\n+                    self.hir.span(node),\n+                ),\n+                _ => (\n+                    format!(\"the lifetime {} as defined on\", fr.bound_region),\n+                    self.sess.codemap().def_span(self.hir.span(node)),\n+                ),\n+            },\n+            _ => bug!(),\n+        };\n+        let (msg, opt_span) = self.explain_span(tag, span);\n+        (format!(\"{} {}\", prefix, msg), opt_span)\n+    }\n+\n+    fn emit_msg_span(\n+        err: &mut DiagnosticBuilder,\n+        prefix: &str,\n+        description: String,\n+        span: Option<Span>,\n+        suffix: &str,\n+    ) {\n         let message = format!(\"{}{}{}\", prefix, description, suffix);\n+\n         if let Some(span) = span {\n             err.span_note(span, &message);\n         } else {\n             err.note(&message);\n         }\n     }\n+\n+    fn item_scope_tag(item: &hir::Item) -> &'static str {\n+        match item.node {\n+            hir::ItemImpl(..) => \"impl\",\n+            hir::ItemStruct(..) => \"struct\",\n+            hir::ItemUnion(..) => \"union\",\n+            hir::ItemEnum(..) => \"enum\",\n+            hir::ItemTrait(..) => \"trait\",\n+            hir::ItemFn(..) => \"function body\",\n+            _ => \"item\",\n+        }\n+    }\n+\n+    fn trait_item_scope_tag(item: &hir::TraitItem) -> &'static str {\n+        match item.node {\n+            hir::TraitItemKind::Method(..) => \"method body\",\n+            hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => \"associated item\",\n+        }\n+    }\n+\n+    fn impl_item_scope_tag(item: &hir::ImplItem) -> &'static str {\n+        match item.node {\n+            hir::ImplItemKind::Method(..) => \"method body\",\n+            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(_) => \"associated item\",\n+        }\n+    }\n+\n+    fn explain_span(self, heading: &str, span: Span) -> (String, Option<Span>) {\n+        let lo = self.sess.codemap().lookup_char_pos_adj(span.lo());\n+        (\n+            format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1),\n+            Some(span),\n+        )\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    pub fn report_region_errors(&self,\n-                                region_scope_tree: &region::ScopeTree,\n-                                errors: &Vec<RegionResolutionError<'tcx>>,\n-                                will_later_be_reported_by_nll: bool) {\n+    pub fn report_region_errors(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        errors: &Vec<RegionResolutionError<'tcx>>,\n+        will_later_be_reported_by_nll: bool,\n+    ) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n-        if will_later_be_reported_by_nll && self.tcx.sess.nll() {\n+        if will_later_be_reported_by_nll && self.tcx.nll() {\n             // With `#![feature(nll)]`, we want to present a nice user\n             // experience, so don't even mention the errors from the\n             // AST checker.\n-            if self.tcx.sess.features.borrow().nll {\n+            if self.tcx.features().nll {\n                 return;\n             }\n \n             // But with -Znll, it's nice to have some note for later.\n             for error in errors {\n                 match *error {\n-                    RegionResolutionError::ConcreteFailure(ref origin, ..) |\n-                    RegionResolutionError::GenericBoundFailure(ref origin, ..) => {\n-                        self.tcx.sess.span_warn(\n-                            origin.span(),\n-                            \"not reporting region error due to -Znll\");\n+                    RegionResolutionError::ConcreteFailure(ref origin, ..)\n+                    | RegionResolutionError::GenericBoundFailure(ref origin, ..) => {\n+                        self.tcx\n+                            .sess\n+                            .span_warn(origin.span(), \"not reporting region error due to -Znll\");\n                     }\n \n                     RegionResolutionError::SubSupConflict(ref rvo, ..) => {\n-                        self.tcx.sess.span_warn(\n-                            rvo.span(),\n-                            \"not reporting region error due to -Znll\");\n+                        self.tcx\n+                            .sess\n+                            .span_warn(rvo.span(), \"not reporting region error due to -Znll\");\n                     }\n                 }\n             }\n@@ -295,7 +322,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // together into a `ProcessedErrors` group:\n         let errors = self.process_errors(errors);\n \n-        debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n+        debug!(\n+            \"report_region_errors: {} errors after preprocessing\",\n+            errors.len()\n+        );\n \n         for error in errors {\n             debug!(\"report_region_errors: error = {:?}\", error);\n@@ -310,7 +340,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // the error. If all of these fails, we fall back to a rather\n                     // general bit of code that displays the error information\n                     RegionResolutionError::ConcreteFailure(origin, sub, sup) => {\n-                        self.report_concrete_failure(region_scope_tree, origin, sub, sup).emit();\n+                        self.report_concrete_failure(region_scope_tree, origin, sub, sup)\n+                            .emit();\n                     }\n \n                     RegionResolutionError::GenericBoundFailure(origin, param_ty, sub) => {\n@@ -323,17 +354,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         );\n                     }\n \n-                    RegionResolutionError::SubSupConflict(var_origin,\n-                                                          sub_origin,\n-                                                          sub_r,\n-                                                          sup_origin,\n-                                                          sup_r) => {\n-                        self.report_sub_sup_conflict(region_scope_tree,\n-                                                     var_origin,\n-                                                     sub_origin,\n-                                                     sub_r,\n-                                                     sup_origin,\n-                                                     sup_r);\n+                    RegionResolutionError::SubSupConflict(\n+                        var_origin,\n+                        sub_origin,\n+                        sub_r,\n+                        sup_origin,\n+                        sup_r,\n+                    ) => {\n+                        self.report_sub_sup_conflict(\n+                            region_scope_tree,\n+                            var_origin,\n+                            sub_origin,\n+                            sub_r,\n+                            sup_origin,\n+                            sup_r,\n+                        );\n                     }\n                 }\n             }\n@@ -350,8 +385,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // The method also attempts to weed out messages that seem like\n     // duplicates that will be unhelpful to the end-user. But\n     // obviously it never weeds out ALL errors.\n-    fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Vec<RegionResolutionError<'tcx>> {\n+    fn process_errors(\n+        &self,\n+        errors: &Vec<RegionResolutionError<'tcx>>,\n+    ) -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"process_errors()\");\n \n         // We want to avoid reporting generic-bound failures if we can\n@@ -368,15 +405,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n-            RegionResolutionError::ConcreteFailure(..) |\n-            RegionResolutionError::SubSupConflict(..) => false,\n+            RegionResolutionError::ConcreteFailure(..)\n+            | RegionResolutionError::SubSupConflict(..) => false,\n         };\n \n-\n         let mut errors = if errors.iter().all(|e| is_bound_failure(e)) {\n             errors.clone()\n         } else {\n-            errors.iter().filter(|&e| !is_bound_failure(e)).cloned().collect()\n+            errors\n+                .iter()\n+                .filter(|&e| !is_bound_failure(e))\n+                .cloned()\n+                .collect()\n         };\n \n         // sort the errors by span, for better error message stability.\n@@ -389,10 +429,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Adds a note if the types come from similarly named crates\n-    fn check_and_note_conflicting_crates(&self,\n-                                         err: &mut DiagnosticBuilder,\n-                                         terr: &TypeError<'tcx>,\n-                                         sp: Span) {\n+    fn check_and_note_conflicting_crates(\n+        &self,\n+        err: &mut DiagnosticBuilder,\n+        terr: &TypeError<'tcx>,\n+        sp: Span,\n+    ) {\n         let report_path_match = |err: &mut DiagnosticBuilder, did1: DefId, did2: DefId| {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n@@ -403,12 +445,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let found_abs_path = self.tcx.absolute_item_path_str(did2);\n                 // We compare strings because DefPath can be different\n                 // for imported and non-imported crates\n-                if exp_path == found_path\n-                || exp_abs_path == found_abs_path {\n+                if exp_path == found_path || exp_abs_path == found_abs_path {\n                     let crate_name = self.tcx.crate_name(did1.krate);\n-                    err.span_note(sp, &format!(\"Perhaps two different versions \\\n-                                                of crate `{}` are being used?\",\n-                                               crate_name));\n+                    err.span_note(\n+                        sp,\n+                        &format!(\n+                            \"Perhaps two different versions \\\n+                             of crate `{}` are being used?\",\n+                            crate_name\n+                        ),\n+                    );\n                 }\n             }\n         };\n@@ -419,24 +465,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 match (&exp_found.expected.sty, &exp_found.found.sty) {\n                     (&ty::TyAdt(exp_adt, _), &ty::TyAdt(found_adt, _)) => {\n                         report_path_match(err, exp_adt.did, found_adt.did);\n-                    },\n-                    _ => ()\n+                    }\n+                    _ => (),\n                 }\n-            },\n+            }\n             TypeError::Traits(ref exp_found) => {\n                 report_path_match(err, exp_found.expected, exp_found.found);\n-            },\n-            _ => () // FIXME(#22750) handle traits and stuff\n+            }\n+            _ => (), // FIXME(#22750) handle traits and stuff\n         }\n     }\n \n-    fn note_error_origin(&self,\n-                         err: &mut DiagnosticBuilder<'tcx>,\n-                         cause: &ObligationCause<'tcx>)\n-    {\n+    fn note_error_origin(&self, err: &mut DiagnosticBuilder<'tcx>, cause: &ObligationCause<'tcx>) {\n         match cause.code {\n             ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n-                hir::MatchSource::IfLetDesugar {..} => {\n+                hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arm with an incompatible type\";\n                     if self.tcx.sess.codemap().is_multiline(arm_span) {\n                         err.span_note(arm_span, msg);\n@@ -453,7 +496,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             },\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -470,13 +513,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Bar<Qux>\n     /// -------- this type is the same as a type argument in the other type, not highlighted\n     /// ```\n-    fn highlight_outer(&self,\n-                       value: &mut DiagnosticStyledString,\n-                       other_value: &mut DiagnosticStyledString,\n-                       name: String,\n-                       sub: &ty::subst::Substs<'tcx>,\n-                       pos: usize,\n-                       other_ty: &Ty<'tcx>) {\n+    fn highlight_outer(\n+        &self,\n+        value: &mut DiagnosticStyledString,\n+        other_value: &mut DiagnosticStyledString,\n+        name: String,\n+        sub: &ty::subst::Substs<'tcx>,\n+        pos: usize,\n+        other_ty: &Ty<'tcx>,\n+    ) {\n         // `value` and `other_value` hold two incomplete type representation for display.\n         // `name` is the path of both types being compared. `sub`\n         value.push_highlighted(name);\n@@ -486,14 +531,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Output the lifetimes fot the first type\n-        let lifetimes = sub.regions().map(|lifetime| {\n-            let s = format!(\"{}\", lifetime);\n-            if s.is_empty() {\n-                \"'_\".to_string()\n-            } else {\n-                s\n-            }\n-        }).collect::<Vec<_>>().join(\", \");\n+        let lifetimes = sub.regions()\n+            .map(|lifetime| {\n+                let s = format!(\"{}\", lifetime);\n+                if s.is_empty() {\n+                    \"'_\".to_string()\n+                } else {\n+                    s\n+                }\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\", \");\n         if !lifetimes.is_empty() {\n             if sub.regions().count() < len {\n                 value.push_normal(lifetimes + &\", \");\n@@ -543,13 +591,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Bar<Qux>\n     /// -------- this type is the same as a type argument in the other type, not highlighted\n     /// ```\n-    fn cmp_type_arg(&self,\n-                    mut t1_out: &mut DiagnosticStyledString,\n-                    mut t2_out: &mut DiagnosticStyledString,\n-                    path: String,\n-                    sub: &ty::subst::Substs<'tcx>,\n-                    other_path: String,\n-                    other_ty: &Ty<'tcx>) -> Option<()> {\n+    fn cmp_type_arg(\n+        &self,\n+        mut t1_out: &mut DiagnosticStyledString,\n+        mut t2_out: &mut DiagnosticStyledString,\n+        path: String,\n+        sub: &ty::subst::Substs<'tcx>,\n+        other_path: String,\n+        other_ty: &Ty<'tcx>,\n+    ) -> Option<()> {\n         for (i, ta) in sub.types().enumerate() {\n             if &ta == other_ty {\n                 self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n@@ -567,11 +617,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Add a `,` to the type representation only if it is appropriate.\n-    fn push_comma(&self,\n-                  value: &mut DiagnosticStyledString,\n-                  other_value: &mut DiagnosticStyledString,\n-                  len: usize,\n-                  pos: usize) {\n+    fn push_comma(\n+        &self,\n+        value: &mut DiagnosticStyledString,\n+        other_value: &mut DiagnosticStyledString,\n+        len: usize,\n+        pos: usize,\n+    ) {\n         if len > 0 && pos != len - 1 {\n             value.push_normal(\", \");\n             other_value.push_normal(\", \");\n@@ -580,39 +632,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Compare two given types, eliding parts that are the same between them and highlighting\n     /// relevant differences, and return two representation of those types for highlighted printing.\n-    fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>)\n-        -> (DiagnosticStyledString, DiagnosticStyledString)\n-    {\n+    fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n         fn equals<'tcx>(a: &Ty<'tcx>, b: &Ty<'tcx>) -> bool {\n             match (&a.sty, &b.sty) {\n                 (a, b) if *a == *b => true,\n-                (&ty::TyInt(_), &ty::TyInfer(ty::InferTy::IntVar(_))) |\n-                (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInt(_)) |\n-                (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInfer(ty::InferTy::IntVar(_))) |\n-                (&ty::TyFloat(_), &ty::TyInfer(ty::InferTy::FloatVar(_))) |\n-                (&ty::TyInfer(ty::InferTy::FloatVar(_)), &ty::TyFloat(_)) |\n-                (&ty::TyInfer(ty::InferTy::FloatVar(_)),\n-                 &ty::TyInfer(ty::InferTy::FloatVar(_))) => true,\n+                (&ty::TyInt(_), &ty::TyInfer(ty::InferTy::IntVar(_)))\n+                | (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInt(_))\n+                | (&ty::TyInfer(ty::InferTy::IntVar(_)), &ty::TyInfer(ty::InferTy::IntVar(_)))\n+                | (&ty::TyFloat(_), &ty::TyInfer(ty::InferTy::FloatVar(_)))\n+                | (&ty::TyInfer(ty::InferTy::FloatVar(_)), &ty::TyFloat(_))\n+                | (\n+                    &ty::TyInfer(ty::InferTy::FloatVar(_)),\n+                    &ty::TyInfer(ty::InferTy::FloatVar(_)),\n+                ) => true,\n                 _ => false,\n             }\n         }\n \n-        fn push_ty_ref<'tcx>(r: &ty::Region<'tcx>,\n-                             tnm: &ty::TypeAndMut<'tcx>,\n-                             s: &mut DiagnosticStyledString) {\n+        fn push_ty_ref<'tcx>(\n+            r: &ty::Region<'tcx>,\n+            tnm: &ty::TypeAndMut<'tcx>,\n+            s: &mut DiagnosticStyledString,\n+        ) {\n             let r = &format!(\"{}\", r);\n-            s.push_highlighted(format!(\"&{}{}{}\",\n-                                       r,\n-                                       if r == \"\" {\n-                                           \"\"\n-                                       } else {\n-                                           \" \"\n-                                       },\n-                                       if tnm.mutbl == hir::MutMutable {\n-                                          \"mut \"\n-                                       } else {\n-                                           \"\"\n-                                       }));\n+            s.push_highlighted(format!(\n+                \"&{}{}{}\",\n+                r,\n+                if r == \"\" { \"\" } else { \" \" },\n+                if tnm.mutbl == hir::MutMutable {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                }\n+            ));\n             s.push_normal(format!(\"{}\", tnm.ty));\n         }\n \n@@ -705,32 +757,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     //     Foo<Bar<Qux>\n                     //         ------- this type argument is exactly the same as the other type\n                     //     Bar<Qux>\n-                    if self.cmp_type_arg(&mut values.0,\n-                                         &mut values.1,\n-                                         path1.clone(),\n-                                         sub1,\n-                                         path2.clone(),\n-                                         &t2).is_some() {\n+                    if self.cmp_type_arg(\n+                        &mut values.0,\n+                        &mut values.1,\n+                        path1.clone(),\n+                        sub1,\n+                        path2.clone(),\n+                        &t2,\n+                    ).is_some()\n+                    {\n                         return values;\n                     }\n                     // Check for case:\n                     //     let x: Bar<Qux> = y:<Foo<Bar<Qux>>>();\n                     //     Bar<Qux>\n                     //     Foo<Bar<Qux>>\n                     //         ------- this type argument is exactly the same as the other type\n-                    if self.cmp_type_arg(&mut values.1,\n-                                         &mut values.0,\n-                                         path2,\n-                                         sub2,\n-                                         path1,\n-                                         &t1).is_some() {\n+                    if self.cmp_type_arg(&mut values.1, &mut values.0, path2, sub2, path1, &t1)\n+                        .is_some()\n+                    {\n                         return values;\n                     }\n \n                     // We couldn't find anything in common, highlight everything.\n                     //     let x: Bar<Qux> = y::<Foo<Zar>>();\n-                    (DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n-                     DiagnosticStyledString::highlighted(format!(\"{}\", t2)))\n+                    (\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t2)),\n+                    )\n                 }\n             }\n \n@@ -759,37 +813,45 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 if t1 == t2 {\n                     // The two types are the same, elide and don't highlight.\n-                    (DiagnosticStyledString::normal(\"_\"), DiagnosticStyledString::normal(\"_\"))\n+                    (\n+                        DiagnosticStyledString::normal(\"_\"),\n+                        DiagnosticStyledString::normal(\"_\"),\n+                    )\n                 } else {\n                     // We couldn't find anything in common, highlight everything.\n-                    (DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n-                     DiagnosticStyledString::highlighted(format!(\"{}\", t2)))\n+                    (\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n+                        DiagnosticStyledString::highlighted(format!(\"{}\", t2)),\n+                    )\n                 }\n             }\n         }\n     }\n \n-    pub fn note_type_err(&self,\n-                         diag: &mut DiagnosticBuilder<'tcx>,\n-                         cause: &ObligationCause<'tcx>,\n-                         secondary_span: Option<(Span, String)>,\n-                         mut values: Option<ValuePairs<'tcx>>,\n-                         terr: &TypeError<'tcx>)\n-    {\n+    pub fn note_type_err(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        secondary_span: Option<(Span, String)>,\n+        mut values: Option<ValuePairs<'tcx>>,\n+        terr: &TypeError<'tcx>,\n+    ) {\n         // For some types of errors, expected-found does not make\n         // sense, so just ignore the values we were given.\n         match terr {\n-            TypeError::CyclicTy(_) => { values = None; }\n-            _ => { }\n+            TypeError::CyclicTy(_) => {\n+                values = None;\n+            }\n+            _ => {}\n         }\n \n         let (expected_found, exp_found, is_simple_error) = match values {\n             None => (None, None, false),\n             Some(values) => {\n                 let (is_simple_error, exp_found) = match values {\n                     ValuePairs::Types(exp_found) => {\n-                        let is_simple_err = exp_found.expected.is_primitive()\n-                            && exp_found.found.is_primitive();\n+                        let is_simple_err =\n+                            exp_found.expected.is_primitive() && exp_found.found.is_primitive();\n \n                         (is_simple_err, Some(exp_found))\n                     }\n@@ -800,7 +862,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     None => {\n                         // Derived error. Cancel the emitter.\n                         self.tcx.sess.diagnostic().cancel(diag);\n-                        return\n+                        return;\n                     }\n                 };\n                 (vals, exp_found, is_simple_error)\n@@ -818,22 +880,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             match (terr, is_simple_error, expected == found) {\n                 (&TypeError::Sorts(ref values), false, true) => {\n                     diag.note_expected_found_extra(\n-                        &\"type\", expected, found,\n+                        &\"type\",\n+                        expected,\n+                        found,\n                         &format!(\" ({})\", values.expected.sort_string(self.tcx)),\n-                        &format!(\" ({})\", values.found.sort_string(self.tcx)));\n+                        &format!(\" ({})\", values.found.sort_string(self.tcx)),\n+                    );\n                 }\n                 (_, false, _) => {\n                     if let Some(exp_found) = exp_found {\n                         let (def_id, ret_ty) = match exp_found.found.sty {\n                             TypeVariants::TyFnDef(def, _) => {\n                                 (Some(def), Some(self.tcx.fn_sig(def).output()))\n                             }\n-                            _ => (None, None)\n+                            _ => (None, None),\n                         };\n \n                         let exp_is_struct = match exp_found.expected.sty {\n                             TypeVariants::TyAdt(def, _) => def.is_struct(),\n-                            _ => false\n+                            _ => false,\n                         };\n \n                         if let (Some(def_id), Some(ret_ty)) = (def_id, ret_ty) {\n@@ -861,14 +926,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.note_error_origin(diag, &cause);\n     }\n \n-    pub fn report_and_explain_type_error(&self,\n-                                         trace: TypeTrace<'tcx>,\n-                                         terr: &TypeError<'tcx>)\n-                                         -> DiagnosticBuilder<'tcx>\n-    {\n-        debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\",\n-               trace,\n-               terr);\n+    pub fn report_and_explain_type_error(\n+        &self,\n+        trace: TypeTrace<'tcx>,\n+        terr: &TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        debug!(\n+            \"report_and_explain_type_error(trace={:?}, terr={:?})\",\n+            trace, terr\n+        );\n \n         let span = trace.cause.span(&self.tcx);\n         let failure_code = trace.cause.as_failure_code(terr);\n@@ -890,19 +956,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         diag\n     }\n \n-    fn values_str(&self, values: &ValuePairs<'tcx>)\n-        -> Option<(DiagnosticStyledString, DiagnosticStyledString)>\n-    {\n+    fn values_str(\n+        &self,\n+        values: &ValuePairs<'tcx>,\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str_ty(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n             infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n         }\n     }\n \n-    fn expected_found_str_ty(&self,\n-                             exp_found: &ty::error::ExpectedFound<Ty<'tcx>>)\n-                             -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+    fn expected_found_str_ty(\n+        &self,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         let exp_found = self.resolve_type_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n@@ -914,25 +982,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string of the form \"expected `{}`, found `{}`\".\n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n-        exp_found: &ty::error::ExpectedFound<T>)\n-        -> Option<(DiagnosticStyledString, DiagnosticStyledString)>\n-    {\n+        exp_found: &ty::error::ExpectedFound<T>,\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n         let exp_found = self.resolve_type_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n \n-        Some((DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.expected)),\n-              DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.found))))\n+        Some((\n+            DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.expected)),\n+            DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.found)),\n+        ))\n     }\n \n-    pub fn report_generic_bound_failure(&self,\n-                                        region_scope_tree: &region::ScopeTree,\n-                                        span: Span,\n-                                        origin: Option<SubregionOrigin<'tcx>>,\n-                                        bound_kind: GenericKind<'tcx>,\n-                                        sub: Region<'tcx>)\n-    {\n+    pub fn report_generic_bound_failure(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        span: Span,\n+        origin: Option<SubregionOrigin<'tcx>>,\n+        bound_kind: GenericKind<'tcx>,\n+        sub: Region<'tcx>,\n+    ) {\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let type_param_span = match (self.in_progress_tables, bound_kind) {\n@@ -958,8 +1028,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // `sp` only covers `T`, change it so that it covers\n                             // `T:` when appropriate\n                             let sp = if has_lifetimes {\n-                                sp.to(self.tcx.sess.codemap().next_point(\n-                                        self.tcx.sess.codemap().next_point(sp)))\n+                                sp.to(self.tcx\n+                                    .sess\n+                                    .codemap()\n+                                    .next_point(self.tcx.sess.codemap().next_point(sp)))\n                             } else {\n                                 sp\n                             };\n@@ -974,37 +1046,39 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let labeled_user_string = match bound_kind {\n-            GenericKind::Param(ref p) =>\n-                format!(\"the parameter type `{}`\", p),\n-            GenericKind::Projection(ref p) =>\n-                format!(\"the associated type `{}`\", p),\n+            GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n+            GenericKind::Projection(ref p) => format!(\"the associated type `{}`\", p),\n         };\n \n         if let Some(SubregionOrigin::CompareImplMethodObligation {\n-            span, item_name, impl_item_def_id, trait_item_def_id,\n-        }) = origin {\n-            self.report_extra_impl_obligation(span,\n-                                              item_name,\n-                                              impl_item_def_id,\n-                                              trait_item_def_id,\n-                                              &format!(\"`{}: {}`\", bound_kind, sub))\n-                .emit();\n+            span,\n+            item_name,\n+            impl_item_def_id,\n+            trait_item_def_id,\n+        }) = origin\n+        {\n+            self.report_extra_impl_obligation(\n+                span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+                &format!(\"`{}: {}`\", bound_kind, sub),\n+            ).emit();\n             return;\n         }\n \n-        fn binding_suggestion<'tcx, S: fmt::Display>(err: &mut DiagnosticBuilder<'tcx>,\n-                                                     type_param_span: Option<(Span, bool)>,\n-                                                     bound_kind: GenericKind<'tcx>,\n-                                                     sub: S) {\n-            let consider = &format!(\"consider adding an explicit lifetime bound `{}: {}`...\",\n-                                    bound_kind,\n-                                    sub);\n+        fn binding_suggestion<'tcx, S: fmt::Display>(\n+            err: &mut DiagnosticBuilder<'tcx>,\n+            type_param_span: Option<(Span, bool)>,\n+            bound_kind: GenericKind<'tcx>,\n+            sub: S,\n+        ) {\n+            let consider = &format!(\n+                \"consider adding an explicit lifetime bound `{}: {}`...\",\n+                bound_kind, sub\n+            );\n             if let Some((sp, has_lifetimes)) = type_param_span {\n-                let tail = if has_lifetimes {\n-                    \" + \"\n-                } else {\n-                    \"\"\n-                };\n+                let tail = if has_lifetimes { \" + \" } else { \"\" };\n                 let suggestion = format!(\"{}: {}{}\", bound_kind, sub, tail);\n                 err.span_suggestion_short(sp, consider, suggestion);\n             } else {\n@@ -1013,44 +1087,56 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let mut err = match *sub {\n-            ty::ReEarlyBound(_) |\n-            ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n+            ty::ReEarlyBound(_)\n+            | ty::ReFree(ty::FreeRegion {\n+                bound_region: ty::BrNamed(..),\n+                ..\n+            }) => {\n                 // Does the required lifetime have a nice name we can print?\n-                let mut err = struct_span_err!(self.tcx.sess,\n-                                               span,\n-                                               E0309,\n-                                               \"{} may not live long enough\",\n-                                               labeled_user_string);\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0309,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string\n+                );\n                 binding_suggestion(&mut err, type_param_span, bound_kind, sub);\n                 err\n             }\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                let mut err = struct_span_err!(self.tcx.sess,\n-                                               span,\n-                                               E0310,\n-                                               \"{} may not live long enough\",\n-                                               labeled_user_string);\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0310,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string\n+                );\n                 binding_suggestion(&mut err, type_param_span, bound_kind, \"'static\");\n                 err\n             }\n \n             _ => {\n                 // If not, be less specific.\n-                let mut err = struct_span_err!(self.tcx.sess,\n-                                               span,\n-                                               E0311,\n-                                               \"{} may not live long enough\",\n-                                               labeled_user_string);\n-                err.help(&format!(\"consider adding an explicit lifetime bound for `{}`\",\n-                                  bound_kind));\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0311,\n+                    \"{} may not live long enough\",\n+                    labeled_user_string\n+                );\n+                err.help(&format!(\n+                    \"consider adding an explicit lifetime bound for `{}`\",\n+                    bound_kind\n+                ));\n                 self.tcx.note_and_explain_region(\n                     region_scope_tree,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n-                    \"...\");\n+                    \"...\",\n+                );\n                 err\n             }\n         };\n@@ -1061,26 +1147,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_sub_sup_conflict(&self,\n-                               region_scope_tree: &region::ScopeTree,\n-                               var_origin: RegionVariableOrigin,\n-                               sub_origin: SubregionOrigin<'tcx>,\n-                               sub_region: Region<'tcx>,\n-                               sup_origin: SubregionOrigin<'tcx>,\n-                               sup_region: Region<'tcx>) {\n-\n+    fn report_sub_sup_conflict(\n+        &self,\n+        region_scope_tree: &region::ScopeTree,\n+        var_origin: RegionVariableOrigin,\n+        sub_origin: SubregionOrigin<'tcx>,\n+        sub_region: Region<'tcx>,\n+        sup_origin: SubregionOrigin<'tcx>,\n+        sup_region: Region<'tcx>,\n+    ) {\n         let mut err = self.report_inference_failure(var_origin);\n \n-        self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n+        self.tcx.note_and_explain_region(\n+            region_scope_tree,\n+            &mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n-            \"...\");\n+            \"...\",\n+        );\n \n         match (&sup_origin, &sub_origin) {\n             (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) => {\n-                if let (Some((sup_expected, sup_found)),\n-                        Some((sub_expected, sub_found))) = (self.values_str(&sup_trace.values),\n-                                                            self.values_str(&sub_trace.values)) {\n+                if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) = (\n+                    self.values_str(&sup_trace.values),\n+                    self.values_str(&sub_trace.values),\n+                ) {\n                     if sub_expected == sup_expected && sub_found == sup_found {\n                         self.tcx.note_and_explain_region(\n                             region_scope_tree,\n@@ -1089,10 +1180,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             sub_region,\n                             \"...\",\n                         );\n-                        err.note(&format!(\"...so that the {}:\\nexpected {}\\n   found {}\",\n-                                          sup_trace.cause.as_requirement_str(),\n-                                          sup_expected.content(),\n-                                          sup_found.content()));\n+                        err.note(&format!(\n+                            \"...so that the {}:\\nexpected {}\\n   found {}\",\n+                            sup_trace.cause.as_requirement_str(),\n+                            sup_expected.content(),\n+                            sup_found.content()\n+                        ));\n                         err.emit();\n                         return;\n                     }\n@@ -1103,20 +1196,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.note_region_origin(&mut err, &sup_origin);\n \n-        self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n+        self.tcx.note_and_explain_region(\n+            region_scope_tree,\n+            &mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n-            \"...\");\n+            \"...\",\n+        );\n \n         self.note_region_origin(&mut err, &sub_origin);\n         err.emit();\n     }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn report_inference_failure(&self,\n-                                var_origin: RegionVariableOrigin)\n-                                -> DiagnosticBuilder<'tcx> {\n+    fn report_inference_failure(\n+        &self,\n+        var_origin: RegionVariableOrigin,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let br_string = |br: ty::BoundRegion| {\n             let mut s = br.to_string();\n             if !s.is_empty() {\n@@ -1131,23 +1228,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::Autoref(_) => \" for autoref\".to_string(),\n             infer::Coercion(_) => \" for automatic coercion\".to_string(),\n             infer::LateBoundRegion(_, br, infer::FnCall) => {\n-                format!(\" for lifetime parameter {}in function call\",\n-                        br_string(br))\n+                format!(\" for lifetime parameter {}in function call\", br_string(br))\n             }\n             infer::LateBoundRegion(_, br, infer::HigherRankedType) => {\n                 format!(\" for lifetime parameter {}in generic type\", br_string(br))\n             }\n-            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => {\n-                format!(\" for lifetime parameter {}in trait containing associated type `{}`\",\n-                        br_string(br), self.tcx.associated_item(def_id).name)\n-            }\n-            infer::EarlyBoundRegion(_, name) => {\n-                format!(\" for lifetime parameter `{}`\",\n-                        name)\n-            }\n+            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => format!(\n+                \" for lifetime parameter {}in trait containing associated type `{}`\",\n+                br_string(br),\n+                self.tcx.associated_item(def_id).name\n+            ),\n+            infer::EarlyBoundRegion(_, name) => format!(\" for lifetime parameter `{}`\", name),\n             infer::BoundRegionInCoherence(name) => {\n-                format!(\" for lifetime parameter `{}` in coherence check\",\n-                        name)\n+                format!(\" for lifetime parameter `{}` in coherence check\", name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n@@ -1157,10 +1250,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),\n         };\n \n-        struct_span_err!(self.tcx.sess, var_origin.span(), E0495,\n-                  \"cannot infer an appropriate lifetime{} \\\n-                   due to conflicting requirements\",\n-                  var_description)\n+        struct_span_err!(\n+            self.tcx.sess,\n+            var_origin.span(),\n+            E0495,\n+            \"cannot infer an appropriate lifetime{} \\\n+             due to conflicting requirements\",\n+            var_description\n+        )\n     }\n }\n \n@@ -1178,7 +1275,7 @@ impl<'tcx> ObligationCause<'tcx> {\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n             MatchExpressionArm { source, .. } => Error0308(match source {\n-                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n+                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have incompatible types\",\n                 _ => \"match arms have incompatible types\",\n             }),\n             IfExpression => Error0308(\"if and else have incompatible types\"),\n@@ -1193,11 +1290,11 @@ impl<'tcx> ObligationCause<'tcx> {\n             // say, also take a look at the error code, maybe we can\n             // tailor to that.\n             _ => match terr {\n-                TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() =>\n-                    Error0644(\"closure/generator type that references itself\"),\n-                _ =>\n-                    Error0308(\"mismatched types\"),\n-            }\n+                TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => {\n+                    Error0644(\"closure/generator type that references itself\")\n+                }\n+                _ => Error0308(\"mismatched types\"),\n+            },\n         }\n     }\n \n@@ -1207,7 +1304,7 @@ impl<'tcx> ObligationCause<'tcx> {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\",\n             MatchExpressionArm { source, .. } => match source {\n-                hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have compatible types\",\n+                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n                 _ => \"match arms have compatible types\",\n             },\n             IfExpression => \"if and else have compatible types\","}, {"sha": "5dbe2ef516cf7c2ab7406f0832b02a2e3d9d3027", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -32,7 +32,6 @@ use ich;\n use ty::{self, TyCtxt};\n use session::{Session, CrateDisambiguator};\n use session::search_paths::PathKind;\n-use util::nodemap::NodeSet;\n \n use std::any::Any;\n use std::collections::BTreeMap;\n@@ -258,8 +257,7 @@ pub trait CrateStore {\n     // utility functions\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 reachable: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n@@ -342,8 +340,7 @@ impl CrateStore for DummyCrateStore {\n     fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 reachable: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata {\n         bug!(\"encode_metadata\")\n     }"}, {"sha": "b1418792490fcc3d40c832f62aec98ca9c050080", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir::def_id::{DefId, LOCAL_CRATE};\n+use std::cmp;\n+use ty;\n+\n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any\n /// kind of crate, including cdylibs which export very few things.\n /// `Rust` will only be exported if the crate produced is a Rust\n /// dylib.\n-#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum SymbolExportLevel {\n     C,\n     Rust,\n@@ -34,3 +38,58 @@ impl SymbolExportLevel {\n         }\n     }\n }\n+\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub enum ExportedSymbol {\n+    NonGeneric(DefId),\n+    NoDefId(ty::SymbolName),\n+}\n+\n+impl ExportedSymbol {\n+    pub fn symbol_name(&self, tcx: ty::TyCtxt) -> ty::SymbolName {\n+        match *self {\n+            ExportedSymbol::NonGeneric(def_id) => {\n+                tcx.symbol_name(ty::Instance::mono(tcx, def_id))\n+            }\n+            ExportedSymbol::NoDefId(symbol_name) => {\n+                symbol_name\n+            }\n+        }\n+    }\n+\n+    pub fn compare_stable(&self, tcx: ty::TyCtxt, other: &ExportedSymbol) -> cmp::Ordering {\n+        match *self {\n+            ExportedSymbol::NonGeneric(self_def_id) => {\n+                match *other {\n+                    ExportedSymbol::NonGeneric(other_def_id) => {\n+                        tcx.def_path_hash(self_def_id).cmp(&tcx.def_path_hash(other_def_id))\n+                    }\n+                    ExportedSymbol::NoDefId(_) => {\n+                        cmp::Ordering::Less\n+                    }\n+                }\n+            }\n+            ExportedSymbol::NoDefId(self_symbol_name) => {\n+                match *other {\n+                    ExportedSymbol::NonGeneric(_) => {\n+                        cmp::Ordering::Greater\n+                    }\n+                    ExportedSymbol::NoDefId(ref other_symbol_name) => {\n+                        self_symbol_name.cmp(other_symbol_name)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum self::ExportedSymbol {\n+    NonGeneric(def_id),\n+    NoDefId(symbol_name)\n+});\n+\n+pub fn metadata_symbol_name(tcx: ty::TyCtxt) -> String {\n+    format!(\"rust_metadata_{}_{}\",\n+            tcx.original_crate_name(LOCAL_CRATE),\n+            tcx.crate_disambiguator(LOCAL_CRATE).to_fingerprint().to_hex())\n+}"}, {"sha": "5658b5b6832915ce29946bdb96fe9b85364c2122", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -206,11 +206,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&mut self) {\n         let mut scanned = FxHashSet();\n-        loop {\n-            let search_item = match self.worklist.pop() {\n-                Some(item) => item,\n-                None => break,\n-            };\n+        while let Some(search_item) = self.worklist.pop() {\n             if !scanned.insert(search_item) {\n                 continue\n             }"}, {"sha": "16c33d6bd837da03f301396a7eb42a43b11d2ac9", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n         where F: FnOnce(&mut Self)\n     {\n-        if self.tcx.sess.features.borrow().staged_api {\n+        if self.tcx.features().staged_api {\n             // This crate explicitly wants staged API.\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n             if let Some(..) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> Index<'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Index<'tcx> {\n         let is_staged_api =\n             tcx.sess.opts.debugging_opts.force_unstable_if_unmarked ||\n-            tcx.sess.features.borrow().staged_api;\n+            tcx.features().staged_api;\n         let mut staged_api = FxHashMap();\n         staged_api.insert(LOCAL_CRATE, is_staged_api);\n         let mut index = Index {\n@@ -408,7 +408,7 @@ impl<'a, 'tcx> Index<'tcx> {\n             active_features: FxHashSet(),\n         };\n \n-        let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n+        let ref active_lib_features = tcx.features().declared_lib_features;\n \n         // Put the active features into a map for quick lookup\n         index.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n@@ -677,7 +677,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n-            hir::ItemUnion(..) if !self.tcx.sess.features.borrow().untagged_unions => {\n+            hir::ItemUnion(..) if !self.tcx.features().untagged_unions => {\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let ty = self.tcx.type_of(def_id);\n@@ -721,8 +721,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let sess = &tcx.sess;\n-\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n@@ -736,12 +734,12 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }\n \n-    let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n+    let ref declared_lib_features = tcx.features().declared_lib_features;\n     let mut remaining_lib_features: FxHashMap<Symbol, Span>\n         = declared_lib_features.clone().into_iter().collect();\n     remaining_lib_features.remove(&Symbol::intern(\"proc_macro\"));\n \n-    for &(ref stable_lang_feature, span) in &sess.features.borrow().declared_stable_lang_features {\n+    for &(ref stable_lang_feature, span) in &tcx.features().declared_stable_lang_features {\n         let version = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n             .expect(\"unexpectedly couldn't find version feature was stabilized\");\n         tcx.lint_node(lint::builtin::STABLE_FEATURES,"}, {"sha": "5e9eeb973007f26f71fc0c366d1d4cdad6e6a1e8", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 19, "deletions": 47, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -20,7 +20,7 @@ use lint::builtin::BuiltinLintDiagnostics;\n use middle::allocator::AllocatorKind;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n-use session::config::{BorrowckMode, DebugInfoLevel, OutputType, Epoch};\n+use session::config::{DebugInfoLevel, OutputType, Epoch};\n use ty::tls;\n use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n@@ -93,7 +93,8 @@ pub struct Session {\n     /// multiple crates with the same name to coexist. See the\n     /// trans::back::symbol_names module for more information.\n     pub crate_disambiguator: RefCell<Option<CrateDisambiguator>>,\n-    pub features: RefCell<feature_gate::Features>,\n+\n+    features: RefCell<Option<feature_gate::Features>>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n@@ -194,6 +195,7 @@ impl Session {\n             None => bug!(\"accessing disambiguator before initialization\"),\n         }\n     }\n+\n     pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n                                                     sp: S,\n                                                     msg: &str)\n@@ -456,16 +458,22 @@ impl Session {\n         self.opts.debugging_opts.print_llvm_passes\n     }\n \n-    /// If true, we should use NLL-style region checking instead of\n-    /// lexical style.\n-    pub fn nll(&self) -> bool {\n-        self.features.borrow().nll || self.opts.debugging_opts.nll\n+    /// Get the features enabled for the current compilation session.\n+    /// DO NOT USE THIS METHOD if there is a TyCtxt available, as it circumvents\n+    /// dependency tracking. Use tcx.features() instead.\n+    #[inline]\n+    pub fn features_untracked(&self) -> cell::Ref<feature_gate::Features> {\n+        let features = self.features.borrow();\n+\n+        if features.is_none() {\n+            bug!(\"Access to Session::features before it is initialized\");\n+        }\n+\n+        cell::Ref::map(features, |r| r.as_ref().unwrap())\n     }\n \n-    /// If true, we should use the MIR-based borrowck (we may *also* use\n-    /// the AST-based borrowck).\n-    pub fn use_mir(&self) -> bool {\n-        self.borrowck_mode().use_mir()\n+    pub fn init_features(&self, features: feature_gate::Features) {\n+        *(self.features.borrow_mut()) = Some(features);\n     }\n \n     /// If true, we should gather causal information during NLL\n@@ -475,42 +483,6 @@ impl Session {\n         self.opts.debugging_opts.nll_dump_cause\n     }\n \n-    /// If true, we should enable two-phase borrows checks. This is\n-    /// done with either `-Ztwo-phase-borrows` or with\n-    /// `#![feature(nll)]`.\n-    pub fn two_phase_borrows(&self) -> bool {\n-        self.features.borrow().nll || self.opts.debugging_opts.two_phase_borrows\n-    }\n-\n-    /// What mode(s) of borrowck should we run? AST? MIR? both?\n-    /// (Also considers the `#![feature(nll)]` setting.)\n-    pub fn borrowck_mode(&self) -> BorrowckMode {\n-        match self.opts.borrowck_mode {\n-            mode @ BorrowckMode::Mir |\n-            mode @ BorrowckMode::Compare => mode,\n-\n-            mode @ BorrowckMode::Ast => {\n-                if self.nll() {\n-                    BorrowckMode::Mir\n-                } else {\n-                    mode\n-                }\n-            }\n-\n-        }\n-    }\n-\n-    /// Should we emit EndRegion MIR statements? These are consumed by\n-    /// MIR borrowck, but not when NLL is used. They are also consumed\n-    /// by the validation stuff.\n-    pub fn emit_end_regions(&self) -> bool {\n-        // FIXME(#46875) -- we should not emit end regions when NLL is enabled,\n-        // but for now we can't stop doing so because it causes false positives\n-        self.opts.debugging_opts.emit_end_regions ||\n-            self.opts.debugging_opts.mir_emit_validate > 0 ||\n-            self.use_mir()\n-    }\n-\n     /// Calculates the flavor of LTO to use for this compilation.\n     pub fn lto(&self) -> config::Lto {\n         // If our target has codegen requirements ignore the command line\n@@ -1029,7 +1001,7 @@ pub fn build_session_(sopts: config::Options,\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FxHashMap()),\n         crate_disambiguator: RefCell::new(None),\n-        features: RefCell::new(feature_gate::Features::new()),\n+        features: RefCell::new(None),\n         recursion_limit: Cell::new(64),\n         type_length_limit: Cell::new(1048576),\n         next_node_id: Cell::new(NodeId::new(1)),"}, {"sha": "d11565618a687ede894f069fa6f841c4ab38599c", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -164,7 +164,7 @@ pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // The feature gate should prevent introducing new specializations, but not\n     // taking advantage of upstream ones.\n-    if !tcx.sess.features.borrow().specialization &&\n+    if !tcx.features().specialization &&\n         (impl1_def_id.is_local() || impl2_def_id.is_local()) {\n         return false;\n     }"}, {"sha": "47a3580e8676974f80c03b809ab5ddddbb21118a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 71, "deletions": 7, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -14,7 +14,7 @@ use dep_graph::DepGraph;\n use dep_graph::{DepNode, DepConstructor};\n use errors::DiagnosticBuilder;\n use session::Session;\n-use session::config::OutputFilenames;\n+use session::config::{BorrowckMode, OutputFilenames};\n use middle;\n use hir::{TraitCandidate, HirId, ItemLocalId};\n use hir::def::{Def, Export};\n@@ -46,7 +46,7 @@ use ty::layout::{LayoutDetails, TargetDataLayout};\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n-use util::nodemap::{NodeMap, NodeSet, DefIdSet, ItemLocalMap};\n+use util::nodemap::{NodeMap, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n@@ -71,6 +71,7 @@ use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::codemap::MultiSpan;\n+use syntax::feature_gate;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n@@ -1255,6 +1256,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.all_crate_nums(LOCAL_CRATE)\n     }\n \n+    pub fn features(self) -> Lrc<feature_gate::Features> {\n+        self.features_query(LOCAL_CRATE)\n+    }\n+\n     pub fn def_key(self, id: DefId) -> hir_map::DefKey {\n         if id.is_local() {\n             self.hir.def_key(id)\n@@ -1362,13 +1367,60 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.on_disk_query_result_cache.serialize(self.global_tcx(), encoder)\n     }\n \n+    /// If true, we should use NLL-style region checking instead of\n+    /// lexical style.\n+    pub fn nll(self) -> bool {\n+        self.features().nll || self.sess.opts.debugging_opts.nll\n+    }\n+\n+    /// If true, we should use the MIR-based borrowck (we may *also* use\n+    /// the AST-based borrowck).\n+    pub fn use_mir(self) -> bool {\n+        self.borrowck_mode().use_mir()\n+    }\n+\n+    /// If true, we should enable two-phase borrows checks. This is\n+    /// done with either `-Ztwo-phase-borrows` or with\n+    /// `#![feature(nll)]`.\n+    pub fn two_phase_borrows(self) -> bool {\n+        self.features().nll || self.sess.opts.debugging_opts.two_phase_borrows\n+    }\n+\n+    /// What mode(s) of borrowck should we run? AST? MIR? both?\n+    /// (Also considers the `#![feature(nll)]` setting.)\n+    pub fn borrowck_mode(&self) -> BorrowckMode {\n+        match self.sess.opts.borrowck_mode {\n+            mode @ BorrowckMode::Mir |\n+            mode @ BorrowckMode::Compare => mode,\n+\n+            mode @ BorrowckMode::Ast => {\n+                if self.nll() {\n+                    BorrowckMode::Mir\n+                } else {\n+                    mode\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    /// Should we emit EndRegion MIR statements? These are consumed by\n+    /// MIR borrowck, but not when NLL is used. They are also consumed\n+    /// by the validation stuff.\n+    pub fn emit_end_regions(self) -> bool {\n+        // FIXME(#46875) -- we should not emit end regions when NLL is enabled,\n+        // but for now we can't stop doing so because it causes false positives\n+        self.sess.opts.debugging_opts.emit_end_regions ||\n+            self.sess.opts.debugging_opts.mir_emit_validate > 0 ||\n+            self.use_mir()\n+    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-    pub fn encode_metadata(self, link_meta: &LinkMeta, reachable: &NodeSet)\n+    pub fn encode_metadata(self, link_meta: &LinkMeta)\n         -> EncodedMetadata\n     {\n-        self.cstore.encode_metadata(self, link_meta, reachable)\n+        self.cstore.encode_metadata(self, link_meta)\n     }\n }\n \n@@ -2020,7 +2072,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_diverging_default(self) -> Ty<'tcx> {\n-        if self.sess.features.borrow().never_type {\n+        if self.features().never_type {\n             self.types.never\n         } else {\n             self.intern_tup(&[], true)\n@@ -2395,13 +2447,25 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     };\n     providers.has_copy_closures = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.sess.features.borrow().copy_closures\n+        tcx.features().copy_closures\n     };\n     providers.has_clone_closures = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.sess.features.borrow().clone_closures\n+        tcx.features().clone_closures\n     };\n     providers.fully_normalize_monormophic_ty = |tcx, ty| {\n         tcx.fully_normalize_associated_types_in(&ty)\n     };\n+    providers.features_query = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Lrc::new(tcx.sess.features_untracked().clone())\n+    };\n+    providers.is_panic_runtime = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        attr::contains_name(tcx.hir.krate_attrs(), \"panic_runtime\")\n+    };\n+    providers.is_compiler_builtins = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        attr::contains_name(tcx.hir.krate_attrs(), \"compiler_builtins\")\n+    };\n }"}, {"sha": "cfc552bdc85c56a84a0b65aee363c43e75edd565", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -212,9 +212,9 @@ impl<'tcx> QueryDescription<'tcx> for queries::item_attrs<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::is_exported_symbol<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_reachable_non_generic<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"is_exported_symbol\")\n+        bug!(\"is_reachable_non_generic\")\n     }\n }\n \n@@ -383,7 +383,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::is_sanitizer_runtime<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::exported_symbol_ids<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::reachable_non_generics<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the exported symbols of a crate\")\n     }\n@@ -593,6 +593,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::fully_normalize_monormophic_ty<'t\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::features_query<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up enabled feature gates\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::typeck_tables_of<'tcx> {\n     #[inline]\n     fn cache_on_disk(def_id: Self::Key) -> bool {"}, {"sha": "2ef97b2673d6efddb6456aa8a2af8f1418cd8f47", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -26,7 +26,7 @@ use middle::region;\n use middle::resolve_lifetime::{ResolveLifetimes, Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n-use middle::exported_symbols::SymbolExportLevel;\n+use middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n use mir::mono::{CodegenUnit, Stats};\n use mir;\n use session::{CompileResult, CrateDisambiguator};\n@@ -52,6 +52,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::symbol::InternedString;\n use syntax::attr;\n use syntax::ast;\n+use syntax::feature_gate;\n use syntax::symbol::Symbol;\n \n #[macro_use]\n@@ -237,7 +238,6 @@ define_maps! { <'tcx>\n     [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n     [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n     [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n-    [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n     [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> ExternBodyNestedBodies,\n     [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Lrc<ItemLocalSet>,\n@@ -289,7 +289,23 @@ define_maps! { <'tcx>\n     [] fn lint_levels: lint_levels_node(CrateNum) -> Lrc<lint::LintLevelMap>,\n \n     [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n-    [] fn exported_symbol_ids: ExportedSymbolIds(CrateNum) -> Lrc<DefIdSet>,\n+\n+    // The DefIds of all non-generic functions and statics in the given crate\n+    // that can be reached from outside the crate.\n+    //\n+    // We expect this items to be available for being linked to.\n+    //\n+    // This query can also be called for LOCAL_CRATE. In this case it will\n+    // compute which items will be reachable to other crates, taking into account\n+    // the kind of crate that is currently compiled. Crates with only a\n+    // C interface have fewer reachable things.\n+    //\n+    // Does not include external symbols that don't have a corresponding DefId,\n+    // like the compiler-generated `main` function and so on.\n+    [] fn reachable_non_generics: ReachableNonGenerics(CrateNum) -> Lrc<DefIdSet>,\n+    [] fn is_reachable_non_generic: IsReachableNonGeneric(DefId) -> bool,\n+\n+\n     [] fn native_libraries: NativeLibraries(CrateNum) -> Lrc<Vec<NativeLibrary>>,\n     [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n@@ -342,7 +358,7 @@ define_maps! { <'tcx>\n     [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n \n     [] fn exported_symbols: ExportedSymbols(CrateNum)\n-        -> Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n+        -> Arc<Vec<(ExportedSymbol, SymbolExportLevel)>>,\n     [] fn collect_and_partition_translation_items:\n         collect_and_partition_translation_items_node(CrateNum)\n         -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n@@ -374,12 +390,19 @@ define_maps! { <'tcx>\n     // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n     [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)\n         -> usize,\n+\n+    [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n }\n \n //////////////////////////////////////////////////////////////////////\n // These functions are little shims used to find the dep-node for a\n // given query when there is not a *direct* mapping:\n \n+\n+fn features_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::Features\n+}\n+\n fn erase_regions_ty<'tcx>(ty: Ty<'tcx>) -> DepConstructor<'tcx> {\n     DepConstructor::EraseRegionsTy { ty }\n }"}, {"sha": "13f286d6a26868250d6fb7d1b5b8eb2c7dfe8553", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -851,7 +851,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::RvaluePromotableMap => { force!(rvalue_promotable_map, def_id!()); }\n         DepKind::ImplParent => { force!(impl_parent, def_id!()); }\n         DepKind::TraitOfItem => { force!(trait_of_item, def_id!()); }\n-        DepKind::IsExportedSymbol => { force!(is_exported_symbol, def_id!()); }\n+        DepKind::IsReachableNonGeneric => { force!(is_reachable_non_generic, def_id!()); }\n         DepKind::IsMirAvailable => { force!(is_mir_available, def_id!()); }\n         DepKind::ItemAttrs => { force!(item_attrs, def_id!()); }\n         DepKind::FnArgNames => { force!(fn_arg_names, def_id!()); }\n@@ -868,7 +868,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::GetPanicStrategy => { force!(panic_strategy, krate!()); }\n         DepKind::IsNoBuiltins => { force!(is_no_builtins, krate!()); }\n         DepKind::ImplDefaultness => { force!(impl_defaultness, def_id!()); }\n-        DepKind::ExportedSymbolIds => { force!(exported_symbol_ids, krate!()); }\n+        DepKind::ReachableNonGenerics => { force!(reachable_non_generics, krate!()); }\n         DepKind::NativeLibraries => { force!(native_libraries, krate!()); }\n         DepKind::PluginRegistrarFn => { force!(plugin_registrar_fn, krate!()); }\n         DepKind::DeriveRegistrarFn => { force!(derive_registrar_fn, krate!()); }\n@@ -936,6 +936,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::TargetFeaturesEnabled => { force!(target_features_enabled, def_id!()); }\n \n         DepKind::GetSymbolExportLevel => { force!(symbol_export_level, def_id!()); }\n+        DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n     }\n \n     true"}, {"sha": "a7c55880e2e17681ad69ac6454c79387dd822940", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -2335,7 +2335,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns true if the impls are the same polarity and are implementing\n     /// a trait which contains no items\n     pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId) -> bool {\n-        if !self.sess.features.borrow().overlapping_marker_traits {\n+        if !self.features().overlapping_marker_traits {\n             return false;\n         }\n         let trait1_is_empty = self.impl_trait_ref(def_id1)\n@@ -2806,7 +2806,7 @@ impl<'tcx> DtorckConstraint<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub struct SymbolName {\n     // FIXME: we don't rely on interning or equality here - better have\n     // this be a `&'tcx str`.\n@@ -2817,6 +2817,14 @@ impl_stable_hash_for!(struct self::SymbolName {\n     name\n });\n \n+impl SymbolName {\n+    pub fn new(name: &str) -> SymbolName {\n+        SymbolName {\n+            name: Symbol::intern(name).as_str()\n+        }\n+    }\n+}\n+\n impl Deref for SymbolName {\n     type Target = str;\n \n@@ -2828,3 +2836,9 @@ impl fmt::Display for SymbolName {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n+\n+impl fmt::Debug for SymbolName {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.name, fmt)\n+    }\n+}"}, {"sha": "bb198adea4a6a6c88a0c304163a1da053747a04b", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -276,7 +276,7 @@ impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n                                 o: Origin)\n                                 -> DiagnosticBuilder<'a>\n     {\n-        if !o.should_emit_errors(self.tcx.sess.borrowck_mode()) {\n+        if !o.should_emit_errors(self.tcx.borrowck_mode()) {\n             self.tcx.sess.diagnostic().cancel(&mut diag);\n         }\n         diag"}, {"sha": "8e3b99f2dbfee86a13c3007ff5e18877ce50fa76", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n \n     fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n-        if self.tcx.sess.features.borrow().never_type {\n+        if self.tcx.features().never_type {\n             self.tcx.is_ty_uninhabited_from(self.module, ty)\n         } else {\n             false\n@@ -227,7 +227,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n                               substs: &'tcx ty::subst::Substs<'tcx>)\n                               -> bool\n     {\n-        if self.tcx.sess.features.borrow().never_type {\n+        if self.tcx.features().never_type {\n             self.tcx.is_enum_variant_uninhabited_from(self.module, variant, substs)\n         } else {\n             false"}, {"sha": "6f7143c185cb3ad2718ae1463fee873fd8ea77ff", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             let pat_ty = self.tables.node_id_to_type(scrut.hir_id);\n             let module = self.tcx.hir.get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n-                let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n+                let scrutinee_is_uninhabited = if self.tcx.features().never_type {\n                     self.tcx.is_ty_uninhabited_from(module, pat_ty)\n                 } else {\n                     self.conservative_is_uninhabited(pat_ty)"}, {"sha": "2a571fa82643b2d97777158abcead4396f283349", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -398,7 +398,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }).collect::<Result<Vec<_>, _>>()?))))\n       }\n       hir::ExprIndex(ref arr, ref idx) => {\n-        if !tcx.sess.features.borrow().const_indexing {\n+        if !tcx.features().const_indexing {\n             signal!(e, IndexOpFeatureGated);\n         }\n         let arr = cx.eval(arr)?;"}, {"sha": "42a17d33fa6f5c795562c783cd5bacd882e3f666", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -415,13 +415,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             }\n         }\n \n-        loop {\n-            // non-standard `while let` to bypass #6393\n-            let i = match error_stack.pop() {\n-                Some(i) => i,\n-                None => break\n-            };\n-\n+        while let Some(i) = error_stack.pop() {\n             let node = &self.nodes[i];\n \n             match node.state.get() {"}, {"sha": "571cc46bc6413e2eb4f8a9ac9366db05b30b71f2", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -650,7 +650,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n \n     let (mut krate, features) = syntax::config::features(krate, &sess.parse_sess, sess.opts.test);\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n-    *sess.features.borrow_mut() = features;\n+    sess.init_features(features);\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n \n@@ -699,7 +699,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n     let mut registry = registry.unwrap_or(Registry::new(sess, krate.span));\n \n     time(time_passes, \"plugin registration\", || {\n-        if sess.features.borrow().rustc_diagnostic_macros {\n+        if sess.features_untracked().rustc_diagnostic_macros {\n             registry.register_macro(\"__diagnostic_used\",\n                                     diagnostics::plugin::expand_diagnostic_used);\n             registry.register_macro(\"__register_diagnostic\",\n@@ -749,7 +749,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n                                      crate_loader,\n                                      &resolver_arenas);\n     resolver.whitelisted_legacy_custom_derives = whitelisted_legacy_custom_derives;\n-    syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features.borrow().quote);\n+    syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features_untracked().quote);\n \n     krate = time(time_passes, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n@@ -780,7 +780,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n                                          .filter(|p| env::join_paths(iter::once(p)).is_ok()))\n                      .unwrap());\n         }\n-        let features = sess.features.borrow();\n+        let features = sess.features_untracked();\n         let cfg = syntax::ext::expand::ExpansionConfig {\n             features: Some(&features),\n             recursion_limit: sess.recursion_limit.get(),\n@@ -819,7 +819,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n                                          sess.opts.test,\n                                          krate,\n                                          sess.diagnostic(),\n-                                         &sess.features.borrow())\n+                                         &sess.features_untracked())\n     });\n \n     // If we're actually rustdoc then there's no need to actually compile\n@@ -886,7 +886,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         sess.track_errors(|| {\n             syntax::feature_gate::check_crate(&krate,\n                                               &sess.parse_sess,\n-                                              &sess.features.borrow(),\n+                                              &sess.features_untracked(),\n                                               &attributes,\n                                               sess.opts.unstable_features);\n         })"}, {"sha": "17a6176b79e954d4cbb72d2968cb65dff82cf12f", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -69,7 +69,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         // if the `rustc_attrs` feature is not enabled, then the\n         // attributes we are interested in cannot be present anyway, so\n         // skip the walk.\n-        if !tcx.sess.features.borrow().rustc_attrs {\n+        if !tcx.features().rustc_attrs {\n             return;\n         }\n "}, {"sha": "e114606a631159c142461f4d67a730c942eb1a8d", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -219,7 +219,7 @@ impl Assertion {\n \n pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n-    if !tcx.sess.features.borrow().rustc_attrs {\n+    if !tcx.features().rustc_attrs {\n         return;\n     }\n "}, {"sha": "62ac898337ca9a13f083cdad8d1bf5aa5115a28d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1356,7 +1356,7 @@ impl UnreachablePub {\n             // visibility is token at start of declaration (can be macro\n             // variable rather than literal `pub`)\n             let pub_span = cx.tcx.sess.codemap().span_until_char(def_span, ' ');\n-            let replacement = if cx.tcx.sess.features.borrow().crate_visibility_modifier {\n+            let replacement = if cx.tcx.features().crate_visibility_modifier {\n                 \"crate\"\n             } else {\n                 \"pub(crate)\""}, {"sha": "1c4bd0ff4c2ec1335ab7429dee64d7b96f00d42a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 148, "deletions": 9, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -150,11 +150,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n                                 // Detect literal value out of range [min, max] inclusive\n                                 // avoiding use of -min to prevent overflow/panic\n-                                if (negative && v > max + 1) ||\n-                                   (!negative && v > max) {\n-                                    cx.span_lint(OVERFLOWING_LITERALS,\n-                                                 e.span,\n-                                                 &format!(\"literal out of range for {:?}\", t));\n+                                if (negative && v > max + 1) || (!negative && v > max) {\n+                                    if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+                                        report_bin_hex_error(\n+                                            cx,\n+                                            e,\n+                                            ty::TyInt(t),\n+                                            repr_str,\n+                                            v,\n+                                            negative,\n+                                        );\n+                                        return;\n+                                    }\n+                                    cx.span_lint(\n+                                        OVERFLOWING_LITERALS,\n+                                        e.span,\n+                                        &format!(\"literal out of range for {:?}\", t),\n+                                    );\n                                     return;\n                                 }\n                             }\n@@ -182,7 +194,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                         let mut err = cx.struct_span_lint(\n                                                              OVERFLOWING_LITERALS,\n                                                              parent_expr.span,\n-                                                             \"only u8 can be casted into char\");\n+                                                             \"only u8 can be cast into char\");\n                                         err.span_suggestion(parent_expr.span,\n                                                             &\"use a char literal instead\",\n                                                             format!(\"'\\\\u{{{:X}}}'\", lit_val));\n@@ -191,9 +203,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                     }\n                                 }\n                             }\n-                            cx.span_lint(OVERFLOWING_LITERALS,\n-                                         e.span,\n-                                         &format!(\"literal out of range for {:?}\", t));\n+                            if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n+                                report_bin_hex_error(\n+                                    cx,\n+                                    e,\n+                                    ty::TyUint(t),\n+                                    repr_str,\n+                                    lit_val,\n+                                    false,\n+                                );\n+                                return;\n+                            }\n+                            cx.span_lint(\n+                                OVERFLOWING_LITERALS,\n+                                e.span,\n+                                &format!(\"literal out of range for {:?}\", t),\n+                            );\n                         }\n                     }\n                     ty::TyFloat(t) => {\n@@ -338,6 +363,120 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 _ => false,\n             }\n         }\n+\n+        fn get_bin_hex_repr(cx: &LateContext, lit: &ast::Lit) -> Option<String> {\n+            let src = cx.sess().codemap().span_to_snippet(lit.span).ok()?;\n+            let firstch = src.chars().next()?;\n+\n+            if firstch == '0' {\n+                match src.chars().nth(1) {\n+                    Some('x') | Some('b') => return Some(src),\n+                    _ => return None,\n+                }\n+            }\n+\n+            None\n+        }\n+\n+        // This function finds the next fitting type and generates a suggestion string.\n+        // It searches for fitting types in the following way (`X < Y`):\n+        //  - `iX`: if literal fits in `uX` => `uX`, else => `iY`\n+        //  - `-iX` => `iY`\n+        //  - `uX` => `uY`\n+        //\n+        // No suggestion for: `isize`, `usize`.\n+        fn get_type_suggestion<'a>(\n+            t: &ty::TypeVariants,\n+            val: u128,\n+            negative: bool,\n+        ) -> Option<String> {\n+            use syntax::ast::IntTy::*;\n+            use syntax::ast::UintTy::*;\n+            macro_rules! find_fit {\n+                ($ty:expr, $val:expr, $negative:expr,\n+                 $($type:ident => [$($utypes:expr),*] => [$($itypes:expr),*]),+) => {\n+                    {\n+                        let _neg = if negative { 1 } else { 0 };\n+                        match $ty {\n+                            $($type => {\n+                                $(if !negative && val <= uint_ty_range($utypes).1 {\n+                                    return Some(format!(\"{:?}\", $utypes))\n+                                })*\n+                                $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n+                                    return Some(format!(\"{:?}\", $itypes))\n+                                })*\n+                                None\n+                            },)*\n+                            _ => None\n+                        }\n+                    }\n+                }\n+            }\n+            match t {\n+                &ty::TyInt(i) => find_fit!(i, val, negative,\n+                              I8 => [U8] => [I16, I32, I64, I128],\n+                              I16 => [U16] => [I32, I64, I128],\n+                              I32 => [U32] => [I64, I128],\n+                              I64 => [U64] => [I128],\n+                              I128 => [U128] => []),\n+                &ty::TyUint(u) => find_fit!(u, val, negative,\n+                              U8 => [U8, U16, U32, U64, U128] => [],\n+                              U16 => [U16, U32, U64, U128] => [],\n+                              U32 => [U32, U64, U128] => [],\n+                              U64 => [U64, U128] => [],\n+                              U128 => [U128] => []),\n+                _ => None,\n+            }\n+        }\n+\n+        fn report_bin_hex_error(\n+            cx: &LateContext,\n+            expr: &hir::Expr,\n+            ty: ty::TypeVariants,\n+            repr_str: String,\n+            val: u128,\n+            negative: bool,\n+        ) {\n+            let (t, actually) = match ty {\n+                ty::TyInt(t) => {\n+                    let bits = int_ty_bits(t, cx.sess().target.isize_ty);\n+                    let actually = (val << (128 - bits)) as i128 >> (128 - bits);\n+                    (format!(\"{:?}\", t), actually.to_string())\n+                }\n+                ty::TyUint(t) => {\n+                    let bits = uint_ty_bits(t, cx.sess().target.usize_ty);\n+                    let actually = (val << (128 - bits)) >> (128 - bits);\n+                    (format!(\"{:?}\", t), actually.to_string())\n+                }\n+                _ => bug!(),\n+            };\n+            let mut err = cx.struct_span_lint(\n+                OVERFLOWING_LITERALS,\n+                expr.span,\n+                &format!(\"literal out of range for {}\", t),\n+            );\n+            err.note(&format!(\n+                \"the literal `{}` (decimal `{}`) does not fit into \\\n+                 an `{}` and will become `{}{}`\",\n+                repr_str, val, t, actually, t\n+            ));\n+            if let Some(sugg_ty) =\n+                get_type_suggestion(&cx.tables.node_id_to_type(expr.hir_id).sty, val, negative)\n+            {\n+                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+                    let (sans_suffix, _) = repr_str.split_at(pos);\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"consider using `{}` instead\", sugg_ty),\n+                        format!(\"{}{}\", sans_suffix, sugg_ty),\n+                    );\n+                } else {\n+                    err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n+                }\n+            }\n+\n+            err.emit();\n+        }\n     }\n }\n "}, {"sha": "6ab3172c4fefaaa1604dfdf0ec72ae75d5521fe9", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let mut fn_warned = false;\n         let mut op_warned = false;\n-        if cx.tcx.sess.features.borrow().fn_must_use {\n+        if cx.tcx.features().fn_must_use {\n             let maybe_def = match expr.node {\n                 hir::ExprCall(ref callee, _) => {\n                     match callee.node {"}, {"sha": "789ecd0f6136b1766436313795d9a85da1d8913c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -225,9 +225,6 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode((&metadata, self.sess))\n         });\n \n-        let exported_symbols = crate_root.exported_symbols\n-                                         .decode((&metadata, self.sess))\n-                                         .collect();\n         let trait_impls = crate_root\n             .impls\n             .decode((&metadata, self.sess))\n@@ -238,7 +235,6 @@ impl<'a> CrateLoader<'a> {\n             name,\n             extern_crate: Cell::new(None),\n             def_path_table: Lrc::new(def_path_table),\n-            exported_symbols,\n             trait_impls,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n                 self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)"}, {"sha": "2e95c23b4aed1f3a63b29a5bb0b19e4b79a63dc1", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -78,8 +78,6 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub def_path_table: Lrc<DefPathTable>,\n \n-    pub exported_symbols: FxHashSet<DefIndex>,\n-\n     pub trait_impls: FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>,\n \n     pub dep_kind: Cell<DepKind>,"}, {"sha": "0b50f5c44962b7dfdd766a5fd716bd3751a87527", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -18,6 +18,7 @@ use rustc::ty::maps::QueryConfig;\n use rustc::middle::cstore::{CrateStore, DepKind,\n                             MetadataLoader, LinkMeta,\n                             LoadedMacro, EncodedMetadata, NativeLibraryKind};\n+use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::middle::stability::DeprecationEntry;\n use rustc::hir::def;\n use rustc::session::{CrateDisambiguator, Session};\n@@ -27,10 +28,11 @@ use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::{DefKey, DefPath, DefPathHash};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::definitions::DefPathTable;\n-use rustc::util::nodemap::{NodeSet, DefIdMap};\n+use rustc::util::nodemap::DefIdMap;\n \n use std::any::Any;\n use rustc_data_structures::sync::Lrc;\n+use std::sync::Arc;\n \n use syntax::ast;\n use syntax::attr;\n@@ -160,9 +162,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n-    is_exported_symbol => {\n-        cdata.exported_symbols.contains(&def_id.index)\n-    }\n     item_body_nested_bodies => { cdata.item_body_nested_bodies(def_id.index) }\n     const_is_rvalue_promotable_to_static => {\n         cdata.const_is_rvalue_promotable_to_static(def_id.index)\n@@ -179,7 +178,21 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     extern_crate => { Lrc::new(cdata.extern_crate.get()) }\n     is_no_builtins => { cdata.is_no_builtins(tcx.sess) }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n-    exported_symbol_ids => { Lrc::new(cdata.get_exported_symbols()) }\n+    reachable_non_generics => {\n+        let reachable_non_generics = tcx\n+            .exported_symbols(cdata.cnum)\n+            .iter()\n+            .filter_map(|&(exported_symbol, _)| {\n+                if let ExportedSymbol::NonGeneric(def_id) = exported_symbol {\n+                    return Some(def_id)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect();\n+\n+        Lrc::new(reachable_non_generics)\n+    }\n     native_libraries => { Lrc::new(cdata.get_native_libraries(tcx.sess)) }\n     plugin_registrar_fn => {\n         cdata.root.plugin_registrar_fn.map(|index| {\n@@ -238,6 +251,19 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     has_copy_closures => { cdata.has_copy_closures(tcx.sess) }\n     has_clone_closures => { cdata.has_clone_closures(tcx.sess) }\n+\n+    exported_symbols => {\n+        let cnum = cdata.cnum;\n+        assert!(cnum != LOCAL_CRATE);\n+\n+        // If this crate is a custom derive crate, then we're not even going to\n+        // link those in so we skip those crates.\n+        if cdata.root.macro_derive_registrar.is_some() {\n+            return Arc::new(Vec::new())\n+        }\n+\n+        Arc::new(cdata.exported_symbols())\n+    }\n }\n \n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n@@ -520,11 +546,10 @@ impl CrateStore for cstore::CStore {\n \n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 reachable: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata\n     {\n-        encoder::encode_metadata(tcx, link_meta, reachable)\n+        encoder::encode_metadata(tcx, link_meta)\n     }\n \n     fn metadata_encoding_version(&self) -> &[u8]"}, {"sha": "60a0d4e03b54a549371cced1ed272efaef180e2b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -18,6 +18,7 @@ use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n use rustc::middle::cstore::{LinkagePreference, ExternConstBody,\n                             ExternBodyNestedBodies};\n+use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex,\n                          CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -27,7 +28,6 @@ use rustc::mir;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n-use rustc::util::nodemap::DefIdSet;\n use rustc::mir::Mir;\n \n use std::cell::Ref;\n@@ -1006,10 +1006,10 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn get_exported_symbols(&self) -> DefIdSet {\n-        self.exported_symbols\n-            .iter()\n-            .map(|&index| self.local_def_id(index))\n+    pub fn exported_symbols(&self) -> Vec<(ExportedSymbol, SymbolExportLevel)> {\n+        self.root\n+            .exported_symbols\n+            .decode(self)\n             .collect()\n     }\n "}, {"sha": "d19ab89459146401069d45c7488d7fa80697c983", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -20,14 +20,16 @@ use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::ich::Fingerprint;\n use rustc::middle::dependency_format::Linkage;\n+use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel,\n+                                      metadata_symbol_name};\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::traits::specialization_graph;\n-use rustc::ty::{self, Ty, TyCtxt, ReprOptions};\n+use rustc::ty::{self, Ty, TyCtxt, ReprOptions, SymbolName};\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n-use rustc::util::nodemap::{FxHashMap, NodeSet};\n+use rustc::util::nodemap::FxHashMap;\n \n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n@@ -53,7 +55,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Encoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     link_meta: &'a LinkMeta,\n-    exported_symbols: &'a NodeSet,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -395,9 +396,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // Encode exported symbols info.\n         i = self.position();\n+        let exported_symbols = self.tcx.exported_symbols(LOCAL_CRATE);\n         let exported_symbols = self.tracked(\n             IsolatedEncoder::encode_exported_symbols,\n-            self.exported_symbols);\n+            &exported_symbols);\n         let exported_symbols_bytes = self.position() - i;\n \n         // Encode and index the items.\n@@ -1388,9 +1390,25 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     // middle::reachable module but filters out items that either don't have a\n     // symbol associated with them (they weren't translated) or if they're an FFI\n     // definition (as that's not defined in this crate).\n-    fn encode_exported_symbols(&mut self, exported_symbols: &NodeSet) -> LazySeq<DefIndex> {\n-        let tcx = self.tcx;\n-        self.lazy_seq(exported_symbols.iter().map(|&id| tcx.hir.local_def_id(id).index))\n+    fn encode_exported_symbols(&mut self,\n+                               exported_symbols: &[(ExportedSymbol, SymbolExportLevel)])\n+                               -> LazySeq<(ExportedSymbol, SymbolExportLevel)> {\n+\n+        // The metadata symbol name is special. It should not show up in\n+        // downstream crates.\n+        let metadata_symbol_name = SymbolName::new(&metadata_symbol_name(self.tcx));\n+\n+        self.lazy_seq(exported_symbols\n+            .iter()\n+            .filter(|&&(ref exported_symbol, _)| {\n+                match *exported_symbol {\n+                    ExportedSymbol::NoDefId(symbol_name) => {\n+                        symbol_name != metadata_symbol_name\n+                    },\n+                    _ => true,\n+                }\n+            })\n+            .cloned())\n     }\n \n     fn encode_dylib_dependency_formats(&mut self, _: ()) -> LazySeq<Option<LinkagePreference>> {\n@@ -1663,8 +1681,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n // generated regardless of trailing bytes that end up in it.\n \n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 exported_symbols: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata\n {\n     let mut cursor = Cursor::new(vec![]);\n@@ -1678,7 +1695,6 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             opaque: opaque::Encoder::new(&mut cursor),\n             tcx,\n             link_meta,\n-            exported_symbols,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),"}, {"sha": "2504f8dc251f9e0d11db9fc81dc750a0646eaf63", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -146,15 +146,15 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n                 None => self.tcx.sess.err(msg),\n             }\n         }\n-        if lib.cfg.is_some() && !self.tcx.sess.features.borrow().link_cfg {\n+        if lib.cfg.is_some() && !self.tcx.features().link_cfg {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n                                            \"link_cfg\",\n                                            span.unwrap(),\n                                            GateIssue::Language,\n                                            \"is feature gated\");\n         }\n         if lib.kind == cstore::NativeStaticNobundle &&\n-           !self.tcx.sess.features.borrow().static_nobundle {\n+           !self.tcx.features().static_nobundle {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n                                            \"static_nobundle\",\n                                            span.unwrap(),"}, {"sha": "ce94e4f912f4f9e1012fd729ea967f222503163f", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -16,6 +16,7 @@ use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId, CrateNum};\n use rustc::ich::StableHashingContext;\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n+use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::session::CrateDisambiguator;\n@@ -202,7 +203,8 @@ pub struct CrateRoot {\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,\n-    pub exported_symbols: LazySeq<DefIndex>,\n+    pub exported_symbols: LazySeq<(ExportedSymbol, SymbolExportLevel)>,\n+\n     pub index: LazySeq<index::Index>,\n }\n "}, {"sha": "b77e7cf2ec8b5f1e597802e54cb39d3bb6ab613c", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 125, "deletions": 71, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::{self, RegionKind};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n \n-use super::{MirBorrowckCtxt, Context};\n+use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n use dataflow::{ActiveBorrows, BorrowData, FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n@@ -96,7 +96,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         } else {\n                             true\n                         }\n-                    },\n+                    }\n                     _ => true,\n                 };\n \n@@ -106,9 +106,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         None => \"value\".to_owned(),\n                     };\n \n-                    err.note(&format!(\"move occurs because {} has type `{}`, \\\n-                                       which does not implement the `Copy` trait\",\n-                                       note_msg, ty));\n+                    err.note(&format!(\n+                        \"move occurs because {} has type `{}`, \\\n+                         which does not implement the `Copy` trait\",\n+                        note_msg, ty\n+                    ));\n                 }\n             }\n \n@@ -154,7 +156,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             self.retrieve_borrow_span(borrow),\n-            &self.describe_place(&borrow.borrowed_place).unwrap_or(\"_\".to_owned()),\n+            &self.describe_place(&borrow.borrowed_place)\n+                .unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n \n@@ -175,8 +178,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         use rustc::hir::ExprClosure;\n         use rustc::mir::AggregateKind;\n \n-        let local = match self.mir[location.block].statements.get(location.statement_index) {\n-            Some(&Statement { kind: StatementKind::Assign(Place::Local(local), _), .. }) => local,\n+        let local = match self.mir[location.block]\n+            .statements\n+            .get(location.statement_index)\n+        {\n+            Some(&Statement {\n+                kind: StatementKind::Assign(Place::Local(local), _),\n+                ..\n+            }) => local,\n             _ => return None,\n         };\n \n@@ -202,8 +211,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             .with_freevars(node_id, |freevars| {\n                                 for (v, place) in freevars.iter().zip(places) {\n                                     match *place {\n-                                        Operand::Copy(Place::Local(l)) |\n-                                        Operand::Move(Place::Local(l)) if local == l =>\n+                                        Operand::Copy(Place::Local(l))\n+                                        | Operand::Move(Place::Local(l)) if local == l =>\n                                         {\n                                             debug!(\n                                                 \"find_closure_span: found captured local {:?}\",\n@@ -232,7 +241,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         (place, span): (&Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n-        issued_borrow: &BorrowData,\n+        issued_borrow: &BorrowData<'tcx>,\n         end_issued_loan_span: Option<Span>,\n     ) {\n         let issued_span = self.retrieve_borrow_span(issued_borrow);\n@@ -255,8 +264,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"immutable\",\n             \"mutable\",\n         ) {\n-            (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt) |\n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n+            (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt)\n+            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n                 .cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n@@ -355,25 +364,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrows: &ActiveBorrows<'cx, 'gcx, 'tcx>\n+        borrows: &ActiveBorrows<'cx, 'gcx, 'tcx>,\n     ) {\n         let end_span = borrows.opt_region_end_span(&borrow.region);\n         let scope_tree = borrows.0.scope_tree();\n-        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All).last().unwrap();\n+        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n+            .last()\n+            .unwrap();\n \n         let borrow_span = self.mir.source_info(borrow.location).span;\n         let proper_span = match *root_place {\n             Place::Local(local) => self.mir.local_decls[local].source_info.span,\n             _ => drop_span,\n         };\n \n-        if self.access_place_error_reported.contains(&(root_place.clone(), borrow_span)) {\n-            debug!(\"suppressing access_place error when borrow doesn't live long enough for {:?}\",\n-                   borrow_span);\n+        if self.access_place_error_reported\n+            .contains(&(root_place.clone(), borrow_span))\n+        {\n+            debug!(\n+                \"suppressing access_place error when borrow doesn't live long enough for {:?}\",\n+                borrow_span\n+            );\n             return;\n         }\n \n-        self.access_place_error_reported.insert((root_place.clone(), borrow_span));\n+        self.access_place_error_reported\n+            .insert((root_place.clone(), borrow_span));\n \n         match (borrow.region, &self.describe_place(&borrow.borrowed_place)) {\n             (RegionKind::ReScope(_), Some(name)) => {\n@@ -385,9 +401,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     drop_span,\n                     borrow_span,\n                     proper_span,\n-                    end_span\n+                    end_span,\n                 );\n-            },\n+            }\n             (RegionKind::ReScope(_), None) => {\n                 self.report_scoped_temporary_value_does_not_live_long_enough(\n                     context,\n@@ -396,14 +412,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     drop_span,\n                     borrow_span,\n                     proper_span,\n-                    end_span\n+                    end_span,\n                 );\n-            },\n-            (RegionKind::ReEarlyBound(_), Some(name)) |\n-            (RegionKind::ReFree(_), Some(name)) |\n-            (RegionKind::ReStatic, Some(name)) |\n-            (RegionKind::ReEmpty, Some(name)) |\n-            (RegionKind::ReVar(_), Some(name)) => {\n+            }\n+            (RegionKind::ReEarlyBound(_), Some(name))\n+            | (RegionKind::ReFree(_), Some(name))\n+            | (RegionKind::ReStatic, Some(name))\n+            | (RegionKind::ReEmpty, Some(name))\n+            | (RegionKind::ReVar(_), Some(name)) => {\n                 self.report_unscoped_local_value_does_not_live_long_enough(\n                     context,\n                     name,\n@@ -414,12 +430,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     proper_span,\n                     end_span,\n                 );\n-            },\n-            (RegionKind::ReEarlyBound(_), None) |\n-            (RegionKind::ReFree(_), None) |\n-            (RegionKind::ReStatic, None) |\n-            (RegionKind::ReEmpty, None) |\n-            (RegionKind::ReVar(_), None) => {\n+            }\n+            (RegionKind::ReEarlyBound(_), None)\n+            | (RegionKind::ReFree(_), None)\n+            | (RegionKind::ReStatic, None)\n+            | (RegionKind::ReEmpty, None)\n+            | (RegionKind::ReVar(_), None) => {\n                 self.report_unscoped_temporary_value_does_not_live_long_enough(\n                     context,\n                     &scope_tree,\n@@ -429,13 +445,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     proper_span,\n                     end_span,\n                 );\n-            },\n-            (RegionKind::ReLateBound(_, _), _) |\n-            (RegionKind::ReSkolemized(_, _), _) |\n-            (RegionKind::ReClosureBound(_), _) |\n-            (RegionKind::ReErased, _) => {\n+            }\n+            (RegionKind::ReLateBound(_, _), _)\n+            | (RegionKind::ReSkolemized(_, _), _)\n+            | (RegionKind::ReClosureBound(_), _)\n+            | (RegionKind::ReErased, _) => {\n                 span_bug!(drop_span, \"region does not make sense in this context\");\n-            },\n+            }\n         }\n     }\n \n@@ -450,11 +466,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         _proper_span: Span,\n         end_span: Option<Span>,\n     ) {\n-        let mut err = self.tcx.path_does_not_live_long_enough(borrow_span,\n-                                                              &format!(\"`{}`\", name),\n-                                                              Origin::Mir);\n+        let mut err = self.tcx.path_does_not_live_long_enough(\n+            borrow_span,\n+            &format!(\"`{}`\", name),\n+            Origin::Mir,\n+        );\n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n-        err.span_label(drop_span, format!(\"`{}` dropped here while still borrowed\", name));\n+        err.span_label(\n+            drop_span,\n+            format!(\"`{}` dropped here while still borrowed\", name),\n+        );\n         if let Some(end) = end_span {\n             err.span_label(end, \"borrowed value needs to live until here\");\n         }\n@@ -472,11 +493,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         proper_span: Span,\n         end_span: Option<Span>,\n     ) {\n-        let mut err = self.tcx.path_does_not_live_long_enough(proper_span,\n-                                                              \"borrowed value\",\n-                                                              Origin::Mir);\n+        let mut err =\n+            self.tcx\n+                .path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n-        err.span_label(drop_span, \"temporary value dropped here while still borrowed\");\n+        err.span_label(\n+            drop_span,\n+            \"temporary value dropped here while still borrowed\",\n+        );\n         err.note(\"consider using a `let` binding to increase its lifetime\");\n         if let Some(end) = end_span {\n             err.span_label(end, \"temporary value needs to live until here\");\n@@ -496,14 +520,31 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         _proper_span: Span,\n         _end_span: Option<Span>,\n     ) {\n-        let mut err = self.tcx.path_does_not_live_long_enough(borrow_span,\n-                                                              &format!(\"`{}`\", name),\n-                                                              Origin::Mir);\n+        debug!(\n+            \"report_unscoped_local_value_does_not_live_long_enough(\\\n+             {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n+             )\",\n+            context, name, scope_tree, borrow, drop_span, borrow_span\n+        );\n+\n+        let mut err = self.tcx.path_does_not_live_long_enough(\n+            borrow_span,\n+            &format!(\"`{}`\", name),\n+            Origin::Mir,\n+        );\n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n         err.span_label(drop_span, \"borrowed value only lives until here\");\n-        self.tcx.note_and_explain_region(scope_tree, &mut err,\n-                                         \"borrowed value must be valid for \",\n-                                         borrow.region, \"...\");\n+\n+        if !self.tcx.nll() {\n+            self.tcx.note_and_explain_region(\n+                scope_tree,\n+                &mut err,\n+                \"borrowed value must be valid for \",\n+                borrow.region,\n+                \"...\",\n+            );\n+        }\n+\n         self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n@@ -516,16 +557,31 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_span: Span,\n         _borrow_span: Span,\n         proper_span: Span,\n-        _end_span: Option<Span>\n+        _end_span: Option<Span>,\n     ) {\n-        let mut err = self.tcx.path_does_not_live_long_enough(proper_span,\n-                                                              \"borrowed value\",\n-                                                              Origin::Mir);\n+        debug!(\n+            \"report_unscoped_temporary_value_does_not_live_long_enough(\\\n+             {:?}, {:?}, {:?}, {:?}, {:?}\\\n+             )\",\n+            context, scope_tree, borrow, drop_span, proper_span\n+        );\n+\n+        let mut err =\n+            self.tcx\n+                .path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(drop_span, \"temporary value only lives until here\");\n-        self.tcx.note_and_explain_region(scope_tree, &mut err,\n-                                         \"borrowed value must be valid for \",\n-                                         borrow.region, \"...\");\n+\n+        if !self.tcx.nll() {\n+            self.tcx.note_and_explain_region(\n+                scope_tree,\n+                &mut err,\n+                \"borrowed value must be valid for \",\n+                borrow.region,\n+                \"...\",\n+            );\n+        }\n+\n         self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n@@ -534,7 +590,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         (place, span): (&Place<'tcx>, Span),\n-        loan: &BorrowData,\n+        loan: &BorrowData<'tcx>,\n     ) {\n         let mut err = self.tcx.cannot_assign_to_borrowed(\n             span,\n@@ -706,9 +762,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 ProjectionElem::Field(_, field_type) => {\n                     self.describe_field_from_ty(&field_type, field)\n                 }\n-                ProjectionElem::Index(..) |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Subslice { .. } => {\n+                ProjectionElem::Index(..)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {\n                     format!(\"{}\", self.describe_field(&proj.base, field))\n                 }\n             },\n@@ -765,13 +821,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Local(local) => {\n                 let local = &self.mir.local_decls[*local];\n                 Some(local.ty)\n-            },\n+            }\n             Place::Static(ref st) => Some(st.ty),\n-            Place::Projection(ref proj) => {\n-                match proj.elem {\n-                    ProjectionElem::Field(_, ty) => Some(ty),\n-                    _ => None,\n-                }\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(_, ty) => Some(ty),\n+                _ => None,\n             },\n         }\n     }"}, {"sha": "1ff0ffaaa68b398e7166b2a6c01b4cc632cfc71d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -72,7 +72,7 @@ fn mir_borrowck<'a, 'tcx>(\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n-    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.use_mir() {\n+    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.use_mir() {\n         return None;\n     }\n \n@@ -101,7 +101,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     // contain non-lexical lifetimes. It will have a lifetime tied\n     // to the inference context.\n     let mut mir: Mir<'tcx> = input_mir.clone();\n-    let free_regions = if !tcx.sess.nll() {\n+    let free_regions = if !tcx.nll() {\n         None\n     } else {\n         let mir = &mut mir;\n@@ -204,7 +204,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         );\n         (Some(Rc::new(regioncx)), opt_closure_req)\n     } else {\n-        assert!(!tcx.sess.nll());\n+        assert!(!tcx.nll());\n         (None, None)\n     };\n     let flow_inits = flow_inits; // remove mut\n@@ -719,7 +719,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// allowed to be split into separate Reservation and\n     /// Activation phases.\n     fn allow_two_phase_borrow(&self, kind: BorrowKind) -> bool {\n-        self.tcx.sess.two_phase_borrows() &&\n+        self.tcx.two_phase_borrows() &&\n             (kind.allows_two_phase_borrow() ||\n              self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n     }\n@@ -1253,7 +1253,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         span: Span,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n-        if !self.tcx.sess.two_phase_borrows() {\n+        if !self.tcx.two_phase_borrows() {\n             return;\n         }\n "}, {"sha": "19f95aeec70950f5170ddc13ed07ff7f6704a9ea", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -21,7 +21,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(in borrow_check) fn explain_why_borrow_contains_point(\n         &self,\n         context: Context,\n-        borrow: &BorrowData<'_>,\n+        borrow: &BorrowData<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n         if let Some(regioncx) = &self.nonlexical_regioncx {\n@@ -70,9 +70,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         }\n                     }\n \n-                    _ => {\n-                        cause.label_diagnostic(mir, err);\n+                    Cause::UniversalRegion(region_vid) => {\n+                        if let Some(region) = regioncx.to_error_region(region_vid) {\n+                            self.tcx.note_and_explain_free_region(\n+                                err,\n+                                \"borrowed value must be valid for \",\n+                                region,\n+                                \"...\",\n+                            );\n+                        }\n                     }\n+\n+                    _ => {}\n                 }\n             }\n         }"}, {"sha": "3ffb4370359bf81dad95334ea71787d363940854", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 18, "deletions": 109, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -26,7 +26,6 @@ use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n use rustc::util::common::ErrorReported;\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_errors::DiagnosticBuilder;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -435,7 +434,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         self.check_type_tests(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n \n-        self.check_universal_regions(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n+        self.check_universal_regions(infcx, mir_def_id, outlives_requirements.as_mut());\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n@@ -574,10 +573,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // an error that multiple bounds are required.\n                 tcx.sess.span_err(\n                     type_test.span,\n-                    &format!(\n-                        \"`{}` does not live long enough\",\n-                        type_test.generic_kind,\n-                    ),\n+                    &format!(\"`{}` does not live long enough\", type_test.generic_kind,),\n                 );\n             }\n         }\n@@ -589,13 +585,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// existentially bound, then we check its inferred value and try\n     /// to find a good name from that. Returns `None` if we can't find\n     /// one (e.g., this is just some random part of the CFG).\n-    fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n+    pub fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n         if self.universal_regions.is_universal_region(r) {\n             return self.definitions[r].external_name;\n         } else {\n             let inferred_values = self.inferred_values\n-                                      .as_ref()\n-                                      .expect(\"region values not yet inferred\");\n+                .as_ref()\n+                .expect(\"region values not yet inferred\");\n             let upper_bound = self.universal_upper_bound(r);\n             if inferred_values.contains(r, upper_bound) {\n                 self.to_error_region(upper_bound)\n@@ -807,9 +803,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         debug!(\n             \"eval_region_test(point={:?}, lower_bound={:?}, test={:?})\",\n-            point,\n-            lower_bound,\n-            test\n+            point, lower_bound, test\n         );\n \n         match test {\n@@ -841,9 +835,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         debug!(\n             \"eval_outlives({:?}: {:?} @ {:?})\",\n-            sup_region,\n-            sub_region,\n-            point\n+            sup_region, sub_region, point\n         );\n \n         // Roughly speaking, do a DFS of all region elements reachable\n@@ -897,7 +889,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_regions<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n@@ -913,7 +904,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for (fr, _) in universal_definitions {\n             self.check_universal_region(\n                 infcx,\n-                mir,\n                 mir_def_id,\n                 fr,\n                 &mut propagated_outlives_requirements,\n@@ -932,7 +922,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_region<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n@@ -951,8 +940,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             debug!(\n                 \"check_universal_region: fr={:?} does not outlive shorter_fr={:?}\",\n-                longer_fr,\n-                shorter_fr,\n+                longer_fr, shorter_fr,\n             );\n \n             let blame_span = self.blame_span(longer_fr, shorter_fr);\n@@ -990,7 +978,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Note: in this case, we use the unapproximated regions\n             // to report the error. This gives better error messages\n             // in some cases.\n-            self.report_error(infcx, mir, mir_def_id, longer_fr, shorter_fr, blame_span);\n+            self.report_error(infcx, mir_def_id, longer_fr, shorter_fr, blame_span);\n         }\n     }\n \n@@ -1005,7 +993,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn report_error(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n@@ -1039,12 +1026,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n         );\n \n-        // Find out why `fr` had to outlive `outlived_fr`...\n-        let inferred_values = self.inferred_values.as_ref().unwrap();\n-        if let Some(cause) = inferred_values.cause(fr, outlived_fr) {\n-            cause.label_diagnostic(mir, &mut diag);\n-        }\n-\n         diag.emit();\n     }\n \n@@ -1134,10 +1115,7 @@ impl fmt::Debug for Constraint {\n         write!(\n             formatter,\n             \"({:?}: {:?} @ {:?}) due to {:?}\",\n-            self.sup,\n-            self.sub,\n-            self.point,\n-            self.span\n+            self.sup, self.sub, self.point, self.span\n         )\n     }\n }\n@@ -1187,9 +1165,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n \n         debug!(\n             \"apply_requirements(location={:?}, closure_def_id={:?}, closure_substs={:?})\",\n-            location,\n-            closure_def_id,\n-            closure_substs\n+            location, closure_def_id, closure_substs\n         );\n \n         // Get Tu.\n@@ -1217,9 +1193,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n                         \"apply_requirements: region={:?} \\\n                          outlived_region={:?} \\\n                          outlives_requirement={:?}\",\n-                        region,\n-                        outlived_region,\n-                        outlives_requirement,\n+                        region, outlived_region, outlives_requirement,\n                     );\n                     infcx.sub_regions(origin, outlived_region, region);\n                 }\n@@ -1230,9 +1204,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n                         \"apply_requirements: ty={:?} \\\n                          outlived_region={:?} \\\n                          outlives_requirement={:?}\",\n-                        ty,\n-                        outlived_region,\n-                        outlives_requirement,\n+                        ty, outlived_region, outlives_requirement,\n                     );\n                     infcx.register_region_obligation(\n                         body_id,\n@@ -1285,77 +1257,14 @@ impl CauseExt for Rc<Cause> {\n }\n \n impl Cause {\n-    pub(crate) fn label_diagnostic(&self, mir: &Mir<'_>, diag: &mut DiagnosticBuilder<'_>) {\n-        // The cause information is pretty messy. Only dump it as an\n-        // internal debugging aid if -Znll-dump-cause is given.\n-        let nll_dump_cause = ty::tls::with(|tcx| tcx.sess.nll_dump_cause());\n-        if !nll_dump_cause {\n-            return;\n-        }\n-\n-        let mut string = String::new();\n-        self.push_diagnostic_string(mir, &mut string);\n-        diag.note(&string);\n-    }\n-\n-    fn push_diagnostic_string(&self, mir: &Mir<'_>, string: &mut String) {\n-        match self {\n-            Cause::LiveVar(local, location) => {\n-                string.push_str(&format!(\"because `{:?}` is live at {:?}\", local, location));\n-            }\n-\n-            Cause::DropVar(local, location) => {\n-                string.push_str(&format!(\n-                    \"because `{:?}` is dropped at {:?}\",\n-                    local,\n-                    location\n-                ));\n-            }\n-\n-            Cause::LiveOther(location) => {\n-                string.push_str(&format!(\n-                    \"because of a general liveness constraint at {:?}\",\n-                    location\n-                ));\n-            }\n-\n-            Cause::UniversalRegion(region_vid) => {\n-                string.push_str(&format!(\n-                    \"because `{:?}` is universally quantified\",\n-                    region_vid\n-                ));\n-            }\n-\n-            Cause::Outlives {\n-                original_cause,\n-                constraint_location,\n-                constraint_span: _,\n-            } => {\n-                string.push_str(&format!(\n-                    \"because of an outlives relation created at `{:?}`\\n\",\n-                    constraint_location\n-                ));\n-\n-                original_cause.push_diagnostic_string(mir, string);\n-            }\n-        }\n-    }\n-\n     pub(crate) fn root_cause(&self) -> &Cause {\n         match self {\n-            Cause::LiveVar(..) |\n-            Cause::DropVar(..) |\n-            Cause::LiveOther(..) |\n-            Cause::UniversalRegion(..) => {\n-                self\n-            }\n+            Cause::LiveVar(..)\n+            | Cause::DropVar(..)\n+            | Cause::LiveOther(..)\n+            | Cause::UniversalRegion(..) => self,\n \n-            Cause::Outlives {\n-                original_cause,\n-                ..\n-            } => {\n-                original_cause.root_cause()\n-            }\n+            Cause::Outlives { original_cause, .. } => original_cause.root_cause(),\n         }\n     }\n }"}, {"sha": "3af10c5c25169e8205c0f72fa1fd1bb8efec5285", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1587,7 +1587,7 @@ impl MirPass for TypeckMir {\n \n         // When NLL is enabled, the borrow checker runs the typeck\n         // itself, so we don't need this MIR pass anymore.\n-        if tcx.sess.nll() {\n+        if tcx.nll() {\n             return;\n         }\n "}, {"sha": "1ed8289d4418469544d5cd7400a6b718584516c6", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> CFG<'tcx> {\n                                              block: BasicBlock,\n                                              source_info: SourceInfo,\n                                              region_scope: region::Scope) {\n-        if tcx.sess.emit_end_regions() {\n+        if tcx.emit_end_regions() {\n             if let region::ScopeData::CallSite(_) = region_scope.data() {\n                 // The CallSite scope (aka the root scope) is sort of weird, in that it is\n                 // supposed to \"separate\" the \"interior\" and \"exterior\" of a closure. Being"}, {"sha": "abea55835466f60434e538f0b2189867afb2c356", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n                 let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n                     i == variant_index || {\n-                        self.hir.tcx().sess.features.borrow().never_type &&\n+                        self.hir.tcx().features().never_type &&\n                         self.hir.tcx().is_variant_uninhabited_from_all_modules(v, substs)\n                     }\n                 });"}, {"sha": "10c2f9f758f14a07eb376222ad2a4c17a918d1ab", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -736,7 +736,7 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n         }\n         Some(_) => true,\n         None => {\n-            if tcx.is_exported_symbol(def_id) ||\n+            if tcx.is_reachable_non_generic(def_id) ||\n                 tcx.is_foreign_item(def_id)\n             {\n                 // We can link to the item in question, no instance needed\n@@ -984,7 +984,7 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n             }\n             MonoItemCollectionMode::Lazy => {\n                 self.entry_fn == Some(def_id) ||\n-                self.tcx.is_exported_symbol(def_id) ||\n+                self.tcx.is_reachable_non_generic(def_id) ||\n                 attr::contains_name(&self.tcx.get_attrs(def_id),\n                                     \"rustc_std_internal_symbol\")\n             }"}, {"sha": "d65c1e03298a1cee8041f795bb08d3ebaf190215", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -363,7 +363,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     can_be_internalized = false;\n                                     Visibility::Hidden\n                                 } else if def_id.is_local() {\n-                                    if tcx.is_exported_symbol(def_id) {\n+                                    if tcx.is_reachable_non_generic(def_id) {\n                                         can_be_internalized = false;\n                                         default_visibility(def_id)\n                                     } else {\n@@ -385,7 +385,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         (Linkage::External, visibility)\n                     }\n                     MonoItem::Static(def_id) => {\n-                        let visibility = if tcx.is_exported_symbol(def_id) {\n+                        let visibility = if tcx.is_reachable_non_generic(def_id) {\n                             can_be_internalized = false;\n                             default_visibility(def_id)\n                         } else {\n@@ -395,7 +395,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     }\n                     MonoItem::GlobalAsm(node_id) => {\n                         let def_id = tcx.hir.local_def_id(node_id);\n-                        let visibility = if tcx.is_exported_symbol(def_id) {\n+                        let visibility = if tcx.is_reachable_non_generic(def_id) {\n                             can_be_internalized = false;\n                             default_visibility(def_id)\n                         } else {"}, {"sha": "6e8985d99d287b83b14b6d32ddd44ea061445145", "filename": "src/librustc_mir/transform/clean_end_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -42,7 +42,7 @@ impl MirPass for CleanEndRegions {\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        if !tcx.sess.emit_end_regions() { return; }\n+        if !tcx.emit_end_regions() { return; }\n \n         let mut gather = GatherBorrowedRegions {\n             seen_regions: FxHashSet()"}, {"sha": "83cd7bf549d5536904e82bdc31cd01c16dcc3a53", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -77,19 +77,12 @@ impl Lower128Bit {\n                 };\n \n                 let bin_statement = block.statements.pop().unwrap();\n-                let (source_info, place, lhs, mut rhs) = match bin_statement {\n-                    Statement {\n-                        source_info,\n-                        kind: StatementKind::Assign(\n-                            place,\n-                            Rvalue::BinaryOp(_, lhs, rhs))\n-                    } => (source_info, place, lhs, rhs),\n-                    Statement {\n-                        source_info,\n-                        kind: StatementKind::Assign(\n-                            place,\n-                            Rvalue::CheckedBinaryOp(_, lhs, rhs))\n-                    } => (source_info, place, lhs, rhs),\n+                let source_info = bin_statement.source_info;\n+                let (place, lhs, mut rhs) = match bin_statement.kind {\n+                    StatementKind::Assign(place, Rvalue::BinaryOp(_, lhs, rhs))\n+                    | StatementKind::Assign(place, Rvalue::CheckedBinaryOp(_, lhs, rhs)) => {\n+                        (place, lhs, rhs)\n+                    }\n                     _ => bug!(\"Statement doesn't match pattern any more?\"),\n                 };\n "}, {"sha": "8f5831270d6e5afa94af754ef71f2f7e24914c61", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -936,7 +936,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                     if self.mode != Mode::Fn &&\n \n                         // feature-gate is not enabled,\n-                        !self.tcx.sess.features.borrow()\n+                        !self.tcx.features()\n                             .declared_lib_features\n                             .iter()\n                             .any(|&(ref sym, _)| sym == feature_name) &&"}, {"sha": "89242ca32bcbfa1586ddb2541e3c13b9d8bc5fce", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -514,7 +514,7 @@ impl<'b, 'gcx, 'tcx> BorrowckErrors for TyCtxt<'b, 'gcx, 'tcx> {\n                                 o: Origin)\n                                 -> DiagnosticBuilder<'a>\n     {\n-        if !o.should_emit_errors(self.sess.borrowck_mode()) {\n+        if !o.should_emit_errors(self.borrowck_mode()) {\n             self.sess.diagnostic().cancel(&mut diag);\n         }\n         diag"}, {"sha": "bf59165a9c4614f010e9ca359f3c9bc59d7dc079", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -52,7 +52,7 @@ pub fn load_plugins(sess: &Session,\n     // do not report any error now. since crate attributes are\n     // not touched by expansion, every use of plugin without\n     // the feature enabled will result in an error later...\n-    if sess.features.borrow().plugin {\n+    if sess.features_untracked().plugin {\n         for attr in &krate.attrs {\n             if !attr.check_name(\"plugin\") {\n                 continue;"}, {"sha": "bf7b81c4d0e420938ad8ca08a906ec9c02330366", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -590,7 +590,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n-                                               &self.session.features,\n+                                               &self.session.features_untracked(),\n                                                &macro_def));\n         self.macro_map.insert(def_id, ext.clone());\n         ext"}, {"sha": "fc1ff248184033dc11d7410375bac313a23c488d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1524,7 +1524,7 @@ impl<'a> Resolver<'a> {\n         invocations.insert(Mark::root(),\n                            arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n-        let features = session.features.borrow();\n+        let features = session.features_untracked();\n \n         let mut macro_defs = FxHashMap();\n         macro_defs.insert(Mark::root(), root_def_id);\n@@ -2998,7 +2998,7 @@ impl<'a> Resolver<'a> {\n                 let prim = self.primitive_type_table.primitive_types[&path[0].node.name];\n                 match prim {\n                     TyUint(UintTy::U128) | TyInt(IntTy::I128) => {\n-                        if !self.session.features.borrow().i128_type {\n+                        if !self.session.features_untracked().i128_type {\n                             emit_feature_err(&self.session.parse_sess,\n                                                 \"i128_type\", span, GateIssue::Language,\n                                                 \"128-bit type is unstable\");\n@@ -3089,7 +3089,7 @@ impl<'a> Resolver<'a> {\n                     let prev_name = path[0].node.name;\n                     if prev_name == keywords::Extern.name() ||\n                        prev_name == keywords::CrateRoot.name() &&\n-                       self.session.features.borrow().extern_absolute_paths {\n+                       self.session.features_untracked().extern_absolute_paths {\n                         // `::extern_crate::a::b`\n                         let crate_id = self.crate_loader.resolve_crate_from_path(name, ident.span);\n                         let crate_root ="}, {"sha": "95fa0f3b52fef6b181523c81edef431f6c634e26", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -744,7 +744,7 @@ impl<'a> Resolver<'a> {\n \n         let def_id = self.definitions.local_def_id(item.id);\n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n-                                               &self.session.features,\n+                                               &self.session.features_untracked(),\n                                                item));\n         self.macro_map.insert(def_id, ext);\n \n@@ -838,7 +838,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn gate_legacy_custom_derive(&mut self, name: Symbol, span: Span) {\n-        if !self.session.features.borrow().custom_derive {\n+        if !self.session.features_untracked().custom_derive {\n             let sess = &self.session.parse_sess;\n             let explain = feature_gate::EXPLAIN_CUSTOM_DERIVE;\n             emit_feature_err(sess, \"custom_derive\", span, GateIssue::Language, explain);"}, {"sha": "01c1ded94578ecc1fa45da7521930f70595598e7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -609,7 +609,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if module_path.len() == 1 && (module_path[0].node.name == keywords::CrateRoot.name() ||\n                                       module_path[0].node.name == keywords::Extern.name()) {\n             let is_extern = module_path[0].node.name == keywords::Extern.name() ||\n-                            self.session.features.borrow().extern_absolute_paths;\n+                            self.session.features_untracked().extern_absolute_paths;\n             match directive.subclass {\n                 GlobImport { .. } if is_extern => {\n                     return Some((directive.span,"}, {"sha": "3fe667f154372df68eed2eb96efbfdb562b02313", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -768,9 +768,9 @@ fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n     let mut symbols = Vec::new();\n \n     let export_threshold = symbol_export::crates_export_threshold(&[crate_type]);\n-    for &(ref name, _, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n+    for &(symbol, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n         if level.is_below_threshold(export_threshold) {\n-            symbols.push(name.clone());\n+            symbols.push(symbol.symbol_name(tcx).to_string());\n         }\n     }\n \n@@ -782,9 +782,9 @@ fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n         // For each dependency that we are linking to statically ...\n         if *dep_format == Linkage::Static {\n             // ... we add its symbol list to our export list.\n-            for &(ref name, _, level) in tcx.exported_symbols(cnum).iter() {\n+            for &(symbol, level) in tcx.exported_symbols(cnum).iter() {\n                 if level.is_below_threshold(export_threshold) {\n-                    symbols.push(name.clone());\n+                    symbols.push(symbol.symbol_name(tcx).to_string());\n                 }\n             }\n         }"}, {"sha": "f79651cef3ec8a58343537ed9390feadf20ce115", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -113,7 +113,7 @@ pub(crate) fn run(cgcx: &CodegenContext,\n         Lto::No => panic!(\"didn't request LTO but we're doing LTO\"),\n     };\n \n-    let symbol_filter = &|&(ref name, _, level): &(String, _, SymbolExportLevel)| {\n+    let symbol_filter = &|&(ref name, level): &(String, SymbolExportLevel)| {\n         if level.is_below_threshold(export_threshold) {\n             let mut bytes = Vec::with_capacity(name.len() + 1);\n             bytes.extend(name.bytes());"}, {"sha": "739ae768ca29ca3b9de94e131c9c47fa99f21b63", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 186, "deletions": 129, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -11,33 +11,27 @@\n use rustc_data_structures::sync::Lrc;\n use std::sync::Arc;\n \n-use base;\n use monomorphize::Instance;\n+use rustc::hir;\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::middle::exported_symbols::SymbolExportLevel;\n+use rustc::middle::exported_symbols::{SymbolExportLevel, ExportedSymbol, metadata_symbol_name};\n use rustc::session::config;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{TyCtxt, SymbolName};\n use rustc::ty::maps::Providers;\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashMap, DefIdSet};\n use rustc_allocator::ALLOCATOR_METHODS;\n use syntax::attr;\n \n pub type ExportedSymbols = FxHashMap<\n     CrateNum,\n-    Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n+    Arc<Vec<(String, SymbolExportLevel)>>,\n >;\n \n pub fn threshold(tcx: TyCtxt) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types.borrow())\n }\n \n-pub fn metadata_symbol_name(tcx: TyCtxt) -> String {\n-    format!(\"rust_metadata_{}_{}\",\n-            tcx.crate_name(LOCAL_CRATE),\n-            tcx.crate_disambiguator(LOCAL_CRATE).to_fingerprint().to_hex())\n-}\n-\n fn crate_export_threshold(crate_type: config::CrateType) -> SymbolExportLevel {\n     match crate_type {\n         config::CrateTypeExecutable |\n@@ -60,140 +54,203 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType])\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n-    providers.exported_symbol_ids = |tcx, cnum| {\n-        let export_threshold = threshold(tcx);\n-        Lrc::new(tcx.exported_symbols(cnum)\n-            .iter()\n-            .filter_map(|&(_, id, level)| {\n-                id.and_then(|id| {\n-                    if level.is_below_threshold(export_threshold) {\n-                        Some(id)\n+fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                             cnum: CrateNum)\n+                                             -> Lrc<DefIdSet>\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+\n+    if !tcx.sess.opts.output_types.should_trans() {\n+        return Lrc::new(DefIdSet())\n+    }\n+\n+    let export_threshold = threshold(tcx);\n+\n+    // We already collect all potentially reachable non-generic items for\n+    // `exported_symbols`. Now we just filter them down to what is actually\n+    // exported for the given crate we are compiling.\n+    let reachable_non_generics = tcx\n+        .exported_symbols(LOCAL_CRATE)\n+        .iter()\n+        .filter_map(|&(exported_symbol, level)| {\n+            if let ExportedSymbol::NonGeneric(def_id) = exported_symbol {\n+                if level.is_below_threshold(export_threshold) {\n+                    return Some(def_id)\n+                }\n+            }\n+\n+            None\n+        })\n+        .collect();\n+\n+    Lrc::new(reachable_non_generics)\n+}\n+\n+fn is_reachable_non_generic_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               def_id: DefId)\n+                                               -> bool {\n+    tcx.reachable_non_generics(def_id.krate).contains(&def_id)\n+}\n+\n+fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                             cnum: CrateNum)\n+                                             -> Arc<Vec<(ExportedSymbol,\n+                                                         SymbolExportLevel)>>\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+\n+    if !tcx.sess.opts.output_types.should_trans() {\n+        return Arc::new(vec![])\n+    }\n+\n+    // Check to see if this crate is a \"special runtime crate\". These\n+    // crates, implementation details of the standard library, typically\n+    // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n+    // ABI between them. We don't want their symbols to have a `C`\n+    // export level, however, as they're just implementation details.\n+    // Down below we'll hardwire all of the symbols to the `Rust` export\n+    // level instead.\n+    let special_runtime_crate = tcx.is_panic_runtime(LOCAL_CRATE) ||\n+        tcx.is_compiler_builtins(LOCAL_CRATE);\n+\n+    let reachable_non_generics: DefIdSet = tcx.reachable_set(LOCAL_CRATE).0\n+        .iter()\n+        .filter_map(|&node_id| {\n+            // We want to ignore some FFI functions that are not exposed from\n+            // this crate. Reachable FFI functions can be lumped into two\n+            // categories:\n+            //\n+            // 1. Those that are included statically via a static library\n+            // 2. Those included otherwise (e.g. dynamically or via a framework)\n+            //\n+            // Although our LLVM module is not literally emitting code for the\n+            // statically included symbols, it's an export of our library which\n+            // needs to be passed on to the linker and encoded in the metadata.\n+            //\n+            // As a result, if this id is an FFI item (foreign item) then we only\n+            // let it through if it's included statically.\n+            match tcx.hir.get(node_id) {\n+                hir::map::NodeForeignItem(..) => {\n+                    let def_id = tcx.hir.local_def_id(node_id);\n+                    if tcx.is_statically_included_foreign_item(def_id) {\n+                        Some(def_id)\n                     } else {\n                         None\n                     }\n-                })\n-            })\n-            .collect())\n-    };\n-\n-    providers.is_exported_symbol = |tcx, id| {\n-        tcx.exported_symbol_ids(id.krate).contains(&id)\n-    };\n-\n-    providers.exported_symbols = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        let local_exported_symbols = base::find_exported_symbols(tcx);\n-\n-        let mut local_crate: Vec<_> = local_exported_symbols\n-            .iter()\n-            .map(|&node_id| {\n-                tcx.hir.local_def_id(node_id)\n-            })\n-            .map(|def_id| {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                let export_level = export_level(tcx, def_id);\n-                debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), Some(def_id), export_level)\n-            })\n-            .collect();\n-\n-        if let Some(_) = *tcx.sess.entry_fn.borrow() {\n-            local_crate.push((\"main\".to_string(),\n-                              None,\n-                              SymbolExportLevel::C));\n-        }\n+                }\n+\n+                // Only consider nodes that actually have exported symbols.\n+                hir::map::NodeItem(&hir::Item {\n+                    node: hir::ItemStatic(..),\n+                    ..\n+                }) |\n+                hir::map::NodeItem(&hir::Item {\n+                    node: hir::ItemFn(..), ..\n+                }) |\n+                hir::map::NodeImplItem(&hir::ImplItem {\n+                    node: hir::ImplItemKind::Method(..),\n+                    ..\n+                }) => {\n+                    let def_id = tcx.hir.local_def_id(node_id);\n+                    let generics = tcx.generics_of(def_id);\n+                    if (generics.parent_types == 0 && generics.types.is_empty()) &&\n+                        // Functions marked with #[inline] are only ever translated\n+                        // with \"internal\" linkage and are never exported.\n+                        !Instance::mono(tcx, def_id).def.requires_local(tcx) {\n+                        Some(def_id)\n+                    } else {\n+                        None\n+                    }\n+                }\n \n-        if tcx.sess.allocator_kind.get().is_some() {\n-            for method in ALLOCATOR_METHODS {\n-                local_crate.push((format!(\"__rust_{}\", method.name),\n-                                  None,\n-                                  SymbolExportLevel::Rust));\n+                _ => None\n             }\n-        }\n+        })\n+        .collect();\n \n-        if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n-            let def_id = tcx.hir.local_def_id(id);\n-            let disambiguator = tcx.sess.local_crate_disambiguator();\n-            let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator);\n-            local_crate.push((registrar, Some(def_id), SymbolExportLevel::C));\n-        }\n+    let mut symbols: Vec<_> = reachable_non_generics\n+        .iter()\n+        .map(|&def_id| {\n+            let export_level = if special_runtime_crate {\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+                // We can probably do better here by just ensuring that\n+                // it has hidden visibility rather than public\n+                // visibility, as this is primarily here to ensure it's\n+                // not stripped during LTO.\n+                //\n+                // In general though we won't link right if these\n+                // symbols are stripped, and LTO currently strips them.\n+                if &*name == \"rust_eh_personality\" ||\n+                   &*name == \"rust_eh_register_frames\" ||\n+                   &*name == \"rust_eh_unregister_frames\" {\n+                    SymbolExportLevel::C\n+                } else {\n+                    SymbolExportLevel::Rust\n+                }\n+            } else {\n+                tcx.symbol_export_level(def_id)\n+            };\n+            debug!(\"EXPORTED SYMBOL (local): {} ({:?})\",\n+                   tcx.symbol_name(Instance::mono(tcx, def_id)),\n+                   export_level);\n+            (ExportedSymbol::NonGeneric(def_id), export_level)\n+        })\n+        .collect();\n+\n+    if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n+        let def_id = tcx.hir.local_def_id(id);\n+        symbols.push((ExportedSymbol::NonGeneric(def_id), SymbolExportLevel::C));\n+    }\n+\n+    if let Some(id) = tcx.sess.plugin_registrar_fn.get() {\n+        let def_id = tcx.hir.local_def_id(id);\n+        symbols.push((ExportedSymbol::NonGeneric(def_id), SymbolExportLevel::C));\n+    }\n+\n+    if let Some(_) = *tcx.sess.entry_fn.borrow() {\n+        let symbol_name = \"main\".to_string();\n+        let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n+\n+        symbols.push((exported_symbol, SymbolExportLevel::C));\n+    }\n+\n+    if tcx.sess.allocator_kind.get().is_some() {\n+        for method in ALLOCATOR_METHODS {\n+            let symbol_name = format!(\"__rust_{}\", method.name);\n+            let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n \n-        if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n-            local_crate.push((metadata_symbol_name(tcx),\n-                              None,\n-                              SymbolExportLevel::Rust));\n+            symbols.push((exported_symbol, SymbolExportLevel::Rust));\n         }\n+    }\n+\n+    if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n+        let symbol_name = metadata_symbol_name(tcx);\n+        let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n \n-        // Sort so we get a stable incr. comp. hash.\n-        local_crate.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n-            name1.cmp(name2)\n-        });\n+        symbols.push((exported_symbol, SymbolExportLevel::Rust));\n+    }\n \n-        Arc::new(local_crate)\n-    };\n+    // Sort so we get a stable incr. comp. hash.\n+    symbols.sort_unstable_by(|&(ref symbol1, ..), &(ref symbol2, ..)| {\n+        symbol1.compare_stable(tcx, symbol2)\n+    });\n \n-    providers.symbol_export_level = export_level;\n+    Arc::new(symbols)\n }\n \n-pub fn provide_extern(providers: &mut Providers) {\n-    providers.exported_symbols = |tcx, cnum| {\n-        // If this crate is a plugin and/or a custom derive crate, then\n-        // we're not even going to link those in so we skip those crates.\n-        if tcx.plugin_registrar_fn(cnum).is_some() ||\n-           tcx.derive_registrar_fn(cnum).is_some() {\n-            return Arc::new(Vec::new())\n-        }\n+pub fn provide(providers: &mut Providers) {\n+    providers.reachable_non_generics = reachable_non_generics_provider;\n+    providers.is_reachable_non_generic = is_reachable_non_generic_provider;\n+    providers.exported_symbols = exported_symbols_provider_local;\n+    providers.symbol_export_level = symbol_export_level_provider;\n+}\n \n-        // Check to see if this crate is a \"special runtime crate\". These\n-        // crates, implementation details of the standard library, typically\n-        // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n-        // ABI between them. We don't want their symbols to have a `C`\n-        // export level, however, as they're just implementation details.\n-        // Down below we'll hardwire all of the symbols to the `Rust` export\n-        // level instead.\n-        let special_runtime_crate =\n-            tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n-\n-        let mut crate_exports: Vec<_> = tcx\n-            .exported_symbol_ids(cnum)\n-            .iter()\n-            .map(|&def_id| {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                let export_level = if special_runtime_crate {\n-                    // We can probably do better here by just ensuring that\n-                    // it has hidden visibility rather than public\n-                    // visibility, as this is primarily here to ensure it's\n-                    // not stripped during LTO.\n-                    //\n-                    // In general though we won't link right if these\n-                    // symbols are stripped, and LTO currently strips them.\n-                    if &*name == \"rust_eh_personality\" ||\n-                       &*name == \"rust_eh_register_frames\" ||\n-                       &*name == \"rust_eh_unregister_frames\" {\n-                        SymbolExportLevel::C\n-                    } else {\n-                        SymbolExportLevel::Rust\n-                    }\n-                } else {\n-                    export_level(tcx, def_id)\n-                };\n-                debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), Some(def_id), export_level)\n-            })\n-            .collect();\n-\n-        // Sort so we get a stable incr. comp. hash.\n-        crate_exports.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n-            name1.cmp(name2)\n-        });\n-\n-        Arc::new(crate_exports)\n-    };\n-    providers.symbol_export_level = export_level;\n+pub fn provide_extern(providers: &mut Providers) {\n+    providers.is_reachable_non_generic = is_reachable_non_generic_provider;\n+    providers.symbol_export_level = symbol_export_level_provider;\n }\n \n-fn export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n+fn symbol_export_level_provider(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n     // We export anything that's not mangled at the \"C\" layer as it probably has\n     // to do with ABI concerns. We do not, however, apply such treatment to\n     // special symbols in the standard library for various plumbing between"}, {"sha": "c0561ff0c17316e0e411d9d26daf1c2eb247ae4c", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1332,20 +1332,31 @@ fn start_executing_work(tcx: TyCtxt,\n     let coordinator_send = tcx.tx_to_llvm_workers.clone();\n     let sess = tcx.sess;\n \n-    let exported_symbols = match sess.lto() {\n-        Lto::No => None,\n-        Lto::ThinLocal => {\n-            let mut exported_symbols = FxHashMap();\n-            exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n-            Some(Arc::new(exported_symbols))\n-        }\n-        Lto::Yes | Lto::Fat | Lto::Thin => {\n-            let mut exported_symbols = FxHashMap();\n-            exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n-            for &cnum in tcx.crates().iter() {\n-                exported_symbols.insert(cnum, tcx.exported_symbols(cnum));\n+    // Compute the set of symbols we need to retain when doing LTO (if we need to)\n+    let exported_symbols = {\n+        let mut exported_symbols = FxHashMap();\n+\n+        let copy_symbols = |cnum| {\n+            let symbols = tcx.exported_symbols(cnum)\n+                             .iter()\n+                             .map(|&(s, lvl)| (s.symbol_name(tcx).to_string(), lvl))\n+                             .collect();\n+            Arc::new(symbols)\n+        };\n+\n+        match sess.lto() {\n+            Lto::No => None,\n+            Lto::ThinLocal => {\n+                exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n+                Some(Arc::new(exported_symbols))\n+            }\n+            Lto::Yes | Lto::Fat | Lto::Thin => {\n+                exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n+                for &cnum in tcx.crates().iter() {\n+                    exported_symbols.insert(cnum, copy_symbols(cnum));\n+                }\n+                Some(Arc::new(exported_symbols))\n             }\n-            Some(Arc::new(exported_symbols))\n         }\n     };\n "}, {"sha": "beb7a091bdcfe29ddd1d4254c4fc65fddf398df4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -30,7 +30,6 @@ use super::ModuleKind;\n \n use abi;\n use back::link;\n-use back::symbol_export;\n use back::write::{self, OngoingCrateTranslation, create_target_machine};\n use llvm::{ContextRef, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n@@ -45,6 +44,7 @@ use rustc::ty::maps::Providers;\n use rustc::dep_graph::{DepNode, DepConstructor};\n use rustc::ty::subst::Kind;\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n+use rustc::middle::exported_symbols;\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n@@ -70,7 +70,7 @@ use time_graph;\n use trans_item::{MonoItem, BaseMonoItemExt, MonoItemExt, DefPathBasedNames};\n use type_::Type;\n use type_of::LayoutLlvmExt;\n-use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n use std::any::Any;\n@@ -89,7 +89,7 @@ use syntax::ast;\n \n use mir::operand::OperandValue;\n \n-pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n+pub use rustc_trans_utils::check_for_rustc_errors_attr;\n pub use rustc_mir::monomorphize::item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n@@ -606,8 +606,7 @@ fn contains_null(s: &str) -> bool {\n \n fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                             llmod_id: &str,\n-                            link_meta: &LinkMeta,\n-                            exported_symbols: &NodeSet)\n+                            link_meta: &LinkMeta)\n                             -> (ContextRef, ModuleRef, EncodedMetadata) {\n     use std::io::Write;\n     use flate2::Compression;\n@@ -643,7 +642,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                 EncodedMetadata::new());\n     }\n \n-    let metadata = tcx.encode_metadata(link_meta, exported_symbols);\n+    let metadata = tcx.encode_metadata(link_meta);\n     if kind == MetadataKind::Uncompressed {\n         return (metadata_llcx, metadata_llmod, metadata);\n     }\n@@ -655,7 +654,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n \n     let llmeta = C_bytes_in_context(metadata_llcx, &compressed);\n     let llconst = C_struct_in_context(metadata_llcx, &[llmeta], false);\n-    let name = symbol_export::metadata_symbol_name(tcx);\n+    let name = exported_symbols::metadata_symbol_name(tcx);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n         llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst).to_ref(), buf.as_ptr())\n@@ -718,13 +717,12 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let link_meta = link::build_link_meta(crate_hash);\n-    let exported_symbol_node_ids = find_exported_symbols(tcx);\n \n     // Translate the metadata.\n     let llmod_id = \"metadata\";\n     let (metadata_llcx, metadata_llmod, metadata) =\n         time(tcx.sess.time_passes(), \"write metadata\", || {\n-            write_metadata(tcx, llmod_id, &link_meta, &exported_symbol_node_ids)\n+            write_metadata(tcx, llmod_id, &link_meta)\n         });\n \n     let metadata_module = ModuleTranslation {"}, {"sha": "54cc561e8041505065d1eae557cacb52072dec58", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -151,7 +151,7 @@ pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n             if cx.tcx.is_translated_item(instance_def_id) {\n                 if instance_def_id.is_local() {\n-                    if !cx.tcx.is_exported_symbol(instance_def_id) {\n+                    if !cx.tcx.is_reachable_non_generic(instance_def_id) {\n                         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n                     }\n                 } else {"}, {"sha": "fd9cb8c5a6bed38ff33bf598ca72b64ce75cd0f0", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -134,7 +134,7 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n \n                 let g = declare::define_global(cx, &sym[..], llty).unwrap();\n \n-                if !cx.tcx.is_exported_symbol(def_id) {\n+                if !cx.tcx.is_reachable_non_generic(def_id) {\n                     unsafe {\n                         llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n                     }"}, {"sha": "b93e8c2ad21ca60e9bee59b4ff60b7cbf69189ee", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -597,6 +597,12 @@ fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     ifn!(\"llvm.bswap.i64\", fn(t_i64) -> t_i64);\n     ifn!(\"llvm.bswap.i128\", fn(t_i128) -> t_i128);\n \n+    ifn!(\"llvm.bitreverse.i8\", fn(t_i8) -> t_i8);\n+    ifn!(\"llvm.bitreverse.i16\", fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.bitreverse.i32\", fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.bitreverse.i64\", fn(t_i64) -> t_i64);\n+    ifn!(\"llvm.bitreverse.i128\", fn(t_i128) -> t_i128);\n+\n     ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.sadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});"}, {"sha": "0a3f06b55f1e87af8e395c8ce5711e60673407a9", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -32,7 +32,7 @@ pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    !cx.tcx.is_exported_symbol(def_id)\n+    !cx.tcx.is_reachable_non_generic(def_id)\n }\n \n #[allow(non_snake_case)]"}, {"sha": "3f87ce7e04792f4c417adc7ba63a0ef705576f37", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -287,8 +287,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             ], None)\n         },\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n-        \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n-        \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n+        \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" |\n+        \"mul_with_overflow\" | \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n         \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n             let ty = arg_tys[0];\n             match int_type_width_signed(ty, cx) {\n@@ -315,6 +315,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                                         &[args[0].immediate()], None)\n                             }\n                         }\n+                        \"bitreverse\" => {\n+                            bx.call(cx.get_intrinsic(&format!(\"llvm.bitreverse.i{}\", width)),\n+                                &[args[0].immediate()], None)\n+                        }\n                         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n                             let intrinsic = format!(\"llvm.{}{}.with.overflow.i{}\",\n                                                     if signed { 's' } else { 'u' },"}, {"sha": "d636a5f2e64b732cf43c8ff8666974e116308866", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -44,11 +44,7 @@ extern crate rustc_data_structures;\n \n pub extern crate rustc as __rustc;\n \n-use rustc::ty::{TyCtxt, Instance};\n-use rustc::hir;\n-use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::hir::map as hir_map;\n-use rustc::util::nodemap::NodeSet;\n+use rustc::ty::TyCtxt;\n \n pub mod diagnostics;\n pub mod link;\n@@ -70,53 +66,4 @@ pub fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n     }\n }\n \n-/// The context provided lists a set of reachable ids as calculated by\n-/// middle::reachable, but this contains far more ids and symbols than we're\n-/// actually exposing from the object file. This function will filter the set in\n-/// the context to the set of ids which correspond to symbols that are exposed\n-/// from the object file being generated.\n-///\n-/// This list is later used by linkers to determine the set of symbols needed to\n-/// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn find_exported_symbols<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeSet {\n-    tcx.reachable_set(LOCAL_CRATE).0.iter().cloned().filter(|&id| {\n-        // Next, we want to ignore some FFI functions that are not exposed from\n-        // this crate. Reachable FFI functions can be lumped into two\n-        // categories:\n-        //\n-        // 1. Those that are included statically via a static library\n-        // 2. Those included otherwise (e.g. dynamically or via a framework)\n-        //\n-        // Although our LLVM module is not literally emitting code for the\n-        // statically included symbols, it's an export of our library which\n-        // needs to be passed on to the linker and encoded in the metadata.\n-        //\n-        // As a result, if this id is an FFI item (foreign item) then we only\n-        // let it through if it's included statically.\n-        match tcx.hir.get(id) {\n-            hir_map::NodeForeignItem(..) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                tcx.is_statically_included_foreign_item(def_id)\n-            }\n-\n-            // Only consider nodes that actually have exported symbols.\n-            hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemStatic(..), .. }) |\n-            hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemFn(..), .. }) |\n-            hir_map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Method(..), .. }) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                let generics = tcx.generics_of(def_id);\n-                (generics.parent_types == 0 && generics.types.is_empty()) &&\n-                // Functions marked with #[inline] are only ever translated\n-                // with \"internal\" linkage and are never exported.\n-                !Instance::mono(tcx, def_id).def.requires_local(tcx)\n-            }\n-\n-            _ => false\n-        }\n-    }).collect()\n-}\n-\n __build_diagnostic_array! { librustc_trans_utils, DIAGNOSTICS }"}, {"sha": "267c8d2bd03c861bcfac1d495c359c6fdfe1b8fd", "filename": "src/librustc_trans_utils/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fsymbol_names_test.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -28,7 +28,7 @@ pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk.\n-    if !tcx.sess.features.borrow().rustc_attrs {\n+    if !tcx.features().rustc_attrs {\n         return;\n     }\n "}, {"sha": "7b2cbe140aebfbe288a6207630b6c126388fc71f", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -247,8 +247,7 @@ impl TransCrate for MetadataOnlyTransCrate {\n         tcx.sess.abort_if_errors();\n \n         let link_meta = build_link_meta(tcx.crate_hash(LOCAL_CRATE));\n-        let exported_symbols = ::find_exported_symbols(tcx);\n-        let metadata = tcx.encode_metadata(&link_meta, &exported_symbols);\n+        let metadata = tcx.encode_metadata(&link_meta);\n \n         box OngoingCrateTranslation {\n             metadata: metadata,"}, {"sha": "0df1225cf26247d157d47284abac2f52f0816ddc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -415,7 +415,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n-        if !self.tcx().sess.features.borrow().unboxed_closures &&\n+        if !self.tcx().features().unboxed_closures &&\n            trait_segment.with_parameters(|p| p.parenthesized) != trait_def.paren_sugar {\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n             let msg = if trait_def.paren_sugar {"}, {"sha": "a261c12bcdd946dcc88cca1beeb2a5ce29f86d7c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n             if pat_adjustments.len() > 0 {\n-                if tcx.sess.features.borrow().match_default_bindings {\n+                if tcx.features().match_default_bindings {\n                     debug!(\"default binding mode is now {:?}\", def_bm);\n                     self.inh.tables.borrow_mut()\n                         .pat_adjustments_mut()"}, {"sha": "abb0acd699cba0b148296bf1580684805d3dff22", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -586,7 +586,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         }\n \n-        if has_unsized_tuple_coercion && !self.tcx.sess.features.borrow().unsized_tuple_coercion {\n+        if has_unsized_tuple_coercion && !self.tcx.features().unsized_tuple_coercion {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n                                            \"unsized_tuple_coercion\",\n                                            self.cause.span,"}, {"sha": "2e00040d99a73f58782bc810277aa9346486715b", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -275,7 +275,8 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"volatile_store\" =>\n                 (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_nil()),\n \n-            \"ctpop\" | \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"bswap\" =>\n+            \"ctpop\" | \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" |\n+            \"bswap\" | \"bitreverse\" =>\n                 (1, vec![param(0)], param(0)),\n \n             \"add_with_overflow\" | \"sub_with_overflow\"  | \"mul_with_overflow\" =>"}, {"sha": "841559013a093352731791934b3b872c74450c60", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -324,7 +324,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // possible that there will be multiple applicable methods.\n                 if !is_suggestion.0 {\n                     if reached_raw_pointer\n-                    && !self.tcx.sess.features.borrow().arbitrary_self_types {\n+                    && !self.tcx.features().arbitrary_self_types {\n                         // this case used to be allowed by the compiler,\n                         // so we do a future-compat lint here for the 2015 epoch\n                         // (see https://github.com/rust-lang/rust/issues/46906)"}, {"sha": "0f59973eab251245ddfc004b9b97e6a2d6e4c167", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1105,7 +1105,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     }\n     fcx.demand_suptype(span, ret_ty, actual_return_ty);\n \n-    if fcx.tcx.sess.features.borrow().termination_trait {\n+    if fcx.tcx.features().termination_trait {\n         // If the termination trait language item is activated, check that the main return type\n         // implements the termination trait.\n         if let Some(term_id) = fcx.tcx.lang_items().termination() {\n@@ -1616,7 +1616,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let repr_type_ty = def.repr.discr_type().to_ty(tcx);\n     if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n-        if !tcx.sess.features.borrow().repr128 {\n+        if !tcx.features().repr128 {\n             emit_feature_err(&tcx.sess.parse_sess,\n                              \"repr128\",\n                              sp,"}, {"sha": "d10ee358e072846e77be1591c47c141b1f55d4b1", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -536,7 +536,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         let is_self_ty = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n         let self_kind = ExplicitSelf::determine(self_arg_ty, is_self_ty);\n \n-        if !fcx.tcx.sess.features.borrow().arbitrary_self_types {\n+        if !fcx.tcx.features().arbitrary_self_types {\n             match self_kind {\n                 ExplicitSelf::ByValue |\n                 ExplicitSelf::ByReference(_, _) |"}, {"sha": "d3de31d630a97469b8fad938a3b3912d7cd21a3b", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -74,7 +74,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_d\n         return;\n     }\n \n-    if tcx.sess.features.borrow().unboxed_closures {\n+    if tcx.features().unboxed_closures {\n         // the feature gate allows all Fn traits\n         return;\n     }"}, {"sha": "f7158593f0b6e37cd64d51e121afc009e2033392", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -711,7 +711,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n-    if paren_sugar && !tcx.sess.features.borrow().unboxed_closures {\n+    if paren_sugar && !tcx.features().unboxed_closures {\n         let mut err = tcx.sess.struct_span_err(\n             item.span,\n             \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n@@ -953,7 +953,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         if !allow_defaults && p.default.is_some() {\n-            if !tcx.sess.features.borrow().default_type_parameter_fallback {\n+            if !tcx.features().default_type_parameter_fallback {\n                 tcx.lint_node(\n                     lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n                     p.id,\n@@ -1692,7 +1692,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n     // ABIs are handled at all correctly.\n     if abi != abi::Abi::RustIntrinsic && abi != abi::Abi::PlatformIntrinsic\n-            && !tcx.sess.features.borrow().simd_ffi {\n+            && !tcx.features().simd_ffi {\n         let check = |ast_ty: &hir::Ty, ty: Ty| {\n             if ty.is_simd() {\n                 tcx.sess.struct_span_err(ast_ty.span,"}, {"sha": "d9bd96b0d769fea0fb7ae6c686eb57f17b5470ef", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -207,7 +207,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             let actual = tcx.fn_sig(main_def_id);\n             let expected_return_type = if tcx.lang_items().termination().is_some()\n-                && tcx.sess.features.borrow().termination_trait {\n+                && tcx.features().termination_trait {\n                 // we take the return type of the given main function, the real check is done\n                 // in `check_fn`\n                 actual.output().skip_binder()"}, {"sha": "e4477bee5c0e9e39e8b0dddd5b9b67959760fc05", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -629,7 +629,7 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n                                             nested: F) {\n         let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs);\n         if let Some(ref cfg) = attrs.cfg {\n-            if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features.borrow())) {\n+            if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features_untracked())) {\n                 return;\n             }\n         }"}, {"sha": "6f4528a0e243ce5b6bae4cf6ae84a48cd7d4ef81", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -620,7 +620,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, isize> = HashMap::new();\n+    /// let mut map: HashMap<&str, i32> = HashMap::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -637,7 +637,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, isize> = HashMap::with_capacity(10);\n+    /// let mut map: HashMap<&str, i32> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -724,7 +724,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// use std::collections::hash_map::RandomState;\n     ///\n     /// let hasher = RandomState::new();\n-    /// let map: HashMap<isize, isize> = HashMap::with_hasher(hasher);\n+    /// let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n     /// let hasher: &RandomState = map.hasher();\n     /// ```\n     #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n@@ -741,7 +741,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let map: HashMap<isize, isize> = HashMap::with_capacity(100);\n+    /// let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n     /// assert!(map.capacity() >= 100);\n     /// ```\n     #[inline]\n@@ -770,7 +770,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, isize> = HashMap::new();\n+    /// let mut map: HashMap<&str, i32> = HashMap::new();\n     /// map.reserve(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -849,7 +849,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     /// use std::collections::HashMap;\n     ///\n-    /// let mut map: HashMap<isize, isize> = HashMap::with_capacity(100);\n+    /// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n     /// map.insert(1, 2);\n     /// map.insert(3, 4);\n     /// assert!(map.capacity() >= 100);\n@@ -1306,7 +1306,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     /// use std::collections::HashMap;\n     ///\n-    /// let mut map: HashMap<isize, isize> = (0..8).map(|x|(x, x*10)).collect();\n+    /// let mut map: HashMap<i32, i32> = (0..8).map(|x|(x, x*10)).collect();\n     /// map.retain(|&k, _| k % 2 == 0);\n     /// assert_eq!(map.len(), 4);\n     /// ```\n@@ -1722,7 +1722,7 @@ impl<K, V, S> IntoIterator for HashMap<K, V, S>\n     /// map.insert(\"c\", 3);\n     ///\n     /// // Not possible with .iter()\n-    /// let vec: Vec<(&str, isize)> = map.into_iter().collect();\n+    /// let vec: Vec<(&str, i32)> = map.into_iter().collect();\n     /// ```\n     fn into_iter(self) -> IntoIter<K, V> {\n         IntoIter { inner: self.table.into_iter() }\n@@ -1750,7 +1750,7 @@ impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Iter<'a, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1773,7 +1773,7 @@ impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n         self.inner.len()\n     }\n }\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -1808,7 +1808,7 @@ impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n         self.inner.len()\n     }\n }\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for IntoIter<K, V> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -1840,7 +1840,7 @@ impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n         self.inner.len()\n     }\n }\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1863,7 +1863,7 @@ impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n         self.inner.len()\n     }\n }\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Values<'a, K, V> {}\n \n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n@@ -1886,7 +1886,7 @@ impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {\n         self.inner.len()\n     }\n }\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -1921,7 +1921,7 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n         self.inner.len()\n     }\n }\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K, V> FusedIterator for Drain<'a, K, V> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -2786,34 +2786,34 @@ mod test_map {\n         assert_eq!(m2.len(), 2);\n     }\n \n-    thread_local! { static DROP_VECTOR: RefCell<Vec<isize>> = RefCell::new(Vec::new()) }\n+    thread_local! { static DROP_VECTOR: RefCell<Vec<i32>> = RefCell::new(Vec::new()) }\n \n     #[derive(Hash, PartialEq, Eq)]\n-    struct Dropable {\n+    struct Droppable {\n         k: usize,\n     }\n \n-    impl Dropable {\n-        fn new(k: usize) -> Dropable {\n+    impl Droppable {\n+        fn new(k: usize) -> Droppable {\n             DROP_VECTOR.with(|slot| {\n                 slot.borrow_mut()[k] += 1;\n             });\n \n-            Dropable { k: k }\n+            Droppable { k: k }\n         }\n     }\n \n-    impl Drop for Dropable {\n+    impl Drop for Droppable {\n         fn drop(&mut self) {\n             DROP_VECTOR.with(|slot| {\n                 slot.borrow_mut()[self.k] -= 1;\n             });\n         }\n     }\n \n-    impl Clone for Dropable {\n-        fn clone(&self) -> Dropable {\n-            Dropable::new(self.k)\n+    impl Clone for Droppable {\n+        fn clone(&self) -> Droppable {\n+            Droppable::new(self.k)\n         }\n     }\n \n@@ -2833,8 +2833,8 @@ mod test_map {\n             });\n \n             for i in 0..100 {\n-                let d1 = Dropable::new(i);\n-                let d2 = Dropable::new(i + 100);\n+                let d1 = Droppable::new(i);\n+                let d2 = Droppable::new(i + 100);\n                 m.insert(d1, d2);\n             }\n \n@@ -2845,7 +2845,7 @@ mod test_map {\n             });\n \n             for i in 0..50 {\n-                let k = Dropable::new(i);\n+                let k = Droppable::new(i);\n                 let v = m.remove(&k);\n \n                 assert!(v.is_some());\n@@ -2892,8 +2892,8 @@ mod test_map {\n             });\n \n             for i in 0..100 {\n-                let d1 = Dropable::new(i);\n-                let d2 = Dropable::new(i + 100);\n+                let d1 = Droppable::new(i);\n+                let d2 = Droppable::new(i + 100);\n                 hm.insert(d1, d2);\n             }\n \n@@ -2943,13 +2943,13 @@ mod test_map {\n \n     #[test]\n     fn test_empty_remove() {\n-        let mut m: HashMap<isize, bool> = HashMap::new();\n+        let mut m: HashMap<i32, bool> = HashMap::new();\n         assert_eq!(m.remove(&0), None);\n     }\n \n     #[test]\n     fn test_empty_entry() {\n-        let mut m: HashMap<isize, bool> = HashMap::new();\n+        let mut m: HashMap<i32, bool> = HashMap::new();\n         match m.entry(0) {\n             Occupied(_) => panic!(),\n             Vacant(_) => {}\n@@ -2960,7 +2960,7 @@ mod test_map {\n \n     #[test]\n     fn test_empty_iter() {\n-        let mut m: HashMap<isize, bool> = HashMap::new();\n+        let mut m: HashMap<i32, bool> = HashMap::new();\n         assert_eq!(m.drain().next(), None);\n         assert_eq!(m.keys().next(), None);\n         assert_eq!(m.values().next(), None);\n@@ -3461,7 +3461,7 @@ mod test_map {\n     fn test_entry_take_doesnt_corrupt() {\n         #![allow(deprecated)] //rand\n         // Test for #19292\n-        fn check(m: &HashMap<isize, ()>) {\n+        fn check(m: &HashMap<i32, ()>) {\n             for k in m.keys() {\n                 assert!(m.contains_key(k),\n                         \"{} is in keys() but not in the map?\", k);\n@@ -3570,7 +3570,7 @@ mod test_map {\n \n     #[test]\n     fn test_retain() {\n-        let mut map: HashMap<isize, isize> = (0..100).map(|x|(x, x*10)).collect();\n+        let mut map: HashMap<i32, i32> = (0..100).map(|x|(x, x*10)).collect();\n \n         map.retain(|&k, _| k % 2 == 0);\n         assert_eq!(map.len(), 50);"}, {"sha": "9e63ba2717a6a586dae78826252086322d4a97ba", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -724,7 +724,7 @@ impl<T, S> HashSet<T, S>\n     /// use std::collections::HashSet;\n     ///\n     /// let xs = [1,2,3,4,5,6];\n-    /// let mut set: HashSet<isize> = xs.iter().cloned().collect();\n+    /// let mut set: HashSet<i32> = xs.iter().cloned().collect();\n     /// set.retain(|&k| k % 2 == 0);\n     /// assert_eq!(set.len(), 3);\n     /// ```\n@@ -1097,7 +1097,7 @@ impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n         self.iter.len()\n     }\n }\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K> FusedIterator for Iter<'a, K> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -1124,7 +1124,7 @@ impl<K> ExactSizeIterator for IntoIter<K> {\n         self.iter.len()\n     }\n }\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K> FusedIterator for IntoIter<K> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -1155,7 +1155,7 @@ impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n         self.iter.len()\n     }\n }\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, K> FusedIterator for Drain<'a, K> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -1208,7 +1208,7 @@ impl<'a, T, S> fmt::Debug for Intersection<'a, T, S>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T, S> FusedIterator for Intersection<'a, T, S>\n     where T: Eq + Hash,\n           S: BuildHasher\n@@ -1244,7 +1244,7 @@ impl<'a, T, S> Iterator for Difference<'a, T, S>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T, S> FusedIterator for Difference<'a, T, S>\n     where T: Eq + Hash,\n           S: BuildHasher\n@@ -1283,7 +1283,7 @@ impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T, S> FusedIterator for SymmetricDifference<'a, T, S>\n     where T: Eq + Hash,\n           S: BuildHasher\n@@ -1307,7 +1307,7 @@ impl<'a, T, S> Clone for Union<'a, T, S> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T, S> FusedIterator for Union<'a, T, S>\n     where T: Eq + Hash,\n           S: BuildHasher\n@@ -1745,7 +1745,7 @@ mod test_set {\n     #[test]\n     fn test_retain() {\n         let xs = [1, 2, 3, 4, 5, 6];\n-        let mut set: HashSet<isize> = xs.iter().cloned().collect();\n+        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n         set.retain(|&k| k % 2 == 0);\n         assert_eq!(set.len(), 3);\n         assert!(set.contains(&2));"}, {"sha": "c88c2bc913713634aa465e8fa82830226b3802e2", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -875,6 +875,8 @@ impl CStr {\n     ///   `ptr`.\n     /// * There is no guarantee that the memory pointed to by `ptr` contains a\n     ///   valid nul terminator byte at the end of the string.\n+    /// * It is not guaranteed that the memory pointed by `ptr` won't change\n+    ///   before the `CStr` has been destroyed.\n     ///\n     /// > **Note**: This operation is intended to be a 0-cost cast but it is\n     /// > currently implemented with an up-front calculation of the length of"}, {"sha": "da15941374d846b44602cffc7d26ebcd3199d930", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -266,7 +266,6 @@\n #![feature(float_from_str_radix)]\n #![feature(fn_traits)]\n #![feature(fnbox)]\n-#![feature(fused)]\n #![feature(generic_param_attrs)]\n #![feature(hashmap_hasher)]\n #![feature(heap_api)]"}, {"sha": "cd2af99d6ac1f47a7beffa8837ad034e80da838e", "filename": "src/libstd/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -905,7 +905,7 @@ impl<'a> DoubleEndedIterator for Iter<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for Iter<'a> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1008,7 +1008,7 @@ impl<'a> DoubleEndedIterator for Components<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for Components<'a> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1076,7 +1076,7 @@ impl<'a> Iterator for Ancestors<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[unstable(feature = \"path_ancestors\", issue = \"48581\")]\n impl<'a> FusedIterator for Ancestors<'a> {}\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9fff8b91f96f32f155f8f9378e515e785ee56b1e", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -428,20 +428,15 @@ impl fmt::Debug for Wtf8 {\n \n         formatter.write_str(\"\\\"\")?;\n         let mut pos = 0;\n-        loop {\n-            match self.next_surrogate(pos) {\n-                None => break,\n-                Some((surrogate_pos, surrogate)) => {\n-                    write_str_escaped(\n-                        formatter,\n-                        unsafe { str::from_utf8_unchecked(\n-                            &self.bytes[pos .. surrogate_pos]\n-                        )},\n-                    )?;\n-                    write!(formatter, \"\\\\u{{{:x}}}\", surrogate)?;\n-                    pos = surrogate_pos + 3;\n-                }\n-            }\n+        while let Some((surrogate_pos, surrogate)) = self.next_surrogate(pos) {\n+            write_str_escaped(\n+                formatter,\n+                unsafe { str::from_utf8_unchecked(\n+                    &self.bytes[pos .. surrogate_pos]\n+                )},\n+            )?;\n+            write!(formatter, \"\\\\u{{{:x}}}\", surrogate)?;\n+            pos = surrogate_pos + 3;\n         }\n         write_str_escaped(\n             formatter,"}, {"sha": "de8b46d5f1b0229b89aeb1fa62316661340aac5a", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -70,7 +70,7 @@ impl Iterator for ToLowercase {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for ToLowercase {}\n \n /// Returns an iterator that yields the uppercase equivalent of a `char`.\n@@ -92,7 +92,7 @@ impl Iterator for ToUppercase {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for ToUppercase {}\n \n #[derive(Debug, Clone)]"}, {"sha": "f155b62e3cc72dd9e6c62fc01608e5b5a7577fdc", "filename": "src/libstd_unicode/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -36,7 +36,6 @@\n #![feature(str_internals)]\n #![feature(decode_utf8)]\n #![feature(fn_traits)]\n-#![feature(fused)]\n #![feature(lang_items)]\n #![feature(non_exhaustive)]\n #![feature(staged_api)]"}, {"sha": "a72e1210d93f61c13279025ada8387668c6a8cd8", "filename": "src/libstd_unicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibstd_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fu_str.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -127,7 +127,6 @@ impl<I> Iterator for Utf16Encoder<I>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n impl<I> FusedIterator for Utf16Encoder<I>\n     where I: FusedIterator<Item = char> {}\n \n@@ -186,5 +185,5 @@ impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a> FusedIterator for SplitWhitespace<'a> {}"}, {"sha": "9162a582599fc6dc79f1b1b9ed6161c47fd6479b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -26,7 +26,6 @@ use parse::token::Token::*;\n use symbol::Symbol;\n use tokenstream::{TokenStream, TokenTree};\n \n-use std::cell::RefCell;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry;\n \n@@ -184,7 +183,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n // Holy self-referential!\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item) -> SyntaxExtension {\n+pub fn compile(sess: &ParseSess, features: &Features, def: &ast::Item) -> SyntaxExtension {\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n@@ -296,7 +295,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n }\n \n fn check_lhs_nt_follows(sess: &ParseSess,\n-                        features: &RefCell<Features>,\n+                        features: &Features,\n                         attrs: &[ast::Attribute],\n                         lhs: &quoted::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n@@ -353,7 +352,7 @@ fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n }\n \n fn check_matcher(sess: &ParseSess,\n-                 features: &RefCell<Features>,\n+                 features: &Features,\n                  attrs: &[ast::Attribute],\n                  matcher: &[quoted::TokenTree]) -> bool {\n     let first_sets = FirstSets::new(matcher);\n@@ -601,7 +600,7 @@ impl TokenSet {\n // Requires that `first_sets` is pre-computed for `matcher`;\n // see `FirstSets::new`.\n fn check_matcher_core(sess: &ParseSess,\n-                      features: &RefCell<Features>,\n+                      features: &Features,\n                       attrs: &[ast::Attribute],\n                       first_sets: &FirstSets,\n                       matcher: &[quoted::TokenTree],\n@@ -869,7 +868,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n }\n \n fn has_legal_fragment_specifier(sess: &ParseSess,\n-                                features: &RefCell<Features>,\n+                                features: &Features,\n                                 attrs: &[ast::Attribute],\n                                 tok: &quoted::TokenTree) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n@@ -884,15 +883,15 @@ fn has_legal_fragment_specifier(sess: &ParseSess,\n }\n \n fn is_legal_fragment_specifier(sess: &ParseSess,\n-                               features: &RefCell<Features>,\n+                               features: &Features,\n                                attrs: &[ast::Attribute],\n                                frag_name: &str,\n                                frag_span: Span) -> bool {\n     match frag_name {\n         \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" |\n         \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"\" => true,\n         \"lifetime\" => {\n-            if !features.borrow().macro_lifetime_matcher &&\n+            if !features.macro_lifetime_matcher &&\n                !attr::contains_name(attrs, \"allow_internal_unstable\") {\n                 let explain = feature_gate::EXPLAIN_LIFETIME_MATCHER;\n                 emit_feature_err(sess,\n@@ -904,7 +903,7 @@ fn is_legal_fragment_specifier(sess: &ParseSess,\n             true\n         },\n         \"vis\" => {\n-            if !features.borrow().macro_vis_matcher &&\n+            if !features.macro_vis_matcher &&\n                !attr::contains_name(attrs, \"allow_internal_unstable\") {\n                 let explain = feature_gate::EXPLAIN_VIS_MATCHER;\n                 emit_feature_err(sess,"}, {"sha": "122bb9ba024a40c321e54a945da2ba0c9020a349", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -17,7 +17,6 @@ use symbol::keywords;\n use syntax_pos::{BytePos, Span, DUMMY_SP};\n use tokenstream;\n \n-use std::cell::RefCell;\n use std::iter::Peekable;\n use rustc_data_structures::sync::Lrc;\n \n@@ -183,7 +182,7 @@ pub fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,\n-    features: &RefCell<Features>,\n+    features: &Features,\n     attrs: &[ast::Attribute],\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n@@ -251,7 +250,7 @@ fn parse_tree<I>(\n     trees: &mut Peekable<I>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n-    features: &RefCell<Features>,\n+    features: &Features,\n     attrs: &[ast::Attribute],\n ) -> TokenTree\n where\n@@ -382,7 +381,7 @@ fn parse_sep_and_kleene_op<I>(\n     input: &mut Peekable<I>,\n     span: Span,\n     sess: &ParseSess,\n-    features: &RefCell<Features>,\n+    features: &Features,\n     attrs: &[ast::Attribute],\n ) -> (Option<token::Token>, KleeneOp)\n where\n@@ -415,7 +414,7 @@ where\n                 match parse_kleene_op(input, span) {\n                     // #2 is a KleeneOp (this is the only valid option) :)\n                     Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n-                        if !features.borrow().macro_at_most_once_rep\n+                        if !features.macro_at_most_once_rep\n                             && !attr::contains_name(attrs, \"allow_internal_unstable\")\n                         {\n                             let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n@@ -438,7 +437,7 @@ where\n                     Err(span) => span,\n                 }\n             } else {\n-                if !features.borrow().macro_at_most_once_rep\n+                if !features.macro_at_most_once_rep\n                     && !attr::contains_name(attrs, \"allow_internal_unstable\")\n                 {\n                     let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n@@ -460,7 +459,7 @@ where\n         Ok(Err((tok, span))) => match parse_kleene_op(input, span) {\n             // #2 is a KleeneOp :D\n             Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n-                if !features.borrow().macro_at_most_once_rep\n+                if !features.macro_at_most_once_rep\n                     && !attr::contains_name(attrs, \"allow_internal_unstable\")\n                 {\n                     let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n@@ -487,7 +486,7 @@ where\n         Err(span) => span,\n     };\n \n-    if !features.borrow().macro_at_most_once_rep\n+    if !features.macro_at_most_once_rep\n         && !attr::contains_name(attrs, \"allow_internal_unstable\")\n     {\n         sess.span_diagnostic"}, {"sha": "45d82bc7af38e824e40ca2d9d27d0c787ae690ca", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -62,6 +62,7 @@ macro_rules! declare_features {\n             &[$((stringify!($feature), $ver, $issue, set!($feature))),+];\n \n         /// A set of features to be used by later passes.\n+        #[derive(Clone)]\n         pub struct Features {\n             /// `#![feature]` attrs for stable language features, for error reporting\n             pub declared_stable_lang_features: Vec<(Symbol, Span)>,\n@@ -78,6 +79,12 @@ macro_rules! declare_features {\n                     $($feature: false),+\n                 }\n             }\n+\n+            pub fn walk_feature_fields<F>(&self, mut f: F)\n+                where F: FnMut(&str, bool)\n+            {\n+                $(f(stringify!($feature), self.$feature);)+\n+            }\n         }\n     };\n "}, {"sha": "94195ccc72c49d576399c0f829ed69d38cc666d5", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -132,6 +132,18 @@ impl<'a> StringReader<'a> {\n         self.advance_token()?;\n         Ok(ret_val)\n     }\n+\n+    fn fail_unterminated_raw_string(&self, pos: BytePos, hash_count: usize) {\n+        let mut err = self.struct_span_fatal(pos, pos, \"unterminated raw string\");\n+        err.span_label(self.mk_sp(pos, pos), \"unterminated raw string\");\n+        if hash_count > 0 {\n+            err.note(&format!(\"this raw string should be terminated with `\\\"{}`\",\n+                              \"#\".repeat(hash_count)));\n+        }\n+        err.emit();\n+        FatalError.raise();\n+    }\n+\n     fn fatal(&self, m: &str) -> FatalError {\n         self.fatal_span(self.peek_span, m)\n     }\n@@ -269,6 +281,15 @@ impl<'a> StringReader<'a> {\n         Self::push_escaped_char_for_msg(&mut m, c);\n         self.fatal_span_(from_pos, to_pos, &m[..])\n     }\n+\n+    fn struct_span_fatal(&self,\n+                         from_pos: BytePos,\n+                         to_pos: BytePos,\n+                         m: &str)\n+                         -> DiagnosticBuilder<'a> {\n+        self.sess.span_diagnostic.struct_span_fatal(self.mk_sp(from_pos, to_pos), m)\n+    }\n+\n     fn struct_fatal_span_char(&self,\n                               from_pos: BytePos,\n                               to_pos: BytePos,\n@@ -1404,8 +1425,7 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 if self.is_eof() {\n-                    let last_bpos = self.pos;\n-                    self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\").raise();\n+                    self.fail_unterminated_raw_string(start_bpos, hash_count);\n                 } else if !self.ch_is('\"') {\n                     let last_bpos = self.pos;\n                     let curr_char = self.ch.unwrap();\n@@ -1421,8 +1441,7 @@ impl<'a> StringReader<'a> {\n                 let mut valid = true;\n                 'outer: loop {\n                     if self.is_eof() {\n-                        let last_bpos = self.pos;\n-                        self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\").raise();\n+                        self.fail_unterminated_raw_string(start_bpos, hash_count);\n                     }\n                     // if self.ch_is('\"') {\n                     // content_end_bpos = self.pos;\n@@ -1636,8 +1655,7 @@ impl<'a> StringReader<'a> {\n         }\n \n         if self.is_eof() {\n-            let pos = self.pos;\n-            self.fatal_span_(start_bpos, pos, \"unterminated raw string\").raise();\n+            self.fail_unterminated_raw_string(start_bpos, hash_count);\n         } else if !self.ch_is('\"') {\n             let pos = self.pos;\n             let ch = self.ch.unwrap();\n@@ -1653,8 +1671,7 @@ impl<'a> StringReader<'a> {\n         'outer: loop {\n             match self.ch {\n                 None => {\n-                    let pos = self.pos;\n-                    self.fatal_span_(start_bpos, pos, \"unterminated raw string\").raise()\n+                    self.fail_unterminated_raw_string(start_bpos, hash_count);\n                 }\n                 Some('\"') => {\n                     content_end_bpos = self.pos;"}, {"sha": "da2a22df997d170f4a865e0963b0532f00080d28", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -3114,7 +3114,7 @@ impl<'a> Parser<'a> {\n                         let expr_str = self.sess.codemap().span_to_snippet(expr.span)\n                                                 .unwrap_or(pprust::expr_to_string(&expr));\n                         err.span_suggestion(expr.span,\n-                                            &format!(\"try {} the casted value\", op_verb),\n+                                            &format!(\"try {} the cast value\", op_verb),\n                                             format!(\"({})\", expr_str));\n                         err.emit();\n "}, {"sha": "8fd95aa1ca8612c40e47e63b7298050969c4c0e1", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -732,18 +732,13 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     let mut parser = parse::Parser::new(fmt_str);\n     let mut pieces = vec![];\n \n-    loop {\n-        match parser.next() {\n-            Some(mut piece) => {\n-                if !parser.errors.is_empty() {\n-                    break;\n-                }\n-                cx.verify_piece(&piece);\n-                cx.resolve_name_inplace(&mut piece);\n-                pieces.push(piece);\n-            }\n-            None => break,\n+    while let Some(mut piece) = parser.next() {\n+        if !parser.errors.is_empty() {\n+            break;\n         }\n+        cx.verify_piece(&piece);\n+        cx.resolve_name_inplace(&mut piece);\n+        pieces.push(piece);\n     }\n \n     let numbered_position_args = pieces.iter().any(|arg: &parse::Piece| {"}, {"sha": "ed9eb5d5c9261fb6d0a313fc2c723e633b77a7f6", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -322,12 +322,7 @@ impl Span {\n     pub fn macro_backtrace(mut self) -> Vec<MacroBacktrace> {\n         let mut prev_span = DUMMY_SP;\n         let mut result = vec![];\n-        loop {\n-            let info = match self.ctxt().outer().expn_info() {\n-                Some(info) => info,\n-                None => break,\n-            };\n-\n+        while let Some(info) = self.ctxt().outer().expn_info() {\n             let (pre, post) = match info.callee.format {\n                 ExpnFormat::MacroAttribute(..) => (\"#[\", \"]\"),\n                 ExpnFormat::MacroBang(..) => (\"\", \"!\"),"}, {"sha": "1e02fe4befdf52d56e6a6b271216b8146f61cf46", "filename": "src/test/codegen/abi-main-signature-16bit-c-int.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Fabi-main-signature-16bit-c-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Fabi-main-signature-16bit-c-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fabi-main-signature-16bit-c-int.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -18,7 +18,6 @@\n // ignore-hexagon\n // ignore-mips\n // ignore-powerpc\n-// ignore-powerpc64\n // ignore-s390x\n // ignore-sparc\n // ignore-wasm32"}, {"sha": "b24899cc363a08b0bf8c9b5847d17fc97794be73", "filename": "src/test/codegen/fastcall-inreg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -25,8 +25,6 @@\n // ignore-mips64\n // ignore-mips64el\n // ignore-msp430\n-// ignore-powerpc64\n-// ignore-powerpc64le\n // ignore-powerpc\n // ignore-r600\n // ignore-amdgcn"}, {"sha": "5661592d0c7b2873699151b8571edd4aa4fa4f90", "filename": "src/test/codegen/global_asm.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fglobal_asm.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -21,8 +21,6 @@\n // ignore-mips64\n // ignore-mips64el\n // ignore-msp430\n-// ignore-powerpc64\n-// ignore-powerpc64le\n // ignore-powerpc\n // ignore-r600\n // ignore-amdgcn"}, {"sha": "d8b5db12404acc12d2b7e5801600b07161ee2ee9", "filename": "src/test/codegen/global_asm_include.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Fglobal_asm_include.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Fglobal_asm_include.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fglobal_asm_include.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -21,8 +21,6 @@\n // ignore-mips64\n // ignore-mips64el\n // ignore-msp430\n-// ignore-powerpc64\n-// ignore-powerpc64le\n // ignore-powerpc\n // ignore-r600\n // ignore-amdgcn"}, {"sha": "caa0506550dde2fec8ac4e8744145db64c5acbd0", "filename": "src/test/codegen/global_asm_x2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Fglobal_asm_x2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Fglobal_asm_x2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fglobal_asm_x2.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -21,8 +21,6 @@\n // ignore-mips64\n // ignore-mips64el\n // ignore-msp430\n-// ignore-powerpc64\n-// ignore-powerpc64le\n // ignore-powerpc\n // ignore-r600\n // ignore-amdgcn"}, {"sha": "655e67cf7eefe543a230a2089b4dabf9c55138ad", "filename": "src/test/codegen/repr-transparent-aggregates-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -14,7 +14,6 @@\n // ignore-mips\n // ignore-mips64\n // ignore-powerpc\n-// ignore-powerpc64\n // See repr-transparent.rs\n \n #![crate_type=\"lib\"]"}, {"sha": "de2f9ab52f60b330cb4af02b6561047ad1fe5588", "filename": "src/test/incremental/feature_gate.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fincremental%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fincremental%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ffeature_gate.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test makes sure that we detect changed feature gates.\n+\n+// revisions:rpass1 cfail2\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+#![cfg_attr(rpass1, feature(nll))]\n+\n+fn main() {\n+    let mut v = vec![1];\n+    v.push(v[0]);\n+    //[cfail2]~^ ERROR cannot borrow\n+}"}, {"sha": "fd8f7b9e384f35410136eb58eb9fd8030db12921", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -41,7 +41,7 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n     let mbe_matcher = quoted::parse(mbe_matcher.into_iter().collect(),\n                                     true,\n                                     cx.parse_sess,\n-                                    &RefCell::new(Features::new()),\n+                                    &Features::new(),\n                                     &[]);\n     let map = match TokenTree::parse(cx, &mbe_matcher, args.iter().cloned().collect()) {\n         Success(map) => map,"}, {"sha": "0dede8eb70de046a594b06a28e0bd4948fefe717", "filename": "src/test/run-pass/extern-types-pointer-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Frun-pass%2Fextern-types-pointer-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Frun-pass%2Fextern-types-pointer-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-types-pointer-cast.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that pointers to extern types can be casted from/to usize,\n+// Test that pointers to extern types can be cast from/to usize,\n // despite being !Sized.\n \n #![feature(extern_types)]"}, {"sha": "bfa3a1e128a9a3e97948d0e8a8b3c41bc28483dc", "filename": "src/test/run-pass/intrinsics-integer.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(intrinsics)]\n+#![feature(intrinsics, i128_type)]\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n@@ -18,6 +18,7 @@ mod rusti {\n         pub fn cttz<T>(x: T) -> T;\n         pub fn cttz_nonzero<T>(x: T) -> T;\n         pub fn bswap<T>(x: T) -> T;\n+        pub fn bitreverse<T>(x: T) -> T;\n     }\n }\n \n@@ -29,106 +30,127 @@ pub fn main() {\n         assert_eq!(ctpop(0u16), 0); assert_eq!(ctpop(0i16), 0);\n         assert_eq!(ctpop(0u32), 0); assert_eq!(ctpop(0i32), 0);\n         assert_eq!(ctpop(0u64), 0); assert_eq!(ctpop(0i64), 0);\n+        assert_eq!(ctpop(0u128), 0); assert_eq!(ctpop(0i128), 0);\n \n         assert_eq!(ctpop(1u8), 1); assert_eq!(ctpop(1i8), 1);\n         assert_eq!(ctpop(1u16), 1); assert_eq!(ctpop(1i16), 1);\n         assert_eq!(ctpop(1u32), 1); assert_eq!(ctpop(1i32), 1);\n         assert_eq!(ctpop(1u64), 1); assert_eq!(ctpop(1i64), 1);\n+        assert_eq!(ctpop(1u128), 1); assert_eq!(ctpop(1i128), 1);\n \n         assert_eq!(ctpop(10u8), 2); assert_eq!(ctpop(10i8), 2);\n         assert_eq!(ctpop(10u16), 2); assert_eq!(ctpop(10i16), 2);\n         assert_eq!(ctpop(10u32), 2); assert_eq!(ctpop(10i32), 2);\n         assert_eq!(ctpop(10u64), 2); assert_eq!(ctpop(10i64), 2);\n+        assert_eq!(ctpop(10u128), 2); assert_eq!(ctpop(10i128), 2);\n \n         assert_eq!(ctpop(100u8), 3); assert_eq!(ctpop(100i8), 3);\n         assert_eq!(ctpop(100u16), 3); assert_eq!(ctpop(100i16), 3);\n         assert_eq!(ctpop(100u32), 3); assert_eq!(ctpop(100i32), 3);\n         assert_eq!(ctpop(100u64), 3); assert_eq!(ctpop(100i64), 3);\n+        assert_eq!(ctpop(100u128), 3); assert_eq!(ctpop(100i128), 3);\n \n         assert_eq!(ctpop(-1i8 as u8), 8); assert_eq!(ctpop(-1i8), 8);\n         assert_eq!(ctpop(-1i16 as u16), 16); assert_eq!(ctpop(-1i16), 16);\n         assert_eq!(ctpop(-1i32 as u32), 32); assert_eq!(ctpop(-1i32), 32);\n         assert_eq!(ctpop(-1i64 as u64), 64); assert_eq!(ctpop(-1i64), 64);\n+        assert_eq!(ctpop(-1i128 as u128), 128); assert_eq!(ctpop(-1i128), 128);\n \n         assert_eq!(ctlz(0u8), 8); assert_eq!(ctlz(0i8), 8);\n         assert_eq!(ctlz(0u16), 16); assert_eq!(ctlz(0i16), 16);\n         assert_eq!(ctlz(0u32), 32); assert_eq!(ctlz(0i32), 32);\n         assert_eq!(ctlz(0u64), 64); assert_eq!(ctlz(0i64), 64);\n+        assert_eq!(ctlz(0u128), 128); assert_eq!(ctlz(0i128), 128);\n \n         assert_eq!(ctlz(1u8), 7); assert_eq!(ctlz(1i8), 7);\n         assert_eq!(ctlz(1u16), 15); assert_eq!(ctlz(1i16), 15);\n         assert_eq!(ctlz(1u32), 31); assert_eq!(ctlz(1i32), 31);\n         assert_eq!(ctlz(1u64), 63); assert_eq!(ctlz(1i64), 63);\n+        assert_eq!(ctlz(1u128), 127); assert_eq!(ctlz(1i128), 127);\n \n         assert_eq!(ctlz(10u8), 4); assert_eq!(ctlz(10i8), 4);\n         assert_eq!(ctlz(10u16), 12); assert_eq!(ctlz(10i16), 12);\n         assert_eq!(ctlz(10u32), 28); assert_eq!(ctlz(10i32), 28);\n         assert_eq!(ctlz(10u64), 60); assert_eq!(ctlz(10i64), 60);\n+        assert_eq!(ctlz(10u128), 124); assert_eq!(ctlz(10i128), 124);\n \n         assert_eq!(ctlz(100u8), 1); assert_eq!(ctlz(100i8), 1);\n         assert_eq!(ctlz(100u16), 9); assert_eq!(ctlz(100i16), 9);\n         assert_eq!(ctlz(100u32), 25); assert_eq!(ctlz(100i32), 25);\n         assert_eq!(ctlz(100u64), 57); assert_eq!(ctlz(100i64), 57);\n+        assert_eq!(ctlz(100u128), 121); assert_eq!(ctlz(100i128), 121);\n \n         assert_eq!(ctlz_nonzero(1u8), 7); assert_eq!(ctlz_nonzero(1i8), 7);\n         assert_eq!(ctlz_nonzero(1u16), 15); assert_eq!(ctlz_nonzero(1i16), 15);\n         assert_eq!(ctlz_nonzero(1u32), 31); assert_eq!(ctlz_nonzero(1i32), 31);\n         assert_eq!(ctlz_nonzero(1u64), 63); assert_eq!(ctlz_nonzero(1i64), 63);\n+        assert_eq!(ctlz_nonzero(1u128), 127); assert_eq!(ctlz_nonzero(1i128), 127);\n \n         assert_eq!(ctlz_nonzero(10u8), 4); assert_eq!(ctlz_nonzero(10i8), 4);\n         assert_eq!(ctlz_nonzero(10u16), 12); assert_eq!(ctlz_nonzero(10i16), 12);\n         assert_eq!(ctlz_nonzero(10u32), 28); assert_eq!(ctlz_nonzero(10i32), 28);\n         assert_eq!(ctlz_nonzero(10u64), 60); assert_eq!(ctlz_nonzero(10i64), 60);\n+        assert_eq!(ctlz_nonzero(10u128), 124); assert_eq!(ctlz_nonzero(10i128), 124);\n \n         assert_eq!(ctlz_nonzero(100u8), 1); assert_eq!(ctlz_nonzero(100i8), 1);\n         assert_eq!(ctlz_nonzero(100u16), 9); assert_eq!(ctlz_nonzero(100i16), 9);\n         assert_eq!(ctlz_nonzero(100u32), 25); assert_eq!(ctlz_nonzero(100i32), 25);\n         assert_eq!(ctlz_nonzero(100u64), 57); assert_eq!(ctlz_nonzero(100i64), 57);\n+        assert_eq!(ctlz_nonzero(100u128), 121); assert_eq!(ctlz_nonzero(100i128), 121);\n \n         assert_eq!(cttz(-1i8 as u8), 0); assert_eq!(cttz(-1i8), 0);\n         assert_eq!(cttz(-1i16 as u16), 0); assert_eq!(cttz(-1i16), 0);\n         assert_eq!(cttz(-1i32 as u32), 0); assert_eq!(cttz(-1i32), 0);\n         assert_eq!(cttz(-1i64 as u64), 0); assert_eq!(cttz(-1i64), 0);\n+        assert_eq!(cttz(-1i128 as u128), 0); assert_eq!(cttz(-1i128), 0);\n \n         assert_eq!(cttz(0u8), 8); assert_eq!(cttz(0i8), 8);\n         assert_eq!(cttz(0u16), 16); assert_eq!(cttz(0i16), 16);\n         assert_eq!(cttz(0u32), 32); assert_eq!(cttz(0i32), 32);\n         assert_eq!(cttz(0u64), 64); assert_eq!(cttz(0i64), 64);\n+        assert_eq!(cttz(0u128), 128); assert_eq!(cttz(0i128), 128);\n \n         assert_eq!(cttz(1u8), 0); assert_eq!(cttz(1i8), 0);\n         assert_eq!(cttz(1u16), 0); assert_eq!(cttz(1i16), 0);\n         assert_eq!(cttz(1u32), 0); assert_eq!(cttz(1i32), 0);\n         assert_eq!(cttz(1u64), 0); assert_eq!(cttz(1i64), 0);\n+        assert_eq!(cttz(1u128), 0); assert_eq!(cttz(1i128), 0);\n \n         assert_eq!(cttz(10u8), 1); assert_eq!(cttz(10i8), 1);\n         assert_eq!(cttz(10u16), 1); assert_eq!(cttz(10i16), 1);\n         assert_eq!(cttz(10u32), 1); assert_eq!(cttz(10i32), 1);\n         assert_eq!(cttz(10u64), 1); assert_eq!(cttz(10i64), 1);\n+        assert_eq!(cttz(10u128), 1); assert_eq!(cttz(10i128), 1);\n \n         assert_eq!(cttz(100u8), 2); assert_eq!(cttz(100i8), 2);\n         assert_eq!(cttz(100u16), 2); assert_eq!(cttz(100i16), 2);\n         assert_eq!(cttz(100u32), 2); assert_eq!(cttz(100i32), 2);\n         assert_eq!(cttz(100u64), 2); assert_eq!(cttz(100i64), 2);\n+        assert_eq!(cttz(100u128), 2); assert_eq!(cttz(100i128), 2);\n \n         assert_eq!(cttz_nonzero(-1i8 as u8), 0); assert_eq!(cttz_nonzero(-1i8), 0);\n         assert_eq!(cttz_nonzero(-1i16 as u16), 0); assert_eq!(cttz_nonzero(-1i16), 0);\n         assert_eq!(cttz_nonzero(-1i32 as u32), 0); assert_eq!(cttz_nonzero(-1i32), 0);\n         assert_eq!(cttz_nonzero(-1i64 as u64), 0); assert_eq!(cttz_nonzero(-1i64), 0);\n+        assert_eq!(cttz_nonzero(-1i128 as u128), 0); assert_eq!(cttz_nonzero(-1i128), 0);\n \n         assert_eq!(cttz_nonzero(1u8), 0); assert_eq!(cttz_nonzero(1i8), 0);\n         assert_eq!(cttz_nonzero(1u16), 0); assert_eq!(cttz_nonzero(1i16), 0);\n         assert_eq!(cttz_nonzero(1u32), 0); assert_eq!(cttz_nonzero(1i32), 0);\n         assert_eq!(cttz_nonzero(1u64), 0); assert_eq!(cttz_nonzero(1i64), 0);\n+        assert_eq!(cttz_nonzero(1u128), 0); assert_eq!(cttz_nonzero(1i128), 0);\n \n         assert_eq!(cttz_nonzero(10u8), 1); assert_eq!(cttz_nonzero(10i8), 1);\n         assert_eq!(cttz_nonzero(10u16), 1); assert_eq!(cttz_nonzero(10i16), 1);\n         assert_eq!(cttz_nonzero(10u32), 1); assert_eq!(cttz_nonzero(10i32), 1);\n         assert_eq!(cttz_nonzero(10u64), 1); assert_eq!(cttz_nonzero(10i64), 1);\n+        assert_eq!(cttz_nonzero(10u128), 1); assert_eq!(cttz_nonzero(10i128), 1);\n \n         assert_eq!(cttz_nonzero(100u8), 2); assert_eq!(cttz_nonzero(100i8), 2);\n         assert_eq!(cttz_nonzero(100u16), 2); assert_eq!(cttz_nonzero(100i16), 2);\n         assert_eq!(cttz_nonzero(100u32), 2); assert_eq!(cttz_nonzero(100i32), 2);\n         assert_eq!(cttz_nonzero(100u64), 2); assert_eq!(cttz_nonzero(100i64), 2);\n+        assert_eq!(cttz_nonzero(100u128), 2); assert_eq!(cttz_nonzero(100i128), 2);\n \n         assert_eq!(bswap(0x0Au8), 0x0A); // no-op\n         assert_eq!(bswap(0x0Ai8), 0x0A); // no-op\n@@ -138,5 +160,18 @@ pub fn main() {\n         assert_eq!(bswap(0x0ABBCC0Di32), 0x0DCCBB0A);\n         assert_eq!(bswap(0x0122334455667708u64), 0x0877665544332201);\n         assert_eq!(bswap(0x0122334455667708i64), 0x0877665544332201);\n+        assert_eq!(bswap(0x0122334455667708u128), 0x08776655443322010000000000000000);\n+        assert_eq!(bswap(0x0122334455667708i128), 0x08776655443322010000000000000000);\n+\n+        assert_eq!(bitreverse(0x0Au8), 0x50);\n+        assert_eq!(bitreverse(0x0Ai8), 0x50);\n+        assert_eq!(bitreverse(0x0A0Cu16), 0x3050);\n+        assert_eq!(bitreverse(0x0A0Ci16), 0x3050);\n+        assert_eq!(bitreverse(0x0ABBCC0Eu32), 0x7033DD50);\n+        assert_eq!(bitreverse(0x0ABBCC0Ei32), 0x7033DD50);\n+        assert_eq!(bitreverse(0x0122334455667708u64), 0x10EE66AA22CC4480);\n+        assert_eq!(bitreverse(0x0122334455667708i64), 0x10EE66AA22CC4480);\n+        assert_eq!(bitreverse(0x0122334455667708u128), 0x10EE66AA22CC44800000000000000000);\n+        assert_eq!(bitreverse(0x0122334455667708i128), 0x10EE66AA22CC44800000000000000000);\n     }\n }"}, {"sha": "ece58eedc56eebf7755a012d61c50badb469c714", "filename": "src/test/run-pass/issue-36053.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Frun-pass%2Fissue-36053.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Frun-pass%2Fissue-36053.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-36053.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -14,7 +14,6 @@\n // `FusedIterator` in std but I was not able to isolate that into an\n // external crate.\n \n-#![feature(fused)]\n use std::iter::FusedIterator;\n \n struct Thing<'a>(&'a str);"}, {"sha": "4dfa5037bc5551373a94232f5ce1e16b99c6796a", "filename": "src/test/ui/cast_char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fcast_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fcast_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast_char.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -12,9 +12,9 @@\n \n fn main() {\n     const XYZ: char = 0x1F888 as char;\n-    //~^ ERROR only u8 can be casted into char\n+    //~^ ERROR only u8 can be cast into char\n     const XY: char = 129160 as char;\n-    //~^ ERROR only u8 can be casted into char\n+    //~^ ERROR only u8 can be cast into char\n     const ZYX: char = '\\u{01F888}';\n     println!(\"{}\", XYZ);\n }"}, {"sha": "600d7e61a0986018af5515c29684555ca361efc6", "filename": "src/test/ui/cast_char.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fcast_char.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fcast_char.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast_char.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -1,4 +1,4 @@\n-error: only u8 can be casted into char\n+error: only u8 can be cast into char\n   --> $DIR/cast_char.rs:14:23\n    |\n LL |     const XYZ: char = 0x1F888 as char;\n@@ -10,7 +10,7 @@ note: lint level defined here\n LL | #![deny(overflowing_literals)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: only u8 can be casted into char\n+error: only u8 can be cast into char\n   --> $DIR/cast_char.rs:16:22\n    |\n LL |     const XY: char = 129160 as char;"}, {"sha": "257b9bd235d763a4f4fdb04f0235693a489b3624", "filename": "src/test/ui/issue-22644.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fissue-22644.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fissue-22644.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-22644.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -5,7 +5,7 @@ LL |     println!(\"{}\", a as usize < long_name); //~ ERROR `<` is interpreted as\n    |                    ---------- ^ --------- interpreted as generic arguments\n    |                    |          |\n    |                    |          not interpreted as comparison\n-   |                    help: try comparing the casted value: `(a as usize)`\n+   |                    help: try comparing the cast value: `(a as usize)`\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n   --> $DIR/issue-22644.rs:17:33\n@@ -14,7 +14,7 @@ LL |     println!(\"{}{}\", a as usize < long_name, long_name);\n    |                      ---------- ^ -------------------- interpreted as generic arguments\n    |                      |          |\n    |                      |          not interpreted as comparison\n-   |                      help: try comparing the casted value: `(a as usize)`\n+   |                      help: try comparing the cast value: `(a as usize)`\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n   --> $DIR/issue-22644.rs:19:31\n@@ -23,7 +23,7 @@ LL |     println!(\"{}\", a as usize < 4); //~ ERROR `<` is interpreted as a start\n    |                    ---------- ^ - interpreted as generic arguments\n    |                    |          |\n    |                    |          not interpreted as comparison\n-   |                    help: try comparing the casted value: `(a as usize)`\n+   |                    help: try comparing the cast value: `(a as usize)`\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n   --> $DIR/issue-22644.rs:21:31\n@@ -32,7 +32,7 @@ LL |     println!(\"{}{}\", a: usize < long_name, long_name);\n    |                      -------- ^ -------------------- interpreted as generic arguments\n    |                      |        |\n    |                      |        not interpreted as comparison\n-   |                      help: try comparing the casted value: `(a: usize)`\n+   |                      help: try comparing the cast value: `(a: usize)`\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n   --> $DIR/issue-22644.rs:23:29\n@@ -41,7 +41,7 @@ LL |     println!(\"{}\", a: usize < 4); //~ ERROR `<` is interpreted as a start o\n    |                    -------- ^ - interpreted as generic arguments\n    |                    |        |\n    |                    |        not interpreted as comparison\n-   |                    help: try comparing the casted value: `(a: usize)`\n+   |                    help: try comparing the cast value: `(a: usize)`\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n   --> $DIR/issue-22644.rs:28:20\n@@ -50,7 +50,7 @@ LL |                    < //~ ERROR `<` is interpreted as a start of generic\n    |                    ^ not interpreted as comparison\n LL |                    4);\n    |                    - interpreted as generic arguments\n-help: try comparing the casted value\n+help: try comparing the cast value\n    |\n LL |     println!(\"{}\", (a\n LL |                    as\n@@ -64,7 +64,7 @@ LL |                    < //~ ERROR `<` is interpreted as a start of generic\n    |                    ^ not interpreted as comparison\n LL |                    5);\n    |                    - interpreted as generic arguments\n-help: try comparing the casted value\n+help: try comparing the cast value\n    |\n LL |     println!(\"{}\", (a\n LL | \n@@ -81,7 +81,7 @@ LL |     println!(\"{}\", a as usize << long_name); //~ ERROR `<` is interpreted a\n    |                    ---------- ^^ --------- interpreted as generic arguments\n    |                    |          |\n    |                    |          not interpreted as shift\n-   |                    help: try shifting the casted value: `(a as usize)`\n+   |                    help: try shifting the cast value: `(a as usize)`\n \n error: expected type, found `4`\n   --> $DIR/issue-22644.rs:42:28"}, {"sha": "9164434006f6170f39dfd1f9aec281b2dc3b2f67", "filename": "src/test/ui/issue-42954.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fissue-42954.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fissue-42954.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-42954.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -5,7 +5,7 @@ LL |         $i as u32 < 0 //~ `<` is interpreted as a start of generic argument\n    |         --------- ^ - interpreted as generic arguments\n    |         |         |\n    |         |         not interpreted as comparison\n-   |         help: try comparing the casted value: `($i as u32)`\n+   |         help: try comparing the cast value: `($i as u32)`\n ...\n LL |     is_plainly_printable!(c);\n    |     ------------------------- in this macro invocation"}, {"sha": "495989587e58571a61a97dbc320289dd3a5c3eae", "filename": "src/test/ui/lint/type-overflow.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(i128_type)]\n+\n+fn main() {\n+    let error = 255i8; //~WARNING literal out of range for i8\n+\n+    let ok = 0b1000_0001; // should be ok -> i32\n+    let ok = 0b0111_1111i8; // should be ok -> 127i8\n+\n+    let fail = 0b1000_0001i8; //~WARNING literal out of range for i8\n+\n+    let fail = 0x8000_0000_0000_0000i64; //~WARNING literal out of range for i64\n+\n+    let fail = 0x1_FFFF_FFFFu32; //~WARNING literal out of range for u32\n+\n+    let fail: i128 = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n+    //~^ WARNING literal out of range for i128\n+\n+    let fail = 0x8FFF_FFFF_FFFF_FFFE; //~WARNING literal out of range for i32\n+\n+    let fail = -0b1111_1111i8; //~WARNING literal out of range for i8\n+}"}, {"sha": "d3fcb1335e20968e4ff28f98be747b39d32cdfbe", "filename": "src/test/ui/lint/type-overflow.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,58 @@\n+warning: literal out of range for i8\n+  --> $DIR/type-overflow.rs:16:17\n+   |\n+LL |     let error = 255i8; //~WARNING literal out of range for i8\n+   |                 ^^^^^\n+   |\n+   = note: #[warn(overflowing_literals)] on by default\n+\n+warning: literal out of range for i8\n+  --> $DIR/type-overflow.rs:21:16\n+   |\n+LL |     let fail = 0b1000_0001i8; //~WARNING literal out of range for i8\n+   |                ^^^^^^^^^^^^^ help: consider using `u8` instead: `0b1000_0001u8`\n+   |\n+   = note: the literal `0b1000_0001i8` (decimal `129`) does not fit into an `i8` and will become `-127i8`\n+\n+warning: literal out of range for i64\n+  --> $DIR/type-overflow.rs:23:16\n+   |\n+LL |     let fail = 0x8000_0000_0000_0000i64; //~WARNING literal out of range for i64\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `u64` instead: `0x8000_0000_0000_0000u64`\n+   |\n+   = note: the literal `0x8000_0000_0000_0000i64` (decimal `9223372036854775808`) does not fit into an `i64` and will become `-9223372036854775808i64`\n+\n+warning: literal out of range for u32\n+  --> $DIR/type-overflow.rs:25:16\n+   |\n+LL |     let fail = 0x1_FFFF_FFFFu32; //~WARNING literal out of range for u32\n+   |                ^^^^^^^^^^^^^^^^ help: consider using `u64` instead: `0x1_FFFF_FFFFu64`\n+   |\n+   = note: the literal `0x1_FFFF_FFFFu32` (decimal `8589934591`) does not fit into an `u32` and will become `4294967295u32`\n+\n+warning: literal out of range for i128\n+  --> $DIR/type-overflow.rs:27:22\n+   |\n+LL |     let fail: i128 = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0x8000_0000_0000_0000_0000_0000_0000_0000` (decimal `170141183460469231731687303715884105728`) does not fit into an `i128` and will become `-170141183460469231731687303715884105728i128`\n+   = help: consider using `u128` instead\n+\n+warning: literal out of range for i32\n+  --> $DIR/type-overflow.rs:30:16\n+   |\n+LL |     let fail = 0x8FFF_FFFF_FFFF_FFFE; //~WARNING literal out of range for i32\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the literal `0x8FFF_FFFF_FFFF_FFFE` (decimal `10376293541461622782`) does not fit into an `i32` and will become `-2i32`\n+   = help: consider using `i128` instead\n+\n+warning: literal out of range for i8\n+  --> $DIR/type-overflow.rs:32:17\n+   |\n+LL |     let fail = -0b1111_1111i8; //~WARNING literal out of range for i8\n+   |                 ^^^^^^^^^^^^^ help: consider using `i16` instead: `0b1111_1111i16`\n+   |\n+   = note: the literal `0b1111_1111i8` (decimal `255`) does not fit into an `i8` and will become `-1i8`\n+"}, {"sha": "785a38da95980362949f8860eb3bed590f91214e", "filename": "src/test/ui/nll/borrowed-local-error.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Znll-dump-cause\n+\n+#![feature(nll)]\n+\n+fn gimme(x: &(u32,)) -> &u32 {\n+    &x.0\n+}\n+\n+fn main() {\n+    let x = gimme({\n+        let v = (22,);\n+        &v\n+        //~^ ERROR `v` does not live long enough [E0597]\n+    });\n+    println!(\"{:?}\", x);\n+}"}, {"sha": "3bc1978554821af639a2e80917c29d6ab8587d94", "filename": "src/test/ui/nll/borrowed-local-error.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-local-error.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,17 @@\n+error[E0597]: `v` does not live long enough\n+  --> $DIR/borrowed-local-error.rs:22:9\n+   |\n+LL |       let x = gimme({\n+   |  _____________-\n+LL | |         let v = (22,);\n+LL | |         &v\n+   | |         ^^ borrowed value does not live long enough\n+LL | |         //~^ ERROR `v` does not live long enough [E0597]\n+LL | |     });\n+   | |_____-- borrow later used here\n+   |       |\n+   |       borrowed value only lives until here\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0597\""}, {"sha": "e1a6112d173f9d469a03cadf9097bd158d3078bb", "filename": "src/test/ui/nll/borrowed-temporary-error.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Znll-dump-cause\n+\n+#![feature(nll)]\n+\n+fn gimme(x: &(u32,)) -> &u32 {\n+    &x.0\n+}\n+\n+fn main() {\n+    let x = gimme({\n+        let v = 22;\n+        &(v,)\n+        //~^ ERROR borrowed value does not live long enough [E0597]\n+    });\n+    println!(\"{:?}\", x);\n+}"}, {"sha": "f5cb1dccc378639f066fd67c3b98d0c6bc86ba76", "filename": "src/test/ui/nll/borrowed-temporary-error.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-temporary-error.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,14 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/borrowed-temporary-error.rs:22:10\n+   |\n+LL |         &(v,)\n+   |          ^^^^ temporary value does not live long enough\n+LL |         //~^ ERROR borrowed value does not live long enough [E0597]\n+LL |     });\n+   |       - temporary value only lives until here\n+LL |     println!(\"{:?}\", x);\n+   |                      - borrow later used here\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0597\""}, {"sha": "da03a9fc39b632adb7d07e95e58801f4a94ea18e", "filename": "src/test/ui/nll/borrowed-universal-error-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Znll-dump-cause\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n+    let v = 22;\n+    &v\n+    //~^ ERROR `v` does not live long enough [E0597]\n+}\n+\n+fn main() {}"}, {"sha": "ff999a71e0f92e603e420ba8b699cd436dff117a", "filename": "src/test/ui/nll/borrowed-universal-error-2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error-2.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,18 @@\n+error[E0597]: `v` does not live long enough\n+  --> $DIR/borrowed-universal-error-2.rs:18:5\n+   |\n+LL |     &v\n+   |     ^^ borrowed value does not live long enough\n+LL |     //~^ ERROR `v` does not live long enough [E0597]\n+LL | }\n+   | - borrowed value only lives until here\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 16:1...\n+  --> $DIR/borrowed-universal-error-2.rs:16:1\n+   |\n+LL | fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0597\""}, {"sha": "fdc4c29071ee9500ca523b5d679365ac06a65adc", "filename": "src/test/ui/nll/borrowed-universal-error.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Znll-dump-cause\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+fn gimme(x: &(u32,)) -> &u32 {\n+    &x.0\n+}\n+\n+fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n+    let v = 22;\n+    gimme(&(v,))\n+    //~^ ERROR borrowed value does not live long enough [E0597]\n+}\n+\n+fn main() {}"}, {"sha": "4a3d0c6d959fce2de0ac19212c74cb577614b09d", "filename": "src/test/ui/nll/borrowed-universal-error.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-universal-error.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,18 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/borrowed-universal-error.rs:22:12\n+   |\n+LL |     gimme(&(v,))\n+   |            ^^^^ temporary value does not live long enough\n+LL |     //~^ ERROR borrowed value does not live long enough [E0597]\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the function body at 20:1...\n+  --> $DIR/borrowed-universal-error.rs:20:1\n+   |\n+LL | fn foo<'a>(x: &'a (u32,)) -> &'a u32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0597\""}, {"sha": "1c545906893a232c24436ae134940cc5806c7c71", "filename": "src/test/ui/nll/capture-ref-in-struct.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -9,8 +9,6 @@ LL |     }\n LL | \n LL |     deref(p);\n    |           - borrow later used here\n-   |\n-   = note: borrowed value must be valid for lifetime '_#5r...\n \n error: aborting due to previous error\n "}, {"sha": "18ffdc5834975ae703a741b25848f798eba660ef", "filename": "src/test/ui/nll/closure-requirements/escape-argument.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -34,8 +34,6 @@ LL |     }\n LL | \n LL |     deref(p);\n    |           - borrow later used here\n-   |\n-   = note: borrowed value must be valid for lifetime '_#6r...\n \n error: aborting due to previous error\n "}, {"sha": "7b2b2f748726c95f9ce0306b922e89f4bd03c647", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -61,8 +61,6 @@ LL |       }\n LL | \n LL |       deref(p);\n    |             - borrow later used here\n-   |\n-   = note: borrowed value must be valid for lifetime '_#4r...\n \n error: aborting due to previous error\n "}, {"sha": "0a45603a42cd08d6c593cae1fbe408048ec59c18", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -38,8 +38,6 @@ LL |     }\n LL | \n LL |     deref(p);\n    |           - borrow later used here\n-   |\n-   = note: borrowed value must be valid for lifetime '_#4r...\n \n error: aborting due to previous error\n "}, {"sha": "21ed421fe96ca80e52355e77a62e37e76500724f", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -78,8 +78,6 @@ LL |     let cell = Cell::new(&a);\n ...\n LL | }\n    | - borrowed value only lives until here\n-   |\n-   = note: borrowed value must be valid for lifetime '_#2r...\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c77e0772ce962bc12653dbe4be16f93b084d83ba", "filename": "src/test/ui/nll/return-ref-mut-issue-46557.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -6,8 +6,6 @@ LL |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long en\n LL |     x\n LL | }\n    | - temporary value only lives until here\n-   |\n-   = note: borrowed value must be valid for lifetime '_#2r...\n \n error: aborting due to previous error\n "}, {"sha": "f1eb91d44fda0f7ef530566e89235dc180e1e6f2", "filename": "src/test/ui/raw_string.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw_string.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = r##\"lol\"#;\n+    //~^ ERROR unterminated raw string\n+}"}, {"sha": "b8aa596ef953a19230f426244f896517ce5c12ed", "filename": "src/test/ui/raw_string.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fraw_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftest%2Fui%2Fraw_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw_string.stderr?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -0,0 +1,8 @@\n+error: unterminated raw string\n+  --> $DIR/raw_string.rs:12:13\n+   |\n+LL |     let x = r##\"lol\"#;\n+   |             ^ unterminated raw string\n+   |\n+   = note: this raw string should be terminated with `\"##`\n+"}, {"sha": "cf63cb2e5d9014f4000eb1e58ea729aadd3b33c2", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -43,7 +43,6 @@ const ARCH_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"mips\", \"mips\"),\n     (\"msp430\", \"msp430\"),\n     (\"powerpc\", \"powerpc\"),\n-    (\"powerpc64\", \"powerpc64\"),\n     (\"s390x\", \"s390x\"),\n     (\"sparc\", \"sparc\"),\n     (\"x86_64\", \"x86_64\"),"}, {"sha": "f7b491823f838b3584c32f4e8d52545aff987813", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -2,3 +2,8 @@\n name = \"tidy\"\n version = \"0.1.0\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+\n+[dependencies]\n+serde = \"1.0.8\"\n+serde_derive = \"1.0.8\"\n+serde_json = \"1.0.2\""}, {"sha": "f40c7a72a452ec63e97267dc5af8fb16108ab585", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 222, "deletions": 26, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -10,9 +10,13 @@\n \n //! Check license of third-party deps by inspecting src/vendor\n \n+use std::collections::{BTreeSet, HashSet};\n use std::fs::File;\n use std::io::Read;\n use std::path::Path;\n+use std::process::Command;\n+\n+use serde_json;\n \n static LICENSES: &'static [&'static str] = &[\n     \"MIT/Apache-2.0\",\n@@ -24,52 +28,182 @@ static LICENSES: &'static [&'static str] = &[\n     \"Unlicense/MIT\",\n ];\n \n-// These are exceptions to Rust's permissive licensing policy, and\n-// should be considered bugs. Exceptions are only allowed in Rust\n-// tooling. It is _crucial_ that no exception crates be dependencies\n-// of the Rust runtime (std / test).\n+/// These are exceptions to Rust's permissive licensing policy, and\n+/// should be considered bugs. Exceptions are only allowed in Rust\n+/// tooling. It is _crucial_ that no exception crates be dependencies\n+/// of the Rust runtime (std / test).\n static EXCEPTIONS: &'static [&'static str] = &[\n-    \"mdbook\", // MPL2, mdbook\n-    \"openssl\", // BSD+advertising clause, cargo, mdbook\n-    \"pest\", // MPL2, mdbook via handlebars\n-    \"thread-id\", // Apache-2.0, mdbook\n-    \"toml-query\", // MPL-2.0, mdbook\n-    \"is-match\", // MPL-2.0, mdbook\n-    \"cssparser\", // MPL-2.0, rustdoc\n-    \"smallvec\", // MPL-2.0, rustdoc\n+    \"mdbook\",             // MPL2, mdbook\n+    \"openssl\",            // BSD+advertising clause, cargo, mdbook\n+    \"pest\",               // MPL2, mdbook via handlebars\n+    \"thread-id\",          // Apache-2.0, mdbook\n+    \"toml-query\",         // MPL-2.0, mdbook\n+    \"is-match\",           // MPL-2.0, mdbook\n+    \"cssparser\",          // MPL-2.0, rustdoc\n+    \"smallvec\",           // MPL-2.0, rustdoc\n     \"fuchsia-zircon-sys\", // BSD-3-Clause, rustdoc, rustc, cargo\n-    \"fuchsia-zircon\", // BSD-3-Clause, rustdoc, rustc, cargo (jobserver & tempdir)\n-    \"cssparser-macros\", // MPL-2.0, rustdoc\n-    \"selectors\", // MPL-2.0, rustdoc\n-    \"clippy_lints\", // MPL-2.0 rls\n+    \"fuchsia-zircon\",     // BSD-3-Clause, rustdoc, rustc, cargo (jobserver & tempdir)\n+    \"cssparser-macros\",   // MPL-2.0, rustdoc\n+    \"selectors\",          // MPL-2.0, rustdoc\n+    \"clippy_lints\",       // MPL-2.0 rls\n+];\n+\n+/// Which crates to check against the whitelist?\n+static WHITELIST_CRATES: &'static [CrateVersion] = &[\n+    CrateVersion(\"rustc\", \"0.0.0\"),\n+    CrateVersion(\"rustc_trans\", \"0.0.0\"),\n ];\n \n+/// Whitelist of crates rustc is allowed to depend on. Avoid adding to the list if possible.\n+static WHITELIST: &'static [Crate] = &[\n+    Crate(\"ar\"),\n+    Crate(\"backtrace\"),\n+    Crate(\"backtrace-sys\"),\n+    Crate(\"bitflags\"),\n+    Crate(\"byteorder\"),\n+    Crate(\"cc\"),\n+    Crate(\"cfg-if\"),\n+    Crate(\"cmake\"),\n+    Crate(\"ena\"),\n+    Crate(\"filetime\"),\n+    Crate(\"flate2\"),\n+    Crate(\"fuchsia-zircon\"),\n+    Crate(\"fuchsia-zircon-sys\"),\n+    Crate(\"jobserver\"),\n+    Crate(\"kernel32-sys\"),\n+    Crate(\"lazy_static\"),\n+    Crate(\"libc\"),\n+    Crate(\"log\"),\n+    Crate(\"log_settings\"),\n+    Crate(\"miniz-sys\"),\n+    Crate(\"num_cpus\"),\n+    Crate(\"owning_ref\"),\n+    Crate(\"parking_lot\"),\n+    Crate(\"parking_lot_core\"),\n+    Crate(\"rand\"),\n+    Crate(\"redox_syscall\"),\n+    Crate(\"rustc-demangle\"),\n+    Crate(\"smallvec\"),\n+    Crate(\"stable_deref_trait\"),\n+    Crate(\"tempdir\"),\n+    Crate(\"unicode-width\"),\n+    Crate(\"winapi\"),\n+    Crate(\"winapi-build\"),\n+    Crate(\"winapi-i686-pc-windows-gnu\"),\n+    Crate(\"winapi-x86_64-pc-windows-gnu\"),\n+];\n+\n+// Some types for Serde to deserialize the output of `cargo metadata` to...\n+\n+#[derive(Deserialize)]\n+struct Output {\n+    resolve: Resolve,\n+}\n+\n+#[derive(Deserialize)]\n+struct Resolve {\n+    nodes: Vec<ResolveNode>,\n+}\n+\n+#[derive(Deserialize)]\n+struct ResolveNode {\n+    id: String,\n+    dependencies: Vec<String>,\n+}\n+\n+/// A unique identifier for a crate\n+#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Hash)]\n+struct Crate<'a>(&'a str); // (name,)\n+\n+#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Hash)]\n+struct CrateVersion<'a>(&'a str, &'a str); // (name, version)\n+\n+impl<'a> Crate<'a> {\n+    pub fn id_str(&self) -> String {\n+        format!(\"{} \", self.0)\n+    }\n+}\n+\n+impl<'a> CrateVersion<'a> {\n+    /// Returns the struct and whether or not the dep is in-tree\n+    pub fn from_str(s: &'a str) -> (Self, bool) {\n+        let mut parts = s.split(\" \");\n+        let name = parts.next().unwrap();\n+        let version = parts.next().unwrap();\n+        let path = parts.next().unwrap();\n+\n+        let is_path_dep = path.starts_with(\"(path+\");\n+\n+        (CrateVersion(name, version), is_path_dep)\n+    }\n+\n+    pub fn id_str(&self) -> String {\n+        format!(\"{} {}\", self.0, self.1)\n+    }\n+}\n+\n+impl<'a> From<CrateVersion<'a>> for Crate<'a> {\n+    fn from(cv: CrateVersion<'a>) -> Crate<'a> {\n+        Crate(cv.0)\n+    }\n+}\n+\n+/// Checks the dependency at the given path. Changes `bad` to `true` if a check failed.\n+///\n+/// Specifically, this checks that the license is correct.\n pub fn check(path: &Path, bad: &mut bool) {\n+    // Check licences\n     let path = path.join(\"vendor\");\n     assert!(path.exists(), \"vendor directory missing\");\n     let mut saw_dir = false;\n-    'next_path: for dir in t!(path.read_dir()) {\n+    for dir in t!(path.read_dir()) {\n         saw_dir = true;\n         let dir = t!(dir);\n \n         // skip our exceptions\n-        for exception in EXCEPTIONS {\n-            if dir.path()\n+        if EXCEPTIONS.iter().any(|exception| {\n+            dir.path()\n                 .to_str()\n                 .unwrap()\n-                .contains(&format!(\"src/vendor/{}\", exception)) {\n-                continue 'next_path;\n-            }\n+                .contains(&format!(\"src/vendor/{}\", exception))\n+        }) {\n+            continue;\n         }\n \n         let toml = dir.path().join(\"Cargo.toml\");\n-        if !check_license(&toml) {\n-            *bad = true;\n-        }\n+        *bad = *bad || !check_license(&toml);\n     }\n     assert!(saw_dir, \"no vendored source\");\n }\n \n+/// Checks the dependency of WHITELIST_CRATES at the given path. Changes `bad` to `true` if a check\n+/// failed.\n+///\n+/// Specifically, this checks that the dependencies are on the WHITELIST.\n+pub fn check_whitelist(path: &Path, cargo: &Path, bad: &mut bool) {\n+    // Get dependencies from cargo metadata\n+    let resolve = get_deps(path, cargo);\n+\n+    // Get the whitelist into a convenient form\n+    let whitelist: HashSet<_> = WHITELIST.iter().cloned().collect();\n+\n+    // Check dependencies\n+    let mut visited = BTreeSet::new();\n+    let mut unapproved = BTreeSet::new();\n+    for &krate in WHITELIST_CRATES.iter() {\n+        let mut bad = check_crate_whitelist(&whitelist, &resolve, &mut visited, krate, false);\n+        unapproved.append(&mut bad);\n+    }\n+\n+    if unapproved.len() > 0 {\n+        println!(\"Dependencies not on the whitelist:\");\n+        for dep in unapproved {\n+            println!(\"* {}\", dep.id_str());\n+        }\n+        *bad = true;\n+    }\n+}\n+\n fn check_license(path: &Path) -> bool {\n     if !path.exists() {\n         panic!(\"{} does not exist\", path.display());\n@@ -102,9 +236,71 @@ fn extract_license(line: &str) -> String {\n     let first_quote = line.find('\"');\n     let last_quote = line.rfind('\"');\n     if let (Some(f), Some(l)) = (first_quote, last_quote) {\n-        let license = &line[f + 1 .. l];\n+        let license = &line[f + 1..l];\n         license.into()\n     } else {\n         \"bad-license-parse\".into()\n     }\n }\n+\n+/// Get the dependencies of the crate at the given path using `cargo metadata`.\n+fn get_deps(path: &Path, cargo: &Path) -> Resolve {\n+    // Run `cargo metadata` to get the set of dependencies\n+    let output = Command::new(cargo)\n+        .arg(\"metadata\")\n+        .arg(\"--format-version\")\n+        .arg(\"1\")\n+        .arg(\"--manifest-path\")\n+        .arg(path.join(\"Cargo.toml\"))\n+        .output()\n+        .expect(\"Unable to run `cargo metadata`\")\n+        .stdout;\n+    let output = String::from_utf8_lossy(&output);\n+    let output: Output = serde_json::from_str(&output).unwrap();\n+\n+    output.resolve\n+}\n+\n+/// Checks the dependencies of the given crate from the given cargo metadata to see if they are on\n+/// the whitelist. Returns a list of illegal dependencies.\n+fn check_crate_whitelist<'a, 'b>(\n+    whitelist: &'a HashSet<Crate>,\n+    resolve: &'a Resolve,\n+    visited: &'b mut BTreeSet<CrateVersion<'a>>,\n+    krate: CrateVersion<'a>,\n+    must_be_on_whitelist: bool,\n+) -> BTreeSet<Crate<'a>> {\n+    // Will contain bad deps\n+    let mut unapproved = BTreeSet::new();\n+\n+    // Check if we have already visited this crate\n+    if visited.contains(&krate) {\n+        return unapproved;\n+    }\n+\n+    visited.insert(krate);\n+\n+    // If this path is in-tree, we don't require it to be on the whitelist\n+    if must_be_on_whitelist {\n+        // If this dependency is not on the WHITELIST, add to bad set\n+        if !whitelist.contains(&krate.into()) {\n+            unapproved.insert(krate.into());\n+        }\n+    }\n+\n+    // Do a DFS in the crate graph (it's a DAG, so we know we have no cycles!)\n+    let to_check = resolve\n+        .nodes\n+        .iter()\n+        .find(|n| n.id.starts_with(&krate.id_str()))\n+        .expect(\"crate does not exist\");\n+\n+    for dep in to_check.dependencies.iter() {\n+        let (krate, is_path_dep) = CrateVersion::from_str(dep);\n+\n+        let mut bad = check_crate_whitelist(whitelist, resolve, visited, krate, !is_path_dep);\n+        unapproved.append(&mut bad);\n+    }\n+\n+    unapproved\n+}"}, {"sha": "c927ff19b279bc15af8f4e804d0596650c0298a4", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -15,6 +15,11 @@\n \n #![deny(warnings)]\n \n+extern crate serde;\n+extern crate serde_json;\n+#[macro_use]\n+extern crate serde_derive;\n+\n use std::fs;\n \n use std::path::Path;"}, {"sha": "afa3ebd198319c681427dd3a58301e4410ab7eda", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=06bad6a441f9ab1f8b8139c4934da4ac2c7bb9df", "patch": "@@ -24,9 +24,12 @@ use std::path::PathBuf;\n use std::env;\n \n fn main() {\n-    let path = env::args_os().skip(1).next().expect(\"need an argument\");\n+    let path = env::args_os().skip(1).next().expect(\"need path to src\");\n     let path = PathBuf::from(path);\n \n+    let cargo = env::args_os().skip(2).next().expect(\"need path to cargo\");\n+    let cargo = PathBuf::from(cargo);\n+\n     let args: Vec<String> = env::args().skip(1).collect();\n \n     let mut bad = false;\n@@ -41,6 +44,7 @@ fn main() {\n     if !args.iter().any(|s| *s == \"--no-vendor\") {\n         deps::check(&path, &mut bad);\n     }\n+    deps::check_whitelist(&path, &cargo, &mut bad);\n \n     if bad {\n         eprintln!(\"some tidy checks failed\");"}]}