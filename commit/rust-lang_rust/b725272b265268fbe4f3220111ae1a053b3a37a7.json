{"sha": "b725272b265268fbe4f3220111ae1a053b3a37a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MjUyNzJiMjY1MjY4ZmJlNGYzMjIwMTExYWUxYTA1M2IzYTM3YTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-17T13:52:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T11:55:29Z"}, "message": "port if-then-else to use `CoerceMany`", "tree": {"sha": "4883fca91ad45f30dcee7ff67969e16cddcea9aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4883fca91ad45f30dcee7ff67969e16cddcea9aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b725272b265268fbe4f3220111ae1a053b3a37a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b725272b265268fbe4f3220111ae1a053b3a37a7", "html_url": "https://github.com/rust-lang/rust/commit/b725272b265268fbe4f3220111ae1a053b3a37a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b725272b265268fbe4f3220111ae1a053b3a37a7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56847af9163284f928d5632a3d0d29399716414f", "url": "https://api.github.com/repos/rust-lang/rust/commits/56847af9163284f928d5632a3d0d29399716414f", "html_url": "https://github.com/rust-lang/rust/commit/56847af9163284f928d5632a3d0d29399716414f"}], "stats": {"total": 71, "additions": 34, "deletions": 37}, "files": [{"sha": "69f1466c475186e9bbfb938d83c98a7d23b703de", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b725272b265268fbe4f3220111ae1a053b3a37a7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b725272b265268fbe4f3220111ae1a053b3a37a7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b725272b265268fbe4f3220111ae1a053b3a37a7", "patch": "@@ -77,6 +77,7 @@ type parameter).\n */\n \n pub use self::Expectation::*;\n+use self::coercion::CoerceMany;\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n@@ -299,12 +300,23 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n         }\n     }\n \n+    /// It sometimes happens that we want to turn an expectation into\n+    /// a **hard constraint** (i.e., something that must be satisfied\n+    /// for the program to type-check). `only_has_type` will return\n+    /// such a constraint, if it exists.\n     fn only_has_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             ExpectHasType(ty) => Some(ty),\n             _ => None\n         }\n     }\n+\n+    /// Like `only_has_type`, but instead of returning `None` if no\n+    /// hard constraint exists, creates a fresh type variable.\n+    fn only_has_type_or_fresh_var(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, span: Span) -> Ty<'tcx> {\n+        self.only_has_type(fcx)\n+            .unwrap_or_else(|| fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span)))\n+    }\n }\n \n #[derive(Copy, Clone)]\n@@ -2743,54 +2755,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let then_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n-        let unit = self.tcx.mk_nil();\n-        let (cause, expected_ty, found_ty, result);\n+        // We've already taken the expected type's preferences\n+        // into account when typing the `then` branch. To figure\n+        // out the initial shot at a LUB, we thus only consider\n+        // `expected` if it represents a *hard* constraint\n+        // (`only_has_type`); otherwise, we just go with a\n+        // fresh type variable.\n+        let coerce_to_ty = expected.only_has_type_or_fresh_var(self, sp);\n+        let mut coerce = CoerceMany::new(coerce_to_ty);\n+\n+        let if_cause = self.cause(sp, ObligationCauseCode::IfExpression);\n+        coerce.coerce(self, &if_cause, then_expr, then_ty);\n+\n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n-            cause = self.cause(sp, ObligationCauseCode::IfExpression);\n-\n-            // Only try to coerce-unify if we have a then expression\n-            // to assign coercions to, otherwise it's () or diverging.\n-            expected_ty = then_ty;\n-            found_ty = else_ty;\n-\n-            let coerce_to = expected.only_has_type(self).unwrap_or(then_ty);\n-            result = {\n-                self.try_coerce(then_expr, then_ty, coerce_to)\n-                    .and_then(|t| {\n-                        self.try_find_coercion_lub(&cause, || Some(then_expr), t, else_expr, else_ty)\n-                    })\n-            };\n+\n+            coerce.coerce(self, &if_cause, else_expr, else_ty);\n \n             // We won't diverge unless both branches do (or the condition does).\n             self.diverges.set(cond_diverges | then_diverges & else_diverges);\n         } else {\n+            let else_cause = self.cause(sp, ObligationCauseCode::IfExpressionWithNoElse);\n+            coerce.coerce_forced_unit(self, &else_cause);\n+\n             // If the condition is false we can't diverge.\n             self.diverges.set(cond_diverges);\n-\n-            cause = self.cause(sp, ObligationCauseCode::IfExpressionWithNoElse);\n-            expected_ty = unit;\n-            found_ty = then_ty;\n-            result = self.eq_types(true, &cause, unit, then_ty)\n-                         .map(|ok| {\n-                             self.register_infer_ok_obligations(ok);\n-                             unit\n-                         });\n         }\n \n-        match result {\n-            Ok(ty) => {\n-                if cond_ty.references_error() {\n-                    self.tcx.types.err\n-                } else {\n-                    ty\n-                }\n-            }\n-            Err(e) => {\n-                self.report_mismatched_types(&cause, expected_ty, found_ty, e).emit();\n-                self.tcx.types.err\n-            }\n+        let result_ty = coerce.complete(self);\n+        if cond_ty.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            result_ty\n         }\n     }\n "}]}