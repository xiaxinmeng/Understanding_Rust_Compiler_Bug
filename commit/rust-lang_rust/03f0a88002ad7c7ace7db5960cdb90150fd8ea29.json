{"sha": "03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZjBhODgwMDJhZDdjN2FjZTdkYjU5NjBjZGI5MDE1MGZkOGVhMjk=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-04T12:33:15Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-11T10:28:11Z"}, "message": "Use a wrapper type to differentiate between PrimVal and pointers", "tree": {"sha": "1dc04aa54b999097591305eeeb7ab5dc9a8ce292", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dc04aa54b999097591305eeeb7ab5dc9a8ce292"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIyBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAllkqDsACgkQpp+NIls6\n19l+eg/4p97lEvw7gimrMC/EdQ8RV2WhIq1l5iEeSy/ED4txs4H3TMff99n3+7lQ\nM39/OZoclsA36TK+Hbauhnb6Jb2z2RJ2LetkJqAZ78mapwQStKVYzmyX8fgNdSHg\nYG58zxIIe2G3I9E0lgT0KWmo+Y7BAqDlPn1FqRnFuV+NJ8KZ3LgZrIhvdbdP2rDt\nNpLxxbNhifJNLttwsP+c0H8W5g1ob7Dy7+blIgeuceILlRm0ORHdmqV1aCWsF3p2\nJ4NKCCfDNL6j80Wv4vA0qOLcffMGD1vwmAlhT9hKwk/2OjO0ZcuHBIFfcWmozxtE\nHRgxkUMyna7TfEOeDiwxVq42TkAmHn0zGHRR1gF8wwxOWEskK8y3t+vzJnxFDfkM\nTNLJ56wXv9acJHpjXroUyDLCtn7tgPvWpMFjatHx89Knj5wnteM4Foq4kc4GuhCX\nMibKofQQhsn6rivkKmPAr6BhKqtDPu6Ct5+q2m+WFzztFOctWO7HrC5qXZtn8a+3\nE50FmPME8dTyeST7b+fV051fFdYFB1O+TbIWBfrZ4Ov287I+at3u8ape8qAz1kTi\nDHPTTWJoxIJX7417hEvmIPPbdb/vAXlmAriL4n1fwKWB9zTvRVvRYuSThk0umKCJ\nfnRXTVH9xHHnRTXe3ulRaJIP3hZnhWow7c5dyUWjDr68M1LDaA==\n=/3AG\n-----END PGP SIGNATURE-----", "payload": "tree 1dc04aa54b999097591305eeeb7ab5dc9a8ce292\nparent a8b957a0f86c1d7b6636caaad006a8f538a317dd\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1499171595 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1499768891 +0200\n\nUse a wrapper type to differentiate between PrimVal and pointers\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "html_url": "https://github.com/rust-lang/rust/commit/03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8b957a0f86c1d7b6636caaad006a8f538a317dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8b957a0f86c1d7b6636caaad006a8f538a317dd", "html_url": "https://github.com/rust-lang/rust/commit/a8b957a0f86c1d7b6636caaad006a8f538a317dd"}], "stats": {"total": 278, "additions": 170, "deletions": 108}, "files": [{"sha": "8a1e991628f6d59878c906530ed58f50548b9518", "filename": "src/eval_context.rs", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "patch": "@@ -19,7 +19,7 @@ use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n use memory::{Memory, MemoryPointer, TlsKey};\n use operator;\n-use value::{PrimVal, PrimValKind, Value};\n+use value::{PrimVal, PrimValKind, Value, Pointer};\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n@@ -395,7 +395,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n                     let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                     let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                    self.write_primval(dest, ptr, ty)?;\n+                    self.write_ptr(dest, ptr, ty)?;\n                 }\n             }\n         }\n@@ -444,7 +444,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n \n         let dest = Lvalue::Ptr {\n-            ptr: PrimVal::Ptr(dest_ptr),\n+            ptr: dest_ptr.into(),\n             extra: LvalueExtra::DowncastVariant(variant_idx),\n         };\n \n@@ -580,7 +580,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                     let operand_ty = self.operand_ty(operand);\n                                     assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n-                                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                                self.write_null(dest, dest_ty)?;\n                             }\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n@@ -662,7 +662,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n-                let dest = PrimVal::Ptr(self.force_allocation(dest)?.to_ptr()?);\n+                let dest = Pointer::from(self.force_allocation(dest)?.to_ptr()?);\n \n                 for i in 0..length {\n                     let elem_dest = dest.offset(i * elem_size, self.memory.layout)?;\n@@ -686,9 +686,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = self.lvalue_ty(lvalue);\n \n                 let val = match extra {\n-                    LvalueExtra::None => Value::ByVal(ptr),\n-                    LvalueExtra::Length(len) => Value::ByValPair(ptr, PrimVal::from_u128(len as u128)),\n-                    LvalueExtra::Vtable(vtable) => Value::ByValPair(ptr, PrimVal::Ptr(vtable)),\n+                    LvalueExtra::None => ptr.to_value(),\n+                    LvalueExtra::Length(len) => ptr.with_extra(PrimVal::from_u128(len as u128)),\n+                    LvalueExtra::Vtable(vtable) => ptr.with_extra(PrimVal::Ptr(vtable)),\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 };\n@@ -928,14 +928,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn wrapping_pointer_offset(&self, ptr: PrimVal, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, PrimVal> {\n+    pub(super) fn wrapping_pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n         let offset = offset.overflowing_mul(pointee_size).0;\n         ptr.wrapping_signed_offset(offset, self.memory.layout)\n     }\n \n-    pub(super) fn pointer_offset(&self, ptr: PrimVal, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, PrimVal> {\n+    pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n         // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n         // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n         // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n@@ -949,7 +949,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n             let ptr = ptr.signed_offset(offset, self.memory.layout)?;\n             // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n-            if let PrimVal::Ptr(ptr) = ptr {\n+            if let PrimVal::Ptr(ptr) = ptr.into_inner_primval() {\n                 self.memory.check_bounds(ptr, false)?;\n             } else if ptr.is_null()? {\n                 // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n \n-    fn copy(&mut self, src: PrimVal, dest: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n+    fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         let size = self.type_size(ty)?.expect(\"cannot copy from an unsized type\");\n         let align = self.type_align(ty)?;\n         self.memory.copy(src, dest, size, align, false)?;\n@@ -1026,8 +1026,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let substs = self.stack[frame].instance.substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n-                        self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(PrimVal::Ptr(ptr))); // it stays live\n-                        self.write_value_to_ptr(val, PrimVal::Ptr(ptr), ty)?;\n+                        self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(ptr.into())); // it stays live\n+                        self.write_value_to_ptr(val, ptr.into(), ty)?;\n                         Lvalue::from_ptr(ptr)\n                     }\n                 }\n@@ -1040,14 +1040,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.instance.substs)?;\n                         self.memory.mark_static(ptr.alloc_id);\n-                        self.write_value_to_ptr(global_val.value, PrimVal::Ptr(ptr), global_val.ty)?;\n+                        self.write_value_to_ptr(global_val.value, ptr.into(), global_val.ty)?;\n                         // see comment on `initialized` field\n                         if global_val.initialized {\n                             self.memory.mark_static_initalized(ptr.alloc_id, global_val.mutable)?;\n                         }\n                         let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n                         *lval = Global {\n-                            value: Value::ByRef(PrimVal::Ptr(ptr)),\n+                            value: Value::ByRef(ptr.into()),\n                             .. global_val\n                         };\n                         Lvalue::from_ptr(ptr)\n@@ -1087,6 +1087,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.write_primval(dest, PrimVal::Bytes(0), dest_ty)\n     }\n \n+    pub(super) fn write_ptr(\n+        &mut self,\n+        dest: Lvalue<'tcx>,\n+        val: Pointer,\n+        dest_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        self.write_value(val.to_value(), dest, dest_ty)\n+    }\n+\n     pub(super) fn write_primval(\n         &mut self,\n         dest: Lvalue<'tcx>,\n@@ -1172,9 +1181,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             if let Ok(Some(src_val)) = self.try_read_value(src_ptr, dest_ty) {\n                 write_dest(self, src_val)?;\n             } else {\n-                let dest_ptr = self.alloc_ptr(dest_ty)?;\n-                self.copy(src_ptr, PrimVal::Ptr(dest_ptr), dest_ty)?;\n-                write_dest(self, Value::ByRef(PrimVal::Ptr(dest_ptr)))?;\n+                let dest_ptr = self.alloc_ptr(dest_ty)?.into();\n+                self.copy(src_ptr, dest_ptr, dest_ty)?;\n+                write_dest(self, Value::ByRef(dest_ptr))?;\n             }\n \n         } else {\n@@ -1188,7 +1197,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn write_value_to_ptr(\n         &mut self,\n         value: Value,\n-        dest: PrimVal,\n+        dest: Pointer,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match value {\n@@ -1218,8 +1227,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let field_1_ty = self.get_field_ty(ty, 1)?;\n         let field_0_size = self.type_size(field_0_ty)?.expect(\"pair element type must be sized\");\n         let field_1_size = self.type_size(field_1_ty)?.expect(\"pair element type must be sized\");\n-        self.memory.write_primval(PrimVal::Ptr(ptr.offset(field_0, self.memory.layout)?), a, field_0_size)?;\n-        self.memory.write_primval(PrimVal::Ptr(ptr.offset(field_1, self.memory.layout)?), b, field_1_size)?;\n+        self.memory.write_primval(ptr.offset(field_0, self.memory.layout)?.into(), a, field_0_size)?;\n+        self.memory.write_primval(ptr.offset(field_1, self.memory.layout)?.into(), b, field_1_size)?;\n         Ok(())\n     }\n \n@@ -1322,7 +1331,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn read_value(&mut self, ptr: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, ty)? {\n             Ok(val)\n         } else {\n@@ -1333,21 +1342,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(crate) fn read_ptr(&self, ptr: MemoryPointer, pointee_ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         let p = self.memory.read_ptr(ptr)?;\n         if self.type_is_sized(pointee_ty) {\n-            Ok(Value::ByVal(p))\n+            Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n             let extra = ptr.offset(self.memory.pointer_size(), self.memory.layout)?;\n             let extra = match self.tcx.struct_tail(pointee_ty).sty {\n-                ty::TyDynamic(..) => self.memory.read_ptr(extra)?,\n+                ty::TyDynamic(..) => self.memory.read_ptr(extra)?.into_inner_primval(),\n                 ty::TySlice(..) |\n                 ty::TyStr => PrimVal::from_u128(self.memory.read_usize(extra)? as u128),\n                 _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n             };\n-            Ok(Value::ByValPair(p, extra))\n+            Ok(p.with_extra(extra))\n         }\n     }\n \n-    fn try_read_value(&mut self, ptr: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    fn try_read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         use syntax::ast::FloatTy;\n \n         let val = match ty.sty {\n@@ -1373,7 +1382,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // if we transmute a ptr to an isize, reading it back into a primval shouldn't panic\n                 // Due to read_ptr ignoring the sign, we need to jump around some hoops\n                 match self.memory.read_int(ptr.to_ptr()?, size) {\n-                    Err(EvalError::ReadPointerAsBytes) if size == self.memory.pointer_size() => self.memory.read_ptr(ptr.to_ptr()?)?,\n+                    Err(EvalError::ReadPointerAsBytes) if size == self.memory.pointer_size() => self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n                     other => PrimVal::from_i128(other?),\n                 }\n             }\n@@ -1390,7 +1399,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 if size == self.memory.pointer_size() {\n                     // if we transmute a ptr to an usize, reading it back into a primval shouldn't panic\n-                    self.memory.read_ptr(ptr.to_ptr()?)?\n+                    self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval()\n                 } else {\n                     PrimVal::from_u128(self.memory.read_uint(ptr.to_ptr()?, size)?)\n                 }\n@@ -1399,7 +1408,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr.to_ptr()?)?),\n             ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr.to_ptr()?)?),\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr(ptr.to_ptr()?)?,\n+            ty::TyFnPtr(_) => self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n             ty::TyRef(_, ref tam) |\n             ty::TyRawPtr(ref tam) => return self.read_ptr(ptr.to_ptr()?, tam.ty).map(Some),\n \n@@ -1458,7 +1467,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                 let ptr = src.read_ptr(&self.memory)?;\n                 let len = PrimVal::from_u128(length as u128);\n-                self.write_value(Value::ByValPair(ptr, len), dest, dest_ty)\n+                self.write_value(ptr.with_extra(len), dest, dest_ty)\n             }\n             (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n                 // For now, upcasts are limited to changes in marker\n@@ -1472,7 +1481,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n                 let ptr = src.read_ptr(&self.memory)?;\n                 let extra = PrimVal::Ptr(vtable);\n-                self.write_value(Value::ByValPair(ptr, extra), dest, dest_ty)\n+                self.write_value(ptr.with_extra(extra), dest, dest_ty)\n             },\n \n             _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n@@ -1532,7 +1541,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let src_f_ptr = src_ptr.offset(src_field_offset, self.memory.layout)?;\n                     let dst_f_ptr = dest.offset(dst_field_offset, self.memory.layout)?;\n                     if src_fty == dst_fty {\n-                        self.copy(src_f_ptr, PrimVal::Ptr(dst_f_ptr), src_fty)?;\n+                        self.copy(src_f_ptr, dst_f_ptr.into(), src_fty)?;\n                     } else {\n                         self.unsize_into(Value::ByRef(src_f_ptr), src_fty, Lvalue::from_ptr(dst_f_ptr), dst_fty)?;\n                     }\n@@ -1561,13 +1570,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Err(err) => {\n                     panic!(\"Failed to access local: {:?}\", err);\n                 }\n-                Ok(Value::ByRef(PrimVal::Ptr(ptr))) => {\n-                    write!(msg, \" by ref:\").unwrap();\n-                    allocs.push(ptr.alloc_id);\n-                }\n-                Ok(Value::ByRef(ptr)) => {\n-                    write!(msg, \" integral by ref: {:?}\", ptr).unwrap();\n-                }\n+                Ok(Value::ByRef(ptr)) => match ptr.into_inner_primval() {\n+                    PrimVal::Ptr(ptr) => {\n+                        write!(msg, \" by ref:\").unwrap();\n+                        allocs.push(ptr.alloc_id);\n+                    },\n+                    ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n+                },\n                 Ok(Value::ByVal(val)) => {\n                     write!(msg, \" {:?}\", val).unwrap();\n                     if let PrimVal::Ptr(ptr) = val { allocs.push(ptr.alloc_id); }"}, {"sha": "3eafe1d0eabb2822c98be003822c3d513b48d959", "filename": "src/lvalue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext};\n use memory::MemoryPointer;\n-use value::{PrimVal, Value};\n+use value::{PrimVal, Value, Pointer};\n \n #[derive(Copy, Clone, Debug)]\n pub enum Lvalue<'tcx> {\n@@ -15,7 +15,7 @@ pub enum Lvalue<'tcx> {\n         /// An lvalue may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n-        ptr: PrimVal,\n+        ptr: Pointer,\n         extra: LvalueExtra,\n     },\n \n@@ -64,18 +64,18 @@ pub struct Global<'tcx> {\n impl<'tcx> Lvalue<'tcx> {\n     /// Produces an Lvalue that will error if attempted to be read from\n     pub fn undef() -> Self {\n-        Self::from_primval_ptr(PrimVal::Undef)\n+        Self::from_primval_ptr(PrimVal::Undef.into())\n     }\n \n-    pub(crate) fn from_primval_ptr(ptr: PrimVal) -> Self {\n+    pub(crate) fn from_primval_ptr(ptr: Pointer) -> Self {\n         Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n     }\n \n     pub(crate) fn from_ptr(ptr: MemoryPointer) -> Self {\n-        Self::from_primval_ptr(PrimVal::Ptr(ptr))\n+        Self::from_primval_ptr(ptr.into())\n     }\n \n-    pub(super) fn to_ptr_and_extra(self) -> (PrimVal, LvalueExtra) {\n+    pub(super) fn to_ptr_and_extra(self) -> (Pointer, LvalueExtra) {\n         match self {\n             Lvalue::Ptr { ptr, extra } => (ptr, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Lvalue::Ptr, got {:?}\", self),\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let offset = match base_extra {\n             LvalueExtra::Vtable(tab) => {\n-                let (_, align) = self.size_and_align_of_dst(base_ty, Value::ByValPair(base_ptr, PrimVal::Ptr(tab)))?;\n+                let (_, align) = self.size_and_align_of_dst(base_ty, base_ptr.with_extra(PrimVal::Ptr(tab)))?;\n                 offset.abi_align(Align::from_bytes(align, align).unwrap()).bytes()\n             }\n             _ => offset.bytes(),"}, {"sha": "caf7f3a65161498821e8b6b1e1409ae36553e636", "filename": "src/memory.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "patch": "@@ -6,7 +6,7 @@ use rustc::ty;\n use rustc::ty::layout::{self, TargetDataLayout};\n \n use error::{EvalError, EvalResult};\n-use value::{PrimVal, self};\n+use value::{PrimVal, self, Pointer};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n@@ -87,7 +87,7 @@ pub type TlsKey = usize;\n \n #[derive(Copy, Clone, Debug)]\n pub struct TlsEntry<'tcx> {\n-    data: PrimVal, // Will eventually become a map from thread IDs to `PrimVal`s, if we ever support more than one thread.\n+    data: Pointer, // Will eventually become a map from thread IDs to `Pointer`s, if we ever support more than one thread.\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n@@ -223,7 +223,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: MemoryPointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64) -> EvalResult<'tcx, Pointer> {\n+    pub fn reallocate(&mut self, ptr: MemoryPointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64) -> EvalResult<'tcx, MemoryPointer> {\n         use std::cmp::min;\n \n         // TODO(solson): Report error about non-__rust_allocate'd pointer.\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n         let new_ptr = self.allocate(new_size, new_align)?;\n-        self.copy(PrimVal::Ptr(ptr), PrimVal::Ptr(new_ptr), min(old_size, new_size), min(old_align, new_align), /*nonoverlapping*/true)?;\n+        self.copy(ptr.into(), new_ptr.into(), min(old_size, new_size), min(old_align, new_align), /*nonoverlapping*/true)?;\n         self.deallocate(ptr, Some((old_size, old_align)))?;\n \n         Ok(new_ptr)\n@@ -278,8 +278,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.layout.endian\n     }\n \n-    pub fn check_align(&self, ptr: PrimVal, align: u64, len: u64) -> EvalResult<'tcx> {\n-        let offset = match ptr {\n+    pub fn check_align(&self, ptr: Pointer, align: u64, len: u64) -> EvalResult<'tcx> {\n+        let offset = match ptr.into_inner_primval() {\n             PrimVal::Ptr(ptr) => {\n                 let alloc = self.get(ptr.alloc_id)?;\n                 // check whether the memory was marked as packed\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub(crate) fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.next_thread_local;\n         self.next_thread_local += 1;\n-        self.thread_local.insert(new_key, TlsEntry { data: PrimVal::Bytes(0), dtor });\n+        self.thread_local.insert(new_key, TlsEntry { data: Pointer::null(), dtor });\n         trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n         return new_key;\n     }\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, PrimVal> {\n+    pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n         return match self.thread_local.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn store_tls(&mut self, key: TlsKey, new_data: PrimVal) -> EvalResult<'tcx> {\n+    pub(crate) fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n         return match self.thread_local.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n@@ -407,7 +407,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     /// with associated destructors, implementations may stop calling destructors,\n     /// or they may continue calling destructors until no non-NULL values with\n     /// associated destructors exist, even though this might result in an infinite loop.\n-    pub(crate) fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, PrimVal, TlsKey)>> {\n+    pub(crate) fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n         use std::collections::Bound::*;\n         let start = match key {\n             Some(key) => Excluded(key),\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             if !data.is_null()? {\n                 if let Some(dtor) = dtor {\n                     let ret = Some((dtor, *data, key));\n-                    *data = PrimVal::Bytes(0);\n+                    *data = Pointer::null();\n                     return Ok(ret);\n                 }\n             }\n@@ -575,7 +575,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n-        self.check_align(PrimVal::Ptr(ptr), align, size)?;\n+        // FIXME: check alignment for zst memory accesses?\n+        self.check_align(ptr.into(), align, size)?;\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -588,7 +589,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if size == 0 {\n             return Ok(&mut []);\n         }\n-        self.check_align(PrimVal::Ptr(ptr), align, size)?;\n+        // FIXME: check alignment for zst memory accesses?\n+        self.check_align(ptr.into(), align, size)?;\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -609,7 +611,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     fn get_bytes_mut(&mut self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size, 0);\n         self.clear_relocations(ptr, size)?;\n-        self.mark_definedness(PrimVal::Ptr(ptr), size, true)?;\n+        self.mark_definedness(ptr.into(), size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size, align)\n     }\n }\n@@ -661,7 +663,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn copy(&mut self, src: PrimVal, dest: PrimVal, size: u64, align: u64, nonoverlapping: bool) -> EvalResult<'tcx> {\n+    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64, nonoverlapping: bool) -> EvalResult<'tcx> {\n         if size == 0 {\n             // TODO: Should we check for alignment here? (Also see write_bytes intrinsic)\n             return Ok(());\n@@ -713,7 +715,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn read_bytes(&self, ptr: PrimVal, size: u64) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n@@ -729,7 +731,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: PrimVal, val: u8, count: u64) -> EvalResult<'tcx> {\n+    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n         if count == 0 {\n             return Ok(());\n         }\n@@ -738,10 +740,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn read_ptr(&self, ptr: MemoryPointer) -> EvalResult<'tcx, PrimVal> {\n+    pub fn read_ptr(&self, ptr: MemoryPointer) -> EvalResult<'tcx, Pointer> {\n         let size = self.pointer_size();\n         if self.check_defined(ptr, size).is_err() {\n-            return Ok(PrimVal::Undef);\n+            return Ok(PrimVal::Undef.into());\n         }\n         let endianess = self.endianess();\n         let bytes = self.get_bytes_unchecked(ptr, size, size)?;\n@@ -750,8 +752,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let offset = offset as u64;\n         let alloc = self.get(ptr.alloc_id)?;\n         match alloc.relocations.get(&ptr.offset) {\n-            Some(&alloc_id) => Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, offset))),\n-            None => Ok(PrimVal::Bytes(offset as u128)),\n+            Some(&alloc_id) => Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, offset)).into()),\n+            None => Ok(PrimVal::Bytes(offset as u128).into()),\n         }\n     }\n \n@@ -763,7 +765,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn write_primval(\n         &mut self,\n-        dest: PrimVal,\n+        dest: Pointer,\n         val: PrimVal,\n         size: u64,\n     ) -> EvalResult<'tcx> {\n@@ -970,7 +972,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn mark_definedness(\n         &mut self,\n-        ptr: PrimVal,\n+        ptr: Pointer,\n         size: u64,\n         new_state: bool\n     ) -> EvalResult<'tcx> {"}, {"sha": "47bd66641b1e8752d94beda2c69d7f4aca7b01e7", "filename": "src/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "patch": "@@ -158,8 +158,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             match bin_op {\n                 Offset if left_kind == Ptr && right_kind == usize => {\n                     let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-                    let ptr = self.pointer_offset(left, pointee_ty, right.to_bytes()? as i64)?;\n-                    return Ok((ptr, false));\n+                    let ptr = self.pointer_offset(left.into(), pointee_ty, right.to_bytes()? as i64)?;\n+                    return Ok((ptr.into_inner_primval(), false));\n                 },\n                 // These work on anything\n                 Eq if left_kind == right_kind => {"}, {"sha": "e035aa58fd152107bf452be2e989eaa8db901082", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "patch": "@@ -12,9 +12,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n         trace!(\"drop_lvalue: {:#?}\", lval);\n         let val = match self.force_allocation(lval)? {\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => Value::ByValPair(ptr, PrimVal::Ptr(vtable)),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => Value::ByValPair(ptr, PrimVal::Bytes(len as u128)),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => Value::ByVal(ptr),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => ptr.with_extra(PrimVal::Ptr(vtable)),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => ptr.with_extra(PrimVal::Bytes(len as u128)),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => ptr.to_value(),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span)"}, {"sha": "94c1bac459d6e55765ec9b4ffa00108faf2d2751", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::{self, Ty};\n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n use lvalue::{Lvalue, LvalueExtra};\n-use value::{PrimVal, PrimValKind, Value};\n+use value::{PrimVal, PrimValKind, Value, Pointer};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(\n@@ -46,7 +46,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n-                self.write_primval(dest, result_ptr, dest_ty)?;\n+                self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n \n             \"assume\" => {\n@@ -257,8 +257,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n                             Err(_) => {\n                                 let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n-                                this.memory.write_repeat(PrimVal::Ptr(ptr), 0, size)?;\n-                                Value::ByRef(PrimVal::Ptr(ptr))\n+                                let ptr = Pointer::from(PrimVal::Ptr(ptr));\n+                                this.memory.write_repeat(ptr, 0, size)?;\n+                                Value::ByRef(ptr)\n                             }\n                         },\n                         Value::ByVal(_) => Value::ByVal(PrimVal::Bytes(0)),\n@@ -307,7 +308,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n-                self.write_primval(dest, result_ptr, dest_ty)?;\n+                self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n \n             \"overflowing_sub\" => {\n@@ -397,7 +398,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.type_size(dest_ty)?.expect(\"transmute() type must be sized\");\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n                 self.memory.mark_packed(ptr, size);\n-                self.write_value_to_ptr(arg_vals[0], PrimVal::Ptr(ptr), src_ty)?;\n+                self.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)?;\n             }\n \n             \"unchecked_shl\" => {"}, {"sha": "9602e5798a7bc439d74eb20e2d2f7c38242e14d5", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "patch": "@@ -10,8 +10,7 @@ use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n use memory::{MemoryPointer, TlsKey};\n-use value::PrimVal;\n-use value::Value;\n+use value::{PrimVal, Value};\n use rustc_data_structures::indexed_vec::Idx;\n \n mod drop;\n@@ -569,7 +568,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let ptr = self.memory.allocate(size, align)?;\n-                self.memory.write_repeat(PrimVal::Ptr(ptr), 0, size)?;\n+                self.memory.write_repeat(ptr.into(), 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_dealloc\" => {\n@@ -705,7 +704,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n                 let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                self.write_primval(arg_dest, data, u8_ptr_ty)?;\n+                self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n \n                 // We ourselves return 0\n                 self.write_null(dest, dest_ty)?;\n@@ -744,7 +743,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(num - idx as u64 - 1, self.memory.layout)?;\n-                    self.write_primval(dest, new_ptr, dest_ty)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_null(dest, dest_ty)?;\n                 }\n@@ -756,7 +755,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(idx as u64, self.memory.layout)?;\n-                    self.write_primval(dest, new_ptr, dest_ty)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_null(dest, dest_ty)?;\n                 }\n@@ -865,15 +864,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"mmap\" => {\n                 // This is a horrible hack, but well... the guard page mechanism calls mmap and expects a particular return value, so we give it that value\n                 let addr = args[0].read_ptr(&self.memory)?;\n-                self.write_primval(dest, addr, dest_ty)?;\n+                self.write_ptr(dest, addr, dest_ty)?;\n             }\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n                 let key_ptr = args[0].read_ptr(&self.memory)?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match args[1].read_ptr(&self.memory)? {\n+                let dtor = match args[1].read_ptr(&self.memory)?.into_inner_primval() {\n                     PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n                     PrimVal::Bytes(0) => None,\n                     PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n@@ -910,7 +909,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n                 let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n                 let ptr = self.memory.load_tls(key)?;\n-                self.write_primval(dest, ptr, dest_ty)?;\n+                self.write_ptr(dest, ptr, dest_ty)?;\n             }\n             \"pthread_setspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t"}, {"sha": "e0937fcb836107be5f0eb7e85437b6742b72f394", "filename": "src/value.rs", "status": "modified", "additions": 69, "deletions": 18, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03f0a88002ad7c7ace7db5960cdb90150fd8ea29/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=03f0a88002ad7c7ace7db5960cdb90150fd8ea29", "patch": "@@ -33,11 +33,70 @@ pub(super) fn f64_to_bytes(f: f64) -> u128 {\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n pub enum Value {\n-    ByRef(PrimVal),\n+    ByRef(Pointer),\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n \n+/// A wrapper type around `PrimVal` that cannot be turned back into a `PrimVal` accidentally.\n+/// This type clears up a few APIs where having a `PrimVal` argument for something that is\n+/// potentially an integer pointer or a pointer to an allocation was unclear.\n+#[derive(Clone, Copy, Debug)]\n+pub struct Pointer {\n+    primval: PrimVal,\n+}\n+\n+impl<'tcx> Pointer {\n+    pub fn null() -> Self {\n+        PrimVal::Bytes(0).into()\n+    }\n+    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n+        self.primval.to_ptr()\n+    }\n+    pub fn into_inner_primval(self) -> PrimVal {\n+        self.primval\n+    }\n+\n+    pub(crate) fn signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+        self.primval.signed_offset(i, layout).map(Pointer::from)\n+    }\n+\n+    pub(crate) fn offset(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+        self.primval.offset(i, layout).map(Pointer::from)\n+    }\n+\n+    pub(crate) fn wrapping_signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+        self.primval.wrapping_signed_offset(i, layout).map(Pointer::from)\n+    }\n+\n+    pub fn is_null(self) -> EvalResult<'tcx, bool> {\n+        match self.primval {\n+            PrimVal::Bytes(b) => Ok(b == 0),\n+            PrimVal::Ptr(_) => Ok(false),\n+            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n+        }\n+    }\n+\n+    pub fn with_extra(self, extra: PrimVal) -> Value {\n+        Value::ByValPair(self.primval, extra)\n+    }\n+    pub fn to_value(self) -> Value {\n+        Value::ByVal(self.primval)\n+    }\n+}\n+\n+impl ::std::convert::From<PrimVal> for Pointer {\n+    fn from(primval: PrimVal) -> Self {\n+        Pointer { primval }\n+    }\n+}\n+\n+impl ::std::convert::From<MemoryPointer> for Pointer {\n+    fn from(ptr: MemoryPointer) -> Self {\n+        PrimVal::Ptr(ptr).into()\n+    }\n+}\n+\n /// A `PrimVal` represents an immediate, primitive value existing outside of a\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `PrimVal` can either represent the raw bytes\n@@ -69,18 +128,18 @@ pub enum PrimValKind {\n }\n \n impl<'a, 'tcx: 'a> Value {\n-    pub(super) fn read_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    pub(super) fn read_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr.to_ptr()?),\n-            ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr),\n+            ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.into()),\n         }\n     }\n \n     pub(super) fn expect_ptr_vtable_pair(\n         &self,\n         mem: &Memory<'a, 'tcx>\n-    ) -> EvalResult<'tcx, (PrimVal, MemoryPointer)> {\n+    ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr) => {\n@@ -89,13 +148,13 @@ impl<'a, 'tcx: 'a> Value {\n                 Ok((ptr, vtable.to_ptr()?))\n             }\n \n-            ByValPair(ptr, vtable) => Ok((ptr, vtable.to_ptr()?)),\n+            ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n \n             _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n         }\n     }\n \n-    pub(super) fn expect_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (PrimVal, u64)> {\n+    pub(super) fn expect_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr) => {\n@@ -106,7 +165,7 @@ impl<'a, 'tcx: 'a> Value {\n             ByValPair(ptr, val) => {\n                 let len = val.to_u128()?;\n                 assert_eq!(len as u64 as u128, len);\n-                Ok((ptr, len as u64))\n+                Ok((ptr.into(), len as u64))\n             },\n             ByVal(_) => unimplemented!(),\n         }\n@@ -220,15 +279,7 @@ impl<'tcx> PrimVal {\n         }\n     }\n \n-    pub fn is_null(self) -> EvalResult<'tcx, bool> {\n-        match self {\n-            PrimVal::Bytes(b) => Ok(b == 0),\n-            PrimVal::Ptr(_) => Ok(false),\n-            PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n-        }\n-    }\n-\n-    pub fn signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+    pub(crate) fn signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         match self {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n@@ -239,7 +290,7 @@ impl<'tcx> PrimVal {\n         }\n     }\n \n-    pub fn offset(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+    pub(crate) fn offset(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         match self {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);\n@@ -250,7 +301,7 @@ impl<'tcx> PrimVal {\n         }\n     }\n \n-    pub fn wrapping_signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n+    pub(crate) fn wrapping_signed_offset(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n         match self {\n             PrimVal::Bytes(b) => {\n                 assert_eq!(b as u64 as u128, b);"}]}