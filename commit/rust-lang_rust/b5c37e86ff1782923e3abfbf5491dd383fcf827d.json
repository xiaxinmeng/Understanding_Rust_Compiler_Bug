{"sha": "b5c37e86ff1782923e3abfbf5491dd383fcf827d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YzM3ZTg2ZmYxNzgyOTIzZTNhYmZiZjU0OTFkZDM4M2ZjZjgyN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-17T03:56:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-17T03:56:03Z"}, "message": "Auto merge of #78801 - sexxi-goose:min_capture, r=nikomatsakis\n\nRFC-2229: Implement Precise Capture Analysis\n\n### This PR introduces\n- Feature gate for RFC-2229 (incomplete) `capture_disjoint_field`\n- Rustc Attribute to print out the capture analysis `rustc_capture_analysis`\n- Precise capture analysis\n\n### Description of the analysis\n1. If the feature gate is not set then all variables that are not local to the closure will be added to the list of captures. (This is for backcompat)\n2. The rest of the analysis is based entirely on how the captured `Place`s are used within the closure. Precise information (i.e. projections) about the `Place` is maintained throughout.\n3. To reduce the amount of information we need to keep track of, we do a minimization step. In this step, we determine a list such that no Place within this list represents an ancestor path to another entry in the list.  Check rust-lang/project-rfc-2229#9 for more detailed examples.\n4. To keep the compiler functional as before we implement a Bridge between the results of this new analysis to existing data structures used for closure captures. Note the new capture analysis results are only part of MaybeTypeckTables that is the information is only available during typeck-ing.\n\n### Known issues\n- Statements like `let _ = x` will make the compiler ICE when used within a closure with the feature enabled. More generally speaking the issue is caused by `let` statements that create no bindings and are init'ed using a Place expression.\n\n### Testing\nWe removed the code that would handle the case where the feature gate is not set, to enable the feature as default and did a bors try and perf run. More information here: #78762\n\n### Thanks\nThis has been slowly in the works for a while now.\nI want to call out `@Azhng` `@ChrisPardy` `@null-sleep` `@jenniferwills` `@logmosier` `@roxelo` for working on this and the previous PRs that led up to this, `@nikomatsakis` for guiding us.\n\nCloses rust-lang/project-rfc-2229#7\nCloses rust-lang/project-rfc-2229#9\nCloses rust-lang/project-rfc-2229#6\nCloses rust-lang/project-rfc-2229#19\n\nr? `@nikomatsakis`", "tree": {"sha": "5f18499561c75efff7135b920d893c62949c2157", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f18499561c75efff7135b920d893c62949c2157"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5c37e86ff1782923e3abfbf5491dd383fcf827d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c37e86ff1782923e3abfbf5491dd383fcf827d", "html_url": "https://github.com/rust-lang/rust/commit/b5c37e86ff1782923e3abfbf5491dd383fcf827d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5c37e86ff1782923e3abfbf5491dd383fcf827d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b2b02a840f358bcadef5c3ae861d2852da20b3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b2b02a840f358bcadef5c3ae861d2852da20b3d", "html_url": "https://github.com/rust-lang/rust/commit/9b2b02a840f358bcadef5c3ae861d2852da20b3d"}, {"sha": "40dfe1eddd35d65348c40abe12dc5c659d068e2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/40dfe1eddd35d65348c40abe12dc5c659d068e2c", "html_url": "https://github.com/rust-lang/rust/commit/40dfe1eddd35d65348c40abe12dc5c659d068e2c"}], "stats": {"total": 2663, "additions": 2485, "deletions": 178}, "files": [{"sha": "a035507924794cd487d469c9efa71af8799d6a21", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -616,6 +616,9 @@ declare_features! (\n     /// Enables `#[cfg(panic = \"...\")]` config key.\n     (active, cfg_panic, \"1.49.0\", Some(77443), None),\n \n+    /// Allows capturing disjoint fields in a closure/generator (RFC 2229).\n+    (active, capture_disjoint_fields, \"1.49.0\", Some(53488), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -639,6 +642,7 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::inline_const,\n     sym::repr128,\n     sym::unsized_locals,\n+    sym::capture_disjoint_fields,\n ];\n \n /// Some features are not allowed to be used together at the same time, if"}, {"sha": "fa8edba629e929251663664c27440a68cd66e2dc", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -547,6 +547,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     rustc_attr!(TEST, rustc_outlives, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_variance, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\")),\n     rustc_attr!(TEST, rustc_regions, Normal, template!(Word)),"}, {"sha": "a5237ffaf78fc888c1439e7745e6546fc85d8524", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -415,6 +415,10 @@ pub struct TypeckResults<'tcx> {\n     /// entire variable.\n     pub closure_captures: ty::UpvarListMap,\n \n+    /// Tracks the minimum captures required for a closure;\n+    /// see `MinCaptureInformationMap` for more details.\n+    pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n+\n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n     pub generator_interior_types: Vec<GeneratorInteriorTypeCause<'tcx>>,\n@@ -442,6 +446,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             tainted_by_errors: None,\n             concrete_opaque_types: Default::default(),\n             closure_captures: Default::default(),\n+            closure_min_captures: Default::default(),\n             generator_interior_types: Default::default(),\n         }\n     }\n@@ -676,6 +681,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             tainted_by_errors,\n             ref concrete_opaque_types,\n             ref closure_captures,\n+            ref closure_min_captures,\n             ref generator_interior_types,\n         } = *self;\n \n@@ -709,6 +715,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             tainted_by_errors.hash_stable(hcx, hasher);\n             concrete_opaque_types.hash_stable(hcx, hasher);\n             closure_captures.hash_stable(hcx, hasher);\n+            closure_min_captures.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);\n         })\n     }"}, {"sha": "c39f66ec89661259b91ed551c7199d80364146be", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -6,6 +6,7 @@ pub use self::IntVarValue::*;\n pub use self::Variance::*;\n \n use crate::hir::exports::ExportMap;\n+use crate::hir::place::Place as HirPlace;\n use crate::ich::StableHashingContext;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n@@ -685,6 +686,12 @@ pub struct UpvarId {\n     pub closure_expr_id: LocalDefId,\n }\n \n+impl UpvarId {\n+    pub fn new(var_hir_id: hir::HirId, closure_def_id: LocalDefId) -> UpvarId {\n+        UpvarId { var_path: UpvarPath { hir_id: var_hir_id }, closure_expr_id: closure_def_id }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n@@ -767,6 +774,56 @@ pub struct UpvarBorrow<'tcx> {\n     pub region: ty::Region<'tcx>,\n }\n \n+/// Given the closure DefId this map provides a map of root variables to minimum\n+/// set of `CapturedPlace`s that need to be tracked to support all captures of that closure.\n+pub type MinCaptureInformationMap<'tcx> = FxHashMap<DefId, RootVariableMinCaptureList<'tcx>>;\n+\n+/// Part of `MinCaptureInformationMap`; Maps a root variable to the list of `CapturedPlace`.\n+/// Used to track the minimum set of `Place`s that need to be captured to support all\n+/// Places captured by the closure starting at a given root variable.\n+///\n+/// This provides a convenient and quick way of checking if a variable being used within\n+/// a closure is a capture of a local variable.\n+pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureList<'tcx>>;\n+\n+/// Part of `MinCaptureInformationMap`; List of `CapturePlace`s.\n+pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n+\n+/// A `Place` and the corresponding `CaptureInfo`.\n+#[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+pub struct CapturedPlace<'tcx> {\n+    pub place: HirPlace<'tcx>,\n+    pub info: CaptureInfo<'tcx>,\n+}\n+\n+/// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)\n+/// for a particular capture as well as identifying the part of the source code\n+/// that triggered this capture to occur.\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n+pub struct CaptureInfo<'tcx> {\n+    /// Expr Id pointing to use that resulted in selecting the current capture kind\n+    ///\n+    /// If the user doesn't enable feature `capture_disjoint_fields` (RFC 2229) then, it is\n+    /// possible that we don't see the use of a particular place resulting in expr_id being\n+    /// None. In such case we fallback on uvpars_mentioned for span.\n+    ///\n+    /// Eg:\n+    /// ```rust,no_run\n+    /// let x = 5;\n+    ///\n+    /// let c = || {\n+    ///     let _ = x\n+    /// };\n+    /// ```\n+    ///\n+    /// In this example, if `capture_disjoint_fields` is **not** set, then x will be captured,\n+    /// but we won't see it being used during capture analysis, since it's essentially a discard.\n+    pub expr_id: Option<hir::HirId>,\n+\n+    /// Capture mode that was selected\n+    pub capture_kind: UpvarCapture<'tcx>,\n+}\n+\n pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n "}, {"sha": "41f3edaa413800b965ca105e963fab6c78575c3e", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -383,16 +383,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.describe_field_from_ty(&ty, field, variant_index)\n                 }\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                    // `tcx.upvars_mentioned(def_id)` returns an `Option`, which is `None` in case\n-                    // the closure comes from another crate. But in that case we wouldn't\n-                    // be borrowck'ing it, so we can just unwrap:\n-                    let (&var_id, _) = self\n-                        .infcx\n-                        .tcx\n-                        .upvars_mentioned(def_id)\n-                        .unwrap()\n-                        .get_index(field.index())\n-                        .unwrap();\n+                    // We won't be borrowck'ing here if the closure came from another crate,\n+                    // so it's safe to call `expect_local`.\n+                    //\n+                    // We know the field exists so it's safe to call operator[] and `unwrap` here.\n+                    let (&var_id, _) =\n+                        self.infcx.tcx.typeck(def_id.expect_local()).closure_captures[&def_id]\n+                            .get_index(field.index())\n+                            .unwrap();\n \n                     self.infcx.tcx.hir().name(var_id).to_string()\n                 }\n@@ -967,9 +965,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {\n-            for ((upvar_hir_id, upvar), place) in\n-                self.infcx.tcx.upvars_mentioned(def_id)?.iter().zip(places)\n+            for (upvar_hir_id, place) in\n+                self.infcx.tcx.typeck(def_id.expect_local()).closure_captures[&def_id]\n+                    .keys()\n+                    .zip(places)\n             {\n+                let span = self.infcx.tcx.upvars_mentioned(local_did)?[upvar_hir_id].span;\n                 match place {\n                     Operand::Copy(place) | Operand::Move(place)\n                         if target_place == place.as_ref() =>\n@@ -991,7 +992,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         let usage_span =\n                             match self.infcx.tcx.typeck(local_did).upvar_capture(upvar_id) {\n                                 ty::UpvarCapture::ByValue(Some(span)) => span,\n-                                _ => upvar.span,\n+                                _ => span,\n                             };\n                         return Some((*args_span, generator_kind, usage_span));\n                     }"}, {"sha": "47c0400533bd828f1e46e8b2140a29843d6c8c7b", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -387,8 +387,9 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 }\n             };\n             let upvars = cx\n-                .tcx\n-                .upvars_mentioned(def_id)\n+                .typeck_results()\n+                .closure_captures\n+                .get(&def_id)\n                 .iter()\n                 .flat_map(|upvars| upvars.iter())\n                 .zip(substs.upvar_tys())"}, {"sha": "debb873beb93b9fbc90affa78a20036e4c302bde", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -317,19 +317,20 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n         // swap in a new set of IR maps for this body\n         let mut maps = IrMaps::new(self.tcx);\n         let hir_id = maps.tcx.hir().body_owner(body.id());\n-        let def_id = maps.tcx.hir().local_def_id(hir_id);\n+        let local_def_id = maps.tcx.hir().local_def_id(hir_id);\n+        let def_id = local_def_id.to_def_id();\n \n         // Don't run unused pass for #[derive()]\n-        if let Some(parent) = self.tcx.parent(def_id.to_def_id()) {\n+        if let Some(parent) = self.tcx.parent(def_id) {\n             if let DefKind::Impl = self.tcx.def_kind(parent.expect_local()) {\n                 if self.tcx.has_attr(parent, sym::automatically_derived) {\n                     return;\n                 }\n             }\n         }\n \n-        if let Some(upvars) = maps.tcx.upvars_mentioned(def_id) {\n-            for (&var_hir_id, _upvar) in upvars {\n+        if let Some(captures) = maps.tcx.typeck(local_def_id).closure_captures.get(&def_id) {\n+            for &var_hir_id in captures.keys() {\n                 let var_name = maps.tcx.hir().name(var_hir_id);\n                 maps.add_variable(Upvar(var_hir_id, var_name));\n             }\n@@ -340,7 +341,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n         intravisit::walk_body(&mut maps, body);\n \n         // compute liveness\n-        let mut lsets = Liveness::new(&mut maps, def_id);\n+        let mut lsets = Liveness::new(&mut maps, local_def_id);\n         let entry_ln = lsets.compute(&body, hir_id);\n         lsets.log_liveness(entry_ln, body.id().hir_id);\n \n@@ -397,10 +398,18 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n                 // construction site.\n                 let mut call_caps = Vec::new();\n                 let closure_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-                if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n-                    call_caps.extend(upvars.iter().map(|(&var_id, upvar)| {\n+                if let Some(captures) = self\n+                    .tcx\n+                    .typeck(closure_def_id)\n+                    .closure_captures\n+                    .get(&closure_def_id.to_def_id())\n+                {\n+                    // If closure captures is Some, upvars_mentioned must also be Some\n+                    let upvars = self.tcx.upvars_mentioned(closure_def_id).unwrap();\n+                    call_caps.extend(captures.keys().map(|var_id| {\n+                        let upvar = upvars[var_id];\n                         let upvar_ln = self.add_live_node(UpvarNode(upvar.span));\n-                        CaptureInfo { ln: upvar_ln, var_hid: var_id }\n+                        CaptureInfo { ln: upvar_ln, var_hid: *var_id }\n                     }));\n                 }\n                 self.set_captures(expr.hir_id, call_caps);\n@@ -564,6 +573,7 @@ struct Liveness<'a, 'tcx> {\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n+    closure_captures: Option<&'tcx FxIndexMap<hir::HirId, ty::UpvarId>>,\n     successors: IndexVec<LiveNode, Option<LiveNode>>,\n     rwu_table: RWUTable,\n \n@@ -587,6 +597,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let typeck_results = ir.tcx.typeck(body_owner);\n         let param_env = ir.tcx.param_env(body_owner);\n         let upvars = ir.tcx.upvars_mentioned(body_owner);\n+        let closure_captures = typeck_results.closure_captures.get(&body_owner.to_def_id());\n \n         let closure_ln = ir.add_live_node(ClosureNode);\n         let exit_ln = ir.add_live_node(ExitNode);\n@@ -600,6 +611,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             typeck_results,\n             param_env,\n             upvars,\n+            closure_captures,\n             successors: IndexVec::from_elem_n(None, num_live_nodes),\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n             closure_ln,\n@@ -850,14 +862,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // if they are live on the entry to the closure, since only the closure\n         // itself can access them on subsequent calls.\n \n-        if let Some(upvars) = self.upvars {\n+        if let Some(closure_captures) = self.closure_captures {\n             // Mark upvars captured by reference as used after closure exits.\n-            for (&var_hir_id, upvar) in upvars.iter().rev() {\n-                let upvar_id = ty::UpvarId {\n-                    var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                    closure_expr_id: self.body_owner,\n-                };\n-                match self.typeck_results.upvar_capture(upvar_id) {\n+            // Since closure_captures is Some, upvars must exists too.\n+            let upvars = self.upvars.unwrap();\n+            for (&var_hir_id, upvar_id) in closure_captures {\n+                let upvar = upvars[&var_hir_id];\n+                match self.typeck_results.upvar_capture(*upvar_id) {\n                     ty::UpvarCapture::ByRef(_) => {\n                         let var = self.variable(var_hir_id, upvar.span);\n                         self.acc(self.exit_ln, var, ACC_READ | ACC_USE);\n@@ -869,7 +880,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let succ = self.propagate_through_expr(&body.value, self.exit_ln);\n \n-        if self.upvars.is_none() {\n+        if self.closure_captures.is_none() {\n             // Either not a closure, or closure without any captured variables.\n             // No need to determine liveness of captured variables, since there\n             // are none.\n@@ -1341,7 +1352,21 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         acc: u32,\n     ) -> LiveNode {\n         match path.res {\n-            Res::Local(hid) => self.access_var(hir_id, hid, succ, acc, path.span),\n+            Res::Local(hid) => {\n+                let in_upvars = self.upvars.map_or(false, |u| u.contains_key(&hid));\n+                let in_captures = self.closure_captures.map_or(false, |c| c.contains_key(&hid));\n+\n+                match (in_upvars, in_captures) {\n+                    (false, _) | (true, true) => self.access_var(hir_id, hid, succ, acc, path.span),\n+                    (true, false) => {\n+                        // This case is possible when with RFC-2229, a wild pattern\n+                        // is used within a closure.\n+                        // eg: `let _ = x`. The closure doesn't capture x here,\n+                        // even though it's mentioned in the closure.\n+                        succ\n+                    }\n+                }\n+            }\n             _ => succ,\n         }\n     }\n@@ -1531,11 +1556,15 @@ impl<'tcx> Liveness<'_, 'tcx> {\n     }\n \n     fn warn_about_unused_upvars(&self, entry_ln: LiveNode) {\n-        let upvars = match self.upvars {\n+        let closure_captures = match self.closure_captures {\n             None => return,\n-            Some(upvars) => upvars,\n+            Some(closure_captures) => closure_captures,\n         };\n-        for (&var_hir_id, upvar) in upvars.iter() {\n+\n+        // If closure_captures is Some(), upvars must be Some() too.\n+        let upvars = self.upvars.unwrap();\n+        for &var_hir_id in closure_captures.keys() {\n+            let upvar = upvars[&var_hir_id];\n             let var = self.variable(var_hir_id, upvar.span);\n             let upvar_id = ty::UpvarId {\n                 var_path: ty::UpvarPath { hir_id: var_hir_id },"}, {"sha": "3a2a3adce35c91cecac03a664584ab2faf1bfe57", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -318,6 +318,7 @@ symbols! {\n         call_mut,\n         call_once,\n         caller_location,\n+        capture_disjoint_fields,\n         cdylib,\n         ceilf32,\n         ceilf64,\n@@ -909,6 +910,7 @@ symbols! {\n         rustc_args_required_const,\n         rustc_attrs,\n         rustc_builtin_macro,\n+        rustc_capture_analysis,\n         rustc_clean,\n         rustc_const_stable,\n         rustc_const_unstable,"}, {"sha": "019fa78fb1e0edb8f1c0df7fa95c541ae25b7d15", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 611, "deletions": 112, "changes": 723, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -39,10 +39,21 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n-use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n+use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n+use rustc_span::sym;\n use rustc_span::{Span, Symbol};\n-use std::collections::hash_map::Entry;\n+\n+/// Describe the relationship between the paths of two places\n+/// eg:\n+/// - `foo` is ancestor of `foo.bar.baz`\n+/// - `foo.bar.baz` is an descendant of `foo.bar`\n+/// - `foo.bar` and `foo.baz` are divergent\n+enum PlaceAncestryRelation {\n+    Ancestor,\n+    Descendant,\n+    Divergent,\n+}\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n@@ -111,40 +122,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None\n         };\n \n-        if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n-            let mut closure_captures: FxIndexMap<hir::HirId, ty::UpvarId> =\n-                FxIndexMap::with_capacity_and_hasher(upvars.len(), Default::default());\n-            for (&var_hir_id, _) in upvars.iter() {\n-                let upvar_id = ty::UpvarId {\n-                    var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                    closure_expr_id: closure_def_id.expect_local(),\n-                };\n-                debug!(\"seed upvar_id {:?}\", upvar_id);\n-                // Adding the upvar Id to the list of Upvars, which will be added\n-                // to the map for the closure at the end of the for loop.\n-                closure_captures.insert(var_hir_id, upvar_id);\n-\n-                let capture_kind = match capture_clause {\n-                    hir::CaptureBy::Value => ty::UpvarCapture::ByValue(None),\n-                    hir::CaptureBy::Ref => {\n-                        let origin = UpvarRegion(upvar_id, span);\n-                        let upvar_region = self.next_region_var(origin);\n-                        let upvar_borrow =\n-                            ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n-                        ty::UpvarCapture::ByRef(upvar_borrow)\n-                    }\n-                };\n+        let local_def_id = closure_def_id.expect_local();\n \n-                self.typeck_results.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n-            }\n-            // Add the vector of upvars to the map keyed with the closure id.\n-            // This gives us an easier access to them without having to call\n-            // tcx.upvars again..\n-            if !closure_captures.is_empty() {\n-                self.typeck_results\n-                    .borrow_mut()\n-                    .closure_captures\n-                    .insert(closure_def_id, closure_captures);\n+        let mut capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>> =\n+            Default::default();\n+        if !self.tcx.features().capture_disjoint_fields {\n+            if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+                for (&var_hir_id, _) in upvars.iter() {\n+                    let place = self.place_for_root_variable(local_def_id, var_hir_id);\n+\n+                    debug!(\"seed place {:?}\", place);\n+\n+                    let upvar_id = ty::UpvarId::new(var_hir_id, local_def_id);\n+                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n+                    let info = ty::CaptureInfo { expr_id: None, capture_kind };\n+\n+                    capture_information.insert(place, info);\n+                }\n             }\n         }\n \n@@ -153,9 +147,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut delegate = InferBorrowKind {\n             fcx: self,\n             closure_def_id,\n+            closure_span: span,\n+            capture_clause,\n             current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n             current_origin: None,\n-            adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n+            capture_information,\n         };\n         euv::ExprUseVisitor::new(\n             &mut delegate,\n@@ -166,6 +162,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n         .consume_body(body);\n \n+        debug!(\n+            \"For closure={:?}, capture_information={:#?}\",\n+            closure_def_id, delegate.capture_information\n+        );\n+        self.log_capture_analysis_first_pass(closure_def_id, &delegate.capture_information, span);\n+\n         if let Some(closure_substs) = infer_kind {\n             // Unify the (as yet unbound) type variable in the closure\n             // substs with the kind we inferred.\n@@ -182,7 +184,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.typeck_results.borrow_mut().upvar_capture_map.extend(delegate.adjust_upvar_captures);\n+        self.compute_min_captures(closure_def_id, delegate);\n+        self.log_closure_min_capture_info(closure_def_id, span);\n+\n+        self.min_captures_to_closure_captures_bridge(closure_def_id);\n \n         // Now that we've analyzed the closure, we know how each\n         // variable is borrowed, and we know what traits the closure\n@@ -226,15 +231,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         let closure_def_id = tcx.hir().local_def_id(closure_id);\n \n-        tcx.upvars_mentioned(closure_def_id)\n+        self.typeck_results\n+            .borrow()\n+            .closure_captures\n+            .get(&closure_def_id.to_def_id())\n             .iter()\n             .flat_map(|upvars| {\n                 upvars.iter().map(|(&var_hir_id, _)| {\n                     let upvar_ty = self.node_ty(var_hir_id);\n-                    let upvar_id = ty::UpvarId {\n-                        var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                        closure_expr_id: closure_def_id,\n-                    };\n+                    let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id);\n                     let capture = self.typeck_results.borrow().upvar_capture(upvar_id);\n \n                     debug!(\"var_id={:?} upvar_ty={:?} capture={:?}\", var_hir_id, upvar_ty, capture);\n@@ -250,6 +255,296 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             })\n             .collect()\n     }\n+\n+    /// Bridge for closure analysis\n+    /// ----------------------------\n+    ///\n+    /// For closure with DefId `c`, the bridge converts structures required for supporting RFC 2229,\n+    /// to structures currently used in the compiler for handling closure captures.\n+    ///\n+    /// For example the following structure will be converted:\n+    ///\n+    /// closure_min_captures\n+    /// foo -> [ {foo.x, ImmBorrow}, {foo.y, MutBorrow} ]\n+    /// bar -> [ {bar.z, ByValue}, {bar.q, MutBorrow} ]\n+    ///\n+    /// to\n+    ///\n+    /// 1. closure_captures\n+    /// foo -> UpvarId(foo, c), bar -> UpvarId(bar, c)\n+    ///\n+    /// 2. upvar_capture_map\n+    /// UpvarId(foo,c) -> MutBorrow, UpvarId(bar, c) -> ByValue\n+    fn min_captures_to_closure_captures_bridge(&self, closure_def_id: DefId) {\n+        let mut closure_captures: FxIndexMap<hir::HirId, ty::UpvarId> = Default::default();\n+        let mut upvar_capture_map = ty::UpvarCaptureMap::default();\n+\n+        if let Some(min_captures) =\n+            self.typeck_results.borrow().closure_min_captures.get(&closure_def_id)\n+        {\n+            for (var_hir_id, min_list) in min_captures.iter() {\n+                for captured_place in min_list {\n+                    let place = &captured_place.place;\n+                    let capture_info = captured_place.info;\n+\n+                    let upvar_id = match place.base {\n+                        PlaceBase::Upvar(upvar_id) => upvar_id,\n+                        base => bug!(\"Expected upvar, found={:?}\", base),\n+                    };\n+\n+                    assert_eq!(upvar_id.var_path.hir_id, *var_hir_id);\n+                    assert_eq!(upvar_id.closure_expr_id, closure_def_id.expect_local());\n+\n+                    closure_captures.insert(*var_hir_id, upvar_id);\n+\n+                    let new_capture_kind = if let Some(capture_kind) =\n+                        upvar_capture_map.get(&upvar_id)\n+                    {\n+                        // upvar_capture_map only stores the UpvarCapture (CaptureKind),\n+                        // so we create a fake capture info with no expression.\n+                        let fake_capture_info =\n+                            ty::CaptureInfo { expr_id: None, capture_kind: capture_kind.clone() };\n+                        determine_capture_info(fake_capture_info, capture_info).capture_kind\n+                    } else {\n+                        capture_info.capture_kind\n+                    };\n+                    upvar_capture_map.insert(upvar_id, new_capture_kind);\n+                }\n+            }\n+        }\n+        debug!(\"For closure_def_id={:?}, closure_captures={:#?}\", closure_def_id, closure_captures);\n+        debug!(\n+            \"For closure_def_id={:?}, upvar_capture_map={:#?}\",\n+            closure_def_id, upvar_capture_map\n+        );\n+\n+        if !closure_captures.is_empty() {\n+            self.typeck_results\n+                .borrow_mut()\n+                .closure_captures\n+                .insert(closure_def_id, closure_captures);\n+\n+            self.typeck_results.borrow_mut().upvar_capture_map.extend(upvar_capture_map);\n+        }\n+    }\n+\n+    /// Analyzes the information collected by `InferBorrowKind` to compute the min number of\n+    /// Places (and corresponding capture kind) that we need to keep track of to support all\n+    /// the required captured paths.\n+    ///\n+    /// Eg:\n+    /// ```rust,no_run\n+    /// struct Point { x: i32, y: i32 }\n+    ///\n+    /// let s: String;  // hir_id_s\n+    /// let mut p: Point; // his_id_p\n+    /// let c = || {\n+    ///        println!(\"{}\", s);  // L1\n+    ///        p.x += 10;  // L2\n+    ///        println!(\"{}\" , p.y) // L3\n+    ///        println!(\"{}\", p) // L4\n+    ///        drop(s);   // L5\n+    /// };\n+    /// ```\n+    /// and let hir_id_L1..5 be the expressions pointing to use of a captured variable on\n+    /// the lines L1..5 respectively.\n+    ///\n+    /// InferBorrowKind results in a structure like this:\n+    ///\n+    /// ```\n+    /// {\n+    ///       Place(base: hir_id_s, projections: [], ....) -> (hir_id_L5, ByValue),\n+    ///       Place(base: hir_id_p, projections: [Field(0, 0)], ...) -> (hir_id_L2, ByRef(MutBorrow))\n+    ///       Place(base: hir_id_p, projections: [Field(1, 0)], ...) -> (hir_id_L3, ByRef(ImmutBorrow))\n+    ///       Place(base: hir_id_p, projections: [], ...) -> (hir_id_L4, ByRef(ImmutBorrow))\n+    /// ```\n+    ///\n+    /// After the min capture analysis, we get:\n+    /// ```\n+    /// {\n+    ///       hir_id_s -> [\n+    ///            Place(base: hir_id_s, projections: [], ....) -> (hir_id_L4, ByValue)\n+    ///       ],\n+    ///       hir_id_p -> [\n+    ///            Place(base: hir_id_p, projections: [], ...) -> (hir_id_L2, ByRef(MutBorrow)),\n+    ///       ],\n+    /// ```\n+    fn compute_min_captures(\n+        &self,\n+        closure_def_id: DefId,\n+        inferred_info: InferBorrowKind<'_, 'tcx>,\n+    ) {\n+        let mut root_var_min_capture_list: ty::RootVariableMinCaptureList<'_> = Default::default();\n+\n+        for (place, capture_info) in inferred_info.capture_information.into_iter() {\n+            let var_hir_id = match place.base {\n+                PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+                base => bug!(\"Expected upvar, found={:?}\", base),\n+            };\n+\n+            // Arrays are captured in entirety, drop Index projections and projections\n+            // after Index projections.\n+            let first_index_projection =\n+                place.projections.split(|proj| ProjectionKind::Index == proj.kind).next();\n+            let place = Place {\n+                base_ty: place.base_ty,\n+                base: place.base,\n+                projections: first_index_projection.map_or(Vec::new(), |p| p.to_vec()),\n+            };\n+\n+            let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n+                None => {\n+                    let min_cap_list = vec![ty::CapturedPlace { place: place, info: capture_info }];\n+                    root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n+                    continue;\n+                }\n+                Some(min_cap_list) => min_cap_list,\n+            };\n+\n+            // Go through each entry in the current list of min_captures\n+            // - if ancestor is found, update it's capture kind to account for current place's\n+            // capture information.\n+            //\n+            // - if descendant is found, remove it from the list, and update the current place's\n+            // capture information to account for the descendants's capture kind.\n+            //\n+            // We can never be in a case where the list contains both an ancestor and a descendant\n+            // Also there can only be ancestor but in case of descendants there might be\n+            // multiple.\n+\n+            let mut descendant_found = false;\n+            let mut updated_capture_info = capture_info;\n+            min_cap_list.retain(|possible_descendant| {\n+                match determine_place_ancestry_relation(&place, &possible_descendant.place) {\n+                    // current place is ancestor of possible_descendant\n+                    PlaceAncestryRelation::Ancestor => {\n+                        descendant_found = true;\n+                        updated_capture_info =\n+                            determine_capture_info(updated_capture_info, possible_descendant.info);\n+                        false\n+                    }\n+\n+                    _ => true,\n+                }\n+            });\n+\n+            let mut ancestor_found = false;\n+            if !descendant_found {\n+                for possible_ancestor in min_cap_list.iter_mut() {\n+                    match determine_place_ancestry_relation(&place, &possible_ancestor.place) {\n+                        // current place is descendant of possible_ancestor\n+                        PlaceAncestryRelation::Descendant => {\n+                            ancestor_found = true;\n+                            possible_ancestor.info =\n+                                determine_capture_info(possible_ancestor.info, capture_info);\n+\n+                            // Only one ancestor of the current place will be in the list.\n+                            break;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n+            // Only need to insert when we don't have an ancestor in the existing min capture list\n+            if !ancestor_found {\n+                let captured_place =\n+                    ty::CapturedPlace { place: place.clone(), info: updated_capture_info };\n+                min_cap_list.push(captured_place);\n+            }\n+        }\n+\n+        debug!(\"For closure={:?}, min_captures={:#?}\", closure_def_id, root_var_min_capture_list);\n+\n+        if !root_var_min_capture_list.is_empty() {\n+            self.typeck_results\n+                .borrow_mut()\n+                .closure_min_captures\n+                .insert(closure_def_id, root_var_min_capture_list);\n+        }\n+    }\n+\n+    fn init_capture_kind(\n+        &self,\n+        capture_clause: hir::CaptureBy,\n+        upvar_id: ty::UpvarId,\n+        closure_span: Span,\n+    ) -> ty::UpvarCapture<'tcx> {\n+        match capture_clause {\n+            hir::CaptureBy::Value => ty::UpvarCapture::ByValue(None),\n+            hir::CaptureBy::Ref => {\n+                let origin = UpvarRegion(upvar_id, closure_span);\n+                let upvar_region = self.next_region_var(origin);\n+                let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n+                ty::UpvarCapture::ByRef(upvar_borrow)\n+            }\n+        }\n+    }\n+\n+    fn place_for_root_variable(\n+        &self,\n+        closure_def_id: LocalDefId,\n+        var_hir_id: hir::HirId,\n+    ) -> Place<'tcx> {\n+        let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id);\n+\n+        Place {\n+            base_ty: self.node_ty(var_hir_id),\n+            base: PlaceBase::Upvar(upvar_id),\n+            projections: Default::default(),\n+        }\n+    }\n+\n+    fn should_log_capture_analysis(&self, closure_def_id: DefId) -> bool {\n+        self.tcx.has_attr(closure_def_id, sym::rustc_capture_analysis)\n+    }\n+\n+    fn log_capture_analysis_first_pass(\n+        &self,\n+        closure_def_id: rustc_hir::def_id::DefId,\n+        capture_information: &FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>,\n+        closure_span: Span,\n+    ) {\n+        if self.should_log_capture_analysis(closure_def_id) {\n+            let mut diag =\n+                self.tcx.sess.struct_span_err(closure_span, \"First Pass analysis includes:\");\n+            for (place, capture_info) in capture_information {\n+                let capture_str = construct_capture_info_string(self.tcx, place, capture_info);\n+                let output_str = format!(\"Capturing {}\", capture_str);\n+\n+                let span = capture_info.expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n+                diag.span_note(span, &output_str);\n+            }\n+            diag.emit();\n+        }\n+    }\n+\n+    fn log_closure_min_capture_info(&self, closure_def_id: DefId, closure_span: Span) {\n+        if self.should_log_capture_analysis(closure_def_id) {\n+            if let Some(min_captures) =\n+                self.typeck_results.borrow().closure_min_captures.get(&closure_def_id)\n+            {\n+                let mut diag =\n+                    self.tcx.sess.struct_span_err(closure_span, \"Min Capture analysis includes:\");\n+\n+                for (_, min_captures_for_var) in min_captures {\n+                    for capture in min_captures_for_var {\n+                        let place = &capture.place;\n+                        let capture_info = &capture.info;\n+\n+                        let capture_str =\n+                            construct_capture_info_string(self.tcx, place, capture_info);\n+                        let output_str = format!(\"Min Capture {}\", capture_str);\n+\n+                        let span =\n+                            capture_info.expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n+                        diag.span_note(span, &output_str);\n+                    }\n+                }\n+                diag.emit();\n+            }\n+        }\n+    }\n }\n \n struct InferBorrowKind<'a, 'tcx> {\n@@ -258,6 +553,10 @@ struct InferBorrowKind<'a, 'tcx> {\n     // The def-id of the closure whose kind and upvar accesses are being inferred.\n     closure_def_id: DefId,\n \n+    closure_span: Span,\n+\n+    capture_clause: hir::CaptureBy,\n+\n     // The kind that we have inferred that the current closure\n     // requires. Note that we *always* infer a minimal kind, even if\n     // we don't always *use* that in the final result (i.e., sometimes\n@@ -270,9 +569,31 @@ struct InferBorrowKind<'a, 'tcx> {\n     // variable access that caused us to do so.\n     current_origin: Option<(Span, Symbol)>,\n \n-    // For each upvar that we access, we track the minimal kind of\n-    // access we need (ref, ref mut, move, etc).\n-    adjust_upvar_captures: ty::UpvarCaptureMap<'tcx>,\n+    /// For each Place that is captured by the closure, we track the minimal kind of\n+    /// access we need (ref, ref mut, move, etc) and the expression that resulted in such access.\n+    ///\n+    /// Consider closure where s.str1 is captured via an ImmutableBorrow and\n+    /// s.str2 via a MutableBorrow\n+    ///\n+    /// ```rust,no_run\n+    /// struct SomeStruct { str1: String, str2: String }\n+    ///\n+    /// // Assume that the HirId for the variable definition is `V1`\n+    /// let mut s = SomeStruct { str1: format!(\"s1\"), str2: format!(\"s2\") }\n+    ///\n+    /// let fix_s = |new_s2| {\n+    ///     // Assume that the HirId for the expression `s.str1` is `E1`\n+    ///     println!(\"Updating SomeStruct with str1=\", s.str1);\n+    ///     // Assume that the HirId for the expression `*s.str2` is `E2`\n+    ///     s.str2 = new_s2;\n+    /// };\n+    /// ```\n+    ///\n+    /// For closure `fix_s`, (at a high level) the map contains\n+    ///\n+    /// Place { V1, [ProjectionKind::Field(Index=0, Variant=0)] } : CaptureKind { E1, ImmutableBorrow }\n+    /// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n+    capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>,\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n@@ -314,26 +635,15 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             var_name(tcx, upvar_id.var_path.hir_id),\n         );\n \n-        let new_capture = ty::UpvarCapture::ByValue(Some(usage_span));\n-        match self.adjust_upvar_captures.entry(upvar_id) {\n-            Entry::Occupied(mut e) => {\n-                match e.get() {\n-                    // We always overwrite `ByRef`, since we require\n-                    // that the upvar be available by value.\n-                    //\n-                    // If we had a previous by-value usage without a specific\n-                    // span, use ours instead. Otherwise, keep the first span\n-                    // we encountered, since there isn't an obviously better one.\n-                    ty::UpvarCapture::ByRef(_) | ty::UpvarCapture::ByValue(None) => {\n-                        e.insert(new_capture);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            Entry::Vacant(e) => {\n-                e.insert(new_capture);\n-            }\n-        }\n+        let capture_info = ty::CaptureInfo {\n+            expr_id: Some(diag_expr_id),\n+            capture_kind: ty::UpvarCapture::ByValue(Some(usage_span)),\n+        };\n+\n+        let curr_info = self.capture_information[&place_with_id.place];\n+        let updated_info = determine_capture_info(curr_info, capture_info);\n+\n+        self.capture_information[&place_with_id.place] = updated_info;\n     }\n \n     /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n@@ -349,7 +659,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id\n         );\n \n-        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n+        if let PlaceBase::Upvar(_) = place_with_id.place.base {\n             let mut borrow_kind = ty::MutBorrow;\n             for pointer_ty in place_with_id.place.deref_tys() {\n                 match pointer_ty.kind() {\n@@ -363,7 +673,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                     _ => (),\n                 }\n             }\n-            self.adjust_upvar_deref(upvar_id, self.fcx.tcx.hir().span(diag_expr_id), borrow_kind);\n+            self.adjust_upvar_deref(place_with_id, diag_expr_id, borrow_kind);\n         }\n     }\n \n@@ -377,24 +687,20 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id\n         );\n \n-        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n+        if let PlaceBase::Upvar(_) = place_with_id.place.base {\n             if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n                 // Raw pointers don't inherit mutability.\n                 return;\n             }\n             // for a borrowed pointer to be unique, its base must be unique\n-            self.adjust_upvar_deref(\n-                upvar_id,\n-                self.fcx.tcx.hir().span(diag_expr_id),\n-                ty::UniqueImmBorrow,\n-            );\n+            self.adjust_upvar_deref(place_with_id, diag_expr_id, ty::UniqueImmBorrow);\n         }\n     }\n \n     fn adjust_upvar_deref(\n         &mut self,\n-        upvar_id: ty::UpvarId,\n-        place_span: Span,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n+        diag_expr_id: hir::HirId,\n         borrow_kind: ty::BorrowKind,\n     ) {\n         assert!(match borrow_kind {\n@@ -411,53 +717,51 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         // upvar, then we need to modify the\n         // borrow_kind of the upvar to make sure it\n         // is inferred to mutable if necessary\n-        self.adjust_upvar_borrow_kind(upvar_id, borrow_kind);\n+        self.adjust_upvar_borrow_kind(place_with_id, diag_expr_id, borrow_kind);\n \n-        // also need to be in an FnMut closure since this is not an ImmBorrow\n-        self.adjust_closure_kind(\n-            upvar_id.closure_expr_id,\n-            ty::ClosureKind::FnMut,\n-            place_span,\n-            var_name(tcx, upvar_id.var_path.hir_id),\n-        );\n+        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n+            self.adjust_closure_kind(\n+                upvar_id.closure_expr_id,\n+                ty::ClosureKind::FnMut,\n+                tcx.hir().span(diag_expr_id),\n+                var_name(tcx, upvar_id.var_path.hir_id),\n+            );\n+        }\n     }\n \n     /// We infer the borrow_kind with which to borrow upvars in a stack closure.\n     /// The borrow_kind basically follows a lattice of `imm < unique-imm < mut`,\n     /// moving from left to right as needed (but never right to left).\n     /// Here the argument `mutbl` is the borrow_kind that is required by\n     /// some particular use.\n-    fn adjust_upvar_borrow_kind(&mut self, upvar_id: ty::UpvarId, kind: ty::BorrowKind) {\n-        let upvar_capture = self\n-            .adjust_upvar_captures\n-            .get(&upvar_id)\n-            .copied()\n-            .unwrap_or_else(|| self.fcx.typeck_results.borrow().upvar_capture(upvar_id));\n+    fn adjust_upvar_borrow_kind(\n+        &mut self,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n+        diag_expr_id: hir::HirId,\n+        kind: ty::BorrowKind,\n+    ) {\n+        let curr_capture_info = self.capture_information[&place_with_id.place];\n+\n         debug!(\n-            \"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n-            upvar_id, upvar_capture, kind\n+            \"adjust_upvar_borrow_kind(place={:?}, diag_expr_id={:?}, capture_info={:?}, kind={:?})\",\n+            place_with_id, diag_expr_id, curr_capture_info, kind\n         );\n \n-        match upvar_capture {\n-            ty::UpvarCapture::ByValue(_) => {\n-                // Upvar is already by-value, the strongest criteria.\n-            }\n-            ty::UpvarCapture::ByRef(mut upvar_borrow) => {\n-                match (upvar_borrow.kind, kind) {\n-                    // Take RHS:\n-                    (ty::ImmBorrow, ty::UniqueImmBorrow | ty::MutBorrow)\n-                    | (ty::UniqueImmBorrow, ty::MutBorrow) => {\n-                        upvar_borrow.kind = kind;\n-                        self.adjust_upvar_captures\n-                            .insert(upvar_id, ty::UpvarCapture::ByRef(upvar_borrow));\n-                    }\n-                    // Take LHS:\n-                    (ty::ImmBorrow, ty::ImmBorrow)\n-                    | (ty::UniqueImmBorrow, ty::ImmBorrow | ty::UniqueImmBorrow)\n-                    | (ty::MutBorrow, _) => {}\n-                }\n-            }\n-        }\n+        if let ty::UpvarCapture::ByValue(_) = curr_capture_info.capture_kind {\n+            // It's already captured by value, we don't need to do anything here\n+            return;\n+        } else if let ty::UpvarCapture::ByRef(curr_upvar_borrow) = curr_capture_info.capture_kind {\n+            // Use the same region as the current capture information\n+            // Doesn't matter since only one of the UpvarBorrow will be used.\n+            let new_upvar_borrow = ty::UpvarBorrow { kind, region: curr_upvar_borrow.region };\n+\n+            let capture_info = ty::CaptureInfo {\n+                expr_id: Some(diag_expr_id),\n+                capture_kind: ty::UpvarCapture::ByRef(new_upvar_borrow),\n+            };\n+            let updated_info = determine_capture_info(curr_capture_info, capture_info);\n+            self.capture_information[&place_with_id.place] = updated_info;\n+        };\n     }\n \n     fn adjust_closure_kind(\n@@ -501,6 +805,28 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn init_capture_info_for_place(\n+        &mut self,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n+        diag_expr_id: hir::HirId,\n+    ) {\n+        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n+            assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n+\n+            let capture_kind =\n+                self.fcx.init_capture_kind(self.capture_clause, upvar_id, self.closure_span);\n+\n+            let expr_id = Some(diag_expr_id);\n+            let capture_info = ty::CaptureInfo { expr_id, capture_kind };\n+\n+            debug!(\"Capturing new place {:?}, capture_info={:?}\", place_with_id, capture_info);\n+\n+            self.capture_information.insert(place_with_id.place.clone(), capture_info);\n+        } else {\n+            debug!(\"Not upvar: {:?}\", place_with_id);\n+        }\n+    }\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n@@ -514,7 +840,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             \"consume(place_with_id={:?}, diag_expr_id={:?}, mode={:?})\",\n             place_with_id, diag_expr_id, mode\n         );\n-        self.adjust_upvar_borrow_kind_for_consume(&place_with_id, diag_expr_id, mode);\n+        if !self.capture_information.contains_key(&place_with_id.place) {\n+            self.init_capture_info_for_place(place_with_id, diag_expr_id);\n+        }\n+\n+        self.adjust_upvar_borrow_kind_for_consume(place_with_id, diag_expr_id, mode);\n     }\n \n     fn borrow(\n@@ -528,6 +858,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, bk\n         );\n \n+        if !self.capture_information.contains_key(&place_with_id.place) {\n+            self.init_capture_info_for_place(place_with_id, diag_expr_id);\n+        }\n+\n         match bk {\n             ty::ImmBorrow => {}\n             ty::UniqueImmBorrow => {\n@@ -541,10 +875,175 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n \n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId) {\n         debug!(\"mutate(assignee_place={:?}, diag_expr_id={:?})\", assignee_place, diag_expr_id);\n+\n+        if !self.capture_information.contains_key(&assignee_place.place) {\n+            self.init_capture_info_for_place(assignee_place, diag_expr_id);\n+        }\n+\n         self.adjust_upvar_borrow_kind_for_mut(assignee_place, diag_expr_id);\n     }\n }\n \n+fn construct_capture_info_string(\n+    tcx: TyCtxt<'_>,\n+    place: &Place<'tcx>,\n+    capture_info: &ty::CaptureInfo<'tcx>,\n+) -> String {\n+    let variable_name = match place.base {\n+        PlaceBase::Upvar(upvar_id) => var_name(tcx, upvar_id.var_path.hir_id).to_string(),\n+        _ => bug!(\"Capture_information should only contain upvars\"),\n+    };\n+\n+    let mut projections_str = String::new();\n+    for (i, item) in place.projections.iter().enumerate() {\n+        let proj = match item.kind {\n+            ProjectionKind::Field(a, b) => format!(\"({:?}, {:?})\", a, b),\n+            ProjectionKind::Deref => String::from(\"Deref\"),\n+            ProjectionKind::Index => String::from(\"Index\"),\n+            ProjectionKind::Subslice => String::from(\"Subslice\"),\n+        };\n+        if i != 0 {\n+            projections_str.push_str(\",\");\n+        }\n+        projections_str.push_str(proj.as_str());\n+    }\n+\n+    let capture_kind_str = match capture_info.capture_kind {\n+        ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),\n+        ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n+    };\n+    format!(\"{}[{}] -> {}\", variable_name, projections_str, capture_kind_str)\n+}\n+\n fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n+\n+/// Helper function to determine if we need to escalate CaptureKind from\n+/// CaptureInfo A to B and returns the escalated CaptureInfo.\n+/// (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)\n+///\n+/// If both `CaptureKind`s are considered equivalent, then the CaptureInfo is selected based\n+/// on the `CaptureInfo` containing an associated expression id.\n+///\n+/// If both the CaptureKind and Expression are considered to be equivalent,\n+/// then `CaptureInfo` A is preferred. This can be useful in cases where we want to priortize\n+/// expressions reported back to the user as part of diagnostics based on which appears earlier\n+/// in the closure. This can be acheived simply by calling\n+/// `determine_capture_info(existing_info, current_info)`. This works out because the\n+/// expressions that occur earlier in the closure body than the current expression are processed before.\n+/// Consider the following example\n+/// ```rust,no_run\n+/// struct Point { x: i32, y: i32 }\n+/// let mut p: Point { x: 10, y: 10 };\n+///\n+/// let c = || {\n+///     p.x     += 10;\n+/// // ^ E1 ^\n+///     // ...\n+///     // More code\n+///     // ...\n+///     p.x += 10; // E2\n+/// // ^ E2 ^\n+/// };\n+/// ```\n+/// `CaptureKind` associated with both `E1` and `E2` will be ByRef(MutBorrow),\n+/// and both have an expression associated, however for diagnostics we prefer reporting\n+/// `E1` since it appears earlier in the closure body. When `E2` is being processed we\n+/// would've already handled `E1`, and have an existing capture_information for it.\n+/// Calling `determine_capture_info(existing_info_e1, current_info_e2)` will return\n+/// `existing_info_e1` in this case, allowing us to point to `E1` in case of diagnostics.\n+fn determine_capture_info(\n+    capture_info_a: ty::CaptureInfo<'tcx>,\n+    capture_info_b: ty::CaptureInfo<'tcx>,\n+) -> ty::CaptureInfo<'tcx> {\n+    // If the capture kind is equivalent then, we don't need to escalate and can compare the\n+    // expressions.\n+    let eq_capture_kind = match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n+        (ty::UpvarCapture::ByValue(_), ty::UpvarCapture::ByValue(_)) => {\n+            // We don't need to worry about the spans being ignored here.\n+            //\n+            // The expr_id in capture_info corresponds to the span that is stored within\n+            // ByValue(span) and therefore it gets handled with priortizing based on\n+            // expressions below.\n+            true\n+        }\n+        (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n+            ref_a.kind == ref_b.kind\n+        }\n+        (ty::UpvarCapture::ByValue(_), _) | (ty::UpvarCapture::ByRef(_), _) => false,\n+    };\n+\n+    if eq_capture_kind {\n+        match (capture_info_a.expr_id, capture_info_b.expr_id) {\n+            (Some(_), _) | (None, None) => capture_info_a,\n+            (None, Some(_)) => capture_info_b,\n+        }\n+    } else {\n+        // We select the CaptureKind which ranks higher based the following priority order:\n+        // ByValue > MutBorrow > UniqueImmBorrow > ImmBorrow\n+        match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n+            (ty::UpvarCapture::ByValue(_), _) => capture_info_a,\n+            (_, ty::UpvarCapture::ByValue(_)) => capture_info_b,\n+            (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n+                match (ref_a.kind, ref_b.kind) {\n+                    // Take LHS:\n+                    (ty::UniqueImmBorrow | ty::MutBorrow, ty::ImmBorrow)\n+                    | (ty::MutBorrow, ty::UniqueImmBorrow) => capture_info_a,\n+\n+                    // Take RHS:\n+                    (ty::ImmBorrow, ty::UniqueImmBorrow | ty::MutBorrow)\n+                    | (ty::UniqueImmBorrow, ty::MutBorrow) => capture_info_b,\n+\n+                    (ty::ImmBorrow, ty::ImmBorrow)\n+                    | (ty::UniqueImmBorrow, ty::UniqueImmBorrow)\n+                    | (ty::MutBorrow, ty::MutBorrow) => {\n+                        bug!(\"Expected unequal capture kinds\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Determines the Ancestry relationship of Place A relative to Place B\n+///\n+/// `PlaceAncestryRelation::Ancestor` implies Place A is ancestor of Place B\n+/// `PlaceAncestryRelation::Descendant` implies Place A is descendant of Place B\n+/// `PlaceAncestryRelation::Divergent` implies neither of them is the ancestor of the other.\n+fn determine_place_ancestry_relation(\n+    place_a: &Place<'tcx>,\n+    place_b: &Place<'tcx>,\n+) -> PlaceAncestryRelation {\n+    // If Place A and Place B, don't start off from the same root variable, they are divergent.\n+    if place_a.base != place_b.base {\n+        return PlaceAncestryRelation::Divergent;\n+    }\n+\n+    // Assume of length of projections_a = n\n+    let projections_a = &place_a.projections;\n+\n+    // Assume of length of projections_b = m\n+    let projections_b = &place_b.projections;\n+\n+    let mut same_initial_projections = true;\n+\n+    for (proj_a, proj_b) in projections_a.iter().zip(projections_b.iter()) {\n+        if proj_a != proj_b {\n+            same_initial_projections = false;\n+            break;\n+        }\n+    }\n+\n+    if same_initial_projections {\n+        // First min(n, m) projections are the same\n+        // Select Ancestor/Descendant\n+        if projections_b.len() >= projections_a.len() {\n+            PlaceAncestryRelation::Ancestor\n+        } else {\n+            PlaceAncestryRelation::Descendant\n+        }\n+    } else {\n+        PlaceAncestryRelation::Divergent\n+    }\n+}"}, {"sha": "1b51d5e0182fde51426de0751acd373488cacdd8", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 107, "deletions": 29, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -15,10 +15,10 @@ use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n use crate::mem_categorization as mc;\n-use rustc_span::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n@@ -73,6 +73,7 @@ pub enum MutateMode {\n // This is the code that actually walks the tree.\n pub struct ExprUseVisitor<'a, 'tcx> {\n     mc: mc::MemCategorizationContext<'a, 'tcx>,\n+    body_owner: LocalDefId,\n     delegate: &'a mut dyn Delegate<'tcx>,\n }\n \n@@ -110,6 +111,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     ) -> Self {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::new(infcx, param_env, body_owner, typeck_results),\n+            body_owner,\n             delegate,\n         }\n     }\n@@ -329,8 +331,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_expr(base);\n             }\n \n-            hir::ExprKind::Closure(_, _, _, fn_decl_span, _) => {\n-                self.walk_captures(expr, fn_decl_span);\n+            hir::ExprKind::Closure(..) => {\n+                self.walk_captures(expr);\n             }\n \n             hir::ExprKind::Box(ref base) => {\n@@ -529,7 +531,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n \n         let tcx = self.tcx();\n-        let ExprUseVisitor { ref mc, ref mut delegate } = *self;\n+        let ExprUseVisitor { ref mc, body_owner: _, ref mut delegate } = *self;\n         return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\"walk_pat: binding place={:?} pat={:?}\", place, pat,);\n@@ -569,36 +571,112 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }));\n     }\n \n-    fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>, fn_decl_span: Span) {\n+    /// Walk closure captures but using `closure_caputes` instead\n+    /// of `closure_min_captures`.\n+    ///\n+    /// This is needed because clippy uses `ExprUseVisitor` after TypeckResults\n+    /// are written back. We don't currently writeback min_captures to\n+    /// TypeckResults.\n+    fn walk_captures_closure_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n+        // FIXME(arora-aman): Remove this function once rust-lang/project-rfc-2229#18\n+        // is completed.\n+        debug!(\"walk_captures_closure_captures({:?}), \", closure_expr);\n+\n+        let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n+        let cl_span = self.tcx().hir().span(closure_expr.hir_id);\n+\n+        let captures = &self.mc.typeck_results.closure_captures[&closure_def_id];\n+\n+        for (&var_id, &upvar_id) in captures {\n+            let upvar_capture = self.mc.typeck_results.upvar_capture(upvar_id);\n+            let captured_place =\n+                return_if_err!(self.cat_captured_var(closure_expr.hir_id, cl_span, var_id));\n+            match upvar_capture {\n+                ty::UpvarCapture::ByValue(_) => {\n+                    let mode = copy_or_move(&self.mc, &captured_place);\n+                    self.delegate.consume(&captured_place, captured_place.hir_id, mode);\n+                }\n+                ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                    self.delegate.borrow(&captured_place, captured_place.hir_id, upvar_borrow.kind);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Handle the case where the current body contains a closure.\n+    ///\n+    /// When the current body being handled is a closure, then we must make sure that\n+    /// - The parent closure only captures Places from the nested closure that are not local to it.\n+    ///\n+    /// In the following example the closures `c` only captures `p.x`` even though `incr`\n+    /// is a capture of the nested closure\n+    ///\n+    /// ```rust,ignore(cannot-test-this-because-pseduo-code)\n+    /// let p = ..;\n+    /// let c = || {\n+    ///    let incr = 10;\n+    ///    let nested = || p.x += incr;\n+    /// }\n+    /// ```\n+    ///\n+    /// - When reporting the Place back to the Delegate, ensure that the UpvarId uses the enclosing\n+    /// closure as the DefId.\n+    fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id);\n-        if let Some(upvars) = self.tcx().upvars_mentioned(closure_def_id) {\n-            for &var_id in upvars.keys() {\n-                let upvar_id = ty::UpvarId {\n-                    var_path: ty::UpvarPath { hir_id: var_id },\n-                    closure_expr_id: closure_def_id,\n-                };\n-                let upvar_capture = self.mc.typeck_results.upvar_capture(upvar_id);\n-                let captured_place = return_if_err!(self.cat_captured_var(\n-                    closure_expr.hir_id,\n-                    fn_decl_span,\n-                    var_id,\n-                ));\n-                match upvar_capture {\n-                    ty::UpvarCapture::ByValue(_) => {\n-                        let mode = copy_or_move(&self.mc, &captured_place);\n-                        self.delegate.consume(&captured_place, captured_place.hir_id, mode);\n-                    }\n-                    ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                        self.delegate.borrow(\n-                            &captured_place,\n-                            captured_place.hir_id,\n-                            upvar_borrow.kind,\n-                        );\n+        let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n+        let upvars = self.tcx().upvars_mentioned(self.body_owner);\n+\n+        // For purposes of this function, generator and closures are equivalent.\n+        let body_owner_is_closure = match self.tcx().type_of(self.body_owner.to_def_id()).kind() {\n+            ty::Closure(..) | ty::Generator(..) => true,\n+            _ => false,\n+        };\n+\n+        if let Some(min_captures) = self.mc.typeck_results.closure_min_captures.get(&closure_def_id)\n+        {\n+            for (var_hir_id, min_list) in min_captures.iter() {\n+                if upvars.map_or(body_owner_is_closure, |upvars| !upvars.contains_key(var_hir_id)) {\n+                    // The nested closure might be capturing the current (enclosing) closure's local variables.\n+                    // We check if the root variable is ever mentioned within the enclosing closure, if not\n+                    // then for the current body (if it's a closure) these aren't captures, we will ignore them.\n+                    continue;\n+                }\n+                for captured_place in min_list {\n+                    let place = &captured_place.place;\n+                    let capture_info = captured_place.info;\n+\n+                    let upvar_id = if body_owner_is_closure {\n+                        // Mark the place to be captured by the enclosing closure\n+                        ty::UpvarId::new(*var_hir_id, self.body_owner)\n+                    } else {\n+                        ty::UpvarId::new(*var_hir_id, closure_def_id.expect_local())\n+                    };\n+                    let place_with_id = PlaceWithHirId::new(\n+                        capture_info.expr_id.unwrap_or(closure_expr.hir_id),\n+                        place.base_ty,\n+                        PlaceBase::Upvar(upvar_id),\n+                        place.projections.clone(),\n+                    );\n+\n+                    match capture_info.capture_kind {\n+                        ty::UpvarCapture::ByValue(_) => {\n+                            let mode = copy_or_move(&self.mc, &place_with_id);\n+                            self.delegate.consume(&place_with_id, place_with_id.hir_id, mode);\n+                        }\n+                        ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                            self.delegate.borrow(\n+                                &place_with_id,\n+                                place_with_id.hir_id,\n+                                upvar_borrow.kind,\n+                            );\n+                        }\n                     }\n                 }\n             }\n+        } else if self.mc.typeck_results.closure_captures.contains_key(&closure_def_id) {\n+            // Handle the case where clippy calls ExprUseVisitor after\n+            self.walk_captures_closure_captures(closure_expr)\n         }\n     }\n "}, {"sha": "131af6a10c8985632c36ca15cebb5c6da39eca10", "filename": "src/test/ui/closures/2229_closure_analysis/arrays-completely-captured.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,24 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+// Ensure that capture analysis results in arrays being completely captured.\n+fn main() {\n+    let mut m = [1, 2, 3, 4, 5];\n+\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        m[0] += 10;\n+        //~^ NOTE: Capturing m[] -> MutBorrow\n+        //~| NOTE: Min Capture m[] -> MutBorrow\n+        m[1] += 40;\n+    };\n+\n+    c();\n+}"}, {"sha": "2a350f303319277bb4620c89e5fe432161f25374", "filename": "src/test/ui/closures/2229_closure_analysis/arrays-completely-captured.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Farrays-completely-captured.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,57 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/arrays-completely-captured.rs:11:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/arrays-completely-captured.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/arrays-completely-captured.rs:14:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         m[0] += 10;\n+...  |\n+LL | |         m[1] += 40;\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing m[] -> MutBorrow\n+  --> $DIR/arrays-completely-captured.rs:17:9\n+   |\n+LL |         m[0] += 10;\n+   |         ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/arrays-completely-captured.rs:14:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         m[0] += 10;\n+...  |\n+LL | |         m[1] += 40;\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture m[] -> MutBorrow\n+  --> $DIR/arrays-completely-captured.rs:17:9\n+   |\n+LL |         m[0] += 10;\n+   |         ^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ba4955085372a20551dc900aef1362cbaeca4da4", "filename": "src/test/ui/closures/2229_closure_analysis/capture-disjoint-field-struct.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-struct.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,33 @@\n+// FIXME(arora-aman) add run-pass once 2229 is implemented\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut p = Point { x: 10, y: 10 };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        println!(\"{}\", p.x);\n+        //~^ NOTE: Capturing p[(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture p[(0, 0)] -> ImmBorrow\n+    };\n+\n+    // `c` should only capture `p.x`, therefore mutating `p.y` is allowed.\n+    let py = &mut p.y;\n+\n+    c();\n+    *py = 20;\n+}"}, {"sha": "5fac6963afd32b49e352ec0b2809f851c0b805b0", "filename": "src/test/ui/closures/2229_closure_analysis/capture-disjoint-field-struct.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-struct.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,57 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-disjoint-field-struct.rs:17:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-disjoint-field-struct.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-disjoint-field-struct.rs:20:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", p.x);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-disjoint-field-struct.rs:23:24\n+   |\n+LL |         println!(\"{}\", p.x);\n+   |                        ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-disjoint-field-struct.rs:20:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", p.x);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-disjoint-field-struct.rs:23:24\n+   |\n+LL |         println!(\"{}\", p.x);\n+   |                        ^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "c1693fbad7986b342e7372aa77651f4b68c03eaa", "filename": "src/test/ui/closures/2229_closure_analysis/capture-disjoint-field-tuple.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-tuple.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,28 @@\n+// FIXME(arora-aman) add run-pass once 2229 is implemented\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+fn main() {\n+    let mut t = (10, 10);\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        println!(\"{}\", t.0);\n+        //~^ NOTE: Capturing t[(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture t[(0, 0)] -> ImmBorrow\n+    };\n+\n+    // `c` only captures t.0, therefore mutating t.1 is allowed.\n+    let t1 = &mut t.1;\n+\n+    c();\n+    *t1 = 20;\n+}"}, {"sha": "1bfd63f2ace8c5e8ed8b33fc260a6dc52fefad45", "filename": "src/test/ui/closures/2229_closure_analysis/capture-disjoint-field-tuple.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-disjoint-field-tuple.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,57 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-disjoint-field-tuple.rs:12:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-disjoint-field-tuple.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-disjoint-field-tuple.rs:15:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", t.0);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-disjoint-field-tuple.rs:18:24\n+   |\n+LL |         println!(\"{}\", t.0);\n+   |                        ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-disjoint-field-tuple.rs:15:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", t.0);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-disjoint-field-tuple.rs:18:24\n+   |\n+LL |         println!(\"{}\", t.0);\n+   |                        ^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "8fb2f7f16d69c4e44841e7ed5c6bff9941d32ad6", "filename": "src/test/ui/closures/2229_closure_analysis/capture-enums.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-enums.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,64 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+enum Info {\n+    Point(i32, i32, String),\n+    Meta(String, Vec<(i32, i32)>)\n+}\n+\n+fn multi_variant_enum() {\n+    let point = Info::Point(10, -10, \"1\".into());\n+\n+    let vec = Vec::new();\n+    let meta = Info::Meta(\"meta\".into(), vec);\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        if let Info::Point(_, _, str) = point {\n+            //~^ NOTE: Capturing point[] -> ImmBorrow\n+            //~| NOTE: Capturing point[(2, 0)] -> ByValue\n+            //~| NOTE: Min Capture point[] -> ByValue\n+            println!(\"{}\", str);\n+        }\n+\n+        if let Info::Meta(_, v) = meta {\n+            //~^ NOTE: Capturing meta[] -> ImmBorrow\n+            //~| NOTE: Capturing meta[(1, 1)] -> ByValue\n+            //~| NOTE: Min Capture meta[] -> ByValue\n+            println!(\"{:?}\", v);\n+        }\n+    };\n+\n+    c();\n+}\n+\n+enum SingleVariant {\n+    Point(i32, i32, String),\n+}\n+\n+fn single_variant_enum() {\n+    let point = SingleVariant::Point(10, -10, \"1\".into());\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        let SingleVariant::Point(_, _, str) = point;\n+        //~^ NOTE: Capturing point[(2, 0)] -> ByValue\n+        //~| NOTE: Min Capture point[(2, 0)] -> ByValue\n+        println!(\"{}\", str);\n+    };\n+\n+    c();\n+}\n+\n+fn main() {}"}, {"sha": "ebe1dcb98848b8ef44b8f6201dd15f28488e7b5e", "filename": "src/test/ui/closures/2229_closure_analysis/capture-enums.stderr", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-enums.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,122 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-enums.rs:18:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-enums.rs:49:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-enums.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-enums.rs:21:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         if let Info::Point(_, _, str) = point {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing point[] -> ImmBorrow\n+  --> $DIR/capture-enums.rs:24:41\n+   |\n+LL |         if let Info::Point(_, _, str) = point {\n+   |                                         ^^^^^\n+note: Capturing point[(2, 0)] -> ByValue\n+  --> $DIR/capture-enums.rs:24:41\n+   |\n+LL |         if let Info::Point(_, _, str) = point {\n+   |                                         ^^^^^\n+note: Capturing meta[] -> ImmBorrow\n+  --> $DIR/capture-enums.rs:31:35\n+   |\n+LL |         if let Info::Meta(_, v) = meta {\n+   |                                   ^^^^\n+note: Capturing meta[(1, 1)] -> ByValue\n+  --> $DIR/capture-enums.rs:31:35\n+   |\n+LL |         if let Info::Meta(_, v) = meta {\n+   |                                   ^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-enums.rs:21:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         if let Info::Point(_, _, str) = point {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture point[] -> ByValue\n+  --> $DIR/capture-enums.rs:24:41\n+   |\n+LL |         if let Info::Point(_, _, str) = point {\n+   |                                         ^^^^^\n+note: Min Capture meta[] -> ByValue\n+  --> $DIR/capture-enums.rs:31:35\n+   |\n+LL |         if let Info::Meta(_, v) = meta {\n+   |                                   ^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-enums.rs:52:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let SingleVariant::Point(_, _, str) = point;\n+...  |\n+LL | |         println!(\"{}\", str);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing point[(2, 0)] -> ByValue\n+  --> $DIR/capture-enums.rs:55:47\n+   |\n+LL |         let SingleVariant::Point(_, _, str) = point;\n+   |                                               ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-enums.rs:52:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let SingleVariant::Point(_, _, str) = point;\n+...  |\n+LL | |         println!(\"{}\", str);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture point[(2, 0)] -> ByValue\n+  --> $DIR/capture-enums.rs:55:47\n+   |\n+LL |         let SingleVariant::Point(_, _, str) = point;\n+   |                                               ^^^^^\n+\n+error: aborting due to 6 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "080ca0405b4776c42ac0a5bc87a79d3c743ec0d3", "filename": "src/test/ui/closures/2229_closure_analysis/destructure_patterns.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,77 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+// Test to ensure Index projections are handled properly during capture analysis\n+// The array should be moved in entirety, even though only some elements are used.\n+fn arrays() {\n+    let arr: [String; 5] = [format!(\"A\"), format!(\"B\"), format!(\"C\"), format!(\"D\"), format!(\"E\")];\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let [a, b, .., e] = arr;\n+        //~^ NOTE: Capturing arr[Index] -> ByValue\n+        //~| NOTE: Min Capture arr[] -> ByValue\n+        assert_eq!(a, \"A\");\n+        assert_eq!(b, \"B\");\n+        assert_eq!(e, \"E\");\n+    };\n+\n+    c();\n+}\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+    id: String,\n+}\n+\n+fn structs() {\n+    let mut p = Point { x: 10, y: 10, id: String::new() };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let Point { x: ref mut x, y: _, id: moved_id } = p;\n+        //~^ NOTE: Capturing p[(0, 0)] -> MutBorrow\n+        //~| NOTE: Capturing p[(2, 0)] -> ByValue\n+        //~| NOTE: Min Capture p[(0, 0)] -> MutBorrow\n+        //~| NOTE: Min Capture p[(2, 0)] -> ByValue\n+\n+        println!(\"{}, {}\", x, moved_id);\n+    };\n+    c();\n+}\n+\n+fn tuples() {\n+    let mut t = (10, String::new(), (String::new(), 42));\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let (ref mut x, ref ref_str, (moved_s, _)) = t;\n+        //~^ NOTE: Capturing t[(0, 0)] -> MutBorrow\n+        //~| NOTE: Capturing t[(1, 0)] -> ImmBorrow\n+        //~| NOTE: Capturing t[(2, 0),(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0)] -> MutBorrow\n+        //~| NOTE: Min Capture t[(1, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture t[(2, 0),(0, 0)] -> ByValue\n+\n+        println!(\"{}, {} {}\", x, ref_str, moved_s);\n+    };\n+    c();\n+}\n+\n+fn main() {}"}, {"sha": "06ccc2d7a88b49e5b39d58ea1f72e652b45d8f52", "filename": "src/test/ui/closures/2229_closure_analysis/destructure_patterns.stderr", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdestructure_patterns.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,177 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/destructure_patterns.rs:12:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/destructure_patterns.rs:38:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/destructure_patterns.rs:58:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/destructure_patterns.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/destructure_patterns.rs:15:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let [a, b, .., e] = arr;\n+...  |\n+LL | |         assert_eq!(e, \"E\");\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing arr[Index] -> ByValue\n+  --> $DIR/destructure_patterns.rs:18:29\n+   |\n+LL |         let [a, b, .., e] = arr;\n+   |                             ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/destructure_patterns.rs:15:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let [a, b, .., e] = arr;\n+...  |\n+LL | |         assert_eq!(e, \"E\");\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture arr[] -> ByValue\n+  --> $DIR/destructure_patterns.rs:18:29\n+   |\n+LL |         let [a, b, .., e] = arr;\n+   |                             ^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/destructure_patterns.rs:41:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n+...  |\n+LL | |         println!(\"{}, {}\", x, moved_id);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0)] -> MutBorrow\n+  --> $DIR/destructure_patterns.rs:44:58\n+   |\n+LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n+   |                                                          ^\n+note: Capturing p[(2, 0)] -> ByValue\n+  --> $DIR/destructure_patterns.rs:44:58\n+   |\n+LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n+   |                                                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/destructure_patterns.rs:41:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n+...  |\n+LL | |         println!(\"{}, {}\", x, moved_id);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[(0, 0)] -> MutBorrow\n+  --> $DIR/destructure_patterns.rs:44:58\n+   |\n+LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n+   |                                                          ^\n+note: Min Capture p[(2, 0)] -> ByValue\n+  --> $DIR/destructure_patterns.rs:44:58\n+   |\n+LL |         let Point { x: ref mut x, y: _, id: moved_id } = p;\n+   |                                                          ^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/destructure_patterns.rs:61:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n+...  |\n+LL | |         println!(\"{}, {} {}\", x, ref_str, moved_s);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0)] -> MutBorrow\n+  --> $DIR/destructure_patterns.rs:64:54\n+   |\n+LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n+   |                                                      ^\n+note: Capturing t[(1, 0)] -> ImmBorrow\n+  --> $DIR/destructure_patterns.rs:64:54\n+   |\n+LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n+   |                                                      ^\n+note: Capturing t[(2, 0),(0, 0)] -> ByValue\n+  --> $DIR/destructure_patterns.rs:64:54\n+   |\n+LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n+   |                                                      ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/destructure_patterns.rs:61:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n+...  |\n+LL | |         println!(\"{}, {} {}\", x, ref_str, moved_s);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> MutBorrow\n+  --> $DIR/destructure_patterns.rs:64:54\n+   |\n+LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n+   |                                                      ^\n+note: Min Capture t[(1, 0)] -> ImmBorrow\n+  --> $DIR/destructure_patterns.rs:64:54\n+   |\n+LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n+   |                                                      ^\n+note: Min Capture t[(2, 0),(0, 0)] -> ByValue\n+  --> $DIR/destructure_patterns.rs:64:54\n+   |\n+LL |         let (ref mut x, ref ref_str, (moved_s, _)) = t;\n+   |                                                      ^\n+\n+error: aborting due to 9 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "a3222635b626c4953c709c1c8099dd84211e13d5", "filename": "src/test/ui/closures/2229_closure_analysis/feature-gate-capture_disjoint_fields.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffeature-gate-capture_disjoint_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffeature-gate-capture_disjoint_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffeature-gate-capture_disjoint_fields.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,20 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+fn main() {\n+    let s = format!(\"s\");\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        println!(\"This uses new capture analyysis to capture s={}\", s);\n+        //~^ NOTE: Capturing s[] -> ImmBorrow\n+        //~| NOTE: Min Capture s[] -> ImmBorrow\n+    };\n+}"}, {"sha": "a031360ed34e1acd757979f5b197a76c356e6050", "filename": "src/test/ui/closures/2229_closure_analysis/feature-gate-capture_disjoint_fields.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffeature-gate-capture_disjoint_fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffeature-gate-capture_disjoint_fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffeature-gate-capture_disjoint_fields.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,57 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/feature-gate-capture_disjoint_fields.rs:10:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/feature-gate-capture_disjoint_fields.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/feature-gate-capture_disjoint_fields.rs:13:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"This uses new capture analyysis to capture s={}\", s);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing s[] -> ImmBorrow\n+  --> $DIR/feature-gate-capture_disjoint_fields.rs:16:69\n+   |\n+LL |         println!(\"This uses new capture analyysis to capture s={}\", s);\n+   |                                                                     ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/feature-gate-capture_disjoint_fields.rs:13:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"This uses new capture analyysis to capture s={}\", s);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture s[] -> ImmBorrow\n+  --> $DIR/feature-gate-capture_disjoint_fields.rs:16:69\n+   |\n+LL |         println!(\"This uses new capture analyysis to capture s={}\", s);\n+   |                                                                     ^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "9466e103897fb2c972449c4c9c01a7f6fa035a37", "filename": "src/test/ui/closures/2229_closure_analysis/filter-on-struct-member.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffilter-on-struct-member.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffilter-on-struct-member.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffilter-on-struct-member.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,45 @@\n+// FIXME(arora-aman) add run-pass once 2229 is implemented\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+struct Filter {\n+    div: i32,\n+}\n+impl Filter {\n+    fn allowed(&self, x: i32) -> bool {\n+        x % self.div == 1\n+    }\n+}\n+\n+struct Data {\n+    filter: Filter,\n+    list: Vec<i32>,\n+}\n+impl Data {\n+    fn update(&mut self) {\n+        // The closure passed to filter only captures self.filter,\n+        // therefore mutating self.list is allowed.\n+        self.list.retain(\n+            #[rustc_capture_analysis]\n+            |v| self.filter.allowed(*v),\n+            //~^ ERROR: First Pass analysis includes:\n+            //~| ERROR: Min Capture analysis includes:\n+            //~| NOTE: Capturing self[Deref,(0, 0)] -> ImmBorrow\n+            //~| NOTE: Min Capture self[Deref,(0, 0)] -> ImmBorrow\n+        );\n+    }\n+}\n+\n+fn main() {\n+    let mut d = Data { filter: Filter { div: 3 }, list: Vec::new() };\n+\n+    for i in 1..10 {\n+        d.list.push(i);\n+    }\n+\n+    d.update();\n+}"}, {"sha": "e9420fe5a0c3a814c13b977f5a7aa3ee881e242b", "filename": "src/test/ui/closures/2229_closure_analysis/filter-on-struct-member.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffilter-on-struct-member.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffilter-on-struct-member.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Ffilter-on-struct-member.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,35 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/filter-on-struct-member.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/filter-on-struct-member.rs:28:13\n+   |\n+LL |             |v| self.filter.allowed(*v),\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: Capturing self[Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/filter-on-struct-member.rs:28:17\n+   |\n+LL |             |v| self.filter.allowed(*v),\n+   |                 ^^^^^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/filter-on-struct-member.rs:28:13\n+   |\n+LL |             |v| self.filter.allowed(*v),\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: Min Capture self[Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/filter-on-struct-member.rs:28:17\n+   |\n+LL |             |v| self.filter.allowed(*v),\n+   |                 ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+"}, {"sha": "7d2d4c104d489c8e22f30eb01324b5499cbc0e09", "filename": "src/test/ui/closures/2229_closure_analysis/multilevel-path-1.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-1.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,41 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+struct Wrapper {\n+    p: Point,\n+}\n+\n+fn main() {\n+    let mut w = Wrapper { p: Point { x: 10, y: 10 } };\n+\n+    // Only paths that appears within the closure that directly start off\n+    // a variable defined outside the closure are captured.\n+    //\n+    // Therefore `w.p` is captured\n+    // Note that `wp.x` doesn't start off a variable defined outside the closure.\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let wp = &w.p;\n+        //~^ NOTE: Capturing w[(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture w[(0, 0)] -> ImmBorrow\n+        println!(\"{}\", wp.x);\n+    };\n+\n+    // Since `c` captures `w.p` by an ImmBorrow, `w.p.y` can't be mutated.\n+    let py = &mut w.p.y;\n+    c();\n+\n+    *py = 20\n+}"}, {"sha": "1c8db7952afe714f21a8e537771300171c6bc4cd", "filename": "src/test/ui/closures/2229_closure_analysis/multilevel-path-1.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-1.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,57 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/multilevel-path-1.rs:24:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/multilevel-path-1.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/multilevel-path-1.rs:27:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let wp = &w.p;\n+...  |\n+LL | |         println!(\"{}\", wp.x);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing w[(0, 0)] -> ImmBorrow\n+  --> $DIR/multilevel-path-1.rs:30:19\n+   |\n+LL |         let wp = &w.p;\n+   |                   ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/multilevel-path-1.rs:27:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let wp = &w.p;\n+...  |\n+LL | |         println!(\"{}\", wp.x);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture w[(0, 0)] -> ImmBorrow\n+  --> $DIR/multilevel-path-1.rs:30:19\n+   |\n+LL |         let wp = &w.p;\n+   |                   ^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "540e70138e50ed546f89eb4d15d4e52bf56301e6", "filename": "src/test/ui/closures/2229_closure_analysis/multilevel-path-2.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-2.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,37 @@\n+// FIXME(arora-aman) add run-pass once 2229 is implemented\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+struct Wrapper {\n+    p: Point,\n+}\n+\n+fn main() {\n+    let mut w = Wrapper { p: Point { x: 10, y: 10 } };\n+\n+    let c = #[rustc_capture_analysis]\n+        //~^ ERROR: attributes on expressions are experimental\n+        //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        println!(\"{}\", w.p.x);\n+        //~^ NOTE: Capturing w[(0, 0),(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture w[(0, 0),(0, 0)] -> ImmBorrow\n+    };\n+\n+    // `c` only captures `w.p.x`, therefore it's safe to mutate `w.p.y`.\n+    let py = &mut w.p.y;\n+    c();\n+\n+    *py = 20\n+}"}, {"sha": "37287f6b3bc745f1204effe2384037b5251b3fc1", "filename": "src/test/ui/closures/2229_closure_analysis/multilevel-path-2.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmultilevel-path-2.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,57 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/multilevel-path-2.rs:21:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/multilevel-path-2.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/multilevel-path-2.rs:24:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", w.p.x);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing w[(0, 0),(0, 0)] -> ImmBorrow\n+  --> $DIR/multilevel-path-2.rs:27:24\n+   |\n+LL |         println!(\"{}\", w.p.x);\n+   |                        ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/multilevel-path-2.rs:24:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", w.p.x);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture w[(0, 0),(0, 0)] -> ImmBorrow\n+  --> $DIR/multilevel-path-2.rs:27:24\n+   |\n+LL |         println!(\"{}\", w.p.x);\n+   |                        ^^^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "88620550f2e7c97577ac0037c3a3a9dfd7573450", "filename": "src/test/ui/closures/2229_closure_analysis/nested-closure.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,56 @@\n+// FIXME(arora-aman) add run-pass once 2229 is implemented\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+// This testcase ensures that nested closures are handles properly\n+// - The nested closure is analyzed first.\n+// - The capture kind of the nested closure is accounted for by the enclosing closure\n+// - Any captured path by the nested closure that starts off a local variable in the enclosing\n+// closure is not listed as a capture of the enclosing closure.\n+\n+fn main() {\n+    let mut p = Point { x: 5, y: 20 };\n+\n+    let mut c1 = #[rustc_capture_analysis]\n+        //~^ ERROR: attributes on expressions are experimental\n+        //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        println!(\"{}\", p.x);\n+        //~^ NOTE: Capturing p[(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture p[(0, 0)] -> ImmBorrow\n+        let incr = 10;\n+        let mut c2 = #[rustc_capture_analysis]\n+        //~^ ERROR: attributes on expressions are experimental\n+        //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+        || p.y += incr;\n+        //~^ ERROR: First Pass analysis includes:\n+        //~| ERROR: Min Capture analysis includes:\n+        //~| NOTE: Capturing p[(1, 0)] -> MutBorrow\n+        //~| NOTE: Capturing incr[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[(1, 0)] -> MutBorrow\n+        //~| NOTE: Min Capture incr[] -> ImmBorrow\n+        //~| NOTE: Capturing p[(1, 0)] -> MutBorrow\n+        //~| NOTE: Min Capture p[(1, 0)] -> MutBorrow\n+        c2();\n+        println!(\"{}\", p.y);\n+    };\n+\n+    c1();\n+\n+    let px = &p.x;\n+\n+    println!(\"{}\", px);\n+\n+    c1();\n+}"}, {"sha": "21147be3f1d0896d6527293e9f78f0b9a6bca112", "filename": "src/test/ui/closures/2229_closure_analysis/nested-closure.stderr", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fnested-closure.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,110 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/nested-closure.rs:23:18\n+   |\n+LL |     let mut c1 = #[rustc_capture_analysis]\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/nested-closure.rs:33:22\n+   |\n+LL |         let mut c2 = #[rustc_capture_analysis]\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/nested-closure.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/nested-closure.rs:36:9\n+   |\n+LL |         || p.y += incr;\n+   |         ^^^^^^^^^^^^^^\n+   |\n+note: Capturing p[(1, 0)] -> MutBorrow\n+  --> $DIR/nested-closure.rs:36:12\n+   |\n+LL |         || p.y += incr;\n+   |            ^^^\n+note: Capturing incr[] -> ImmBorrow\n+  --> $DIR/nested-closure.rs:36:19\n+   |\n+LL |         || p.y += incr;\n+   |                   ^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/nested-closure.rs:36:9\n+   |\n+LL |         || p.y += incr;\n+   |         ^^^^^^^^^^^^^^\n+   |\n+note: Min Capture p[(1, 0)] -> MutBorrow\n+  --> $DIR/nested-closure.rs:36:12\n+   |\n+LL |         || p.y += incr;\n+   |            ^^^\n+note: Min Capture incr[] -> ImmBorrow\n+  --> $DIR/nested-closure.rs:36:19\n+   |\n+LL |         || p.y += incr;\n+   |                   ^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/nested-closure.rs:26:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", p.x);\n+...  |\n+LL | |         println!(\"{}\", p.y);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0)] -> ImmBorrow\n+  --> $DIR/nested-closure.rs:29:24\n+   |\n+LL |         println!(\"{}\", p.x);\n+   |                        ^^^\n+note: Capturing p[(1, 0)] -> MutBorrow\n+  --> $DIR/nested-closure.rs:36:12\n+   |\n+LL |         || p.y += incr;\n+   |            ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/nested-closure.rs:26:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", p.x);\n+...  |\n+LL | |         println!(\"{}\", p.y);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[(0, 0)] -> ImmBorrow\n+  --> $DIR/nested-closure.rs:29:24\n+   |\n+LL |         println!(\"{}\", p.x);\n+   |                        ^^^\n+note: Min Capture p[(1, 0)] -> MutBorrow\n+  --> $DIR/nested-closure.rs:36:12\n+   |\n+LL |         || p.y += incr;\n+   |            ^^^\n+\n+error: aborting due to 6 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "16acd2f3206c91ec7c29d7582f5b6312d4b128db", "filename": "src/test/ui/closures/2229_closure_analysis/path-with-array-access.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpath-with-array-access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpath-with-array-access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpath-with-array-access.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,35 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+struct Point {\n+    x: f32,\n+    y: f32,\n+}\n+\n+struct Pentagon {\n+    points: [Point; 5],\n+}\n+\n+fn main() {\n+    let p1 = Point { x: 10.0, y: 10.0 };\n+    let p2 = Point { x: 7.5, y: 12.5 };\n+    let p3 = Point { x: 15.0, y: 15.0 };\n+    let p4 = Point { x: 12.5, y: 12.5 };\n+    let p5 = Point { x: 20.0, y: 10.0 };\n+\n+    let pent = Pentagon { points: [p1, p2, p3, p4, p5] };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        println!(\"{}\", pent.points[5].x);\n+        //~^ NOTE: Capturing pent[(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture pent[(0, 0)] -> ImmBorrow\n+    };\n+}"}, {"sha": "3c8d07ed9ba67b46bb2b667094e86fabfd3c2e5e", "filename": "src/test/ui/closures/2229_closure_analysis/path-with-array-access.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpath-with-array-access.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpath-with-array-access.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpath-with-array-access.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,57 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/path-with-array-access.rs:25:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/path-with-array-access.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/path-with-array-access.rs:28:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", pent.points[5].x);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing pent[(0, 0)] -> ImmBorrow\n+  --> $DIR/path-with-array-access.rs:31:24\n+   |\n+LL |         println!(\"{}\", pent.points[5].x);\n+   |                        ^^^^^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/path-with-array-access.rs:28:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", pent.points[5].x);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture pent[(0, 0)] -> ImmBorrow\n+  --> $DIR/path-with-array-access.rs:31:24\n+   |\n+LL |         println!(\"{}\", pent.points[5].x);\n+   |                        ^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "aaff3531e585046fc2ad73705cf8e162c253a4de", "filename": "src/test/ui/closures/2229_closure_analysis/simple-struct-min-capture.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,41 @@\n+// FIXME(arora-aman) add run-pass once 2229 is implemented\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+// Test to ensure that min analysis meets capture kind for all paths captured.\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut p = Point { x: 10, y: 20 };\n+\n+    //\n+    // Requirements:\n+    // p.x -> MutBoorrow\n+    // p   -> ImmBorrow\n+    //\n+    // Requirements met when p is captured via MutBorrow\n+    //\n+    let mut c = #[rustc_capture_analysis]\n+        //~^ ERROR: attributes on expressions are experimental\n+        //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        p.x += 10;\n+        //~^ NOTE: Capturing p[(0, 0)] -> MutBorrow\n+        //~| NOTE: Min Capture p[] -> MutBorrow\n+        println!(\"{:?}\", p);\n+        //~^ NOTE: Capturing p[] -> ImmBorrow\n+    };\n+\n+    c();\n+}"}, {"sha": "30d3d5f504eb9b472be775dcc22dee3552eab039", "filename": "src/test/ui/closures/2229_closure_analysis/simple-struct-min-capture.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,62 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/simple-struct-min-capture.rs:27:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/simple-struct-min-capture.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/simple-struct-min-capture.rs:30:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         p.x += 10;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0)] -> MutBorrow\n+  --> $DIR/simple-struct-min-capture.rs:33:9\n+   |\n+LL |         p.x += 10;\n+   |         ^^^\n+note: Capturing p[] -> ImmBorrow\n+  --> $DIR/simple-struct-min-capture.rs:36:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/simple-struct-min-capture.rs:30:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         p.x += 10;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> MutBorrow\n+  --> $DIR/simple-struct-min-capture.rs:33:9\n+   |\n+LL |         p.x += 10;\n+   |         ^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "90b8033d074a17357c042d712d1aa50daea37955", "filename": "src/test/ui/closures/2229_closure_analysis/wild_patterns.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fwild_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fwild_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fwild_patterns.rs?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,75 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+// Test to ensure that we can handle cases where\n+// let statements create no bindings are intialized\n+// using a Place expression\n+//\n+// Note: Currently when feature `capture_disjoint_fields` is enabled\n+// we can't handle such cases. So the test current use `_x` instead of\n+// `_` until the issue is resolved.\n+// Check rust-lang/project-rfc-2229#24 for status.\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn wild_struct() {\n+    let p = Point { x: 10, y: 20 };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        // FIXME(arora-aman): Change `_x` to `_`\n+        let Point { x: _x, y: _ } = p;\n+        //~^ NOTE: Capturing p[(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture p[(0, 0)] -> ImmBorrow\n+    };\n+\n+    c();\n+}\n+\n+fn wild_tuple() {\n+    let t = (String::new(), 10);\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        // FIXME(arora-aman): Change `_x` to `_`\n+        let (_x, _) = t;\n+        //~^ NOTE: Capturing t[(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n+    };\n+\n+    c();\n+}\n+\n+fn wild_arr() {\n+    let arr = [String::new(), String::new()];\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        // FIXME(arora-aman): Change `_x` to `_`\n+        let [_x, _] = arr;\n+        //~^ NOTE: Capturing arr[Index] -> ByValue\n+        //~| NOTE: Min Capture arr[] -> ByValue\n+    };\n+\n+    c();\n+}\n+\n+fn main() {}"}, {"sha": "36be8431be508f5f9c7e9de8b683b95b86db6aa7", "filename": "src/test/ui/closures/2229_closure_analysis/wild_patterns.stderr", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fwild_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fwild_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fwild_patterns.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -0,0 +1,147 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/wild_patterns.rs:24:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/wild_patterns.rs:42:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/wild_patterns.rs:60:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/wild_patterns.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/wild_patterns.rs:27:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         // FIXME(arora-aman): Change `_x` to `_`\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0)] -> ImmBorrow\n+  --> $DIR/wild_patterns.rs:31:37\n+   |\n+LL |         let Point { x: _x, y: _ } = p;\n+   |                                     ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/wild_patterns.rs:27:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         // FIXME(arora-aman): Change `_x` to `_`\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[(0, 0)] -> ImmBorrow\n+  --> $DIR/wild_patterns.rs:31:37\n+   |\n+LL |         let Point { x: _x, y: _ } = p;\n+   |                                     ^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/wild_patterns.rs:45:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         // FIXME(arora-aman): Change `_x` to `_`\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0)] -> ByValue\n+  --> $DIR/wild_patterns.rs:49:23\n+   |\n+LL |         let (_x, _) = t;\n+   |                       ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/wild_patterns.rs:45:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         // FIXME(arora-aman): Change `_x` to `_`\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> ByValue\n+  --> $DIR/wild_patterns.rs:49:23\n+   |\n+LL |         let (_x, _) = t;\n+   |                       ^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/wild_patterns.rs:63:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         // FIXME(arora-aman): Change `_x` to `_`\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing arr[Index] -> ByValue\n+  --> $DIR/wild_patterns.rs:67:23\n+   |\n+LL |         let [_x, _] = arr;\n+   |                       ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/wild_patterns.rs:63:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         // FIXME(arora-aman): Change `_x` to `_`\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture arr[] -> ByValue\n+  --> $DIR/wild_patterns.rs:67:23\n+   |\n+LL |         let [_x, _] = arr;\n+   |                       ^^^\n+\n+error: aborting due to 9 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "d590f876b8e77c9acfcf6cee3711fd0087f3868b", "filename": "src/test/ui/generator/print/generator-print-verbose-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c37e86ff1782923e3abfbf5491dd383fcf827d/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-2.stderr?ref=b5c37e86ff1782923e3abfbf5491dd383fcf827d", "patch": "@@ -8,8 +8,8 @@ LL |     assert_send(|| {\n    |     ^^^^^^^^^^^ `Cell<i32>` cannot be shared between threads safely\n    |\n    = help: the trait `Sync` is not implemented for `Cell<i32>`\n-   = note: required because of the requirements on the impl of `Send` for `&'_#3r Cell<i32>`\n-   = note: required because it appears within the type `[main::{closure#1} upvar_tys=(&'_#3r Cell<i32>) _#17t]`\n+   = note: required because of the requirements on the impl of `Send` for `&'_#4r Cell<i32>`\n+   = note: required because it appears within the type `[main::{closure#1} upvar_tys=(&'_#4r Cell<i32>) _#17t]`\n \n error: generator cannot be shared between threads safely\n   --> $DIR/generator-print-verbose-2.rs:12:5"}]}