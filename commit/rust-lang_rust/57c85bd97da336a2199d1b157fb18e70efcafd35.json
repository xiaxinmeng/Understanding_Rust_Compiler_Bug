{"sha": "57c85bd97da336a2199d1b157fb18e70efcafd35", "node_id": "C_kwDOAAsO6NoAKDU3Yzg1YmQ5N2RhMzM2YTIxOTlkMWIxNTdmYjE4ZTcwZWZjYWZkMzU", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-17T10:55:00Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-18T08:48:06Z"}, "message": "Remove need to give JSON file path", "tree": {"sha": "c59dc1a3e33951fa5c5eb40896c359ca1c3eaf53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c59dc1a3e33951fa5c5eb40896c359ca1c3eaf53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57c85bd97da336a2199d1b157fb18e70efcafd35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57c85bd97da336a2199d1b157fb18e70efcafd35", "html_url": "https://github.com/rust-lang/rust/commit/57c85bd97da336a2199d1b157fb18e70efcafd35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57c85bd97da336a2199d1b157fb18e70efcafd35/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c20b2a8cc7588decb6de25ac6a7912dcef24d65", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c20b2a8cc7588decb6de25ac6a7912dcef24d65", "html_url": "https://github.com/rust-lang/rust/commit/9c20b2a8cc7588decb6de25ac6a7912dcef24d65"}], "stats": {"total": 160, "additions": 53, "deletions": 107}, "files": [{"sha": "f9e54232750b63f7f99d6876061e980aead8a029", "filename": "src/tools/jsondocck/src/cache.rs", "status": "modified", "additions": 12, "deletions": 58, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/57c85bd97da336a2199d1b157fb18e70efcafd35/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57c85bd97da336a2199d1b157fb18e70efcafd35/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Fcache.rs?ref=57c85bd97da336a2199d1b157fb18e70efcafd35", "patch": "@@ -1,77 +1,31 @@\n-use crate::error::CkError;\n+use crate::config::Config;\n use serde_json::Value;\n use std::collections::HashMap;\n-use std::io;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n \n use fs_err as fs;\n \n #[derive(Debug)]\n pub struct Cache {\n-    root: PathBuf,\n-    files: HashMap<PathBuf, String>,\n-    values: HashMap<PathBuf, Value>,\n+    value: Value,\n     pub variables: HashMap<String, Value>,\n-    last_path: Option<PathBuf>,\n }\n \n impl Cache {\n     /// Create a new cache, used to read files only once and otherwise store their contents.\n-    pub fn new(doc_dir: &str) -> Cache {\n+    pub fn new(config: &Config) -> Cache {\n+        let root = Path::new(&config.doc_dir);\n+        let filename = Path::new(&config.template).file_stem().unwrap();\n+        let file_path = root.join(&Path::with_extension(Path::new(filename), \"json\"));\n+        let content = fs::read_to_string(&file_path).expect(\"failed to read JSON file\");\n+\n         Cache {\n-            root: Path::new(doc_dir).to_owned(),\n-            files: HashMap::new(),\n-            values: HashMap::new(),\n+            value: serde_json::from_str::<Value>(&content).expect(\"failed to convert from JSON\"),\n             variables: HashMap::new(),\n-            last_path: None,\n         }\n     }\n \n-    fn resolve_path(&mut self, path: &String) -> PathBuf {\n-        if path != \"-\" {\n-            let resolve = self.root.join(path);\n-            self.last_path = Some(resolve.clone());\n-            resolve\n-        } else {\n-            self.last_path\n-                .as_ref()\n-                // FIXME: Point to a line number\n-                .expect(\"No last path set. Make sure to specify a full path before using `-`\")\n-                .clone()\n-        }\n-    }\n-\n-    fn read_file(&mut self, path: PathBuf) -> Result<String, io::Error> {\n-        if let Some(f) = self.files.get(&path) {\n-            return Ok(f.clone());\n-        }\n-\n-        let file = fs::read_to_string(&path)?;\n-\n-        self.files.insert(path, file.clone());\n-\n-        Ok(file)\n-    }\n-\n-    /// Get the text from a file. If called multiple times, the file will only be read once\n-    pub fn get_file(&mut self, path: &String) -> Result<String, io::Error> {\n-        let path = self.resolve_path(path);\n-        self.read_file(path)\n-    }\n-\n-    /// Parse the JSON from a file. If called multiple times, the file will only be read once.\n-    pub fn get_value(&mut self, path: &String) -> Result<Value, CkError> {\n-        let path = self.resolve_path(path);\n-\n-        if let Some(v) = self.values.get(&path) {\n-            return Ok(v.clone());\n-        }\n-\n-        let content = self.read_file(path.clone())?;\n-        let val = serde_json::from_str::<Value>(&content)?;\n-\n-        self.values.insert(path, val.clone());\n-\n-        Ok(val)\n+    pub fn value(&self) -> &Value {\n+        &self.value\n     }\n }"}, {"sha": "76770fe36a70884a24f3cf1a3704bf11101def67", "filename": "src/tools/jsondocck/src/main.rs", "status": "modified", "additions": 41, "deletions": 49, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/57c85bd97da336a2199d1b157fb18e70efcafd35/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57c85bd97da336a2199d1b157fb18e70efcafd35/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs?ref=57c85bd97da336a2199d1b157fb18e70efcafd35", "patch": "@@ -17,7 +17,7 @@ fn main() -> Result<(), String> {\n     let config = parse_config(env::args().collect());\n \n     let mut failed = Vec::new();\n-    let mut cache = Cache::new(&config.doc_dir);\n+    let mut cache = Cache::new(&config);\n     let commands = get_commands(&config.template)\n         .map_err(|_| format!(\"Jsondocck failed for {}\", &config.template))?;\n \n@@ -55,28 +55,23 @@ pub enum CommandKind {\n }\n \n impl CommandKind {\n-    fn validate(&self, args: &[String], command_num: usize, lineno: usize) -> bool {\n+    fn validate(&self, args: &[String], lineno: usize) -> bool {\n         let count = match self {\n-            CommandKind::Has => (1..=3).contains(&args.len()),\n-            CommandKind::IsMany => args.len() >= 3,\n-            CommandKind::Count | CommandKind::Is => 3 == args.len(),\n-            CommandKind::Set => 4 == args.len(),\n+            CommandKind::Has => (1..=2).contains(&args.len()),\n+            CommandKind::IsMany => args.len() >= 2,\n+            CommandKind::Count | CommandKind::Is => 2 == args.len(),\n+            CommandKind::Set => 3 == args.len(),\n         };\n \n         if !count {\n             print_err(&format!(\"Incorrect number of arguments to `@{}`\", self), lineno);\n             return false;\n         }\n \n-        if args[0] == \"-\" && command_num == 0 {\n-            print_err(&format!(\"Tried to use the previous path in the first command\"), lineno);\n-            return false;\n-        }\n-\n         if let CommandKind::Count = self {\n-            if args[2].parse::<usize>().is_err() {\n+            if args[1].parse::<usize>().is_err() {\n                 print_err(\n-                    &format!(\"Third argument to @count must be a valid usize (got `{}`)\", args[2]),\n+                    &format!(\"Second argument to @count must be a valid usize (got `{}`)\", args[2]),\n                     lineno,\n                 );\n                 return false;\n@@ -181,7 +176,7 @@ fn get_commands(template: &str) -> Result<Vec<Command>, ()> {\n             }\n         };\n \n-        if !cmd.validate(&args, commands.len(), lineno) {\n+        if !cmd.validate(&args, lineno) {\n             errors = true;\n             continue;\n         }\n@@ -199,26 +194,24 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n     let result = match command.kind {\n         CommandKind::Has => {\n             match command.args.len() {\n-                // @has <path> = file existence\n-                1 => cache.get_file(&command.args[0]).is_ok(),\n-                // @has <path> <jsonpath> = check path exists\n-                2 => {\n-                    let val = cache.get_value(&command.args[0])?;\n-                    let results = select(&val, &command.args[1]).unwrap();\n+                // @has <jsonpath> = check path exists\n+                1 => {\n+                    let val = cache.value();\n+                    let results = select(val, &command.args[0]).unwrap();\n                     !results.is_empty()\n                 }\n-                // @has <path> <jsonpath> <value> = check *any* item matched by path equals value\n-                3 => {\n-                    let val = cache.get_value(&command.args[0])?;\n-                    let results = select(&val, &command.args[1]).unwrap();\n-                    let pat = string_to_value(&command.args[2], cache);\n+                // @has <jsonpath> <value> = check *any* item matched by path equals value\n+                2 => {\n+                    let val = cache.value().clone();\n+                    let results = select(&val, &command.args[0]).unwrap();\n+                    let pat = string_to_value(&command.args[1], cache);\n                     let has = results.contains(&pat.as_ref());\n                     // Give better error for when @has check fails\n                     if !command.negated && !has {\n                         return Err(CkError::FailedCheck(\n                             format!(\n                                 \"{} matched to {:?} but didn't have {:?}\",\n-                                &command.args[1],\n+                                &command.args[0],\n                                 results,\n                                 pat.as_ref()\n                             ),\n@@ -233,13 +226,13 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n         }\n         CommandKind::IsMany => {\n             // @ismany <path> <jsonpath> <value>...\n-            let (path, query, values) = if let [path, query, values @ ..] = &command.args[..] {\n-                (path, query, values)\n+            let (query, values) = if let [query, values @ ..] = &command.args[..] {\n+                (query, values)\n             } else {\n                 unreachable!(\"Checked in CommandKind::validate\")\n             };\n-            let val = cache.get_value(path)?;\n-            let got_values = select(&val, &query).unwrap();\n+            let val = cache.value();\n+            let got_values = select(val, &query).unwrap();\n             assert!(!command.negated, \"`@!ismany` is not supported\");\n \n             // Serde json doesn't implement Ord or Hash for Value, so we must\n@@ -270,18 +263,17 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n             true\n         }\n         CommandKind::Count => {\n-            // @count <path> <jsonpath> <count> = Check that the jsonpath matches exactly [count] times\n-            assert_eq!(command.args.len(), 3);\n-            let expected: usize = command.args[2].parse().unwrap();\n-\n-            let val = cache.get_value(&command.args[0])?;\n-            let results = select(&val, &command.args[1]).unwrap();\n+            // @count <jsonpath> <count> = Check that the jsonpath matches exactly [count] times\n+            assert_eq!(command.args.len(), 2);\n+            let expected: usize = command.args[1].parse().unwrap();\n+            let val = cache.value();\n+            let results = select(val, &command.args[0]).unwrap();\n             let eq = results.len() == expected;\n             if !command.negated && !eq {\n                 return Err(CkError::FailedCheck(\n                     format!(\n                         \"`{}` matched to `{:?}` with length {}, but expected length {}\",\n-                        &command.args[1],\n+                        &command.args[0],\n                         results,\n                         results.len(),\n                         expected\n@@ -293,17 +285,17 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n             }\n         }\n         CommandKind::Is => {\n-            // @has <path> <jsonpath> <value> = check *exactly one* item matched by path, and it equals value\n-            assert_eq!(command.args.len(), 3);\n-            let val = cache.get_value(&command.args[0])?;\n-            let results = select(&val, &command.args[1]).unwrap();\n-            let pat = string_to_value(&command.args[2], cache);\n+            // @has <jsonpath> <value> = check *exactly one* item matched by path, and it equals value\n+            assert_eq!(command.args.len(), 2);\n+            let val = cache.value().clone();\n+            let results = select(&val, &command.args[0]).unwrap();\n+            let pat = string_to_value(&command.args[1], cache);\n             let is = results.len() == 1 && results[0] == pat.as_ref();\n             if !command.negated && !is {\n                 return Err(CkError::FailedCheck(\n                     format!(\n                         \"{} matched to {:?}, but expected {:?}\",\n-                        &command.args[1],\n+                        &command.args[0],\n                         results,\n                         pat.as_ref()\n                     ),\n@@ -314,16 +306,16 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n             }\n         }\n         CommandKind::Set => {\n-            // @set <name> = <path> <jsonpath>\n-            assert_eq!(command.args.len(), 4);\n+            // @set <name> = <jsonpath>\n+            assert_eq!(command.args.len(), 3);\n             assert_eq!(command.args[1], \"=\", \"Expected an `=`\");\n-            let val = cache.get_value(&command.args[2])?;\n-            let results = select(&val, &command.args[3]).unwrap();\n+            let val = cache.value().clone();\n+            let results = select(&val, &command.args[2]).unwrap();\n             assert_eq!(\n                 results.len(),\n                 1,\n                 \"Expected 1 match for `{}` (because of @set): matched to {:?}\",\n-                command.args[3],\n+                command.args[2],\n                 results\n             );\n             match results.len() {\n@@ -336,7 +328,7 @@ fn check_command(command: Command, cache: &mut Cache) -> Result<(), CkError> {\n                 _ => {\n                     panic!(\n                         \"Got multiple results in `@set` for `{}`: {:?}\",\n-                        &command.args[3], results\n+                        &command.args[2], results,\n                     );\n                 }\n             }"}]}