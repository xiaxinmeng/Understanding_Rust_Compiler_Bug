{"sha": "a20953906056f85f71896795e762ac242e1891aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMDk1MzkwNjA1NmY4NWY3MTg5Njc5NWU3NjJhYzI0MmUxODkxYWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-06T11:24:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-06T11:24:18Z"}, "message": "Auto merge of #43849 - QuietMisdreavus:foreign-impls, r=steveklabnik\n\nrustdoc: add new \"Implementations on Foreign Types\" section to traits\n\nDemo screenshot:\n\n![image](https://user-images.githubusercontent.com/5217170/29281219-c547f758-80e3-11e7-808f-49f592c65c5b.png)\n\nFull demo available at https://tonberry.quietmisdreavus.net/foreign-test/foreign_test/trait.CheckIt.html\n\nThis PR splits the \"Implementors\" section on trait pages into two: First, for impls on types local to the crate, their impls are kept as-is, printing one line for the impl line, and any additional lines for associated types. However, for types external to the crate, they are now pulled up over the others and are printed (almost) like the summary impl on the type page itself. This gives any doc comments on these impls or methods to be exposed in the documentation.\n\nThere's just one small problem, though: [libstd docs apparently surface impls for libc and rand, possibly among others](https://tonberry.quietmisdreavus.net/foreign-std/std/marker/trait.Copy.html#foreign-impls). This adds this section to pages in the std docs where we might not want them to show up in the first place. I think this is a bug distinct from this PR, but it does make it drastically apparent.\n\n~~My question, then, is this: Do we want this here? Taking it out involves fixing which impls are visible to rustdoc, possibly specifically when rendering the std facade. I'm convinced this is fine to land as-is, since it adds a feature specifically for non-std crates (i'm thinking of things like `num` or related crates that implement things on primitives or std types as part of their functionality).~~ (EDIT: I have an open PR to fix this: https://github.com/rust-lang/rust/pull/44026)", "tree": {"sha": "900231998a6226ba52127819ec0e74d129557b04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/900231998a6226ba52127819ec0e74d129557b04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a20953906056f85f71896795e762ac242e1891aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a20953906056f85f71896795e762ac242e1891aa", "html_url": "https://github.com/rust-lang/rust/commit/a20953906056f85f71896795e762ac242e1891aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a20953906056f85f71896795e762ac242e1891aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f83d20eff734310a0381b7c71e0192988b6b0847", "url": "https://api.github.com/repos/rust-lang/rust/commits/f83d20eff734310a0381b7c71e0192988b6b0847", "html_url": "https://github.com/rust-lang/rust/commit/f83d20eff734310a0381b7c71e0192988b6b0847"}, {"sha": "a9f0f6df94c4d08fe300b6e06941aea9c7324530", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f0f6df94c4d08fe300b6e06941aea9c7324530", "html_url": "https://github.com/rust-lang/rust/commit/a9f0f6df94c4d08fe300b6e06941aea9c7324530"}], "stats": {"total": 100, "additions": 86, "deletions": 14}, "files": [{"sha": "60651bd617f959066d3bdf080145be4c08e4a3f5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a20953906056f85f71896795e762ac242e1891aa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a20953906056f85f71896795e762ac242e1891aa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a20953906056f85f71896795e762ac242e1891aa", "patch": "@@ -1651,6 +1651,16 @@ impl GetDefId for Type {\n     fn def_id(&self) -> Option<DefId> {\n         match *self {\n             ResolvedPath { did, .. } => Some(did),\n+            Primitive(p) => ::html::render::cache().primitive_locations.get(&p).cloned(),\n+            BorrowedRef { type_: box Generic(..), .. } =>\n+                Primitive(PrimitiveType::Reference).def_id(),\n+            BorrowedRef { ref type_, .. } => type_.def_id(),\n+            Tuple(..) => Primitive(PrimitiveType::Tuple).def_id(),\n+            BareFunction(..) => Primitive(PrimitiveType::Fn).def_id(),\n+            Slice(..) => Primitive(PrimitiveType::Slice).def_id(),\n+            Array(..) => Primitive(PrimitiveType::Array).def_id(),\n+            RawPointer(..) => Primitive(PrimitiveType::RawPointer).def_id(),\n+            QPath { ref self_type, .. } => self_type.def_id(),\n             _ => None,\n         }\n     }"}, {"sha": "46bb119cf9c9d3b04cd4cc5320c365f1001d6584", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 76, "deletions": 14, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a20953906056f85f71896795e762ac242e1891aa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a20953906056f85f71896795e762ac242e1891aa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a20953906056f85f71896795e762ac242e1891aa", "patch": "@@ -2416,12 +2416,12 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)?;\n \n     let cache = cache();\n-    write!(w, \"\n+    let impl_header = \"\n         <h2 id='implementors' class='small-section-header'>\n           Implementors<a href='#implementors' class='anchor'></a>\n         </h2>\n         <ul class='item-list' id='implementors-list'>\n-    \")?;\n+    \";\n     if let Some(implementors) = cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n@@ -2443,7 +2443,38 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             }\n         }\n \n-        for implementor in implementors {\n+        let (local, foreign) = implementors.iter()\n+            .partition::<Vec<_>, _>(|i| i.impl_.for_.def_id()\n+                                         .map_or(true, |d| cache.paths.contains_key(&d)));\n+\n+        if !foreign.is_empty() {\n+            write!(w, \"\n+                <h2 id='foreign-impls' class='section-header'>\n+                  Implementations on Foreign Types<a href='#foreign-impls' class='anchor'></a>\n+                </h2>\n+            \")?;\n+\n+            for implementor in foreign {\n+                // need to get from a clean::Impl to a clean::Item so i can use render_impl\n+                if let Some(t_did) = implementor.impl_.for_.def_id() {\n+                    if let Some(impl_item) = cache.impls.get(&t_did).and_then(|i| i.iter()\n+                        .find(|i| i.impl_item.def_id == implementor.def_id))\n+                    {\n+                        let i = &impl_item.impl_item;\n+                        let impl_ = Impl { impl_item: i.clone() };\n+                        let assoc_link = AssocItemLink::GotoSource(\n+                            i.def_id, &implementor.impl_.provided_trait_methods\n+                        );\n+                        render_impl(w, cx, &impl_, assoc_link,\n+                                    RenderMode::Normal, i.stable_since(), false)?;\n+                    }\n+                }\n+            }\n+        }\n+\n+        write!(w, \"{}\", impl_header)?;\n+\n+        for implementor in local {\n             write!(w, \"<li><code>\")?;\n             // If there's already another implementor that has the same abbridged name, use the\n             // full path, for example in `std::iter::ExactSizeIterator`\n@@ -2465,6 +2496,10 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             }\n             writeln!(w, \"</code></li>\")?;\n         }\n+    } else {\n+        // even without any implementations to write in, we still want the heading and list, so the\n+        // implementors javascript file pulled in below has somewhere to write the impls into\n+        write!(w, \"{}\", impl_header)?;\n     }\n     write!(w, \"</ul>\")?;\n     write!(w, r#\"<script type=\"text/javascript\" async\n@@ -3069,7 +3104,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         };\n         for i in &non_trait {\n             render_impl(w, cx, i, AssocItemLink::Anchor(None), render_mode,\n-                        containing_item.stable_since())?;\n+                        containing_item.stable_since(), true)?;\n         }\n     }\n     if let AssocItemRender::DerefFor { .. } = what {\n@@ -3094,7 +3129,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n             let did = i.trait_did().unwrap();\n             let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n             render_impl(w, cx, i, assoc_link,\n-                        RenderMode::Normal, containing_item.stable_since())?;\n+                        RenderMode::Normal, containing_item.stable_since(), true)?;\n         }\n     }\n     Ok(())\n@@ -3124,7 +3159,8 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n }\n \n fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLink,\n-               render_mode: RenderMode, outer_version: Option<&str>) -> fmt::Result {\n+               render_mode: RenderMode, outer_version: Option<&str>,\n+               show_def_docs: bool) -> fmt::Result {\n     if render_mode == RenderMode::Normal {\n         let id = derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => format!(\"impl-{}\", Escape(&format!(\"{:#}\", t))),\n@@ -3153,7 +3189,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     fn doc_impl_item(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n                      link: AssocItemLink, render_mode: RenderMode,\n                      is_default_item: bool, outer_version: Option<&str>,\n-                     trait_: Option<&clean::Trait>) -> fmt::Result {\n+                     trait_: Option<&clean::Trait>, show_def_docs: bool) -> fmt::Result {\n         let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n \n@@ -3248,19 +3284,23 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                         document_stability(w, cx, it)?;\n                         if item.doc_value().is_some() {\n                             document_full(w, item, cx, &prefix)?;\n-                        } else {\n+                        } else if show_def_docs {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n                             document_short(w, it, link, cx, &prefix)?;\n                         }\n                     }\n                 } else {\n                     document_stability(w, cx, item)?;\n-                    document_full(w, item, cx, &prefix)?;\n+                    if show_def_docs {\n+                        document_full(w, item, cx, &prefix)?;\n+                    }\n                 }\n             } else {\n                 document_stability(w, cx, item)?;\n-                document_short(w, item, link, cx, &prefix)?;\n+                if show_def_docs {\n+                    document_short(w, item, link, cx, &prefix)?;\n+                }\n             }\n         }\n         Ok(())\n@@ -3269,18 +3309,23 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     let traits = &cache().traits;\n     let trait_ = i.trait_did().and_then(|did| traits.get(&did));\n \n+    if !show_def_docs {\n+        write!(w, \"<span class='docblock autohide'>\")?;\n+    }\n+\n     write!(w, \"<div class='impl-items'>\")?;\n     for trait_item in &i.inner_impl().items {\n         doc_impl_item(w, cx, trait_item, link, render_mode,\n-                      false, outer_version, trait_)?;\n+                      false, outer_version, trait_, show_def_docs)?;\n     }\n \n     fn render_default_items(w: &mut fmt::Formatter,\n                             cx: &Context,\n                             t: &clean::Trait,\n                             i: &clean::Impl,\n                             render_mode: RenderMode,\n-                            outer_version: Option<&str>) -> fmt::Result {\n+                            outer_version: Option<&str>,\n+                            show_def_docs: bool) -> fmt::Result {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n             if i.items.iter().find(|m| m.name == n).is_some() {\n@@ -3290,17 +3335,23 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             let assoc_link = AssocItemLink::GotoSource(did, &i.provided_trait_methods);\n \n             doc_impl_item(w, cx, trait_item, assoc_link, render_mode, true,\n-                          outer_version, None)?;\n+                          outer_version, None, show_def_docs)?;\n         }\n         Ok(())\n     }\n \n     // If we've implemented a trait, then also emit documentation for all\n     // default items which weren't overridden in the implementation block.\n     if let Some(t) = trait_ {\n-        render_default_items(w, cx, t, &i.inner_impl(), render_mode, outer_version)?;\n+        render_default_items(w, cx, t, &i.inner_impl(),\n+                             render_mode, outer_version, show_def_docs)?;\n     }\n     write!(w, \"</div>\")?;\n+\n+    if !show_def_docs {\n+        write!(w, \"</span>\")?;\n+    }\n+\n     Ok(())\n }\n \n@@ -3484,6 +3535,17 @@ fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n \n     sidebar.push_str(&sidebar_assoc_items(it));\n \n+    let c = cache();\n+\n+    if let Some(implementors) = c.implementors.get(&it.def_id) {\n+        if implementors.iter().any(|i| i.impl_.for_.def_id()\n+                                   .map_or(false, |d| !c.paths.contains_key(&d)))\n+        {\n+            sidebar.push_str(\"<li><a href=\\\"#foreign-impls\\\">\\\n+                             Implementations on Foreign Types</a></li>\");\n+        }\n+    }\n+\n     sidebar.push_str(\"<li><a href=\\\"#implementors\\\">Implementors</a></li>\");\n \n     write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)"}]}