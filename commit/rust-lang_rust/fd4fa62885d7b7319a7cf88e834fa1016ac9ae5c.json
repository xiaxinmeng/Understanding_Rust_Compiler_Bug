{"sha": "fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNGZhNjI4ODVkN2I3MzE5YTdjZjg4ZTgzNGZhMTAxNmFjOWFlNWM=", "commit": {"author": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-03-08T00:07:06Z"}, "committer": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-03-14T20:49:18Z"}, "message": "derive: remove most __ strings FIXME(#2810)\n\nThis changes local variable names in all derives to remove leading\ndouble-underscores. As far as I can tell, this doesn't break anything\nbecause there is no user code in these generated functions except for\nstruct, field and type parameter names, and this doesn't cause shadowing\nof those. But I am still a bit nervous.", "tree": {"sha": "32cd52dc4ad079cb4ce80e84e7fbe388708f2fa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32cd52dc4ad079cb4ce80e84e7fbe388708f2fa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c", "html_url": "https://github.com/rust-lang/rust/commit/fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4982f913461a2a6dfbac8bace53961233322646a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4982f913461a2a6dfbac8bace53961233322646a", "html_url": "https://github.com/rust-lang/rust/commit/4982f913461a2a6dfbac8bace53961233322646a"}], "stats": {"total": 96, "additions": 48, "deletions": 48}, "files": [{"sha": "a69d57423a22cf296687e1981afa286abd48ccbf", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c", "patch": "@@ -64,7 +64,7 @@ pub fn ordering_collapsed(cx: &mut ExtCtxt,\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> P<Expr> {\n-    let test_id = cx.ident_of(\"__test\");\n+    let test_id = cx.ident_of(\"cmp\");\n     let equals_path = cx.path_global(span,\n                                      cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n \n@@ -79,9 +79,9 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n                 ::std::cmp::Ordering::Equal => {\n                     ...\n                 }\n-                __test => __test\n+                cmp => cmp\n             },\n-        __test => __test\n+        cmp => cmp\n     }\n     */\n     cs_fold(\n@@ -91,7 +91,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n         |cx, span, old, self_f, other_fs| {\n             // match new {\n             //     ::std::cmp::Ordering::Equal => old,\n-            //     __test => __test\n+            //     cmp => cmp\n             // }\n \n             let new = {"}, {"sha": "b3864a6c2e79e3e609a1b9ad5b553ee9cc0d810d", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c", "patch": "@@ -107,7 +107,7 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> P<Expr> {\n-    let test_id = cx.ident_of(\"__test\");\n+    let test_id = cx.ident_of(\"cmp\");\n     let ordering = cx.path_global(span,\n                                   cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n@@ -124,9 +124,9 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n                 ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {\n                     ...\n                 }\n-                __test => __test\n+                cmp => cmp\n             },\n-        __test => __test\n+        cmp => cmp\n     }\n     */\n     cs_fold(\n@@ -136,7 +136,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n         |cx, span, old, self_f, other_fs| {\n             // match new {\n             //     Some(::std::cmp::Ordering::Equal) => old,\n-            //     __test => __test\n+            //     cmp => cmp\n             // }\n \n             let new = {"}, {"sha": "f72fa98b482ab36bdf91fc6351a31d9056e73687", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=fd4fa62885d7b7319a7cf88e834fa1016ac9ae5c", "patch": "@@ -156,14 +156,14 @@\n //!\n //! ```{.text}\n //! EnumNonMatchingCollapsed(\n-//!     vec![<ident of self>, <ident of __arg_1>],\n+//!     vec![<ident of self>, <ident of arg_1>],\n //!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n-//!     &[<ident for self index value>, <ident of __arg_1 index value>])\n+//!     &[<ident for self index value>, <ident of arg_1 index value>])\n //! ```\n //!\n //! It is the same for when the arguments are flipped to `C1 {x}` and\n //! `C0(a)`; the only difference is what the values of the identifiers\n-//! <ident for self index value> and <ident of __arg_1 index value> will\n+//! <ident for self index value> and <ident of arg_1 index value> will\n //! be in the generated code.\n //!\n //! `EnumNonMatchingCollapsed` deliberately provides far less information\n@@ -826,7 +826,7 @@ impl<'a> MethodDef<'a> {\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(&format!(\"__arg_{}\", i));\n+            let ident = cx.ident_of(&format!(\"arg_{}\", i));\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -911,12 +911,12 @@ impl<'a> MethodDef<'a> {\n     ///\n     /// // equivalent to:\n     /// impl PartialEq for A {\n-    ///     fn eq(&self, __arg_1: &A) -> bool {\n+    ///     fn eq(&self, arg_1: &A) -> bool {\n     ///         match *self {\n-    ///             A {x: ref __self_0_0, y: ref __self_0_1} => {\n-    ///                 match *__arg_1 {\n-    ///                     A {x: ref __self_1_0, y: ref __self_1_1} => {\n-    ///                         __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n+    ///             A {x: ref self_0_0, y: ref self_0_1} => {\n+    ///                 match *arg_1 {\n+    ///                     A {x: ref self_1_0, y: ref self_1_1} => {\n+    ///                         self_0_0.eq(self_1_0) && self_0_1.eq(self_1_1)\n     ///                     }\n     ///                 }\n     ///             }\n@@ -942,7 +942,7 @@ impl<'a> MethodDef<'a> {\n                 trait_.create_struct_pattern(cx,\n                                              struct_path,\n                                              struct_def,\n-                                             &format!(\"__self_{}\",\n+                                             &format!(\"self_{}\",\n                                                      i),\n                                              ast::Mutability::Immutable);\n             patterns.push(pat);\n@@ -1020,25 +1020,25 @@ impl<'a> MethodDef<'a> {\n     /// // is equivalent to\n     ///\n     /// impl PartialEq for A {\n-    ///     fn eq(&self, __arg_1: &A) -> ::bool {\n-    ///         match (&*self, &*__arg_1) {\n+    ///     fn eq(&self, arg_1: &A) -> ::bool {\n+    ///         match (&*self, &*arg_1) {\n     ///             (&A1, &A1) => true,\n-    ///             (&A2(ref __self_0),\n-    ///              &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n+    ///             (&A2(ref self_0),\n+    ///              &A2(ref arg_1_0)) => (*self_0).eq(&(*arg_1_0)),\n     ///             _ => {\n-    ///                 let __self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n-    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0, A2(..) => 1 };\n+    ///                 let self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n+    ///                 let arg_1_vi = match *arg_1 { A1(..) => 0, A2(..) => 1 };\n     ///                 false\n     ///             }\n     ///         }\n     ///     }\n     /// }\n     /// ```\n     ///\n-    /// (Of course `__self_vi` and `__arg_1_vi` are unused for\n+    /// (Of course `self_vi` and `arg_1_vi` are unused for\n     /// `PartialEq`, and those subcomputations will hopefully be removed\n-    /// as their results are unused.  The point of `__self_vi` and\n-    /// `__arg_1_vi` is for `PartialOrd`; see #15503.)\n+    /// as their results are unused.  The point of `self_vi` and\n+    /// `arg_1_vi` is for `PartialOrd`; see #15503.)\n     fn expand_enum_method_body<'b>(&self,\n                                cx: &mut ExtCtxt,\n                                trait_: &TraitDef<'b>,\n@@ -1069,14 +1069,14 @@ impl<'a> MethodDef<'a> {\n     /// for each of the self-args, carried in precomputed variables.\n \n     /// ```{.text}\n-    /// let __self0_vi = unsafe {\n+    /// let self0_vi = unsafe {\n     ///     std::intrinsics::discriminant_value(&self) } as i32;\n-    /// let __self1_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&__arg1) } as i32;\n-    /// let __self2_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&__arg2) } as i32;\n+    /// let self1_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&arg1) } as i32;\n+    /// let self2_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&arg2) } as i32;\n     ///\n-    /// if __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n+    /// if self0_vi == self1_vi && self0_vi == self2_vi && ... {\n     ///     match (...) {\n     ///         (Variant1, Variant1, ...) => Body1\n     ///         (Variant2, Variant2, ...) => Body2,\n@@ -1104,9 +1104,9 @@ impl<'a> MethodDef<'a> {\n         let self_arg_names = self_args.iter().enumerate()\n             .map(|(arg_count, _self_arg)| {\n                 if arg_count == 0 {\n-                    \"__self\".to_string()\n+                    \"self\".to_string()\n                 } else {\n-                    format!(\"__arg_{}\", arg_count)\n+                    format!(\"arg_{}\", arg_count)\n                 }\n             })\n             .collect::<Vec<String>>();\n@@ -1243,17 +1243,17 @@ impl<'a> MethodDef<'a> {\n             // with three Self args, builds three statements:\n             //\n             // ```\n-            // let __self0_vi = unsafe {\n+            // let self0_vi = unsafe {\n             //     std::intrinsics::discriminant_value(&self) } as i32;\n-            // let __self1_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&__arg1) } as i32;\n-            // let __self2_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&__arg2) } as i32;\n+            // let self1_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&arg1) } as i32;\n+            // let self2_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&arg2) } as i32;\n             // ```\n             let mut index_let_stmts: Vec<ast::Stmt> = Vec::new();\n \n             //We also build an expression which checks whether all discriminants are equal\n-            // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n+            // discriminant_test = self0_vi == self1_vi && self0_vi == self2_vi && ...\n             let mut discriminant_test = cx.expr_bool(sp, true);\n \n             let target_type_name =\n@@ -1312,7 +1312,7 @@ impl<'a> MethodDef<'a> {\n             // down to desired l-values, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n-            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+            // `(*self, *arg_0, ...)` into `(&*self, &*arg_0, ...)`.\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n             let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n \n@@ -1326,7 +1326,7 @@ impl<'a> MethodDef<'a> {\n             //      }\n             //  }\n             //  else {\n-            //      <delegated expression referring to __self0_vi, et al.>\n+            //      <delegated expression referring to self0_vi, et al.>\n             //  }\n             let all_match = cx.expr_match(sp, match_arg, match_arms);\n             let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n@@ -1350,8 +1350,8 @@ impl<'a> MethodDef<'a> {\n             // error-prone, since the catch-all as defined above would\n             // generate code like this:\n             //\n-            //     _ => { let __self0 = match *self { };\n-            //            let __self1 = match *__arg_0 { };\n+            //     _ => { let self0 = match *self { };\n+            //            let self1 = match *arg_0 { };\n             //            <catch-all-expr> }\n             //\n             // Which is yields bindings for variables which type\n@@ -1390,7 +1390,7 @@ impl<'a> MethodDef<'a> {\n             // down to desired l-values, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n-            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+            // `(*self, *arg_0, ...)` into `(&*self, &*arg_0, ...)`.\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n             let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n             cx.expr_match(sp, match_arg, match_arms)\n@@ -1604,8 +1604,8 @@ pub fn cs_fold<F>(use_foldl: bool,\n /// process the collected results. i.e.\n ///\n /// ```ignore\n-/// f(cx, span, vec![self_1.method(__arg_1_1, __arg_2_1),\n-///                  self_2.method(__arg_1_2, __arg_2_2)])\n+/// f(cx, span, vec![self_1.method(arg_1_1, arg_2_1),\n+///                  self_2.method(arg_1_2, arg_2_2)])\n /// ```\n #[inline]\n pub fn cs_same_method<F>(f: F,"}]}