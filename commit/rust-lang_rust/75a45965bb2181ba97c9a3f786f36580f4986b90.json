{"sha": "75a45965bb2181ba97c9a3f786f36580f4986b90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1YTQ1OTY1YmIyMTgxYmE5N2M5YTNmNzg2ZjM2NTgwZjQ5ODZiOTA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-30T13:34:34Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-30T13:34:34Z"}, "message": "Add support for binop rem on floats", "tree": {"sha": "11a85c5eaed3b3b110f735244e96a28a33959348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11a85c5eaed3b3b110f735244e96a28a33959348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75a45965bb2181ba97c9a3f786f36580f4986b90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75a45965bb2181ba97c9a3f786f36580f4986b90", "html_url": "https://github.com/rust-lang/rust/commit/75a45965bb2181ba97c9a3f786f36580f4986b90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75a45965bb2181ba97c9a3f786f36580f4986b90/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b06ec8f1d78264a69ee89c90958c492fea509ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b06ec8f1d78264a69ee89c90958c492fea509ff", "html_url": "https://github.com/rust-lang/rust/commit/9b06ec8f1d78264a69ee89c90958c492fea509ff"}], "stats": {"total": 126, "additions": 83, "deletions": 43}, "files": [{"sha": "ead77acb376ea7f7974a6fc72a20396af43556be", "filename": "src/abi.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/75a45965bb2181ba97c9a3f786f36580f4986b90/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75a45965bb2181ba97c9a3f786f36580f4986b90/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=75a45965bb2181ba97c9a3f786f36580f4986b90", "patch": "@@ -104,6 +104,34 @@ impl<'a, 'tcx: 'a> FunctionCx<'a, 'tcx> {\n         module.declare_func_in_func(func_id, &mut self.bcx.func)\n     }\n \n+    pub fn lib_call(\n+        &mut self,\n+        name: &str,\n+        input_tys: Vec<types::Type>,\n+        output_ty: types::Type,\n+        args: &[Value],\n+    ) -> Value {\n+        let sig = Signature {\n+            params: input_tys.iter().cloned().map(AbiParam::new).collect(),\n+            returns: vec![AbiParam::new(output_ty)],\n+            call_conv: CallConv::SystemV,\n+            argument_bytes: None,\n+        };\n+        let func_id = self.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n+        let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n+        let call_inst = self.bcx.ins().call(func_ref, args);\n+        let results = self.bcx.inst_results(call_inst);\n+        assert_eq!(results.len(), 1);\n+        results[0]\n+    }\n+\n+    pub fn easy_call(&mut self, name: &str, args: &[CValue<'tcx>], return_ty: Ty<'tcx>) -> CValue<'tcx> {\n+        let (input_tys, args): (Vec<_>, Vec<_>) = args.into_iter().map(|arg| (self.cton_type(arg.layout().ty).unwrap(), arg.load_value(self))).unzip();\n+        let return_layout = self.layout_of(return_ty);\n+        let return_ty = self.cton_type(return_ty).unwrap();\n+        CValue::ByVal(self.lib_call(name, input_tys, return_ty, &args), return_layout)\n+    }\n+\n     fn self_sig(&self) -> FnSig<'tcx> {\n         ty_fn_sig(self.tcx, self.instance.ty(self.tcx))\n     }\n@@ -267,7 +295,6 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n                     assert_eq!(args.len(), 1);\n                     let discr = ::base::trans_get_discriminant(fx, args[0], ret.layout());\n                     ret.write_cvalue(fx, discr);\n-                    unimplemented!(\"discriminant\");\n                 }\n                 \"size_of\" => {\n                     assert_eq!(args.len(), 0);\n@@ -289,8 +316,6 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n                 }\n                 _ if intrinsic.starts_with(\"unchecked_\") => {\n                     assert_eq!(args.len(), 2);\n-                    let lhs = args[0].load_value(fx);\n-                    let rhs = args[1].load_value(fx);\n                     let bin_op = match intrinsic {\n                         \"unchecked_div\" => BinOp::Div,\n                         \"unchecked_rem\" => BinOp::Rem,\n@@ -300,10 +325,10 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n                     };\n                     let res = match ret.layout().ty.sty {\n                         TypeVariants::TyUint(_) => {\n-                            ::base::trans_int_binop(fx, bin_op, lhs, rhs, args[0].layout().ty, false, false)\n+                            ::base::trans_int_binop(fx, bin_op, args[0], args[1], ret.layout().ty, false, false)\n                         }\n                         TypeVariants::TyInt(_) => {\n-                            ::base::trans_int_binop(fx, bin_op, lhs, rhs, args[0].layout().ty, true, false)\n+                            ::base::trans_int_binop(fx, bin_op, args[0], args[1], ret.layout().ty, true, false)\n                         }\n                         _ => panic!(),\n                     };"}, {"sha": "104b948f148435aa6fb813f96bfbc4a3d2022f12", "filename": "src/base.rs", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/75a45965bb2181ba97c9a3f786f36580f4986b90/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75a45965bb2181ba97c9a3f786f36580f4986b90/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=75a45965bb2181ba97c9a3f786f36580f4986b90", "patch": "@@ -239,8 +239,8 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, cur_ebb: Ebb, stmt: &\n                 }\n                 Rvalue::BinaryOp(bin_op, lhs, rhs) => {\n                     let ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n-                    let lhs = trans_operand(fx, lhs).load_value(fx);\n-                    let rhs = trans_operand(fx, rhs).load_value(fx);\n+                    let lhs = trans_operand(fx, lhs);\n+                    let rhs = trans_operand(fx, rhs);\n \n                     let res = match ty.sty {\n                         TypeVariants::TyBool => {\n@@ -267,8 +267,8 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, cur_ebb: Ebb, stmt: &\n                 }\n                 Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n                     let ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n-                    let lhs = trans_operand(fx, lhs).load_value(fx);\n-                    let rhs = trans_operand(fx, rhs).load_value(fx);\n+                    let lhs = trans_operand(fx, lhs);\n+                    let rhs = trans_operand(fx, rhs);\n \n                     let res = match ty.sty {\n                         TypeVariants::TyUint(_) => {\n@@ -412,37 +412,47 @@ pub fn trans_get_discriminant<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, value\n }\n \n macro_rules! binop_match {\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, bug) => {\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, bug) => {\n         bug!(\"bin op {} on {} lhs: {:?} rhs: {:?}\", stringify!($var), $bug_fmt, $lhs, $rhs)\n     };\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, icmp($cc:ident)) => {{\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, icmp($cc:ident)) => {{\n+        assert_eq!($fx.tcx.types.bool, $ret_ty);\n+        let ret_layout = $fx.layout_of($ret_ty);\n         let b = $fx.bcx.ins().icmp(IntCC::$cc, $lhs, $rhs);\n-        $fx.bcx.ins().bint(types::I8, b)\n+        CValue::ByVal($fx.bcx.ins().bint(types::I8, b), ret_layout)\n     }};\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, fcmp($cc:ident)) => {{\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, fcmp($cc:ident)) => {{\n+        assert_eq!($fx.tcx.types.bool, $ret_ty);\n+        let ret_layout = $fx.layout_of($ret_ty);\n         let b = $fx.bcx.ins().fcmp(FloatCC::$cc, $lhs, $rhs);\n-        $fx.bcx.ins().bint(types::I8, b)\n+        CValue::ByVal($fx.bcx.ins().bint(types::I8, b), ret_layout)\n+    }};\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, custom(|| $body:expr)) => {{\n+        $body\n+    }};\n+    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, $name:ident) => {{\n+        let ret_layout = $fx.layout_of($ret_ty);\n+        CValue::ByVal($fx.bcx.ins().$name($lhs, $rhs), ret_layout)\n     }};\n-    (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, $name:ident) => {\n-        $fx.bcx.ins().$name($lhs, $rhs)\n-    };\n     (\n-        $fx:expr, $bin_op:expr, $signed:expr, $lhs:expr, $rhs:expr, $bug_fmt:expr;\n+        $fx:expr, $bin_op:expr, $signed:expr, $lhs:expr, $rhs:expr, $ret_ty:expr, $bug_fmt:expr;\n         $(\n-            $var:ident ($sign:pat) $name:tt $( ( $next:tt ) )? ;\n+            $var:ident ($sign:pat) $name:tt $( ( $($next:tt)* ) )? ;\n         )*\n-    ) => {\n+    ) => {{\n+        let lhs = $lhs.load_value($fx);\n+        let rhs = $rhs.load_value($fx);\n         match ($bin_op, $signed) {\n             $(\n-                (BinOp::$var, $sign) => binop_match!(@single $fx, $bug_fmt, $var, $lhs, $rhs, $name $( ( $next ) )?),\n+                (BinOp::$var, $sign) => binop_match!(@single $fx, $bug_fmt, $var, lhs, rhs, $ret_ty, $name $( ( $($next)* ) )?),\n             )*\n         }\n-    }\n+    }}\n }\n \n-fn trans_bool_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: Value, rhs: Value, ty: Ty<'tcx>) -> CValue<'tcx> {\n+fn trans_bool_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: CValue<'tcx>, rhs: CValue<'tcx>, ty: Ty<'tcx>) -> CValue<'tcx> {\n     let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, \"bool\";\n+        fx, bin_op, false, lhs, rhs, ty, \"bool\";\n         Add (_) bug;\n         Sub (_) bug;\n         Mul (_) bug;\n@@ -464,12 +474,12 @@ fn trans_bool_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp,\n         Offset (_) bug;\n     };\n \n-    CValue::ByVal(res, fx.layout_of(ty))\n+    res\n }\n \n-pub fn trans_int_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: Value, rhs: Value, ty: Ty<'tcx>, signed: bool, _checked: bool) -> CValue<'tcx> {\n+pub fn trans_int_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: CValue<'tcx>, rhs: CValue<'tcx>, ty: Ty<'tcx>, signed: bool, _checked: bool) -> CValue<'tcx> {\n     let res = binop_match! {\n-        fx, bin_op, signed, lhs, rhs, \"int/uint\";\n+        fx, bin_op, signed, lhs, rhs, ty, \"int/uint\";\n         Add (_) iadd;\n         Sub (_) isub;\n         Mul (_) imul;\n@@ -499,17 +509,25 @@ pub fn trans_int_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinO\n     };\n \n     // TODO: return correct value for checked binops\n-    CValue::ByVal(res, fx.layout_of(ty))\n+    res\n }\n \n-fn trans_float_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: Value, rhs: Value, ty: Ty<'tcx>) -> CValue<'tcx> {\n+fn trans_float_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: CValue<'tcx>, rhs: CValue<'tcx>, ty: Ty<'tcx>) -> CValue<'tcx> {\n     let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, \"float\";\n+        fx, bin_op, false, lhs, rhs, ty, \"float\";\n         Add (_) fadd;\n         Sub (_) fsub;\n         Mul (_) fmul;\n         Div (_) fdiv;\n-        Rem (_) bug;\n+        Rem (_) custom(|| {\n+            assert_eq!(lhs.layout().ty, ty);\n+            assert_eq!(rhs.layout().ty, ty);\n+            match ty.sty {\n+                TypeVariants::TyFloat(FloatTy::F32) => fx.easy_call(\"fmodf\", &[lhs, rhs], ty),\n+                TypeVariants::TyFloat(FloatTy::F64) => fx.easy_call(\"fmod\", &[lhs, rhs], ty),\n+                _ => bug!(),\n+            }\n+        });\n         BitXor (_) bxor;\n         BitAnd (_) band;\n         BitOr (_) bor;\n@@ -526,12 +544,12 @@ fn trans_float_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp,\n         Offset (_) bug;\n     };\n \n-    CValue::ByVal(res, fx.layout_of(ty))\n+    res\n }\n \n-fn trans_char_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: Value, rhs: Value, ty: Ty<'tcx>) -> CValue<'tcx> {\n+fn trans_char_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: CValue<'tcx>, rhs: CValue<'tcx>, ty: Ty<'tcx>) -> CValue<'tcx> {\n     let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, \"char\";\n+        fx, bin_op, false, lhs, rhs, ty, \"char\";\n         Add (_) bug;\n         Sub (_) bug;\n         Mul (_) bug;\n@@ -553,12 +571,12 @@ fn trans_char_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp,\n         Offset (_) bug;\n     };\n \n-    CValue::ByVal(res, fx.layout_of(ty))\n+    res\n }\n \n-fn trans_ptr_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: Value, rhs: Value, ty: Ty<'tcx>, _checked: bool) -> CValue<'tcx> {\n-    let res = binop_match! {\n-        fx, bin_op, false, lhs, rhs, \"ptr\";\n+fn trans_ptr_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: CValue<'tcx>, rhs: CValue<'tcx>, ty: Ty<'tcx>, _checked: bool) -> CValue<'tcx> {\n+    binop_match! {\n+        fx, bin_op, false, lhs, rhs, ty, \"ptr\";\n         Add (_) bug;\n         Sub (_) bug;\n         Mul (_) bug;\n@@ -578,10 +596,7 @@ fn trans_ptr_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, l\n         Gt (_) icmp(UnsignedGreaterThan);\n \n         Offset (_) iadd;\n-    };\n-\n-    // TODO: return correct value for checked binops\n-    CValue::ByVal(res, fx.layout_of(ty))\n+    }\n }\n \n pub fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>) -> CPlace<'tcx> {"}, {"sha": "ba84b2d64611af4101a638b5bc5ccb72bcbfe21f", "filename": "src/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75a45965bb2181ba97c9a3f786f36580f4986b90/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75a45965bb2181ba97c9a3f786f36580f4986b90/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=75a45965bb2181ba97c9a3f786f36580f4986b90", "patch": "@@ -1,6 +1,5 @@\n use std::fmt;\n \n-use syntax::ast::{IntTy, UintTy, FloatTy};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n use cranelift_module::{Module, FuncId, DataId};"}, {"sha": "c26b7cd19473fb1a317e53c3466cd16e209dfe8f", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75a45965bb2181ba97c9a3f786f36580f4986b90/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75a45965bb2181ba97c9a3f786f36580f4986b90/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=75a45965bb2181ba97c9a3f786f36580f4986b90", "patch": "@@ -54,6 +54,7 @@ mod prelude {\n     pub use std::collections::{HashMap, HashSet};\n \n     pub use syntax::codemap::DUMMY_SP;\n+    pub use syntax::ast::{IntTy, UintTy, FloatTy};\n     pub use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n     pub use rustc::mir;\n     pub use rustc::mir::*;"}]}