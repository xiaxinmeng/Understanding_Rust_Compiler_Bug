{"sha": "3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f", "node_id": "C_kwDOAAsO6NoAKDNiYWM1YzBmMzlkOWRiMzljYjgyZjRmYjc3ZWY5ZGVlZTdmZjllMGY", "commit": {"author": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-04-22T02:50:33Z"}, "committer": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-04-22T03:18:05Z"}, "message": "Use `run_build` helper consistently across most bootstrap tests\n\nThis is not super important to do, but the consistency is nice.\n\nI didn't change any tests that call `configure(\"dist\")` and then override the subcommand - doing\nthat at all is pretty sketchy, but I don't want to mess with it while already doing a refactor.", "tree": {"sha": "b737d5137ebbe042b777e5dc6e9ae0e4489031a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b737d5137ebbe042b777e5dc6e9ae0e4489031a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f", "html_url": "https://github.com/rust-lang/rust/commit/3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a4a66da3d5020311c78bdfbafad647fc99e436a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4a66da3d5020311c78bdfbafad647fc99e436a", "html_url": "https://github.com/rust-lang/rust/commit/7a4a66da3d5020311c78bdfbafad647fc99e436a"}], "stats": {"total": 165, "additions": 69, "deletions": 96}, "files": [{"sha": "3b6cd7564f08ae57e77365128feefc9908217ba3", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 69, "deletions": 96, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=3bac5c0f39d9db39cb82f4fb77ef9deee7ff9e0f", "patch": "@@ -38,16 +38,13 @@ fn run_build(paths: &[PathBuf], config: Config) -> Cache {\n fn test_exclude() {\n     let mut config = configure(\"test\", &[\"A\"], &[\"A\"]);\n     config.exclude = vec![TaskPath::parse(\"src/tools/tidy\")];\n-\n-    let build = Build::new(config);\n-    let builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+    let cache = run_build(&[], config);\n \n     // Ensure we have really excluded tidy\n-    assert!(!builder.cache.contains::<test::Tidy>());\n+    assert!(!cache.contains::<test::Tidy>());\n \n     // Ensure other tests are not affected.\n-    assert!(builder.cache.contains::<test::RustdocUi>());\n+    assert!(cache.contains::<test::RustdocUi>());\n }\n \n #[test]\n@@ -70,67 +67,61 @@ fn test_exclude_kind() {\n }\n \n mod defaults {\n-    use super::{configure, first};\n+    use super::{configure, first, run_build};\n     use crate::builder::*;\n     use crate::Config;\n     use pretty_assertions::assert_eq;\n \n     #[test]\n     fn build_default() {\n-        let build = Build::new(configure(\"build\", &[\"A\"], &[\"A\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+        let mut cache = run_build(&[], configure(\"build\", &[\"A\"], &[\"A\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n         assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n+            first(cache.all::<compile::Std>()),\n             &[\n                 compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n             ]\n         );\n-        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert!(!cache.all::<compile::Assemble>().is_empty());\n         // Make sure rustdoc is only built once.\n         assert_eq!(\n-            first(builder.cache.all::<tool::Rustdoc>()),\n+            first(cache.all::<tool::Rustdoc>()),\n             // Recall that rustdoc stages are off-by-one\n             // - this is the compiler it's _linked_ to, not built with.\n             &[tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } }],\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n+            first(cache.all::<compile::Rustc>()),\n             &[compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },]\n         );\n     }\n \n     #[test]\n     fn build_stage_0() {\n         let config = Config { stage: 0, ..configure(\"build\", &[\"A\"], &[\"A\"]) };\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+        let mut cache = run_build(&[], config);\n \n         let a = TargetSelection::from_user(\"A\");\n         assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n+            first(cache.all::<compile::Std>()),\n             &[compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },]\n         );\n-        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert!(!cache.all::<compile::Assemble>().is_empty());\n         assert_eq!(\n-            first(builder.cache.all::<tool::Rustdoc>()),\n+            first(cache.all::<tool::Rustdoc>()),\n             // This is the beta rustdoc.\n             // Add an assert here to make sure this is the only rustdoc built.\n             &[tool::Rustdoc { compiler: Compiler { host: a, stage: 0 } }],\n         );\n-        assert!(builder.cache.all::<compile::Rustc>().is_empty());\n+        assert!(cache.all::<compile::Rustc>().is_empty());\n     }\n \n     #[test]\n     fn build_cross_compile() {\n         let config = Config { stage: 1, ..configure(\"build\", &[\"A\", \"B\"], &[\"A\", \"B\"]) };\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+        let mut cache = run_build(&[], config);\n \n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n@@ -141,7 +132,7 @@ mod defaults {\n         // (since we're producing stage 1 libraries/binaries).  But currently\n         // rustbuild is just a bit buggy here; this should be fixed though.\n         assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n+            first(cache.all::<compile::Std>()),\n             &[\n                 compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n@@ -150,22 +141,22 @@ mod defaults {\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n+            first(cache.all::<compile::Assemble>()),\n             &[\n                 compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n                 compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n                 compile::Assemble { target_compiler: Compiler { host: b, stage: 1 } },\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<tool::Rustdoc>()),\n+            first(cache.all::<tool::Rustdoc>()),\n             &[\n                 tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } },\n                 tool::Rustdoc { compiler: Compiler { host: b, stage: 1 } },\n             ],\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n+            first(cache.all::<compile::Rustc>()),\n             &[\n                 compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: b },\n@@ -178,33 +169,28 @@ mod defaults {\n         let mut config = configure(\"doc\", &[\"A\"], &[\"A\"]);\n         config.compiler_docs = true;\n         config.cmd = Subcommand::Doc { paths: Vec::new(), open: false };\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n+        let mut cache = run_build(&[], config);\n         let a = TargetSelection::from_user(\"A\");\n \n         // error_index_generator uses stage 0 to share rustdoc artifacts with the\n         // rustdoc tool.\n+        assert_eq!(first(cache.all::<doc::ErrorIndex>()), &[doc::ErrorIndex { target: a },]);\n         assert_eq!(\n-            first(builder.cache.all::<doc::ErrorIndex>()),\n-            &[doc::ErrorIndex { target: a },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<tool::ErrorIndex>()),\n+            first(cache.all::<tool::ErrorIndex>()),\n             &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 0 } }]\n         );\n         // docs should be built with the beta compiler, not with the stage0 artifacts.\n         // recall that rustdoc is off-by-one: `stage` is the compiler rustdoc is _linked_ to,\n         // not the one it was built by.\n         assert_eq!(\n-            first(builder.cache.all::<tool::Rustdoc>()),\n+            first(cache.all::<tool::Rustdoc>()),\n             &[tool::Rustdoc { compiler: Compiler { host: a, stage: 0 } },]\n         );\n     }\n }\n \n mod dist {\n-    use super::{first, Config};\n+    use super::{first, run_build, Config};\n     use crate::builder::*;\n     use pretty_assertions::assert_eq;\n \n@@ -214,94 +200,88 @@ mod dist {\n \n     #[test]\n     fn dist_baseline() {\n-        let build = Build::new(configure(&[\"A\"], &[\"A\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], configure(&[\"A\"], &[\"A\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n+        assert_eq!(first(cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n+        assert_eq!(first(cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },]\n         );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n         // Make sure rustdoc is only built once.\n         assert_eq!(\n-            first(builder.cache.all::<tool::Rustdoc>()),\n+            first(cache.all::<tool::Rustdoc>()),\n             &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n         );\n     }\n \n     #[test]\n     fn dist_with_targets() {\n-        let build = Build::new(configure(&[\"A\"], &[\"A\", \"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], configure(&[\"A\"], &[\"A\", \"B\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n \n         assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n+            first(cache.all::<dist::Docs>()),\n             &[dist::Docs { host: a }, dist::Docs { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n+            first(cache.all::<dist::Mingw>()),\n             &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n                 dist::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n             ]\n         );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n     #[test]\n     fn dist_with_hosts() {\n-        let build = Build::new(configure(&[\"A\", \"B\"], &[\"A\", \"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], configure(&[\"A\", \"B\"], &[\"A\", \"B\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n \n         assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n+            first(cache.all::<dist::Docs>()),\n             &[dist::Docs { host: a }, dist::Docs { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n+            first(cache.all::<dist::Mingw>()),\n             &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[\n                 dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n                 dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n+            first(cache.all::<compile::Std>()),\n             &[\n                 compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n@@ -310,26 +290,25 @@ mod dist {\n                 compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n             ],\n         );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n     #[test]\n     fn dist_only_cross_host() {\n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n-        let mut build = Build::new(configure(&[\"A\", \"B\"], &[\"A\", \"B\"]));\n-        build.config.docs = false;\n-        build.config.extended = true;\n-        build.hosts = vec![b];\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut config = configure(&[\"A\", \"B\"], &[\"A\", \"B\"]);\n+        config.docs = false;\n+        config.extended = true;\n+        config.hosts = vec![b];\n+        let mut cache = run_build(&[], config);\n \n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[dist::Rustc { compiler: Compiler { host: b, stage: 2 } },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n+            first(cache.all::<compile::Rustc>()),\n             &[\n                 compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n@@ -339,92 +318,86 @@ mod dist {\n \n     #[test]\n     fn dist_with_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"A\", \"B\"], &[\"A\", \"B\", \"C\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], configure(&[\"A\", \"B\"], &[\"A\", \"B\", \"C\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n         let c = TargetSelection::from_user(\"C\");\n \n         assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n+            first(cache.all::<dist::Docs>()),\n             &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n+            first(cache.all::<dist::Mingw>()),\n             &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[\n                 dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n                 dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n                 dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n             ]\n         );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n     #[test]\n     fn dist_with_empty_host() {\n         let config = configure(&[], &[\"C\"]);\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], config);\n \n         let a = TargetSelection::from_user(\"A\");\n         let c = TargetSelection::from_user(\"C\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: c },]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: c },]);\n+        assert_eq!(first(cache.all::<dist::Docs>()), &[dist::Docs { host: c },]);\n+        assert_eq!(first(cache.all::<dist::Mingw>()), &[dist::Mingw { host: c },]);\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },]\n         );\n     }\n \n     #[test]\n     fn dist_with_same_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"A\", \"B\"], &[\"A\", \"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+        let mut cache = run_build(&[], configure(&[\"A\", \"B\"], &[\"A\", \"B\"]));\n \n         let a = TargetSelection::from_user(\"A\");\n         let b = TargetSelection::from_user(\"B\");\n \n         assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n+            first(cache.all::<dist::Docs>()),\n             &[dist::Docs { host: a }, dist::Docs { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n+            first(cache.all::<dist::Mingw>()),\n             &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n+            first(cache.all::<dist::Rustc>()),\n             &[\n                 dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n                 dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n+            first(cache.all::<dist::Std>()),\n             &[\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n                 dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n             ]\n         );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(cache.all::<dist::Src>()), &[dist::Src]);\n         assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n+            first(cache.all::<compile::Std>()),\n             &[\n                 compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n                 compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n@@ -434,7 +407,7 @@ mod dist {\n             ]\n         );\n         assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n+            first(cache.all::<compile::Assemble>()),\n             &[\n                 compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n                 compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },"}]}