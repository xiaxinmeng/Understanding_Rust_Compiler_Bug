{"sha": "572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MmYxYzA4YjZiYTQzYmRkNTdjNWNiOTlmNzlhMDhlY2Q4MjFjMWM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T17:49:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T17:49:26Z"}, "message": "Minor gramamr reorder", "tree": {"sha": "5c4677b6e1d3e73424046283c79ebb0d8b175691", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c4677b6e1d3e73424046283c79ebb0d8b175691"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c", "html_url": "https://github.com/rust-lang/rust/commit/572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cade89d730b025082ff2df70aace259951a9ccf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cade89d730b025082ff2df70aace259951a9ccf", "html_url": "https://github.com/rust-lang/rust/commit/5cade89d730b025082ff2df70aace259951a9ccf"}], "stats": {"total": 783, "additions": 391, "deletions": 392}, "files": [{"sha": "66821a31c2ac6a70d1eacfa180ffa5df4bfa59ff", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 328, "deletions": 331, "changes": 659, "blob_url": "https://github.com/rust-lang/rust/blob/572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c", "patch": "@@ -6,6 +6,20 @@ use crate::{\n     SyntaxNode, SyntaxToken, T,\n };\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Name {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl Name {\n+    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct NameRef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl NameRef {\n+    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -33,13 +47,6 @@ impl PathSegment {\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct NameRef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl NameRef {\n-    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct GenericArgList {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -116,13 +123,16 @@ impl TypeBoundList {\n     pub fn bounds(&self) -> AstChildren<TypeBound> { support::children(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct SourceFile {\n+pub struct MacroCall {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for SourceFile {}\n-impl ast::ModuleItemOwner for SourceFile {}\n-impl SourceFile {\n-    pub fn shebang_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![shebang]) }\n+impl ast::AttrsOwner for MacroCall {}\n+impl ast::NameOwner for MacroCall {}\n+impl MacroCall {\n+    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n+    pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Attr {\n@@ -139,6 +149,41 @@ impl Attr {\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TokenTree {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl TokenTree {\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MacroItems {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::ModuleItemOwner for MacroItems {}\n+impl MacroItems {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MacroStmts {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl MacroStmts {\n+    pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct SourceFile {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for SourceFile {}\n+impl ast::ModuleItemOwner for SourceFile {}\n+impl SourceFile {\n+    pub fn shebang_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![shebang]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Const {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -228,18 +273,6 @@ impl Impl {\n     pub fn assoc_item_list(&self) -> Option<AssocItemList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MacroCall {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for MacroCall {}\n-impl ast::NameOwner for MacroCall {}\n-impl MacroCall {\n-    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n-    pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Module {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -349,13 +382,6 @@ impl Visibility {\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Name {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl Name {\n-    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ItemList {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -589,18 +615,6 @@ pub struct Literal {\n impl ast::AttrsOwner for Literal {}\n impl Literal {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TokenTree {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl TokenTree {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExprStmt {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -1097,28 +1111,15 @@ impl TypeBound {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct OrPat {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl OrPat {\n-    pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ParenPat {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ParenPat {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RefPat {\n+pub struct BindPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl RefPat {\n-    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n+impl ast::AttrsOwner for BindPat {}\n+impl ast::NameOwner for BindPat {}\n+impl BindPat {\n+    pub fn ref_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ref]) }\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn at_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![@]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1130,69 +1131,61 @@ impl BoxPat {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct BindPat {\n+pub struct DotDotPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for BindPat {}\n-impl ast::NameOwner for BindPat {}\n-impl BindPat {\n-    pub fn ref_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ref]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n-    pub fn at_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![@]) }\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n+impl DotDotPat {\n+    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PlaceholderPat {\n+pub struct LiteralPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl PlaceholderPat {\n-    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n+impl LiteralPat {\n+    pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct DotDotPat {\n+pub struct MacroPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl DotDotPat {\n-    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n+impl MacroPat {\n+    pub fn macro_call(&self) -> Option<MacroCall> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PathPat {\n+pub struct OrPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl PathPat {\n-    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n+impl OrPat {\n+    pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct SlicePat {\n+pub struct ParenPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl SlicePat {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n-    pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n+impl ParenPat {\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n+    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RangePat {\n+pub struct PathPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl RangePat {\n-    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n-    pub fn dotdoteq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..=]) }\n+impl PathPat {\n+    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LiteralPat {\n+pub struct PlaceholderPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl LiteralPat {\n-    pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n+impl PlaceholderPat {\n+    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MacroPat {\n+pub struct RangePat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl MacroPat {\n-    pub fn macro_call(&self) -> Option<MacroCall> { support::child(&self.syntax) }\n-}\n+impl RangePat {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1204,60 +1197,64 @@ impl RecordPat {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RecordFieldPatList {\n+pub struct RefPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl RecordFieldPatList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n-    pub fn record_field_pats(&self) -> AstChildren<RecordFieldPat> {\n-        support::children(&self.syntax)\n-    }\n-    pub fn bind_pats(&self) -> AstChildren<BindPat> { support::children(&self.syntax) }\n-    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n+impl RefPat {\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RecordFieldPat {\n+pub struct SlicePat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for RecordFieldPat {}\n-impl RecordFieldPat {\n-    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n+impl SlicePat {\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+    pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TupleStructPat {\n+pub struct TuplePat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl TupleStructPat {\n-    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n+impl TuplePat {\n     pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TuplePat {\n+pub struct TupleStructPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl TuplePat {\n+impl TupleStructPat {\n+    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n     pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n     pub fn args(&self) -> AstChildren<Pat> { support::children(&self.syntax) }\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MacroItems {\n+pub struct RecordFieldPatList {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::ModuleItemOwner for MacroItems {}\n-impl MacroItems {}\n+impl RecordFieldPatList {\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n+    pub fn record_field_pats(&self) -> AstChildren<RecordFieldPat> {\n+        support::children(&self.syntax)\n+    }\n+    pub fn bind_pats(&self) -> AstChildren<BindPat> { support::children(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n+}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MacroStmts {\n+pub struct RecordFieldPat {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl MacroStmts {\n-    pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for RecordFieldPat {}\n+impl RecordFieldPat {\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n+    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericArg {\n@@ -1334,22 +1331,28 @@ pub enum Item {\n }\n impl ast::AttrsOwner for Item {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum Stmt {\n+    ExprStmt(ExprStmt),\n+    Item(Item),\n+    LetStmt(LetStmt),\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Pat {\n-    OrPat(OrPat),\n-    ParenPat(ParenPat),\n-    RefPat(RefPat),\n-    BoxPat(BoxPat),\n     BindPat(BindPat),\n-    PlaceholderPat(PlaceholderPat),\n+    BoxPat(BoxPat),\n     DotDotPat(DotDotPat),\n+    LiteralPat(LiteralPat),\n+    MacroPat(MacroPat),\n+    OrPat(OrPat),\n+    ParenPat(ParenPat),\n     PathPat(PathPat),\n+    PlaceholderPat(PlaceholderPat),\n+    RangePat(RangePat),\n     RecordPat(RecordPat),\n-    TupleStructPat(TupleStructPat),\n-    TuplePat(TuplePat),\n+    RefPat(RefPat),\n     SlicePat(SlicePat),\n-    RangePat(RangePat),\n-    LiteralPat(LiteralPat),\n-    MacroPat(MacroPat),\n+    TuplePat(TuplePat),\n+    TupleStructPat(TupleStructPat),\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum FieldList {\n@@ -1390,14 +1393,19 @@ pub enum GenericParam {\n     TypeParam(TypeParam),\n }\n impl ast::AttrsOwner for GenericParam {}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum Stmt {\n-    ExprStmt(ExprStmt),\n-    Item(Item),\n-    LetStmt(LetStmt),\n+impl AstNode for Name {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Path {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }\n+impl AstNode for NameRef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME_REF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1407,8 +1415,8 @@ impl AstNode for Path {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PathSegment {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_SEGMENT }\n+impl AstNode for Path {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1418,8 +1426,8 @@ impl AstNode for PathSegment {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for NameRef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME_REF }\n+impl AstNode for PathSegment {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_SEGMENT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1528,8 +1536,8 @@ impl AstNode for TypeBoundList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for SourceFile {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }\n+impl AstNode for MacroCall {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_CALL }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1550,6 +1558,50 @@ impl AstNode for Attr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl AstNode for TokenTree {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TOKEN_TREE }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for MacroItems {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_ITEMS }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for MacroStmts {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_STMTS }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for SourceFile {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n impl AstNode for Const {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == CONST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -1616,17 +1668,6 @@ impl AstNode for Impl {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MacroCall {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_CALL }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for Module {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -1715,17 +1756,6 @@ impl AstNode for Visibility {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Name {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for ItemList {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == ITEM_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -1979,17 +2009,6 @@ impl AstNode for Literal {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TokenTree {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TOKEN_TREE }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for ExprStmt {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == EXPR_STMT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2529,30 +2548,8 @@ impl AstNode for TupleType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeBound {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-impl AstNode for OrPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == OR_PAT }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-impl AstNode for ParenPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_PAT }\n+impl AstNode for TypeBound {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2562,8 +2559,8 @@ impl AstNode for ParenPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RefPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_PAT }\n+impl AstNode for BindPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BIND_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2584,8 +2581,8 @@ impl AstNode for BoxPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for BindPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BIND_PAT }\n+impl AstNode for DotDotPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOT_DOT_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2595,8 +2592,8 @@ impl AstNode for BindPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PlaceholderPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PLACEHOLDER_PAT }\n+impl AstNode for LiteralPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2606,8 +2603,8 @@ impl AstNode for PlaceholderPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for DotDotPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == DOT_DOT_PAT }\n+impl AstNode for MacroPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2617,8 +2614,8 @@ impl AstNode for DotDotPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PathPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_PAT }\n+impl AstNode for OrPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == OR_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2628,8 +2625,8 @@ impl AstNode for PathPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for SlicePat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SLICE_PAT }\n+impl AstNode for ParenPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2639,8 +2636,8 @@ impl AstNode for SlicePat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RangePat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RANGE_PAT }\n+impl AstNode for PathPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2650,8 +2647,8 @@ impl AstNode for RangePat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for LiteralPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL_PAT }\n+impl AstNode for PlaceholderPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PLACEHOLDER_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2661,8 +2658,8 @@ impl AstNode for LiteralPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MacroPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_PAT }\n+impl AstNode for RangePat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RANGE_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2683,8 +2680,8 @@ impl AstNode for RecordPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RecordFieldPatList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_FIELD_PAT_LIST }\n+impl AstNode for RefPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2694,8 +2691,8 @@ impl AstNode for RecordFieldPatList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RecordFieldPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_FIELD_PAT }\n+impl AstNode for SlicePat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SLICE_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2705,8 +2702,8 @@ impl AstNode for RecordFieldPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TupleStructPat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_STRUCT_PAT }\n+impl AstNode for TuplePat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2716,8 +2713,8 @@ impl AstNode for TupleStructPat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TuplePat {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_PAT }\n+impl AstNode for TupleStructPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_STRUCT_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2727,8 +2724,8 @@ impl AstNode for TuplePat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MacroItems {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_ITEMS }\n+impl AstNode for RecordFieldPatList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_FIELD_PAT_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2738,8 +2735,8 @@ impl AstNode for MacroItems {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MacroStmts {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_STMTS }\n+impl AstNode for RecordFieldPat {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_FIELD_PAT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -3133,98 +3130,107 @@ impl AstNode for Item {\n         }\n     }\n }\n-impl From<OrPat> for Pat {\n-    fn from(node: OrPat) -> Pat { Pat::OrPat(node) }\n-}\n-impl From<ParenPat> for Pat {\n-    fn from(node: ParenPat) -> Pat { Pat::ParenPat(node) }\n+impl From<ExprStmt> for Stmt {\n+    fn from(node: ExprStmt) -> Stmt { Stmt::ExprStmt(node) }\n }\n-impl From<RefPat> for Pat {\n-    fn from(node: RefPat) -> Pat { Pat::RefPat(node) }\n+impl From<Item> for Stmt {\n+    fn from(node: Item) -> Stmt { Stmt::Item(node) }\n }\n-impl From<BoxPat> for Pat {\n-    fn from(node: BoxPat) -> Pat { Pat::BoxPat(node) }\n+impl From<LetStmt> for Stmt {\n+    fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }\n }\n impl From<BindPat> for Pat {\n     fn from(node: BindPat) -> Pat { Pat::BindPat(node) }\n }\n-impl From<PlaceholderPat> for Pat {\n-    fn from(node: PlaceholderPat) -> Pat { Pat::PlaceholderPat(node) }\n+impl From<BoxPat> for Pat {\n+    fn from(node: BoxPat) -> Pat { Pat::BoxPat(node) }\n }\n impl From<DotDotPat> for Pat {\n     fn from(node: DotDotPat) -> Pat { Pat::DotDotPat(node) }\n }\n+impl From<LiteralPat> for Pat {\n+    fn from(node: LiteralPat) -> Pat { Pat::LiteralPat(node) }\n+}\n+impl From<MacroPat> for Pat {\n+    fn from(node: MacroPat) -> Pat { Pat::MacroPat(node) }\n+}\n+impl From<OrPat> for Pat {\n+    fn from(node: OrPat) -> Pat { Pat::OrPat(node) }\n+}\n+impl From<ParenPat> for Pat {\n+    fn from(node: ParenPat) -> Pat { Pat::ParenPat(node) }\n+}\n impl From<PathPat> for Pat {\n     fn from(node: PathPat) -> Pat { Pat::PathPat(node) }\n }\n+impl From<PlaceholderPat> for Pat {\n+    fn from(node: PlaceholderPat) -> Pat { Pat::PlaceholderPat(node) }\n+}\n+impl From<RangePat> for Pat {\n+    fn from(node: RangePat) -> Pat { Pat::RangePat(node) }\n+}\n impl From<RecordPat> for Pat {\n     fn from(node: RecordPat) -> Pat { Pat::RecordPat(node) }\n }\n-impl From<TupleStructPat> for Pat {\n-    fn from(node: TupleStructPat) -> Pat { Pat::TupleStructPat(node) }\n-}\n-impl From<TuplePat> for Pat {\n-    fn from(node: TuplePat) -> Pat { Pat::TuplePat(node) }\n+impl From<RefPat> for Pat {\n+    fn from(node: RefPat) -> Pat { Pat::RefPat(node) }\n }\n impl From<SlicePat> for Pat {\n     fn from(node: SlicePat) -> Pat { Pat::SlicePat(node) }\n }\n-impl From<RangePat> for Pat {\n-    fn from(node: RangePat) -> Pat { Pat::RangePat(node) }\n-}\n-impl From<LiteralPat> for Pat {\n-    fn from(node: LiteralPat) -> Pat { Pat::LiteralPat(node) }\n+impl From<TuplePat> for Pat {\n+    fn from(node: TuplePat) -> Pat { Pat::TuplePat(node) }\n }\n-impl From<MacroPat> for Pat {\n-    fn from(node: MacroPat) -> Pat { Pat::MacroPat(node) }\n+impl From<TupleStructPat> for Pat {\n+    fn from(node: TupleStructPat) -> Pat { Pat::TupleStructPat(node) }\n }\n impl AstNode for Pat {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            OR_PAT | PAREN_PAT | REF_PAT | BOX_PAT | BIND_PAT | PLACEHOLDER_PAT | DOT_DOT_PAT\n-            | PATH_PAT | RECORD_PAT | TUPLE_STRUCT_PAT | TUPLE_PAT | SLICE_PAT | RANGE_PAT\n-            | LITERAL_PAT | MACRO_PAT => true,\n+            BIND_PAT | BOX_PAT | DOT_DOT_PAT | LITERAL_PAT | MACRO_PAT | OR_PAT | PAREN_PAT\n+            | PATH_PAT | PLACEHOLDER_PAT | RANGE_PAT | RECORD_PAT | REF_PAT | SLICE_PAT\n+            | TUPLE_PAT | TUPLE_STRUCT_PAT => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            OR_PAT => Pat::OrPat(OrPat { syntax }),\n-            PAREN_PAT => Pat::ParenPat(ParenPat { syntax }),\n-            REF_PAT => Pat::RefPat(RefPat { syntax }),\n-            BOX_PAT => Pat::BoxPat(BoxPat { syntax }),\n             BIND_PAT => Pat::BindPat(BindPat { syntax }),\n-            PLACEHOLDER_PAT => Pat::PlaceholderPat(PlaceholderPat { syntax }),\n+            BOX_PAT => Pat::BoxPat(BoxPat { syntax }),\n             DOT_DOT_PAT => Pat::DotDotPat(DotDotPat { syntax }),\n+            LITERAL_PAT => Pat::LiteralPat(LiteralPat { syntax }),\n+            MACRO_PAT => Pat::MacroPat(MacroPat { syntax }),\n+            OR_PAT => Pat::OrPat(OrPat { syntax }),\n+            PAREN_PAT => Pat::ParenPat(ParenPat { syntax }),\n             PATH_PAT => Pat::PathPat(PathPat { syntax }),\n+            PLACEHOLDER_PAT => Pat::PlaceholderPat(PlaceholderPat { syntax }),\n+            RANGE_PAT => Pat::RangePat(RangePat { syntax }),\n             RECORD_PAT => Pat::RecordPat(RecordPat { syntax }),\n-            TUPLE_STRUCT_PAT => Pat::TupleStructPat(TupleStructPat { syntax }),\n-            TUPLE_PAT => Pat::TuplePat(TuplePat { syntax }),\n+            REF_PAT => Pat::RefPat(RefPat { syntax }),\n             SLICE_PAT => Pat::SlicePat(SlicePat { syntax }),\n-            RANGE_PAT => Pat::RangePat(RangePat { syntax }),\n-            LITERAL_PAT => Pat::LiteralPat(LiteralPat { syntax }),\n-            MACRO_PAT => Pat::MacroPat(MacroPat { syntax }),\n+            TUPLE_PAT => Pat::TuplePat(TuplePat { syntax }),\n+            TUPLE_STRUCT_PAT => Pat::TupleStructPat(TupleStructPat { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            Pat::OrPat(it) => &it.syntax,\n-            Pat::ParenPat(it) => &it.syntax,\n-            Pat::RefPat(it) => &it.syntax,\n-            Pat::BoxPat(it) => &it.syntax,\n             Pat::BindPat(it) => &it.syntax,\n-            Pat::PlaceholderPat(it) => &it.syntax,\n+            Pat::BoxPat(it) => &it.syntax,\n             Pat::DotDotPat(it) => &it.syntax,\n+            Pat::LiteralPat(it) => &it.syntax,\n+            Pat::MacroPat(it) => &it.syntax,\n+            Pat::OrPat(it) => &it.syntax,\n+            Pat::ParenPat(it) => &it.syntax,\n             Pat::PathPat(it) => &it.syntax,\n+            Pat::PlaceholderPat(it) => &it.syntax,\n+            Pat::RangePat(it) => &it.syntax,\n             Pat::RecordPat(it) => &it.syntax,\n-            Pat::TupleStructPat(it) => &it.syntax,\n-            Pat::TuplePat(it) => &it.syntax,\n+            Pat::RefPat(it) => &it.syntax,\n             Pat::SlicePat(it) => &it.syntax,\n-            Pat::RangePat(it) => &it.syntax,\n-            Pat::LiteralPat(it) => &it.syntax,\n-            Pat::MacroPat(it) => &it.syntax,\n+            Pat::TuplePat(it) => &it.syntax,\n+            Pat::TupleStructPat(it) => &it.syntax,\n         }\n     }\n }\n@@ -3393,15 +3399,6 @@ impl AstNode for GenericParam {\n         }\n     }\n }\n-impl From<ExprStmt> for Stmt {\n-    fn from(node: ExprStmt) -> Stmt { Stmt::ExprStmt(node) }\n-}\n-impl From<Item> for Stmt {\n-    fn from(node: Item) -> Stmt { Stmt::Item(node) }\n-}\n-impl From<LetStmt> for Stmt {\n-    fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }\n-}\n impl std::fmt::Display for GenericArg {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3422,6 +3419,11 @@ impl std::fmt::Display for Item {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n+impl std::fmt::Display for Stmt {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for Pat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3452,22 +3454,22 @@ impl std::fmt::Display for GenericParam {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Stmt {\n+impl std::fmt::Display for Name {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Path {\n+impl std::fmt::Display for NameRef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PathSegment {\n+impl std::fmt::Display for Path {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for NameRef {\n+impl std::fmt::Display for PathSegment {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3517,7 +3519,7 @@ impl std::fmt::Display for TypeBoundList {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for SourceFile {\n+impl std::fmt::Display for MacroCall {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3527,6 +3529,26 @@ impl std::fmt::Display for Attr {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n+impl std::fmt::Display for TokenTree {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for MacroItems {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for MacroStmts {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for SourceFile {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for Const {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3557,11 +3579,6 @@ impl std::fmt::Display for Impl {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MacroCall {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for Module {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3602,11 +3619,6 @@ impl std::fmt::Display for Visibility {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Name {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for ItemList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3722,11 +3734,6 @@ impl std::fmt::Display for Literal {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TokenTree {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for ExprStmt {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3977,37 +3984,37 @@ impl std::fmt::Display for TypeBound {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for OrPat {\n+impl std::fmt::Display for BindPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ParenPat {\n+impl std::fmt::Display for BoxPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RefPat {\n+impl std::fmt::Display for DotDotPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for BoxPat {\n+impl std::fmt::Display for LiteralPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for BindPat {\n+impl std::fmt::Display for MacroPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PlaceholderPat {\n+impl std::fmt::Display for OrPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for DotDotPat {\n+impl std::fmt::Display for ParenPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -4017,7 +4024,7 @@ impl std::fmt::Display for PathPat {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for SlicePat {\n+impl std::fmt::Display for PlaceholderPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -4027,47 +4034,37 @@ impl std::fmt::Display for RangePat {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for LiteralPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl std::fmt::Display for MacroPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for RecordPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RecordFieldPatList {\n+impl std::fmt::Display for RefPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RecordFieldPat {\n+impl std::fmt::Display for SlicePat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TupleStructPat {\n+impl std::fmt::Display for TuplePat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TuplePat {\n+impl std::fmt::Display for TupleStructPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MacroItems {\n+impl std::fmt::Display for RecordFieldPatList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MacroStmts {\n+impl std::fmt::Display for RecordFieldPat {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }"}, {"sha": "27bf563b656e325ee805477828d56491c2727afd", "filename": "xtask/src/codegen/rust.ungram", "status": "modified", "additions": 63, "deletions": 61, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Frust.ungram?ref=572f1c08b6ba43bdd57c5cb99f79a08ecd821c1c", "patch": "@@ -1,3 +1,9 @@\n+Name =\n+  'ident'\n+\n+NameRef =\n+  'ident' | 'int_number'\n+\n Path =\n   (qualifier:Path '::')? segment:PathSegment\n \n@@ -29,6 +35,21 @@ LifetimeArg =\n ConstArg =\n   Expr\n \n+MacroCall =\n+  Attr* Path '!' Name? TokenTree ';'?\n+\n+TokenTree =\n+  '(' ')'\n+| '{' '}'\n+| '[' ']'\n+\n+MacroItems =\n+  Item*\n+\n+MacroStmts =\n+  statements:Stmt*\n+  Expr?\n+\n SourceFile =\n   'shebang'?\n   Attr*\n@@ -475,41 +496,37 @@ TypeBound =\n   'lifetime'\n | '?'? Type\n \n-OrPat =\n-  Pat*\n-\n-ParenPat =\n-  '(' Pat ')'\n-\n-RefPat =\n-  '&' 'mut'? Pat\n-\n-BoxPat =\n-  'box' Path\n-\n-BindPat =\n-  Attr* 'ref'? 'mut'? Name ('@' Pat)?\n-\n-PlaceholderPat =\n-  '_'\n+Pat =\n+  BindPat\n+| BoxPat\n+| DotDotPat\n+| LiteralPat\n+| MacroPat\n+| OrPat\n+| ParenPat\n+| PathPat\n+| PlaceholderPat\n+| RangePat\n+| RecordPat\n+| RefPat\n+| SlicePat\n+| TuplePat\n+| TupleStructPat\n \n-DotDotPat =\n-  '..'\n+LiteralPat =\n+  Literal\n \n PathPat =\n   Path\n \n-SlicePat =\n-  '[' args:Pat* ']'\n+PlaceholderPat =\n+  '_'\n \n RangePat =\n-  '..' | '..='\n-\n-LiteralPat =\n-  Literal\n+  start:Pat op:('..' | '..=') end:Pat\n \n-MacroPat =\n-  MacroCall\n+RefPat =\n+  '&' 'mut'? Pat\n \n RecordPat =\n   Path RecordFieldPatList\n@@ -522,46 +539,31 @@ RecordFieldPatList =\n   '}'\n \n RecordFieldPat =\n-  Attr* NameRef ':' Pat\n+  Attr* (NameRef ':')? Pat\n \n-TupleStructPat =\n-   Path '(' args:Pat* ')'\n+OrPat =\n+  Pat*\n \n-TuplePat =\n-   '(' args:Pat* ')'\n+ParenPat =\n+  '(' Pat ')'\n \n-Name =\n-  'ident'\n+BoxPat =\n+  'box' Path\n \n-NameRef =\n-  'ident' | 'int_number'\n+BindPat =\n+  Attr* 'ref'? 'mut'? Name ('@' Pat)?\n \n-MacroCall =\n-  Attr* Path '!' Name? TokenTree ';'?\n+DotDotPat =\n+  '..'\n \n-TokenTree =\n-  '(' ')' | '{' '}' | '[' ']'\n+SlicePat =\n+  '[' args:Pat* ']'\n \n-MacroItems =\n-  Item*\n+MacroPat =\n+  MacroCall\n \n-MacroStmts =\n-  statements:Stmt*\n-  Expr?\n+TupleStructPat =\n+   Path '(' args:Pat* ')'\n \n-Pat =\n-  OrPat\n-| ParenPat\n-| RefPat\n-| BoxPat\n-| BindPat\n-| PlaceholderPat\n-| DotDotPat\n-| PathPat\n-| RecordPat\n-| TupleStructPat\n-| TuplePat\n-| SlicePat\n-| RangePat\n-| LiteralPat\n-| MacroPat\n+TuplePat =\n+   '(' args:Pat* ')'"}]}