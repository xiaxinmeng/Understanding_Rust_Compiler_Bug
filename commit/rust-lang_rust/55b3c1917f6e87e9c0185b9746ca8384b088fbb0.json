{"sha": "55b3c1917f6e87e9c0185b9746ca8384b088fbb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1YjNjMTkxN2Y2ZTg3ZTljMDE4NWI5NzQ2Y2E4Mzg0YjA4OGZiYjA=", "commit": {"author": {"name": "Micah Chalmer", "email": "micah@micahchalmer.net", "date": "2014-02-23T03:24:55Z"}, "committer": {"name": "Micah Chalmer", "email": "micah@micahchalmer.net", "date": "2014-02-23T04:06:46Z"}, "message": "Emacs: indent relative to enclosing block\n\nThis changes the indent to calculate positions relative to the enclosing\nblock (or braced/parenthesized expression), rather than by an absolute\nnesting level within the whole file.  This allows things like this to\nwork:\n\n    let x =\n        match expr {\n            Pattern => ...\n        }\n\nWith the old method, only one level of nesting would be added within the\nmatch braces, so \"Pattern\" would have ended up aligned with the match.\n\nThe other change is that multiple parens/braces on the same line only\nincrease the indent once.  This is a very common case for passing\nclosures/procs.  The absolute nesting method would do this:\n\n    spawn(proc() {\n            // Indented out two indent levels...\n    })\n\nwhereas the code in this commit does this:\n\n    spawn(proc() {\n        // Indented out only one level...\n    })", "tree": {"sha": "75e3c9b4661dd251e8360cb91f9e22ebc63b48bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75e3c9b4661dd251e8360cb91f9e22ebc63b48bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55b3c1917f6e87e9c0185b9746ca8384b088fbb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55b3c1917f6e87e9c0185b9746ca8384b088fbb0", "html_url": "https://github.com/rust-lang/rust/commit/55b3c1917f6e87e9c0185b9746ca8384b088fbb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55b3c1917f6e87e9c0185b9746ca8384b088fbb0/comments", "author": {"login": "MicahChalmer", "id": 698400, "node_id": "MDQ6VXNlcjY5ODQwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/698400?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MicahChalmer", "html_url": "https://github.com/MicahChalmer", "followers_url": "https://api.github.com/users/MicahChalmer/followers", "following_url": "https://api.github.com/users/MicahChalmer/following{/other_user}", "gists_url": "https://api.github.com/users/MicahChalmer/gists{/gist_id}", "starred_url": "https://api.github.com/users/MicahChalmer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MicahChalmer/subscriptions", "organizations_url": "https://api.github.com/users/MicahChalmer/orgs", "repos_url": "https://api.github.com/users/MicahChalmer/repos", "events_url": "https://api.github.com/users/MicahChalmer/events{/privacy}", "received_events_url": "https://api.github.com/users/MicahChalmer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "MicahChalmer", "id": 698400, "node_id": "MDQ6VXNlcjY5ODQwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/698400?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MicahChalmer", "html_url": "https://github.com/MicahChalmer", "followers_url": "https://api.github.com/users/MicahChalmer/followers", "following_url": "https://api.github.com/users/MicahChalmer/following{/other_user}", "gists_url": "https://api.github.com/users/MicahChalmer/gists{/gist_id}", "starred_url": "https://api.github.com/users/MicahChalmer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MicahChalmer/subscriptions", "organizations_url": "https://api.github.com/users/MicahChalmer/orgs", "repos_url": "https://api.github.com/users/MicahChalmer/repos", "events_url": "https://api.github.com/users/MicahChalmer/events{/privacy}", "received_events_url": "https://api.github.com/users/MicahChalmer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45008f9b3e455d8d9619238e6a0c1981ffaf2860", "url": "https://api.github.com/repos/rust-lang/rust/commits/45008f9b3e455d8d9619238e6a0c1981ffaf2860", "html_url": "https://github.com/rust-lang/rust/commit/45008f9b3e455d8d9619238e6a0c1981ffaf2860"}], "stats": {"total": 164, "additions": 127, "deletions": 37}, "files": [{"sha": "bdd7d63a8be5001fb76d132cf8a51e132c3abb13", "filename": "src/etc/emacs/rust-mode-tests.el", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/55b3c1917f6e87e9c0185b9746ca8384b088fbb0/src%2Fetc%2Femacs%2Frust-mode-tests.el", "raw_url": "https://github.com/rust-lang/rust/raw/55b3c1917f6e87e9c0185b9746ca8384b088fbb0/src%2Fetc%2Femacs%2Frust-mode-tests.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode-tests.el?ref=55b3c1917f6e87e9c0185b9746ca8384b088fbb0", "patch": "@@ -452,6 +452,70 @@ fn foo() {\n \"\n    ))\n \n+(ert-deftest indent-indented-match ()\n+  (test-indent\n+   \"\n+fn foo() {\n+    let x = \n+        match blah {\n+            Pattern |\n+            Pattern2 => {\n+                hello()\n+            },\n+            _ => whatever\n+        };\n+    y();\n+}\n+\"\n+   ))\n+\n+(ert-deftest indent-curly-braces-within-parens ()\n+  (test-indent\n+   \"\n+fn foo() {\n+    let x = \n+        foo(bar(|x| {\n+            only_one_indent_here();\n+        }));\n+    y();\n+}\n+\"\n+   ))\n+\n+(ert-deftest indent-weirdly-indented-block ()\n+  (rust-test-manip-code\n+   \"\n+fn foo() {\n+ {\n+this_block_is_over_to_the_left_for_some_reason();\n+ }\n+\n+}\n+\"\n+   16\n+   #'indent-for-tab-command\n+   \"\n+fn foo() {\n+ {\n+     this_block_is_over_to_the_left_for_some_reason();\n+ }\n+\n+}\n+\"\n+   ))\n+\n+(ert-deftest indent-multi-line-attrib ()\n+  (test-indent\n+   \"\n+#[attrib(\n+    this,\n+    that,\n+    theotherthing)]\n+mod function_with_multiline_attribute() {}\n+\"\n+   ))\n+\n+\n ;; Make sure that in effort to cover match patterns we don't mistreat || or expressions\n (ert-deftest indent-nonmatch-or-expression ()\n   (test-indent"}, {"sha": "b304df8f14c1661e7755e28c95bb65953df69291", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 63, "deletions": 37, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/55b3c1917f6e87e9c0185b9746ca8384b088fbb0/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/55b3c1917f6e87e9c0185b9746ca8384b088fbb0/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=55b3c1917f6e87e9c0185b9746ca8384b088fbb0", "patch": "@@ -59,61 +59,87 @@\n \t(backward-word 1))\n       (current-column))))\n \n+(defun rust-rewind-to-beginning-of-current-level-expr ()\n+  (let ((current-level (rust-paren-level)))\n+    (back-to-indentation)\n+    (while (> (rust-paren-level) current-level)\n+      (backward-up-list)\n+      (back-to-indentation))))\n+\n (defun rust-mode-indent-line ()\n   (interactive)\n   (let ((indent\n          (save-excursion\n            (back-to-indentation)\n-           (let ((level (rust-paren-level)))\n+           ;; Point is now at beginning of current line\n+           (let* ((level (rust-paren-level))\n+                  (baseline\n+                   ;; Our \"baseline\" is one level out from the indentation of the expression\n+                   ;; containing the innermost enclosing opening bracket.  That\n+                   ;; way if we are within a block that has a different\n+                   ;; indentation than this mode would give it, we still indent\n+                   ;; the inside of it correctly relative to the outside.\n+                   (if (= 0 level)\n+                       0\n+                     (save-excursion\n+                       (backward-up-list)\n+                       (rust-rewind-to-beginning-of-current-level-expr)\n+                       (+ (current-column) rust-indent-offset)))))\n              (cond\n               ;; A function return type is indented to the corresponding function arguments\n               ((looking-at \"->\")\n                (save-excursion\n                  (backward-list)\n                  (or (rust-align-to-expr-after-brace)\n-                     (* rust-indent-offset (+ 1 level)))))\n+                     (+ baseline rust-indent-offset))))\n \n               ;; A closing brace is 1 level unindended\n-              ((looking-at \"}\") (* rust-indent-offset (- level 1)))\n+              ((looking-at \"}\") (- baseline rust-indent-offset))\n \n               ;; Doc comments in /** style with leading * indent to line up the *s\n               ((and (nth 4 (syntax-ppss)) (looking-at \"*\"))\n-               (+ 1 (* rust-indent-offset level)))\n+               (+ 1 baseline))\n \n               ;; If we're in any other token-tree / sexp, then:\n-              ;;  - [ or ( means line up with the opening token\n-              ;;  - { means indent to either nesting-level * rust-indent-offset,\n-              ;;    or one further indent from that if either current line\n-              ;;    begins with 'else', or previous line didn't end in\n-              ;;    semi, comma, brace or single pipe (other than whitespace and line\n-              ;;    comments) , and wasn't an attribute.  But if we have\n-              ;;    something after the open brace and ending with a comma,\n-              ;;    treat it as fields and align them.  PHEW.\n-              ((> level 0)\n-               (let ((pt (point)))\n-                 (rust-rewind-irrelevant)\n-                 (backward-up-list)\n-                 (or (and (looking-at \"[[({]\")\n-                          (rust-align-to-expr-after-brace))\n-                     (progn\n-                       (goto-char pt)\n-                       (back-to-indentation)\n-                       (if (looking-at \"\\\\<else\\\\>\")\n-                           (* rust-indent-offset (+ 1 level))\n-                         (progn\n-                           (goto-char pt)\n-                           (beginning-of-line)\n-                           (rust-rewind-irrelevant)\n-                           (end-of-line)\n-                           (if (looking-back \"\\\\(?:[(,:;?[{}]\\\\|[^|]|\\\\)[[:space:]]*\\\\(?://.*\\\\)?\")\n-                               (* rust-indent-offset level)\n-                             (back-to-indentation)\n-                             (if (looking-at \"#\")\n-                                 (* rust-indent-offset level)\n-                               (* rust-indent-offset (+ 1 level))))))))))\n-\n-              ;; Otherwise we're in a column-zero definition\n-              (t 0))))))\n+              (t\n+               (or\n+                ;; If we are inside a pair of braces, with something after the\n+                ;; open brace on the same line and ending with a comma, treat\n+                ;; it as fields and align them.\n+                (when (> level 0)\n+                  (save-excursion\n+                    (rust-rewind-irrelevant)\n+                    (backward-up-list)\n+                    ;; Point is now at the beginning of the containing set of braces\n+                    (rust-align-to-expr-after-brace)))\n+\n+                (progn\n+                  (back-to-indentation)\n+                  ;; Point is now at the beginning of the current line\n+                  (if (or\n+                       ;; If this line begins with \"else\" or \"{\", stay on the\n+                       ;; baseline as well (we are continuing an expression,\n+                       ;; but the \"else\" or \"{\" should align with the beginning\n+                       ;; of the expression it's in.)\n+                       (looking-at \"\\\\<else\\\\>\\\\|{\")\n+                       \n+                       (save-excursion\n+                         (rust-rewind-irrelevant)\n+                         ;; Point is now at the end of the previous ine\n+                         (or\n+                          ;; If we are at the first line, no indentation is needed, so stay at baseline...\n+                          (= 1 (line-number-at-pos (point)))\n+                          ;; ..or if the previous line ends with any of these:\n+                          ;;     { ? : ( , ; [ }\n+                          ;; then we are at the beginning of an expression, so stay on the baseline...\n+                          (looking-back \"[(,:;?[{}]\\\\|[^|]|\")\n+                          ;; or if the previous line is the end of an attribute, stay at the baseline...\n+                          (progn (rust-rewind-to-beginning-of-current-level-expr) (looking-at \"#\")))))\n+                      baseline\n+\n+                    ;; Otherwise, we are continuing the same expression from the previous line,\n+                    ;; so add one additional indent level\n+                    (+ baseline rust-indent-offset))))))))))\n     (when (not (eq (current-indentation) indent))\n       ;; If we're at the beginning of the line (before or at the current\n       ;; indentation), jump with the indentation change.  Otherwise, save the"}]}