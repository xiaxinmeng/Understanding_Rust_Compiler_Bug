{"sha": "4a52c5625c08f4c9df8f7367d999b6828c20a83a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNTJjNTYyNWMwOGY0YzlkZjhmNzM2N2Q5OTliNjgyOGMyMGE4M2E=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-11-18T22:24:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-18T22:24:34Z"}, "message": "Rollup merge of #55834 - ogoffart:union-abi, r=eddyb\n\nForward the ABI of the non-zero sized fields of an union if they have the same ABI\n\nThis is supposed to fix the performence regression of using MaybeUninit in\nhttps://github.com/rust-lang/rust/pull/54668", "tree": {"sha": "3c828e80b1af345d0e04df47b45267dd5e874480", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c828e80b1af345d0e04df47b45267dd5e874480"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a52c5625c08f4c9df8f7367d999b6828c20a83a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb8eajCRBK7hj4Ov3rIwAAdHIIAKYR4E154vjxnSne0BtApoBy\nNnZO3s82KUnWRE7M8uXsuQpKZzDnAGfGQmOe1ea7u4Nu2OUqUiYttJkv+V3ZhqGd\n2JgmSJNyPiOCe0WTu2lvDhKTL1EEdoi5h0uBqN1X9MmUjye3G/nXaCe2U93G3tXM\naykltGiYQ2V7TR3psje85twRc9Ra6PKYU8QNDYBhrdZYOX0cB7y9CeSyHast44BG\n7ATwUZanamVYv8Ij9i5GYXdysU+/NiCqxx5uYz7g2NgLLO2pi5QxpC9hJTjy5/0s\njr+KI+QmuhiK45JxNhvx4BVJ7arg4sTWkY8JYvU1UB+XidB+OloGwm5Lw9I/F+Q=\n=5Tzi\n-----END PGP SIGNATURE-----\n", "payload": "tree 3c828e80b1af345d0e04df47b45267dd5e874480\nparent 9c3e8d340f7a35fae673c7f55ec9ab6866b5dd15\nparent c040a483bcb522b60865130ea5e94e2ef2915f94\nauthor Pietro Albini <pietro@pietroalbini.org> 1542579874 +0100\ncommitter GitHub <noreply@github.com> 1542579874 +0100\n\nRollup merge of #55834 - ogoffart:union-abi, r=eddyb\n\nForward the ABI of the non-zero sized fields of an union if they have the same ABI\n\nThis is supposed to fix the performence regression of using MaybeUninit in\nhttps://github.com/rust-lang/rust/pull/54668\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a52c5625c08f4c9df8f7367d999b6828c20a83a", "html_url": "https://github.com/rust-lang/rust/commit/4a52c5625c08f4c9df8f7367d999b6828c20a83a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a52c5625c08f4c9df8f7367d999b6828c20a83a/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c3e8d340f7a35fae673c7f55ec9ab6866b5dd15", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c3e8d340f7a35fae673c7f55ec9ab6866b5dd15", "html_url": "https://github.com/rust-lang/rust/commit/9c3e8d340f7a35fae673c7f55ec9ab6866b5dd15"}, {"sha": "c040a483bcb522b60865130ea5e94e2ef2915f94", "url": "https://api.github.com/repos/rust-lang/rust/commits/c040a483bcb522b60865130ea5e94e2ef2915f94", "html_url": "https://github.com/rust-lang/rust/commit/c040a483bcb522b60865130ea5e94e2ef2915f94"}], "stats": {"total": 121, "additions": 120, "deletions": 1}, "files": [{"sha": "d7fb8da7acd05fca7bffaaff732f7066b5a65b0f", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4a52c5625c08f4c9df8f7367d999b6828c20a83a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a52c5625c08f4c9df8f7367d999b6828c20a83a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=4a52c5625c08f4c9df8f7367d999b6828c20a83a", "patch": "@@ -697,7 +697,9 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             Align::from_bytes(repr_align, repr_align).unwrap());\n                     }\n \n+                    let optimize = !def.repr.inhibit_union_abi_opt();\n                     let mut size = Size::ZERO;\n+                    let mut abi = Abi::Aggregate { sized: true };\n                     let index = VariantIdx::new(0);\n                     for field in &variants[index] {\n                         assert!(!field.is_unsized());\n@@ -708,13 +710,44 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         } else {\n                             align = align.max(field.align);\n                         }\n+\n+                        // If all non-ZST fields have the same ABI, forward this ABI\n+                        if optimize && !field.is_zst() {\n+                            // Normalize scalar_unit to the maximal valid range\n+                            let field_abi = match &field.abi {\n+                                Abi::Scalar(x) => Abi::Scalar(scalar_unit(x.value)),\n+                                Abi::ScalarPair(x, y) => {\n+                                    Abi::ScalarPair(\n+                                        scalar_unit(x.value),\n+                                        scalar_unit(y.value),\n+                                    )\n+                                }\n+                                Abi::Vector { element: x, count } => {\n+                                    Abi::Vector {\n+                                        element: scalar_unit(x.value),\n+                                        count: *count,\n+                                    }\n+                                }\n+                                Abi::Uninhabited |\n+                                Abi::Aggregate { .. }  => Abi::Aggregate { sized: true },\n+                            };\n+\n+                            if size == Size::ZERO {\n+                                // first non ZST: initialize 'abi'\n+                                abi = field_abi;\n+                            } else if abi != field_abi  {\n+                                // different fields have different ABI: reset to Aggregate\n+                                abi = Abi::Aggregate { sized: true };\n+                            }\n+                        }\n+\n                         size = cmp::max(size, field.size);\n                     }\n \n                     return Ok(tcx.intern_layout(LayoutDetails {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n-                        abi: Abi::Aggregate { sized: true },\n+                        abi,\n                         align,\n                         size: size.abi_align(align)\n                     }));"}, {"sha": "a474065b5cd55fe1911c8a1de888eb53ddf52ac3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a52c5625c08f4c9df8f7367d999b6828c20a83a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a52c5625c08f4c9df8f7367d999b6828c20a83a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4a52c5625c08f4c9df8f7367d999b6828c20a83a", "patch": "@@ -1998,6 +1998,12 @@ impl ReprOptions {\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n         !(self.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty() || (self.pack == 1)\n     }\n+\n+    /// Returns true if this `#[repr()]` should inhibit union abi optimisations\n+    pub fn inhibit_union_abi_opt(&self) -> bool {\n+        self.c()\n+    }\n+\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {"}, {"sha": "786968128ec1bbc06c32fc211f9ee018d6dbf1ed", "filename": "src/test/codegen/union-abi.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4a52c5625c08f4c9df8f7367d999b6828c20a83a/src%2Ftest%2Fcodegen%2Funion-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a52c5625c08f4c9df8f7367d999b6828c20a83a/src%2Ftest%2Fcodegen%2Funion-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funion-abi.rs?ref=4a52c5625c08f4c9df8f7367d999b6828c20a83a", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+// This test that using union forward the abi of the inner type, as\n+// discussed in #54668\n+\n+#![crate_type=\"lib\"]\n+#![feature(repr_simd)]\n+\n+#[derive(Copy, Clone)]\n+pub enum Unhab {}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct i64x4(i64, i64, i64, i64);\n+\n+#[derive(Copy, Clone)]\n+pub union UnionI64x4{ a:(), b: i64x4 }\n+\n+// CHECK: define void @test_UnionI64x4(<4 x i64>* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_UnionI64x4(_: UnionI64x4) { loop {} }\n+\n+pub union UnionI64x4_{ a: i64x4, b: (), c:i64x4, d: Unhab, e: ((),()), f: UnionI64x4 }\n+\n+// CHECK: define void @test_UnionI64x4_(<4 x i64>* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_UnionI64x4_(_: UnionI64x4_) { loop {} }\n+\n+pub union UnionI64x4I64{ a: i64x4, b: i64 }\n+\n+// CHECK: define void @test_UnionI64x4I64(%UnionI64x4I64* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_UnionI64x4I64(_: UnionI64x4I64) { loop {} }\n+\n+pub union UnionI64x4Tuple{ a: i64x4, b: (i64, i64, i64, i64) }\n+\n+// CHECK: define void @test_UnionI64x4Tuple(%UnionI64x4Tuple* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_UnionI64x4Tuple(_: UnionI64x4Tuple) { loop {} }\n+\n+\n+pub union UnionF32{a:f32}\n+\n+// CHECK: define float @test_UnionF32(float %arg0)\n+#[no_mangle]\n+pub fn test_UnionF32(_: UnionF32) -> UnionF32 { loop {} }\n+\n+pub union UnionF32F32{a:f32, b:f32}\n+\n+// CHECK: define float @test_UnionF32F32(float %arg0)\n+#[no_mangle]\n+pub fn test_UnionF32F32(_: UnionF32F32) -> UnionF32F32 { loop {} }\n+\n+pub union UnionF32U32{a:f32, b:u32}\n+\n+// CHECK: define i32 @test_UnionF32U32(i32)\n+#[no_mangle]\n+pub fn test_UnionF32U32(_: UnionF32U32) -> UnionF32U32 { loop {} }\n+\n+pub union UnionU128{a:u128}\n+// CHECK: define i128 @test_UnionU128(i128 %arg0)\n+#[no_mangle]\n+pub fn test_UnionU128(_: UnionU128) -> UnionU128 { loop {} }\n+\n+#[repr(C)]\n+pub union CUnionU128{a:u128}\n+// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_CUnionU128(_: CUnionU128) { loop {} }\n+"}]}