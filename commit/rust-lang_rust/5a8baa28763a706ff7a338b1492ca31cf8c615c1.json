{"sha": "5a8baa28763a706ff7a338b1492ca31cf8c615c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhOGJhYTI4NzYzYTcwNmZmN2EzMzhiMTQ5MmNhMzFjZjhjNjE1YzE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-14T22:18:39Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-23T13:47:19Z"}, "message": "refactor with extract_binding_mode", "tree": {"sha": "e297fc6eae7fbab3757310716d9458d469152488", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e297fc6eae7fbab3757310716d9458d469152488"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a8baa28763a706ff7a338b1492ca31cf8c615c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8baa28763a706ff7a338b1492ca31cf8c615c1", "html_url": "https://github.com/rust-lang/rust/commit/5a8baa28763a706ff7a338b1492ca31cf8c615c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a8baa28763a706ff7a338b1492ca31cf8c615c1/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eed311f719ac4cda2f1df2fae5f4ce9404cae135", "url": "https://api.github.com/repos/rust-lang/rust/commits/eed311f719ac4cda2f1df2fae5f4ce9404cae135", "html_url": "https://github.com/rust-lang/rust/commit/eed311f719ac4cda2f1df2fae5f4ce9404cae135"}], "stats": {"total": 107, "additions": 45, "deletions": 62}, "files": [{"sha": "e36b11ae0050c0074d007c835b352726182aa542", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5a8baa28763a706ff7a338b1492ca31cf8c615c1", "patch": "@@ -648,6 +648,13 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n+    pub fn extract_binding_mode(&self, s: &Session, id: HirId, sp: Span) -> Option<BindingMode> {\n+        self.pat_binding_modes().get(id).copied().or_else(|| {\n+            s.delay_span_bug(sp, \"missing binding mode\");\n+            None\n+        })\n+    }\n+\n     pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,"}, {"sha": "3a2a2dc412e72c7a39a936309ae3b29da4581387", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=5a8baa28763a706ff7a338b1492ca31cf8c615c1", "patch": "@@ -816,15 +816,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n                     if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                         name = ident.name;\n-\n-                        if let Some(&bm) = hir_tables.pat_binding_modes().get(pat.hir_id) {\n-                            if bm == ty::BindByValue(hir::Mutability::Mut) {\n+                        match hir_tables.extract_binding_mode(tcx.sess, pat.hir_id, pat.span) {\n+                            Some(ty::BindByValue(hir::Mutability::Mut)) => {\n                                 mutability = Mutability::Mut;\n-                            } else {\n-                                mutability = Mutability::Not;\n                             }\n-                        } else {\n-                            tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+                            Some(_) => mutability = Mutability::Not,\n+                            _ => {}\n                         }\n                     }\n                 }"}, {"sha": "3cfafaf180634e9cf7b128d0b46c99d32564ca78", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=5a8baa28763a706ff7a338b1492ca31cf8c615c1", "patch": "@@ -271,11 +271,9 @@ fn const_not_var(err: &mut DiagnosticBuilder<'_>, tcx: TyCtxt<'_>, pat: &Pat, pa\n fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n     pat.walk(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n-            if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                if bm != ty::BindByValue(hir::Mutability::Not) {\n-                    // Nothing to check.\n-                    return true;\n-                }\n+            if let Some(ty::BindByValue(hir::Mutability::Not)) =\n+                cx.tables.extract_binding_mode(cx.tcx.sess, p.hir_id, p.span)\n+            {\n                 let pat_ty = cx.tables.pat_ty(p);\n                 if let ty::Adt(edef, _) = pat_ty.kind {\n                     if edef.is_enum()\n@@ -303,8 +301,6 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                         err.emit();\n                     }\n                 }\n-            } else {\n-                cx.tcx.sess.delay_span_bug(p.span, \"missing binding mode\");\n             }\n         }\n         true\n@@ -581,15 +577,14 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n \n // Check the legality of legality of by-move bindings.\n fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat) {\n+    let sess = cx.tcx.sess;\n+    let tables = cx.tables;\n+\n     // Find all by-ref spans.\n     let mut by_ref_spans = Vec::new();\n     pat.each_binding(|_, hir_id, span, _| {\n-        if let Some(&bm) = cx.tables.pat_binding_modes().get(hir_id) {\n-            if let ty::BindByReference(..) = bm {\n-                by_ref_spans.push(span);\n-            }\n-        } else {\n-            cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+        if let Some(ty::BindByReference(_)) = tables.extract_binding_mode(sess, hir_id, span) {\n+            by_ref_spans.push(span);\n         }\n     });\n \n@@ -600,7 +595,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n         //\n         // `x @ Foo(..)` is legal, but `x @ Foo(y)` isn't.\n         if sub.map_or(false, |p| p.contains_bindings()) {\n-            struct_span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\")\n+            struct_span_err!(sess, p.span, E0007, \"cannot bind by-move with sub-bindings\")\n                 .span_label(p.span, \"binds an already bound by-move value by moving it\")\n                 .emit();\n         } else if !has_guard && !by_ref_spans.is_empty() {\n@@ -609,15 +604,11 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     };\n     pat.walk(|p| {\n         if let hir::PatKind::Binding(.., sub) = &p.kind {\n-            if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                if let ty::BindByValue(..) = bm {\n-                    let pat_ty = cx.tables.node_type(p.hir_id);\n-                    if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n-                        check_move(p, sub.as_deref());\n-                    }\n+            if let Some(ty::BindByValue(_)) = tables.extract_binding_mode(sess, p.hir_id, p.span) {\n+                let pat_ty = tables.node_type(p.hir_id);\n+                if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n+                    check_move(p, sub.as_deref());\n                 }\n-            } else {\n-                cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n             }\n         }\n         true\n@@ -626,7 +617,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     // Found some bad by-move spans, error!\n     if !by_move_spans.is_empty() {\n         let mut err = struct_span_err!(\n-            cx.tcx.sess,\n+            sess,\n             MultiSpan::from_spans(by_move_spans.clone()),\n             E0009,\n             \"cannot bind by-move and by-ref in the same pattern\",\n@@ -642,14 +633,12 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n }\n \n fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+    let tab = cx.tables;\n+    let sess = cx.tcx.sess;\n     // Get the mutability of `p` if it's by-ref.\n-    let extract_binding_mut = |hir_id, span| match cx.tables.pat_binding_modes().get(hir_id) {\n-        None => {\n-            cx.tcx.sess.delay_span_bug(span, \"missing binding mode\");\n-            None\n-        }\n-        Some(ty::BindByValue(..)) => None,\n-        Some(ty::BindByReference(m)) => Some(*m),\n+    let extract_binding_mut = |hir_id, span| match tab.extract_binding_mode(sess, hir_id, span)? {\n+        ty::BindByValue(_) => None,\n+        ty::BindByReference(m) => Some(m),\n     };\n     pat.walk(|pat| {\n         // Extract `sub` in `binding @ sub`.\n@@ -671,8 +660,8 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n         sub.each_binding(|_, hir_id, span, _| {\n             if let Some(mut_inner) = extract_binding_mut(hir_id, span) {\n                 match (mut_outer, mut_inner) {\n-                    (Mutability::Immutable, Mutability::Immutable) => {}\n-                    (Mutability::Mutable, Mutability::Mutable) => conflicts_mut_mut.push(span),\n+                    (Mutability::Not, Mutability::Not) => {}\n+                    (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push(span),\n                     _ => conflicts_mut_ref.push(span),\n                 }\n             }\n@@ -683,7 +672,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n         if !conflicts_mut_mut.is_empty() {\n             // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n             let msg = &format!(\"cannot borrow `{}` as mutable more than once at a time\", name);\n-            let mut err = cx.tcx.sess.struct_span_err(pat.span, msg);\n+            let mut err = sess.struct_span_err(pat.span, msg);\n             err.span_label(binding_span, \"first mutable borrow occurs here\");\n             for sp in conflicts_mut_mut {\n                 err.span_label(sp, \"another mutable borrow occurs here\");\n@@ -695,14 +684,14 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n         } else if !conflicts_mut_ref.is_empty() {\n             // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n             let (primary, also) = match mut_outer {\n-                Mutability::Mutable => (\"mutable\", \"immutable\"),\n-                Mutability::Immutable => (\"immutable\", \"mutable\"),\n+                Mutability::Mut => (\"mutable\", \"immutable\"),\n+                Mutability::Not => (\"immutable\", \"mutable\"),\n             };\n             let msg = &format!(\n                 \"cannot borrow `{}` as {} because it is also borrowed as {}\",\n                 name, primary, also,\n             );\n-            let mut err = cx.tcx.sess.struct_span_err(pat.span, msg);\n+            let mut err = sess.struct_span_err(pat.span, msg);\n             err.span_label(binding_span, &format!(\"{} borrow occurs here\", primary));\n             for sp in conflicts_mut_ref {\n                 err.span_label(sp, &format!(\"{} borrow occurs here\", also));"}, {"sha": "149f27ed305fb825d43f0e7a72001141bd9d3779", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5a8baa28763a706ff7a338b1492ca31cf8c615c1", "patch": "@@ -1007,20 +1007,13 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn link_pattern(&self, discr_cmt: mc::Place<'tcx>, root_pat: &hir::Pat) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n         ignore_err!(self.with_mc(|mc| {\n-            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n+            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id }| {\n                 // `ref x` pattern\n-                if let PatKind::Binding(..) = sub_pat.kind {\n-                    if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n-                        if let ty::BindByReference(mutbl) = bm {\n-                            self.link_region_from_node_type(\n-                                sub_pat.span,\n-                                sub_pat.hir_id,\n-                                mutbl,\n-                                &sub_cmt,\n-                            );\n-                        }\n-                    } else {\n-                        self.tcx.sess.delay_span_bug(sub_pat.span, \"missing binding mode\");\n+                if let PatKind::Binding(..) = kind {\n+                    if let Some(ty::BindByReference(mutbl)) =\n+                        mc.tables.extract_binding_mode(self.tcx.sess, *hir_id, *span)\n+                    {\n+                        self.link_region_from_node_type(*span, *hir_id, mutbl, &sub_cmt);\n                     }\n                 }\n             })"}, {"sha": "5ef5f4c648e8ce73ef7263944198d1065cc4e4fc", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=5a8baa28763a706ff7a338b1492ca31cf8c615c1", "patch": "@@ -284,10 +284,9 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n         match p.kind {\n             hir::PatKind::Binding(..) => {\n-                if let Some(&bm) = self.fcx.tables.borrow().pat_binding_modes().get(p.hir_id) {\n+                let tables = self.fcx.tables.borrow();\n+                if let Some(bm) = tables.extract_binding_mode(self.tcx().sess, p.hir_id, p.span) {\n                     self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n-                } else {\n-                    self.tcx().sess.delay_span_bug(p.span, \"missing binding mode\");\n                 }\n             }\n             hir::PatKind::Struct(_, ref fields, _) => {"}, {"sha": "788dda1cd5a0e26165972eb604d4ab3ef5ab9b87", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a8baa28763a706ff7a338b1492ca31cf8c615c1/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=5a8baa28763a706ff7a338b1492ca31cf8c615c1", "patch": "@@ -534,7 +534,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\"walk_pat: binding place={:?} pat={:?}\", place, pat,);\n-                if let Some(&bm) = mc.tables.pat_binding_modes().get(pat.hir_id) {\n+                if let Some(bm) = mc.tables.extract_binding_mode(tcx.sess, pat.hir_id, pat.span) {\n                     debug!(\"walk_pat: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n \n                     // pat_ty: the type of the binding being produced.\n@@ -560,8 +560,6 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             delegate.consume(place, mode);\n                         }\n                     }\n-                } else {\n-                    tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n             }\n         }));"}]}