{"sha": "9e3889e2ea6b69f84b6034e506e6967ffef408cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMzg4OWUyZWE2YjY5Zjg0YjYwMzRlNTA2ZTY5NjdmZmVmNDA4Y2Y=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-11T11:27:39Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-23T11:50:11Z"}, "message": "Refactor region naming for control of diagnostics.\n\nPreviously, region naming would always highlight the source of the\nregion name it found. Now, region naming returns the name as part\nof a larger structure that encodes the source of the region naming\nsuch that a region name can be optionally added to the diagnostic.", "tree": {"sha": "424707445117e44058ce3923d7a40210b78d0be9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/424707445117e44058ce3923d7a40210b78d0be9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e3889e2ea6b69f84b6034e506e6967ffef408cf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlunffMACgkQAXYLT59T\n8VS0sxAAmN/P7lCe81uVrjd62kXqA1/OmvTYumzLoiMrr2zBAaVckHMc1spFe68r\nwTQU9rEosfW6thoYOCq1opZ0b+4db6DS+benfWSZ2sCbwQlXMGERO6hjj6Qf2+vt\ngBwqZu79xxGWAfKuI/zAXNno1ww3/ZOyWK0oI67eHIX7OI58WxcmZHbuYKUMie+J\n2OxNkUn3WwBKAZ1SeszdmLtmvYH9nyQGg+NqICadQ2MlIZNPDWfrv7n+pNC1lsYU\nSramy7lbXF/XXUEvxleuRFUTx7TVbs3mBnGHYrPrNZseJ+ILOz/MVptct626ZByC\nwNQ2wRl2+rOZyArk5hbVPuTs7UZP34aWNzNOgZcM3BYOYtjak0r3NVxpke8OexKz\ncnMNZfjYIzz69Ovwq25cKnSEGCAooNzUbH5bD8GM19dARS4wIzhwPMKIBHIKlVPs\nqcZbKockh2M60/xnqG3bNLLwzSvijpJ56jj5eLDYFUrZvD+88X9PdX9qAKueE4ST\nVz2X69WdfsNhWbHo2XvUqdzaXaCJGuCDYaU1Yx4HQmxy0fKalrXM08xHIW8Hqzui\nQu29eVHZW4nBdylqAcQl++mrgBcSu/zptvNJZdkZ/CTwyfYDYLWXkQZsV/nzzp41\nX0+5i4e5UEsTTGeQrzwRoHTzfYrMh+CysdJSfhCmaB38yPj60VQ=\n=AAFU\n-----END PGP SIGNATURE-----", "payload": "tree 424707445117e44058ce3923d7a40210b78d0be9\nparent 10af6a2b37bf52e023b892dc2622c19e32f6ebf5\nauthor David Wood <david@davidtw.co> 1536665259 +0200\ncommitter David Wood <david@davidtw.co> 1537703411 +0200\n\nRefactor region naming for control of diagnostics.\n\nPreviously, region naming would always highlight the source of the\nregion name it found. Now, region naming returns the name as part\nof a larger structure that encodes the source of the region naming\nsuch that a region name can be optionally added to the diagnostic.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e3889e2ea6b69f84b6034e506e6967ffef408cf", "html_url": "https://github.com/rust-lang/rust/commit/9e3889e2ea6b69f84b6034e506e6967ffef408cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e3889e2ea6b69f84b6034e506e6967ffef408cf/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10af6a2b37bf52e023b892dc2622c19e32f6ebf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/10af6a2b37bf52e023b892dc2622c19e32f6ebf5", "html_url": "https://github.com/rust-lang/rust/commit/10af6a2b37bf52e023b892dc2622c19e32f6ebf5"}], "stats": {"total": 293, "additions": 168, "deletions": 125}, "files": [{"sha": "31d7c7c631e1791f177d6996164b415ca7dc553b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e3889e2ea6b69f84b6034e506e6967ffef408cf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3889e2ea6b69f84b6034e506e6967ffef408cf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=9e3889e2ea6b69f84b6034e506e6967ffef408cf", "patch": "@@ -339,10 +339,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(\n-            infcx, mir, mir_def_id, fr, counter, &mut diag);\n+        let fr_name = self.give_region_a_name(infcx, mir, mir_def_id, fr, counter);\n+        fr_name.highlight_region_name(&mut diag);\n         let outlived_fr_name = self.give_region_a_name(\n-            infcx, mir, mir_def_id, outlived_fr, counter, &mut diag);\n+            infcx, mir, mir_def_id, outlived_fr, counter);\n+        outlived_fr_name.highlight_region_name(&mut diag);\n \n         let mir_def_name = if infcx.tcx.is_closure(mir_def_id) { \"closure\" } else { \"function\" };\n \n@@ -430,10 +431,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n                     let span = infcx.tcx.def_span(*did);\n                     if let Ok(snippet) = infcx.tcx.sess.source_map().span_to_snippet(span) {\n-                        let suggestable_fr_name = match fr_name {\n-                            RegionName::Named(name) => format!(\"{}\", name),\n-                            RegionName::Synthesized(_) => \"'_\".to_string(),\n+                        let suggestable_fr_name = if fr_name.was_named() {\n+                            format!(\"{}\", fr_name)\n+                        } else {\n+                            \"'_\".to_string()\n                         };\n+\n                         diag.span_suggestion_with_applicability(\n                             span,\n                             &format!("}, {"sha": "875348ac819d8011db0f62b1d1eff73c0d87937d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 159, "deletions": 119, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/9e3889e2ea6b69f84b6034e506e6967ffef408cf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3889e2ea6b69f84b6034e506e6967ffef408cf/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=9e3889e2ea6b69f84b6034e506e6967ffef408cf", "patch": "@@ -25,29 +25,102 @@ use syntax::symbol::keywords;\n use syntax_pos::Span;\n use syntax_pos::symbol::InternedString;\n \n-/// Name of a region used in error reporting. Variants denote the source of the region name -\n-/// whether it was synthesized for the error message and therefore should not be used in\n-/// suggestions; or whether it was found from the region.\n #[derive(Debug)]\n-pub(crate) enum RegionName {\n-    Named(InternedString),\n-    Synthesized(InternedString),\n+crate struct RegionName {\n+    name: InternedString,\n+    source: RegionNameSource,\n+}\n+\n+#[derive(Debug)]\n+crate enum RegionNameSource {\n+    NamedEarlyBoundRegion(Span),\n+    NamedFreeRegion(Span),\n+    Static,\n+    SynthesizedFreeEnvRegion(Span, String),\n+    CannotMatchHirTy(Span, String),\n+    MatchedHirTy(Span),\n+    MatchedAdtAndSegment(Span),\n+    AnonRegionFromUpvar(Span, String),\n+    AnonRegionFromOutput(Span, String, String),\n }\n \n impl RegionName {\n-    fn as_interned_string(&self) -> &InternedString {\n-        match self {\n-            RegionName::Named(name) | RegionName::Synthesized(name) => name,\n+    #[allow(dead_code)]\n+    crate fn was_named(&self) -> bool {\n+        match self.source {\n+            RegionNameSource::NamedEarlyBoundRegion(..) |\n+            RegionNameSource::NamedFreeRegion(..) |\n+            RegionNameSource::Static => true,\n+            RegionNameSource::SynthesizedFreeEnvRegion(..) |\n+            RegionNameSource::CannotMatchHirTy(..) |\n+            RegionNameSource::MatchedHirTy(..) |\n+            RegionNameSource::MatchedAdtAndSegment(..) |\n+            RegionNameSource::AnonRegionFromUpvar(..) |\n+            RegionNameSource::AnonRegionFromOutput(..) => false,\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    crate fn was_synthesized(&self) -> bool {\n+        !self.was_named()\n+    }\n+\n+    #[allow(dead_code)]\n+    crate fn name(&self) -> &InternedString {\n+        &self.name\n+    }\n+\n+    crate fn highlight_region_name(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'_>\n+    ) {\n+        match &self.source {\n+            RegionNameSource::NamedFreeRegion(span) |\n+            RegionNameSource::NamedEarlyBoundRegion(span) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"lifetime `{}` defined here\", self),\n+                );\n+            },\n+            RegionNameSource::SynthesizedFreeEnvRegion(span, note) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"lifetime `{}` represents this closure's body\", self),\n+                );\n+                diag.note(&note);\n+            },\n+            RegionNameSource::CannotMatchHirTy(span, type_name) => {\n+                diag.span_label(*span, format!(\"has type `{}`\", type_name));\n+            },\n+            RegionNameSource::MatchedHirTy(span) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"let's call the lifetime of this reference `{}`\", self),\n+                );\n+            },\n+            RegionNameSource::MatchedAdtAndSegment(span) => {\n+                diag.span_label(*span, format!(\"let's call this `{}`\", self));\n+            },\n+            RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"lifetime `{}` appears in the type of `{}`\", self, upvar_name),\n+                );\n+            },\n+            RegionNameSource::AnonRegionFromOutput(span, mir_description, type_name) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\"return type{} is {}\", mir_description, type_name),\n+                );\n+            },\n+            RegionNameSource::Static => {},\n         }\n     }\n }\n \n impl Display for RegionName {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self {\n-            RegionName::Named(name) | RegionName::Synthesized(name) =>\n-                write!(f, \"{}\", name),\n-        }\n+        write!(f, \"{}\", self.name)\n     }\n }\n \n@@ -84,26 +157,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder,\n     ) -> RegionName {\n         debug!(\"give_region_a_name(fr={:?}, counter={})\", fr, counter);\n \n         assert!(self.universal_regions.is_universal_region(fr));\n \n-        let value = self.give_name_from_error_region(infcx.tcx, mir_def_id, fr, counter, diag)\n+        let value = self.give_name_from_error_region(infcx.tcx, mir_def_id, fr, counter)\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_arguments(\n-                    infcx, mir, mir_def_id, fr, counter, diag,\n+                    infcx, mir, mir_def_id, fr, counter,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_upvars(\n-                    infcx.tcx, mir, fr, counter, diag,\n+                    infcx.tcx, mir, fr, counter,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_output(\n-                    infcx, mir, mir_def_id, fr, counter, diag,\n+                    infcx, mir, mir_def_id, fr, counter,\n                 )\n             })\n             .unwrap_or_else(|| span_bug!(mir.span, \"can't make a name for free region {:?}\", fr));\n@@ -122,31 +194,35 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n         debug!(\"give_region_a_name: error_region = {:?}\", error_region);\n         match error_region {\n             ty::ReEarlyBound(ebr) => {\n                 if ebr.has_name() {\n-                    let name = RegionName::Named(ebr.name);\n-                    self.highlight_named_span(tcx, error_region, &name, diag);\n-                    Some(name)\n+                    let span = self.get_named_span(tcx, error_region, &ebr.name);\n+                    Some(RegionName {\n+                        name: ebr.name,\n+                        source: RegionNameSource::NamedEarlyBoundRegion(span)\n+                    })\n                 } else {\n                     None\n                 }\n             }\n \n-            ty::ReStatic => Some(RegionName::Named(\n-                keywords::StaticLifetime.name().as_interned_str()\n-            )),\n+            ty::ReStatic => Some(RegionName {\n+                name: keywords::StaticLifetime.name().as_interned_str(),\n+                source: RegionNameSource::Static\n+            }),\n \n             ty::ReFree(free_region) => match free_region.bound_region {\n                 ty::BoundRegion::BrNamed(_, name) => {\n-                    let name = RegionName::Named(name);\n-                    self.highlight_named_span(tcx, error_region, &name, diag);\n-                    Some(name)\n+                    let span = self.get_named_span(tcx, error_region, &name);\n+                    Some(RegionName {\n+                        name,\n+                        source: RegionNameSource::NamedFreeRegion(span),\n+                    })\n                 },\n \n                 ty::BoundRegion::BrEnv => {\n@@ -162,13 +238,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             bug!(\"Closure is not defined by a closure expr\");\n                         };\n                         let region_name = self.synthesize_region_name(counter);\n-                        diag.span_label(\n-                            args_span,\n-                            format!(\n-                                \"lifetime `{}` represents this closure's body\",\n-                                region_name\n-                            ),\n-                        );\n \n                         let closure_kind_ty = substs.closure_kind_ty(def_id, tcx);\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n@@ -186,9 +255,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             None => bug!(\"Closure kind not inferred in borrow check\"),\n                         };\n \n-                        diag.note(note);\n-\n-                        Some(region_name)\n+                        Some(RegionName {\n+                            name: region_name,\n+                            source: RegionNameSource::SynthesizedFreeEnvRegion(\n+                                args_span,\n+                                note.to_string()\n+                            ),\n+                        })\n                     } else {\n                         // Can't have BrEnv in functions, constants or generators.\n                         bug!(\"BrEnv outside of closure.\");\n@@ -209,27 +282,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Get the span of a named region.\n-    pub(super) fn get_span_of_named_region(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        error_region: &RegionKind,\n-        name: &RegionName,\n-    ) -> Span {\n-        let scope = error_region.free_region_binding_scope(tcx);\n-        let node = tcx.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n-\n-        let span = tcx.sess.source_map().def_span(tcx.hir.span(node));\n-        if let Some(param) = tcx.hir.get_generics(scope).and_then(|generics| {\n-            generics.get_named(name.as_interned_string())\n-        }) {\n-            param.span\n-        } else {\n-            span\n-        }\n-    }\n-\n-    /// Highlight a named span to provide context for error messages that\n+    /// Get a span of a named region to provide context for error messages that\n     /// mention that span, for example:\n     ///\n     /// ```\n@@ -243,19 +296,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must\n     ///  |                                                         outlive `'a`\n     /// ```\n-    fn highlight_named_span(\n+    fn get_named_span(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         error_region: &RegionKind,\n-        name: &RegionName,\n-        diag: &mut DiagnosticBuilder<'_>,\n-    ) {\n-        let span = self.get_span_of_named_region(tcx, error_region, name);\n+        name: &InternedString,\n+    ) -> Span {\n+        let scope = error_region.free_region_binding_scope(tcx);\n+        let node = tcx.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n \n-        diag.span_label(\n-            span,\n-            format!(\"lifetime `{}` defined here\", name),\n-        );\n+        let span = tcx.sess.source_map().def_span(tcx.hir.span(node));\n+        if let Some(param) = tcx.hir\n+            .get_generics(scope)\n+            .and_then(|generics| generics.get_named(name))\n+        {\n+            param.span\n+        } else {\n+            span\n+        }\n     }\n \n     /// Find an argument that contains `fr` and label it with a fully\n@@ -273,7 +331,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n         let argument_index = self.get_argument_index_for_region(infcx.tcx, fr)?;\n@@ -288,12 +345,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             arg_ty,\n             argument_index,\n             counter,\n-            diag,\n         ) {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(infcx, mir, fr, arg_ty, counter, diag)\n+        self.give_name_if_we_cannot_match_hir_ty(infcx, mir, fr, arg_ty, counter)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n@@ -305,7 +361,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let mir_node_id = infcx.tcx.hir.as_local_node_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir.fn_decl(mir_node_id)?;\n@@ -320,7 +375,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 needle_fr,\n                 argument_ty,\n                 counter,\n-                diag,\n             ),\n \n             _ => self.give_name_if_we_can_match_hir_ty(\n@@ -329,7 +383,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 argument_ty,\n                 argument_hir_ty,\n                 counter,\n-                diag,\n             ),\n         }\n     }\n@@ -352,7 +405,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let type_name = with_highlight_region(needle_fr, *counter, || {\n             infcx.extract_type_name(&argument_ty)\n@@ -366,12 +418,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Only add a label if we can confirm that a region was labelled.\n             let argument_index = self.get_argument_index_for_region(infcx.tcx, needle_fr)?;\n             let (_, span) = self.get_argument_name_and_span_for_region(mir, argument_index);\n-            diag.span_label(span, format!(\"has type `{}`\", type_name));\n \n-            // This counter value will already have been used, so this function will increment it\n-            // so the next value will be used next and return the region name that would have been\n-            // used.\n-            Some(self.synthesize_region_name(counter))\n+            Some(RegionName {\n+                // This counter value will already have been used, so this function will increment it\n+                // so the next value will be used next and return the region name that would have been\n+                // used.\n+                name: self.synthesize_region_name(counter),\n+                source: RegionNameSource::CannotMatchHirTy(span, type_name),\n+            })\n         } else {\n             None\n         };\n@@ -407,7 +461,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> = &mut Vec::new();\n \n@@ -432,15 +485,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         let source_map = tcx.sess.source_map();\n                         let ampersand_span = source_map.start_point(hir_ty.span);\n \n-                        diag.span_label(\n-                            ampersand_span,\n-                            format!(\n-                                \"let's call the lifetime of this reference `{}`\",\n-                                region_name\n-                            ),\n-                        );\n-\n-                        return Some(region_name);\n+                        return Some(RegionName {\n+                            name: region_name,\n+                            source: RegionNameSource::MatchedHirTy(ampersand_span),\n+                        });\n                     }\n \n                     // Otherwise, let's descend into the referent types.\n@@ -464,7 +512,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                                 needle_fr,\n                                 last_segment,\n                                 counter,\n-                                diag,\n                                 search_stack,\n                             ) {\n                                 return Some(name);\n@@ -509,7 +556,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         needle_fr: RegionVid,\n         last_segment: &'hir hir::PathSegment,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n     ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n@@ -521,11 +567,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             | hir::LifetimeName::Underscore => {\n                 let region_name = self.synthesize_region_name(counter);\n                 let ampersand_span = lifetime.span;\n-                diag.span_label(\n-                    ampersand_span,\n-                    format!(\"let's call this `{}`\", region_name)\n-                );\n-                return Some(region_name);\n+                return Some(RegionName {\n+                    name: region_name,\n+                    source: RegionNameSource::MatchedAdtAndSegment(ampersand_span),\n+                });\n             }\n \n             hir::LifetimeName::Implicit => {\n@@ -600,22 +645,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir: &Mir<'tcx>,\n         fr: RegionVid,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n         let (upvar_name, upvar_span) =\n             self.get_upvar_name_and_span_for_region(tcx, mir, upvar_index);\n         let region_name = self.synthesize_region_name(counter);\n \n-        diag.span_label(\n-            upvar_span,\n-            format!(\n-                \"lifetime `{}` appears in the type of `{}`\",\n-                region_name, upvar_name\n-            ),\n-        );\n-\n-        Some(region_name)\n+        Some(RegionName {\n+            name: region_name,\n+            source: RegionNameSource::AnonRegionFromUpvar(upvar_span, upvar_name.to_string()),\n+        })\n     }\n \n     /// Check for arguments appearing in the (closure) return type. It\n@@ -629,7 +668,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n-        diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<RegionName> {\n         let tcx = infcx.tcx;\n \n@@ -666,23 +704,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 (mir.span, \"\")\n             };\n \n-        diag.span_label(\n-            return_span,\n-            format!(\"return type{} is {}\", mir_description, type_name),\n-        );\n-\n-        // This counter value will already have been used, so this function will increment it\n-        // so the next value will be used next and return the region name that would have been\n-        // used.\n-        Some(self.synthesize_region_name(counter))\n+        Some(RegionName {\n+            // This counter value will already have been used, so this function will increment it\n+            // so the next value will be used next and return the region name that would have been\n+            // used.\n+            name: self.synthesize_region_name(counter),\n+            source: RegionNameSource::AnonRegionFromOutput(\n+                return_span,\n+                mir_description.to_string(),\n+                type_name\n+            ),\n+        })\n     }\n \n     /// Create a synthetic region named `'1`, incrementing the\n     /// counter.\n-    fn synthesize_region_name(&self, counter: &mut usize) -> RegionName {\n+    fn synthesize_region_name(&self, counter: &mut usize) -> InternedString {\n         let c = *counter;\n         *counter += 1;\n \n-        RegionName::Synthesized(Name::intern(&format!(\"'{:?}\", c)).as_interned_str())\n+        Name::intern(&format!(\"'{:?}\", c)).as_interned_str()\n     }\n }"}]}