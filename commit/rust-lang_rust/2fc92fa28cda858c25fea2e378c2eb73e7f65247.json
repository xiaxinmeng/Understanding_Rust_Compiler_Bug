{"sha": "2fc92fa28cda858c25fea2e378c2eb73e7f65247", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYzkyZmEyOGNkYTg1OGMyNWZlYTJlMzc4YzJlYjczZTdmNjUyNDc=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-06-02T22:44:04Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-06-27T14:13:14Z"}, "message": "Remove track_parent and parent_map, replace with simple walk in missign unsafe validator", "tree": {"sha": "276b53c89a7ca76b20ea4e8f80f41d85bcfbb9f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/276b53c89a7ca76b20ea4e8f80f41d85bcfbb9f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fc92fa28cda858c25fea2e378c2eb73e7f65247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc92fa28cda858c25fea2e378c2eb73e7f65247", "html_url": "https://github.com/rust-lang/rust/commit/2fc92fa28cda858c25fea2e378c2eb73e7f65247", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fc92fa28cda858c25fea2e378c2eb73e7f65247/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f78df42f813504a376dca555b04ac427582f542c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f78df42f813504a376dca555b04ac427582f542c", "html_url": "https://github.com/rust-lang/rust/commit/f78df42f813504a376dca555b04ac427582f542c"}], "stats": {"total": 412, "additions": 121, "deletions": 291}, "files": [{"sha": "4f2350915dcb76ec3ce6009b6e3a792f8aacacfa", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fc92fa28cda858c25fea2e378c2eb73e7f65247/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc92fa28cda858c25fea2e378c2eb73e7f65247/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=2fc92fa28cda858c25fea2e378c2eb73e7f65247", "patch": "@@ -184,7 +184,6 @@ pub struct Body {\n     /// The `ExprId` of the actual body expression.\n     pub body_expr: ExprId,\n     pub item_scope: ItemScope,\n-    pub parent_map: ArenaMap<ExprId, ExprId>,\n }\n \n pub type ExprPtr = AstPtr<ast::Expr>;"}, {"sha": "fdd2be843cb183da26dd0dd83bd442de6a20e92c", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 98, "deletions": 271, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/2fc92fa28cda858c25fea2e378c2eb73e7f65247/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc92fa28cda858c25fea2e378c2eb73e7f65247/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=2fc92fa28cda858c25fea2e378c2eb73e7f65247", "patch": "@@ -7,7 +7,7 @@ use hir_expand::{\n     name::{name, AsName, Name},\n     HirFileId, MacroDefId, MacroDefKind,\n };\n-use ra_arena::{map::ArenaMap, Arena};\n+use ra_arena::Arena;\n use ra_syntax::{\n     ast::{\n         self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, ModuleItemOwner, NameOwner,\n@@ -74,7 +74,6 @@ pub(super) fn lower(\n             params: Vec::new(),\n             body_expr: dummy_expr_id(),\n             item_scope: Default::default(),\n-            parent_map: ArenaMap::default(),\n         },\n         item_trees: {\n             let mut map = FxHashMap::default();\n@@ -96,40 +95,6 @@ struct ExprCollector<'a> {\n     item_trees: FxHashMap<HirFileId, Arc<ItemTree>>,\n }\n \n-macro_rules! track_parent {\n-    (@build $collector:ident, $parent:expr $(,)?) => {\n-        $parent\n-    };\n-    (@build $collector:ident, $parent:expr, opt $expr:ident $($rest:tt)*) => {\n-        {\n-            if let Some(expr) = $expr {\n-                $collector.body.parent_map.insert(expr, $parent);\n-            }\n-            track_parent!(@build $collector, $parent $($rest)*)\n-        }\n-    };\n-    (@build $collector:ident, $parent:expr, vec $expr:ident $($rest:tt)*) => {\n-        {\n-            for expr in $expr {\n-                $collector.body.parent_map.insert(expr, $parent);\n-            }\n-            track_parent!(@build $collector, $parent $($rest)*)\n-        }\n-    };\n-    (@build $collector:ident, $parent:expr, $expr:ident $($rest:tt)*) => {\n-        {\n-            $collector.body.parent_map.insert($expr, $parent);\n-            track_parent!(@build $collector, $parent $($rest)*)\n-        }\n-    };\n-    ($collector:ident, $parent:expr, $($rest:tt)*) => {\n-        {\n-            let parent = $parent;\n-            track_parent!(@build $collector, parent, $($rest)*)\n-        }\n-    }\n-}\n-\n impl ExprCollector<'_> {\n     fn collect(\n         mut self,\n@@ -206,51 +171,7 @@ impl ExprCollector<'_> {\n         id\n     }\n \n-    fn update_parent_map(\n-        &mut self,\n-        (parent_expr, children_exprs): (ExprId, Vec<ExprId>),\n-    ) -> ExprId {\n-        for child_expr in children_exprs {\n-            self.body.parent_map.insert(child_expr, parent_expr);\n-        }\n-\n-        parent_expr\n-    }\n-\n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n-        let expr_id = self.collect_expr_inner(expr);\n-\n-        debug_assert!({\n-            let mut found_count = 0;\n-            let mut incr = || {\n-                found_count += 1;\n-                true\n-            };\n-            let mut all_children_found = true;\n-            self.body[expr_id].walk_child_exprs(|child| {\n-                all_children_found = all_children_found\n-                    && self\n-                        .body\n-                        .parent_map\n-                        .get(child)\n-                        .map(|parent| *parent == expr_id)\n-                        .unwrap_or(false)\n-                    && incr()\n-            });\n-\n-            if all_children_found {\n-                let child_count_in_map =\n-                    self.body.parent_map.iter().filter(|&(_, parent)| *parent == expr_id).count();\n-                found_count == child_count_in_map\n-            } else {\n-                false\n-            }\n-        });\n-\n-        expr_id\n-    }\n-\n-    fn collect_expr_inner(&mut self, expr: ast::Expr) -> ExprId {\n         let syntax_ptr = AstPtr::new(&expr);\n         if !self.expander.is_cfg_enabled(&expr) {\n             return self.missing_expr();\n@@ -285,30 +206,22 @@ impl ExprCollector<'_> {\n                                     guard: None,\n                                 },\n                             ];\n-                            let arm_exprs = arms.iter().map(|arm| arm.expr).collect::<Vec<_>>();\n-                            return track_parent!(\n-                                self,\n-                                self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr),\n-                                match_expr, vec arm_exprs\n-                            );\n+                            return self\n+                                .alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr);\n                         }\n                     },\n                 };\n \n-                track_parent!(\n-                    self,\n-                    self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr),\n-                    then_branch, opt else_branch, condition\n-                )\n+                self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n             ast::Expr::EffectExpr(e) => match e.effect() {\n                 ast::Effect::Try(_) => {\n                     let body = self.collect_block_opt(e.block_expr());\n-                    track_parent!(self, self.alloc_expr(Expr::TryBlock { body }, syntax_ptr), body)\n+                    self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n                 }\n                 ast::Effect::Unsafe(_) => {\n                     let body = self.collect_block_opt(e.block_expr());\n-                    track_parent!(self, self.alloc_expr(Expr::Unsafe { body }, syntax_ptr), body)\n+                    self.alloc_expr(Expr::Unsafe { body }, syntax_ptr)\n                 }\n                 // FIXME: we need to record these effects somewhere...\n                 ast::Effect::Async(_) | ast::Effect::Label(_) => {\n@@ -318,19 +231,15 @@ impl ExprCollector<'_> {\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n-                track_parent!(\n-                    self,\n-                    self.alloc_expr(\n-                        Expr::Loop {\n-                            body,\n-                            label: e\n-                                .label()\n-                                .and_then(|l| l.lifetime_token())\n-                                .map(|l| Name::new_lifetime(&l)),\n-                        },\n-                        syntax_ptr,\n-                    ),\n-                    body\n+                self.alloc_expr(\n+                    Expr::Loop {\n+                        body,\n+                        label: e\n+                            .label()\n+                            .and_then(|l| l.lifetime_token())\n+                            .map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n                 )\n             }\n             ast::Expr::WhileExpr(e) => {\n@@ -354,61 +263,47 @@ impl ExprCollector<'_> {\n                             ];\n                             let match_expr =\n                                 self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n-                            return track_parent!(\n-                                self,\n-                                self.alloc_expr(\n-                                    Expr::Loop {\n-                                        body: match_expr,\n-                                        label: e\n-                                            .label()\n-                                            .and_then(|l| l.lifetime_token())\n-                                            .map(|l| Name::new_lifetime(&l)),\n-                                    },\n-                                    syntax_ptr,\n-                                ),\n-                                match_expr\n+                            return self.alloc_expr(\n+                                Expr::Loop {\n+                                    body: match_expr,\n+                                    label: e\n+                                        .label()\n+                                        .and_then(|l| l.lifetime_token())\n+                                        .map(|l| Name::new_lifetime(&l)),\n+                                },\n+                                syntax_ptr,\n                             );\n                         }\n                     },\n                 };\n \n-                track_parent!(\n-                    self,\n-                    self.alloc_expr(\n-                        Expr::While {\n-                            condition,\n-                            body,\n-                            label: e\n-                                .label()\n-                                .and_then(|l| l.lifetime_token())\n-                                .map(|l| Name::new_lifetime(&l)),\n-                        },\n-                        syntax_ptr,\n-                    ),\n-                    body,\n-                    condition\n+                self.alloc_expr(\n+                    Expr::While {\n+                        condition,\n+                        body,\n+                        label: e\n+                            .label()\n+                            .and_then(|l| l.lifetime_token())\n+                            .map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n                 )\n             }\n             ast::Expr::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n-                track_parent!(\n-                    self,\n-                    self.alloc_expr(\n-                        Expr::For {\n-                            iterable,\n-                            pat,\n-                            body,\n-                            label: e\n-                                .label()\n-                                .and_then(|l| l.lifetime_token())\n-                                .map(|l| Name::new_lifetime(&l)),\n-                        },\n-                        syntax_ptr,\n-                    ),\n-                    iterable,\n-                    body\n+                self.alloc_expr(\n+                    Expr::For {\n+                        iterable,\n+                        pat,\n+                        body,\n+                        label: e\n+                            .label()\n+                            .and_then(|l| l.lifetime_token())\n+                            .map(|l| Name::new_lifetime(&l)),\n+                    },\n+                    syntax_ptr,\n                 )\n             }\n             ast::Expr::CallExpr(e) => {\n@@ -418,7 +313,7 @@ impl ExprCollector<'_> {\n                 } else {\n                     Vec::new()\n                 };\n-                track_parent!(self, self.alloc_expr(Expr::Call { callee, args: args.clone() }, syntax_ptr), callee, vec args)\n+                self.alloc_expr(Expr::Call { callee, args: args.clone() }, syntax_ptr)\n             }\n             ast::Expr::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.expr());\n@@ -430,46 +325,29 @@ impl ExprCollector<'_> {\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let generic_args =\n                     e.type_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx(), it));\n-                track_parent!(\n-                    self,\n-                    self.alloc_expr(\n-                        Expr::MethodCall {\n-                            receiver,\n-                            method_name,\n-                            args: args.clone(),\n-                            generic_args\n-                        },\n-                        syntax_ptr,\n-                    ),\n-                    receiver,\n-                    vec args\n+                self.alloc_expr(\n+                    Expr::MethodCall { receiver, method_name, args: args.clone(), generic_args },\n+                    syntax_ptr,\n                 )\n             }\n             ast::Expr::MatchExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let (arms, children_exprs): (Vec<_>, Vec<_>) =\n-                    if let Some(match_arm_list) = e.match_arm_list() {\n-                        match_arm_list\n-                            .arms()\n-                            .map(|arm| {\n-                                let expr = self.collect_expr_opt(arm.expr());\n-                                (\n-                                    MatchArm {\n-                                        pat: self.collect_pat_opt(arm.pat()),\n-                                        expr,\n-                                        guard: arm\n-                                            .guard()\n-                                            .and_then(|guard| guard.expr())\n-                                            .map(|e| self.collect_expr(e)),\n-                                    },\n-                                    expr,\n-                                )\n-                            })\n-                            .unzip()\n-                    } else {\n-                        (vec![], vec![])\n-                    };\n-                track_parent!(self, self.alloc_expr(Expr::Match { expr, arms: arms.clone() }, syntax_ptr), expr, vec children_exprs)\n+                let arms = if let Some(match_arm_list) = e.match_arm_list() {\n+                    match_arm_list\n+                        .arms()\n+                        .map(|arm| MatchArm {\n+                            pat: self.collect_pat_opt(arm.pat()),\n+                            expr: self.collect_expr_opt(arm.expr()),\n+                            guard: arm\n+                                .guard()\n+                                .and_then(|guard| guard.expr())\n+                                .map(|e| self.collect_expr(e)),\n+                        })\n+                        .collect()\n+                } else {\n+                    vec![]\n+                };\n+                self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n             }\n             ast::Expr::PathExpr(e) => {\n                 let path = e\n@@ -485,10 +363,10 @@ impl ExprCollector<'_> {\n             ),\n             ast::Expr::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                track_parent!(self, self.alloc_expr(\n+                self.alloc_expr(\n                     Expr::Break { expr, label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n                     syntax_ptr,\n-                ), opt expr)\n+                )\n             }\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n@@ -499,13 +377,13 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::ReturnExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                track_parent!(self, self.alloc_expr(Expr::Return { expr }, syntax_ptr), opt expr)\n+                self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::Expr::RecordLit(e) => {\n                 let path = e.path().and_then(|path| self.expander.parse_path(path));\n                 let mut field_ptrs = Vec::new();\n-                let (record_lit, children) = if let Some(nfl) = e.record_field_list() {\n-                    let (fields, children): (Vec<_>, Vec<_>) = nfl\n+                let record_lit = if let Some(nfl) = e.record_field_list() {\n+                    let fields = nfl\n                         .fields()\n                         .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n                         .filter_map(|field| {\n@@ -518,49 +396,42 @@ impl ExprCollector<'_> {\n                                 Some(e) => self.collect_expr(e),\n                                 None => self.missing_expr(),\n                             };\n-                            Some((RecordLitField { name, expr }, expr))\n+                            Some(RecordLitField { name, expr })\n                         })\n-                        .unzip();\n+                        .collect();\n                     let spread = nfl.spread().map(|s| self.collect_expr(s));\n-                    (\n-                        Expr::RecordLit { path, fields, spread: spread },\n-                        children.into_iter().chain(spread.into_iter()).collect(),\n-                    )\n+                    Expr::RecordLit { path, fields, spread: spread }\n                 } else {\n-                    (Expr::RecordLit { path, fields: Vec::new(), spread: None }, vec![])\n+                    Expr::RecordLit { path, fields: Vec::new(), spread: None }\n                 };\n \n                 let res = self.alloc_expr(record_lit, syntax_ptr);\n                 for (i, ptr) in field_ptrs.into_iter().enumerate() {\n                     let src = self.expander.to_source(ptr);\n                     self.source_map.field_map.insert((res, i), src);\n                 }\n-                track_parent!(self, res, vec children)\n+                res\n             }\n             ast::Expr::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let name = match e.field_access() {\n                     Some(kind) => kind.as_name(),\n                     _ => Name::missing(),\n                 };\n-                track_parent!(self, self.alloc_expr(Expr::Field { expr, name }, syntax_ptr), expr)\n+                self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n             }\n             ast::Expr::AwaitExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                track_parent!(self, self.alloc_expr(Expr::Await { expr }, syntax_ptr), expr)\n+                self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n             }\n             ast::Expr::TryExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                track_parent!(self, self.alloc_expr(Expr::Try { expr }, syntax_ptr), expr)\n+                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n             }\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = TypeRef::from_ast_opt(&self.ctx(), e.type_ref());\n-                track_parent!(\n-                    self,\n-                    self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr),\n-                    expr\n-                )\n+                self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n             ast::Expr::RefExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n@@ -577,20 +448,12 @@ impl ExprCollector<'_> {\n                     Mutability::from_mutable(e.mut_token().is_some())\n                 };\n                 let rawness = Rawness::from_raw(raw_tok);\n-                track_parent!(\n-                    self,\n-                    self.alloc_expr(Expr::Ref { expr, rawness, mutability }, syntax_ptr),\n-                    expr\n-                )\n+                self.alloc_expr(Expr::Ref { expr, rawness, mutability }, syntax_ptr)\n             }\n             ast::Expr::PrefixExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 if let Some(op) = e.op_kind() {\n-                    track_parent!(\n-                        self,\n-                        self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr),\n-                        expr\n-                    )\n+                    self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n                 } else {\n                     self.alloc_expr(Expr::Missing, syntax_ptr)\n                 }\n@@ -612,30 +475,21 @@ impl ExprCollector<'_> {\n                     .and_then(|r| r.type_ref())\n                     .map(|it| TypeRef::from_ast(&self.ctx(), it));\n                 let body = self.collect_expr_opt(e.body());\n-                track_parent!(\n-                    self,\n-                    self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr),\n-                    body,\n-                )\n+                self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n             }\n             ast::Expr::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n                 let rhs = self.collect_expr_opt(e.rhs());\n                 let op = e.op_kind().map(BinaryOp::from);\n-                track_parent!(\n-                    self,\n-                    self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr),\n-                    lhs,\n-                    rhs\n-                )\n+                self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::Expr::TupleExpr(e) => {\n                 let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect::<Vec<_>>();\n-                track_parent!(self, self.alloc_expr(Expr::Tuple { exprs: exprs.clone() }, syntax_ptr), vec exprs)\n+                self.alloc_expr(Expr::Tuple { exprs: exprs.clone() }, syntax_ptr)\n             }\n             ast::Expr::BoxExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                track_parent!(self, self.alloc_expr(Expr::Box { expr }, syntax_ptr), expr)\n+                self.alloc_expr(Expr::Box { expr }, syntax_ptr)\n             }\n \n             ast::Expr::ArrayExpr(e) => {\n@@ -644,25 +498,14 @@ impl ExprCollector<'_> {\n                 match kind {\n                     ArrayExprKind::ElementList(e) => {\n                         let exprs = e.map(|expr| self.collect_expr(expr)).collect::<Vec<_>>();\n-                        track_parent!(self,\n-                            self.alloc_expr(\n-                                Expr::Array(Array::ElementList(exprs.clone())),\n-                                syntax_ptr,\n-                            ),\n-                            vec exprs,\n-                        )\n+                        self.alloc_expr(Expr::Array(Array::ElementList(exprs.clone())), syntax_ptr)\n                     }\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n                         let initializer = self.collect_expr_opt(initializer);\n                         let repeat = self.collect_expr_opt(repeat);\n-                        track_parent!(\n-                            self,\n-                            self.alloc_expr(\n-                                Expr::Array(Array::Repeat { initializer, repeat }),\n-                                syntax_ptr,\n-                            ),\n-                            initializer,\n-                            repeat,\n+                        self.alloc_expr(\n+                            Expr::Array(Array::Repeat { initializer, repeat }),\n+                            syntax_ptr,\n                         )\n                     }\n                 }\n@@ -672,22 +515,15 @@ impl ExprCollector<'_> {\n             ast::Expr::IndexExpr(e) => {\n                 let base = self.collect_expr_opt(e.base());\n                 let index = self.collect_expr_opt(e.index());\n-                track_parent!(\n-                    self,\n-                    self.alloc_expr(Expr::Index { base, index }, syntax_ptr),\n-                    base,\n-                    index\n-                )\n+                self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n             }\n             ast::Expr::RangeExpr(e) => {\n                 let lhs = e.start().map(|lhs| self.collect_expr(lhs));\n                 let rhs = e.end().map(|rhs| self.collect_expr(rhs));\n                 match e.op_kind() {\n-                    Some(range_type) => track_parent!(\n-                        self,\n-                        self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr),\n-                        opt lhs, opt rhs\n-                    ),\n+                    Some(range_type) => {\n+                        self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr)\n+                    }\n                     None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n@@ -762,33 +598,24 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n-        let parent_and_children = self.collect_block_inner(block);\n-        self.update_parent_map(parent_and_children)\n-    }\n-\n-    fn collect_block_inner(&mut self, block: ast::BlockExpr) -> (ExprId, Vec<ExprId>) {\n         let syntax_node_ptr = AstPtr::new(&block.clone().into());\n         self.collect_block_items(&block);\n-        let (statements, children_exprs): (Vec<_>, Vec<_>) = block\n+        let statements = block\n             .statements()\n             .map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref =\n                         stmt.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx(), it));\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    (Statement::Let { pat, type_ref, initializer }, initializer)\n-                }\n-                ast::Stmt::ExprStmt(stmt) => {\n-                    let expr = self.collect_expr_opt(stmt.expr());\n-                    (Statement::Expr(expr), Some(expr))\n+                    Statement::Let { pat, type_ref, initializer }\n                 }\n+                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n             })\n-            .unzip();\n+            .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n         let label = block.label().and_then(|l| l.lifetime_token()).map(|t| Name::new_lifetime(&t));\n-        let children_exprs = children_exprs.into_iter().flatten().chain(tail.into_iter()).collect();\n-        (self.alloc_expr(Expr::Block { statements, tail, label }, syntax_node_ptr), children_exprs)\n+        self.alloc_expr(Expr::Block { statements, tail, label }, syntax_node_ptr)\n     }\n \n     fn collect_block_items(&mut self, block: &ast::BlockExpr) {"}, {"sha": "f3ce7112ad0c45ff060ba4622fff14744e46601e", "filename": "crates/ra_hir_ty/src/unsafe_validation.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2fc92fa28cda858c25fea2e378c2eb73e7f65247/crates%2Fra_hir_ty%2Fsrc%2Funsafe_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc92fa28cda858c25fea2e378c2eb73e7f65247/crates%2Fra_hir_ty%2Fsrc%2Funsafe_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Funsafe_validation.rs?ref=2fc92fa28cda858c25fea2e378c2eb73e7f65247", "patch": "@@ -13,16 +13,9 @@ use crate::{\n \n use rustc_hash::FxHashSet;\n \n-pub use hir_def::{\n-    body::{\n-        scope::{ExprScopes, ScopeEntry, ScopeId},\n-        Body, BodySourceMap, ExprPtr, ExprSource, PatPtr, PatSource,\n-    },\n-    expr::{\n-        ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n-        MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n-    },\n-    LocalFieldId, VariantId,\n+use hir_def::{\n+    body::Body,\n+    expr::{Expr, ExprId, UnaryOp},\n };\n \n pub struct UnsafeValidator<'a, 'b: 'a> {\n@@ -119,16 +112,27 @@ pub fn unsafe_expressions(\n         }\n     }\n \n-    'unsafe_exprs: for unsafe_expr in &mut unsafe_exprs {\n-        let mut child = unsafe_expr.expr;\n-        while let Some(parent) = body.parent_map.get(child) {\n-            if unsafe_block_exprs.contains(parent) {\n-                unsafe_expr.inside_unsafe_block = true;\n-                continue 'unsafe_exprs;\n-            }\n-            child = *parent;\n-        }\n+    for unsafe_expr in &mut unsafe_exprs {\n+        unsafe_expr.inside_unsafe_block =\n+            is_in_unsafe(&body, body.body_expr, unsafe_expr.expr, false);\n     }\n \n     unsafe_exprs\n }\n+\n+fn is_in_unsafe(body: &Body, current: ExprId, needle: ExprId, within_unsafe: bool) -> bool {\n+    if current == needle {\n+        return within_unsafe;\n+    }\n+\n+    let expr = &body.exprs[current];\n+    if let &Expr::Unsafe { body: child } = expr {\n+        return is_in_unsafe(body, child, needle, true);\n+    }\n+\n+    let mut found = false;\n+    expr.walk_child_exprs(|child| {\n+        found = found || is_in_unsafe(body, child, needle, within_unsafe);\n+    });\n+    found\n+}"}]}