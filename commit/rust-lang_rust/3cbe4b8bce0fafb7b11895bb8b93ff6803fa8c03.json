{"sha": "3cbe4b8bce0fafb7b11895bb8b93ff6803fa8c03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYmU0YjhiY2UwZmFmYjdiMTE4OTViYjhiOTNmZjY4MDNmYThjMDM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-30T05:14:12Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T16:21:33Z"}, "message": "rustc_metadata: sign-extend when decoding signed integers.", "tree": {"sha": "7ca1dad5be1a922cdac143e1b24569fabeba3e31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ca1dad5be1a922cdac143e1b24569fabeba3e31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cbe4b8bce0fafb7b11895bb8b93ff6803fa8c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cbe4b8bce0fafb7b11895bb8b93ff6803fa8c03", "html_url": "https://github.com/rust-lang/rust/commit/3cbe4b8bce0fafb7b11895bb8b93ff6803fa8c03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cbe4b8bce0fafb7b11895bb8b93ff6803fa8c03/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "html_url": "https://github.com/rust-lang/rust/commit/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb"}], "stats": {"total": 67, "additions": 50, "deletions": 17}, "files": [{"sha": "d4ac97ce5e03c9812bce834d9eb857f115f04713", "filename": "src/librustc_metadata/rbml/reader.rs", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3cbe4b8bce0fafb7b11895bb8b93ff6803fa8c03/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cbe4b8bce0fafb7b11895bb8b93ff6803fa8c03/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Freader.rs?ref=3cbe4b8bce0fafb7b11895bb8b93ff6803fa8c03", "patch": "@@ -595,30 +595,27 @@ impl<'doc> Decoder<'doc> {\n     }\n \n     // variable-length unsigned integer with different tags.\n-    // `first_tag` should be a tag for u8 or i8.\n-    // `last_tag` should be the largest allowed integer tag with the matching signedness.\n+    // `last_tag` should be the largest allowed unsigned integer tag.\n     // all tags between them should be valid, in the order of u8, u16, u32 and u64.\n-    fn _next_int(&mut self,\n-                 first_tag: EbmlEncoderTag,\n+    fn next_uint(&mut self,\n                  last_tag: EbmlEncoderTag)\n                  -> DecodeResult<u64> {\n         if self.pos >= self.parent.end {\n             return Err(Expected(format!(\"no more documents in current node!\")));\n         }\n \n         let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-        let r = if first_tag as usize <= r_tag && r_tag <= last_tag as usize {\n-            match r_tag - first_tag as usize {\n+        let r = if EsU8 as usize <= r_tag && r_tag <= last_tag as usize {\n+            match r_tag - EsU8 as usize {\n                 0 => doc_as_u8(r_doc) as u64,\n                 1 => doc_as_u16(r_doc) as u64,\n                 2 => doc_as_u32(r_doc) as u64,\n                 3 => doc_as_u64(r_doc),\n                 _ => unreachable!(),\n             }\n         } else {\n-            return Err(Expected(format!(\"expected EBML doc with tag {:?} through {:?} but \\\n+            return Err(Expected(format!(\"expected EBML doc with tag EsU8 through {:?} but \\\n                                          found tag {:?}\",\n-                                        first_tag,\n                                         last_tag,\n                                         r_tag)));\n         };\n@@ -629,7 +626,43 @@ impl<'doc> Decoder<'doc> {\n                                         self.parent.end)));\n         }\n         self.pos = r_doc.end;\n-        debug!(\"_next_int({:?}, {:?}) result={:?}\", first_tag, last_tag, r);\n+        debug!(\"next_uint({:?}) result={:?}\", last_tag, r);\n+        Ok(r)\n+    }\n+\n+    // variable-length signed integer with different tags.\n+    // `last_tag` should be the largest allowed signed integer tag.\n+    // all tags between them should be valid, in the order of i8, i16, i32 and i64.\n+    fn next_int(&mut self,\n+                last_tag: EbmlEncoderTag)\n+                -> DecodeResult<i64> {\n+        if self.pos >= self.parent.end {\n+            return Err(Expected(format!(\"no more documents in current node!\")));\n+        }\n+\n+        let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n+        let r = if EsI8 as usize <= r_tag && r_tag <= last_tag as usize {\n+            match r_tag - EsI8 as usize {\n+                0 => doc_as_i8(r_doc) as i64,\n+                1 => doc_as_i16(r_doc) as i64,\n+                2 => doc_as_i32(r_doc) as i64,\n+                3 => doc_as_i64(r_doc),\n+                _ => unreachable!(),\n+            }\n+        } else {\n+            return Err(Expected(format!(\"expected EBML doc with tag EsI8 through {:?} but \\\n+                                         found tag {:?}\",\n+                                        last_tag,\n+                                        r_tag)));\n+        };\n+        if r_doc.end > self.parent.end {\n+            return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n+                                         {:#x}\",\n+                                        r_doc.end,\n+                                        self.parent.end)));\n+        }\n+        self.pos = r_doc.end;\n+        debug!(\"next_int({:?}) result={:?}\", last_tag, r);\n         Ok(r)\n     }\n \n@@ -662,19 +695,19 @@ impl<'doc> serialize::Decoder for Decoder<'doc> {\n     }\n \n     fn read_u64(&mut self) -> DecodeResult<u64> {\n-        self._next_int(EsU8, EsU64)\n+        self.next_uint(EsU64)\n     }\n     fn read_u32(&mut self) -> DecodeResult<u32> {\n-        Ok(self._next_int(EsU8, EsU32)? as u32)\n+        Ok(self.next_uint(EsU32)? as u32)\n     }\n     fn read_u16(&mut self) -> DecodeResult<u16> {\n-        Ok(self._next_int(EsU8, EsU16)? as u16)\n+        Ok(self.next_uint(EsU16)? as u16)\n     }\n     fn read_u8(&mut self) -> DecodeResult<u8> {\n         Ok(doc_as_u8(self.next_doc(EsU8)?))\n     }\n     fn read_usize(&mut self) -> DecodeResult<usize> {\n-        let v = self._next_int(EsU8, EsU64)?;\n+        let v = self.read_u64()?;\n         if v > (::std::usize::MAX as u64) {\n             Err(IntTooBig(v as usize))\n         } else {\n@@ -683,19 +716,19 @@ impl<'doc> serialize::Decoder for Decoder<'doc> {\n     }\n \n     fn read_i64(&mut self) -> DecodeResult<i64> {\n-        Ok(self._next_int(EsI8, EsI64)? as i64)\n+        Ok(self.next_int(EsI64)? as i64)\n     }\n     fn read_i32(&mut self) -> DecodeResult<i32> {\n-        Ok(self._next_int(EsI8, EsI32)? as i32)\n+        Ok(self.next_int(EsI32)? as i32)\n     }\n     fn read_i16(&mut self) -> DecodeResult<i16> {\n-        Ok(self._next_int(EsI8, EsI16)? as i16)\n+        Ok(self.next_int(EsI16)? as i16)\n     }\n     fn read_i8(&mut self) -> DecodeResult<i8> {\n         Ok(doc_as_u8(self.next_doc(EsI8)?) as i8)\n     }\n     fn read_isize(&mut self) -> DecodeResult<isize> {\n-        let v = self._next_int(EsI8, EsI64)? as i64;\n+        let v = self.next_int(EsI64)? as i64;\n         if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n             debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n             Err(IntTooBig(v as usize))"}]}