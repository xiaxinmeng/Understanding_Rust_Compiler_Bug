{"sha": "69051d2f9dcf008124918ef34d2f11221a6a20f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MDUxZDJmOWRjZjAwODEyNDkxOGVmMzRkMmYxMTIyMWE2YTIwZjA=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-03T03:09:14Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-03T22:56:58Z"}, "message": "SSR: Refactor matching code.\n\nMutable state is now stored in the enum Phase.\nMatchState, since it now has no mutable state is renamed Matcher.\nMatchInputs is merged into Matcher", "tree": {"sha": "fb9527539d736ff98f690550bc769b68e5263811", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb9527539d736ff98f690550bc769b68e5263811"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69051d2f9dcf008124918ef34d2f11221a6a20f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69051d2f9dcf008124918ef34d2f11221a6a20f0", "html_url": "https://github.com/rust-lang/rust/commit/69051d2f9dcf008124918ef34d2f11221a6a20f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69051d2f9dcf008124918ef34d2f11221a6a20f0/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a8679824b9ddf950e6754231755d5d065692c47", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8679824b9ddf950e6754231755d5d065692c47", "html_url": "https://github.com/rust-lang/rust/commit/4a8679824b9ddf950e6754231755d5d065692c47"}], "stats": {"total": 155, "additions": 75, "deletions": 80}, "files": [{"sha": "50b29eab2d630f5856b6adc2e1b4b7a2f81e9d2f", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 75, "deletions": 80, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/69051d2f9dcf008124918ef34d2f11221a6a20f0/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69051d2f9dcf008124918ef34d2f11221a6a20f0/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=69051d2f9dcf008124918ef34d2f11221a6a20f0", "patch": "@@ -92,58 +92,52 @@ pub(crate) fn get_match(\n     sema: &Semantics<ra_ide_db::RootDatabase>,\n ) -> Result<Match, MatchFailed> {\n     record_match_fails_reasons_scope(debug_active, || {\n-        MatchState::try_match(rule, code, restrict_range, sema)\n+        Matcher::try_match(rule, code, restrict_range, sema)\n     })\n }\n \n-/// Inputs to matching. This cannot be part of `MatchState`, since we mutate `MatchState` and in at\n-/// least one case need to hold a borrow of a placeholder from the input pattern while calling a\n-/// mutable `MatchState` method.\n-struct MatchInputs<'pattern> {\n-    ssr_pattern: &'pattern SsrPattern,\n-}\n-\n-/// State used while attempting to match our search pattern against a particular node of the AST.\n-struct MatchState<'db, 'sema> {\n+/// Checks if our search pattern matches a particular node of the AST.\n+struct Matcher<'db, 'sema> {\n     sema: &'sema Semantics<'db, ra_ide_db::RootDatabase>,\n     /// If any placeholders come from anywhere outside of this range, then the match will be\n     /// rejected.\n     restrict_range: Option<FileRange>,\n-    /// The match that we're building. We do two passes for a successful match. On the first pass,\n-    /// this is None so that we can avoid doing things like storing copies of what placeholders\n-    /// matched to. If that pass succeeds, then we do a second pass where we collect those details.\n-    /// This means that if we have a pattern like `$a.foo()` we won't do an insert into the\n-    /// placeholders map for every single method call in the codebase. Instead we'll discard all the\n-    /// method calls that aren't calls to `foo` on the first pass and only insert into the\n-    /// placeholders map on the second pass. Likewise for ignored comments.\n-    match_out: Option<Match>,\n+    rule: &'sema SsrRule,\n+}\n+\n+/// Which phase of matching we're currently performing. We do two phases because most attempted\n+/// matches will fail and it means we can defer more expensive checks to the second phase.\n+enum Phase<'a> {\n+    /// On the first phase, we perform cheap checks. No state is mutated and nothing is recorded.\n+    First,\n+    /// On the second phase, we construct the `Match`. Things like what placeholders bind to is\n+    /// recorded.\n+    Second(&'a mut Match),\n }\n \n-impl<'db, 'sema> MatchState<'db, 'sema> {\n+impl<'db, 'sema> Matcher<'db, 'sema> {\n     fn try_match(\n-        rule: &SsrRule,\n+        rule: &'sema SsrRule,\n         code: &SyntaxNode,\n         restrict_range: &Option<FileRange>,\n         sema: &'sema Semantics<'db, ra_ide_db::RootDatabase>,\n     ) -> Result<Match, MatchFailed> {\n-        let mut match_state =\n-            MatchState { sema, restrict_range: restrict_range.clone(), match_out: None };\n-        let match_inputs = MatchInputs { ssr_pattern: &rule.pattern };\n+        let match_state = Matcher { sema, restrict_range: restrict_range.clone(), rule };\n         let pattern_tree = rule.pattern.tree_for_kind(code.kind())?;\n         // First pass at matching, where we check that node types and idents match.\n-        match_state.attempt_match_node(&match_inputs, &pattern_tree, code)?;\n+        match_state.attempt_match_node(&mut Phase::First, &pattern_tree, code)?;\n         match_state.validate_range(&sema.original_range(code))?;\n-        match_state.match_out = Some(Match {\n+        let mut the_match = Match {\n             range: sema.original_range(code),\n             matched_node: code.clone(),\n             placeholder_values: FxHashMap::default(),\n             ignored_comments: Vec::new(),\n             template: rule.template.clone(),\n-        });\n+        };\n         // Second matching pass, where we record placeholder matches, ignored comments and maybe do\n         // any other more expensive checks that we didn't want to do on the first pass.\n-        match_state.attempt_match_node(&match_inputs, &pattern_tree, code)?;\n-        Ok(match_state.match_out.unwrap())\n+        match_state.attempt_match_node(&mut Phase::Second(&mut the_match), &pattern_tree, code)?;\n+        Ok(the_match)\n     }\n \n     /// Checks that `range` is within the permitted range if any. This is applicable when we're\n@@ -161,27 +155,22 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     }\n \n     fn attempt_match_node(\n-        &mut self,\n-        match_inputs: &MatchInputs,\n+        &self,\n+        phase: &mut Phase,\n         pattern: &SyntaxNode,\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n         // Handle placeholders.\n-        if let Some(placeholder) =\n-            match_inputs.get_placeholder(&SyntaxElement::Node(pattern.clone()))\n-        {\n+        if let Some(placeholder) = self.get_placeholder(&SyntaxElement::Node(pattern.clone())) {\n             for constraint in &placeholder.constraints {\n                 self.check_constraint(constraint, code)?;\n             }\n-            if self.match_out.is_none() {\n-                return Ok(());\n-            }\n-            let original_range = self.sema.original_range(code);\n-            // We validated the range for the node when we started the match, so the placeholder\n-            // probably can't fail range validation, but just to be safe...\n-            self.validate_range(&original_range)?;\n-            if let Some(match_out) = &mut self.match_out {\n-                match_out.placeholder_values.insert(\n+            if let Phase::Second(matches_out) = phase {\n+                let original_range = self.sema.original_range(code);\n+                // We validated the range for the node when we started the match, so the placeholder\n+                // probably can't fail range validation, but just to be safe...\n+                self.validate_range(&original_range)?;\n+                matches_out.placeholder_values.insert(\n                     Var(placeholder.ident.to_string()),\n                     PlaceholderMatch::new(code, original_range),\n                 );\n@@ -190,53 +179,59 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         }\n         // Non-placeholders.\n         if pattern.kind() != code.kind() {\n-            fail_match!(\"Pattern had a {:?}, code had {:?}\", pattern.kind(), code.kind());\n+            fail_match!(\n+                \"Pattern had a `{}` ({:?}), code had `{}` ({:?})\",\n+                pattern.text(),\n+                pattern.kind(),\n+                code.text(),\n+                code.kind()\n+            );\n         }\n         // Some kinds of nodes have special handling. For everything else, we fall back to default\n         // matching.\n         match code.kind() {\n             SyntaxKind::RECORD_FIELD_LIST => {\n-                self.attempt_match_record_field_list(match_inputs, pattern, code)\n+                self.attempt_match_record_field_list(phase, pattern, code)\n             }\n-            SyntaxKind::TOKEN_TREE => self.attempt_match_token_tree(match_inputs, pattern, code),\n-            _ => self.attempt_match_node_children(match_inputs, pattern, code),\n+            SyntaxKind::TOKEN_TREE => self.attempt_match_token_tree(phase, pattern, code),\n+            _ => self.attempt_match_node_children(phase, pattern, code),\n         }\n     }\n \n     fn attempt_match_node_children(\n-        &mut self,\n-        match_inputs: &MatchInputs,\n+        &self,\n+        phase: &mut Phase,\n         pattern: &SyntaxNode,\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n         self.attempt_match_sequences(\n-            match_inputs,\n+            phase,\n             PatternIterator::new(pattern),\n             code.children_with_tokens(),\n         )\n     }\n \n     fn attempt_match_sequences(\n-        &mut self,\n-        match_inputs: &MatchInputs,\n+        &self,\n+        phase: &mut Phase,\n         pattern_it: PatternIterator,\n         mut code_it: SyntaxElementChildren,\n     ) -> Result<(), MatchFailed> {\n         let mut pattern_it = pattern_it.peekable();\n         loop {\n-            match self.next_non_trivial(&mut code_it) {\n+            match phase.next_non_trivial(&mut code_it) {\n                 None => {\n                     if let Some(p) = pattern_it.next() {\n                         fail_match!(\"Part of the pattern was unmatched: {:?}\", p);\n                     }\n                     return Ok(());\n                 }\n                 Some(SyntaxElement::Token(c)) => {\n-                    self.attempt_match_token(&mut pattern_it, &c)?;\n+                    self.attempt_match_token(phase, &mut pattern_it, &c)?;\n                 }\n                 Some(SyntaxElement::Node(c)) => match pattern_it.next() {\n                     Some(SyntaxElement::Node(p)) => {\n-                        self.attempt_match_node(match_inputs, &p, &c)?;\n+                        self.attempt_match_node(phase, &p, &c)?;\n                     }\n                     Some(p) => fail_match!(\"Pattern wanted '{}', code has {}\", p, c.text()),\n                     None => fail_match!(\"Pattern reached end, code has {}\", c.text()),\n@@ -246,11 +241,12 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     }\n \n     fn attempt_match_token(\n-        &mut self,\n+        &self,\n+        phase: &mut Phase,\n         pattern: &mut Peekable<PatternIterator>,\n         code: &ra_syntax::SyntaxToken,\n     ) -> Result<(), MatchFailed> {\n-        self.record_ignored_comments(code);\n+        phase.record_ignored_comments(code);\n         // Ignore whitespace and comments.\n         if code.kind().is_trivia() {\n             return Ok(());\n@@ -317,8 +313,8 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     /// We want to allow the records to match in any order, so we have special matching logic for\n     /// them.\n     fn attempt_match_record_field_list(\n-        &mut self,\n-        match_inputs: &MatchInputs,\n+        &self,\n+        phase: &mut Phase,\n         pattern: &SyntaxNode,\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n@@ -334,11 +330,11 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         for p in pattern.children_with_tokens() {\n             if let SyntaxElement::Node(p) = p {\n                 if let Some(name_element) = p.first_child_or_token() {\n-                    if match_inputs.get_placeholder(&name_element).is_some() {\n+                    if self.get_placeholder(&name_element).is_some() {\n                         // If the pattern is using placeholders for field names then order\n                         // independence doesn't make sense. Fall back to regular ordered\n                         // matching.\n-                        return self.attempt_match_node_children(match_inputs, pattern, code);\n+                        return self.attempt_match_node_children(phase, pattern, code);\n                     }\n                     if let Some(ident) = only_ident(name_element) {\n                         let code_record = fields_by_name.remove(ident.text()).ok_or_else(|| {\n@@ -347,7 +343,7 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n                                 ident\n                             )\n                         })?;\n-                        self.attempt_match_node(match_inputs, &p, &code_record)?;\n+                        self.attempt_match_node(phase, &p, &code_record)?;\n                     }\n                 }\n             }\n@@ -367,16 +363,15 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     /// pattern matches the macro invocation. For matches within the macro call, we'll already have\n     /// expanded the macro.\n     fn attempt_match_token_tree(\n-        &mut self,\n-        match_inputs: &MatchInputs,\n+        &self,\n+        phase: &mut Phase,\n         pattern: &SyntaxNode,\n         code: &ra_syntax::SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n         let mut pattern = PatternIterator::new(pattern).peekable();\n         let mut children = code.children_with_tokens();\n         while let Some(child) = children.next() {\n-            if let Some(placeholder) = pattern.peek().and_then(|p| match_inputs.get_placeholder(p))\n-            {\n+            if let Some(placeholder) = pattern.peek().and_then(|p| self.get_placeholder(p)) {\n                 pattern.next();\n                 let next_pattern_token = pattern\n                     .peek()\n@@ -402,7 +397,7 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n                                 if Some(first_token.to_string()) == next_pattern_token {\n                                     if let Some(SyntaxElement::Node(p)) = pattern.next() {\n                                         // We have a subtree that starts with the next token in our pattern.\n-                                        self.attempt_match_token_tree(match_inputs, &p, &n)?;\n+                                        self.attempt_match_token_tree(phase, &p, &n)?;\n                                         break;\n                                     }\n                                 }\n@@ -411,7 +406,7 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n                     };\n                     last_matched_token = next;\n                 }\n-                if let Some(match_out) = &mut self.match_out {\n+                if let Phase::Second(match_out) = phase {\n                     match_out.placeholder_values.insert(\n                         Var(placeholder.ident.to_string()),\n                         PlaceholderMatch::from_range(FileRange {\n@@ -427,11 +422,11 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n             // Match literal (non-placeholder) tokens.\n             match child {\n                 SyntaxElement::Token(token) => {\n-                    self.attempt_match_token(&mut pattern, &token)?;\n+                    self.attempt_match_token(phase, &mut pattern, &token)?;\n                 }\n                 SyntaxElement::Node(node) => match pattern.next() {\n                     Some(SyntaxElement::Node(p)) => {\n-                        self.attempt_match_token_tree(match_inputs, &p, &node)?;\n+                        self.attempt_match_token_tree(phase, &p, &node)?;\n                     }\n                     Some(SyntaxElement::Token(p)) => fail_match!(\n                         \"Pattern has token '{}', code has subtree '{}'\",\n@@ -448,6 +443,13 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         Ok(())\n     }\n \n+    fn get_placeholder(&self, element: &SyntaxElement) -> Option<&Placeholder> {\n+        only_ident(element.clone())\n+            .and_then(|ident| self.rule.pattern.placeholders_by_stand_in.get(ident.text()))\n+    }\n+}\n+\n+impl Phase<'_> {\n     fn next_non_trivial(&mut self, code_it: &mut SyntaxElementChildren) -> Option<SyntaxElement> {\n         loop {\n             let c = code_it.next();\n@@ -463,7 +465,7 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n \n     fn record_ignored_comments(&mut self, token: &SyntaxToken) {\n         if token.kind() == SyntaxKind::COMMENT {\n-            if let Some(match_out) = &mut self.match_out {\n+            if let Phase::Second(match_out) = self {\n                 if let Some(comment) = ast::Comment::cast(token.clone()) {\n                     match_out.ignored_comments.push(comment);\n                 }\n@@ -472,13 +474,6 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     }\n }\n \n-impl MatchInputs<'_> {\n-    fn get_placeholder(&self, element: &SyntaxElement) -> Option<&Placeholder> {\n-        only_ident(element.clone())\n-            .and_then(|ident| self.ssr_pattern.placeholders_by_stand_in.get(ident.text()))\n-    }\n-}\n-\n fn is_closing_token(kind: SyntaxKind) -> bool {\n     kind == SyntaxKind::R_PAREN || kind == SyntaxKind::R_CURLY || kind == SyntaxKind::R_BRACK\n }\n@@ -596,12 +591,12 @@ impl PatternIterator {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::MatchFinder;\n+    use crate::{MatchFinder, SsrRule};\n \n     #[test]\n     fn parse_match_replace() {\n         let rule: SsrRule = \"foo($x) ==>> bar($x)\".parse().unwrap();\n-        let input = \"fn main() { foo(1+2); }\";\n+        let input = \"fn foo() {} fn main() { foo(1+2); }\";\n \n         use ra_db::fixture::WithFixture;\n         let (db, file_id) = ra_ide_db::RootDatabase::with_single_file(input);\n@@ -623,6 +618,6 @@ mod tests {\n         let edit = crate::replacing::matches_to_edit(&matches, input);\n         let mut after = input.to_string();\n         edit.apply(&mut after);\n-        assert_eq!(after, \"fn main() { bar(1+2); }\");\n+        assert_eq!(after, \"fn foo() {} fn main() { bar(1+2); }\");\n     }\n }"}]}