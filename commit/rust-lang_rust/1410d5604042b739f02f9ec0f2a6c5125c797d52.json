{"sha": "1410d5604042b739f02f9ec0f2a6c5125c797d52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MTBkNTYwNDA0MmI3MzlmMDJmOWVjMGYyYTZjNTEyNWM3OTdkNTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-16T06:10:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-16T06:10:36Z"}, "message": "Auto merge of #45920 - sunfishcode:trap-on-unreachable, r=Zoxc\n\nEnable TrapUnreachable in LLVM.\n\nThis patch enables LLVM's TrapUnreachable flag, which tells it to translate `unreachable` instructions into hardware trap instructions, rather than allowing control flow to \"fall through\" into whatever code happens to follow it in memory.\n\nThis follows up on https://github.com/rust-lang/rust/issues/28728#issuecomment-332581533. For example, for @zackw's testcase [here](https://github.com/rust-lang/rust/issues/42009#issue-228745924), the output function contains a `ud2` instead of no code, so it won't \"fall through\" into whatever happens to be next in memory.\n\n(I'm also working on the problem of LLVM optimizing away infinite loops, but the patch here is useful independently.)\n\nI tested this patch on a few different codebases, and the code size increase ranged from 0.0% to 0.1%.", "tree": {"sha": "5e945d090d07c9abff1dbb8ce36193ed5ee32f15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e945d090d07c9abff1dbb8ce36193ed5ee32f15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1410d5604042b739f02f9ec0f2a6c5125c797d52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1410d5604042b739f02f9ec0f2a6c5125c797d52", "html_url": "https://github.com/rust-lang/rust/commit/1410d5604042b739f02f9ec0f2a6c5125c797d52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1410d5604042b739f02f9ec0f2a6c5125c797d52/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8385fc062dbb57c32d96d16e59d244c168103946", "url": "https://api.github.com/repos/rust-lang/rust/commits/8385fc062dbb57c32d96d16e59d244c168103946", "html_url": "https://github.com/rust-lang/rust/commit/8385fc062dbb57c32d96d16e59d244c168103946"}, {"sha": "ac48348db85d0ce9efdc450ab52837dcfc42a932", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac48348db85d0ce9efdc450ab52837dcfc42a932", "html_url": "https://github.com/rust-lang/rust/commit/ac48348db85d0ce9efdc450ab52837dcfc42a932"}], "stats": {"total": 38, "additions": 33, "deletions": 5}, "files": [{"sha": "f5532b22b5d741f3ea207b5b07e3e1ca63476f9b", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=1410d5604042b739f02f9ec0f2a6c5125c797d52", "patch": "@@ -1 +1 @@\n-Subproject commit 0b9844764ea1f99ea11a7917a4f3ba7fd2db775c\n+Subproject commit f5532b22b5d741f3ea207b5b07e3e1ca63476f9b"}, {"sha": "d60d6438b4d61d96723e5bc04b1402e8a2917b4c", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=1410d5604042b739f02f9ec0f2a6c5125c797d52", "patch": "@@ -435,6 +435,10 @@ pub struct TargetOptions {\n \n     /// Default number of codegen units to use in debug mode\n     pub default_codegen_units: Option<u64>,\n+\n+    /// Whether to generate trap instructions in places where optimization would\n+    /// otherwise produce control flow that falls through into unrelated memory.\n+    pub trap_unreachable: bool,\n }\n \n impl Default for TargetOptions {\n@@ -498,6 +502,7 @@ impl Default for TargetOptions {\n             stack_probes: false,\n             min_global_align: None,\n             default_codegen_units: None,\n+            trap_unreachable: true,\n         }\n     }\n }\n@@ -739,6 +744,7 @@ impl Target {\n         key!(stack_probes, bool);\n         key!(min_global_align, Option<u64>);\n         key!(default_codegen_units, Option<u64>);\n+        key!(trap_unreachable, bool);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -932,6 +938,7 @@ impl ToJson for Target {\n         target_option_val!(stack_probes);\n         target_option_val!(min_global_align);\n         target_option_val!(default_codegen_units);\n+        target_option_val!(trap_unreachable);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()"}, {"sha": "24c3963fbc4b31b9388376cc6af18496ca9e0714", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=1410d5604042b739f02f9ec0f2a6c5125c797d52", "patch": "@@ -1605,7 +1605,8 @@ extern \"C\" {\n                                        UseSoftFP: bool,\n                                        PositionIndependentExecutable: bool,\n                                        FunctionSections: bool,\n-                                       DataSections: bool)\n+                                       DataSections: bool,\n+                                       TrapUnreachable: bool)\n                                        -> TargetMachineRef;\n     pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n     pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef, PM: PassManagerRef, M: ModuleRef);"}, {"sha": "e443f13a7a1ca5ef2207df6a2ec240a9a8f9e2bf", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=1410d5604042b739f02f9ec0f2a6c5125c797d52", "patch": "@@ -196,6 +196,7 @@ pub fn target_machine_factory(sess: &Session)\n     let cpu = CString::new(cpu.as_bytes()).unwrap();\n     let features = CString::new(target_feature(sess).as_bytes()).unwrap();\n     let is_pie_binary = is_pie_binary(sess);\n+    let trap_unreachable = sess.target.target.options.trap_unreachable;\n \n     Arc::new(move || {\n         let tm = unsafe {\n@@ -208,6 +209,7 @@ pub fn target_machine_factory(sess: &Session)\n                 is_pie_binary,\n                 ffunction_sections,\n                 fdata_sections,\n+                trap_unreachable,\n             )\n         };\n "}, {"sha": "b4116c96ba130afd3a35decf2baf8a582e868e38", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=1410d5604042b739f02f9ec0f2a6c5125c797d52", "patch": "@@ -366,7 +366,7 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     LLVMRustCodeModel RustCM, LLVMRustRelocMode RustReloc,\n     LLVMRustCodeGenOptLevel RustOptLevel, bool UseSoftFloat,\n     bool PositionIndependentExecutable, bool FunctionSections,\n-    bool DataSections) {\n+    bool DataSections, bool TrapUnreachable) {\n \n   auto CM = fromRust(RustCM);\n   auto OptLevel = fromRust(RustOptLevel);\n@@ -398,6 +398,14 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   Options.DataSections = DataSections;\n   Options.FunctionSections = FunctionSections;\n \n+  if (TrapUnreachable) {\n+    // Tell LLVM to translate `unreachable` into an explicit trap instruction.\n+    // This limits the extent of possible undefined behavior in some cases, as\n+    // it prevents control flow from \"falling through\" into whatever code\n+    // happens to be laid out next in memory.\n+    Options.TrapUnreachable = true;\n+  }\n+\n   TargetMachine *TM = TheTarget->createTargetMachine(\n       Trip.getTriple(), RealCPU, Feature, Options, RM, CM, OptLevel);\n   return wrap(TM);"}, {"sha": "1b8b644dd78e867888038e4f5412cdd806d36774", "filename": "src/test/run-make/intrinsic-unreachable/exit-ret.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Ftest%2Frun-make%2Fintrinsic-unreachable%2Fexit-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Ftest%2Frun-make%2Fintrinsic-unreachable%2Fexit-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fintrinsic-unreachable%2Fexit-ret.rs?ref=1410d5604042b739f02f9ec0f2a6c5125c797d52", "patch": "@@ -11,10 +11,15 @@\n #![feature(asm)]\n #![crate_type=\"lib\"]\n \n-pub fn exit(n: usize) {\n+#[deny(unreachable_code)]\n+pub fn exit(n: usize) -> i32 {\n     unsafe {\n         // Pretend this asm is an exit() syscall.\n         asm!(\"\" :: \"r\"(n) :: \"volatile\");\n         // Can't actually reach this point, but rustc doesn't know that.\n     }\n+    // This return value is just here to generate some extra code for a return\n+    // value, making it easier for the test script to detect whether the\n+    // compiler deleted it.\n+    42\n }"}, {"sha": "de63809ab6638f19fc9df0dd41333d8052c78ef7", "filename": "src/test/run-make/intrinsic-unreachable/exit-unreachable.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Ftest%2Frun-make%2Fintrinsic-unreachable%2Fexit-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1410d5604042b739f02f9ec0f2a6c5125c797d52/src%2Ftest%2Frun-make%2Fintrinsic-unreachable%2Fexit-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fintrinsic-unreachable%2Fexit-unreachable.rs?ref=1410d5604042b739f02f9ec0f2a6c5125c797d52", "patch": "@@ -13,10 +13,15 @@\n \n use std::intrinsics;\n \n-pub fn exit(n: usize) -> ! {\n+#[allow(unreachable_code)]\n+pub fn exit(n: usize) -> i32 {\n     unsafe {\n         // Pretend this asm is an exit() syscall.\n         asm!(\"\" :: \"r\"(n) :: \"volatile\");\n         intrinsics::unreachable()\n     }\n+    // This return value is just here to generate some extra code for a return\n+    // value, making it easier for the test script to detect whether the\n+    // compiler deleted it.\n+    42\n }"}]}