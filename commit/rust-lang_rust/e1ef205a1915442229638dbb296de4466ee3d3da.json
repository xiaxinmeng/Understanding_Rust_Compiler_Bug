{"sha": "e1ef205a1915442229638dbb296de4466ee3d3da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZWYyMDVhMTkxNTQ0MjIyOTYzOGRiYjI5NmRlNDQ2NmVlM2QzZGE=", "commit": {"author": {"name": "gfreezy", "email": "gfreezy@gmail.com", "date": "2018-12-30T15:03:43Z"}, "committer": {"name": "gfreezy", "email": "gfreezy@gmail.com", "date": "2018-12-30T15:03:43Z"}, "message": "avoid allocating an unnecessary intermediate vector & not traverse multiple times", "tree": {"sha": "71c05d8052fbc2cc68161b2b52a54d5612c7fe02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71c05d8052fbc2cc68161b2b52a54d5612c7fe02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1ef205a1915442229638dbb296de4466ee3d3da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1ef205a1915442229638dbb296de4466ee3d3da", "html_url": "https://github.com/rust-lang/rust/commit/e1ef205a1915442229638dbb296de4466ee3d3da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1ef205a1915442229638dbb296de4466ee3d3da/comments", "author": {"login": "gfreezy", "id": 510012, "node_id": "MDQ6VXNlcjUxMDAxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/510012?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gfreezy", "html_url": "https://github.com/gfreezy", "followers_url": "https://api.github.com/users/gfreezy/followers", "following_url": "https://api.github.com/users/gfreezy/following{/other_user}", "gists_url": "https://api.github.com/users/gfreezy/gists{/gist_id}", "starred_url": "https://api.github.com/users/gfreezy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gfreezy/subscriptions", "organizations_url": "https://api.github.com/users/gfreezy/orgs", "repos_url": "https://api.github.com/users/gfreezy/repos", "events_url": "https://api.github.com/users/gfreezy/events{/privacy}", "received_events_url": "https://api.github.com/users/gfreezy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gfreezy", "id": 510012, "node_id": "MDQ6VXNlcjUxMDAxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/510012?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gfreezy", "html_url": "https://github.com/gfreezy", "followers_url": "https://api.github.com/users/gfreezy/followers", "following_url": "https://api.github.com/users/gfreezy/following{/other_user}", "gists_url": "https://api.github.com/users/gfreezy/gists{/gist_id}", "starred_url": "https://api.github.com/users/gfreezy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gfreezy/subscriptions", "organizations_url": "https://api.github.com/users/gfreezy/orgs", "repos_url": "https://api.github.com/users/gfreezy/repos", "events_url": "https://api.github.com/users/gfreezy/events{/privacy}", "received_events_url": "https://api.github.com/users/gfreezy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3520bf01dd4709ea1c9694f91cbb72d1eac3924", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3520bf01dd4709ea1c9694f91cbb72d1eac3924", "html_url": "https://github.com/rust-lang/rust/commit/a3520bf01dd4709ea1c9694f91cbb72d1eac3924"}], "stats": {"total": 134, "additions": 72, "deletions": 62}, "files": [{"sha": "1b336cfe2e85e39d07c4d1ef313ce78b619e4f4d", "filename": "crates/ra_editor/src/diagnostics.rs", "status": "modified", "additions": 72, "deletions": 62, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/e1ef205a1915442229638dbb296de4466ee3d3da/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1ef205a1915442229638dbb296de4466ee3d3da/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs?ref=e1ef205a1915442229638dbb296de4466ee3d3da", "patch": "@@ -7,6 +7,7 @@ use ra_syntax::{\n     SyntaxKind,\n     TextRange,\n };\n+use ra_syntax::SyntaxNodeRef;\n use ra_text_edit::{\n     TextEdit,\n     TextEditBuilder,\n@@ -37,44 +38,44 @@ pub fn diagnostics(file: &SourceFileNode) -> Vec<Diagnostic> {\n         })\n         .collect();\n \n-    errors.extend(check_unnecessary_braces_in_use_statement(file));\n-    errors.extend(check_struct_shorthand_initialization(file));\n+    for node in file.syntax().descendants() {\n+        check_unnecessary_braces_in_use_statement(&mut errors, node);\n+        check_struct_shorthand_initialization(&mut errors, node);\n+    }\n+\n     errors\n }\n \n-fn check_unnecessary_braces_in_use_statement(file: &SourceFileNode) -> Vec<Diagnostic> {\n-    let mut diagnostics = Vec::new();\n-    for use_tree_list in file\n-        .syntax()\n-        .descendants()\n-        .filter_map(ast::UseTreeList::cast)\n-    {\n-        if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n-            let range = use_tree_list.syntax().range();\n-            let edit =\n-                text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n-                    .unwrap_or_else(|| {\n-                        let to_replace = single_use_tree.syntax().text().to_string();\n-                        let mut edit_builder = TextEditBuilder::new();\n-                        edit_builder.delete(range);\n-                        edit_builder.insert(range.start(), to_replace);\n-                        edit_builder.finish()\n-                    });\n+fn check_unnecessary_braces_in_use_statement(\n+    acc: &mut Vec<Diagnostic>,\n+    node: SyntaxNodeRef,\n+) -> Option<()> {\n+    let use_tree_list = ast::UseTreeList::cast(node)?;\n+    if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n+        let range = use_tree_list.syntax().range();\n+        let edit =\n+            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n+                .unwrap_or_else(|| {\n+                    let to_replace = single_use_tree.syntax().text().to_string();\n+                    let mut edit_builder = TextEditBuilder::new();\n+                    edit_builder.delete(range);\n+                    edit_builder.insert(range.start(), to_replace);\n+                    edit_builder.finish()\n+                });\n \n-            diagnostics.push(Diagnostic {\n-                range,\n-                msg: format!(\"Unnecessary braces in use statement\"),\n-                severity: Severity::WeakWarning,\n-                fix: Some(LocalEdit {\n-                    label: \"Remove unnecessary braces\".to_string(),\n-                    edit,\n-                    cursor_position: None,\n-                }),\n-            })\n-        }\n+        acc.push(Diagnostic {\n+            range,\n+            msg: format!(\"Unnecessary braces in use statement\"),\n+            severity: Severity::WeakWarning,\n+            fix: Some(LocalEdit {\n+                label: \"Remove unnecessary braces\".to_string(),\n+                edit,\n+                cursor_position: None,\n+            }),\n+        });\n     }\n \n-    diagnostics\n+    Some(())\n }\n \n fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n@@ -99,36 +100,36 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n     None\n }\n \n-fn check_struct_shorthand_initialization(file: &SourceFileNode) -> Vec<Diagnostic> {\n-    let mut diagnostics = Vec::new();\n-    for struct_lit in file.syntax().descendants().filter_map(ast::StructLit::cast) {\n-        if let Some(named_field_list) = struct_lit.named_field_list() {\n-            for named_field in named_field_list.fields() {\n-                if let (Some(name_ref), Some(expr)) = (named_field.name_ref(), named_field.expr()) {\n-                    let field_name = name_ref.syntax().text().to_string();\n-                    let field_expr = expr.syntax().text().to_string();\n-                    if field_name == field_expr {\n-                        let mut edit_builder = TextEditBuilder::new();\n-                        edit_builder.delete(named_field.syntax().range());\n-                        edit_builder.insert(named_field.syntax().range().start(), field_name);\n-                        let edit = edit_builder.finish();\n+fn check_struct_shorthand_initialization(\n+    acc: &mut Vec<Diagnostic>,\n+    node: SyntaxNodeRef,\n+) -> Option<()> {\n+    let struct_lit = ast::StructLit::cast(node)?;\n+    let named_field_list = struct_lit.named_field_list()?;\n+    for named_field in named_field_list.fields() {\n+        if let (Some(name_ref), Some(expr)) = (named_field.name_ref(), named_field.expr()) {\n+            let field_name = name_ref.syntax().text().to_string();\n+            let field_expr = expr.syntax().text().to_string();\n+            if field_name == field_expr {\n+                let mut edit_builder = TextEditBuilder::new();\n+                edit_builder.delete(named_field.syntax().range());\n+                edit_builder.insert(named_field.syntax().range().start(), field_name);\n+                let edit = edit_builder.finish();\n \n-                        diagnostics.push(Diagnostic {\n-                            range: named_field.syntax().range(),\n-                            msg: format!(\"Shorthand struct initialization\"),\n-                            severity: Severity::WeakWarning,\n-                            fix: Some(LocalEdit {\n-                                label: \"use struct shorthand initialization\".to_string(),\n-                                edit,\n-                                cursor_position: None,\n-                            }),\n-                        });\n-                    }\n-                }\n+                acc.push(Diagnostic {\n+                    range: named_field.syntax().range(),\n+                    msg: format!(\"Shorthand struct initialization\"),\n+                    severity: Severity::WeakWarning,\n+                    fix: Some(LocalEdit {\n+                        label: \"use struct shorthand initialization\".to_string(),\n+                        edit,\n+                        cursor_position: None,\n+                    }),\n+                });\n             }\n         }\n     }\n-    diagnostics\n+    Some(())\n }\n \n #[cfg(test)]\n@@ -137,15 +138,24 @@ mod tests {\n \n     use super::*;\n \n-    fn check_not_applicable(code: &str, func: fn(file: &SourceFileNode) -> Vec<Diagnostic>) {\n+    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, SyntaxNodeRef) -> Option<()>;\n+\n+    fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n         let file = SourceFileNode::parse(code);\n-        let diagnostics = func(&file);\n+        let mut diagnostics = Vec::new();\n+        for node in file.syntax().descendants() {\n+            func(&mut diagnostics, node);\n+        }\n         assert!(diagnostics.is_empty());\n     }\n \n-    fn check_apply(before: &str, after: &str, func: fn(file: &SourceFileNode) -> Vec<Diagnostic>) {\n+    fn check_apply(before: &str, after: &str, func: DiagnosticChecker) {\n         let file = SourceFileNode::parse(before);\n-        let diagnostic = func(&file)\n+        let mut diagnostics = Vec::new();\n+        for node in file.syntax().descendants() {\n+            func(&mut diagnostics, node);\n+        }\n+        let diagnostic = diagnostics\n             .pop()\n             .unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n         let fix = diagnostic.fix.unwrap();"}]}