{"sha": "4b74dc167c90ed591a2b0e75ab5a28176427ea3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNzRkYzE2N2M5MGVkNTkxYTJiMGU3NWFiNWEyODE3NjQyN2VhM2Q=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-07-03T18:35:34Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-07-31T20:14:03Z"}, "message": "Rewrite the local_data implementation\n\nThis was motivated by a desire to remove allocation in the common\npattern of\n\n    let old = key.replace(None)\n    do_something();\n    key.replace(old);\n\nThis also switched the map representation from a Vec to a TreeMap. A Vec\nmay be reasonable if there's only a couple TLD keys, but a TreeMap\nprovides better behavior as the number of keys increases.\n\nLike the Vec, this TreeMap implementation does not shrink the container\nwhen a value is removed. Unlike Vec, this TreeMap implementation cannot\nreuse an empty node for a different key. Therefore any key that has been\ninserted into the TLD at least once will continue to take up space in\nthe Map until the task ends. The expectation is that the majority of\nkeys that are inserted into TLD will be expected to have a value for\nmost of the rest of the task's lifetime. If this assumption is wrong,\nthere are two reasonable ways to fix this that could be implemented in\nthe future:\n\n1. Provide an API call to either remove a specific key from the TLD and\n   destruct its node (e.g. `remove()`), or instead to explicitly clean\n   up all currently-empty nodes in the map (e.g. `compact()`). This is\n   simple, but requires the user to explicitly call it.\n2. Keep track of the number of empty nodes in the map and when the map\n   is mutated (via `replace()`), if the number of empty nodes passes\n   some threshold, compact it automatically. Alternatively, whenever a\n   new key is inserted that hasn't been used before, compact the map at\n   that point.\n\n---\n\nBenchmarks:\n\nI ran 3 benchmarks. tld_replace_none just replaces the tld key with None\nrepeatedly. tld_replace_some replaces it with Some repeatedly. And\ntld_replace_none_some simulates the common behavior of replacing with\nNone, then replacing with the previous value again (which was a Some).\n\nOld implementation:\n\n    test tld_replace_none      ... bench:        20 ns/iter (+/- 0)\n    test tld_replace_none_some ... bench:        77 ns/iter (+/- 4)\n    test tld_replace_some      ... bench:        57 ns/iter (+/- 2)\n\nNew implementation:\n\n    test tld_replace_none      ... bench:        11 ns/iter (+/- 0)\n    test tld_replace_none_some ... bench:        23 ns/iter (+/- 0)\n    test tld_replace_some      ... bench:        12 ns/iter (+/- 0)", "tree": {"sha": "36ce2c7f8115d23e69ed5801443f097f09dfa71b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36ce2c7f8115d23e69ed5801443f097f09dfa71b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b74dc167c90ed591a2b0e75ab5a28176427ea3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b74dc167c90ed591a2b0e75ab5a28176427ea3d", "html_url": "https://github.com/rust-lang/rust/commit/4b74dc167c90ed591a2b0e75ab5a28176427ea3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b74dc167c90ed591a2b0e75ab5a28176427ea3d/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3db5cf6f1da06c4aadc5395e69f81afcd25e7555", "url": "https://api.github.com/repos/rust-lang/rust/commits/3db5cf6f1da06c4aadc5395e69f81afcd25e7555", "html_url": "https://github.com/rust-lang/rust/commit/3db5cf6f1da06c4aadc5395e69f81afcd25e7555"}], "stats": {"total": 341, "additions": 229, "deletions": 112}, "files": [{"sha": "7ea16ccca1199d6b01ab3864a3e5201c5f1bebb0", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 229, "deletions": 112, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/4b74dc167c90ed591a2b0e75ab5a28176427ea3d/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b74dc167c90ed591a2b0e75ab5a28176427ea3d/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=4b74dc167c90ed591a2b0e75ab5a28176427ea3d", "patch": "@@ -40,12 +40,15 @@ assert_eq!(*key_vector.get().unwrap(), vec![4]);\n \n use core::prelude::*;\n \n-use alloc::boxed::Box;\n-use collections::MutableSeq;\n-use collections::vec::Vec;\n+use alloc::heap;\n+use collections::treemap::TreeMap;\n+use collections::{Map, MutableMap};\n+use core::cmp;\n use core::kinds::marker;\n use core::mem;\n-use core::raw;\n+use core::ptr;\n+use core::fmt;\n+use core::cell::UnsafeCell;\n \n use local::Local;\n use task::{Task, LocalStorage};\n@@ -66,33 +69,53 @@ pub type Key<T> = &'static KeyValue<T>;\n #[allow(missing_doc)]\n pub enum KeyValue<T> { Key }\n \n-#[doc(hidden)]\n-trait LocalData {}\n-impl<T: 'static> LocalData for T {}\n-\n-// The task-local-map stores all TLD information for the currently running task.\n-// It is stored as an owned pointer into the runtime, and it's only allocated\n-// when TLD is used for the first time. This map must be very carefully\n-// constructed because it has many mutable loans unsoundly handed out on it to\n-// the various invocations of TLD requests.\n+// The task-local-map stores all TLD information for the currently running\n+// task. It is stored as an owned pointer into the runtime, and it's only\n+// allocated when TLD is used for the first time.\n+//\n+// TLD values are boxed up, with a loan count stored in the box. The box is\n+// necessary given how TLD maps are constructed, but theoretically in the\n+// future this could be rewritten to statically construct TLD offsets at\n+// compile-time to get O(1) lookup. At that time, the box can be removed.\n //\n-// One of the most important operations is loaning a value via `get` to a\n-// caller. In doing so, the slot that the TLD entry is occupying cannot be\n-// invalidated because upon returning its loan state must be updated. Currently\n-// the TLD map is a vector, but this is possibly dangerous because the vector\n-// can be reallocated/moved when new values are pushed onto it.\n+// A very common usage pattern for TLD is to use replace(None) to extract a\n+// value from TLD, work with it, and then store it (or a derived/new value)\n+// back with replace(v). We take special care to reuse the allocation in this\n+// case for performance reasons.\n //\n-// This problem currently isn't solved in a very elegant way. Inside the `get`\n-// function, it internally \"invalidates\" all references after the loan is\n-// finished and looks up into the vector again. In theory this will prevent\n-// pointers from being moved under our feet so long as LLVM doesn't go too crazy\n-// with the optimizations.\n+// However, that does mean that if a value is replaced with None, the\n+// allocation will stay alive and the entry will stay in the TLD map until the\n+// task deallocates. This makes the assumption that every key inserted into a\n+// given task's TLD is going to be present for a majority of the rest of the\n+// task's lifetime, but that's a fairly safe assumption, and there's very\n+// little downside as long as it holds true for most keys.\n //\n-// n.b. If TLD is used heavily in future, this could be made more efficient with\n-//      a proper map.\n+// The Map type must be public in order to allow rustrt to see it.\n+//\n+// We'd like to use HashMap here, but it uses TLD in its construction (it uses\n+// the task-local rng). We could try to provide our own source of randomness,\n+// except it also lives in libstd (which is a client of us) so we can't even\n+// reference it. Instead, use TreeMap, which provides reasonable performance.\n #[doc(hidden)]\n-pub type Map = Vec<Option<(*const u8, TLDValue, uint)>>;\n-type TLDValue = Box<LocalData + Send>;\n+pub type Map = TreeMap<uint, TLDValue>;\n+#[unsafe_no_drop_flag]\n+struct TLDValue {\n+    // box_ptr is a pointer to TLDValueBox<T>. It can never be null.\n+    box_ptr: *mut (),\n+    // drop_fn is the function that knows how to drop the box_ptr.\n+    drop_fn: unsafe fn(p: *mut ())\n+}\n+\n+struct TLDValueBox<T> {\n+    // value is only initialized when refcount >= 1.\n+    value: T,\n+    // refcount of 0 means uninitialized value, 1 means initialized, 2+ means\n+    // borrowed.\n+    // NB: we use UnsafeCell instead of Cell because Ref should be allowed to\n+    // be Share. The only mutation occurs when a Ref is created or destroyed,\n+    // so there's no issue with &Ref being thread-safe.\n+    refcount: UnsafeCell<uint>\n+}\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n unsafe fn get_local_map<'a>() -> Option<&'a mut Map> {\n@@ -108,7 +131,7 @@ unsafe fn get_local_map<'a>() -> Option<&'a mut Map> {\n         // If this is the first time we've accessed TLD, perform similar\n         // actions to the oldsched way of doing things.\n         &LocalStorage(ref mut slot) => {\n-            *slot = Some(Vec::new());\n+            *slot = Some(TreeMap::new());\n             match *slot {\n                 Some(ref mut map_ptr) => { return Some(map_ptr) }\n                 None => fail!(\"unreachable code\"),\n@@ -117,21 +140,19 @@ unsafe fn get_local_map<'a>() -> Option<&'a mut Map> {\n     }\n }\n \n-fn key_to_key_value<T: 'static>(key: Key<T>) -> *const u8 {\n-    key as *const KeyValue<T> as *const u8\n-}\n-\n-/// An RAII immutable reference to a task-local value.\n+/// A RAII immutable reference to a task-local value.\n ///\n /// The task-local data can be accessed through this value, and when this\n /// structure is dropped it will return the borrow on the data.\n pub struct Ref<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n-    _ptr: &'static T,\n-    _key: Key<T>,\n-    _index: uint,\n-    _nosend: marker::NoSend,\n+    _inner: &'static TLDValueBox<T>,\n+    _marker: marker::NoSend\n+}\n+\n+fn key_to_key_value<T: 'static>(key: Key<T>) -> uint {\n+    key as *const _ as uint\n }\n \n impl<T: 'static> KeyValue<T> {\n@@ -142,9 +163,12 @@ impl<T: 'static> KeyValue<T> {\n     ///\n     /// # Failure\n     ///\n-    /// This function will fail if this key is present in TLD and currently on\n+    /// This function will fail if the key is present in TLD and currently on\n     /// loan with the `get` method.\n     ///\n+    /// It will also fail if there is no local task (because the current thread\n+    /// is not owned by the runtime).\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -161,58 +185,70 @@ impl<T: 'static> KeyValue<T> {\n         };\n         let keyval = key_to_key_value(self);\n \n-        // When the task-local map is destroyed, all the data needs to be\n-        // cleaned up. For this reason we can't do some clever tricks to store\n-        // '~T' as a '*c_void' or something like that. To solve the problem, we\n-        // cast everything to a trait (LocalData) which is then stored inside\n-        // the map.  Upon destruction of the map, all the objects will be\n-        // destroyed and the traits have enough information about them to\n-        // destroy themselves.\n-        //\n-        // Additionally, the type of the local data map must ascribe to Send, so\n-        // we do the transmute here to add the Send bound back on. This doesn't\n-        // actually matter because TLD will always own the data (until its moved\n-        // out) and we're not actually sending it to other schedulers or\n-        // anything.\n-        let newval = data.map(|d| {\n-            let d = box d as Box<LocalData>;\n-            let d: Box<LocalData + Send> = unsafe { mem::transmute(d) };\n-            (keyval, d, 0)\n-        });\n-\n-        let pos = match self.find(map) {\n-            Some((i, _, &0)) => Some(i),\n-            Some((_, _, _)) => fail!(\"TLD value cannot be replaced because it \\\n-                                      is already borrowed\"),\n-            None => map.iter().position(|entry| entry.is_none()),\n-        };\n-\n-        match pos {\n-            Some(i) => {\n-                mem::replace(map.get_mut(i), newval).map(|(_, data, _)| {\n-                    // Move `data` into transmute to get out the memory that it\n-                    // owns, we must free it manually later.\n-                    let t: raw::TraitObject = unsafe { mem::transmute(data) };\n-                    let alloc: Box<T> = unsafe { mem::transmute(t.data) };\n-\n-                    // Now that we own `alloc`, we can just move out of it as we\n-                    // would with any other data.\n-                    *alloc\n-                })\n+        // The following match takes a mutable borrow on the map. In order to insert\n+        // our data if the key isn't present, we need to let the match end first.\n+        let data = match (map.find_mut(&keyval), data) {\n+            (None, Some(data)) => {\n+                // The key doesn't exist and we need to insert it. To make borrowck\n+                // happy, return it up a scope and insert it there.\n+                data\n             }\n-            None => {\n-                map.push(newval);\n-                None\n+            (None, None) => {\n+                // The key doesn't exist and we're trying to replace it with nothing.\n+                // Do nothing.\n+                return None\n             }\n-        }\n+            (Some(slot), data) => {\n+                // We have a slot with a box.\n+                let value_box = slot.box_ptr as *mut TLDValueBox<T>;\n+                let refcount = unsafe { *(*value_box).refcount.get() };\n+                return match (refcount, data) {\n+                    (0, None) => {\n+                        // The current value is uninitialized and we have no new value.\n+                        // Do nothing.\n+                        None\n+                    }\n+                    (0, Some(newValue)) => {\n+                        // The current value is uninitialized and we're storing a new value.\n+                        unsafe {\n+                            ptr::write(&mut (*value_box).value, newValue);\n+                            *(*value_box).refcount.get() = 1;\n+                            None\n+                        }\n+                    }\n+                    (1, None) => {\n+                        // We have an initialized value and we're removing it.\n+                        unsafe {\n+                            let ret = ptr::read(&(*value_box).value);\n+                            *(*value_box).refcount.get() = 0;\n+                            Some(ret)\n+                        }\n+                    }\n+                    (1, Some(newValue)) => {\n+                        // We have an initialized value and we're replacing it.\n+                        let value_ref = unsafe { &mut (*value_box).value };\n+                        let ret = mem::replace(value_ref, newValue);\n+                        // Refcount is already 1, leave it as that.\n+                        Some(ret)\n+                    }\n+                    _ => {\n+                        // Refcount is 2+, which means we have a live borrow.\n+                        fail!(\"TLD value cannot be replaced because it is already borrowed\");\n+                    }\n+                }\n+            }\n+        };\n+        // If we've reached this point, we need to insert into the map.\n+        map.insert(keyval, TLDValue::new(data));\n+        None\n     }\n \n     /// Borrows a value from TLD.\n     ///\n-    /// If `None` is returned, then this key is not present in TLD. If `Some` is\n-    /// returned, then the returned data is a smart pointer representing a new\n-    /// loan on this TLD key. While on loan, this key cannot be altered via the\n-    /// `replace` method.\n+    /// If `None` is returned, then this key is not present in TLD. If `Some`\n+    /// is returned, then the returned data is a smart pointer representing a\n+    /// new loan on this TLD key. While on loan, this key cannot be altered via\n+    /// the `replace` method.\n     ///\n     /// # Example\n     ///\n@@ -229,47 +265,128 @@ impl<T: 'static> KeyValue<T> {\n             Some(map) => map,\n             None => return None,\n         };\n+        let keyval = key_to_key_value(self);\n \n-        self.find(map).map(|(pos, data, loan)| {\n-            *loan += 1;\n-\n-            // data was created with `~T as ~LocalData`, so we extract\n-            // pointer part of the trait, (as ~T), and then use\n-            // compiler coercions to achieve a '&' pointer.\n-            let ptr = unsafe {\n-                let data = data as *const Box<LocalData + Send>\n-                                as *const raw::TraitObject;\n-                &mut *((*data).data as *mut T)\n-            };\n-            Ref { _ptr: ptr, _index: pos, _nosend: marker::NoSend, _key: self }\n-        })\n-    }\n-\n-    fn find<'a>(&'static self,\n-                map: &'a mut Map) -> Option<(uint, &'a TLDValue, &'a mut uint)>{\n-        let key_value = key_to_key_value(self);\n-        map.mut_iter().enumerate().filter_map(|(i, entry)| {\n-            match *entry {\n-                Some((k, ref data, ref mut loan)) if k == key_value => {\n-                    Some((i, data, loan))\n+        match map.find(&keyval) {\n+            Some(slot) => {\n+                let value_box = slot.box_ptr as *mut TLDValueBox<T>;\n+                if unsafe { *(*value_box).refcount.get() } >= 1 {\n+                    unsafe {\n+                        *(*value_box).refcount.get() += 1;\n+                        Some(Ref {\n+                            _inner: &*value_box,\n+                            _marker: marker::NoSend\n+                        })\n+                    }\n+                } else {\n+                    None\n                 }\n-                _ => None\n             }\n-        }).next()\n+            None => None\n+        }\n     }\n }\n \n impl<T: 'static> Deref<T> for Ref<T> {\n-    fn deref<'a>(&'a self) -> &'a T { self._ptr }\n+    #[inline(always)]\n+    fn deref<'a>(&'a self) -> &'a T {\n+        &self._inner.value\n+    }\n+}\n+\n+impl<T: 'static + fmt::Show> fmt::Show for Ref<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n+\n+impl<T: cmp::PartialEq + 'static> cmp::PartialEq for Ref<T> {\n+    fn eq(&self, other: &Ref<T>) -> bool {\n+        (**self).eq(&**other)\n+    }\n+    fn ne(&self, other: &Ref<T>) -> bool {\n+        (**self).ne(&**other)\n+    }\n+}\n+\n+impl<T: cmp::Eq + 'static> cmp::Eq for Ref<T> {}\n+\n+impl<T: cmp::PartialOrd + 'static> cmp::PartialOrd for Ref<T> {\n+    fn partial_cmp(&self, other: &Ref<T>) -> Option<cmp::Ordering> {\n+        (**self).partial_cmp(&**other)\n+    }\n+    fn lt(&self, other: &Ref<T>) -> bool { (**self).lt(&**other) }\n+    fn le(&self, other: &Ref<T>) -> bool { (**self).le(&**other) }\n+    fn gt(&self, other: &Ref<T>) -> bool { (**self).gt(&**other) }\n+    fn ge(&self, other: &Ref<T>) -> bool { (**self).ge(&**other) }\n+}\n+\n+impl<T: cmp::Ord + 'static> cmp::Ord for Ref<T> {\n+    fn cmp(&self, other: &Ref<T>) -> cmp::Ordering {\n+        (**self).cmp(&**other)\n+    }\n }\n \n #[unsafe_destructor]\n impl<T: 'static> Drop for Ref<T> {\n     fn drop(&mut self) {\n-        let map = unsafe { get_local_map().unwrap() };\n+        unsafe {\n+            *self._inner.refcount.get() -= 1;\n+        }\n+    }\n+}\n \n-        let (_, _, ref mut loan) = *map.get_mut(self._index).get_mut_ref();\n-        *loan -= 1;\n+impl TLDValue {\n+    fn new<T>(value: T) -> TLDValue {\n+        let box_ptr = unsafe {\n+            let allocation = heap::allocate(mem::size_of::<TLDValueBox<T>>(),\n+                                            mem::min_align_of::<TLDValueBox<T>>());\n+            let value_box = allocation as *mut TLDValueBox<T>;\n+            ptr::write(value_box, TLDValueBox {\n+                value: value,\n+                refcount: UnsafeCell::new(1)\n+            });\n+            value_box as *mut ()\n+        };\n+        // Destruction of TLDValue needs to know how to properly deallocate the TLDValueBox,\n+        // so we need our own custom destructor function.\n+        unsafe fn d<T>(p: *mut ()) {\n+            let value_box = p as *mut TLDValueBox<T>;\n+            debug_assert!(*(*value_box).refcount.get() < 2, \"TLDValue destructed while borrowed\");\n+            // use a RAII type here to ensure we always deallocate even if we fail while\n+            // running the destructor for the value.\n+            struct Guard<T> {\n+                p: *mut TLDValueBox<T>\n+            }\n+            #[unsafe_destructor]\n+            impl<T> Drop for Guard<T> {\n+                fn drop(&mut self) {\n+                    let size = mem::size_of::<TLDValueBox<T>>();\n+                    let align = mem::align_of::<TLDValueBox<T>>();\n+                    unsafe { heap::deallocate(self.p as *mut u8, size, align); }\n+                }\n+            }\n+            let _guard = Guard::<T> { p: value_box };\n+            if *(*value_box).refcount.get() != 0 {\n+                // the contained value is valid; drop it\n+                ptr::read(&(*value_box).value);\n+            }\n+            // the box will be deallocated by the guard\n+        }\n+        TLDValue {\n+            box_ptr: box_ptr,\n+            drop_fn: d::<T>\n+        }\n+    }\n+}\n+\n+\n+impl Drop for TLDValue {\n+    fn drop(&mut self) {\n+        // box_ptr should always be non-null. Check it anyway just to be thorough\n+        if !self.box_ptr.is_null() {\n+            unsafe { (self.drop_fn)(self.box_ptr) }\n+        }\n     }\n }\n "}]}