{"sha": "0ad3d7938f18dd12df6b66a12656558b166c8d7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZDNkNzkzOGYxOGRkMTJkZjZiNjZhMTI2NTY1NThiMTY2YzhkN2Y=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-09T19:14:32Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-13T19:04:52Z"}, "message": "migrate body span to {parent,text_range}\n\nThis simplifies api as we are not duplicating code from syntax crate", "tree": {"sha": "dc03d66cad7a905d2893dd2c57245dfa68d11dd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc03d66cad7a905d2893dd2c57245dfa68d11dd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ad3d7938f18dd12df6b66a12656558b166c8d7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad3d7938f18dd12df6b66a12656558b166c8d7f", "html_url": "https://github.com/rust-lang/rust/commit/0ad3d7938f18dd12df6b66a12656558b166c8d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ad3d7938f18dd12df6b66a12656558b166c8d7f/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "205e72f34d26898779c8ab11c8500e74fd8ce28b", "url": "https://api.github.com/repos/rust-lang/rust/commits/205e72f34d26898779c8ab11c8500e74fd8ce28b", "html_url": "https://github.com/rust-lang/rust/commit/205e72f34d26898779c8ab11c8500e74fd8ce28b"}], "stats": {"total": 246, "additions": 112, "deletions": 134}, "files": [{"sha": "4bddd4eec81b4521bba2408f4ab132491b259dee", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 112, "deletions": 134, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/0ad3d7938f18dd12df6b66a12656558b166c8d7f/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad3d7938f18dd12df6b66a12656558b166c8d7f/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=0ad3d7938f18dd12df6b66a12656558b166c8d7f", "patch": "@@ -1,3 +1,6 @@\n+use std::{fmt, iter};\n+\n+use ast::make;\n use either::Either;\n use hir::{HirDisplay, Local};\n use ide_db::{\n@@ -82,10 +85,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         return None;\n     }\n \n-    let target_range = match &body {\n-        FunctionBody::Expr(expr) => expr.syntax().text_range(),\n-        FunctionBody::Span { .. } => ctx.frange.range,\n-    };\n+    let target_range = body.text_range();\n \n     acc.add(\n         AssistId(\"extract_function\", crate::AssistKind::RefactorExtract),\n@@ -209,7 +209,7 @@ impl RetType {\n #[derive(Debug)]\n enum FunctionBody {\n     Expr(ast::Expr),\n-    Span { elements: Vec<SyntaxElement>, leading_indent: String },\n+    Span { parent: ast::BlockExpr, text_range: TextRange },\n }\n \n impl FunctionBody {\n@@ -226,81 +226,48 @@ impl FunctionBody {\n         }\n     }\n \n-    fn from_range(node: &SyntaxNode, range: TextRange) -> Option<FunctionBody> {\n-        let mut first = node.token_at_offset(range.start()).left_biased()?;\n-        let last = node.token_at_offset(range.end()).right_biased()?;\n-\n-        let mut leading_indent = String::new();\n-\n-        let leading_trivia = first\n-            .siblings_with_tokens(Direction::Prev)\n-            .skip(1)\n-            .take_while(|e| e.kind() == SyntaxKind::WHITESPACE && e.as_token().is_some());\n-\n-        for e in leading_trivia {\n-            let token = e.as_token().unwrap();\n-            let text = token.text();\n-            match text.rfind('\\n') {\n-                Some(pos) => {\n-                    leading_indent = text[pos..].to_owned();\n-                    break;\n-                }\n-                None => first = token.clone(),\n-            }\n-        }\n-\n-        let mut elements: Vec<_> = first\n-            .siblings_with_tokens(Direction::Next)\n-            .take_while(|e| e.as_token() != Some(&last))\n-            .collect();\n-\n-        if !(last.kind() == SyntaxKind::WHITESPACE && last.text().lines().count() <= 2) {\n-            elements.push(last.into());\n-        }\n-\n-        Some(FunctionBody::Span { elements, leading_indent })\n+    fn from_range(node: SyntaxNode, text_range: TextRange) -> Option<FunctionBody> {\n+        let block = ast::BlockExpr::cast(node)?;\n+        Some(Self::Span { parent: block, text_range })\n     }\n \n     fn indent_level(&self) -> IndentLevel {\n         match &self {\n             FunctionBody::Expr(expr) => IndentLevel::from_node(expr.syntax()),\n-            FunctionBody::Span { elements, .. } => elements\n-                .iter()\n-                .filter_map(SyntaxElement::as_node)\n-                .map(IndentLevel::from_node)\n-                .min_by_key(|level| level.0)\n-                .expect(\"body must contain at least one node\"),\n+            FunctionBody::Span { parent, .. } => IndentLevel::from_node(parent.syntax()),\n         }\n     }\n \n     fn tail_expr(&self) -> Option<ast::Expr> {\n         match &self {\n             FunctionBody::Expr(expr) => Some(expr.clone()),\n-            FunctionBody::Span { elements, .. } => {\n-                elements.iter().rev().find_map(|e| e.as_node()).cloned().and_then(ast::Expr::cast)\n+            FunctionBody::Span { parent, text_range } => {\n+                let tail_expr = parent.tail_expr()?;\n+                if text_range.contains_range(tail_expr.syntax().text_range()) {\n+                    Some(tail_expr)\n+                } else {\n+                    None\n+                }\n             }\n         }\n     }\n \n     fn descendants(&self) -> impl Iterator<Item = SyntaxNode> + '_ {\n         match self {\n             FunctionBody::Expr(expr) => Either::Right(expr.syntax().descendants()),\n-            FunctionBody::Span { elements, .. } => Either::Left(\n-                elements\n-                    .iter()\n-                    .filter_map(SyntaxElement::as_node)\n-                    .flat_map(SyntaxNode::descendants),\n+            FunctionBody::Span { parent, text_range } => Either::Left(\n+                parent\n+                    .syntax()\n+                    .descendants()\n+                    .filter(move |it| text_range.contains_range(it.text_range())),\n             ),\n         }\n     }\n \n     fn text_range(&self) -> TextRange {\n         match self {\n             FunctionBody::Expr(expr) => expr.syntax().text_range(),\n-            FunctionBody::Span { elements, .. } => TextRange::new(\n-                elements.first().unwrap().text_range().start(),\n-                elements.last().unwrap().text_range().end(),\n-            ),\n+            FunctionBody::Span { parent: _, text_range } => *text_range,\n         }\n     }\n \n@@ -321,30 +288,27 @@ impl HasTokenAtOffset for FunctionBody {\n     fn token_at_offset(&self, offset: TextSize) -> TokenAtOffset<SyntaxToken> {\n         match self {\n             FunctionBody::Expr(expr) => expr.syntax().token_at_offset(offset),\n-            FunctionBody::Span { elements, .. } => {\n-                stdx::always!(self.text_range().contains(offset));\n-                let mut iter = elements\n-                    .iter()\n-                    .filter(|element| element.text_range().contains_inclusive(offset));\n-                let element1 = iter.next().expect(\"offset does not fall into body\");\n-                let element2 = iter.next();\n-                stdx::always!(iter.next().is_none(), \"> 2 tokens at offset\");\n-                let t1 = match element1 {\n-                    syntax::NodeOrToken::Node(node) => node.token_at_offset(offset),\n-                    syntax::NodeOrToken::Token(token) => TokenAtOffset::Single(token.clone()),\n-                };\n-                let t2 = element2.map(|e| match e {\n-                    syntax::NodeOrToken::Node(node) => node.token_at_offset(offset),\n-                    syntax::NodeOrToken::Token(token) => TokenAtOffset::Single(token.clone()),\n-                });\n-\n-                match t2 {\n-                    Some(t2) => match (t1.clone().right_biased(), t2.clone().left_biased()) {\n-                        (Some(e1), Some(e2)) => TokenAtOffset::Between(e1, e2),\n-                        (Some(_), None) => t1,\n-                        (None, _) => t2,\n-                    },\n-                    None => t1,\n+            FunctionBody::Span { parent, text_range } => {\n+                match parent.syntax().token_at_offset(offset) {\n+                    TokenAtOffset::None => TokenAtOffset::None,\n+                    TokenAtOffset::Single(t) => {\n+                        if text_range.contains_range(t.text_range()) {\n+                            TokenAtOffset::Single(t)\n+                        } else {\n+                            TokenAtOffset::None\n+                        }\n+                    }\n+                    TokenAtOffset::Between(a, b) => {\n+                        match (\n+                            text_range.contains_range(a.text_range()),\n+                            text_range.contains_range(b.text_range()),\n+                        ) {\n+                            (true, true) => TokenAtOffset::Between(a, b),\n+                            (true, false) => TokenAtOffset::Single(a),\n+                            (false, true) => TokenAtOffset::Single(b),\n+                            (false, false) => TokenAtOffset::None,\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -389,7 +353,7 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n     // we have selected a few statements in a block\n     // so covering_element returns the whole block\n     if node.kind() == BLOCK_EXPR {\n-        let body = FunctionBody::from_range(&node, selection_range);\n+        let body = FunctionBody::from_range(node.clone(), selection_range);\n         if body.is_some() {\n             return body;\n         }\n@@ -400,7 +364,7 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n     // so we try to expand covering_element to parent and repeat the previous\n     if let Some(parent) = node.parent() {\n         if parent.kind() == BLOCK_EXPR {\n-            let body = FunctionBody::from_range(&parent, selection_range);\n+            let body = FunctionBody::from_range(parent, selection_range);\n             if body.is_some() {\n                 return body;\n             }\n@@ -642,13 +606,9 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n \n /// checks if local variable is used after(outside of) body\n fn var_outlives_body(ctx: &AssistContext, body: &FunctionBody, var: &Local) -> bool {\n-    let usages = Definition::Local(*var)\n-        .usages(&ctx.sema)\n-        .in_scope(SearchScope::single_file(ctx.frange.file_id))\n-        .all();\n-    let mut usages = usages.iter().flat_map(|(_, rs)| rs.iter());\n-\n-    usages.any(|reference| body.preceedes_range(reference.range))\n+    let usages = LocalUsages::find(ctx, *var);\n+    let has_usages = usages.iter().any(|reference| body.preceedes_range(reference.range));\n+    has_usages\n }\n \n fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n@@ -675,10 +635,7 @@ enum Anchor {\n fn scope_for_fn_insertion(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNode> {\n     match body {\n         FunctionBody::Expr(e) => scope_for_fn_insertion_node(e.syntax(), anchor),\n-        FunctionBody::Span { elements, .. } => {\n-            let node = elements.iter().find_map(|e| e.as_node())?;\n-            scope_for_fn_insertion_node(&node, anchor)\n-        }\n+        FunctionBody::Span { parent, .. } => scope_for_fn_insertion_node(parent.syntax(), anchor),\n     }\n }\n \n@@ -768,9 +725,8 @@ fn format_function(\n     format_function_param_list_to(&mut fn_def, ctx, module, fun);\n     fn_def.push(')');\n     format_function_ret_to(&mut fn_def, ctx, module, fun);\n-    fn_def.push_str(\" {\");\n+    fn_def.push(' ');\n     format_function_body_to(&mut fn_def, ctx, old_indent, new_indent, fun);\n-    format_to!(fn_def, \"{}}}\", new_indent);\n \n     fn_def\n }\n@@ -836,60 +792,82 @@ fn format_function_body_to(\n     new_indent: IndentLevel,\n     fun: &Function,\n ) {\n-    match &fun.body {\n+    let block = match &fun.body {\n         FunctionBody::Expr(expr) => {\n-            fn_def.push('\\n');\n-            let expr = expr.dedent(old_indent).indent(new_indent + 1);\n-            let expr = fix_param_usages(ctx, &fun.params, expr.syntax());\n-            format_to!(fn_def, \"{}{}\", new_indent + 1, expr);\n-            fn_def.push('\\n');\n+            let expr = rewrite_body_segment(ctx, &fun.params, expr.syntax());\n+            let expr = ast::Expr::cast(expr).unwrap();\n+            let expr = expr.dedent(old_indent).indent(IndentLevel(1));\n+            let block = make::block_expr(Vec::new(), Some(expr));\n+            block.indent(new_indent)\n         }\n-        FunctionBody::Span { elements, leading_indent } => {\n-            format_to!(fn_def, \"{}\", leading_indent);\n-            let new_indent_str = format!(\"\\n{}\", new_indent + 1);\n-            for mut element in elements {\n-                let new_ws;\n-                if let Some(ws) = element.as_token().cloned().and_then(ast::Whitespace::cast) {\n-                    let text = ws.syntax().text();\n-                    if text.contains('\\n') {\n-                        let new_text = text.replace(&format!(\"\\n{}\", old_indent), &new_indent_str);\n-                        new_ws = ast::make::tokens::whitespace(&new_text).into();\n-                        element = &new_ws;\n-                    }\n-                }\n+        FunctionBody::Span { parent, text_range } => {\n+            let mut elements: Vec<_> = parent\n+                .syntax()\n+                .children()\n+                .filter(|it| text_range.contains_range(it.text_range()))\n+                .map(|it| rewrite_body_segment(ctx, &fun.params, &it))\n+                .collect();\n+\n+            let mut tail_expr = match elements.pop() {\n+                Some(node) => ast::Expr::cast(node.clone()).or_else(|| {\n+                    elements.push(node);\n+                    None\n+                }),\n+                None => None,\n+            };\n \n-                match element {\n-                    syntax::NodeOrToken::Node(node) => {\n-                        format_to!(fn_def, \"{}\", fix_param_usages(ctx, &fun.params, node));\n-                    }\n-                    syntax::NodeOrToken::Token(token) => {\n-                        format_to!(fn_def, \"{}\", token);\n+            if tail_expr.is_none() {\n+                match fun.vars_defined_in_body_and_outlive.as_slice() {\n+                    [] => {}\n+                    [var] => {\n+                        tail_expr = Some(path_expr_from_local(ctx, *var));\n+                    },\n+                    vars => {\n+                        let exprs = vars.iter()\n+                            .map(|var| path_expr_from_local(ctx, *var));\n+                        let expr = make::expr_tuple(exprs);\n+                        tail_expr = Some(expr);\n                     }\n                 }\n             }\n-            if !fn_def.ends_with('\\n') {\n-                fn_def.push('\\n');\n-            }\n+\n+            let elements = elements.into_iter().filter_map(|node| match ast::Stmt::cast(node) {\n+                Some(stmt) => Some(stmt),\n+                None => {\n+                    stdx::never!(\"block contains non-statement\");\n+                    None\n+                }\n+            });\n+\n+\n+            let block = make::block_expr(elements, tail_expr);\n+            block.dedent(old_indent).indent(new_indent)\n         }\n-    }\n+    };\n \n-    match fun.vars_defined_in_body_and_outlive.as_slice() {\n-        [] => {}\n-        [var] => format_to!(fn_def, \"{}{}\\n\", new_indent + 1, var.name(ctx.db()).unwrap()),\n-        [v0, vs @ ..] => {\n-            format_to!(fn_def, \"{}({}\", new_indent + 1, v0.name(ctx.db()).unwrap());\n-            for var in vs {\n-                format_to!(fn_def, \", {}\", var.name(ctx.db()).unwrap());\n-            }\n-            fn_def.push_str(\")\\n\");\n         }\n-    }\n+    \n+    format_to!(fn_def, \"{}\", block);\n+}\n+\n+fn path_expr_from_local(ctx: &AssistContext, var: Local) -> ast::Expr {\n+    let name = var.name(ctx.db()).unwrap().to_string();\n+    let path = make::path_unqualified(make::path_segment(make::name_ref(&name)));\n+    make::expr_path(path)\n }\n \n fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> String {\n     ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"()\".to_string())\n }\n \n+fn rewrite_body_segment(\n+    ctx: &AssistContext,\n+    params: &[Param],\n+    syntax: &SyntaxNode,\n+) -> SyntaxNode {\n+    fix_param_usages(ctx, params, syntax)\n+}\n+\n /// change all usages to account for added `&`/`&mut` for some params\n fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n     let mut rewriter = SyntaxRewriter::default();\n@@ -919,7 +897,7 @@ fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode)\n                     rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n                 }\n                 Some(_) | None => {\n-                    rewriter.replace_ast(&path, &ast::make::expr_prefix(T![*], path.clone()));\n+                    rewriter.replace_ast(&path, &make::expr_prefix(T![*], path.clone()));\n                 }\n             };\n         }"}]}