{"sha": "0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZWEwZjZlOTA3ZmY4YzhhMjVhMTAwMDRiZWRlN2I0NjIxYjUwYWE=", "commit": {"author": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-06-28T17:38:28Z"}, "committer": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-07-25T02:18:16Z"}, "message": "Allow writing types which \"can't\" be instantiated.\n\nThe borrow checker doesn't allow constructing such a type at runtime\nusing safe code, but there isn't any reason to ban them in the type checker.\n\nIncluded in this commit is an example of a neat static doubly-linked list.\n\nFeature-gated under the static_recursion gate to be on the safe side, but\nthere are unlikely to be any reasons this shouldn't be turned on by\ndefault.", "tree": {"sha": "4e7dd59605a8022a06728ccb58bd0d3001265209", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e7dd59605a8022a06728ccb58bd0d3001265209"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "html_url": "https://github.com/rust-lang/rust/commit/0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/comments", "author": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "742e1242d9b568edfef51d968f4f81787534e475", "url": "https://api.github.com/repos/rust-lang/rust/commits/742e1242d9b568edfef51d968f4f81787534e475", "html_url": "https://github.com/rust-lang/rust/commit/742e1242d9b568edfef51d968f4f81787534e475"}], "stats": {"total": 118, "additions": 72, "deletions": 46}, "files": [{"sha": "082dafc72bc6ffb8cf6a9752846c78ca268ca177", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "patch": "@@ -115,6 +115,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::ast::{self, DefId, Visibility};\n use syntax::ast_util::{self, local_def};\n use syntax::codemap::{self, Span};\n+use syntax::feature_gate::emit_feature_err;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::print::pprust;\n@@ -4009,9 +4010,7 @@ fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n-/// pointer, which would mean their size is unbounded. This is different from\n-/// the question of whether a type can be instantiated. See the definition of\n-/// `check_instantiable`.\n+/// pointer, which would mean their size is unbounded.\n pub fn check_representable(tcx: &ty::ctxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n@@ -4036,31 +4035,19 @@ pub fn check_representable(tcx: &ty::ctxt,\n     return true\n }\n \n-/// Checks whether a type can be created without an instance of itself.\n-/// This is similar but different from the question of whether a type\n-/// can be represented.  For example, the following type:\n-///\n-///     enum foo { None, Some(foo) }\n-///\n-/// is instantiable but is not representable.  Similarly, the type\n-///\n-///     enum foo { Some(@foo) }\n-///\n-/// is representable, but not instantiable.\n+/// Checks whether a type can be constructed at runtime without\n+/// an existing instance of that type.\n pub fn check_instantiable(tcx: &ty::ctxt,\n                           sp: Span,\n-                          item_id: ast::NodeId)\n-                          -> bool {\n+                          item_id: ast::NodeId) {\n     let item_ty = tcx.node_id_to_type(item_id);\n-    if !item_ty.is_instantiable(tcx) {\n-        span_err!(tcx.sess, sp, E0073,\n-            \"this type cannot be instantiated without an \\\n-             instance of itself\");\n-        fileline_help!(tcx.sess, sp, \"consider using `Option<{:?}>`\",\n-             item_ty);\n-        false\n-    } else {\n-        true\n+    if !item_ty.is_instantiable(tcx) &&\n+            !tcx.sess.features.borrow().static_recursion {\n+        emit_feature_err(&tcx.sess.parse_sess.span_diagnostic,\n+                         \"static_recursion\",\n+                         sp,\n+                         \"this type cannot be instantiated at runtime \\\n+                          without an instance of itself\");\n     }\n }\n \n@@ -4199,11 +4186,6 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     do_check(ccx, vs, id, hint);\n \n     check_representable(ccx.tcx, sp, id, \"enum\");\n-\n-    // Check that it is possible to instantiate this enum:\n-    //\n-    // This *sounds* like the same that as representable, but it's\n-    // not.  See def'n of `check_instantiable()` for details.\n     check_instantiable(ccx.tcx, sp, id);\n }\n "}, {"sha": "2f1fa6780ab0c969a3ff8dd5acd4a7f23f383f3d", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(static_recursion)]\n+\n enum foo { foo_(bar) }\n struct bar { x: bar }\n //~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n-//~^^ ERROR this type cannot be instantiated without an instance of itself\n \n fn main() {\n }"}, {"sha": "de0389248408e4cc7b57bf359a98077dc9ace4ae", "filename": "src/test/compile-fail/static-recursion-gate-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Fcompile-fail%2Fstatic-recursion-gate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Fcompile-fail%2Fstatic-recursion-gate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-recursion-gate-2.rs?ref=0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Z(&'static Z);\n+//~^ ERROR this type cannot be instantiated\n+\n+pub fn main() {}"}, {"sha": "b972934d0604cde3980302472e87e05f4f01ea60", "filename": "src/test/compile-fail/type-recursive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs?ref=0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:this type cannot be instantiated\n+// error-pattern:illegal recursive struct type\n struct t1 {\n     foo: isize,\n     foolish: t1"}, {"sha": "aa9a7afc37f8a05e8ffda790256b8b72b2e58890", "filename": "src/test/run-pass/issue-2063-resource.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Frun-pass%2Fissue-2063-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Frun-pass%2Fissue-2063-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2063-resource.rs?ref=0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "patch": "@@ -8,15 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(static_recursion)]\n \n // test that autoderef of a type like this does not\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed.\n-struct S { //~ ERROR this type cannot be instantiated\n+\n+struct S {\n   x: X,\n   to_str: (),\n }\n \n-struct X(Box<S>); //~ ERROR this type cannot be instantiated\n+struct X(Box<S>);\n \n fn main() {}", "previous_filename": "src/test/compile-fail/issue-2063-resource.rs"}, {"sha": "48da7ecc5089dd8b98949c3f0ad6d9c0d5bdeb45", "filename": "src/test/run-pass/issue-2063.rs", "status": "renamed", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Frun-pass%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Frun-pass%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2063.rs?ref=0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "patch": "@@ -8,28 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(static_recursion)]\n+\n // test that autoderef of a type like this does not\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed.\n \n-struct t(Box<t>); //~ ERROR this type cannot be instantiated\n+struct T(Box<T>);\n \n-trait to_str_2 {\n-    fn my_to_string() -> String;\n+trait ToStr2 {\n+    fn my_to_string(&self) -> String;\n }\n \n-// I use an impl here because it will cause\n-// the compiler to attempt autoderef and then\n-// try to resolve the method.\n-impl to_str_2 for t {\n-    fn my_to_string() -> String { \"t\".to_string() }\n+impl ToStr2 for T {\n+    fn my_to_string(&self) -> String { \"t\".to_string() }\n }\n \n-fn new_t(x: t) {\n+#[allow(dead_code)]\n+fn new_t(x: T) {\n     x.my_to_string();\n-    // (there used to be an error emitted right here as well. It was\n-    // spurious, at best; if `t` did exist as a type, it clearly would\n-    // have an impl of the `to_str_2` trait.)\n }\n \n fn main() {", "previous_filename": "src/test/compile-fail/issue-2063.rs"}, {"sha": "f3db102ea5a49ae7579c18671e5772a263217621", "filename": "src/test/run-pass/static-recursive.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eea0f6e907ff8c8a25a10004bede7b4621b50aa/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs?ref=0eea0f6e907ff8c8a25a10004bede7b4621b50aa", "patch": "@@ -12,6 +12,36 @@\n \n static mut S: *const u8 = unsafe { &S as *const *const u8 as *const u8 };\n \n+struct StaticDoubleLinked {\n+    prev: &'static StaticDoubleLinked,\n+    next: &'static StaticDoubleLinked,\n+    data: i32,\n+    head: bool\n+}\n+\n+static L1: StaticDoubleLinked = StaticDoubleLinked{prev: &L3, next: &L2, data: 1, head: true};\n+static L2: StaticDoubleLinked = StaticDoubleLinked{prev: &L1, next: &L3, data: 2, head: false};\n+static L3: StaticDoubleLinked = StaticDoubleLinked{prev: &L2, next: &L1, data: 3, head: false};\n+\n+\n pub fn main() {\n     unsafe { assert_eq!(S, *(S as *const *const u8)); }\n+\n+    let mut test_vec = Vec::new();\n+    let mut cur = &L1;\n+    loop {\n+        test_vec.push(cur.data);\n+        cur = cur.next;\n+        if cur.head { break }\n+    }\n+    assert_eq!(&test_vec, &[1,2,3]);\n+\n+    let mut test_vec = Vec::new();\n+    let mut cur = &L1;\n+    loop {\n+        cur = cur.prev;\n+        test_vec.push(cur.data);\n+        if cur.head { break }\n+    }\n+    assert_eq!(&test_vec, &[3,2,1]);\n }"}]}