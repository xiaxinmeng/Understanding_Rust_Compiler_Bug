{"sha": "a2d5d093e03bcacb7622d6616143c7dbfd2602c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZDVkMDkzZTAzYmNhY2I3NjIyZDY2MTYxNDNjN2RiZmQyNjAyYzE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-15T10:26:47Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-15T10:28:25Z"}, "message": "debuginfo: Some namespace-related cleanup.", "tree": {"sha": "22fc9c7b59f05330f6153f04d14da9d4c38bd832", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22fc9c7b59f05330f6153f04d14da9d4c38bd832"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2d5d093e03bcacb7622d6616143c7dbfd2602c1", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2d5d093e03bcacb7622d6616143c7dbfd2602c1", "html_url": "https://github.com/rust-lang/rust/commit/a2d5d093e03bcacb7622d6616143c7dbfd2602c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2d5d093e03bcacb7622d6616143c7dbfd2602c1/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3ffbc3151a8676efe1ae8ac1ccf353f76c52549", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ffbc3151a8676efe1ae8ac1ccf353f76c52549", "html_url": "https://github.com/rust-lang/rust/commit/c3ffbc3151a8676efe1ae8ac1ccf353f76c52549"}], "stats": {"total": 134, "additions": 66, "deletions": 68}, "files": [{"sha": "272ce49a3779afaf4be0d3bc7b3a81c65cbc2b00", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 66, "deletions": 68, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/a2d5d093e03bcacb7622d6616143c7dbfd2602c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d5d093e03bcacb7622d6616143c7dbfd2602c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a2d5d093e03bcacb7622d6616143c7dbfd2602c1", "patch": "@@ -550,7 +550,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n                 ast::item_fn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n-                    (item.ident, fn_decl, generics, Some(top_level_block), item.span)\n+                    (item.ident, fn_decl, generics, top_level_block, item.span)\n                 }\n                 _ => {\n                     cx.sess.span_bug(item.span,\n@@ -569,7 +569,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n             },\n             _,\n             _) => {\n-            (ident, fn_decl, generics, Some(top_level_block), span)\n+            (ident, fn_decl, generics, top_level_block, span)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n@@ -580,7 +580,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                         // This is not quite right. It should actually inherit the generics of the\n                         // enclosing function.\n                         &empty_generics,\n-                        Some(top_level_block),\n+                        top_level_block,\n                         expr.span)\n                 }\n                 _ => cx.sess.span_bug(expr.span,\n@@ -599,7 +599,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                 }),\n             _,\n             _) => {\n-            (ident, fn_decl, generics, Some(top_level_block), span)\n+            (ident, fn_decl, generics, top_level_block, span)\n         }\n         ast_map::node_foreign_item(@ast::foreign_item { _ }, _, _, _) |\n         ast_map::node_variant(*) |\n@@ -624,11 +624,11 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n     // get_template_parameters() will append a `<...>` clause to the function name if necessary.\n     let mut function_name = token::ident_to_str(&ident).to_owned();\n-    let template_parameters = if cx.sess.opts.extra_debuginfo {\n-        get_template_parameters(cx, generics, param_substs, file_metadata, &mut function_name)\n-    } else {\n-        ptr::null()\n-    };\n+    let template_parameters = get_template_parameters(cx,\n+                                                      generics,\n+                                                      param_substs,\n+                                                      file_metadata,\n+                                                      &mut function_name);\n \n     let namespace_node = debug_context(cx).local_namespace_map.find_copy(&fn_ast_id);\n     let (linkage_name, containing_scope) = match namespace_node {\n@@ -637,10 +637,9 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         }\n         None => {\n             // This branch is only hit when there is a bug in the NamespaceVisitor.\n-            cx.sess.span_warn(span, \"debuginfo: Could not find namespace node for function. \\\n-                                     This is a bug! Try running with RUST_LOG=rustc=1 \\\n-                                     to get further details and report the results \\\n-                                     to github.com/mozilla/rust/issues\");\n+            cx.sess.span_warn(span, fmt!(\"debuginfo: Could not find namespace node for function\n+                                          with name %s. This is a bug! Please report this to\n+                                          github.com/mozilla/rust/issues\", function_name));\n             (function_name.clone(), file_metadata)\n         }\n     };\n@@ -680,16 +679,14 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n     populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n \n-    match top_level_block {\n-        Some(top_level_block) => {\n-            let mut namespace_visitor = NamespaceVisitor::new_function_visitor(cx,\n-                                                                               function_name,\n-                                                                               namespace_node,\n-                                                                               file_metadata,\n-                                                                               span);\n-            visit::walk_block(&mut namespace_visitor, top_level_block, ());\n-        }\n-        _ => { /*nothing to do*/ }\n+    // Create namespaces for the interior of this function\n+    {\n+        let mut namespace_visitor = NamespaceVisitor::new_function_visitor(cx,\n+                                                                           function_name,\n+                                                                           namespace_node,\n+                                                                           file_metadata,\n+                                                                           span);\n+        visit::walk_block(&mut namespace_visitor, top_level_block, ());\n     }\n \n     return FunctionDebugContext(fn_debug_context);\n@@ -757,7 +754,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         let has_self_type = self_type.is_some();\n \n         if !generics.is_type_parameterized() && !has_self_type {\n-            return ptr::null();\n+            return create_DIArray(DIB(cx), []);\n         }\n \n         name_to_append_suffix_to.push_char('<');\n@@ -768,33 +765,37 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         // Handle self type\n         if has_self_type {\n             let actual_self_type = self_type.unwrap();\n-            let actual_self_type_metadata = type_metadata(cx,\n-                                                          actual_self_type,\n-                                                          codemap::dummy_sp());\n-\n             // Add self type name to <...> clause of function name\n             let actual_self_type_name = ppaux::ty_to_str(cx.tcx, actual_self_type);\n             name_to_append_suffix_to.push_str(actual_self_type_name);\n+\n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n \n-            let ident = special_idents::type_self;\n+            // Only create type information if extra_debuginfo is enabled\n+            if cx.sess.opts.extra_debuginfo {\n+                let actual_self_type_metadata = type_metadata(cx,\n+                                                              actual_self_type,\n+                                                              codemap::dummy_sp());\n \n-            let param_metadata = do token::ident_to_str(&ident).to_c_str().with_ref |name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                        DIB(cx),\n-                        file_metadata,\n-                        name,\n-                        actual_self_type_metadata,\n-                        ptr::null(),\n-                        0,\n-                        0)\n-                }\n-            };\n+                let ident = special_idents::type_self;\n+\n+                let param_metadata = do token::ident_to_str(&ident).to_c_str().with_ref |name| {\n+                    unsafe {\n+                        llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                            DIB(cx),\n+                            file_metadata,\n+                            name,\n+                            actual_self_type_metadata,\n+                            ptr::null(),\n+                            0,\n+                            0)\n+                    }\n+                };\n \n-            template_params.push(param_metadata);\n+                template_params.push(param_metadata);\n+            }\n         }\n \n         // Handle other generic parameters\n@@ -807,8 +808,6 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n         for (index, &ast::TyParam{ ident: ident, _ }) in generics.ty_params.iter().enumerate() {\n             let actual_type = actual_types[index];\n-            let actual_type_metadata = type_metadata(cx, actual_type, codemap::dummy_sp());\n-\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = ppaux::ty_to_str(cx.tcx, actual_type);\n             name_to_append_suffix_to.push_str(actual_type_name);\n@@ -817,20 +816,23 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n \n-            let param_metadata = do token::ident_to_str(&ident).to_c_str().with_ref |name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n-                        DIB(cx),\n-                        file_metadata,\n-                        name,\n-                        actual_type_metadata,\n-                        ptr::null(),\n-                        0,\n-                        0)\n-                }\n-            };\n-\n-            template_params.push(param_metadata);\n+            // Again, only create type information if extra_debuginfo is enabled\n+            if cx.sess.opts.extra_debuginfo {\n+                let actual_type_metadata = type_metadata(cx, actual_type, codemap::dummy_sp());\n+                let param_metadata = do token::ident_to_str(&ident).to_c_str().with_ref |name| {\n+                    unsafe {\n+                        llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                            DIB(cx),\n+                            file_metadata,\n+                            name,\n+                            actual_type_metadata,\n+                            ptr::null(),\n+                            0,\n+                            0)\n+                    }\n+                };\n+                template_params.push(param_metadata);\n+            }\n         }\n \n         name_to_append_suffix_to.push_char('>');\n@@ -839,14 +841,14 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     }\n \n     fn get_scope_line(cx: &CrateContext,\n-                      top_level_block: Option<&ast::Block>,\n+                      top_level_block: &ast::Block,\n                       default: uint)\n                    -> uint {\n-        match top_level_block {\n-            Some(&ast::Block { stmts: ref statements, _ }) if statements.len() > 0 => {\n+        match *top_level_block {\n+            ast::Block { stmts: ref statements, _ } if statements.len() > 0 => {\n                 span_start(cx, statements[0].span).line\n             }\n-            Some(&ast::Block { expr: Some(@ref expr), _ }) => {\n+            ast::Block { expr: Some(@ref expr), _ } => {\n                 span_start(cx, expr.span).line\n             }\n             _ => default\n@@ -2154,7 +2156,7 @@ fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n // shadowing.\n fn populate_scope_map(cx: &mut CrateContext,\n                       arg_pats: &[@ast::Pat],\n-                      fn_entry_block: Option<&ast::Block>,\n+                      fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n     let def_map = cx.tcx.def_map;\n@@ -2175,13 +2177,9 @@ fn populate_scope_map(cx: &mut CrateContext,\n         }\n     }\n \n-    for &fn_entry_block in fn_entry_block.iter() {\n-        walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n-    }\n-\n+    walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n \n     // local helper functions for walking the AST.\n-\n     fn with_new_scope(cx: &mut CrateContext,\n                       scope_span: Span,\n                       scope_stack: &mut ~[ScopeStackEntry],"}]}