{"sha": "d3288841ea86b7ebcff57c840b9a4855f9033ece", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMjg4ODQxZWE4NmI3ZWJjZmY1N2M4NDBiOWE0ODU1ZjkwMzNlY2U=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T02:25:17Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:17:47Z"}, "message": "Refactoring: factor `format_lines` and `format_project` into smaller chunks", "tree": {"sha": "4fd478e0f0f9e040474bf219e95636060dcbdbde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fd478e0f0f9e040474bf219e95636060dcbdbde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3288841ea86b7ebcff57c840b9a4855f9033ece", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3288841ea86b7ebcff57c840b9a4855f9033ece", "html_url": "https://github.com/rust-lang/rust/commit/d3288841ea86b7ebcff57c840b9a4855f9033ece", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3288841ea86b7ebcff57c840b9a4855f9033ece/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fbce1f627afe175c37fe9b8d81fb27269ea9158", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fbce1f627afe175c37fe9b8d81fb27269ea9158", "html_url": "https://github.com/rust-lang/rust/commit/9fbce1f627afe175c37fe9b8d81fb27269ea9158"}], "stats": {"total": 399, "additions": 217, "deletions": 182}, "files": [{"sha": "ee2539a2fa501e0391f51780b66978616e6d240b", "filename": "src/formatting.rs", "status": "modified", "additions": 210, "deletions": 182, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/d3288841ea86b7ebcff57c840b9a4855f9033ece/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3288841ea86b7ebcff57c840b9a4855f9033ece/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=d3288841ea86b7ebcff57c840b9a4855f9033ece", "patch": "@@ -9,7 +9,7 @@ use std::time::{Duration, Instant};\n use syntax::ast;\n use syntax::codemap::{CodeMap, FilePathMapping, Span};\n use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n-use syntax::errors::{DiagnosticBuilder, Handler};\n+use syntax::errors::Handler;\n use syntax::parse::{self, ParseSess};\n \n use comment::{CharClasses, FullCodeCharKind};\n@@ -63,43 +63,17 @@ fn format_project<T: FormatHandler>(\n     let mut summary = Summary::default();\n     let mut timer = Timer::Initialized(Instant::now());\n \n-    let input_is_stdin = input.is_text();\n-    let main_file = match input {\n-        Input::File(ref file) => FileName::Real(file.clone()),\n-        Input::Text(..) => FileName::Stdin,\n-    };\n+    let main_file = input.file_name();\n+    let input_is_stdin = main_file == FileName::Stdin;\n \n     // Parse the crate.\n     let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n     let mut parse_session = make_parse_sess(codemap.clone(), config);\n-    let krate = match parse_input(input, &parse_session, config) {\n-        Ok(krate) => krate,\n-        Err(err) => {\n-            match err {\n-                ParseError::Error(mut diagnostic) => diagnostic.emit(),\n-                ParseError::Panic => {\n-                    // Note that if you see this message and want more information,\n-                    // then go to `parse_input` and run the parse function without\n-                    // `catch_unwind` so rustfmt panics and you can get a backtrace.\n-                    should_emit_verbose(!input_is_stdin, config, || {\n-                        println!(\"The Rust parser panicked\")\n-                    });\n-                }\n-                ParseError::Recovered => {}\n-            }\n-            summary.add_parsing_error();\n-            return Err(ErrorKind::ParseError);\n-        }\n-    };\n+    let krate = parse_crate(input, &parse_session, config, &mut summary)?;\n     timer = timer.done_parsing();\n \n     // Suppress error output if we have to do any further parsing.\n-    let silent_emitter = Box::new(EmitterWriter::new(\n-        Box::new(Vec::new()),\n-        Some(codemap.clone()),\n-        false,\n-        false,\n-    ));\n+    let silent_emitter = silent_emitter(codemap);\n     parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n \n     let mut context = FormatContext::new(\n@@ -130,19 +104,7 @@ fn format_project<T: FormatHandler>(\n         )\n     });\n \n-    if context.report.has_warnings() {\n-        context.summary.add_formatting_error();\n-    }\n-    {\n-        let report_errs = &context.report.internal.borrow().1;\n-        if report_errs.has_check_errors {\n-            context.summary.add_check_error();\n-        }\n-        if report_errs.has_operational_errors {\n-            context.summary.add_operational_error();\n-        }\n-    }\n-\n+    context.summarise_errors();\n     Ok((context.report, context.summary))\n }\n \n@@ -158,6 +120,20 @@ struct FormatContext<'a, T: FormatHandler + 'a> {\n }\n \n impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n+    // Moves errors from the report to the summary.\n+    fn summarise_errors(&mut self) {\n+        if self.report.has_warnings() {\n+            self.summary.add_formatting_error();\n+        }\n+        let report_errs = &self.report.internal.borrow().1;\n+        if report_errs.has_check_errors {\n+            self.summary.add_check_error();\n+        }\n+        if report_errs.has_operational_errors {\n+            self.summary.add_operational_error();\n+        }\n+    }\n+\n     // Formats a single file/module.\n     fn format_file(\n         &mut self,\n@@ -178,6 +154,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             &snippet_provider,\n             self.report.clone(),\n         );\n+\n         // Format inner attributes if available.\n         if !self.krate.attrs.is_empty() && is_root {\n             visitor.skip_empty_lines(filemap.end_pos);\n@@ -481,41 +458,6 @@ impl Timer {\n     }\n }\n \n-fn should_emit_verbose<F>(is_stdin: bool, config: &Config, f: F)\n-where\n-    F: Fn(),\n-{\n-    if config.verbose() == Verbosity::Verbose && !is_stdin {\n-        f();\n-    }\n-}\n-\n-/// Returns true if the line with the given line number was skipped by `#[rustfmt::skip]`.\n-fn is_skipped_line(line_number: usize, skipped_range: &[(usize, usize)]) -> bool {\n-    skipped_range\n-        .iter()\n-        .any(|&(lo, hi)| lo <= line_number && line_number <= hi)\n-}\n-\n-fn should_report_error(\n-    config: &Config,\n-    char_kind: FullCodeCharKind,\n-    is_string: bool,\n-    error_kind: &ErrorKind,\n-) -> bool {\n-    let allow_error_report = if char_kind.is_comment() || is_string || error_kind.is_comment() {\n-        config.error_on_unformatted()\n-    } else {\n-        true\n-    };\n-\n-    match error_kind {\n-        ErrorKind::LineOverflow(..) => config.error_on_line_overflow() && allow_error_report,\n-        ErrorKind::TrailingWhitespace | ErrorKind::LostComment => allow_error_report,\n-        _ => true,\n-    }\n-}\n-\n // Formatting done on a char by char or line by line basis.\n // FIXME(#20) other stuff for parity with make tidy\n fn format_lines(\n@@ -525,115 +467,191 @@ fn format_lines(\n     config: &Config,\n     report: &FormatReport,\n ) {\n-    let mut last_was_space = false;\n-    let mut line_len = 0;\n-    let mut cur_line = 1;\n-    let mut newline_count = 0;\n-    let mut errors = vec![];\n-    let mut issue_seeker = BadIssueSeeker::new(config.report_todo(), config.report_fixme());\n-    let mut line_buffer = String::with_capacity(config.max_width() * 2);\n-    let mut is_string = false; // true if the current line contains a string literal.\n-    let mut format_line = config.file_lines().contains_line(name, cur_line);\n-    let allow_issue_seek = !issue_seeker.is_disabled();\n-\n-    // Check license.\n-    if let Some(ref license_template) = config.license_template {\n-        if !license_template.is_match(text) {\n-            errors.push(FormattingError {\n-                line: cur_line,\n-                kind: ErrorKind::LicenseCheck,\n-                is_comment: false,\n-                is_string: false,\n-                line_buffer: String::new(),\n-            });\n-        }\n+    let mut formatter = FormatLines::new(name, skipped_range, config);\n+    formatter.check_license(text);\n+    formatter.iterate(text);\n+\n+    if formatter.newline_count > 1 {\n+        debug!(\"track truncate: {} {}\", text.len(), formatter.newline_count);\n+        let line = text.len() - formatter.newline_count + 1;\n+        text.truncate(line);\n     }\n \n-    // Iterate over the chars in the file map.\n-    for (kind, c) in CharClasses::new(text.chars()) {\n-        if c == '\\r' {\n-            continue;\n+    report.append(name.clone(), formatter.errors);\n+}\n+\n+struct FormatLines<'a> {\n+    name: &'a FileName,\n+    skipped_range: &'a [(usize, usize)],\n+    last_was_space: bool,\n+    line_len: usize,\n+    cur_line: usize,\n+    newline_count: usize,\n+    errors: Vec<FormattingError>,\n+    issue_seeker: BadIssueSeeker,\n+    line_buffer: String,\n+    // true if the current line contains a string literal.\n+    is_string: bool,\n+    format_line: bool,\n+    allow_issue_seek: bool,\n+    config: &'a Config,\n+}\n+\n+impl<'a> FormatLines<'a> {\n+    fn new(\n+        name: &'a FileName,\n+        skipped_range: &'a [(usize, usize)],\n+        config: &'a Config,\n+    ) -> FormatLines<'a> {\n+        let issue_seeker = BadIssueSeeker::new(config.report_todo(), config.report_fixme());\n+        FormatLines {\n+            name,\n+            skipped_range,\n+            last_was_space: false,\n+            line_len: 0,\n+            cur_line: 1,\n+            newline_count: 0,\n+            errors: vec![],\n+            allow_issue_seek: !issue_seeker.is_disabled(),\n+            issue_seeker,\n+            line_buffer: String::with_capacity(config.max_width() * 2),\n+            is_string: false,\n+            format_line: config.file_lines().contains_line(name, 1),\n+            config,\n         }\n+    }\n \n-        if allow_issue_seek && format_line {\n-            // Add warnings for bad todos/ fixmes\n-            if let Some(issue) = issue_seeker.inspect(c) {\n-                errors.push(FormattingError {\n-                    line: cur_line,\n-                    kind: ErrorKind::BadIssue(issue),\n+    fn check_license(&mut self, text: &mut String) {\n+        if let Some(ref license_template) = self.config.license_template {\n+            if !license_template.is_match(text) {\n+                self.errors.push(FormattingError {\n+                    line: self.cur_line,\n+                    kind: ErrorKind::LicenseCheck,\n                     is_comment: false,\n                     is_string: false,\n                     line_buffer: String::new(),\n                 });\n             }\n         }\n+    }\n \n-        if c == '\\n' {\n-            if format_line {\n-                // Check for (and record) trailing whitespace.\n-                if last_was_space {\n-                    if should_report_error(config, kind, is_string, &ErrorKind::TrailingWhitespace)\n-                        && !is_skipped_line(cur_line, skipped_range)\n-                    {\n-                        errors.push(FormattingError {\n-                            line: cur_line,\n-                            kind: ErrorKind::TrailingWhitespace,\n-                            is_comment: kind.is_comment(),\n-                            is_string: kind.is_string(),\n-                            line_buffer: line_buffer.clone(),\n-                        });\n-                    }\n-                    line_len -= 1;\n+    // Iterate over the chars in the file map.\n+    fn iterate(&mut self, text: &mut String) {\n+        for (kind, c) in CharClasses::new(text.chars()) {\n+            if c == '\\r' {\n+                continue;\n+            }\n+\n+            if self.allow_issue_seek && self.format_line {\n+                // Add warnings for bad todos/ fixmes\n+                if let Some(issue) = self.issue_seeker.inspect(c) {\n+                    self.push_err(ErrorKind::BadIssue(issue), false, false);\n                 }\n+            }\n \n-                // Check for any line width errors we couldn't correct.\n-                let error_kind = ErrorKind::LineOverflow(line_len, config.max_width());\n-                if line_len > config.max_width()\n-                    && !is_skipped_line(cur_line, skipped_range)\n-                    && should_report_error(config, kind, is_string, &error_kind)\n+            if c == '\\n' {\n+                self.new_line(kind);\n+            } else {\n+                self.char(c, kind);\n+            }\n+        }\n+    }\n+\n+    fn new_line(&mut self, kind: FullCodeCharKind) {\n+        if self.format_line {\n+            // Check for (and record) trailing whitespace.\n+            if self.last_was_space {\n+                if self.should_report_error(kind, &ErrorKind::TrailingWhitespace)\n+                    && !self.is_skipped_line()\n                 {\n-                    errors.push(FormattingError {\n-                        line: cur_line,\n-                        kind: error_kind,\n-                        is_comment: kind.is_comment(),\n-                        is_string,\n-                        line_buffer: line_buffer.clone(),\n-                    });\n+                    self.push_err(\n+                        ErrorKind::TrailingWhitespace,\n+                        kind.is_comment(),\n+                        kind.is_string(),\n+                    );\n                 }\n+                self.line_len -= 1;\n             }\n \n-            line_len = 0;\n-            cur_line += 1;\n-            format_line = config.file_lines().contains_line(name, cur_line);\n-            newline_count += 1;\n-            last_was_space = false;\n-            line_buffer.clear();\n-            is_string = false;\n-        } else {\n-            newline_count = 0;\n-            line_len += if c == '\\t' { config.tab_spaces() } else { 1 };\n-            last_was_space = c.is_whitespace();\n-            line_buffer.push(c);\n-            if kind.is_string() {\n-                is_string = true;\n+            // Check for any line width errors we couldn't correct.\n+            let error_kind = ErrorKind::LineOverflow(self.line_len, self.config.max_width());\n+            if self.line_len > self.config.max_width()\n+                && !self.is_skipped_line()\n+                && self.should_report_error(kind, &error_kind)\n+            {\n+                self.push_err(error_kind, kind.is_comment(), self.is_string);\n             }\n         }\n+\n+        self.line_len = 0;\n+        self.cur_line += 1;\n+        self.format_line = self\n+            .config\n+            .file_lines()\n+            .contains_line(self.name, self.cur_line);\n+        self.newline_count += 1;\n+        self.last_was_space = false;\n+        self.line_buffer.clear();\n+        self.is_string = false;\n+    }\n+\n+    fn char(&mut self, c: char, kind: FullCodeCharKind) {\n+        self.newline_count = 0;\n+        self.line_len += if c == '\\t' {\n+            self.config.tab_spaces()\n+        } else {\n+            1\n+        };\n+        self.last_was_space = c.is_whitespace();\n+        self.line_buffer.push(c);\n+        if kind.is_string() {\n+            self.is_string = true;\n+        }\n     }\n \n-    if newline_count > 1 {\n-        debug!(\"track truncate: {} {}\", text.len(), newline_count);\n-        let line = text.len() - newline_count + 1;\n-        text.truncate(line);\n+    fn push_err(&mut self, kind: ErrorKind, is_comment: bool, is_string: bool) {\n+        self.errors.push(FormattingError {\n+            line: self.cur_line,\n+            kind,\n+            is_comment,\n+            is_string,\n+            line_buffer: self.line_buffer.clone(),\n+        });\n     }\n \n-    report.append(name.clone(), errors);\n+    fn should_report_error(&self, char_kind: FullCodeCharKind, error_kind: &ErrorKind) -> bool {\n+        let allow_error_report =\n+            if char_kind.is_comment() || self.is_string || error_kind.is_comment() {\n+                self.config.error_on_unformatted()\n+            } else {\n+                true\n+            };\n+\n+        match error_kind {\n+            ErrorKind::LineOverflow(..) => {\n+                self.config.error_on_line_overflow() && allow_error_report\n+            }\n+            ErrorKind::TrailingWhitespace | ErrorKind::LostComment => allow_error_report,\n+            _ => true,\n+        }\n+    }\n+\n+    /// Returns true if the line with the given line number was skipped by `#[rustfmt::skip]`.\n+    fn is_skipped_line(&self) -> bool {\n+        self.skipped_range\n+            .iter()\n+            .any(|&(lo, hi)| lo <= self.cur_line && self.cur_line <= hi)\n+    }\n }\n \n-fn parse_input<'sess>(\n+fn parse_crate(\n     input: Input,\n-    parse_session: &'sess ParseSess,\n+    parse_session: &ParseSess,\n     config: &Config,\n-) -> Result<ast::Crate, ParseError<'sess>> {\n+    summary: &mut Summary,\n+) -> Result<ast::Crate, ErrorKind> {\n+    let input_is_stdin = input.is_text();\n+\n     let mut parser = match input {\n         Input::File(file) => parse::new_parser_from_file(parse_session, &file),\n         Input::Text(text) => parse::new_parser_from_source_str(\n@@ -653,36 +671,37 @@ fn parse_input<'sess>(\n \n     match result {\n         Ok(Ok(c)) => {\n-            if parse_session.span_diagnostic.has_errors() {\n-                // Bail out if the parser recovered from an error.\n-                Err(ParseError::Recovered)\n-            } else {\n-                Ok(c)\n+            if !parse_session.span_diagnostic.has_errors() {\n+                return Ok(c);\n             }\n         }\n-        Ok(Err(e)) => Err(ParseError::Error(e)),\n-        Err(_) => Err(ParseError::Panic),\n+        Ok(Err(mut e)) => e.emit(),\n+        Err(_) => {\n+            // Note that if you see this message and want more information,\n+            // then run the `parse_crate_mod` function above without\n+            // `catch_unwind` so rustfmt panics and you can get a backtrace.\n+            should_emit_verbose(!input_is_stdin, config, || {\n+                println!(\"The Rust parser panicked\")\n+            });\n+        }\n     }\n+\n+    summary.add_parsing_error();\n+    Err(ErrorKind::ParseError)\n }\n \n-/// All the ways that parsing can fail.\n-enum ParseError<'sess> {\n-    /// There was an error, but the parser recovered.\n-    Recovered,\n-    /// There was an error (supplied) and parsing failed.\n-    Error(DiagnosticBuilder<'sess>),\n-    /// The parser panicked.\n-    Panic,\n+fn silent_emitter(codemap: Rc<CodeMap>) -> Box<EmitterWriter> {\n+    Box::new(EmitterWriter::new(\n+        Box::new(Vec::new()),\n+        Some(codemap),\n+        false,\n+        false,\n+    ))\n }\n \n fn make_parse_sess(codemap: Rc<CodeMap>, config: &Config) -> ParseSess {\n     let tty_handler = if config.hide_parse_errors() {\n-        let silent_emitter = Box::new(EmitterWriter::new(\n-            Box::new(Vec::new()),\n-            Some(codemap.clone()),\n-            false,\n-            false,\n-        ));\n+        let silent_emitter = silent_emitter(codemap.clone());\n         Handler::with_emitter(true, false, silent_emitter)\n     } else {\n         let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n@@ -724,3 +743,12 @@ fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n         NewlineStyle::Native => unreachable!(),\n     }\n }\n+\n+fn should_emit_verbose<F>(is_stdin: bool, config: &Config, f: F)\n+where\n+    F: Fn(),\n+{\n+    if config.verbose() == Verbosity::Verbose && !is_stdin {\n+        f();\n+    }\n+}"}, {"sha": "a1cd3ba84a1f179e5639720c36474054047da758", "filename": "src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d3288841ea86b7ebcff57c840b9a4855f9033ece/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3288841ea86b7ebcff57c840b9a4855f9033ece/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d3288841ea86b7ebcff57c840b9a4855f9033ece", "patch": "@@ -499,6 +499,13 @@ impl Input {\n             Input::Text(_) => true,\n         }\n     }\n+\n+    fn file_name(&self) -> FileName {\n+        match *self {\n+            Input::File(ref file) => FileName::Real(file.clone()),\n+            Input::Text(..) => FileName::Stdin,\n+        }\n+    }\n }\n \n #[cfg(test)]"}]}