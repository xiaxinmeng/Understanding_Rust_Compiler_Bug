{"sha": "7158c944a4f033f6feb57fbcdbf3453333d892b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNThjOTQ0YTRmMDMzZjZmZWI1N2ZiY2RiZjM0NTMzMzNkODkyYjc=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-21T16:01:49Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:14:20Z"}, "message": "Refactor while let loop to its own module", "tree": {"sha": "032f607d34fec2de36b951dd76619b9a8834b043", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/032f607d34fec2de36b951dd76619b9a8834b043"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7158c944a4f033f6feb57fbcdbf3453333d892b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7158c944a4f033f6feb57fbcdbf3453333d892b7", "html_url": "https://github.com/rust-lang/rust/commit/7158c944a4f033f6feb57fbcdbf3453333d892b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7158c944a4f033f6feb57fbcdbf3453333d892b7/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "287a4f8ab176a95cff2b82f6414d37e33809110a", "url": "https://api.github.com/repos/rust-lang/rust/commits/287a4f8ab176a95cff2b82f6414d37e33809110a", "html_url": "https://github.com/rust-lang/rust/commit/287a4f8ab176a95cff2b82f6414d37e33809110a"}], "stats": {"total": 176, "additions": 92, "deletions": 84}, "files": [{"sha": "9076e48584a7a102e4ea4ddb89c92bbb9dacdabc", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 5, "deletions": 84, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7158c944a4f033f6feb57fbcdbf3453333d892b7/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7158c944a4f033f6feb57fbcdbf3453333d892b7/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=7158c944a4f033f6feb57fbcdbf3453333d892b7", "patch": "@@ -12,14 +12,13 @@ mod needless_collect;\n mod never_loop;\n mod same_item_push;\n mod utils;\n+mod while_let_loop;\n mod while_let_on_iterator;\n \n use crate::utils::sugg::Sugg;\n-use crate::utils::{higher, snippet_with_applicability, span_lint_and_sugg, sugg};\n-use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, LoopSource, MatchSource, Pat, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n+use crate::utils::{higher, sugg};\n+use rustc_hir::{Expr, ExprKind, LoopSource, Pat};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use utils::{get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n@@ -564,49 +563,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         if let ExprKind::Loop(ref block, _, LoopSource::Loop, _) = expr.kind {\n             // also check for empty `loop {}` statements, skipping those in #[panic_handler]\n             empty_loop::check_empty_loop(cx, expr, block);\n-\n-            // extract the expression from the first statement (if any) in a block\n-            let inner_stmt_expr = extract_expr_from_first_stmt(block);\n-            // or extract the first expression (if any) from the block\n-            if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(block)) {\n-                if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.kind {\n-                    // ensure \"if let\" compatible match structure\n-                    match *source {\n-                        MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n-                            if arms.len() == 2\n-                                && arms[0].guard.is_none()\n-                                && arms[1].guard.is_none()\n-                                && is_simple_break_expr(&arms[1].body)\n-                            {\n-                                if in_external_macro(cx.sess(), expr.span) {\n-                                    return;\n-                                }\n-\n-                                // NOTE: we used to build a body here instead of using\n-                                // ellipsis, this was removed because:\n-                                // 1) it was ugly with big bodies;\n-                                // 2) it was not indented properly;\n-                                // 3) it wasn\u2019t very smart (see #675).\n-                                let mut applicability = Applicability::HasPlaceholders;\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    WHILE_LET_LOOP,\n-                                    expr.span,\n-                                    \"this loop could be written as a `while let` loop\",\n-                                    \"try\",\n-                                    format!(\n-                                        \"while let {} = {} {{ .. }}\",\n-                                        snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability),\n-                                        snippet_with_applicability(cx, matchexpr.span, \"..\", &mut applicability),\n-                                    ),\n-                                    applicability,\n-                                );\n-                            }\n-                        },\n-                        _ => (),\n-                    }\n-                }\n-            }\n+            while_let_loop::check_while_let_loop(cx, expr, block);\n         }\n \n         while_let_on_iterator::check_while_let_on_iterator(cx, expr);\n@@ -709,39 +666,3 @@ impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n         }\n     }\n }\n-\n-/// If a block begins with a statement (possibly a `let` binding) and has an\n-/// expression, return it.\n-fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    if block.stmts.is_empty() {\n-        return None;\n-    }\n-    if let StmtKind::Local(ref local) = block.stmts[0].kind {\n-        local.init //.map(|expr| expr)\n-    } else {\n-        None\n-    }\n-}\n-\n-/// If a block begins with an expression (with or without semicolon), return it.\n-fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    match block.expr {\n-        Some(ref expr) if block.stmts.is_empty() => Some(expr),\n-        None if !block.stmts.is_empty() => match block.stmts[0].kind {\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => Some(expr),\n-            StmtKind::Local(..) | StmtKind::Item(..) => None,\n-        },\n-        _ => None,\n-    }\n-}\n-\n-/// Returns `true` if expr contains a single break expr without destination label\n-/// and\n-/// passed expression. The expression may be within a block.\n-fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprKind::Block(ref b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n-        _ => false,\n-    }\n-}"}, {"sha": "0c9579869645750c3915c1b3976d8f1e6dd854a6", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7158c944a4f033f6feb57fbcdbf3453333d892b7/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7158c944a4f033f6feb57fbcdbf3453333d892b7/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=7158c944a4f033f6feb57fbcdbf3453333d892b7", "patch": "@@ -0,0 +1,87 @@\n+use super::WHILE_LET_LOOP;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Block, Expr, ExprKind, MatchSource, StmtKind};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+\n+pub(super) fn check_while_let_loop(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n+    // extract the expression from the first statement (if any) in a block\n+    let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n+    // or extract the first expression (if any) from the block\n+    if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n+        if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.kind {\n+            // ensure \"if let\" compatible match structure\n+            match *source {\n+                MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n+                    if arms.len() == 2\n+                        && arms[0].guard.is_none()\n+                        && arms[1].guard.is_none()\n+                        && is_simple_break_expr(&arms[1].body)\n+                    {\n+                        if in_external_macro(cx.sess(), expr.span) {\n+                            return;\n+                        }\n+\n+                        // NOTE: we used to build a body here instead of using\n+                        // ellipsis, this was removed because:\n+                        // 1) it was ugly with big bodies;\n+                        // 2) it was not indented properly;\n+                        // 3) it wasn\u2019t very smart (see #675).\n+                        let mut applicability = Applicability::HasPlaceholders;\n+                        span_lint_and_sugg(\n+                            cx,\n+                            WHILE_LET_LOOP,\n+                            expr.span,\n+                            \"this loop could be written as a `while let` loop\",\n+                            \"try\",\n+                            format!(\n+                                \"while let {} = {} {{ .. }}\",\n+                                snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability),\n+                                snippet_with_applicability(cx, matchexpr.span, \"..\", &mut applicability),\n+                            ),\n+                            applicability,\n+                        );\n+                    }\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+}\n+\n+/// If a block begins with a statement (possibly a `let` binding) and has an\n+/// expression, return it.\n+fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    if block.stmts.is_empty() {\n+        return None;\n+    }\n+    if let StmtKind::Local(ref local) = block.stmts[0].kind {\n+        local.init //.map(|expr| expr)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// If a block begins with an expression (with or without semicolon), return it.\n+fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    match block.expr {\n+        Some(ref expr) if block.stmts.is_empty() => Some(expr),\n+        None if !block.stmts.is_empty() => match block.stmts[0].kind {\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => Some(expr),\n+            StmtKind::Local(..) | StmtKind::Item(..) => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n+/// Returns `true` if expr contains a single break expr without destination label\n+/// and\n+/// passed expression. The expression may be within a block.\n+fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n+    match expr.kind {\n+        ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n+        ExprKind::Block(ref b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n+        _ => false,\n+    }\n+}"}]}