{"sha": "00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZjNjM2Y3YTcwNThhYzFiMDQ5ODEwY2ZmYzJhOGZhNzFlZjdkYWE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-27T18:53:34Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-07T00:05:58Z"}, "message": "librustc: remove unnecessary `as_slice()` calls", "tree": {"sha": "46a41e88814d12bf9245f7714a0381f9a8038370", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46a41e88814d12bf9245f7714a0381f9a8038370"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "html_url": "https://github.com/rust-lang/rust/commit/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/comments", "author": null, "committer": null, "parents": [{"sha": "ae555a99a63fc3a6038a9bb4345a30413946aa8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae555a99a63fc3a6038a9bb4345a30413946aa8c", "html_url": "https://github.com/rust-lang/rust/commit/ae555a99a63fc3a6038a9bb4345a30413946aa8c"}], "stats": {"total": 78, "additions": 38, "deletions": 40}, "files": [{"sha": "c474820c3c934e5cd9f054642b854fb39628379e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -902,7 +902,7 @@ impl NonSnakeCase {\n                 let mut buf = String::new();\n                 if s.is_empty() { continue; }\n                 for ch in s.chars() {\n-                    if !buf.is_empty() && buf.as_slice() != \"'\"\n+                    if !buf.is_empty() && buf != \"'\"\n                                        && ch.is_uppercase()\n                                        && !last_upper {\n                         words.push(buf);"}, {"sha": "deeab18de7c139cb51ce59acc5bd8513269eb248", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -277,7 +277,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n \n fn register_native_lib(sess: &Session, span: Option<Span>, name: String,\n                        kind: cstore::NativeLibaryKind) {\n-    if name.as_slice().is_empty() {\n+    if name.is_empty() {\n         match span {\n             Some(span) => {\n                 sess.span_err(span, \"#[link(name = \\\"\\\")] given with \\\n@@ -304,7 +304,7 @@ fn existing_match(e: &Env, name: &str,\n                   hash: Option<&Svh>) -> Option<ast::CrateNum> {\n     let mut ret = None;\n     e.sess.cstore.iter_crate_data(|cnum, data| {\n-        if data.name.as_slice() != name { return }\n+        if data.name != name { return }\n \n         match hash {\n             Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }"}, {"sha": "07a8888c531cfd7f3228c1d5d793d5887982766a", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -162,7 +162,7 @@ impl CStore {\n         let mut ordering = Vec::new();\n         fn visit(cstore: &CStore, cnum: ast::CrateNum,\n                  ordering: &mut Vec<ast::CrateNum>) {\n-            if ordering.as_slice().contains(&cnum) { return }\n+            if ordering.contains(&cnum) { return }\n             let meta = cstore.get_crate_data(cnum);\n             for (_, &dep) in meta.cnum_map.iter() {\n                 visit(cstore, dep, ordering);\n@@ -173,7 +173,6 @@ impl CStore {\n             visit(self, num, &mut ordering);\n         }\n         ordering.as_mut_slice().reverse();\n-        let ordering = ordering.as_slice();\n         let mut libs = self.used_crate_sources.borrow()\n             .iter()\n             .map(|src| (src.cnum, match prefer {"}, {"sha": "3a111a3223b686446f320d771bada7f6b7f2cd87", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -474,7 +474,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n         // encoded metadata for static methods relative to Bar,\n         // but not yet for Foo.\n         //\n-        if path_differs || original_name.get() != exp.name.as_slice() {\n+        if path_differs || original_name.get() != exp.name {\n             if !encode_reexported_static_base_methods(ecx, rbml_w, exp) {\n                 if encode_reexported_static_trait_methods(ecx, rbml_w, exp) {\n                     debug!(\"(encode reexported static methods) {} [trait]\","}, {"sha": "63fc2af492cb0de4ea94f694113c91d797495aa9", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -214,7 +214,7 @@ pub fn rust_path() -> Vec<Path> {\n     let mut env_rust_path: Vec<Path> = match get_rust_path() {\n         Some(env_path) => {\n             let env_path_components =\n-                env_path.as_slice().split_str(PATH_ENTRY_SEPARATOR);\n+                env_path.split_str(PATH_ENTRY_SEPARATOR);\n             env_path_components.map(|s| Path::new(s)).collect()\n         }\n         None => Vec::new()"}, {"sha": "14b1eea2eb819714e88ce5d43cc45b55f48947f1", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -545,7 +545,7 @@ impl<'a> Context<'a> {\n     fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> bool {\n         if self.should_match_name {\n             match decoder::maybe_get_crate_name(crate_data) {\n-                Some(ref name) if self.crate_name == name.as_slice() => {}\n+                Some(ref name) if self.crate_name == *name => {}\n                 _ => { info!(\"Rejecting via crate name\"); return false }\n             }\n         }\n@@ -560,7 +560,7 @@ impl<'a> Context<'a> {\n             None => { debug!(\"triple not present\"); return false }\n             Some(t) => t,\n         };\n-        if triple.as_slice() != self.triple {\n+        if triple != self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\", self.triple, triple);\n             self.rejected_via_triple.push(CrateMismatch {\n                 path: libpath.clone(),\n@@ -743,7 +743,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n             let name = String::from_raw_buf_len(name_buf as *const u8,\n                                                 name_len as uint);\n             debug!(\"get_metadata_section: name {}\", name);\n-            if read_meta_section_name(is_osx).as_slice() == name.as_slice() {\n+            if read_meta_section_name(is_osx) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let cvbuf: *const u8 = cbuf as *const u8;"}, {"sha": "5785972c484bbb5a55eedac6b0813db17f6688e3", "filename": "src/librustc/middle/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -234,15 +234,15 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     debug!(\"fragments 3 assigned: {}\", path_lps(assigned.as_slice()));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n-    for m in moved.as_slice().iter() {\n+    for m in moved.iter() {\n         let lp = this.path_loan_path(*m);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }\n-    for a in assigned.as_slice().iter() {\n+    for a in assigned.iter() {\n         let lp = this.path_loan_path(*a);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }\n-    for p in parents.as_slice().iter() {\n+    for p in parents.iter() {\n         let lp = this.path_loan_path(*p);\n         add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n     }"}, {"sha": "e33f44967f1ad4661aae2dcc24ad8981baa11344", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -31,14 +31,14 @@ pub struct LabelledCFG<'a, 'ast: 'a> {\n fn replace_newline_with_backslash_l(s: String) -> String {\n     // Replacing newlines with \\\\l causes each line to be left-aligned,\n     // improving presentation of (long) pretty-printed expressions.\n-    if s.as_slice().contains(\"\\n\") {\n+    if s.contains(\"\\n\") {\n         let mut s = s.replace(\"\\n\", \"\\\\l\");\n         // Apparently left-alignment applies to the line that precedes\n         // \\l, not the line that follows; so, add \\l at end of string\n         // if not already present, ensuring last line gets left-aligned\n         // as well.\n         let mut last_two: Vec<_> =\n-            s.as_slice().chars().rev().take(2).collect();\n+            s.chars().rev().take(2).collect();\n         last_two.reverse();\n         if last_two != ['\\\\', 'l'] {\n             s.push_str(\"\\\\l\");"}, {"sha": "d2f43faa003559c8d5fe32b971db959289a7c4e0", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -321,7 +321,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     for attr in lint::gather_attrs(attrs).into_iter() {\n         match attr {\n             Ok((ref name, lint::Allow, _))\n-                if name.get() == dead_code.as_slice() => return true,\n+                if name.get() == dead_code => return true,\n             _ => (),\n         }\n     }"}, {"sha": "a6d3c15df8a7488ff7d37c1b0537b0bafc41846f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -1065,7 +1065,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 // the same bindings, and we also consider the first pattern to be\n                 // the \"authoritative\" set of ids\n                 let arm_succ =\n-                    self.define_bindings_in_arm_pats(arm.pats.as_slice().head().map(|p| &**p),\n+                    self.define_bindings_in_arm_pats(arm.pats.head().map(|p| &**p),\n                                                      guard_succ);\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n@@ -1431,7 +1431,7 @@ fn check_arm(this: &mut Liveness, arm: &ast::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n-    this.arm_pats_bindings(arm.pats.as_slice().head().map(|p| &**p), |this, ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats.head().map(|p| &**p), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm);"}, {"sha": "66acda782460711394ae84edcdbecfd65896178c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -1668,7 +1668,7 @@ impl<'a> Resolver<'a> {\n                 let module_path = match view_path.node {\n                     ViewPathSimple(_, ref full_path, _) => {\n                         full_path.segments\n-                            .as_slice().init()\n+                            .init()\n                             .iter().map(|ident| ident.identifier.name)\n                             .collect()\n                     }\n@@ -1739,7 +1739,7 @@ impl<'a> Resolver<'a> {\n                                             continue;\n                                         }\n                                     };\n-                                    let module_path = module_path.as_slice().init();\n+                                    let module_path = module_path.init();\n                                     (module_path.to_vec(), name)\n                                 }\n                             };\n@@ -3735,12 +3735,12 @@ impl<'a> Resolver<'a> {\n                          .codemap()\n                          .span_to_snippet((*imports)[index].span)\n                          .unwrap();\n-            if sn.as_slice().contains(\"::\") {\n+            if sn.contains(\"::\") {\n                 self.resolve_error((*imports)[index].span,\n                                    \"unresolved import\");\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n-                                  sn.as_slice().slice(0, sn.len()));\n+                                  sn.slice(0, sn.len()));\n                 self.resolve_error((*imports)[index].span, err.as_slice());\n             }\n         }\n@@ -5748,7 +5748,7 @@ impl<'a> Resolver<'a> {\n                                 });\n \n                                 if method_scope && token::get_name(self.self_name).get()\n-                                                                   == wrong_name.as_slice() {\n+                                                                   == wrong_name {\n                                         self.resolve_error(\n                                             expr.span,\n                                             \"`self` is not available \\"}, {"sha": "8a2529701bbb38433001719f2253c6ab48ddfd3f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -2907,7 +2907,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                         res = res | TC::ReachesFfiUnsafe;\n                     }\n \n-                    match repr_hints.as_slice().get(0) {\n+                    match repr_hints.get(0) {\n                         Some(h) => if !h.is_ffi_safe() {\n                             res = res | TC::ReachesFfiUnsafe;\n                         },\n@@ -3566,23 +3566,23 @@ pub fn positional_element_ty<'tcx>(cx: &ctxt<'tcx>,\n                                    variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n \n     match (&ty.sty, variant) {\n-        (&ty_tup(ref v), None) => v.as_slice().get(i).map(|&t| t),\n+        (&ty_tup(ref v), None) => v.get(i).map(|&t| t),\n \n \n         (&ty_struct(def_id, ref substs), None) => lookup_struct_fields(cx, def_id)\n-            .as_slice().get(i)\n+            .get(i)\n             .map(|&t|lookup_item_type(cx, t.id).ty.subst(cx, substs)),\n \n         (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {\n             let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n-            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))\n+            variant_info.args.get(i).map(|t|t.subst(cx, substs))\n         }\n \n         (&ty_enum(def_id, ref substs), None) => {\n             assert!(enum_is_univariant(cx, def_id));\n             let enum_variants = enum_variants(cx, def_id);\n             let variant_info = &(*enum_variants)[0];\n-            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))\n+            variant_info.args.get(i).map(|t|t.subst(cx, substs))\n         }\n \n         _ => None"}, {"sha": "8701248d1f58eec0e2ec38cf6b4d62dd9856be1d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -512,13 +512,13 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n {\n     let mut cg = basic_codegen_options();\n     for option in matches.opt_strs(\"C\").into_iter() {\n-        let mut iter = option.as_slice().splitn(1, '=');\n+        let mut iter = option.splitn(1, '=');\n         let key = iter.next().unwrap();\n         let value = iter.next();\n         let option_to_lookup = key.replace(\"-\", \"_\");\n         let mut found = false;\n         for &(candidate, setter, opt_type_desc, _) in CG_OPTIONS.iter() {\n-            if option_to_lookup.as_slice() != candidate { continue }\n+            if option_to_lookup != candidate { continue }\n             if !setter(&mut cg, value) {\n                 match (value, opt_type_desc) {\n                     (Some(..), None) => {\n@@ -714,7 +714,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     for &level in [lint::Allow, lint::Warn, lint::Deny, lint::Forbid].iter() {\n         for lint_name in matches.opt_strs(level.as_str()).into_iter() {\n-            if lint_name.as_slice() == \"help\" {\n+            if lint_name == \"help\" {\n                 describe_lints = true;\n             } else {\n                 lint_opts.push((lint_name.replace(\"-\", \"_\").into_string(), level));\n@@ -727,9 +727,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let debug_map = debugging_opts_map();\n     for debug_flag in debug_flags.iter() {\n         let mut this_bit = 0;\n-        for tuple in debug_map.iter() {\n-            let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n-            if *name == debug_flag.as_slice() {\n+        for &(name, _, bit) in debug_map.iter() {\n+            if name == *debug_flag {\n                 this_bit = bit;\n                 break;\n             }\n@@ -749,7 +748,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     if !parse_only && !no_trans {\n         let unparsed_output_types = matches.opt_strs(\"emit\");\n         for unparsed_output_type in unparsed_output_types.iter() {\n-            for part in unparsed_output_type.as_slice().split(',') {\n+            for part in unparsed_output_type.split(',') {\n                 let output_type = match part.as_slice() {\n                     \"asm\"  => OutputTypeAssembly,\n                     \"ir\"   => OutputTypeLlvmAssembly,\n@@ -824,7 +823,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     }).collect();\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n-        let mut parts = s.as_slice().rsplitn(1, ':');\n+        let mut parts = s.rsplitn(1, ':');\n         let kind = parts.next().unwrap();\n         let (name, kind) = match (parts.next(), kind) {\n             (None, name) |\n@@ -875,7 +874,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut externs = HashMap::new();\n     for arg in matches.opt_strs(\"extern\").iter() {\n-        let mut parts = arg.as_slice().splitn(1, '=');\n+        let mut parts = arg.splitn(1, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n             None => early_error(\"--extern value must not be empty\"),\n@@ -925,7 +924,7 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateTy\n \n     let mut crate_types: Vec<CrateType> = Vec::new();\n     for unparsed_crate_type in list_list.iter() {\n-        for part in unparsed_crate_type.as_slice().split(',') {\n+        for part in unparsed_crate_type.split(',') {\n             let new_part = match part {\n                 \"lib\"       => default_lib_output(),\n                 \"rlib\"      => CrateTypeRlib,"}, {"sha": "e4d34e09d330a5cc64bc00e8c6ad4576fdbdcc63", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -257,7 +257,7 @@ pub fn build_session_(sopts: config::Options,\n \n     let can_print_warnings = sopts.lint_opts\n         .iter()\n-        .filter(|&&(ref key, _)| key.as_slice() == \"warnings\")\n+        .filter(|&&(ref key, _)| *key == \"warnings\")\n         .map(|&(_, ref level)| *level != lint::Allow)\n         .last()\n         .unwrap_or(true);"}, {"sha": "3895a1137267433b93468922e8aa041c5d2ee43d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=00f3c3f7a7058ac1b049810cffc2a8fa71ef7daa", "patch": "@@ -538,7 +538,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n-        s = s.as_slice().slice(0u, 32u).to_string();\n+        s = s.slice(0u, 32u).to_string();\n     }\n     return s;\n }"}]}