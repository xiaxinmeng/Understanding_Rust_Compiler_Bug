{"sha": "f9019b70865089e09507274075188f50b189a79d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MDE5YjcwODY1MDg5ZTA5NTA3Mjc0MDc1MTg4ZjUwYjE4OWE3OWQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-03-06T20:37:59Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-03-06T21:17:31Z"}, "message": "Move full configuration logic from `rustc_expand` to `rustc_builtin_macros`\n\nThis logic is applicable to two specific macros and not to the expansion infrastructure in general.", "tree": {"sha": "bb172419d76686f2b34d968f5cb26683ad225f52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb172419d76686f2b34d968f5cb26683ad225f52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9019b70865089e09507274075188f50b189a79d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9019b70865089e09507274075188f50b189a79d", "html_url": "https://github.com/rust-lang/rust/commit/f9019b70865089e09507274075188f50b189a79d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9019b70865089e09507274075188f50b189a79d/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dad6c25751f577c53bd36d09f033e1c245d0806", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dad6c25751f577c53bd36d09f033e1c245d0806", "html_url": "https://github.com/rust-lang/rust/commit/5dad6c25751f577c53bd36d09f033e1c245d0806"}], "stats": {"total": 360, "additions": 184, "deletions": 176}, "files": [{"sha": "8cf3be33e2046b2cc03eddf7fd5f0fb342071946", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 172, "deletions": 4, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/f9019b70865089e09507274075188f50b189a79d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9019b70865089e09507274075188f50b189a79d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=f9019b70865089e09507274075188f50b189a79d", "patch": "@@ -1,23 +1,29 @@\n use crate::util::check_builtin_macro_attribute;\n \n+use rustc_ast::mut_visit::{self, MutVisitor};\n+use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, AstLike};\n+use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_expand::config::StripUnconfigured;\n+use rustc_expand::configure;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use smallvec::SmallVec;\n \n-pub fn expand(\n+crate fn expand(\n     ecx: &mut ExtCtxt<'_>,\n     _span: Span,\n     meta_item: &ast::MetaItem,\n     item: Annotatable,\n ) -> Vec<Annotatable> {\n     check_builtin_macro_attribute(ecx, meta_item, sym::cfg_eval);\n \n-    let mut visitor =\n-        StripUnconfigured { sess: ecx.sess, features: ecx.ecfg.features, modified: false };\n+    let mut visitor = CfgEval {\n+        cfg: StripUnconfigured { sess: ecx.sess, features: ecx.ecfg.features, modified: false },\n+    };\n     let mut item = visitor.fully_configure(item);\n-    if visitor.modified {\n+    if visitor.cfg.modified {\n         // Erase the tokens if cfg-stripping modified the item\n         // This will cause us to synthesize fake tokens\n         // when `nt_to_tokenstream` is called on this item.\n@@ -27,3 +33,165 @@ pub fn expand(\n     }\n     vec![item]\n }\n+\n+crate struct CfgEval<'a> {\n+    pub cfg: StripUnconfigured<'a>,\n+}\n+\n+impl CfgEval<'_> {\n+    fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n+        self.cfg.configure(node)\n+    }\n+\n+    fn configure_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n+        let ast::ForeignMod { unsafety: _, abi: _, items } = foreign_mod;\n+        items.flat_map_in_place(|item| self.configure(item));\n+    }\n+\n+    fn configure_variant_data(&mut self, vdata: &mut ast::VariantData) {\n+        match vdata {\n+            ast::VariantData::Struct(fields, ..) | ast::VariantData::Tuple(fields, _) => {\n+                fields.flat_map_in_place(|field| self.configure(field))\n+            }\n+            ast::VariantData::Unit(_) => {}\n+        }\n+    }\n+\n+    fn configure_item_kind(&mut self, item: &mut ast::ItemKind) {\n+        match item {\n+            ast::ItemKind::Struct(def, _generics) | ast::ItemKind::Union(def, _generics) => {\n+                self.configure_variant_data(def)\n+            }\n+            ast::ItemKind::Enum(ast::EnumDef { variants }, _generics) => {\n+                variants.flat_map_in_place(|variant| self.configure(variant));\n+                for variant in variants {\n+                    self.configure_variant_data(&mut variant.data);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn configure_expr_kind(&mut self, expr_kind: &mut ast::ExprKind) {\n+        match expr_kind {\n+            ast::ExprKind::Match(_m, arms) => {\n+                arms.flat_map_in_place(|arm| self.configure(arm));\n+            }\n+            ast::ExprKind::Struct(_path, fields, _base) => {\n+                fields.flat_map_in_place(|field| self.configure(field));\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn configure_pat(&mut self, pat: &mut P<ast::Pat>) {\n+        if let ast::PatKind::Struct(_path, fields, _etc) = &mut pat.kind {\n+            fields.flat_map_in_place(|field| self.configure(field));\n+        }\n+    }\n+\n+    fn configure_fn_decl(&mut self, fn_decl: &mut ast::FnDecl) {\n+        fn_decl.inputs.flat_map_in_place(|arg| self.configure(arg));\n+    }\n+\n+    crate fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n+        // Since the item itself has already been configured by the InvocationCollector,\n+        // we know that fold result vector will contain exactly one element\n+        match item {\n+            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n+            Annotatable::TraitItem(item) => {\n+                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n+            }\n+            Annotatable::ImplItem(item) => {\n+                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n+            }\n+            Annotatable::ForeignItem(item) => {\n+                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n+            }\n+            Annotatable::Stmt(stmt) => {\n+                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n+            }\n+            Annotatable::Expr(mut expr) => Annotatable::Expr({\n+                self.visit_expr(&mut expr);\n+                expr\n+            }),\n+            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n+            Annotatable::Field(field) => {\n+                Annotatable::Field(self.flat_map_field(field).pop().unwrap())\n+            }\n+            Annotatable::FieldPat(fp) => {\n+                Annotatable::FieldPat(self.flat_map_field_pattern(fp).pop().unwrap())\n+            }\n+            Annotatable::GenericParam(param) => {\n+                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n+            }\n+            Annotatable::Param(param) => {\n+                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n+            }\n+            Annotatable::StructField(sf) => {\n+                Annotatable::StructField(self.flat_map_struct_field(sf).pop().unwrap())\n+            }\n+            Annotatable::Variant(v) => {\n+                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n+            }\n+        }\n+    }\n+}\n+\n+impl MutVisitor for CfgEval<'_> {\n+    fn visit_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n+        self.configure_foreign_mod(foreign_mod);\n+        mut_visit::noop_visit_foreign_mod(foreign_mod, self);\n+    }\n+\n+    fn visit_item_kind(&mut self, item: &mut ast::ItemKind) {\n+        self.configure_item_kind(item);\n+        mut_visit::noop_visit_item_kind(item, self);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(expr);\n+        self.configure_expr_kind(&mut expr.kind);\n+        mut_visit::noop_visit_expr(expr, self);\n+    }\n+\n+    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        let mut expr = configure!(self, expr);\n+        self.configure_expr_kind(&mut expr.kind);\n+        mut_visit::noop_visit_expr(&mut expr, self);\n+        Some(expr)\n+    }\n+\n+    fn flat_map_generic_param(\n+        &mut self,\n+        param: ast::GenericParam,\n+    ) -> SmallVec<[ast::GenericParam; 1]> {\n+        mut_visit::noop_flat_map_generic_param(configure!(self, param), self)\n+    }\n+\n+    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+        mut_visit::noop_flat_map_stmt(configure!(self, stmt), self)\n+    }\n+\n+    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        mut_visit::noop_flat_map_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        mut_visit::noop_flat_map_assoc_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        mut_visit::noop_flat_map_assoc_item(configure!(self, item), self)\n+    }\n+\n+    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n+        self.configure_pat(pat);\n+        mut_visit::noop_visit_pat(pat, self)\n+    }\n+\n+    fn visit_fn_decl(&mut self, mut fn_decl: &mut P<ast::FnDecl>) {\n+        self.configure_fn_decl(&mut fn_decl);\n+        mut_visit::noop_visit_fn_decl(fn_decl, self);\n+    }\n+}"}, {"sha": "48b1dddfdd1e81e46a3b64adec34964c3da9cdb1", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9019b70865089e09507274075188f50b189a79d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9019b70865089e09507274075188f50b189a79d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=f9019b70865089e09507274075188f50b189a79d", "patch": "@@ -1,3 +1,5 @@\n+use crate::cfg_eval::CfgEval;\n+\n use rustc_ast::{self as ast, token, AstLike, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n@@ -52,10 +54,11 @@ impl MultiItemModifier for Expander {\n         // FIXME: Try to cache intermediate results to avoid collecting same paths multiple times.\n         match ecx.resolver.resolve_derives(ecx.current_expansion.id, derives, ecx.force_mode) {\n             Ok(()) => {\n-                let mut visitor =\n-                    StripUnconfigured { sess, features: ecx.ecfg.features, modified: false };\n+                let mut visitor = CfgEval {\n+                    cfg: StripUnconfigured { sess, features: ecx.ecfg.features, modified: false },\n+                };\n                 let mut item = visitor.fully_configure(item);\n-                if visitor.modified {\n+                if visitor.cfg.modified {\n                     // Erase the tokens if cfg-stripping modified the item\n                     // This will cause us to synthesize fake tokens\n                     // when `nt_to_tokenstream` is called on this item."}, {"sha": "a23731cf309a41a7749ad778779e5c31a6013d56", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 6, "deletions": 169, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/f9019b70865089e09507274075188f50b189a79d/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9019b70865089e09507274075188f50b189a79d/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=f9019b70865089e09507274075188f50b189a79d", "patch": "@@ -1,8 +1,5 @@\n //! Conditional compilation stripping.\n \n-use crate::base::Annotatable;\n-\n-use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, LazyTokenStream, Spacing, TokenStream, TokenTree};\n@@ -22,8 +19,6 @@ use rustc_span::edition::{Edition, ALL_EDITIONS};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n-use smallvec::SmallVec;\n-\n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n     pub sess: &'a Session,\n@@ -272,7 +267,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives compiler warnings if any `cfg_attr` does not contain any\n     /// attributes and is in the original source code. Gives compiler errors if\n     /// the syntax of any `cfg_attr` is incorrect.\n-    pub fn process_cfg_attrs<T: AstLike>(&mut self, node: &mut T) {\n+    fn process_cfg_attrs<T: AstLike>(&mut self, node: &mut T) {\n         node.visit_attrs(|attrs| {\n             attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         });\n@@ -387,7 +382,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// Determines if a node with the given attributes should be included in this configuration.\n-    pub fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n+    fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n             if !is_cfg(self.sess, attr) {\n                 return true;\n@@ -427,16 +422,8 @@ impl<'a> StripUnconfigured<'a> {\n         })\n     }\n \n-    /// Visit attributes on expression and statements (but not attributes on items in blocks).\n-    fn visit_expr_attrs(&mut self, attrs: &[Attribute]) {\n-        // flag the offending attributes\n-        for attr in attrs.iter() {\n-            self.maybe_emit_expr_attr_err(attr);\n-        }\n-    }\n-\n     /// If attributes are not allowed on expressions, emit an error for `attr`\n-    pub fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n+    crate fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map_or(true, |features| features.stmt_expr_attributes) {\n             let mut err = feature_err(\n                 &self.sess.parse_sess,\n@@ -453,49 +440,10 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    pub fn configure_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n-        let ast::ForeignMod { unsafety: _, abi: _, items } = foreign_mod;\n-        items.flat_map_in_place(|item| self.configure(item));\n-    }\n-\n-    fn configure_variant_data(&mut self, vdata: &mut ast::VariantData) {\n-        match vdata {\n-            ast::VariantData::Struct(fields, ..) | ast::VariantData::Tuple(fields, _) => {\n-                fields.flat_map_in_place(|field| self.configure(field))\n-            }\n-            ast::VariantData::Unit(_) => {}\n-        }\n-    }\n-\n-    pub fn configure_item_kind(&mut self, item: &mut ast::ItemKind) {\n-        match item {\n-            ast::ItemKind::Struct(def, _generics) | ast::ItemKind::Union(def, _generics) => {\n-                self.configure_variant_data(def)\n-            }\n-            ast::ItemKind::Enum(ast::EnumDef { variants }, _generics) => {\n-                variants.flat_map_in_place(|variant| self.configure(variant));\n-                for variant in variants {\n-                    self.configure_variant_data(&mut variant.data);\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    pub fn configure_expr_kind(&mut self, expr_kind: &mut ast::ExprKind) {\n-        match expr_kind {\n-            ast::ExprKind::Match(_m, arms) => {\n-                arms.flat_map_in_place(|arm| self.configure(arm));\n-            }\n-            ast::ExprKind::Struct(_path, fields, _base) => {\n-                fields.flat_map_in_place(|field| self.configure(field));\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     pub fn configure_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.visit_expr_attrs(expr.attrs());\n+        for attr in expr.attrs.iter() {\n+            self.maybe_emit_expr_attr_err(attr);\n+        }\n \n         // If an expr is valid to cfg away it will have been removed by the\n         // outer stmt or expression folder before descending in here.\n@@ -511,117 +459,6 @@ impl<'a> StripUnconfigured<'a> {\n \n         self.process_cfg_attrs(expr)\n     }\n-\n-    pub fn configure_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        if let ast::PatKind::Struct(_path, fields, _etc) = &mut pat.kind {\n-            fields.flat_map_in_place(|field| self.configure(field));\n-        }\n-    }\n-\n-    pub fn configure_fn_decl(&mut self, fn_decl: &mut ast::FnDecl) {\n-        fn_decl.inputs.flat_map_in_place(|arg| self.configure(arg));\n-    }\n-\n-    pub fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n-        // Since the item itself has already been configured by the InvocationCollector,\n-        // we know that fold result vector will contain exactly one element\n-        match item {\n-            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n-            Annotatable::TraitItem(item) => {\n-                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n-            }\n-            Annotatable::ImplItem(item) => {\n-                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n-            }\n-            Annotatable::ForeignItem(item) => {\n-                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n-            }\n-            Annotatable::Stmt(stmt) => {\n-                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n-            }\n-            Annotatable::Expr(mut expr) => Annotatable::Expr({\n-                self.visit_expr(&mut expr);\n-                expr\n-            }),\n-            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n-            Annotatable::Field(field) => {\n-                Annotatable::Field(self.flat_map_field(field).pop().unwrap())\n-            }\n-            Annotatable::FieldPat(fp) => {\n-                Annotatable::FieldPat(self.flat_map_field_pattern(fp).pop().unwrap())\n-            }\n-            Annotatable::GenericParam(param) => {\n-                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n-            }\n-            Annotatable::Param(param) => {\n-                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n-            }\n-            Annotatable::StructField(sf) => {\n-                Annotatable::StructField(self.flat_map_struct_field(sf).pop().unwrap())\n-            }\n-            Annotatable::Variant(v) => {\n-                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> MutVisitor for StripUnconfigured<'a> {\n-    fn visit_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n-        self.configure_foreign_mod(foreign_mod);\n-        noop_visit_foreign_mod(foreign_mod, self);\n-    }\n-\n-    fn visit_item_kind(&mut self, item: &mut ast::ItemKind) {\n-        self.configure_item_kind(item);\n-        noop_visit_item_kind(item, self);\n-    }\n-\n-    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.configure_expr(expr);\n-        self.configure_expr_kind(&mut expr.kind);\n-        noop_visit_expr(expr, self);\n-    }\n-\n-    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let mut expr = configure!(self, expr);\n-        self.configure_expr_kind(&mut expr.kind);\n-        noop_visit_expr(&mut expr, self);\n-        Some(expr)\n-    }\n-\n-    fn flat_map_generic_param(\n-        &mut self,\n-        param: ast::GenericParam,\n-    ) -> SmallVec<[ast::GenericParam; 1]> {\n-        noop_flat_map_generic_param(configure!(self, param), self)\n-    }\n-\n-    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n-        noop_flat_map_stmt(configure!(self, stmt), self)\n-    }\n-\n-    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        noop_flat_map_item(configure!(self, item), self)\n-    }\n-\n-    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        noop_flat_map_assoc_item(configure!(self, item), self)\n-    }\n-\n-    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        noop_flat_map_assoc_item(configure!(self, item), self)\n-    }\n-\n-    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        self.configure_pat(pat);\n-        noop_visit_pat(pat, self)\n-    }\n-\n-    fn visit_fn_decl(&mut self, mut fn_decl: &mut P<ast::FnDecl>) {\n-        self.configure_fn_decl(&mut fn_decl);\n-        noop_visit_fn_decl(fn_decl, self);\n-    }\n }\n \n fn is_cfg(sess: &Session, attr: &Attribute) -> bool {"}]}