{"sha": "963dab5dcb9c348bb2631998702695de62916b31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2M2RhYjVkY2I5YzM0OGJiMjYzMTk5ODcwMjY5NWRlNjI5MTZiMzE=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-29T12:59:08Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:10Z"}, "message": "marking on both input and output from macros. nice shiny new test case framework", "tree": {"sha": "069c35a4ac618f9a30628ecf889d012b6c4943dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/069c35a4ac618f9a30628ecf889d012b6c4943dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/963dab5dcb9c348bb2631998702695de62916b31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/963dab5dcb9c348bb2631998702695de62916b31", "html_url": "https://github.com/rust-lang/rust/commit/963dab5dcb9c348bb2631998702695de62916b31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/963dab5dcb9c348bb2631998702695de62916b31/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f68aa459ea981b08a41fa9650696414de64eabd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f68aa459ea981b08a41fa9650696414de64eabd4", "html_url": "https://github.com/rust-lang/rust/commit/f68aa459ea981b08a41fa9650696414de64eabd4"}], "stats": {"total": 304, "additions": 275, "deletions": 29}, "files": [{"sha": "63dd8231aa079b1866ad71705c16117db6304858", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 275, "deletions": 29, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/963dab5dcb9c348bb2631998702695de62916b31/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963dab5dcb9c348bb2631998702695de62916b31/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=963dab5dcb9c348bb2631998702695de62916b31", "patch": "@@ -67,10 +67,10 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                     span: exp_span,\n                                 },\n                             });\n-\n                             let fm = fresh_mark();\n-                            let marked_tts = mark_tts(*tts,fm);\n-                            let expanded = match expandfun(cx, mac.span, marked_tts) {\n+                            // mark before:\n+                            let marked_before = mark_tts(*tts,fm);\n+                            let expanded = match expandfun(cx, mac.span, marked_before) {\n                                 MRExpr(e) => e,\n                                 MRAny(expr_maker,_,_) => expr_maker(),\n                                 _ => {\n@@ -83,10 +83,12 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                     )\n                                 }\n                             };\n+                            // mark after:\n+                            let marked_after = mark_expr(expanded,fm);\n \n                             //keep going, outside-in\n                             let fully_expanded =\n-                                fld.fold_expr(expanded).node.clone();\n+                                fld.fold_expr(marked_after).node.clone();\n                             cx.bt_pop();\n \n                             (fully_expanded, s)\n@@ -262,12 +264,6 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n     }\n }\n \n-// apply a fresh mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts : &[token_tree], m : Mrk) -> ~[token_tree] {\n-    fold_tts(tts,new_ident_marker(m))\n-}\n-\n-\n // This is a secondary mechanism for invoking syntax extensions on items:\n // \"decorator\" attributes, such as #[auto_encode]. These are invoked by an\n // attribute prefixing an item, and are interpreted by feeding the item\n@@ -315,7 +311,6 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n     ast::_mod { items: new_items, ..module_ }\n }\n \n-\n // eval $e with a new exts frame:\n macro_rules! with_exts_frame (\n     ($extsboxexpr:expr,$macros_escape:expr,$e:expr) =>\n@@ -381,6 +376,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n \n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n+    let fm = fresh_mark();\n     let expanded = match (*extsbox).find(&extname.name) {\n         None => cx.span_fatal(pth.span,\n                               fmt!(\"macro undefined: '%s!'\", extnamestr)),\n@@ -399,7 +395,11 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                     span: span\n                 }\n             });\n-             expander(cx, it.span, tts)\n+            // mark before expansion:\n+            let marked_tts = mark_tts(tts,fm);\n+            // mark after expansion:\n+            // RIGHT HERE: can't apply mark_item to MacResult ... :(\n+            expander(cx, it.span, marked_tts)\n         }\n         Some(@SE(IdentTT(expander, span))) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n@@ -414,18 +414,24 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                     span: span\n                 }\n             });\n-            expander(cx, it.span, it.ident, tts)\n+            let fm = fresh_mark();\n+            // mark before expansion:\n+            let marked_tts = mark_tts(tts,fm);\n+        expander(cx, it.span, it.ident, marked_tts)\n         }\n         _ => cx.span_fatal(\n             it.span, fmt!(\"%s! is not legal in item position\", extnamestr))\n     };\n \n     let maybe_it = match expanded {\n-        MRItem(it) => fld.fold_item(it),\n+        MRItem(it) => mark_item(it,fm).chain(|i| {fld.fold_item(i)}),\n         MRExpr(_) => cx.span_fatal(pth.span,\n                                    fmt!(\"expr macro in item position: %s\", extnamestr)),\n-        MRAny(_, item_maker, _) => item_maker().chain(|i| {fld.fold_item(i)}),\n+        MRAny(_, item_maker, _) => item_maker().chain(|i| {mark_item(i,fm)})\n+                                      .chain(|i| {fld.fold_item(i)}),\n         MRDef(ref mdef) => {\n+            // yikes... no idea how to apply the mark to this. I'm afraid\n+            // we're going to have to wait-and-see on this one.\n             insert_macro(*extsbox,intern(mdef.name), @SE((*mdef).ext));\n             None\n         }\n@@ -460,6 +466,8 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    orig: @fn(&Stmt_, Span, @ast_fold)\n                              -> (Option<Stmt_>, Span))\n                 -> (Option<Stmt_>, Span) {\n+    // why the copying here and not in expand_expr?\n+    // looks like classic changed-in-only-one-place\n     let (mac, pth, tts, semi) = match *s {\n         StmtMac(ref mac, semi) => {\n             match mac.node {\n@@ -487,7 +495,10 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 call_site: sp,\n                 callee: NameAndSpan { name: extnamestr, span: exp_span }\n             });\n-            let expanded = match expandfun(cx, mac.span, tts) {\n+            let fm = fresh_mark();\n+            // mark before expansion:\n+            let marked_tts = mark_tts(tts,fm);\n+            let expanded = match expandfun(cx, mac.span, marked_tts) {\n                 MRExpr(e) =>\n                     @codemap::Spanned { node: StmtExpr(e, cx.next_id()),\n                                     span: e.span},\n@@ -496,9 +507,10 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                     pth.span,\n                     fmt!(\"non-stmt macro in stmt pos: %s\", extnamestr))\n             };\n+            let marked_after = mark_stmt(expanded,fm);\n \n             //keep going, outside-in\n-            let fully_expanded = match fld.fold_stmt(expanded) {\n+            let fully_expanded = match fld.fold_stmt(marked_after) {\n                 Some(stmt) => {\n                     let fully_expanded = &stmt.node;\n                     cx.bt_pop();\n@@ -736,6 +748,132 @@ impl Visitor<()> for NewNameFinderContext {\n     }\n }\n \n+// a visitor that extracts the path exprs from\n+// a crate/expression/whatever and puts them in a mutable\n+// array (passed in to the traversal)\n+#[deriving(Clone)]\n+struct NewPathExprFinderContext {\n+    path_accumulator: @mut ~[ast::Path],\n+}\n+\n+\n+// XXX : YIKES a lot of boilerplate again....\n+impl Visitor<()> for NewPathExprFinderContext {\n+\n+    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n+        match *expr {\n+            ast::Expr{id:_,span:_,node:ast::ExprPath(ref p)} => {\n+                self.path_accumulator.push(p.clone());\n+                // not calling visit_path, should be fine.\n+            }\n+            _ => visit::walk_expr(self,expr,())\n+        }\n+    }\n+\n+\n+    // XXX: Methods below can become default methods.\n+\n+    fn visit_pat(&mut self, pattern: @ast::Pat, _: ()) {\n+        visit::walk_pat(self,pattern,())\n+    }\n+\n+    fn visit_mod(&mut self, module: &ast::_mod, _: Span, _: NodeId, _: ()) {\n+        visit::walk_mod(self, module, ())\n+    }\n+\n+    fn visit_view_item(&mut self, view_item: &ast::view_item, _: ()) {\n+        visit::walk_view_item(self, view_item, ())\n+    }\n+\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        visit::walk_item(self, item, ())\n+    }\n+\n+    fn visit_foreign_item(&mut self,\n+                          foreign_item: @ast::foreign_item,\n+                          _: ()) {\n+        visit::walk_foreign_item(self, foreign_item, ())\n+    }\n+\n+    fn visit_local(&mut self, local: @ast::Local, _: ()) {\n+        visit::walk_local(self, local, ())\n+    }\n+\n+    fn visit_block(&mut self, block: &ast::Block, _: ()) {\n+        visit::walk_block(self, block, ())\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: @ast::Stmt, _: ()) {\n+        visit::walk_stmt(self, stmt, ())\n+    }\n+\n+    fn visit_arm(&mut self, arm: &ast::Arm, _: ()) {\n+        visit::walk_arm(self, arm, ())\n+    }\n+\n+    fn visit_decl(&mut self, decl: @ast::Decl, _: ()) {\n+        visit::walk_decl(self, decl, ())\n+    }\n+\n+    fn visit_expr_post(&mut self, _: @ast::Expr, _: ()) {\n+        // Empty!\n+    }\n+\n+    fn visit_ty(&mut self, typ: &ast::Ty, _: ()) {\n+        visit::walk_ty(self, typ, ())\n+    }\n+\n+    fn visit_generics(&mut self, generics: &ast::Generics, _: ()) {\n+        visit::walk_generics(self, generics, ())\n+    }\n+\n+    fn visit_fn(&mut self,\n+                function_kind: &visit::fn_kind,\n+                function_declaration: &ast::fn_decl,\n+                block: &ast::Block,\n+                span: Span,\n+                node_id: NodeId,\n+                _: ()) {\n+        visit::walk_fn(self,\n+                        function_kind,\n+                        function_declaration,\n+                        block,\n+                        span,\n+                        node_id,\n+                        ())\n+    }\n+\n+    fn visit_ty_method(&mut self, ty_method: &ast::TypeMethod, _: ()) {\n+        visit::walk_ty_method(self, ty_method, ())\n+    }\n+\n+    fn visit_trait_method(&mut self,\n+                          trait_method: &ast::trait_method,\n+                          _: ()) {\n+        visit::walk_trait_method(self, trait_method, ())\n+    }\n+\n+    fn visit_struct_def(&mut self,\n+                        struct_def: @ast::struct_def,\n+                        ident: Ident,\n+                        generics: &ast::Generics,\n+                        node_id: NodeId,\n+                        _: ()) {\n+        visit::walk_struct_def(self,\n+                                struct_def,\n+                                ident,\n+                                generics,\n+                                node_id,\n+                                ())\n+    }\n+\n+    fn visit_struct_field(&mut self,\n+                          struct_field: @ast::struct_field,\n+                          _: ()) {\n+        visit::walk_struct_field(self, struct_field, ())\n+    }\n+}\n+\n // return a visitor that extracts the pat_ident paths\n // from a given pattern and puts them in a mutable\n // array (passed in to the traversal)\n@@ -746,6 +884,16 @@ pub fn new_name_finder(idents: @mut ~[ast::Ident]) -> @mut Visitor<()> {\n     context as @mut Visitor<()>\n }\n \n+// return a visitor that extracts the paths\n+// from a given pattern and puts them in a mutable\n+// array (passed in to the traversal)\n+pub fn new_path_finder(paths: @mut ~[ast::Path]) -> @mut Visitor<()> {\n+    let context = @mut NewPathExprFinderContext {\n+        path_accumulator: paths,\n+    };\n+    context as @mut Visitor<()>\n+}\n+\n // given a mutable list of renames, return a tree-folder that applies those\n // renames.\n // FIXME #4536: currently pub to allow testing\n@@ -1295,7 +1443,6 @@ pub fn new_ident_renamer(from: ast::Ident,\n     }\n }\n \n-\n // update the ctxts in a path to get a mark node\n pub fn new_ident_marker(mark: Mrk) ->\n     @fn(ast::Ident)->ast::Ident {\n@@ -1319,20 +1466,42 @@ pub fn new_ident_resolver() ->\n     }\n }\n \n+// apply a given mark to the given token trees. Used prior to expansion of a macro.\n+fn mark_tts(tts : &[token_tree], m : Mrk) -> ~[token_tree] {\n+    fold_tts(tts,new_ident_marker(m))\n+}\n+\n+// apply a given mark to the given expr. Used following the expansion of a macro.\n+fn mark_expr(expr : @ast::Expr, m : Mrk) -> @ast::Expr {\n+    fun_to_ident_folder(new_ident_marker(m)).fold_expr(expr)\n+}\n+\n+// apply a given mark to the given stmt. Used following the expansion of a macro.\n+fn mark_stmt(expr : &ast::Stmt, m : Mrk) -> @ast::Stmt {\n+    fun_to_ident_folder(new_ident_marker(m)).fold_stmt(expr).unwrap()\n+}\n+\n+// apply a given mark to the given item. Used following the expansion of a macro.\n+fn mark_item(expr : @ast::item, m : Mrk) -> Option<@ast::item> {\n+    fun_to_ident_folder(new_ident_marker(m)).fold_item(expr)\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord, EMPTY_CTXT};\n-    use ast_util::{get_sctable, new_rename};\n+    use ast_util::{get_sctable, mtwt_resolve, new_rename};\n     use codemap;\n     use codemap::Spanned;\n     use parse;\n     use parse::token::{gensym, intern, get_ident_interner};\n     use print::pprust;\n     use std;\n+    use std::vec;\n     use util::parser_testing::{string_to_crate_and_sess, string_to_item, string_to_pat};\n     use util::parser_testing::{strs_to_idents};\n+    use visit;\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n@@ -1478,30 +1647,107 @@ mod test {\n         //pprust::to_str(&resolved_ast,fake_print_crate,get_ident_interner())\n     //}\n \n+    // renaming tests expand a crate and then check that the bindings match\n+    // the right varrefs. The specification of the test case includes the\n+    // text of the crate, and also an array of arrays.  Each element in the\n+    // outer array corresponds to a binding in the traversal of the AST\n+    // induced by visit.  Each of these arrays contains a list of indexes,\n+    // interpreted as the varrefs in the varref traversal that this binding\n+    // should match.  So, for instance, in a program with two bindings and\n+    // three varrefs, the array ~[~[1,2],~[0]] would indicate that the first\n+    // binding should match the second two varrefs, and the second binding\n+    // should match the first varref.\n+    //\n+    // The comparisons are done post-mtwt-resolve, so we're comparing renamed\n+    // names; differences in marks don't matter any more.\n+    type renaming_test = (&'static str, ~[~[uint]]);\n+\n     #[test]\n     fn automatic_renaming () {\n         // need some other way to test these...\n-        let teststrs =\n+        let tests : ~[renaming_test] =\n             ~[// b & c should get new names throughout, in the expr too:\n-                @\"fn a() -> int { let b = 13; let c = b; b+c }\",\n+                (\"fn a() -> int { let b = 13; let c = b; b+c }\",\n+                 ~[~[0,1],~[2]]),\n                 // both x's should be renamed (how is this causing a bug?)\n-                @\"fn main () {let x : int = 13;x;}\",\n-                // the use of b before the + should be renamed, the other one not:\n-                @\"macro_rules! f (($x:ident) => ($x + b)) fn a() -> int { let b = 13; f!(b)}\",\n+                (\"fn main () {let x : int = 13;x;}\",\n+                 ~[~[0]]),\n+                // the use of b after the + should be renamed, the other one not:\n+                (\"macro_rules! f (($x:ident) => (b + $x)) fn a() -> int { let b = 13; f!(b)}\",\n+                 ~[~[1]]),\n                 // the b before the plus should not be renamed (requires marks)\n-                @\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})) fn a() -> int { f!(b)}\",\n+                (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})) fn a() -> int { f!(b)}\",\n+                 ~[~[1]]),\n+                // the marks going in and out of letty should cancel, allowing that $x to\n+                // capture the one following the semicolon.\n+                // this was an awesome test case, and caught a *lot* of bugs.\n+                (\"macro_rules! letty(($x:ident) => (let $x = 15;))\n+                  macro_rules! user(($x:ident) => ({letty!($x); $x}))\n+                  fn main() -> int {user!(z)}\",\n+                 ~[~[0]])\n                 // FIXME #6994: the next string exposes the bug referred to in issue 6994, so I'm\n                 // commenting it out.\n                 // the z flows into and out of two macros (g & f) along one path, and one (just g) along the\n                 // other, so the result of the whole thing should be \"let z_123 = 3; z_123\"\n-                //@\"macro_rules! g (($x:ident) => ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}))\n+                //\"macro_rules! g (($x:ident) => ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}))\n                 //   fn a(){g!(z)}\"\n                 // create a really evil test case where a $x appears inside a binding of $x but *shouldnt*\n                 // bind because it was inserted by a different macro....\n             ];\n-        for s in teststrs.iter() {\n-            // we need regexps to test these!\n-            //std::io::println(expand_and_resolve_and_pretty_print(*s));\n+        for s in tests.iter() {\n+            run_renaming_test(s);\n+        }\n+    }\n+\n+\n+    fn run_renaming_test(t : &renaming_test) {\n+        let (teststr, bound_connections) = match *t {\n+            (ref str,ref conns) => (str.to_managed(), conns.clone())\n+        };\n+        let cr = expand_crate_str(teststr.to_managed());\n+        // find the bindings:\n+        let bindings = @mut ~[];\n+        visit::walk_crate(&mut new_name_finder(bindings),cr,());\n+        // find the varrefs:\n+        let varrefs = @mut ~[];\n+        visit::walk_crate(&mut new_path_finder(varrefs),cr,());\n+        // must be one check clause for each binding:\n+        assert_eq!(bindings.len(),bound_connections.len());\n+        for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n+            let binding_name = mtwt_resolve(bindings[binding_idx]);\n+            // shouldmatch can't name varrefs that don't exist:\n+            assert!((shouldmatch.len() == 0) ||\n+                    (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n+            for (idx,varref) in varrefs.iter().enumerate() {\n+                if shouldmatch.contains(&idx) {\n+                    // it should be a path of length 1, and it should\n+                    // be free-identifier=? to the given binding\n+                    assert_eq!(varref.segments.len(),1);\n+                    let varref_name = mtwt_resolve(varref.segments[0].identifier);\n+                    if (!(varref_name==binding_name)){\n+                        std::io::println(\"uh oh, should match but doesn't:\");\n+                        std::io::println(fmt!(\"varref: %?\",varref));\n+                        std::io::println(fmt!(\"binding: %?\", bindings[binding_idx]));\n+                        let table = get_sctable();\n+                        std::io::println(\"SC table:\");\n+                        for (idx,val) in table.table.iter().enumerate() {\n+                            std::io::println(fmt!(\"%4u : %?\",idx,val));\n+                        }\n+                    }\n+                    assert_eq!(varref_name,binding_name);\n+                } else {\n+                    let fail = (varref.segments.len() == 1)\n+                        && (mtwt_resolve(varref.segments[0].identifier) == binding_name);\n+                    // temp debugging:\n+                    if (fail) {\n+                        std::io::println(\"uh oh, matches but shouldn't:\");\n+                        std::io::println(fmt!(\"varref: %?\",varref));\n+                        std::io::println(fmt!(\"binding: %?\", bindings[binding_idx]));\n+                        std::io::println(fmt!(\"sc_table: %?\",get_sctable()));\n+                    }\n+                    assert!(!fail);\n+                }\n+            }\n         }\n     }\n "}]}