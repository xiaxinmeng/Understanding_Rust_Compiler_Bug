{"sha": "db7494680331100f16620d694e57203d1ced50c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNzQ5NDY4MDMzMTEwMGYxNjYyMGQ2OTRlNTcyMDNkMWNlZDUwYzc=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-09T13:31:41Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-09T17:01:24Z"}, "message": "Rollup merge of #53106 - RalfJung:ordering, r=stjepang\n\natomic ordering docs\n\nDiscussion in https://github.com/rust-lang/rfcs/pull/2503 revealed that this could be improved. I hope this helps.", "tree": {"sha": "71fda73f0b90d51157b2d9d2cfd8837ec80c6bb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71fda73f0b90d51157b2d9d2cfd8837ec80c6bb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db7494680331100f16620d694e57203d1ced50c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAltsc2QACgkQ/vbIBR0O\nATy8qg/9HibjYn6KKYC2I3JJIys84Omci6YZuT967WjDKsbMgDEPbpqSzl6BmFeo\nszb+tatLJBTvQwqRCo2n+wWVYUtHfn4gadWC11/dGA/eTMi3DhRFqw5SqGC6nrA0\nZzwdeXk+faHnjo45tZw3yIfu9o0FeQRXEs7+2rI0bjAldhDh2mGOmegmiYhV649h\nBrWjTTvOvw38OcLNNT2++hwGNLcRNbQV8ZNj9r7/JoAiNj5I0poDmtzP6g7Nuhnr\nJw4vuV1U01nurZeZVYxSyRAJeZyDwdbYR2U55n+zgnlgExp5dginNHk9DVtgzf/D\nzGM6H2K9V23mOZL7Wt89MzDOAuoMgFxHScJaf01xNfLPzxnWGnMYV7TmF6Gkjbcr\nUVK1R5ZnGV0gQsPewknQEHdbjISizyuH52d4d8tk+f3HPaPo+iP8ItFV3q6zes8m\n7bXM1Q/NVs9YPOjpR1DTDKZfqvubIrlMQEu677nncAgwQzY8AmfBrTq7qPZR9mnc\nT+Sy9Vn0y54IRjJWAXCvMQ7xunXkv9azfIucumWX4owahSRP1vrQggbTyaLEeNzi\ntwfiBkaW6OjSB+gBvwvgE1rxEaZD1TZKF/KH/kBB/8/RGmP4cFFjxohouwm68nhD\nXGaBdwR2qi42j/A2zavU94oviKGJxzp3vi54lgjALP44vDNjKt8=\n=+DyX\n-----END PGP SIGNATURE-----", "payload": "tree 71fda73f0b90d51157b2d9d2cfd8837ec80c6bb9\nparent 8188f12aaab8b650a13a93f71cf8d0647aa522f7\nparent 6a018a03dfcffef05feec0bf2e5fdba6b965ca1b\nauthor kennytm <kennytm@gmail.com> 1533821501 +0800\ncommitter kennytm <kennytm@gmail.com> 1533834084 +0800\n\nRollup merge of #53106 - RalfJung:ordering, r=stjepang\n\natomic ordering docs\n\nDiscussion in https://github.com/rust-lang/rfcs/pull/2503 revealed that this could be improved. I hope this helps.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db7494680331100f16620d694e57203d1ced50c7", "html_url": "https://github.com/rust-lang/rust/commit/db7494680331100f16620d694e57203d1ced50c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db7494680331100f16620d694e57203d1ced50c7/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8188f12aaab8b650a13a93f71cf8d0647aa522f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8188f12aaab8b650a13a93f71cf8d0647aa522f7", "html_url": "https://github.com/rust-lang/rust/commit/8188f12aaab8b650a13a93f71cf8d0647aa522f7"}, {"sha": "6a018a03dfcffef05feec0bf2e5fdba6b965ca1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a018a03dfcffef05feec0bf2e5fdba6b965ca1b", "html_url": "https://github.com/rust-lang/rust/commit/6a018a03dfcffef05feec0bf2e5fdba6b965ca1b"}], "stats": {"total": 401, "additions": 327, "deletions": 74}, "files": [{"sha": "5bb713f5767411022c1c18a4f119512241f34aec", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 327, "deletions": 74, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/db7494680331100f16620d694e57203d1ced50c7/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7494680331100f16620d694e57203d1ced50c7/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=db7494680331100f16620d694e57203d1ced50c7", "patch": "@@ -29,7 +29,7 @@\n //!\n //! [`Ordering`]: enum.Ordering.html\n //!\n-//! [1]: http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n+//! [1]: https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n //! [2]: ../../../nomicon/atomics.html\n //!\n //! Atomic variables are safe to share between threads (they implement [`Sync`])\n@@ -178,7 +178,7 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// \"relaxed\" atomics allow all reorderings.\n ///\n /// Rust's memory orderings are [the same as\n-/// LLVM's](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n+/// LLVM's](https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n ///\n /// For more information see the [nomicon].\n ///\n@@ -190,35 +190,70 @@ pub enum Ordering {\n     ///\n     /// Corresponds to LLVM's [`Monotonic`] ordering.\n     ///\n-    /// [`Monotonic`]: http://llvm.org/docs/Atomics.html#monotonic\n+    /// [`Monotonic`]: https://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n-    /// When coupled with a store, all previous writes become visible\n-    /// to the other threads that perform a load with [`Acquire`] ordering\n-    /// on the same value.\n+    /// When coupled with a store, all previous operations become ordered\n+    /// before any load of this value with [`Acquire`] (or stronger) ordering.\n+    /// In particular, all previous writes become visible to all threads\n+    /// that perform an [`Acquire`] (or stronger) load of this value.\n     ///\n-    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n+    /// Notice that using this ordering for an operation that combines loads\n+    /// and stores leads to a [`Relaxed`] load operation!\n+    ///\n+    /// This ordering is only applicable for operations that can perform a store.\n+    ///\n+    /// Corresponds to LLVM's [`Release`] ordering.\n+    ///\n+    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n+    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n+    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n-    /// When coupled with a load, all subsequent loads will see data\n-    /// written before a store with [`Release`] ordering on the same value\n-    /// in other threads.\n+    /// When coupled with a load, if the loaded value was written by a store operation with\n+    /// [`Release`] (or stronger) ordering, then all subsequent operations\n+    /// become ordered after that store. In particular, all subsequent loads will see data\n+    /// written before the store.\n+    ///\n+    /// Notice that using this ordering for an operation that combines loads\n+    /// and stores leads to a [`Relaxed`] store operation!\n+    ///\n+    /// This ordering is only applicable for operations that can perform a load.\n     ///\n-    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n+    /// Corresponds to LLVM's [`Acquire`] ordering.\n+    ///\n+    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n+    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n+    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n-    /// Has the effects of both [`Acquire`] and [`Release`] together.\n+    /// Has the effects of both [`Acquire`] and [`Release`] together:\n+    /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n+    ///\n+    /// Notice that in the case of `compare_and_swap`, it is possible that the operation ends up\n+    /// not performing any store and hence it has just `Acquire` ordering. However,\n+    /// `AcqRel` will never perform [`Relaxed`] accesses.\n     ///\n     /// This ordering is only applicable for operations that combine both loads and stores.\n     ///\n-    /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n+    /// Corresponds to LLVM's [`AcquireRelease`] ordering.\n     ///\n-    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n-    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n+    /// [`AcquireRelease`]: https://llvm.org/docs/Atomics.html#acquirerelease\n+    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n+    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n+    /// [`Relaxed`]: https://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n-    /// Like `AcqRel` with the additional guarantee that all threads see all\n+    /// Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n+    /// operations, respectively) with the additional guarantee that all threads see all\n     /// sequentially consistent operations in the same order.\n+    ///\n+    /// Corresponds to LLVM's [`SequentiallyConsistent`] ordering.\n+    ///\n+    /// [`SequentiallyConsistent`]: https://llvm.org/docs/Atomics.html#sequentiallyconsistent\n+    /// [`Acquire`]: https://llvm.org/docs/Atomics.html#acquire\n+    /// [`Release`]: https://llvm.org/docs/Atomics.html#release\n+    /// [`AcqRel`]: https://llvm.org/docs/Atomics.html#acquirerelease\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     SeqCst,\n     // Prevent exhaustive matching to allow for future extension\n@@ -297,15 +332,18 @@ impl AtomicBool {\n     /// Loads a value from the bool.\n     ///\n     /// `load` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is [`Release`] or [`AcqRel`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n     /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -325,9 +363,18 @@ impl AtomicBool {\n     /// Stores a value into the bool.\n     ///\n     /// `store` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -339,13 +386,6 @@ impl AtomicBool {\n     /// some_bool.store(false, Ordering::Relaxed);\n     /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n     /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n-    ///\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n@@ -357,9 +397,14 @@ impl AtomicBool {\n     /// Stores a value into the bool, returning the previous value.\n     ///\n     /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n     ///\n     /// # Examples\n     ///\n@@ -384,9 +429,16 @@ impl AtomicBool {\n     /// was updated.\n     ///\n     /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-    /// ordering of this operation.\n+    /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n+    /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n+    /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n+    /// happens, and using [`Release`] makes the load part [`Relaxed`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     /// [`bool`]: ../../../std/primitive.bool.html\n     ///\n     /// # Examples\n@@ -420,13 +472,18 @@ impl AtomicBool {\n     /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the\n     /// operation succeeds while the second describes the required ordering when the\n-    /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and must\n-    /// be equivalent or weaker than the success ordering.\n+    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+    /// and must be equivalent to or weaker than the success ordering.\n+    ///\n     ///\n     /// [`bool`]: ../../../std/primitive.bool.html\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -473,16 +530,20 @@ impl AtomicBool {\n     /// previous value.\n     ///\n     /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the operation\n-    /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n-    /// weaker than the success ordering.\n+    /// ordering of this operation. The first describes the required ordering if the\n+    /// operation succeeds while the second describes the required ordering when the\n+    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+    /// and must be equivalent to or weaker than the success ordering.\n     ///\n     /// [`bool`]: ../../../std/primitive.bool.html\n     /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -523,6 +584,16 @@ impl AtomicBool {\n     ///\n     /// Returns the previous value.\n     ///\n+    /// `fetch_and` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -554,6 +625,16 @@ impl AtomicBool {\n     ///\n     /// Returns the previous value.\n     ///\n+    /// `fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -598,6 +679,16 @@ impl AtomicBool {\n     ///\n     /// Returns the previous value.\n     ///\n+    /// `fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -629,6 +720,16 @@ impl AtomicBool {\n     ///\n     /// Returns the previous value.\n     ///\n+    /// `fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -714,15 +815,18 @@ impl<T> AtomicPtr<T> {\n     /// Loads a value from the pointer.\n     ///\n     /// `load` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n     ///\n     /// # Panics\n     ///\n     /// Panics if `order` is [`Release`] or [`AcqRel`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n     /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -743,9 +847,18 @@ impl<T> AtomicPtr<T> {\n     /// Stores a value into the pointer.\n     ///\n     /// `store` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -759,13 +872,6 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// some_ptr.store(other_ptr, Ordering::Relaxed);\n     /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n-    ///\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n@@ -777,9 +883,14 @@ impl<T> AtomicPtr<T> {\n     /// Stores a value into the pointer, returning the previous value.\n     ///\n     /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n-    /// of this operation.\n+    /// of this operation. All ordering modes are possible. Note that using\n+    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n+    /// using [`Release`] makes the load part [`Relaxed`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n     ///\n     /// # Examples\n     ///\n@@ -806,9 +917,16 @@ impl<T> AtomicPtr<T> {\n     /// was updated.\n     ///\n     /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-    /// ordering of this operation.\n+    /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n+    /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n+    /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n+    /// happens, and using [`Release`] makes the load part [`Relaxed`].\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -839,14 +957,18 @@ impl<T> AtomicPtr<T> {\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n     /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if\n-    /// the operation succeeds while the second describes the required ordering when\n-    /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`]\n-    /// and must be equivalent or weaker than the success ordering.\n+    /// ordering of this operation. The first describes the required ordering if the\n+    /// operation succeeds while the second describes the required ordering when the\n+    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+    /// and must be equivalent to or weaker than the success ordering.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -892,15 +1014,19 @@ impl<T> AtomicPtr<T> {\n     /// previous value.\n     ///\n     /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n-    /// ordering of this operation. The first describes the required ordering if the operation\n-    /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n-    /// weaker than the success ordering.\n+    /// ordering of this operation. The first describes the required ordering if the\n+    /// operation succeeds while the second describes the required ordering when the\n+    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n+    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+    /// and must be equivalent to or weaker than the success ordering.\n     ///\n     /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n+    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n     ///\n     /// # Examples\n     ///\n@@ -1077,14 +1203,18 @@ assert_eq!(some_var.into_inner(), 5);\n                 concat!(\"Loads a value from the atomic integer.\n \n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n \n # Panics\n \n Panics if `order` is [`Release`] or [`AcqRel`].\n \n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n \n # Examples\n \n@@ -1106,8 +1236,18 @@ assert_eq!(some_var.load(Ordering::Relaxed), 5);\n                 concat!(\"Stores a value into the atomic integer.\n \n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+ Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n+\n+# Panics\n+\n+Panics if `order` is [`Acquire`] or [`AcqRel`].\n \n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n \n # Examples\n \n@@ -1118,14 +1258,7 @@ let some_var = \", stringify!($atomic_type), \"::new(5);\n \n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n-```\n-\n-# Panics\n-\n-Panics if `order` is [`Acquire`] or [`AcqRel`].\n-\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-[`AcqRel`]: enum.Ordering.html#variant.AcqRel\"),\n+```\"),\n                 #[inline]\n                 #[$stable]\n                 pub fn store(&self, val: $int_type, order: Ordering) {\n@@ -1136,9 +1269,15 @@ Panics if `order` is [`Acquire`] or [`AcqRel`].\n             doc_comment! {\n                 concat!(\"Stores a value into the atomic integer, returning the previous value.\n \n-`swap` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n+`swap` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n \n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n \n # Examples\n \n@@ -1165,9 +1304,16 @@ The return value is always the previous value. If it is equal to `current`, then\n value was updated.\n \n `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n-ordering of this operation.\n+ordering of this operation. Notice that even when using [`AcqRel`], the operation\n+might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n+Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n+happens, and using [`Release`] makes the load part [`Relaxed`].\n \n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n \n # Examples\n \n@@ -1208,14 +1354,18 @@ containing the previous value. On success this value is guaranteed to be equal t\n `current`.\n \n `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n-ordering of this operation. The first describes the required ordering if\n-the operation succeeds while the second describes the required ordering when\n-the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-must be equivalent or weaker than the success ordering.\n+ordering of this operation. The first describes the required ordering if the\n+operation succeeds while the second describes the required ordering when the\n+operation fails. Using [`Acquire`] as success ordering makes the store part\n+of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+[`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+and must be equivalent to or weaker than the success ordering.\n \n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n-[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n \n # Examples\n \n@@ -1260,13 +1410,17 @@ written and containing the previous value.\n `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n ordering of this operation. The first describes the required ordering if the\n operation succeeds while the second describes the required ordering when the\n-operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n-must be equivalent or weaker than the success ordering.\n+operation fails. Using [`Acquire`] as success ordering makes the store part\n+of this operation [`Relaxed`], and using [`Release`] makes the successful load\n+[`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+and must be equivalent to or weaker than the success ordering.\n \n [`compare_exchange`]: #method.compare_exchange\n [`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n [`Release`]: enum.Ordering.html#variant.Release\n-[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n \n # Examples\n \n@@ -1302,6 +1456,16 @@ loop {\n \n This operation wraps around on overflow.\n \n+`fetch_add` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1323,6 +1487,16 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n \n This operation wraps around on overflow.\n \n+`fetch_sub` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1347,6 +1521,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_and` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1371,6 +1555,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1396,6 +1590,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1420,6 +1624,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1445,6 +1659,25 @@ Note: This may call the function multiple times if the value has been changed fr\n the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n but once to the stored value.\n \n+`fetch_update` takes two [`Ordering`] arguments to describe the memory\n+ordering of this operation. The first describes the required ordering for loads\n+and failed updates while the second describes the required ordering when the\n+operation finally succeeds. Beware that this is different from the two\n+modes in [`compare_exchange`]!\n+\n+Using [`Acquire`] as success ordering makes the store part\n+of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n+[`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n+and must be equivalent to or weaker than the success ordering.\n+\n+[`bool`]: ../../../std/primitive.bool.html\n+[`compare_exchange`]: #method.compare_exchange\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n+\n # Examples\n \n ```rust\n@@ -1485,6 +1718,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_max` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```\n@@ -1524,6 +1767,16 @@ sets the new value to the result.\n \n Returns the previous value.\n \n+`fetch_min` takes an [`Ordering`] argument which describes the memory ordering\n+of this operation. All ordering modes are possible. Note that using\n+[`Acquire`] makes the store part of this operation [`Relaxed`], and\n+using [`Release`] makes the load part [`Relaxed`].\n+\n+[`Ordering`]: enum.Ordering.html\n+[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+[`Release`]: enum.Ordering.html#variant.Release\n+[`Acquire`]: enum.Ordering.html#variant.Acquire\n+\n # Examples\n \n ```"}]}