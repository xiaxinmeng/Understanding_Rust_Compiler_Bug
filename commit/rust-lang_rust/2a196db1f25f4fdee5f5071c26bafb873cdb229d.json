{"sha": "2a196db1f25f4fdee5f5071c26bafb873cdb229d", "node_id": "C_kwDOAAsO6NoAKDJhMTk2ZGIxZjI1ZjRmZGVlNWY1MDcxYzI2YmFmYjg3M2NkYjIyOWQ", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2023-03-07T14:06:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-07T14:06:22Z"}, "message": "Rollup merge of #108728 - tshepang:fix-and-improve, r=michaelwoerister\n\ninfer: fix and improve comments", "tree": {"sha": "5c8fda95b53e4d5dd1686351ab2a76905ef5386b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c8fda95b53e4d5dd1686351ab2a76905ef5386b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a196db1f25f4fdee5f5071c26bafb873cdb229d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkB0TeCRBK7hj4Ov3rIwAAg0cIAE7Dj7kKN6Iv4DvWagMo/rB7\nMh1kvz7L6qFqWS6fM80MBcxwyOkvqeNMhrt2P+69nNGdVXTPvK7omrHK6Jo7J3O3\nTXOgBFfucOJ6HpZVc0ljg9oMv+/TjU3asPoC4CbvAYVYsdsRfju/OR1tBp5B61cD\nnSIVGeTSaLiYQXA8g/PwMnXVUELyooDU0ZP+ZtmFFehkra8SutRTXVdlOmTK+ZB1\nwuEXUfbmu7nwWlU3rzAAcIAusogPVTgJLHqnFv+PRWlhkTsvMArJPJ2FOebtmDvg\nORR3c4h6G/2fXuJQfvKH0BrHIG4ZKXH+YVt34XRJx6Vi0uBGrCCcNbtIql0bx6k=\n=k9p3\n-----END PGP SIGNATURE-----\n", "payload": "tree 5c8fda95b53e4d5dd1686351ab2a76905ef5386b\nparent a7b9488599494a0c91ab18a169aaab476a274177\nparent 34063c5706798033933cfdb02cff89c2fa03c247\nauthor Yuki Okushi <jtitor@2k36.org> 1678197982 +0900\ncommitter GitHub <noreply@github.com> 1678197982 +0900\n\nRollup merge of #108728 - tshepang:fix-and-improve, r=michaelwoerister\n\ninfer: fix and improve comments\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a196db1f25f4fdee5f5071c26bafb873cdb229d", "html_url": "https://github.com/rust-lang/rust/commit/2a196db1f25f4fdee5f5071c26bafb873cdb229d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a196db1f25f4fdee5f5071c26bafb873cdb229d/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7b9488599494a0c91ab18a169aaab476a274177", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7b9488599494a0c91ab18a169aaab476a274177", "html_url": "https://github.com/rust-lang/rust/commit/a7b9488599494a0c91ab18a169aaab476a274177"}, {"sha": "34063c5706798033933cfdb02cff89c2fa03c247", "url": "https://api.github.com/repos/rust-lang/rust/commits/34063c5706798033933cfdb02cff89c2fa03c247", "html_url": "https://github.com/rust-lang/rust/commit/34063c5706798033933cfdb02cff89c2fa03c247"}], "stats": {"total": 61, "additions": 32, "deletions": 29}, "files": [{"sha": "fb067e7ac2135f24e4f3b76094f5b73ef239a1ac", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2a196db1f25f4fdee5f5071c26bafb873cdb229d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a196db1f25f4fdee5f5071c26bafb873cdb229d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=2a196db1f25f4fdee5f5071c26bafb873cdb229d", "patch": "@@ -114,24 +114,26 @@ pub struct InferCtxtInner<'tcx> {\n     float_unification_storage: ut::UnificationTableStorage<ty::FloatVid>,\n \n     /// Tracks the set of region variables and the constraints between them.\n+    ///\n     /// This is initially `Some(_)` but when\n     /// `resolve_regions_and_report_errors` is invoked, this gets set to `None`\n     /// -- further attempts to perform unification, etc., may fail if new\n     /// region constraints would've been added.\n     region_constraint_storage: Option<RegionConstraintStorage<'tcx>>,\n \n-    /// A set of constraints that regionck must validate. Each\n-    /// constraint has the form `T:'a`, meaning \"some type `T` must\n+    /// A set of constraints that regionck must validate.\n+    ///\n+    /// Each constraint has the form `T:'a`, meaning \"some type `T` must\n     /// outlive the lifetime 'a\". These constraints derive from\n     /// instantiated type parameters. So if you had a struct defined\n-    /// like\n+    /// like the following:\n     /// ```ignore (illustrative)\n-    ///     struct Foo<T:'static> { ... }\n+    /// struct Foo<T: 'static> { ... }\n     /// ```\n-    /// then in some expression `let x = Foo { ... }` it will\n+    /// In some expression `let x = Foo { ... }`, it will\n     /// instantiate the type parameter `T` with a fresh type `$0`. At\n     /// the same time, it will record a region obligation of\n-    /// `$0:'static`. This will get checked later by regionck. (We\n+    /// `$0: 'static`. This will get checked later by regionck. (We\n     /// can't generally check these things right away because we have\n     /// to wait until types are resolved.)\n     ///\n@@ -268,7 +270,7 @@ pub struct InferCtxt<'tcx> {\n     /// Caches the results of trait evaluation.\n     pub evaluation_cache: select::EvaluationCache<'tcx>,\n \n-    /// the set of predicates on which errors have been reported, to\n+    /// The set of predicates on which errors have been reported, to\n     /// avoid reporting the same error twice.\n     pub reported_trait_errors: RefCell<FxIndexMap<Span, Vec<ty::Predicate<'tcx>>>>,\n \n@@ -291,7 +293,7 @@ pub struct InferCtxt<'tcx> {\n     tainted_by_errors: Cell<Option<ErrorGuaranteed>>,\n \n     /// Track how many errors were reported when this infcx is created.\n-    /// If the number of errors increases, that's also a sign (line\n+    /// If the number of errors increases, that's also a sign (like\n     /// `tainted_by_errors`) to avoid reporting certain kinds of errors.\n     // FIXME(matthewjasper) Merge into `tainted_by_errors`\n     err_count_on_creation: usize,\n@@ -313,7 +315,7 @@ pub struct InferCtxt<'tcx> {\n     /// During coherence we have to assume that other crates may add\n     /// additional impls which we currently don't know about.\n     ///\n-    /// To deal with this evaluation should be conservative\n+    /// To deal with this evaluation, we should be conservative\n     /// and consider the possibility of impls from outside this crate.\n     /// This comes up primarily when resolving ambiguity. Imagine\n     /// there is some trait reference `$0: Bar` where `$0` is an\n@@ -323,7 +325,7 @@ pub struct InferCtxt<'tcx> {\n     /// bound to some type that in a downstream crate that implements\n     /// `Bar`.\n     ///\n-    /// Outside of coherence we set this to false because we are only\n+    /// Outside of coherence, we set this to false because we are only\n     /// interested in types that the user could actually have written.\n     /// In other words, we consider `$0: Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n@@ -373,7 +375,7 @@ pub enum SubregionOrigin<'tcx> {\n     Subtype(Box<TypeTrace<'tcx>>),\n \n     /// When casting `&'a T` to an `&'b Trait` object,\n-    /// relating `'a` to `'b`\n+    /// relating `'a` to `'b`.\n     RelateObjectBound(Span),\n \n     /// Some type parameter was instantiated with the given type,\n@@ -384,7 +386,7 @@ pub enum SubregionOrigin<'tcx> {\n     /// that must outlive some other region.\n     RelateRegionParamBound(Span),\n \n-    /// Creating a pointer `b` to contents of another reference\n+    /// Creating a pointer `b` to contents of another reference.\n     Reborrow(Span),\n \n     /// (&'a &'b T) where a >= b\n@@ -398,7 +400,7 @@ pub enum SubregionOrigin<'tcx> {\n         trait_item_def_id: DefId,\n     },\n \n-    /// Checking that the bounds of a trait's associated type hold for a given impl\n+    /// Checking that the bounds of a trait's associated type hold for a given impl.\n     CheckAssociatedTypeBounds {\n         parent: Box<SubregionOrigin<'tcx>>,\n         impl_item_def_id: LocalDefId,\n@@ -435,32 +437,33 @@ pub enum LateBoundRegionConversionTime {\n     AssocTypeProjection(DefId),\n }\n \n-/// Reasons to create a region inference variable\n+/// Reasons to create a region inference variable.\n ///\n-/// See `error_reporting` module for more details\n+/// See `error_reporting` module for more details.\n #[derive(Copy, Clone, Debug)]\n pub enum RegionVariableOrigin {\n-    /// Region variables created for ill-categorized reasons,\n-    /// mostly indicates places in need of refactoring\n+    /// Region variables created for ill-categorized reasons.\n+    ///\n+    /// They mostly indicate places in need of refactoring.\n     MiscVariable(Span),\n \n-    /// Regions created by a `&P` or `[...]` pattern\n+    /// Regions created by a `&P` or `[...]` pattern.\n     PatternRegion(Span),\n \n-    /// Regions created by `&` operator\n+    /// Regions created by `&` operator.\n+    ///\n     AddrOfRegion(Span),\n-\n-    /// Regions created as part of an autoref of a method receiver\n+    /// Regions created as part of an autoref of a method receiver.\n     Autoref(Span),\n \n-    /// Regions created as part of an automatic coercion\n+    /// Regions created as part of an automatic coercion.\n     Coercion(Span),\n \n-    /// Region variables created as the values for early-bound regions\n+    /// Region variables created as the values for early-bound regions.\n     EarlyBoundRegion(Span, Symbol),\n \n     /// Region variables created for bound regions\n-    /// in a function or method that is called\n+    /// in a function or method that is called.\n     LateBoundRegion(Span, ty::BoundRegionKind, LateBoundRegionConversionTime),\n \n     UpvarRegion(ty::UpvarId, Span),\n@@ -534,7 +537,7 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n     }\n }\n \n-/// Used to configure inference contexts before their creation\n+/// Used to configure inference contexts before their creation.\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     defining_use_anchor: DefiningAnchor,\n@@ -835,9 +838,9 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     /// Scan the constraints produced since `snapshot` began and returns:\n     ///\n-    /// - `None` -- if none of them involve \"region outlives\" constraints\n-    /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder\n-    /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders\n+    /// - `None` -- if none of them involves \"region outlives\" constraints.\n+    /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder.\n+    /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders.\n     pub fn region_constraints_added_in_snapshot(\n         &self,\n         snapshot: &CombinedSnapshot<'tcx>,\n@@ -1770,7 +1773,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     }\n }\n \n-/// Helper for `ty_or_const_infer_var_changed` (see comment on that), currently\n+/// Helper for [InferCtxt::ty_or_const_infer_var_changed] (see comment on that), currently\n /// used only for `traits::fulfill`'s list of `stalled_on` inference variables.\n #[derive(Copy, Clone, Debug)]\n pub enum TyOrConstInferVar<'tcx> {"}]}