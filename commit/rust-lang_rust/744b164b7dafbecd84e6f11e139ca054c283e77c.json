{"sha": "744b164b7dafbecd84e6f11e139ca054c283e77c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NGIxNjRiN2RhZmJlY2Q4NGU2ZjExZTEzOWNhMDU0YzI4M2U3N2M=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-21T20:13:51Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-22T00:24:17Z"}, "message": "rustc: Move type logic out of typeck so trans doesn't look like it's calling into typeck", "tree": {"sha": "1a0196d4fa25f51facd76c9189bf583f43c9bbe3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a0196d4fa25f51facd76c9189bf583f43c9bbe3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/744b164b7dafbecd84e6f11e139ca054c283e77c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/744b164b7dafbecd84e6f11e139ca054c283e77c", "html_url": "https://github.com/rust-lang/rust/commit/744b164b7dafbecd84e6f11e139ca054c283e77c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/744b164b7dafbecd84e6f11e139ca054c283e77c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7cbeba731716f176f4c116cfe92f3ec246e1396", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7cbeba731716f176f4c116cfe92f3ec246e1396", "html_url": "https://github.com/rust-lang/rust/commit/d7cbeba731716f176f4c116cfe92f3ec246e1396"}], "stats": {"total": 1848, "additions": 936, "deletions": 912}, "files": [{"sha": "8159962de1c324807110216b8dc4eaf492686e8a", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/744b164b7dafbecd84e6f11e139ca054c283e77c/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744b164b7dafbecd84e6f11e139ca054c283e77c/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=744b164b7dafbecd84e6f11e139ca054c283e77c", "patch": "@@ -1,7 +1,6 @@\n \n import std.map.hashmap;\n import std.option;\n-import middle.typeck;\n import util.common.span;\n import util.common.spanned;\n import util.common.ty_mach;\n@@ -21,7 +20,7 @@ type ty_param = rec(ident ident, def_id id);\n // Annotations added during successive passes.\n tag ann {\n     ann_none;\n-    ann_type(@typeck.ty);\n+    ann_type(@middle.ty.t);\n }\n \n tag def {\n@@ -168,7 +167,7 @@ tag lit_ {\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n-// type structure in middle/typeck.rs as well.\n+// type structure in middle/ty.rs as well.\n \n type ty_field = rec(ident ident, @ty ty);\n type ty_arg = rec(mode mode, @ty ty);"}, {"sha": "190b71f0a76397b14a7f2f9d441d7f5cbdd9c79e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 159, "deletions": 166, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/744b164b7dafbecd84e6f11e139ca054c283e77c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744b164b7dafbecd84e6f11e139ca054c283e77c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=744b164b7dafbecd84e6f11e139ca054c283e77c", "patch": "@@ -11,11 +11,11 @@ import std.option.none;\n \n import front.ast;\n import driver.session;\n-import middle.typeck;\n+import middle.ty;\n import back.x86;\n import back.abi;\n \n-import middle.typeck.pat_ty;\n+import middle.ty.pat_ty;\n \n import util.common;\n import util.common.istr;\n@@ -66,7 +66,7 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, ValueRef] item_ids,\n                             hashmap[ast.def_id, @ast.item] items,\n                             hashmap[ast.def_id, @tag_info] tags,\n-                            hashmap[@typeck.ty, ValueRef] tydescs,\n+                            hashmap[@ty.t, ValueRef] tydescs,\n                             @glue_fns glues,\n                             namegen names,\n                             str path);\n@@ -275,27 +275,25 @@ fn T_taskptr() -> TypeRef {\n     ret T_ptr(T_task());\n }\n \n-fn type_of(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n+fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     let TypeRef llty = type_of_inner(cx, t);\n     check (llty as int != 0);\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(typeck.ty_to_str(t)), llty);\n+    llvm.LLVMAddTypeName(cx.llmod, _str.buf(ty.ty_to_str(t)), llty);\n     ret llty;\n }\n \n-fn type_of_fn(@crate_ctxt cx,\n-              vec[typeck.arg] inputs,\n-              @typeck.ty output) -> TypeRef {\n+fn type_of_fn(@crate_ctxt cx, vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n     let vec[TypeRef] atys = vec(T_taskptr());\n \n-    auto fn_ty = typeck.plain_ty(typeck.ty_fn(inputs, output));\n-    auto ty_param_count = typeck.count_ty_params(fn_ty);\n+    auto fn_ty = ty.plain_ty(ty.ty_fn(inputs, output));\n+    auto ty_param_count = ty.count_ty_params(fn_ty);\n     auto i = 0u;\n     while (i < ty_param_count) {\n         atys += T_ptr(T_tydesc());\n         i += 1u;\n     }\n \n-    for (typeck.arg arg in inputs) {\n+    for (ty.arg arg in inputs) {\n         let TypeRef t = type_of(cx, arg.ty);\n         alt (arg.mode) {\n             case (ast.alias) {\n@@ -307,7 +305,7 @@ fn type_of_fn(@crate_ctxt cx,\n     }\n \n     auto ret_ty;\n-    if (typeck.type_is_nil(output)) {\n+    if (ty.type_is_nil(output)) {\n         ret_ty = llvm.LLVMVoidType();\n     } else {\n         ret_ty = type_of(cx, output);\n@@ -316,13 +314,13 @@ fn type_of_fn(@crate_ctxt cx,\n     ret T_fn(atys, ret_ty);\n }\n \n-fn type_of_inner(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n+fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     alt (t.struct) {\n-        case (typeck.ty_nil) { ret T_nil(); }\n-        case (typeck.ty_bool) { ret T_bool(); }\n-        case (typeck.ty_int) { ret T_int(); }\n-        case (typeck.ty_uint) { ret T_int(); }\n-        case (typeck.ty_machine(?tm)) {\n+        case (ty.ty_nil) { ret T_nil(); }\n+        case (ty.ty_bool) { ret T_bool(); }\n+        case (ty.ty_int) { ret T_int(); }\n+        case (ty.ty_uint) { ret T_int(); }\n+        case (ty.ty_machine(?tm)) {\n             alt (tm) {\n                 case (common.ty_i8) { ret T_i8(); }\n                 case (common.ty_u8) { ret T_i8(); }\n@@ -336,37 +334,37 @@ fn type_of_inner(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n                 case (common.ty_f64) { ret T_f64(); }\n             }\n         }\n-        case (typeck.ty_char) { ret T_char(); }\n-        case (typeck.ty_str) { ret T_ptr(T_str()); }\n-        case (typeck.ty_tag(?tag_id)) {\n+        case (ty.ty_char) { ret T_char(); }\n+        case (ty.ty_str) { ret T_ptr(T_str()); }\n+        case (ty.ty_tag(?tag_id)) {\n             ret llvm.LLVMResolveTypeHandle(cx.tags.get(tag_id).th.llth);\n         }\n-        case (typeck.ty_box(?t)) {\n+        case (ty.ty_box(?t)) {\n             ret T_ptr(T_box(type_of(cx, t)));\n         }\n-        case (typeck.ty_vec(?t)) {\n+        case (ty.ty_vec(?t)) {\n             ret T_ptr(T_vec(type_of(cx, t)));\n         }\n-        case (typeck.ty_tup(?elts)) {\n+        case (ty.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n-            for (@typeck.ty elt in elts) {\n+            for (@ty.t elt in elts) {\n                 tys += type_of(cx, elt);\n             }\n             ret T_struct(tys);\n         }\n-        case (typeck.ty_rec(?fields)) {\n+        case (ty.ty_rec(?fields)) {\n             let vec[TypeRef] tys = vec();\n-            for (typeck.field f in fields) {\n+            for (ty.field f in fields) {\n                 tys += type_of(cx, f.ty);\n             }\n             ret T_struct(tys);\n         }\n-        case (typeck.ty_fn(?args, ?out)) {\n+        case (ty.ty_fn(?args, ?out)) {\n             ret type_of_fn(cx, args, out);\n         }\n-        case (typeck.ty_obj(?meths)) {\n+        case (ty.ty_obj(?meths)) {\n             let vec[TypeRef] mtys = vec();\n-            for (typeck.method m in meths) {\n+            for (ty.method m in meths) {\n                 let TypeRef mty = type_of_fn(cx, m.inputs, m.output);\n                 mtys += T_ptr(mty);\n             }\n@@ -376,18 +374,18 @@ fn type_of_inner(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n                              T_ptr(T_box(T_nil()))));\n             ret pair;\n         }\n-        case (typeck.ty_var(_)) {\n+        case (ty.ty_var(_)) {\n             log \"ty_var in trans.type_of\";\n             fail;\n         }\n-        case (typeck.ty_param(_)) {\n+        case (ty.ty_param(_)) {\n             ret T_ptr(T_i8());\n         }\n     }\n     fail;\n }\n \n-fn type_of_arg(@crate_ctxt cx, &typeck.arg arg) -> TypeRef {\n+fn type_of_arg(@crate_ctxt cx, &ty.arg arg) -> TypeRef {\n     auto ty = type_of(cx, arg.ty);\n     if (arg.mode == ast.alias) {\n         ty = T_ptr(ty);\n@@ -568,7 +566,7 @@ fn align_of(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntCast(lib.llvm.llvm.LLVMAlignOf(t), T_int(), False);\n }\n \n-fn trans_malloc(@block_ctxt cx, @typeck.ty t) -> result {\n+fn trans_malloc(@block_ctxt cx, @ty.t t) -> result {\n     auto scope_cx = find_scope_cx(cx);\n     auto ptr_ty = type_of(cx.fcx.ccx, t);\n     auto body_ty = lib.llvm.llvm.LLVMGetElementType(ptr_ty);\n@@ -587,38 +585,38 @@ fn trans_malloc(@block_ctxt cx, @typeck.ty t) -> result {\n // Given a type and a field index into its corresponding type descriptor,\n // returns an LLVM ValueRef of that field from the tydesc, generating the\n // tydesc if necessary.\n-fn field_of_tydesc(@block_ctxt cx, @typeck.ty ty, int field) -> ValueRef {\n-    auto tydesc = get_tydesc(cx, ty);\n+fn field_of_tydesc(@block_ctxt cx, @ty.t t, int field) -> ValueRef {\n+    auto tydesc = get_tydesc(cx, t);\n     ret cx.build.GEP(tydesc, vec(C_int(0), C_int(field)));\n }\n \n-fn get_tydesc(&@block_ctxt cx, @typeck.ty ty) -> ValueRef {\n+fn get_tydesc(&@block_ctxt cx, @ty.t t) -> ValueRef {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n-    alt (typeck.type_param(ty)) {\n+    alt (ty.type_param(t)) {\n         case (some[ast.def_id](?id)) { ret cx.fcx.lltydescs.get(id); }\n         case (none[ast.def_id])      { /* fall through */ }\n     }\n \n     // Does it contain a type param? If so, generate a derived tydesc.\n-    if (typeck.count_ty_params(ty) > 0u) {\n+    if (ty.count_ty_params(t) > 0u) {\n         log \"TODO: trans.get_tydesc(): generate a derived type descriptor\";\n         fail;\n     }\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n-    if (!cx.fcx.ccx.tydescs.contains_key(ty)) {\n-        make_tydesc(cx.fcx.ccx, ty);\n+    if (!cx.fcx.ccx.tydescs.contains_key(t)) {\n+        make_tydesc(cx.fcx.ccx, t);\n     }\n-    ret cx.fcx.ccx.tydescs.get(ty);\n+    ret cx.fcx.ccx.tydescs.get(t);\n }\n \n-fn make_tydesc(@crate_ctxt cx, @typeck.ty ty) {\n+fn make_tydesc(@crate_ctxt cx, @ty.t t) {\n     auto tg = make_take_glue;\n-    auto take_glue = make_generic_glue(cx, ty, \"take\", tg);\n+    auto take_glue = make_generic_glue(cx, t, \"take\", tg);\n     auto dg = make_drop_glue;\n-    auto drop_glue = make_generic_glue(cx, ty, \"drop\", dg);\n+    auto drop_glue = make_generic_glue(cx, t, \"drop\", dg);\n \n-    auto llty = type_of(cx, ty);\n+    auto llty = type_of(cx, t);\n     auto pvoid = T_ptr(T_i8());\n     auto glue_fn_ty = T_ptr(T_fn(vec(T_taskptr(), pvoid), T_void()));\n     auto tydesc = C_struct(vec(C_null(pvoid),\n@@ -632,28 +630,28 @@ fn make_tydesc(@crate_ctxt cx, @typeck.ty ty) {\n                                C_null(glue_fn_ty),    // obj_drop_glue_off\n                                C_null(glue_fn_ty)));  // is_stateful\n \n-    auto name = sanitize(cx.names.next(\"tydesc_\" + typeck.ty_to_str(ty)));\n+    auto name = sanitize(cx.names.next(\"tydesc_\" + ty.ty_to_str(t)));\n     auto gvar = llvm.LLVMAddGlobal(cx.llmod, val_ty(tydesc), _str.buf(name));\n     llvm.LLVMSetInitializer(gvar, tydesc);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n-    cx.tydescs.insert(ty, gvar);\n+    cx.tydescs.insert(t, gvar);\n }\n \n-fn make_generic_glue(@crate_ctxt cx, @typeck.ty t, str name,\n+fn make_generic_glue(@crate_ctxt cx, @ty.t t, str name,\n                      val_and_ty_fn helper) -> ValueRef {\n     auto llfnty = T_fn(vec(T_taskptr(), T_ptr(T_i8())), T_void());\n \n-    auto fn_name = cx.names.next(\"_rust_\" + name) + \".\" + typeck.ty_to_str(t);\n+    auto fn_name = cx.names.next(\"_rust_\" + name) + \".\" + ty.ty_to_str(t);\n     fn_name = sanitize(fn_name);\n     auto llfn = decl_fastcall_fn(cx.llmod, fn_name, llfnty);\n \n     auto fcx = new_fn_ctxt(cx, fn_name, llfn);\n     auto bcx = new_top_block_ctxt(fcx);\n \n     auto re;\n-    if (!typeck.type_is_scalar(t)) {\n+    if (!ty.type_is_scalar(t)) {\n         auto llty;\n-        if (typeck.type_is_structural(t)) {\n+        if (ty.type_is_structural(t)) {\n             llty = T_ptr(type_of(cx, t));\n         } else {\n             llty = type_of(cx, t);\n@@ -671,11 +669,11 @@ fn make_generic_glue(@crate_ctxt cx, @typeck.ty t, str name,\n     ret llfn;\n }\n \n-fn make_take_glue(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result {\n-    if (typeck.type_is_boxed(t)) {\n+fn make_take_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n+    if (ty.type_is_boxed(t)) {\n         ret incr_refcnt_of_boxed(cx, v);\n \n-    } else if (typeck.type_is_structural(t)) {\n+    } else if (ty.type_is_structural(t)) {\n         ret iter_structural_ty(cx, v, t,\n                                bind incr_all_refcnts(_, _, _));\n     }\n@@ -701,18 +699,17 @@ fn incr_refcnt_of_boxed(@block_ctxt cx, ValueRef box_ptr) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-fn make_drop_glue(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result {\n+fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n     alt (t.struct) {\n-        case (typeck.ty_str) {\n+        case (ty.ty_str) {\n             ret decr_refcnt_and_if_zero(cx, v,\n                                         bind trans_non_gc_free(_, v),\n                                         \"free string\",\n                                         T_int(), C_int(0));\n         }\n \n-        case (typeck.ty_vec(_)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v,\n-                        @typeck.ty t) -> result {\n+        case (ty.ty_vec(_)) {\n+            fn hit_zero(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                 auto res = iter_sequence(cx, v, t, bind drop_ty(_,_,_));\n                 // FIXME: switch gc/non-gc on layer of the type.\n                 ret trans_non_gc_free(res.bcx, v);\n@@ -723,9 +720,8 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result {\n                                         T_int(), C_int(0));\n         }\n \n-        case (typeck.ty_box(?body_ty)) {\n-            fn hit_zero(@block_ctxt cx, ValueRef v,\n-                        @typeck.ty body_ty) -> result {\n+        case (ty.ty_box(?body_ty)) {\n+            fn hit_zero(@block_ctxt cx, ValueRef v, @ty.t body_ty) -> result {\n                 auto body = cx.build.GEP(v,\n                                          vec(C_int(0),\n                                              C_int(abi.box_rc_field_body)));\n@@ -742,18 +738,18 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result {\n         }\n \n         case (_) {\n-            if (typeck.type_is_structural(t)) {\n+            if (ty.type_is_structural(t)) {\n                 ret iter_structural_ty(cx, v, t,\n                                        bind drop_ty(_, _, _));\n \n-            } else if (typeck.type_is_scalar(t) ||\n-                       typeck.type_is_nil(t)) {\n+            } else if (ty.type_is_scalar(t) ||\n+                       ty.type_is_nil(t)) {\n                 ret res(cx, C_nil());\n             }\n         }\n     }\n     cx.fcx.ccx.sess.bug(\"bad type in trans.make_drop_glue_inner: \" +\n-                        typeck.ty_to_str(t));\n+                        ty.ty_to_str(t));\n     fail;\n }\n \n@@ -802,9 +798,9 @@ fn decr_refcnt_and_if_zero(@block_ctxt cx,\n \n fn type_of_variant(@crate_ctxt cx, &ast.variant v) -> TypeRef {\n     let vec[TypeRef] lltys = vec();\n-    alt (typeck.ann_to_type(v.ann).struct) {\n-        case (typeck.ty_fn(?args, _)) {\n-            for (typeck.arg arg in args) {\n+    alt (ty.ann_to_type(v.ann).struct) {\n+        case (ty.ty_fn(?args, _)) {\n+            for (ty.arg arg in args) {\n                 lltys += vec(type_of(cx, arg.ty));\n             }\n         }\n@@ -813,13 +809,12 @@ fn type_of_variant(@crate_ctxt cx, &ast.variant v) -> TypeRef {\n     ret T_struct(lltys);\n }\n \n-type val_and_ty_fn =\n-    fn(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result;\n+type val_and_ty_fn = fn(@block_ctxt cx, ValueRef v, @ty.t t) -> result;\n \n // Iterates through the elements of a structural type.\n fn iter_structural_ty(@block_ctxt cx,\n                       ValueRef v,\n-                      @typeck.ty t,\n+                      @ty.t t,\n                       val_and_ty_fn f)\n     -> result {\n     let result r = res(cx, C_nil());\n@@ -828,8 +823,8 @@ fn iter_structural_ty(@block_ctxt cx,\n                   ValueRef box_cell,\n                   val_and_ty_fn f) -> result {\n         auto box_ptr = cx.build.Load(box_cell);\n-        auto tnil = typeck.plain_ty(typeck.ty_nil);\n-        auto tbox = typeck.plain_ty(typeck.ty_box(tnil));\n+        auto tnil = ty.plain_ty(ty.ty_nil);\n+        auto tbox = ty.plain_ty(ty.ty_box(tnil));\n \n         auto inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -842,27 +837,27 @@ fn iter_structural_ty(@block_ctxt cx,\n     }\n \n     alt (t.struct) {\n-        case (typeck.ty_tup(?args)) {\n+        case (ty.ty_tup(?args)) {\n             let int i = 0;\n-            for (@typeck.ty arg in args) {\n+            for (@ty.t arg in args) {\n                 auto elt = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n                 r = f(r.bcx,\n                       load_non_structural(r.bcx, elt, arg),\n                       arg);\n                 i += 1;\n             }\n         }\n-        case (typeck.ty_rec(?fields)) {\n+        case (ty.ty_rec(?fields)) {\n             let int i = 0;\n-            for (typeck.field fld in fields) {\n+            for (ty.field fld in fields) {\n                 auto llfld = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n                 r = f(r.bcx,\n                       load_non_structural(r.bcx, llfld, fld.ty),\n                       fld.ty);\n                 i += 1;\n             }\n         }\n-        case (typeck.ty_tag(?tid)) {\n+        case (ty.ty_tag(?tid)) {\n             check (cx.fcx.ccx.tags.contains_key(tid));\n             auto info = cx.fcx.ccx.tags.get(tid);\n             auto n_variants = _vec.len[tup(ast.def_id,arity)](info.variants);\n@@ -907,15 +902,15 @@ fn iter_structural_ty(@block_ctxt cx,\n                         auto llvarty = type_of_variant(cx.fcx.ccx,\n                                                        variants.(i));\n \n-                        auto fn_ty = typeck.ann_to_type(variants.(i).ann);\n+                        auto fn_ty = ty.ann_to_type(variants.(i).ann);\n                         alt (fn_ty.struct) {\n-                            case (typeck.ty_fn(?args, _)) {\n+                            case (ty.ty_fn(?args, _)) {\n                                 auto llvarp = variant_cx.build.\n                                     TruncOrBitCast(llunion_ptr,\n                                                    T_ptr(llvarty));\n \n                                 auto j = 0u;\n-                                for (typeck.arg a in args) {\n+                                for (ty.arg a in args) {\n                                     auto llfldp = variant_cx.build.GEP(llvarp,\n                                         vec(C_int(0), C_int(j as int)));\n                                     auto llfld =\n@@ -943,14 +938,14 @@ fn iter_structural_ty(@block_ctxt cx,\n \n             ret res(next_cx, C_nil());\n         }\n-        case (typeck.ty_fn(_,_)) {\n+        case (ty.ty_fn(_,_)) {\n             auto box_cell =\n                 cx.build.GEP(v,\n                              vec(C_int(0),\n                                  C_int(abi.fn_field_box)));\n             ret iter_boxpp(cx, box_cell, f);\n         }\n-        case (typeck.ty_obj(_)) {\n+        case (ty.ty_obj(_)) {\n             auto box_cell =\n                 cx.build.GEP(v,\n                              vec(C_int(0),\n@@ -967,12 +962,12 @@ fn iter_structural_ty(@block_ctxt cx,\n // Iterates through the elements of a vec or str.\n fn iter_sequence(@block_ctxt cx,\n                  ValueRef v,\n-                 @typeck.ty ty,\n+                 @ty.t t,\n                  val_and_ty_fn f) -> result {\n \n     fn iter_sequence_body(@block_ctxt cx,\n                           ValueRef v,\n-                          @typeck.ty elt_ty,\n+                          @ty.t elt_ty,\n                           val_and_ty_fn f,\n                           bool trailing_null) -> result {\n \n@@ -1022,12 +1017,12 @@ fn iter_sequence(@block_ctxt cx,\n         ret res(next_cx, C_nil());\n     }\n \n-    alt (ty.struct) {\n-        case (typeck.ty_vec(?et)) {\n+    alt (t.struct) {\n+        case (ty.ty_vec(?et)) {\n             ret iter_sequence_body(cx, v, et, f, false);\n         }\n-        case (typeck.ty_str) {\n-            auto et = typeck.plain_ty(typeck.ty_machine(common.ty_u8));\n+        case (ty.ty_str) {\n+            auto et = ty.plain_ty(ty.ty_machine(common.ty_u8));\n             ret iter_sequence_body(cx, v, et, f, true);\n         }\n         case (_) { fail; }\n@@ -1038,9 +1033,9 @@ fn iter_sequence(@block_ctxt cx,\n \n fn incr_all_refcnts(@block_ctxt cx,\n                     ValueRef v,\n-                    @typeck.ty t) -> result {\n+                    @ty.t t) -> result {\n \n-    if (!typeck.type_is_scalar(t)) {\n+    if (!ty.type_is_scalar(t)) {\n         auto llrawptr = cx.build.BitCast(v, T_ptr(T_i8()));\n         auto llfnptr = field_of_tydesc(cx, t, abi.tydesc_field_take_glue_off);\n         auto llfn = cx.build.Load(llfnptr);\n@@ -1051,7 +1046,7 @@ fn incr_all_refcnts(@block_ctxt cx,\n \n fn drop_slot(@block_ctxt cx,\n              ValueRef slot,\n-             @typeck.ty t) -> result {\n+             @ty.t t) -> result {\n     auto llptr = load_non_structural(cx, slot, t);\n     auto re = drop_ty(cx, llptr, t);\n \n@@ -1063,9 +1058,9 @@ fn drop_slot(@block_ctxt cx,\n \n fn drop_ty(@block_ctxt cx,\n            ValueRef v,\n-           @typeck.ty t) -> result {\n+           @ty.t t) -> result {\n \n-    if (!typeck.type_is_scalar(t)) {\n+    if (!ty.type_is_scalar(t)) {\n         auto llrawptr = cx.build.BitCast(v, T_ptr(T_i8()));\n         auto llfnptr = field_of_tydesc(cx, t, abi.tydesc_field_drop_glue_off);\n         auto llfn = cx.build.Load(llfnptr);\n@@ -1102,21 +1097,21 @@ fn copy_ty(@block_ctxt cx,\n            bool is_init,\n            ValueRef dst,\n            ValueRef src,\n-           @typeck.ty t) -> result {\n-    if (typeck.type_is_scalar(t)) {\n+           @ty.t t) -> result {\n+    if (ty.type_is_scalar(t)) {\n         ret res(cx, cx.build.Store(src, dst));\n \n-    } else if (typeck.type_is_nil(t)) {\n+    } else if (ty.type_is_nil(t)) {\n         ret res(cx, C_nil());\n \n-    } else if (typeck.type_is_boxed(t)) {\n+    } else if (ty.type_is_boxed(t)) {\n         auto r = incr_all_refcnts(cx, src, t);\n         if (! is_init) {\n             r = drop_ty(r.bcx, r.bcx.build.Load(dst), t);\n         }\n         ret res(r.bcx, r.bcx.build.Store(src, dst));\n \n-    } else if (typeck.type_is_structural(t)) {\n+    } else if (ty.type_is_structural(t)) {\n         auto r = incr_all_refcnts(cx, src, t);\n         if (! is_init) {\n             r = drop_ty(r.bcx, dst, t);\n@@ -1128,7 +1123,7 @@ fn copy_ty(@block_ctxt cx,\n     }\n \n     cx.fcx.ccx.sess.bug(\"unexpected type in trans.copy_ty: \" +\n-                        typeck.ty_to_str(t));\n+                        ty.ty_to_str(t));\n     fail;\n }\n \n@@ -1185,22 +1180,22 @@ impure fn trans_lit(@block_ctxt cx, &ast.lit lit, &ast.ann ann) -> result {\n     }\n }\n \n-fn target_type(@crate_ctxt cx, @typeck.ty t) -> @typeck.ty {\n+fn target_type(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     alt (t.struct) {\n-        case (typeck.ty_int) {\n-            auto tm = typeck.ty_machine(cx.sess.get_targ_cfg().int_type);\n+        case (ty.ty_int) {\n+            auto tm = ty.ty_machine(cx.sess.get_targ_cfg().int_type);\n             ret @rec(struct=tm with *t);\n         }\n-        case (typeck.ty_uint) {\n-            auto tm = typeck.ty_machine(cx.sess.get_targ_cfg().uint_type);\n+        case (ty.ty_uint) {\n+            auto tm = ty.ty_machine(cx.sess.get_targ_cfg().uint_type);\n             ret @rec(struct=tm with *t);\n         }\n         case (_) { /* fall through */ }\n     }\n     ret t;\n }\n \n-fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> @typeck.ty {\n+fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> @ty.t {\n     alt (a) {\n         case (ast.ann_none) {\n             cx.sess.bug(\"missing type annotation\");\n@@ -1235,7 +1230,7 @@ impure fn trans_unary(@block_ctxt cx, ast.unop op,\n             ret sub;\n         }\n         case (ast.box) {\n-            auto e_ty = typeck.expr_ty(e);\n+            auto e_ty = ty.expr_ty(e);\n             auto e_val = sub.val;\n             sub = trans_malloc(sub.bcx, node_ann_type(sub.bcx.fcx.ccx, a));\n             auto box = sub.val;\n@@ -1254,8 +1249,8 @@ impure fn trans_unary(@block_ctxt cx, ast.unop op,\n                                         vec(C_int(0),\n                                             C_int(abi.box_rc_field_body)));\n             auto e_ty = node_ann_type(sub.bcx.fcx.ccx, a);\n-            if (typeck.type_is_scalar(e_ty) ||\n-                typeck.type_is_nil(e_ty)) {\n+            if (ty.type_is_scalar(e_ty) ||\n+                ty.type_is_nil(e_ty)) {\n                 sub.val = sub.bcx.build.Load(sub.val);\n             }\n             ret sub;\n@@ -1659,22 +1654,20 @@ impure fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n                       &ast.ident field, &ast.ann ann) -> tup(result, bool) {\n     auto lv = trans_lval(cx, base);\n     auto r = lv._0;\n-    auto ty = typeck.expr_ty(base);\n-    alt (ty.struct) {\n-        case (typeck.ty_tup(?fields)) {\n-            let uint ix = typeck.field_num(cx.fcx.ccx.sess, sp, field);\n+    auto t = ty.expr_ty(base);\n+    alt (t.struct) {\n+        case (ty.ty_tup(?fields)) {\n+            let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n             auto v = r.bcx.build.GEP(r.val, vec(C_int(0), C_int(ix as int)));\n             ret tup(res(r.bcx, v), true);\n         }\n-        case (typeck.ty_rec(?fields)) {\n-            let uint ix = typeck.field_idx(cx.fcx.ccx.sess, sp,\n-                                           field, fields);\n+        case (ty.ty_rec(?fields)) {\n+            let uint ix = ty.field_idx(cx.fcx.ccx.sess, sp, field, fields);\n             auto v = r.bcx.build.GEP(r.val, vec(C_int(0), C_int(ix as int)));\n             ret tup(res(r.bcx, v), true);\n         }\n-        case (typeck.ty_obj(?methods)) {\n-            let uint ix = typeck.method_idx(cx.fcx.ccx.sess, sp,\n-                                            field, methods);\n+        case (ty.ty_obj(?methods)) {\n+            let uint ix = ty.method_idx(cx.fcx.ccx.sess, sp, field, methods);\n             auto vtbl = r.bcx.build.GEP(r.val,\n                                         vec(C_int(0),\n                                             C_int(abi.obj_field_vtbl)));\n@@ -1747,10 +1740,10 @@ impure fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     auto llsrctype = val_ty(e_res.val);\n     auto t = node_ann_type(cx.fcx.ccx, ann);\n     auto lldsttype = type_of(cx.fcx.ccx, t);\n-    if (!typeck.type_is_fp(t)) {\n+    if (!ty.type_is_fp(t)) {\n         if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n             llvm.LLVMGetIntTypeWidth(llsrctype)) {\n-            if (typeck.type_is_signed(t)) {\n+            if (ty.type_is_signed(t)) {\n                 // Widening signed cast.\n                 e_res.val =\n                     e_res.bcx.build.SExtOrBitCast(e_res.val,\n@@ -1774,14 +1767,14 @@ impure fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n }\n \n \n-impure fn trans_args(@block_ctxt cx, &vec[@ast.expr] es, @typeck.ty fn_ty)\n+impure fn trans_args(@block_ctxt cx, &vec[@ast.expr] es, @ty.t fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef]) {\n     let vec[ValueRef] vs = vec(cx.fcx.lltaskptr);\n     let @block_ctxt bcx = cx;\n \n-    let vec[typeck.arg] args = vec();   // FIXME: typestate bug\n+    let vec[ty.arg] args = vec();   // FIXME: typestate bug\n     alt (fn_ty.struct) {\n-        case (typeck.ty_fn(?a, _)) { args = a; }\n+        case (ty.ty_fn(?a, _)) { args = a; }\n         case (_) { fail; }\n     }\n \n@@ -1790,7 +1783,7 @@ impure fn trans_args(@block_ctxt cx, &vec[@ast.expr] es, @typeck.ty fn_ty)\n         auto mode = args.(i).mode;\n \n         auto re;\n-        if (typeck.type_is_structural(typeck.expr_ty(e))) {\n+        if (ty.type_is_structural(ty.expr_ty(e))) {\n             re = trans_expr(bcx, e);\n             if (mode == ast.val) {\n                 // Until here we've been treating structures by pointer;\n@@ -1800,7 +1793,7 @@ impure fn trans_args(@block_ctxt cx, &vec[@ast.expr] es, @typeck.ty fn_ty)\n         } else {\n             if (mode == ast.alias) {\n                 let tup(result, bool /* is a pointer? */) pair;\n-                if (typeck.is_lval(e)) {\n+                if (ty.is_lval(e)) {\n                     pair = trans_lval(bcx, e);\n                 } else {\n                     pair = tup(trans_expr(bcx, e), false);\n@@ -1836,13 +1829,13 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n     if (f_res._1) {\n         faddr = f_res._0.bcx.build.Load(faddr);\n     }\n-    auto fn_ty = typeck.expr_ty(f);\n-    auto ret_ty = typeck.ann_to_type(ann);\n+    auto fn_ty = ty.expr_ty(f);\n+    auto ret_ty = ty.ann_to_type(ann);\n     auto args_res = trans_args(f_res._0.bcx, args, fn_ty);\n \n     auto real_retval = args_res._0.build.FastCall(faddr, args_res._1);\n     auto retval;\n-    if (typeck.type_is_nil(ret_ty)) {\n+    if (ty.type_is_nil(ret_ty)) {\n         retval = C_nil();\n     } else {\n         retval = real_retval;\n@@ -1851,7 +1844,7 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n     // Structured returns come back as first-class values. This is nice for\n     // LLVM but wrong for us; we treat structured values by pointer in\n     // most of our code here. So spill it to an alloca.\n-    if (typeck.type_is_structural(ret_ty)) {\n+    if (ty.type_is_structural(ret_ty)) {\n         auto local = args_res._0.build.Alloca(type_of(cx.fcx.ccx, ret_ty));\n         args_res._0.build.Store(retval, local);\n         retval = local;\n@@ -1867,14 +1860,14 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n \n impure fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n                     &ast.ann ann) -> result {\n-    auto ty = node_ann_type(cx.fcx.ccx, ann);\n-    auto llty = type_of(cx.fcx.ccx, ty);\n+    auto t = node_ann_type(cx.fcx.ccx, ann);\n+    auto llty = type_of(cx.fcx.ccx, t);\n     auto tup_val = cx.build.Alloca(llty);\n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, tup_val, ty));\n+    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, tup_val, t));\n     let int i = 0;\n     auto r = res(cx, C_nil());\n     for (ast.elt e in elts) {\n-        auto t = typeck.expr_ty(e.expr);\n+        auto t = ty.expr_ty(e.expr);\n         auto src_res = trans_expr(r.bcx, e.expr);\n         auto dst_elt = r.bcx.build.GEP(tup_val, vec(C_int(0), C_int(i)));\n         r = copy_ty(src_res.bcx, true, dst_elt, src_res.val, t);\n@@ -1885,10 +1878,10 @@ impure fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n \n impure fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n                     &ast.ann ann) -> result {\n-    auto ty = node_ann_type(cx.fcx.ccx, ann);\n-    auto unit_ty = ty;\n-    alt (ty.struct) {\n-        case (typeck.ty_vec(?t)) {\n+    auto t = node_ann_type(cx.fcx.ccx, ann);\n+    auto unit_ty = t;\n+    alt (t.struct) {\n+        case (ty.ty_vec(?t)) {\n             unit_ty = t;\n         }\n         case (_) {\n@@ -1904,9 +1897,9 @@ impure fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     // FIXME: pass tydesc properly.\n     auto sub = trans_upcall(cx, \"upcall_new_vec\", vec(data_sz, C_int(0)));\n \n-    auto llty = type_of(cx.fcx.ccx, ty);\n+    auto llty = type_of(cx.fcx.ccx, t);\n     auto vec_val = sub.bcx.build.IntToPtr(sub.val, llty);\n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, vec_val, ty));\n+    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, vec_val, t));\n \n     auto body = sub.bcx.build.GEP(vec_val, vec(C_int(0),\n                                                C_int(abi.vec_elt_data)));\n@@ -1926,14 +1919,14 @@ impure fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n \n impure fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n                     &ast.ann ann) -> result {\n-    auto ty = node_ann_type(cx.fcx.ccx, ann);\n-    auto llty = type_of(cx.fcx.ccx, ty);\n+    auto t = node_ann_type(cx.fcx.ccx, ann);\n+    auto llty = type_of(cx.fcx.ccx, t);\n     auto rec_val = cx.build.Alloca(llty);\n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, rec_val, ty));\n+    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, rec_val, t));\n     let int i = 0;\n     auto r = res(cx, C_nil());\n     for (ast.field f in fields) {\n-        auto t = typeck.expr_ty(f.expr);\n+        auto t = ty.expr_ty(f.expr);\n         auto src_res = trans_expr(r.bcx, f.expr);\n         auto dst_elt = r.bcx.build.GEP(rec_val, vec(C_int(0), C_int(i)));\n         // FIXME: calculate copy init-ness in typestate.\n@@ -2031,7 +2024,7 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n         // possibly load the result (if it's non-structural).\n \n         case (_) {\n-            auto t = typeck.expr_ty(e);\n+            auto t = ty.expr_ty(e);\n             auto sub = trans_lval(cx, e);\n             ret res(sub._0.bcx,\n                     load_non_structural(sub._0.bcx, sub._0.val, t));\n@@ -2047,8 +2040,8 @@ impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n \n fn load_non_structural(@block_ctxt cx,\n                        ValueRef v,\n-                       @typeck.ty t) -> ValueRef {\n-    if (typeck.type_is_structural(t)) {\n+                       @ty.t t) -> ValueRef {\n+    if (ty.type_is_structural(t)) {\n         ret v;\n     } else {\n         ret cx.build.Load(v);\n@@ -2058,9 +2051,9 @@ fn load_non_structural(@block_ctxt cx,\n impure fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n \n     auto sub = trans_expr(cx, e);\n-    auto e_ty = typeck.expr_ty(e);\n+    auto e_ty = ty.expr_ty(e);\n     alt (e_ty.struct) {\n-        case (typeck.ty_str) {\n+        case (ty.ty_str) {\n             auto v = sub.bcx.build.PtrToInt(sub.val, T_int());\n             ret trans_upcall(sub.bcx,\n                              \"upcall_log_str\",\n@@ -2099,14 +2092,14 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n     auto r = res(cx, C_nil());\n     alt (e) {\n         case (some[@ast.expr](?x)) {\n-            auto t = typeck.expr_ty(x);\n+            auto t = ty.expr_ty(x);\n             r = trans_expr(cx, x);\n \n             // A return is an implicit copy into a newborn anonymous\n             // 'return value' in the caller frame.\n             r.bcx = incr_all_refcnts(r.bcx, r.val, t).bcx;\n \n-            if (typeck.type_is_structural(t)) {\n+            if (ty.type_is_structural(t)) {\n                 // We usually treat structurals by-pointer; in particular,\n                 // trans_expr will have given us a structure pointer. But in\n                 // this case we're about to return. LLVM wants a first-class\n@@ -2134,7 +2127,7 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n \n     alt (e) {\n         case (some[@ast.expr](?ex)) {\n-            if (typeck.type_is_nil(typeck.expr_ty(ex))) {\n+            if (ty.type_is_nil(ty.expr_ty(ex))) {\n                 r.bcx.build.RetVoid();\n                 r.val = C_nil();\n             } else {\n@@ -2359,7 +2352,7 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx, &vec[ast.arg] args,\n // were passed and whatnot. Apparently mem2reg will mop up.\n \n fn copy_args_to_allocas(@block_ctxt cx, vec[ast.arg] args,\n-                        vec[typeck.arg] arg_tys) {\n+                        vec[ty.arg] arg_tys) {\n \n     let uint arg_n = 0u;\n \n@@ -2382,18 +2375,18 @@ fn is_terminated(@block_ctxt cx) -> bool {\n     ret llvm.LLVMIsATerminatorInst(inst) as int != 0;\n }\n \n-fn arg_tys_of_fn(ast.ann ann) -> vec[typeck.arg] {\n-    alt (typeck.ann_to_type(ann).struct) {\n-        case (typeck.ty_fn(?arg_tys, _)) {\n+fn arg_tys_of_fn(ast.ann ann) -> vec[ty.arg] {\n+    alt (ty.ann_to_type(ann).struct) {\n+        case (ty.ty_fn(?arg_tys, _)) {\n             ret arg_tys;\n         }\n     }\n     fail;\n }\n \n-fn ret_ty_of_fn(ast.ann ann) -> @typeck.ty {\n-    alt (typeck.ann_to_type(ann).struct) {\n-        case (typeck.ty_fn(_, ?ret_ty)) {\n+fn ret_ty_of_fn(ast.ann ann) -> @ty.t {\n+    alt (ty.ann_to_type(ann).struct) {\n+        case (ty.ty_fn(_, ?ret_ty)) {\n             ret ret_ty;\n         }\n     }\n@@ -2498,7 +2491,7 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n                            id=varg.id));\n     }\n \n-    auto var_ty = typeck.ann_to_type(variant.ann);\n+    auto var_ty = ty.ann_to_type(variant.ann);\n     auto llfnty = type_of(cx, var_ty);\n \n     let str s = cx.names.next(\"_rust_tag\") + \".\" + cx.path;\n@@ -2531,7 +2524,7 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n \n     // First, generate the union type.\n     let vec[TypeRef] llargtys = vec();\n-    for (typeck.arg arg in arg_tys) {\n+    for (ty.arg arg in arg_tys) {\n         llargtys += vec(type_of(cx, arg.ty));\n     }\n \n@@ -2941,9 +2934,9 @@ fn trans_crate(session.session sess, @ast.crate crate, str output) {\n     auto intrinsics = declare_intrinsics(llmod);\n \n     auto glues = make_glues(llmod);\n-    auto hasher = typeck.hash_ty;\n-    auto eqer = typeck.eq_ty;\n-    auto tydescs = map.mk_hashmap[@typeck.ty,ValueRef](hasher, eqer);\n+    auto hasher = ty.hash_ty;\n+    auto eqer = ty.eq_ty;\n+    auto tydescs = map.mk_hashmap[@ty.t,ValueRef](hasher, eqer);\n \n     auto cx = @rec(sess = sess,\n                    llmod = llmod,"}, {"sha": "19fb0285d58e311ec64fc6788fead2ee63cadaf9", "filename": "src/comp/middle/ty.rs", "status": "added", "additions": 588, "deletions": 0, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/744b164b7dafbecd84e6f11e139ca054c283e77c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744b164b7dafbecd84e6f11e139ca054c283e77c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=744b164b7dafbecd84e6f11e139ca054c283e77c", "patch": "@@ -0,0 +1,588 @@\n+import std._str;\n+import std._vec;\n+import std.option;\n+import std.option.none;\n+import std.option.some;\n+\n+import driver.session;\n+import front.ast;\n+import front.ast.mutability;\n+import util.common;\n+import util.common.span;\n+\n+// Data types\n+\n+type arg = rec(ast.mode mode, @t ty);\n+type field = rec(ast.ident ident, @t ty);\n+type method = rec(ast.ident ident, vec[arg] inputs, @t output);\n+\n+// NB: If you change this, you'll probably want to change the corresponding\n+// AST structure in front/ast.rs as well.\n+type t = rec(sty struct, mutability mut, option.t[str] cname);\n+tag sty {\n+    ty_nil;\n+    ty_bool;\n+    ty_int;\n+    ty_uint;\n+    ty_machine(util.common.ty_mach);\n+    ty_char;\n+    ty_str;\n+    ty_tag(ast.def_id);\n+    ty_box(@t);\n+    ty_vec(@t);\n+    ty_tup(vec[@t]);\n+    ty_rec(vec[field]);\n+    ty_fn(vec[arg], @t);                            // TODO: effect\n+    ty_obj(vec[method]);\n+    ty_var(int);                                    // ephemeral type var\n+    ty_local(ast.def_id);                           // type of a local var\n+    ty_param(ast.def_id);                           // fn type param\n+    // TODO: ty_fn_arg(@t), for a possibly-aliased function argument\n+}\n+\n+// Stringification\n+\n+fn ast_ty_to_str(&@ast.ty ty) -> str {\n+\n+    fn ast_fn_input_to_str(&rec(ast.mode mode, @ast.ty ty) input) -> str {\n+        auto s;\n+        if (mode_is_alias(input.mode)) {\n+            s = \"&\";\n+        } else {\n+            s = \"\";\n+        }\n+\n+        ret s + ast_ty_to_str(input.ty);\n+    }\n+\n+    fn ast_ty_field_to_str(&ast.ty_field f) -> str {\n+        ret ast_ty_to_str(f.ty) + \" \" + f.ident;\n+    }\n+\n+    auto s;\n+    alt (ty.node) {\n+        case (ast.ty_nil)          { s = \"()\";                            }\n+        case (ast.ty_bool)         { s = \"bool\";                          }\n+        case (ast.ty_int)          { s = \"int\";                           }\n+        case (ast.ty_uint)         { s = \"uint\";                          }\n+        case (ast.ty_machine(?tm)) { s = common.ty_mach_to_str(tm);       }\n+        case (ast.ty_char)         { s = \"char\";                          }\n+        case (ast.ty_str)          { s = \"str\";                           }\n+        case (ast.ty_box(?t))      { s = \"@\" + ast_ty_to_str(t);          }\n+        case (ast.ty_vec(?t))      { s = \"vec[\" + ast_ty_to_str(t) + \"]\"; }\n+\n+        case (ast.ty_tup(?elts)) {\n+            auto f = ast_ty_to_str;\n+            s = \"tup(\";\n+            s += _str.connect(_vec.map[@ast.ty,str](f, elts), \",\");\n+            s += \")\";\n+        }\n+\n+        case (ast.ty_rec(?fields)) {\n+            auto f = ast_ty_field_to_str;\n+            s = \"rec(\";\n+            s += _str.connect(_vec.map[ast.ty_field,str](f, fields), \",\");\n+            s += \")\";\n+        }\n+\n+        case (ast.ty_fn(?inputs, ?output)) {\n+            auto f = ast_fn_input_to_str;\n+            s = \"fn(\";\n+            auto is = _vec.map[rec(ast.mode mode, @ast.ty ty),str](f, inputs);\n+            s += _str.connect(is, \", \");\n+            s += \")\";\n+\n+            if (output.node != ast.ty_nil) {\n+                s += \" -> \" + ast_ty_to_str(output);\n+            }\n+        }\n+\n+        case (ast.ty_path(?path, _)) {\n+            s = path_to_str(path);\n+        }\n+\n+        case (ast.ty_mutable(?t)) {\n+            s = \"mutable \" + ast_ty_to_str(t);\n+        }\n+\n+        case (_) {\n+            fail;   // FIXME: typestate bug\n+        }\n+    }\n+\n+    ret s;\n+}\n+\n+fn name_to_str(&ast.name nm) -> str {\n+    auto result = nm.node.ident;\n+    if (_vec.len[@ast.ty](nm.node.types) > 0u) {\n+        auto f = ast_ty_to_str;\n+        result += \"[\";\n+        result += _str.connect(_vec.map[@ast.ty,str](f, nm.node.types), \",\");\n+        result += \"]\";\n+    }\n+    ret result;\n+}\n+\n+fn path_to_str(&ast.path path) -> str {\n+    auto f = name_to_str;\n+    ret _str.connect(_vec.map[ast.name,str](f, path), \".\");\n+}\n+\n+fn ty_to_str(&@t typ) -> str {\n+\n+    fn fn_input_to_str(&rec(ast.mode mode, @t ty) input) -> str {\n+        auto s;\n+        if (mode_is_alias(input.mode)) {\n+            s = \"&\";\n+        } else {\n+            s = \"\";\n+        }\n+\n+        ret s + ty_to_str(input.ty);\n+    }\n+\n+    fn fn_to_str(option.t[ast.ident] ident,\n+                 vec[arg] inputs, @t output) -> str {\n+            auto f = fn_input_to_str;\n+            auto s = \"fn\";\n+            alt (ident) {\n+                case (some[ast.ident](?i)) {\n+                    s += \" \";\n+                    s += i;\n+                }\n+                case (_) { }\n+            }\n+\n+            s += \"(\";\n+            s += _str.connect(_vec.map[arg,str](f, inputs), \", \");\n+            s += \")\";\n+\n+            if (output.struct != ty_nil) {\n+                s += \" -> \" + ty_to_str(output);\n+            }\n+            ret s;\n+    }\n+\n+    fn method_to_str(&method m) -> str {\n+        ret fn_to_str(some[ast.ident](m.ident), m.inputs, m.output) + \";\";\n+    }\n+\n+    fn field_to_str(&field f) -> str {\n+        ret ty_to_str(f.ty) + \" \" + f.ident;\n+    }\n+\n+    auto s = \"\";\n+    if (typ.mut == ast.mut) {\n+        s += \"mutable \";\n+    }\n+\n+    alt (typ.struct) {\n+        case (ty_nil)          { s = \"()\";                        }\n+        case (ty_bool)         { s = \"bool\";                      }\n+        case (ty_int)          { s = \"int\";                       }\n+        case (ty_uint)         { s = \"uint\";                      }\n+        case (ty_machine(?tm)) { s = common.ty_mach_to_str(tm);   }\n+        case (ty_char)         { s = \"char\";                      }\n+        case (ty_str)          { s = \"str\";                       }\n+        case (ty_box(?t))      { s = \"@\" + ty_to_str(t);          }\n+        case (ty_vec(?t))      { s = \"vec[\" + ty_to_str(t) + \"]\"; }\n+\n+        case (ty_tup(?elems)) {\n+            auto f = ty_to_str;\n+            auto strs = _vec.map[@t,str](f, elems);\n+            s = \"tup(\" + _str.connect(strs, \",\") + \")\";\n+        }\n+\n+        case (ty_rec(?elems)) {\n+            auto f = field_to_str;\n+            auto strs = _vec.map[field,str](f, elems);\n+            s = \"rec(\" + _str.connect(strs, \",\") + \")\";\n+        }\n+\n+        case (ty_tag(_)) {\n+            // The user should never see this if the cname is set properly!\n+            s = \"<tag>\";\n+        }\n+\n+        case (ty_fn(?inputs, ?output)) {\n+            s = fn_to_str(none[ast.ident], inputs, output);\n+        }\n+\n+        case (ty_obj(?meths)) {\n+            auto f = method_to_str;\n+            auto m = _vec.map[method,str](f, meths);\n+            s = \"obj {\\n\\t\" + _str.connect(m, \"\\n\\t\") + \"\\n}\";\n+        }\n+\n+        case (ty_var(?v)) {\n+            s = \"<T\" + util.common.istr(v) + \">\";\n+        }\n+\n+        case (ty_param(?id)) {\n+            s = \"<P\" + util.common.istr(id._0) + \":\" + util.common.istr(id._1)\n+                + \">\";\n+        }\n+    }\n+\n+    ret s;\n+}\n+\n+// Type folds\n+\n+type ty_fold = state obj {\n+    fn fold_simple_ty(@t ty) -> @t;\n+};\n+\n+fn fold_ty(ty_fold fld, @t ty) -> @t {\n+    fn rewrap(@t orig, &sty new) -> @t {\n+        ret @rec(struct=new, mut=orig.mut, cname=orig.cname);\n+    }\n+\n+    alt (ty.struct) {\n+        case (ty_nil)           { ret fld.fold_simple_ty(ty); }\n+        case (ty_bool)          { ret fld.fold_simple_ty(ty); }\n+        case (ty_int)           { ret fld.fold_simple_ty(ty); }\n+        case (ty_uint)          { ret fld.fold_simple_ty(ty); }\n+        case (ty_machine(_))    { ret fld.fold_simple_ty(ty); }\n+        case (ty_char)          { ret fld.fold_simple_ty(ty); }\n+        case (ty_str)           { ret fld.fold_simple_ty(ty); }\n+        case (ty_tag(_))        { ret fld.fold_simple_ty(ty); }\n+        case (ty_box(?subty)) {\n+            ret rewrap(ty, ty_box(fold_ty(fld, subty)));\n+        }\n+        case (ty_vec(?subty)) {\n+            ret rewrap(ty, ty_vec(fold_ty(fld, subty)));\n+        }\n+        case (ty_tup(?subtys)) {\n+            let vec[@t] new_subtys = vec();\n+            for (@t subty in subtys) {\n+                new_subtys += vec(fold_ty(fld, subty));\n+            }\n+            ret rewrap(ty, ty_tup(new_subtys));\n+        }\n+        case (ty_rec(?fields)) {\n+            let vec[field] new_fields = vec();\n+            for (field fl in fields) {\n+                auto new_ty = fold_ty(fld, fl.ty);\n+                new_fields += vec(rec(ident=fl.ident, ty=new_ty));\n+            }\n+            ret rewrap(ty, ty_rec(new_fields));\n+        }\n+        case (ty_fn(?args, ?ret_ty)) {\n+            let vec[arg] new_args = vec();\n+            for (arg a in args) {\n+                auto new_ty = fold_ty(fld, a.ty);\n+                new_args += vec(rec(mode=a.mode, ty=new_ty));\n+            }\n+            ret rewrap(ty, ty_fn(new_args, fold_ty(fld, ret_ty)));\n+        }\n+        case (ty_obj(?methods)) {\n+            let vec[method] new_methods = vec();\n+            for (method m in methods) {\n+                let vec[arg] new_args = vec();\n+                for (arg a in m.inputs) {\n+                    new_args += vec(rec(mode=a.mode, ty=fold_ty(fld, a.ty)));\n+                }\n+                new_methods += vec(rec(ident=m.ident, inputs=new_args,\n+                                       output=fold_ty(fld, m.output)));\n+            }\n+            ret rewrap(ty, ty_obj(new_methods));\n+        }\n+        case (ty_var(_))        { ret fld.fold_simple_ty(ty); }\n+        case (ty_local(_))      { ret fld.fold_simple_ty(ty); }\n+        case (ty_param(_))      { ret fld.fold_simple_ty(ty); }\n+    }\n+\n+    ret ty;\n+}\n+\n+// Type utilities\n+\n+// FIXME: remove me when == works on these tags.\n+fn mode_is_alias(ast.mode m) -> bool {\n+    alt (m) {\n+        case (ast.val) { ret false; }\n+        case (ast.alias) { ret true; }\n+    }\n+    fail;\n+}\n+\n+fn type_is_nil(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_nil) { ret true; }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n+fn type_is_structural(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_tup(_)) { ret true; }\n+        case (ty_rec(_)) { ret true; }\n+        case (ty_tag(_)) { ret true; }\n+        case (ty_fn(_,_)) { ret true; }\n+        case (ty_obj(_)) { ret true; }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n+fn type_is_boxed(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_str) { ret true; }\n+        case (ty_vec(_)) { ret true; }\n+        case (ty_box(_)) { ret true; }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n+fn type_is_scalar(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_nil) { ret true; }\n+        case (ty_bool) { ret true; }\n+        case (ty_int) { ret true; }\n+        case (ty_uint) { ret true; }\n+        case (ty_machine(_)) { ret true; }\n+        case (ty_char) { ret true; }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n+\n+fn type_is_integral(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_int) { ret true; }\n+        case (ty_uint) { ret true; }\n+        case (ty_machine(?m)) {\n+            alt (m) {\n+                case (common.ty_i8) { ret true; }\n+                case (common.ty_i16) { ret true; }\n+                case (common.ty_i32) { ret true; }\n+                case (common.ty_i64) { ret true; }\n+\n+                case (common.ty_u8) { ret true; }\n+                case (common.ty_u16) { ret true; }\n+                case (common.ty_u32) { ret true; }\n+                case (common.ty_u64) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_char) { ret true; }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n+fn type_is_fp(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_machine(?tm)) {\n+            alt (tm) {\n+                case (common.ty_f32) { ret true; }\n+                case (common.ty_f64) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n+fn type_is_signed(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_int) { ret true; }\n+        case (ty_machine(?tm)) {\n+            alt (tm) {\n+                case (common.ty_i8) { ret true; }\n+                case (common.ty_i16) { ret true; }\n+                case (common.ty_i32) { ret true; }\n+                case (common.ty_i64) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (_) { ret false; }\n+    }\n+    fail;\n+}\n+\n+fn type_param(@t ty) -> option.t[ast.def_id] {\n+    alt (ty.struct) {\n+        case (ty_param(?id)) { ret some[ast.def_id](id); }\n+        case (_)             { /* fall through */        }\n+    }\n+    ret none[ast.def_id];\n+}\n+\n+fn plain_ty(&sty st) -> @t {\n+    ret @rec(struct=st, mut=ast.imm, cname=none[str]);\n+}\n+\n+fn hash_ty(&@t ty) -> uint {\n+    ret _str.hash(ty_to_str(ty));\n+}\n+\n+fn eq_ty(&@t a, &@t b) -> bool {\n+    // FIXME: this is gross, but I think it's safe, and I don't think writing\n+    // a giant function to handle all the cases is necessary when structural\n+    // equality will someday save the day.\n+    ret _str.eq(ty_to_str(a), ty_to_str(b));\n+}\n+\n+fn ann_to_type(&ast.ann ann) -> @t {\n+    alt (ann) {\n+        case (ast.ann_none) {\n+            // shouldn't happen, but can until the typechecker is complete\n+            ret plain_ty(ty_var(-1));    // FIXME: broken, broken, broken\n+        }\n+        case (ast.ann_type(?ty)) {\n+            ret ty;\n+        }\n+    }\n+}\n+\n+fn count_ty_params(@t ty) -> uint {\n+    state obj ty_param_counter(@mutable vec[ast.def_id] param_ids) {\n+        fn fold_simple_ty(@t ty) -> @t {\n+            alt (ty.struct) {\n+                case (ty_param(?param_id)) {\n+                    for (ast.def_id other_param_id in *param_ids) {\n+                        if (param_id._0 == other_param_id._0 &&\n+                                param_id._1 == other_param_id._1) {\n+                            ret ty;\n+                        }\n+                    }\n+                    *param_ids += vec(param_id);\n+                }\n+                case (_) { /* fall through */ }\n+            }\n+            ret ty;\n+        }\n+    }\n+\n+    let vec[ast.def_id] param_ids_inner = vec();\n+    let @mutable vec[ast.def_id] param_ids = @mutable param_ids_inner;\n+    fold_ty(ty_param_counter(param_ids), ty);\n+    ret _vec.len[ast.def_id](*param_ids);\n+}\n+\n+// Type accessors for AST nodes\n+\n+fn stmt_ty(@ast.stmt s) -> @t {\n+    alt (s.node) {\n+        case (ast.stmt_expr(?e)) {\n+            ret expr_ty(e);\n+        }\n+        case (_) {\n+            ret plain_ty(ty_nil);\n+        }\n+    }\n+}\n+\n+fn block_ty(&ast.block b) -> @t {\n+    alt (b.node.expr) {\n+        case (some[@ast.expr](?e)) { ret expr_ty(e); }\n+        case (none[@ast.expr])     { ret plain_ty(ty_nil); }\n+    }\n+}\n+\n+fn pat_ty(@ast.pat pat) -> @t {\n+    alt (pat.node) {\n+        case (ast.pat_wild(?ann))           { ret ann_to_type(ann); }\n+        case (ast.pat_bind(_, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.pat_tag(_, _, _, ?ann))   { ret ann_to_type(ann); }\n+    }\n+    fail;   // not reached\n+}\n+\n+fn expr_ty(@ast.expr expr) -> @t {\n+    alt (expr.node) {\n+        case (ast.expr_vec(_, ?ann))          { ret ann_to_type(ann); }\n+        case (ast.expr_tup(_, ?ann))          { ret ann_to_type(ann); }\n+        case (ast.expr_rec(_, ?ann))          { ret ann_to_type(ann); }\n+        case (ast.expr_call(_, _, ?ann))      { ret ann_to_type(ann); }\n+        case (ast.expr_binary(_, _, _, ?ann)) { ret ann_to_type(ann); }\n+        case (ast.expr_unary(_, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_lit(_, ?ann))          { ret ann_to_type(ann); }\n+        case (ast.expr_cast(_, _, ?ann))      { ret ann_to_type(ann); }\n+        case (ast.expr_if(_, _, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_while(_, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_do_while(_, _, ?ann))  { ret ann_to_type(ann); }\n+        case (ast.expr_alt(_, _, ?ann))       { ret ann_to_type(ann); }\n+        case (ast.expr_block(_, ?ann))        { ret ann_to_type(ann); }\n+        case (ast.expr_assign(_, _, ?ann))    { ret ann_to_type(ann); }\n+        case (ast.expr_assign_op(_, _, _, ?ann))\n+                                              { ret ann_to_type(ann); }\n+        case (ast.expr_field(_, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_index(_, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_name(_, _, ?ann))      { ret ann_to_type(ann); }\n+    }\n+    fail;\n+}\n+\n+// Expression utilities\n+\n+fn field_num(session.session sess, &span sp, &ast.ident id) -> uint {\n+    let uint accum = 0u;\n+    let uint i = 0u;\n+    for (u8 c in id) {\n+        if (i == 0u) {\n+            if (c != ('_' as u8)) {\n+                sess.span_err(sp,\n+                              \"bad numeric field on tuple: \"\n+                              + \"missing leading underscore\");\n+            }\n+        } else {\n+            if (('0' as u8) <= c && c <= ('9' as u8)) {\n+                accum *= 10u;\n+                accum += (c as uint) - ('0' as uint);\n+            } else {\n+                auto s = \"\";\n+                s += c;\n+                sess.span_err(sp,\n+                              \"bad numeric field on tuple: \"\n+                              + \" non-digit character: \"\n+                              + s);\n+            }\n+        }\n+        i += 1u;\n+    }\n+    ret accum;\n+}\n+\n+fn field_idx(session.session sess, &span sp,\n+             &ast.ident id, vec[field] fields) -> uint {\n+    let uint i = 0u;\n+    for (field f in fields) {\n+        if (_str.eq(f.ident, id)) {\n+            ret i;\n+        }\n+        i += 1u;\n+    }\n+    sess.span_err(sp, \"unknown field '\" + id + \"' of record\");\n+    fail;\n+}\n+\n+fn method_idx(session.session sess, &span sp,\n+              &ast.ident id, vec[method] meths) -> uint {\n+    let uint i = 0u;\n+    for (method m in meths) {\n+        if (_str.eq(m.ident, id)) {\n+            ret i;\n+        }\n+        i += 1u;\n+    }\n+    sess.span_err(sp, \"unknown method '\" + id + \"' of obj\");\n+    fail;\n+}\n+\n+fn is_lval(@ast.expr expr) -> bool {\n+    alt (expr.node) {\n+        case (ast.expr_field(_,_,_))    { ret true;  }\n+        case (ast.expr_index(_,_,_))    { ret true;  }\n+        case (ast.expr_name(_,_,_))     { ret true;  }\n+        case (_)                        { ret false; }\n+    }\n+}\n+"}, {"sha": "8994d72d1513bfac46df64fa0bc3e3f028000325", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 186, "deletions": 743, "changes": 929, "blob_url": "https://github.com/rust-lang/rust/blob/744b164b7dafbecd84e6f11e139ca054c283e77c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744b164b7dafbecd84e6f11e139ca054c283e77c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=744b164b7dafbecd84e6f11e139ca054c283e77c", "patch": "@@ -7,6 +7,21 @@ import util.common;\n import util.common.append;\n import util.common.span;\n \n+import middle.ty;\n+import middle.ty.ann_to_type;\n+import middle.ty.arg;\n+import middle.ty.block_ty;\n+import middle.ty.expr_ty;\n+import middle.ty.field;\n+import middle.ty.method;\n+import middle.ty.mode_is_alias;\n+import middle.ty.pat_ty;\n+import middle.ty.path_to_str;\n+import middle.ty.plain_ty;\n+import middle.ty.ty_to_str;\n+import middle.ty.type_is_integral;\n+import middle.ty.type_is_scalar;\n+\n import std._str;\n import std._uint;\n import std._vec;\n@@ -16,42 +31,17 @@ import std.option;\n import std.option.none;\n import std.option.some;\n \n-type ty_table = hashmap[ast.def_id, @ty];\n+type ty_table = hashmap[ast.def_id, @ty.t];\n type crate_ctxt = rec(session.session sess,\n                       @ty_table item_types,\n                       mutable int next_var_id);\n \n-type fn_ctxt = rec(@ty ret_ty,\n+type fn_ctxt = rec(@ty.t ret_ty,\n                    @ty_table locals,\n                    @crate_ctxt ccx);\n \n-type arg = rec(ast.mode mode, @ty ty);\n-type field = rec(ast.ident ident, @ty ty);\n-type method = rec(ast.ident ident, vec[arg] inputs, @ty output);\n-\n-// NB: If you change this, you'll probably want to change the corresponding\n-// AST structure in front/ast.rs as well.\n-type ty = rec(sty struct, mutability mut, option.t[str] cname);\n-tag sty {\n-    ty_nil;\n-    ty_bool;\n-    ty_int;\n-    ty_uint;\n-    ty_machine(util.common.ty_mach);\n-    ty_char;\n-    ty_str;\n-    ty_tag(ast.def_id);\n-    ty_box(@ty);\n-    ty_vec(@ty);\n-    ty_tup(vec[@ty]);\n-    ty_rec(vec[field]);\n-    ty_fn(vec[arg], @ty);                           // TODO: effect\n-    ty_obj(vec[method]);\n-    ty_var(int);                                    // ephemeral type var\n-    ty_local(ast.def_id);                           // type of a local var\n-    ty_param(ast.def_id);                           // fn type param\n-    // TODO: ty_fn_arg(@ty), for a possibly-aliased function argument\n-}\n+// Used for ast_ty_to_ty() below.\n+type ty_getter = fn(ast.def_id) -> @ty.t;\n \n tag type_err {\n     terr_mismatch;\n@@ -64,208 +54,18 @@ tag type_err {\n }\n \n tag unify_result {\n-    ures_ok(@ty);\n-    ures_err(type_err, @ty, @ty);\n-}\n-\n-// Used for ast_ty_to_ty() below.\n-type ty_getter = fn(ast.def_id) -> @ty;\n-\n-// Error-reporting utility functions\n-\n-fn ast_ty_to_str(&@ast.ty ty) -> str {\n-\n-    fn ast_fn_input_to_str(&rec(ast.mode mode, @ast.ty ty) input) -> str {\n-        auto s;\n-        if (mode_is_alias(input.mode)) {\n-            s = \"&\";\n-        } else {\n-            s = \"\";\n-        }\n-\n-        ret s + ast_ty_to_str(input.ty);\n-    }\n-\n-    fn ast_ty_field_to_str(&ast.ty_field f) -> str {\n-        ret ast_ty_to_str(f.ty) + \" \" + f.ident;\n-    }\n-\n-    auto s;\n-    alt (ty.node) {\n-        case (ast.ty_nil)          { s = \"()\";                            }\n-        case (ast.ty_bool)         { s = \"bool\";                          }\n-        case (ast.ty_int)          { s = \"int\";                           }\n-        case (ast.ty_uint)         { s = \"uint\";                          }\n-        case (ast.ty_machine(?tm)) { s = common.ty_mach_to_str(tm);       }\n-        case (ast.ty_char)         { s = \"char\";                          }\n-        case (ast.ty_str)          { s = \"str\";                           }\n-        case (ast.ty_box(?t))      { s = \"@\" + ast_ty_to_str(t);          }\n-        case (ast.ty_vec(?t))      { s = \"vec[\" + ast_ty_to_str(t) + \"]\"; }\n-\n-        case (ast.ty_tup(?elts)) {\n-            auto f = ast_ty_to_str;\n-            s = \"tup(\";\n-            s += _str.connect(_vec.map[@ast.ty,str](f, elts), \",\");\n-            s += \")\";\n-        }\n-\n-        case (ast.ty_rec(?fields)) {\n-            auto f = ast_ty_field_to_str;\n-            s = \"rec(\";\n-            s += _str.connect(_vec.map[ast.ty_field,str](f, fields), \",\");\n-            s += \")\";\n-        }\n-\n-        case (ast.ty_fn(?inputs, ?output)) {\n-            auto f = ast_fn_input_to_str;\n-            s = \"fn(\";\n-            auto is = _vec.map[rec(ast.mode mode, @ast.ty ty),str](f, inputs);\n-            s += _str.connect(is, \", \");\n-            s += \")\";\n-\n-            if (output.node != ast.ty_nil) {\n-                s += \" -> \" + ast_ty_to_str(output);\n-            }\n-        }\n-\n-        case (ast.ty_path(?path, _)) {\n-            s = path_to_str(path);\n-        }\n-\n-        case (ast.ty_mutable(?t)) {\n-            s = \"mutable \" + ast_ty_to_str(t);\n-        }\n-\n-        case (_) {\n-            fail;   // FIXME: typestate bug\n-        }\n-    }\n-\n-    ret s;\n-}\n-\n-fn name_to_str(&ast.name nm) -> str {\n-    auto result = nm.node.ident;\n-    if (_vec.len[@ast.ty](nm.node.types) > 0u) {\n-        auto f = ast_ty_to_str;\n-        result += \"[\";\n-        result += _str.connect(_vec.map[@ast.ty,str](f, nm.node.types), \",\");\n-        result += \"]\";\n-    }\n-    ret result;\n-}\n-\n-fn path_to_str(&ast.path path) -> str {\n-    auto f = name_to_str;\n-    ret _str.connect(_vec.map[ast.name,str](f, path), \".\");\n-}\n-\n-fn ty_to_str(&@ty typ) -> str {\n-\n-    fn fn_input_to_str(&rec(ast.mode mode, @ty ty) input) -> str {\n-        auto s;\n-        if (mode_is_alias(input.mode)) {\n-            s = \"&\";\n-        } else {\n-            s = \"\";\n-        }\n-\n-        ret s + ty_to_str(input.ty);\n-    }\n-\n-    fn fn_to_str(option.t[ast.ident] ident,\n-                 vec[arg] inputs, @ty output) -> str {\n-            auto f = fn_input_to_str;\n-            auto s = \"fn\";\n-            alt (ident) {\n-                case (some[ast.ident](?i)) {\n-                    s += \" \";\n-                    s += i;\n-                }\n-                case (_) { }\n-            }\n-\n-            s += \"(\";\n-            s += _str.connect(_vec.map[arg,str](f, inputs), \", \");\n-            s += \")\";\n-\n-            if (output.struct != ty_nil) {\n-                s += \" -> \" + ty_to_str(output);\n-            }\n-            ret s;\n-    }\n-\n-    fn method_to_str(&method m) -> str {\n-        ret fn_to_str(some[ast.ident](m.ident), m.inputs, m.output) + \";\";\n-    }\n-\n-    fn field_to_str(&field f) -> str {\n-        ret ty_to_str(f.ty) + \" \" + f.ident;\n-    }\n-\n-    auto s = \"\";\n-    if (typ.mut == ast.mut) {\n-        s += \"mutable \";\n-    }\n-\n-    alt (typ.struct) {\n-        case (ty_nil)          { s = \"()\";                        }\n-        case (ty_bool)         { s = \"bool\";                      }\n-        case (ty_int)          { s = \"int\";                       }\n-        case (ty_uint)         { s = \"uint\";                      }\n-        case (ty_machine(?tm)) { s = common.ty_mach_to_str(tm);   }\n-        case (ty_char)         { s = \"char\";                      }\n-        case (ty_str)          { s = \"str\";                       }\n-        case (ty_box(?t))      { s = \"@\" + ty_to_str(t);          }\n-        case (ty_vec(?t))      { s = \"vec[\" + ty_to_str(t) + \"]\"; }\n-\n-        case (ty_tup(?elems)) {\n-            auto f = ty_to_str;\n-            auto strs = _vec.map[@ty,str](f, elems);\n-            s = \"tup(\" + _str.connect(strs, \",\") + \")\";\n-        }\n-\n-        case (ty_rec(?elems)) {\n-            auto f = field_to_str;\n-            auto strs = _vec.map[field,str](f, elems);\n-            s = \"rec(\" + _str.connect(strs, \",\") + \")\";\n-        }\n-\n-        case (ty_tag(_)) {\n-            // The user should never see this if the cname is set properly!\n-            s = \"<tag>\";\n-        }\n-\n-        case (ty_fn(?inputs, ?output)) {\n-            s = fn_to_str(none[ast.ident], inputs, output);\n-        }\n-\n-        case (ty_obj(?meths)) {\n-            auto f = method_to_str;\n-            auto m = _vec.map[method,str](f, meths);\n-            s = \"obj {\\n\\t\" + _str.connect(m, \"\\n\\t\") + \"\\n}\";\n-        }\n-\n-        case (ty_var(?v)) {\n-            s = \"<T\" + util.common.istr(v) + \">\";\n-        }\n-\n-        case (ty_param(?id)) {\n-            s = \"<P\" + util.common.istr(id._0) + \":\" + util.common.istr(id._1)\n-                + \">\";\n-        }\n-    }\n-\n-    ret s;\n+    ures_ok(@ty.t);\n+    ures_err(type_err, @ty.t, @ty.t);\n }\n \n // Replaces parameter types inside a type with type variables.\n-fn generalize_ty(@crate_ctxt cx, @ty t) -> @ty {\n+fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     state obj ty_generalizer(@crate_ctxt cx,\n-                             @hashmap[ast.def_id,@ty] ty_params_to_ty_vars) {\n-        fn fold_simple_ty(@ty t) -> @ty {\n+                             @hashmap[ast.def_id,@ty.t]\n+                             ty_params_to_ty_vars) {\n+        fn fold_simple_ty(@ty.t t) -> @ty.t {\n             alt (t.struct) {\n-                case (ty_param(?pid)) {\n+                case (ty.ty_param(?pid)) {\n                     if (ty_params_to_ty_vars.contains_key(pid)) {\n                         ret ty_params_to_ty_vars.get(pid);\n                     }\n@@ -279,52 +79,52 @@ fn generalize_ty(@crate_ctxt cx, @ty t) -> @ty {\n         }\n     }\n \n-    auto generalizer = ty_generalizer(cx, @common.new_def_hash[@ty]());\n-    ret fold_ty(generalizer, t);\n+    auto generalizer = ty_generalizer(cx, @common.new_def_hash[@ty.t]());\n+    ret ty.fold_ty(generalizer, t);\n }\n \n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID.\n-fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n+fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n     fn ast_arg_to_arg(ty_getter getter, &rec(ast.mode mode, @ast.ty ty) arg)\n-            -> rec(ast.mode mode, @ty ty) {\n+            -> rec(ast.mode mode, @ty.t ty) {\n         ret rec(mode=arg.mode, ty=ast_ty_to_ty(getter, arg.ty));\n     }\n \n     auto mut = ast.imm;\n     auto sty;\n     auto cname = none[str];\n     alt (ast_ty.node) {\n-        case (ast.ty_nil)          { sty = ty_nil; }\n-        case (ast.ty_bool)         { sty = ty_bool; }\n-        case (ast.ty_int)          { sty = ty_int; }\n-        case (ast.ty_uint)         { sty = ty_uint; }\n-        case (ast.ty_machine(?tm)) { sty = ty_machine(tm); }\n-        case (ast.ty_char)         { sty = ty_char; }\n-        case (ast.ty_str)          { sty = ty_str; }\n-        case (ast.ty_box(?t))      { sty = ty_box(ast_ty_to_ty(getter, t)); }\n-        case (ast.ty_vec(?t))      { sty = ty_vec(ast_ty_to_ty(getter, t)); }\n+        case (ast.ty_nil)          { sty = ty.ty_nil; }\n+        case (ast.ty_bool)         { sty = ty.ty_bool; }\n+        case (ast.ty_int)          { sty = ty.ty_int; }\n+        case (ast.ty_uint)         { sty = ty.ty_uint; }\n+        case (ast.ty_machine(?tm)) { sty = ty.ty_machine(tm); }\n+        case (ast.ty_char)         { sty = ty.ty_char; }\n+        case (ast.ty_str)          { sty = ty.ty_str; }\n+        case (ast.ty_box(?t)) { sty = ty.ty_box(ast_ty_to_ty(getter, t)); }\n+        case (ast.ty_vec(?t)) { sty = ty.ty_vec(ast_ty_to_ty(getter, t)); }\n         case (ast.ty_tup(?fields)) {\n-            let vec[@ty] flds = vec();\n+            let vec[@ty.t] flds = vec();\n             for (@ast.ty field in fields) {\n-                append[@ty](flds, ast_ty_to_ty(getter, field));\n+                append[@ty.t](flds, ast_ty_to_ty(getter, field));\n             }\n-            sty = ty_tup(flds);\n+            sty = ty.ty_tup(flds);\n         }\n         case (ast.ty_rec(?fields)) {\n             let vec[field] flds = vec();\n             for (ast.ty_field f in fields) {\n                 append[field](flds, rec(ident=f.ident,\n                                         ty=ast_ty_to_ty(getter, f.ty)));\n             }\n-            sty = ty_rec(flds);\n+            sty = ty.ty_rec(flds);\n         }\n \n         case (ast.ty_fn(?inputs, ?output)) {\n             auto f = bind ast_arg_to_arg(getter, _);\n             auto i = _vec.map[rec(ast.mode mode, @ast.ty ty),arg](f, inputs);\n-            sty = ty_fn(i, ast_ty_to_ty(getter, output));\n+            sty = ty.ty_fn(i, ast_ty_to_ty(getter, output));\n         }\n \n         case (ast.ty_path(?path, ?def)) {\n@@ -335,7 +135,7 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n                     // \"foo = int\" like OCaml?\n                     sty = getter(id).struct;\n                 }\n-                case (ast.def_ty_arg(?id))  { sty = ty_param(id); }\n+                case (ast.def_ty_arg(?id))  { sty = ty.ty_param(id); }\n                 case (_)                    { fail; }\n             }\n \n@@ -359,8 +159,8 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n \n // A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n-fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty {\n-    fn getter(@crate_ctxt ccx, ast.def_id id) -> @ty {\n+fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n+    fn getter(@crate_ctxt ccx, ast.def_id id) -> @ty.t {\n         check (ccx.item_types.contains_key(id));\n         ret ccx.item_types.get(id);\n     }\n@@ -417,7 +217,7 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n \n     fn getter(@ty_item_table id_to_ty_item,\n               @ty_table item_to_ty,\n-              ast.def_id id) -> @ty {\n+              ast.def_id id) -> @ty.t {\n         check (id_to_ty_item.contains_key(id));\n         auto item = id_to_ty_item.get(id);\n         ret ty_of_item(id_to_ty_item, item_to_ty, item);\n@@ -443,31 +243,31 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n \n     fn ty_of_obj(@ty_item_table id_to_ty_item,\n                  @ty_table item_to_ty,\n-                 &ast._obj obj_info) -> @ty {\n+                 &ast._obj obj_info) -> @ty.t {\n         auto f = bind ty_of_method(id_to_ty_item, item_to_ty, _);\n         auto methods =\n             _vec.map[@ast.method,method](f, obj_info.methods);\n \n-        auto t_obj = plain_ty(ty_obj(methods));\n+        auto t_obj = plain_ty(ty.ty_obj(methods));\n         ret t_obj;\n     }\n \n     fn ty_of_obj_ctor(@ty_item_table id_to_ty_item,\n                       @ty_table item_to_ty,\n-                      &ast._obj obj_info) -> @ty {\n+                      &ast._obj obj_info) -> @ty.t {\n         auto t_obj = ty_of_obj(id_to_ty_item, item_to_ty, obj_info);\n         let vec[arg] t_inputs = vec();\n         for (ast.obj_field f in obj_info.fields) {\n             auto t_field = getter(id_to_ty_item, item_to_ty, f.id);\n             append[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n         }\n-        auto t_fn = plain_ty(ty_fn(t_inputs, t_obj));\n+        auto t_fn = plain_ty(ty.ty_fn(t_inputs, t_obj));\n         ret t_fn;\n     }\n \n     fn ty_of_item(@ty_item_table id_to_ty_item,\n                   @ty_table item_to_ty,\n-                  @ast.item it) -> @ty {\n+                  @ast.item it) -> @ty.t {\n \n         auto get = bind getter(id_to_ty_item, item_to_ty, _);\n         auto convert = bind ast_ty_to_ty(get, _);\n@@ -485,7 +285,7 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n                 auto input_tys = _vec.map[ast.arg,arg](f, fn_info.inputs);\n                 auto output_ty = convert(fn_info.output);\n \n-                auto t_fn = plain_ty(ty_fn(input_tys, output_ty));\n+                auto t_fn = plain_ty(ty.ty_fn(input_tys, output_ty));\n                 item_to_ty.insert(def_id, t_fn);\n                 ret t_fn;\n             }\n@@ -513,9 +313,9 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n             }\n \n             case (ast.item_tag(_, _, _, ?def_id)) {\n-                auto ty = plain_ty(ty_tag(def_id));\n-                item_to_ty.insert(def_id, ty);\n-                ret ty;\n+                auto t = plain_ty(ty.ty_tag(def_id));\n+                item_to_ty.insert(def_id, t);\n+                ret t;\n             }\n \n             case (ast.item_mod(_, _, _)) { fail; }\n@@ -533,7 +333,7 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n             // constructors get turned into functions.\n             auto result_ty;\n             if (_vec.len[ast.variant_arg](variant.args) == 0u) {\n-                result_ty = plain_ty(ty_tag(tag_id));\n+                result_ty = plain_ty(ty.ty_tag(tag_id));\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n@@ -544,7 +344,8 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n                     auto arg_ty = ast_ty_to_ty(f, va.ty);\n                     args += vec(rec(mode=ast.alias, ty=arg_ty));\n                 }\n-                result_ty = plain_ty(ty_fn(args, plain_ty(ty_tag(tag_id))));\n+                auto tag_t = plain_ty(ty.ty_tag(tag_id));\n+                result_ty = plain_ty(ty.ty_fn(args, tag_t));\n             }\n \n             item_to_ty.insert(variant.id, result_ty);\n@@ -580,7 +381,7 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n \n \n     // Second pass: translate the types of all items.\n-    let @ty_table item_to_ty = @common.new_def_hash[@ty]();\n+    let @ty_table item_to_ty = @common.new_def_hash[@ty.t]();\n \n     type env = rec(@ty_item_table id_to_ty_item,\n                    @ty_table item_to_ty);\n@@ -621,11 +422,11 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n-    fn get_ctor_obj_methods(@ty t) -> vec[method] {\n+    fn get_ctor_obj_methods(@ty.t t) -> vec[method] {\n         alt (t.struct) {\n-            case (ty_fn(_,?tobj)) {\n+            case (ty.ty_fn(_,?tobj)) {\n                 alt (tobj.struct) {\n-                    case (ty_obj(?tm)) {\n+                    case (ty.ty_obj(?tm)) {\n                         ret tm;\n                     }\n                     case (_) {\n@@ -646,17 +447,17 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n                     &ast._obj ob, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n         check (e.item_to_ty.contains_key(id));\n-        auto ty = e.item_to_ty.get(id);\n-        let vec[method] meth_tys = get_ctor_obj_methods(ty);\n+        auto t = e.item_to_ty.get(id);\n+        let vec[method] meth_tys = get_ctor_obj_methods(t);\n         let vec[@ast.method] methods = vec();\n \n         let uint n = 0u;\n         for (method meth_ty in meth_tys) {\n             let @ast.method meth = ob.methods.(n);\n             let ast.method_ m_;\n             let @ast.method m;\n-            auto meth_tfn = plain_ty(ty_fn(meth_ty.inputs,\n-                                           meth_ty.output));\n+            auto meth_tfn = plain_ty(ty.ty_fn(meth_ty.inputs,\n+                                              meth_ty.output));\n             m_ = rec(ann=ast.ann_type(meth_tfn) with meth.node);\n             m = @rec(node=m_ with *meth);\n             append[@ast.method](methods, m);\n@@ -665,7 +466,7 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n \n         auto ob_ = rec(methods = methods with ob);\n         auto item = ast.item_obj(i, ob_, ty_params, id,\n-                                 ast.ann_type(ty));\n+                                 ast.ann_type(t));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -703,367 +504,9 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n     ret tup(crate_, item_to_ty);\n }\n \n-// Expression utilities\n-\n-fn field_num(session.session sess, &span sp, &ast.ident id) -> uint {\n-    let uint accum = 0u;\n-    let uint i = 0u;\n-    for (u8 c in id) {\n-        if (i == 0u) {\n-            if (c != ('_' as u8)) {\n-                sess.span_err(sp,\n-                              \"bad numeric field on tuple: \"\n-                              + \"missing leading underscore\");\n-            }\n-        } else {\n-            if (('0' as u8) <= c && c <= ('9' as u8)) {\n-                accum *= 10u;\n-                accum += (c as uint) - ('0' as uint);\n-            } else {\n-                auto s = \"\";\n-                s += c;\n-                sess.span_err(sp,\n-                              \"bad numeric field on tuple: \"\n-                              + \" non-digit character: \"\n-                              + s);\n-            }\n-        }\n-        i += 1u;\n-    }\n-    ret accum;\n-}\n-\n-fn field_idx(session.session sess, &span sp,\n-             &ast.ident id, vec[field] fields) -> uint {\n-    let uint i = 0u;\n-    for (field f in fields) {\n-        if (_str.eq(f.ident, id)) {\n-            ret i;\n-        }\n-        i += 1u;\n-    }\n-    sess.span_err(sp, \"unknown field '\" + id + \"' of record\");\n-    fail;\n-}\n-\n-fn method_idx(session.session sess, &span sp,\n-              &ast.ident id, vec[method] meths) -> uint {\n-    let uint i = 0u;\n-    for (method m in meths) {\n-        if (_str.eq(m.ident, id)) {\n-            ret i;\n-        }\n-        i += 1u;\n-    }\n-    sess.span_err(sp, \"unknown method '\" + id + \"' of obj\");\n-    fail;\n-}\n-\n-fn is_lval(@ast.expr expr) -> bool {\n-    alt (expr.node) {\n-        case (ast.expr_field(_,_,_))    { ret true;  }\n-        case (ast.expr_index(_,_,_))    { ret true;  }\n-        case (ast.expr_name(_,_,_))     { ret true;  }\n-        case (_)                        { ret false; }\n-    }\n-}\n-\n-// Type folds\n-\n-type ty_fold = state obj {\n-    fn fold_simple_ty(@ty ty) -> @ty;\n-};\n-\n-fn fold_ty(ty_fold fld, @ty t) -> @ty {\n-    fn rewrap(@ty orig, &sty new) -> @ty {\n-        ret @rec(struct=new, mut=orig.mut, cname=orig.cname);\n-    }\n-\n-    alt (t.struct) {\n-        case (ty_nil)           { ret fld.fold_simple_ty(t); }\n-        case (ty_bool)          { ret fld.fold_simple_ty(t); }\n-        case (ty_int)           { ret fld.fold_simple_ty(t); }\n-        case (ty_uint)          { ret fld.fold_simple_ty(t); }\n-        case (ty_machine(_))    { ret fld.fold_simple_ty(t); }\n-        case (ty_char)          { ret fld.fold_simple_ty(t); }\n-        case (ty_str)           { ret fld.fold_simple_ty(t); }\n-        case (ty_tag(_))        { ret fld.fold_simple_ty(t); }\n-        case (ty_box(?subty)) {\n-            ret rewrap(t, ty_box(fold_ty(fld, subty)));\n-        }\n-        case (ty_vec(?subty)) {\n-            ret rewrap(t, ty_vec(fold_ty(fld, subty)));\n-        }\n-        case (ty_tup(?subtys)) {\n-            let vec[@ty] new_subtys = vec();\n-            for (@ty subty in subtys) {\n-                new_subtys += vec(fold_ty(fld, subty));\n-            }\n-            ret rewrap(t, ty_tup(new_subtys));\n-        }\n-        case (ty_rec(?fields)) {\n-            let vec[field] new_fields = vec();\n-            for (field fl in fields) {\n-                auto new_ty = fold_ty(fld, fl.ty);\n-                new_fields += vec(rec(ident=fl.ident, ty=new_ty));\n-            }\n-            ret rewrap(t, ty_rec(new_fields));\n-        }\n-        case (ty_fn(?args, ?ret_ty)) {\n-            let vec[arg] new_args = vec();\n-            for (arg a in args) {\n-                auto new_ty = fold_ty(fld, a.ty);\n-                new_args += vec(rec(mode=a.mode, ty=new_ty));\n-            }\n-            ret rewrap(t, ty_fn(new_args, fold_ty(fld, ret_ty)));\n-        }\n-        case (ty_obj(?methods)) {\n-            let vec[method] new_methods = vec();\n-            for (method m in methods) {\n-                let vec[arg] new_args = vec();\n-                for (arg a in m.inputs) {\n-                    new_args += vec(rec(mode=a.mode, ty=fold_ty(fld, a.ty)));\n-                }\n-                new_methods += vec(rec(ident=m.ident, inputs=new_args,\n-                                       output=fold_ty(fld, m.output)));\n-            }\n-            ret rewrap(t, ty_obj(new_methods));\n-        }\n-        case (ty_var(_))        { ret fld.fold_simple_ty(t); }\n-        case (ty_local(_))      { ret fld.fold_simple_ty(t); }\n-        case (ty_param(_))      { ret fld.fold_simple_ty(t); }\n-    }\n-\n-    ret t;\n-}\n-\n-// Type utilities\n-\n-// FIXME: remove me when == works on these tags.\n-fn mode_is_alias(ast.mode m) -> bool {\n-    alt (m) {\n-        case (ast.val) { ret false; }\n-        case (ast.alias) { ret true; }\n-    }\n-    fail;\n-}\n-\n-fn type_is_nil(@ty t) -> bool {\n-    alt (t.struct) {\n-        case (ty_nil) { ret true; }\n-        case (_) { ret false; }\n-    }\n-    fail;\n-}\n-\n-fn type_is_structural(@ty t) -> bool {\n-    alt (t.struct) {\n-        case (ty_tup(_)) { ret true; }\n-        case (ty_rec(_)) { ret true; }\n-        case (ty_tag(_)) { ret true; }\n-        case (ty_fn(_,_)) { ret true; }\n-        case (ty_obj(_)) { ret true; }\n-        case (_) { ret false; }\n-    }\n-    fail;\n-}\n-\n-fn type_is_boxed(@ty t) -> bool {\n-    alt (t.struct) {\n-        case (ty_str) { ret true; }\n-        case (ty_vec(_)) { ret true; }\n-        case (ty_box(_)) { ret true; }\n-        case (_) { ret false; }\n-    }\n-    fail;\n-}\n-\n-fn type_is_scalar(@ty t) -> bool {\n-    alt (t.struct) {\n-        case (ty_nil) { ret true; }\n-        case (ty_bool) { ret true; }\n-        case (ty_int) { ret true; }\n-        case (ty_uint) { ret true; }\n-        case (ty_machine(_)) { ret true; }\n-        case (ty_char) { ret true; }\n-        case (_) { ret false; }\n-    }\n-    fail;\n-}\n-\n-\n-fn type_is_integral(@ty t) -> bool {\n-    alt (t.struct) {\n-        case (ty_int) { ret true; }\n-        case (ty_uint) { ret true; }\n-        case (ty_machine(?m)) {\n-            alt (m) {\n-                case (common.ty_i8) { ret true; }\n-                case (common.ty_i16) { ret true; }\n-                case (common.ty_i32) { ret true; }\n-                case (common.ty_i64) { ret true; }\n-\n-                case (common.ty_u8) { ret true; }\n-                case (common.ty_u16) { ret true; }\n-                case (common.ty_u32) { ret true; }\n-                case (common.ty_u64) { ret true; }\n-                case (_) { ret false; }\n-            }\n-        }\n-        case (ty_char) { ret true; }\n-        case (_) { ret false; }\n-    }\n-    fail;\n-}\n-\n-fn type_is_fp(@ty t) -> bool {\n-    alt (t.struct) {\n-        case (ty_machine(?tm)) {\n-            alt (tm) {\n-                case (common.ty_f32) { ret true; }\n-                case (common.ty_f64) { ret true; }\n-                case (_) { ret false; }\n-            }\n-        }\n-        case (_) { ret false; }\n-    }\n-    fail;\n-}\n-\n-fn type_is_signed(@ty t) -> bool {\n-    alt (t.struct) {\n-        case (ty_int) { ret true; }\n-        case (ty_machine(?tm)) {\n-            alt (tm) {\n-                case (common.ty_i8) { ret true; }\n-                case (common.ty_i16) { ret true; }\n-                case (common.ty_i32) { ret true; }\n-                case (common.ty_i64) { ret true; }\n-                case (_) { ret false; }\n-            }\n-        }\n-        case (_) { ret false; }\n-    }\n-    fail;\n-}\n-\n-fn type_param(@ty t) -> option.t[ast.def_id] {\n-    alt (t.struct) {\n-        case (ty_param(?id)) { ret some[ast.def_id](id); }\n-        case (_)             { /* fall through */        }\n-    }\n-    ret none[ast.def_id];\n-}\n-\n-fn plain_ty(&sty st) -> @ty {\n-    ret @rec(struct=st, mut=ast.imm, cname=none[str]);\n-}\n-\n-fn hash_ty(&@ty t) -> uint {\n-    ret _str.hash(ty_to_str(t));\n-}\n-\n-fn eq_ty(&@ty a, &@ty b) -> bool {\n-    // FIXME: this is gross, but I think it's safe, and I don't think writing\n-    // a giant function to handle all the cases is necessary when structural\n-    // equality will someday save the day.\n-    ret _str.eq(ty_to_str(a), ty_to_str(b));\n-}\n-\n-fn ann_to_type(&ast.ann ann) -> @ty {\n-    alt (ann) {\n-        case (ast.ann_none) {\n-            // shouldn't happen, but can until the typechecker is complete\n-            ret plain_ty(ty_var(-1));    // FIXME: broken, broken, broken\n-        }\n-        case (ast.ann_type(?ty)) {\n-            ret ty;\n-        }\n-    }\n-}\n-\n-fn count_ty_params(@ty t) -> uint {\n-    state obj ty_param_counter(@mutable vec[ast.def_id] param_ids) {\n-        fn fold_simple_ty(@ty t) -> @ty {\n-            alt (t.struct) {\n-                case (ty_param(?param_id)) {\n-                    for (ast.def_id other_param_id in *param_ids) {\n-                        if (param_id._0 == other_param_id._0 &&\n-                                param_id._1 == other_param_id._1) {\n-                            ret t;\n-                        }\n-                    }\n-                    *param_ids += vec(param_id);\n-                }\n-                case (_) { /* fall through */ }\n-            }\n-            ret t;\n-        }\n-    }\n-\n-    let vec[ast.def_id] param_ids_inner = vec();\n-    let @mutable vec[ast.def_id] param_ids = @mutable param_ids_inner;\n-    fold_ty(ty_param_counter(param_ids), t);\n-    ret _vec.len[ast.def_id](*param_ids);\n-}\n-\n-// Type accessors for AST nodes\n-\n-fn stmt_ty(@ast.stmt s) -> @ty {\n-    alt (s.node) {\n-        case (ast.stmt_expr(?e)) {\n-            ret expr_ty(e);\n-        }\n-        case (_) {\n-            ret plain_ty(ty_nil);\n-        }\n-    }\n-}\n-\n-fn block_ty(&ast.block b) -> @ty {\n-    alt (b.node.expr) {\n-        case (some[@ast.expr](?e)) { ret expr_ty(e); }\n-        case (none[@ast.expr])     { ret plain_ty(ty_nil); }\n-    }\n-}\n-\n-fn pat_ty(@ast.pat pat) -> @ty {\n-    alt (pat.node) {\n-        case (ast.pat_wild(?ann))           { ret ann_to_type(ann); }\n-        case (ast.pat_bind(_, _, ?ann))     { ret ann_to_type(ann); }\n-        case (ast.pat_tag(_, _, _, ?ann))   { ret ann_to_type(ann); }\n-    }\n-    fail;   // not reached\n-}\n-\n-fn expr_ty(@ast.expr expr) -> @ty {\n-    alt (expr.node) {\n-        case (ast.expr_vec(_, ?ann))          { ret ann_to_type(ann); }\n-        case (ast.expr_tup(_, ?ann))          { ret ann_to_type(ann); }\n-        case (ast.expr_rec(_, ?ann))          { ret ann_to_type(ann); }\n-        case (ast.expr_call(_, _, ?ann))      { ret ann_to_type(ann); }\n-        case (ast.expr_binary(_, _, _, ?ann)) { ret ann_to_type(ann); }\n-        case (ast.expr_unary(_, _, ?ann))     { ret ann_to_type(ann); }\n-        case (ast.expr_lit(_, ?ann))          { ret ann_to_type(ann); }\n-        case (ast.expr_cast(_, _, ?ann))      { ret ann_to_type(ann); }\n-        case (ast.expr_if(_, _, _, ?ann))     { ret ann_to_type(ann); }\n-        case (ast.expr_while(_, _, ?ann))     { ret ann_to_type(ann); }\n-        case (ast.expr_do_while(_, _, ?ann))  { ret ann_to_type(ann); }\n-        case (ast.expr_alt(_, _, ?ann))       { ret ann_to_type(ann); }\n-        case (ast.expr_block(_, ?ann))        { ret ann_to_type(ann); }\n-        case (ast.expr_assign(_, _, ?ann))    { ret ann_to_type(ann); }\n-        case (ast.expr_assign_op(_, _, _, ?ann))\n-                                              { ret ann_to_type(ann); }\n-        case (ast.expr_field(_, _, ?ann))     { ret ann_to_type(ann); }\n-        case (ast.expr_index(_, _, ?ann))     { ret ann_to_type(ann); }\n-        case (ast.expr_name(_, _, ?ann))      { ret ann_to_type(ann); }\n-    }\n-    fail;\n-}\n-\n // Type unification\n \n-fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n+fn unify(&fn_ctxt fcx, @ty.t expected, @ty.t actual) -> unify_result {\n     // Wraps the given type in an appropriate cname.\n     //\n     // TODO: This doesn't do anything yet. We should carry the cname up from\n@@ -1072,36 +515,36 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n     // something we'll probably need to develop over time.\n \n     // Simple structural type comparison.\n-    fn struct_cmp(@ty expected, @ty actual) -> unify_result {\n+    fn struct_cmp(@ty.t expected, @ty.t actual) -> unify_result {\n         if (expected.struct == actual.struct) {\n             ret ures_ok(expected);\n         }\n \n         ret ures_err(terr_mismatch, expected, actual);\n     }\n \n-    fn unify_step(&fn_ctxt fcx, &hashmap[int,@ty] bindings, @ty expected,\n-                  @ty actual) -> unify_result {\n+    fn unify_step(&fn_ctxt fcx, &hashmap[int,@ty.t] bindings, @ty.t expected,\n+                  @ty.t actual) -> unify_result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n         // If the RHS is a variable type, then just do the appropriate\n         // binding.\n         alt (actual.struct) {\n-            case (ty_var(?actual_id)) {\n+            case (ty.ty_var(?actual_id)) {\n                 alt (bindings.find(actual_id)) {\n-                    case (some[@ty](?actual_ty)) {\n+                    case (some[@ty.t](?actual_ty)) {\n                         // FIXME: change the binding here?\n                         // FIXME: \"be\"\n                         ret unify_step(fcx, bindings, expected, actual_ty);\n                     }\n-                    case (none[@ty]) {\n+                    case (none[@ty.t]) {\n                         bindings.insert(actual_id, expected);\n                         ret ures_ok(expected);\n                     }\n                 }\n             }\n-            case (ty_local(?actual_id)) {\n+            case (ty.ty_local(?actual_id)) {\n                 check (fcx.locals.contains_key(actual_id));\n                 auto actual_ty = fcx.locals.get(actual_id);\n                 auto result = unify_step(fcx, bindings, expected, actual_ty);\n@@ -1117,17 +560,17 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n         }\n \n         alt (expected.struct) {\n-            case (ty_nil)        { ret struct_cmp(expected, actual); }\n-            case (ty_bool)       { ret struct_cmp(expected, actual); }\n-            case (ty_int)        { ret struct_cmp(expected, actual); }\n-            case (ty_uint)       { ret struct_cmp(expected, actual); }\n-            case (ty_machine(_)) { ret struct_cmp(expected, actual); }\n-            case (ty_char)       { ret struct_cmp(expected, actual); }\n-            case (ty_str)        { ret struct_cmp(expected, actual); }\n-\n-            case (ty_tag(?expected_id)) {\n+            case (ty.ty_nil)        { ret struct_cmp(expected, actual); }\n+            case (ty.ty_bool)       { ret struct_cmp(expected, actual); }\n+            case (ty.ty_int)        { ret struct_cmp(expected, actual); }\n+            case (ty.ty_uint)       { ret struct_cmp(expected, actual); }\n+            case (ty.ty_machine(_)) { ret struct_cmp(expected, actual); }\n+            case (ty.ty_char)       { ret struct_cmp(expected, actual); }\n+            case (ty.ty_str)        { ret struct_cmp(expected, actual); }\n+\n+            case (ty.ty_tag(?expected_id)) {\n                 alt (actual.struct) {\n-                    case (ty_tag(?actual_id)) {\n+                    case (ty.ty_tag(?actual_id)) {\n                         if (expected_id._0 == actual_id._0 &&\n                                 expected_id._1 == actual_id._1) {\n                             ret ures_ok(expected);\n@@ -1139,16 +582,16 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                 ret ures_err(terr_mismatch, expected, actual);\n             }\n \n-            case (ty_box(?expected_sub)) {\n+            case (ty.ty_box(?expected_sub)) {\n                 alt (actual.struct) {\n-                    case (ty_box(?actual_sub)) {\n+                    case (ty.ty_box(?actual_sub)) {\n                         auto result = unify_step(fcx,\n                                                  bindings,\n                                                  expected_sub,\n                                                  actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(plain_ty(ty_box(result_sub)));\n+                                ret ures_ok(plain_ty(ty.ty_box(result_sub)));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1164,16 +607,16 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                 }\n             }\n \n-            case (ty_vec(?expected_sub)) {\n+            case (ty.ty_vec(?expected_sub)) {\n                 alt (actual.struct) {\n-                    case (ty_vec(?actual_sub)) {\n+                    case (ty.ty_vec(?actual_sub)) {\n                         auto result = unify_step(fcx,\n                                                  bindings,\n                                                  expected_sub,\n                                                  actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(plain_ty(ty_vec(result_sub)));\n+                                ret ures_ok(plain_ty(ty.ty_vec(result_sub)));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1189,11 +632,11 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                 }\n             }\n \n-            case (ty_tup(?expected_elems)) {\n+            case (ty.ty_tup(?expected_elems)) {\n                 alt (actual.struct) {\n-                    case (ty_tup(?actual_elems)) {\n-                        auto expected_len = _vec.len[@ty](expected_elems);\n-                        auto actual_len = _vec.len[@ty](actual_elems);\n+                    case (ty.ty_tup(?actual_elems)) {\n+                        auto expected_len = _vec.len[@ty.t](expected_elems);\n+                        auto actual_len = _vec.len[@ty.t](actual_elems);\n                         if (expected_len != actual_len) {\n                             auto err = terr_tuple_size(expected_len,\n                                                        actual_len);\n@@ -1202,7 +645,7 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n \n                         // TODO: implement an iterator that can iterate over\n                         // two arrays simultaneously.\n-                        let vec[@ty] result_elems = vec();\n+                        let vec[@ty.t] result_elems = vec();\n                         auto i = 0u;\n                         while (i < expected_len) {\n                             auto expected_elem = expected_elems.(i);\n@@ -1218,7 +661,7 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                                                      actual_elem);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    append[@ty](result_elems,rty);\n+                                    append[@ty.t](result_elems,rty);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -1228,7 +671,7 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(plain_ty(ty_tup(result_elems)));\n+                        ret ures_ok(plain_ty(ty.ty_tup(result_elems)));\n                     }\n \n                     // TODO: ty_var\n@@ -1239,9 +682,9 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                 }\n             }\n \n-            case (ty_rec(?expected_fields)) {\n+            case (ty.ty_rec(?expected_fields)) {\n                 alt (actual.struct) {\n-                    case (ty_rec(?actual_fields)) {\n+                    case (ty.ty_rec(?actual_fields)) {\n                         auto expected_len = _vec.len[field](expected_fields);\n                         auto actual_len = _vec.len[field](actual_fields);\n                         if (expected_len != actual_len) {\n@@ -1289,7 +732,7 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(plain_ty(ty_rec(result_fields)));\n+                        ret ures_ok(plain_ty(ty.ty_rec(result_fields)));\n                     }\n \n                     // TODO: ty_var\n@@ -1300,9 +743,9 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                 }\n             }\n \n-            case (ty_fn(?expected_inputs, ?expected_output)) {\n+            case (ty.ty_fn(?expected_inputs, ?expected_output)) {\n                 alt (actual.struct) {\n-                    case (ty_fn(?actual_inputs, ?actual_output)) {\n+                    case (ty.ty_fn(?actual_inputs, ?actual_output)) {\n                         auto expected_len = _vec.len[arg](expected_inputs);\n                         auto actual_len = _vec.len[arg](actual_inputs);\n                         if (expected_len != actual_len) {\n@@ -1360,7 +803,8 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                             }\n                         }\n \n-                        ret ures_ok(plain_ty(ty_fn(result_ins, result_out)));\n+                        auto t = plain_ty(ty.ty_fn(result_ins, result_out));\n+                        ret ures_ok(t);\n                     }\n \n                     case (_) {\n@@ -1369,21 +813,21 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                 }\n             }\n \n-            case (ty_var(?expected_id)) {\n+            case (ty.ty_var(?expected_id)) {\n                 alt (bindings.find(expected_id)) {\n-                    case (some[@ty](?expected_ty)) {\n+                    case (some[@ty.t](?expected_ty)) {\n                         // FIXME: change the binding here?\n                         // FIXME: \"be\"\n                         ret unify_step(fcx, bindings, expected_ty, actual);\n                     }\n-                    case (none[@ty]) {\n+                    case (none[@ty.t]) {\n                         bindings.insert(expected_id, actual);\n                         ret ures_ok(actual);\n                     }\n                 }\n             }\n \n-            case (ty_local(?expected_id)) {\n+            case (ty.ty_local(?expected_id)) {\n                 check (fcx.locals.contains_key(expected_id));\n                 auto expected_ty = fcx.locals.get(expected_id);\n                 auto result = unify_step(fcx, bindings, expected_ty, actual);\n@@ -1396,9 +840,9 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n                 ret result;\n             }\n \n-            case (ty_param(?expected_id)) {\n+            case (ty.ty_param(?expected_id)) {\n                 alt (actual.struct) {\n-                    case (ty_param(?actual_id)) {\n+                    case (ty.ty_param(?actual_id)) {\n                         if (expected_id._0 == actual_id._0 &&\n                                 expected_id._1 == actual_id._1) {\n                             ret ures_ok(expected);\n@@ -1419,14 +863,14 @@ fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n     fn eq_int(&int a, &int b) -> bool { ret a == b; }\n     auto hasher = hash_int;\n     auto eqer = eq_int;\n-    auto bindings = map.mk_hashmap[int,@ty](hasher, eqer);\n+    auto bindings = map.mk_hashmap[int,@ty.t](hasher, eqer);\n \n     ret unify_step(fcx, bindings, expected, actual);\n }\n \n // Requires that the two types unify, and prints an error message if they\n // don't. Returns the unified type.\n-fn demand(&fn_ctxt fcx, &span sp, @ty expected, @ty actual) -> @ty {\n+fn demand(&fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n     alt (unify(fcx, expected, actual)) {\n         case (ures_ok(?ty)) {\n             ret ty;\n@@ -1446,7 +890,7 @@ fn demand(&fn_ctxt fcx, &span sp, @ty expected, @ty actual) -> @ty {\n }\n \n // Returns true if the two types unify and false if they don't.\n-fn are_compatible(&fn_ctxt fcx, @ty expected, @ty actual) -> bool {\n+fn are_compatible(&fn_ctxt fcx, @ty.t expected, @ty.t actual) -> bool {\n     alt (unify(fcx, expected, actual)) {\n         case (ures_ok(_))        { ret true;  }\n         case (ures_err(_, _, _)) { ret false; }\n@@ -1458,7 +902,7 @@ fn are_compatible(&fn_ctxt fcx, @ty expected, @ty actual) -> bool {\n //\n // TODO: enforce this via a predicate.\n \n-fn demand_pat(&fn_ctxt fcx, @ty expected, @ast.pat pat) -> @ast.pat {\n+fn demand_pat(&fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n     auto p_1 = ast.pat_wild(ast.ann_none);  // FIXME: typestate botch\n \n     alt (pat.node) {\n@@ -1489,12 +933,12 @@ fn demand_pat(&fn_ctxt fcx, @ty expected, @ast.pat pat) -> @ast.pat {\n \n             auto subpats_len = _vec.len[@ast.pat](subpats);\n             alt (variant_ty.struct) {\n-                case (ty_tag(_)) {\n+                case (ty.ty_tag(_)) {\n                     // Nullary tag variant.\n                     check (subpats_len == 0u);\n                     p_1 = ast.pat_tag(id, subpats, vdef_opt, ast.ann_type(t));\n                 }\n-                case (ty_fn(?args, ?tag_ty)) {\n+                case (ty.ty_fn(?args, ?tag_ty)) {\n                     let vec[@ast.pat] new_subpats = vec();\n                     auto i = 0u;\n                     for (arg a in args) {\n@@ -1519,7 +963,7 @@ fn demand_pat(&fn_ctxt fcx, @ty expected, @ast.pat pat) -> @ast.pat {\n // TODO: propagate the types downward. This makes the typechecker quadratic,\n //       but we can mitigate that if expected == actual == unified.\n \n-fn demand_expr(&fn_ctxt fcx, @ty expected, @ast.expr e) -> @ast.expr {\n+fn demand_expr(&fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n     // FIXME: botch to work around typestate bug in rustboot\n     let vec[@ast.expr] v = vec();\n     auto e_1 = ast.expr_vec(v, ast.ann_none);\n@@ -1529,7 +973,7 @@ fn demand_expr(&fn_ctxt fcx, @ty expected, @ast.expr e) -> @ast.expr {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             let vec[@ast.expr] es_1 = vec();\n             alt (t.struct) {\n-                case (ty_vec(?subty)) {\n+                case (ty.ty_vec(?subty)) {\n                     for (@ast.expr e_0 in es_0) {\n                         es_1 += vec(demand_expr(fcx, subty, e_0));\n                     }\n@@ -1545,7 +989,7 @@ fn demand_expr(&fn_ctxt fcx, @ty expected, @ast.expr e) -> @ast.expr {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             let vec[ast.elt] elts_1 = vec();\n             alt (t.struct) {\n-                case (ty_tup(?subtys)) {\n+                case (ty.ty_tup(?subtys)) {\n                     auto i = 0u;\n                     for (ast.elt elt_0 in es_0) {\n                         auto e_1 = demand_expr(fcx, subtys.(i), elt_0.expr);\n@@ -1564,7 +1008,7 @@ fn demand_expr(&fn_ctxt fcx, @ty expected, @ast.expr e) -> @ast.expr {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             let vec[ast.field] fields_1 = vec();\n             alt (t.struct) {\n-                case (ty_rec(?field_tys)) {\n+                case (ty.ty_rec(?field_tys)) {\n                     auto i = 0u;\n                     for (ast.field field_0 in fields_0) {\n                         check (_str.eq(field_0.ident, field_tys.(i).ident));\n@@ -1661,7 +1105,7 @@ fn demand_expr(&fn_ctxt fcx, @ty expected, @ast.expr e) -> @ast.expr {\n }\n \n // Type unification over typed blocks.\n-fn demand_block(&fn_ctxt fcx, @ty expected, &ast.block bloc) -> ast.block {\n+fn demand_block(&fn_ctxt fcx, @ty.t expected, &ast.block bloc) -> ast.block {\n     alt (bloc.node.expr) {\n         case (some[@ast.expr](?e_0)) {\n             auto e_1 = demand_expr(fcx, expected, e_0);\n@@ -1671,7 +1115,7 @@ fn demand_block(&fn_ctxt fcx, @ty expected, &ast.block bloc) -> ast.block {\n             ret fold.respan[ast.block_](bloc.span, block_);\n         }\n         case (none[@ast.expr]) {\n-            demand(fcx, bloc.span, expected, plain_ty(ty_nil));\n+            demand(fcx, bloc.span, expected, plain_ty(ty.ty_nil));\n             ret bloc;\n         }\n     }\n@@ -1699,18 +1143,16 @@ fn writeback(&fn_ctxt fcx, &ast.block block) -> ast.block {\n \n // AST fragment checking\n \n-fn check_lit(@ast.lit lit) -> @ty {\n+fn check_lit(@ast.lit lit) -> @ty.t {\n     auto sty;\n     alt (lit.node) {\n-        case (ast.lit_str(_))   { sty = ty_str;  }\n-        case (ast.lit_char(_))  { sty = ty_char; }\n-        case (ast.lit_int(_))   { sty = ty_int;  }\n-        case (ast.lit_uint(_))  { sty = ty_uint; }\n-        case (ast.lit_mach_int(?tm, _)) {\n-            sty = ty_machine(tm);\n-        }\n-        case (ast.lit_nil)      { sty = ty_nil;  }\n-        case (ast.lit_bool(_))  { sty = ty_bool; }\n+        case (ast.lit_str(_))           { sty = ty.ty_str;  }\n+        case (ast.lit_char(_))          { sty = ty.ty_char; }\n+        case (ast.lit_int(_))           { sty = ty.ty_int;  }\n+        case (ast.lit_uint(_))          { sty = ty.ty_uint; }\n+        case (ast.lit_mach_int(?tm, _)) { sty = ty.ty_machine(tm); }\n+        case (ast.lit_nil)              { sty = ty.ty_nil;  }\n+        case (ast.lit_bool(_))          { sty = ty.ty_bool; }\n     }\n \n     ret plain_ty(sty);\n@@ -1731,7 +1173,7 @@ fn check_pat(&fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n             auto t = fcx.ccx.item_types.get(vdef._1); \n             alt (t.struct) {\n                 // N-ary variants have function types.\n-                case (ty_fn(?args, ?tag_ty)) {\n+                case (ty.ty_fn(?args, ?tag_ty)) {\n                     auto arg_len = _vec.len[arg](args);\n                     auto subpats_len = _vec.len[@ast.pat](subpats);\n                     if (arg_len != subpats_len) {\n@@ -1755,7 +1197,7 @@ fn check_pat(&fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n                 }\n \n                 // Nullary variants have tag types.\n-                case (ty_tag(?tid)) {\n+                case (ty.ty_tag(?tid)) {\n                     auto subpats_len = _vec.len[@ast.pat](subpats);\n                     if (subpats_len > 0u) {\n                         // TODO: pluralize properly\n@@ -1768,7 +1210,7 @@ fn check_pat(&fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n                         fail;   // TODO: recover\n                     }\n \n-                    auto ann = ast.ann_type(plain_ty(ty_tag(tid)));\n+                    auto ann = ast.ann_type(plain_ty(ty.ty_tag(tid)));\n                     new_pat = ast.pat_tag(id, subpats, vdef_opt, ann);\n                 }\n             }\n@@ -1799,12 +1241,12 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             auto t = lhs_t0;\n             alt (binop) {\n-                case (ast.eq) { t = plain_ty(ty_bool); }\n-                case (ast.lt) { t = plain_ty(ty_bool); }\n-                case (ast.le) { t = plain_ty(ty_bool); }\n-                case (ast.ne) { t = plain_ty(ty_bool); }\n-                case (ast.ge) { t = plain_ty(ty_bool); }\n-                case (ast.gt) { t = plain_ty(ty_bool); }\n+                case (ast.eq) { t = plain_ty(ty.ty_bool); }\n+                case (ast.lt) { t = plain_ty(ty.ty_bool); }\n+                case (ast.le) { t = plain_ty(ty.ty_bool); }\n+                case (ast.ne) { t = plain_ty(ty.ty_bool); }\n+                case (ast.ge) { t = plain_ty(ty.ty_bool); }\n+                case (ast.gt) { t = plain_ty(ty.ty_bool); }\n                 case (_) { /* fall through */ }\n             }\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -1817,10 +1259,10 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto oper_1 = check_expr(fcx, oper);\n             auto oper_t = expr_ty(oper_1);\n             alt (unop) {\n-                case (ast.box) { oper_t = plain_ty(ty_box(oper_t)); }\n+                case (ast.box) { oper_t = plain_ty(ty.ty_box(oper_t)); }\n                 case (ast.deref) {\n                     alt (oper_t.struct) {\n-                        case (ty_box(?inner_t)) {\n+                        case (ty.ty_box(?inner_t)) {\n                             oper_t = inner_t;\n                         }\n                         case (_) {\n@@ -1839,7 +1281,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_name(?name, ?defopt, _)) {\n-            auto t = plain_ty(ty_nil);\n+            auto t = plain_ty(ty.ty_nil);\n             check (defopt != none[ast.def]);\n             alt (option.get[ast.def](defopt)) {\n                 case (ast.def_arg(?id)) {\n@@ -1848,8 +1290,8 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n                 case (ast.def_local(?id)) {\n                     alt (fcx.locals.find(id)) {\n-                        case (some[@ty](?t1)) { t = t1; }\n-                        case (none[@ty])      { t = plain_ty(ty_local(id)); }\n+                        case (some[@ty.t](?t1)) { t = t1; }\n+                        case (none[@ty.t]) { t = plain_ty(ty.ty_local(id)); }\n                     }\n                 }\n                 case (ast.def_fn(?id)) {\n@@ -1917,7 +1359,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = demand_expr(fcx, plain_ty(ty_bool), cond_0);\n+            auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n \n             auto thn_0 = check_block(fcx, thn);\n             auto thn_t = block_ty(thn_0);\n@@ -1933,7 +1375,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n                 case (none[ast.block]) {\n                     elsopt_1 = none[ast.block];\n-                    elsopt_t = plain_ty(ty_nil);\n+                    elsopt_t = plain_ty(ty.ty_nil);\n                 }\n             }\n \n@@ -1946,17 +1388,17 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_while(?cond, ?body, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = demand_expr(fcx, plain_ty(ty_bool), cond_0);\n+            auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = ast.ann_type(plain_ty(ty_nil));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_nil));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_while(cond_1, body_1, ann));\n         }\n \n         case (ast.expr_do_while(?body, ?cond, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = demand_expr(fcx, plain_ty(ty_bool), cond_0);\n+            auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n             auto body_1 = check_block(fcx, body);\n \n             auto ann = ast.ann_type(block_ty(body_1));\n@@ -2030,17 +1472,17 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 append[arg](arg_tys_0, rec(mode=ast.val, ty=expr_ty(a_0)));\n             }\n             auto rt_0 = next_ty_var(fcx.ccx);\n-            auto t_0 = plain_ty(ty_fn(arg_tys_0, rt_0));\n+            auto t_0 = plain_ty(ty.ty_fn(arg_tys_0, rt_0));\n \n             // Unify and write back to the function.\n             auto f_1 = demand_expr(fcx, t_0, f_0);\n \n             // Take the argument types out of the resulting function type.\n             auto t_1 = expr_ty(f_1);\n-            let vec[arg] arg_tys_1 = vec();     // TODO: typestate botch\n-            let @ty rt_1 = plain_ty(ty_nil);    // TODO: typestate botch\n+            let vec[arg] arg_tys_1 = vec();        // TODO: typestate botch\n+            let @ty.t rt_1 = plain_ty(ty.ty_nil);  // TODO: typestate botch\n             alt (t_1.struct) {\n-                case (ty_fn(?arg_tys, ?rt)) {\n+                case (ty.ty_fn(?arg_tys, ?rt)) {\n                     arg_tys_1 = arg_tys;\n                     rt_1 = rt;\n                 }\n@@ -2091,7 +1533,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             // FIXME: implement mutable vectors with leading 'mutable' flag\n             // marking the elements as mutable.\n \n-            let @ty t;\n+            let @ty.t t;\n             if (_vec.len[@ast.expr](args) == 0u) {\n                 t = next_ty_var(fcx.ccx);\n             } else {\n@@ -2105,14 +1547,14 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 demand(fcx, expr.span, t, expr_t);\n                 append[@ast.expr](args_1,expr_1);\n             }\n-            auto ann = ast.ann_type(plain_ty(ty_vec(t)));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_vec(t)));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_vec(args_1, ann));\n         }\n \n         case (ast.expr_tup(?elts, _)) {\n             let vec[ast.elt] elts_1 = vec();\n-            let vec[@ty] elts_t = vec();\n+            let vec[@ty.t] elts_t = vec();\n \n             for (ast.elt e in elts) {\n                 auto expr_1 = check_expr(fcx, e.expr);\n@@ -2121,10 +1563,10 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     expr_t = @rec(mut=ast.mut with *expr_t);\n                 }\n                 append[ast.elt](elts_1, rec(expr=expr_1 with e));\n-                append[@ty](elts_t, expr_t);\n+                append[@ty.t](elts_t, expr_t);\n             }\n \n-            auto ann = ast.ann_type(plain_ty(ty_tup(elts_t)));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_t)));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_tup(elts_1, ann));\n         }\n@@ -2143,7 +1585,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 append[field](fields_t, rec(ident=f.ident, ty=expr_t));\n             }\n \n-            auto ann = ast.ann_type(plain_ty(ty_rec(fields_t)));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_rec(fields_t)));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_rec(fields_1, ann));\n         }\n@@ -2152,10 +1594,10 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto base_1 = check_expr(fcx, base);\n             auto base_t = expr_ty(base_1);\n             alt (base_t.struct) {\n-                case (ty_tup(?args)) {\n-                    let uint ix = field_num(fcx.ccx.sess,\n-                                            expr.span, field);\n-                    if (ix >= _vec.len[@ty](args)) {\n+                case (ty.ty_tup(?args)) {\n+                    let uint ix = ty.field_num(fcx.ccx.sess,\n+                                               expr.span, field);\n+                    if (ix >= _vec.len[@ty.t](args)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n@@ -2166,9 +1608,9 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                                ann));\n                 }\n \n-                case (ty_rec(?fields)) {\n-                    let uint ix = field_idx(fcx.ccx.sess,\n-                                            expr.span, field, fields);\n+                case (ty.ty_rec(?fields)) {\n+                    let uint ix = ty.field_idx(fcx.ccx.sess,\n+                                               expr.span, field, fields);\n                     if (ix >= _vec.len[typeck.field](fields)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n@@ -2180,16 +1622,16 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                                ann));\n                 }\n \n-                case (ty_obj(?methods)) {\n-                    let uint ix = method_idx(fcx.ccx.sess,\n-                                             expr.span, field, methods);\n+                case (ty.ty_obj(?methods)) {\n+                    let uint ix = ty.method_idx(fcx.ccx.sess,\n+                                                expr.span, field, methods);\n                     if (ix >= _vec.len[typeck.method](methods)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on obj\");\n                     }\n                     auto meth = methods.(ix);\n-                    auto ty = plain_ty(ty_fn(meth.inputs, meth.output));\n-                    auto ann = ast.ann_type(ty);\n+                    auto t = plain_ty(ty.ty_fn(meth.inputs, meth.output));\n+                    auto ann = ast.ann_type(t);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2212,7 +1654,7 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto idx_t = expr_ty(idx_1);\n \n             alt (base_t.struct) {\n-                case (ty_vec(?t)) {\n+                case (ty.ty_vec(?t)) {\n                     if (! type_is_integral(idx_t)) {\n                         fcx.ccx.sess.span_err\n                             (idx.span,\n@@ -2225,14 +1667,14 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                                                idx_1,\n                                                                ann));\n                 }\n-                case (ty_str) {\n+                case (ty.ty_str) {\n                     if (! type_is_integral(idx_t)) {\n                         fcx.ccx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of str index: \"\n                              + ty_to_str(idx_t));\n                     }\n-                    auto t = ty_machine(common.ty_u8);\n+                    auto t = ty.ty_machine(common.ty_u8);\n                     auto ann = ast.ann_type(plain_ty(t));\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n@@ -2256,8 +1698,8 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n     }\n }\n \n-fn next_ty_var(@crate_ctxt ccx) -> @ty {\n-    auto t = plain_ty(ty_var(ccx.next_var_id));\n+fn next_ty_var(@crate_ctxt ccx) -> @ty.t {\n+    auto t = plain_ty(ty.ty_var(ccx.next_var_id));\n     ccx.next_var_id += 1;\n     ret t;\n }\n@@ -2287,7 +1729,7 @@ fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n                     alt (local.init) {\n                         case (some[@ast.expr](?expr)) {\n                             auto expr_0 = check_expr(fcx, expr);\n-                            auto lty = plain_ty(ty_local(local.id));\n+                            auto lty = plain_ty(ty.ty_local(local.id));\n                             auto expr_1 = demand_expr(fcx, lty, expr_0);\n                             init = some[@ast.expr](expr_1);\n                         }\n@@ -2312,7 +1754,8 @@ fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n         case (ast.stmt_ret(?expr_opt)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n-                    if (!are_compatible(fcx, fcx.ret_ty, plain_ty(ty_nil))) {\n+                    auto nil = plain_ty(ty.ty_nil);\n+                    if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n                         fcx.ccx.sess.err(\"ret; in function \"\n                                          + \"returning non-nil\");\n                     }\n@@ -2336,7 +1779,7 @@ fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n \n         case (ast.stmt_check_expr(?expr)) {\n             auto expr_t = check_expr(fcx, expr);\n-            demand(fcx, expr.span, plain_ty(ty_bool), expr_ty(expr_t));\n+            demand(fcx, expr.span, plain_ty(ty.ty_bool), expr_ty(expr_t));\n             ret @fold.respan[ast.stmt_](stmt.span,\n                                         ast.stmt_check_expr(expr_t));\n         }\n@@ -2375,7 +1818,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n     // for checking the initializer expression.\n     auto rty = ann_to_type(ann);\n     let fn_ctxt fcx = rec(ret_ty = rty,\n-                          locals = @common.new_def_hash[@ty](),\n+                          locals = @common.new_def_hash[@ty.t](),\n                           ccx = ccx);\n     auto e_ = check_expr(fcx, e);\n     // FIXME: necessary? Correct sequence?\n@@ -2387,7 +1830,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n fn check_fn(&@crate_ctxt ccx, ast.effect effect,\n             vec[ast.arg] inputs,\n             @ast.ty output, &ast.block body) -> ast._fn {\n-    auto local_ty_table = @common.new_def_hash[@ty]();\n+    auto local_ty_table = @common.new_def_hash[@ty.t]();\n \n     // FIXME: duplicate work: the item annotation already has the arg types\n     // and return type translated to typeck.ty values. We don't need do to it\n@@ -2426,7 +1869,7 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n     }\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.output);\n-    auto fn_sty = ty_fn(inputs, output_ty);\n+    auto fn_sty = ty.ty_fn(inputs, output_ty);\n     auto fn_ann = ast.ann_type(plain_ty(fn_sty));\n \n     auto item = ast.item_fn(ident, f, ty_params, id, fn_ann);"}, {"sha": "8f5414158f9de6da7799bbe66cca07735b094619", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/744b164b7dafbecd84e6f11e139ca054c283e77c/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/744b164b7dafbecd84e6f11e139ca054c283e77c/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=744b164b7dafbecd84e6f11e139ca054c283e77c", "patch": "@@ -14,6 +14,7 @@ mod middle {\n     mod fold;\n     mod resolve;\n     mod trans;\n+    mod ty;\n     mod typeck;\n }\n "}]}