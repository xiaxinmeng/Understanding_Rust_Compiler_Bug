{"sha": "b24da1c2e5d94faace40a934720b3b200309fb41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNGRhMWMyZTVkOTRmYWFjZTQwYTkzNDcyMGIzYjIwMDMwOWZiNDE=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-28T21:43:19Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-28T21:54:32Z"}, "message": "The names 'outer' and 'inner' make more sense than 'self' and 'with'.\n(Also, some formatting and long-string cleanup.)", "tree": {"sha": "4221f4967ef446521ad616e6f48e2318ec25be92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4221f4967ef446521ad616e6f48e2318ec25be92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b24da1c2e5d94faace40a934720b3b200309fb41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b24da1c2e5d94faace40a934720b3b200309fb41", "html_url": "https://github.com/rust-lang/rust/commit/b24da1c2e5d94faace40a934720b3b200309fb41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b24da1c2e5d94faace40a934720b3b200309fb41/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73812cd3de3afe0ce492e44ad56c6696549f0b29", "url": "https://api.github.com/repos/rust-lang/rust/commits/73812cd3de3afe0ce492e44ad56c6696549f0b29", "html_url": "https://github.com/rust-lang/rust/commit/73812cd3de3afe0ce492e44ad56c6696549f0b29"}], "stats": {"total": 203, "additions": 103, "deletions": 100}, "files": [{"sha": "d65a9049786b1a952900ad932cd648a402a9eefa", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -89,7 +89,7 @@ const obj_body_elt_typarams: int = 1;\n const obj_body_elt_fields: int = 2;\n \n // The base object to which an anonymous object is attached.\n-const obj_body_elt_with_obj: int = 3;\n+const obj_body_elt_inner_obj: int = 3;\n \n // The two halves of a closure: code and environment.\n const fn_field_code: int = 0;"}, {"sha": "186a0198cba0c3eff21d741abb9d1b17dd1757be", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 74, "deletions": 69, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -5709,18 +5709,18 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n          methods: anon_obj.methods,\n          dtor: none[@ast::method]};\n \n-    let with_obj_ty: ty::t;\n+    let inner_obj_ty: ty::t;\n     let vtbl;\n-    alt anon_obj.with_obj {\n+    alt anon_obj.inner_obj {\n       none. {\n-        // If there's no with_obj -- that is, if we're just adding new\n+        // If there's no inner_obj -- that is, if we're just adding new\n         // fields rather than extending an existing object -- then we just\n         // pass the outer object to create_vtbl().  Our vtable won't need\n         // to have any forwarding slots.\n \n-        // We need a dummy with_obj_ty for setting up the object body\n+        // We need a dummy inner_obj_ty for setting up the object body\n         // later.\n-        with_obj_ty = ty::mk_type(ccx.tcx);\n+        inner_obj_ty = ty::mk_type(ccx.tcx);\n \n         // This seems a little strange, because it'll come into\n         // create_vtbl() with no \"additional methods\".  What's happening\n@@ -5734,10 +5734,10 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         // TODO: What makes more sense to get the type of an expr --\n         // calling ty::expr_ty(ccx.tcx, e) on it or calling\n         // ty::node_id_to_type(ccx.tcx, id) on its id?\n-        with_obj_ty = ty::expr_ty(ccx.tcx, e);\n-        //with_obj_ty = ty::node_id_to_type(ccx.tcx, e.id);\n+        inner_obj_ty = ty::expr_ty(ccx.tcx, e);\n+        //inner_obj_ty = ty::node_id_to_type(ccx.tcx, e.id);\n \n-        // If there's a with_obj, we pass its type along to create_vtbl().\n+        // If there's a inner_obj, we pass its type along to create_vtbl().\n         // Part of what create_vtbl() will do is take the set difference\n         // of methods defined on the original and methods being added.\n         // For every method defined on the original that does *not* have\n@@ -5746,7 +5746,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         // normal vtable entry for every method being added.\n         vtbl =\n             create_vtbl(bcx.fcx.lcx, sp, outer_obj_ty, wrapper_obj, ~[],\n-                        some(with_obj_ty), additional_field_tys);\n+                        some(inner_obj_ty), additional_field_tys);\n       }\n     }\n \n@@ -5770,12 +5770,12 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n \n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n-    // typarams, fields, and a pointer to our with_obj.\n+    // typarams, fields, and a pointer to our inner_obj.\n     let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n \n     if std::ivec::len[ast::anon_obj_field](additional_fields) == 0u &&\n-           anon_obj.with_obj == none {\n-        // If the object we're translating has no fields and no with_obj,\n+           anon_obj.inner_obj == none {\n+        // If the object we're translating has no fields and no inner_obj,\n         // there's not much to do.\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n@@ -5791,10 +5791,11 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         let typarams_ty: ty::t = ty::mk_imm_tup(ccx.tcx, ~[]);\n \n         // Tuple type for body:\n-        // [tydesc, [typaram, ...], [field, ...], with_obj]\n+        // [tydesc, [typaram, ...], [field, ...], inner_obj]\n         let body_ty: ty::t =\n             ty::mk_imm_tup(ccx.tcx,\n-                           ~[tydesc_ty, typarams_ty, fields_ty, with_obj_ty]);\n+                           ~[tydesc_ty, typarams_ty, fields_ty,\n+                             inner_obj_ty]);\n \n         // Hand this type we've synthesized off to trans_malloc_boxed, which\n         // allocates a box, including space for a refcount.\n@@ -5803,7 +5804,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n \n         // mk_imm_box throws a refcount into the type we're synthesizing,\n         // so that it looks like:\n-        // [rc, [tydesc, [typaram, ...], [field, ...], with_obj]]\n+        // [rc, [tydesc, [typaram, ...], [field, ...], inner_obj]]\n         let boxed_body_ty: ty::t = ty::mk_imm_box(ccx.tcx, body_ty);\n \n         // Grab onto the refcount and body parts of the box we allocated.\n@@ -5860,22 +5861,23 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n             i += 1;\n         }\n \n-        // If there's a with_obj, copy a pointer to it into the object's body.\n-        alt anon_obj.with_obj {\n+        // If there's a inner_obj, copy a pointer to it into the object's\n+        // body.\n+        alt anon_obj.inner_obj {\n           none. { }\n           some(e) {\n-            // If with_obj (the object being extended) exists, translate\n-            // it.  Translating with_obj returns a ValueRef (pointer to a\n-            // 2-word value) wrapped in a result.\n-            let with_obj_val: result = trans_expr(bcx, e);\n+            // If inner_obj (the object being extended) exists, translate it.\n+            // Translating inner_obj returns a ValueRef (pointer to a 2-word\n+            // value) wrapped in a result.\n+            let inner_obj_val: result = trans_expr(bcx, e);\n \n-            let body_with_obj =\n+            let body_inner_obj =\n                 GEP_tup_like(bcx, body_ty, body.val,\n-                             ~[0, abi::obj_body_elt_with_obj]);\n-            bcx = body_with_obj.bcx;\n+                             ~[0, abi::obj_body_elt_inner_obj]);\n+            bcx = body_inner_obj.bcx;\n             bcx =\n-                copy_val(bcx, INIT, body_with_obj.val, with_obj_val.val,\n-                         with_obj_ty).bcx;\n+                copy_val(bcx, INIT, body_inner_obj.val, inner_obj_val.val,\n+                         inner_obj_ty).bcx;\n           }\n         }\n \n@@ -6544,7 +6546,7 @@ fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n // vtable slot for method calls that \"fall through\" to an inner object.  A\n // helper function for create_vtbl.\n fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n-                       ty_params: &ast::ty_param[], with_obj_ty: ty::t,\n+                       ty_params: &ast::ty_param[], inner_obj_ty: ty::t,\n                        backwarding_vtbl: option::t[ValueRef],\n                        additional_field_tys: &ty::t[]) -> ValueRef {\n \n@@ -6619,7 +6621,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         llretptr = bcx.build.PointerCast(llretptr, T_typaram_ptr(cx.ccx.tn));\n     }\n \n-    // Now, we have to get the the with_obj's vtbl out of the self_obj.  This\n+    // Now, we have to get the the inner_obj's vtbl out of the self_obj.  This\n     // is a multi-step process:\n \n     // First, grab the box out of the self_obj.  It contains a refcount and a\n@@ -6653,51 +6655,51 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let typarams_ty: ty::t = ty::mk_imm_tup(cx.ccx.tcx, ~[]);\n \n     // Tuple type for body:\n-    // [tydesc, [typaram, ...], [field, ...], with_obj]\n+    // [tydesc, [typaram, ...], [field, ...], inner_obj]\n     let body_ty: ty::t =\n         ty::mk_imm_tup(cx.ccx.tcx,\n-                       ~[tydesc_ty, typarams_ty, fields_ty, with_obj_ty]);\n+                       ~[tydesc_ty, typarams_ty, fields_ty, inner_obj_ty]);\n \n     // And cast to that type.\n     llself_obj_body =\n         bcx.build.PointerCast(llself_obj_body,\n                               T_ptr(type_of(cx.ccx, sp, body_ty)));\n \n-    // Now, reach into the body and grab the with_obj.\n-    let llwith_obj =\n+    // Now, reach into the body and grab the inner_obj.\n+    let llinner_obj =\n         GEP_tup_like(bcx, body_ty, llself_obj_body,\n-                     ~[0, abi::obj_body_elt_with_obj]);\n-    bcx = llwith_obj.bcx;\n+                     ~[0, abi::obj_body_elt_inner_obj]);\n+    bcx = llinner_obj.bcx;\n \n-    // And, now, somewhere in with_obj is a vtable with an entry for the\n+    // And, now, somewhere in inner_obj is a vtable with an entry for the\n     // method we want.  First, pick out the vtable, and then pluck that\n     // method's entry out of the vtable so that the forwarding function can\n     // call it.\n-    let llwith_obj_vtbl =\n-        bcx.build.GEP(llwith_obj.val,\n+    let llinner_obj_vtbl =\n+        bcx.build.GEP(llinner_obj.val,\n                       ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n-    llwith_obj_vtbl = bcx.build.Load(llwith_obj_vtbl);\n+    llinner_obj_vtbl = bcx.build.Load(llinner_obj_vtbl);\n \n     // Get the index of the method we want.\n     let ix: uint = 0u;\n-    alt ty::struct(bcx_tcx(bcx), with_obj_ty) {\n+    alt ty::struct(bcx_tcx(bcx), inner_obj_ty) {\n       ty::ty_obj(methods) {\n         ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n       }\n       _ {\n         // Shouldn't happen.\n-        cx.ccx.sess.bug(\"process_fwding_mthd(): non-object type passed \" +\n-                            \"as with_obj_ty\");\n+        cx.ccx.sess.bug(\"process_fwding_mthd(): non-object type passed \\\n+                        as inner_obj_ty\");\n       }\n     }\n \n     // Pick out the original method from the vtable.  The +1 is because slot\n     // #0 contains the destructor.\n     let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 2u));\n-    llwith_obj_vtbl = bcx.build.PointerCast(llwith_obj_vtbl, vtbl_type);\n+    llinner_obj_vtbl = bcx.build.PointerCast(llinner_obj_vtbl, vtbl_type);\n \n     let llorig_mthd =\n-        bcx.build.GEP(llwith_obj_vtbl, ~[C_int(0), C_int(ix + 1u as int)]);\n+        bcx.build.GEP(llinner_obj_vtbl, ~[C_int(0), C_int(ix + 1u as int)]);\n \n     // Set up the original method to be called.\n     let orig_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n@@ -6776,14 +6778,15 @@ tag vtbl_mthd {\n \n // Create a vtable for an object being translated.  Returns a pointer into\n // read-only memory.\n-fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n-               ty_params: &ast::ty_param[], with_obj_ty: option::t[ty::t],\n+fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n+               ob: &ast::_obj, ty_params: &ast::ty_param[],\n+               inner_obj_ty: option::t[ty::t],\n                additional_field_tys: &ty::t[]) -> ValueRef {\n \n     let dtor = C_null(T_ptr(T_i8()));\n     alt ob.dtor {\n       some(d) {\n-        let dtor_1 = trans_dtor(cx, self_ty, ty_params, d);\n+        let dtor_1 = trans_dtor(cx, outer_obj_ty, ty_params, d);\n         dtor = llvm::LLVMConstBitCast(dtor_1, val_ty(dtor));\n       }\n       none. { }\n@@ -6793,34 +6796,34 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n     let meths: vtbl_mthd[] = ~[];\n     let backwarding_vtbl: option::t[ValueRef] = none;\n \n-    alt with_obj_ty {\n+    alt inner_obj_ty {\n       none. {\n \n-        // If there's no with_obj, then we don't need any forwarding\n+        // If there's no inner_obj, then we don't need any forwarding\n         // slots.  Just use the object's regular methods.\n         for m: @ast::method  in ob.methods { meths += ~[normal_mthd(m)]; }\n       }\n-      some(with_obj_ty) {\n+      some(inner_obj_ty) {\n         // Handle forwarding slots.\n \n         // If this vtable is being created for an extended object, then\n         // the vtable needs to contain 'forwarding slots' for methods that\n         // were on the original object and are not being overloaded by the\n         // extended one.  So, to find the set of methods that we need\n         // forwarding slots for, we need to take the set difference of\n-        // with_obj_methods (methods on the original object) and\n+        // inner_obj_methods (methods on the original object) and\n         // ob.methods (methods on the object being added).\n \n-        // If we're here, then with_obj_ty and llwith_obj_ty are the type\n+        // If we're here, then inner_obj_ty and llinner_obj_ty are the type\n         // of the inner object, and \"ob\" is the wrapper object.  We need\n-        // to take apart with_obj_ty (it had better have an object type\n+        // to take apart inner_obj_ty (it had better have an object type\n         // with methods!) and put those original methods onto the list of\n         // methods we need forwarding methods for.\n \n         // Gather up methods on the original object in 'meths'.\n-        alt ty::struct(cx.ccx.tcx, with_obj_ty) {\n-          ty::ty_obj(with_obj_methods) {\n-            for m: ty::method  in with_obj_methods {\n+        alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n+          ty::ty_obj(inner_obj_methods) {\n+            for m: ty::method  in inner_obj_methods {\n                 meths += ~[fwding_mthd(@m)];\n             }\n           }\n@@ -6857,8 +6860,8 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n               }\n               normal_mthd(_) {\n                 // Should never happen.\n-                cx.ccx.sess.bug(\"create_vtbl(): shouldn't be any\" +\n-                                    \" normal_mthds in meths here\");\n+                cx.ccx.sess.bug(\"create_vtbl(): shouldn't be any \\\n+                                normal_mthds in meths here\");\n               }\n             }\n         }\n@@ -6897,17 +6900,18 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n     for m: vtbl_mthd in meths {\n         alt m {\n           normal_mthd(nm) {\n-            llmethods += ~[process_normal_mthd(cx, nm, self_ty, ty_params)];\n+            llmethods += ~[process_normal_mthd(cx, nm, outer_obj_ty,\n+                                               ty_params)];\n           }\n \n           // If we have to process a forwarding method, then we need to know\n-          // about the with_obj's type as well as the outer object's type.\n+          // about the inner_obj's type as well as the outer object's type.\n           fwding_mthd(fm) {\n-            alt with_obj_ty {\n+            alt inner_obj_ty {\n               none. {\n                 // This shouldn't happen; if we're trying to process a\n                 // forwarding method, then we should always have a\n-                // with_obj_ty.\n+                // inner_obj_ty.\n                 cx.ccx.sess.bug(\"create_vtbl(): trying to create \\\n                                 forwarding method without a type \\\n                                 of object to forward to\");\n@@ -6934,19 +6938,20 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, self_ty: ty::t, ob: &ast::_obj,\n     ret gvar;\n }\n \n-fn trans_dtor(cx: @local_ctxt, self_ty: ty::t, ty_params: &ast::ty_param[],\n+fn trans_dtor(cx: @local_ctxt, outer_obj_ty: ty::t,\n+              ty_params: &ast::ty_param[],\n               dtor: &@ast::method) -> ValueRef {\n     let llfnty = T_dtor(cx.ccx, dtor.span);\n     let s: str = mangle_internal_name_by_path(cx.ccx, cx.path + ~[\"drop\"]);\n     let llfn: ValueRef = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n     cx.ccx.item_ids.insert(dtor.node.id, llfn);\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n-    trans_fn(cx, dtor.span, dtor.node.meth, llfn, some(self_ty), ty_params,\n-             dtor.node.id);\n+    trans_fn(cx, dtor.span, dtor.node.meth, llfn, some(outer_obj_ty),\n+             ty_params, dtor.node.id);\n     ret llfn;\n }\n \n-fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, with_obj_ty: ty::t,\n+fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n                            outer_obj_ty: ty::t) -> ValueRef {\n \n     // This vtbl needs to have slots for all of the methods on an inner\n@@ -6958,9 +6963,9 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, with_obj_ty: ty::t,\n     let meths: vtbl_mthd[]= ~[];\n \n     // Gather up methods on the inner object.\n-    alt ty::struct(cx.ccx.tcx, with_obj_ty) {\n-        ty::ty_obj(with_obj_methods) {\n-            for m: ty::method in with_obj_methods {\n+    alt ty::struct(cx.ccx.tcx, inner_obj_ty) {\n+        ty::ty_obj(inner_obj_methods) {\n+            for m: ty::method in inner_obj_methods {\n                 meths += ~[fwding_mthd(@m)];\n             }\n         }\n@@ -7076,7 +7081,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n     // typarams, and fields.\n \n-    // FIXME: What about with_obj?  Do we have to think about it here?\n+    // FIXME: What about inner_obj?  Do we have to think about it here?\n     // (Pertains to issues #538/#539/#540/#543.)\n \n     let llbox_ty: TypeRef = T_ptr(T_empty_struct());"}, {"sha": "a820b76c4a1e2d2a1558d05523bd13a2609051b4", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -555,7 +555,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       expr_port(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n       expr_anon_obj(anon_obj) {\n-        alt anon_obj.with_obj {\n+        alt anon_obj.inner_obj {\n           some(ex) {\n             find_pre_post_expr(fcx, ex);\n             copy_pre_post(fcx.ccx, e.id, ex);"}, {"sha": "afa34478d9583cc2cfc3a58b647766aa153360da", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -553,7 +553,7 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       expr_port(_) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_self_method(_) { ret pure_exp(fcx.ccx, e.id, pres); }\n       expr_anon_obj(anon_obj) {\n-        alt anon_obj.with_obj {\n+        alt anon_obj.inner_obj {\n           some(wt) { ret find_pre_post_state_sub(fcx, pres, wt, e.id, none); }\n           none. { ret pure_exp(fcx.ccx, e.id, pres); }\n         }"}, {"sha": "c1d2b7a075878947b075017dfc74bab5c8798add", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -58,7 +58,7 @@ tag obj_info {\n     regular_obj(ast::obj_field[], ast::node_id);\n \n     // Anonymous objects only have a type at compile time.  It's optional\n-    // because not all anonymous objects have a with_obj to attach to.\n+    // because not all anonymous objects have a inner_obj to attach to.\n     anon_obj(ast::obj_field[], option::t[ty::sty]);\n }\n \n@@ -2395,27 +2395,27 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n \n             // Inner methods.\n \n-            // Typecheck 'with_obj'.  If it exists, it had better have\n+            // Typecheck 'inner_obj'.  If it exists, it had better have\n             // object type.\n-            let with_obj_methods: ty::method[] = ~[];\n-            let with_obj_ty: ty::t = ty::mk_nil(fcx.ccx.tcx);\n-            let with_obj_sty: option::t[ty::sty] = none;\n-            alt ao.with_obj {\n+            let inner_obj_methods: ty::method[] = ~[];\n+            let inner_obj_ty: ty::t = ty::mk_nil(fcx.ccx.tcx);\n+            let inner_obj_sty: option::t[ty::sty] = none;\n+            alt ao.inner_obj {\n               none. { }\n               some(e) {\n-                // If there's a with_obj, we push it onto the\n+                // If there's a inner_obj, we push it onto the\n                 // obj_infos stack so that self-calls can be checked\n                 // within its context later.\n                 check_expr(fcx, e);\n-                with_obj_ty = expr_ty(fcx.ccx.tcx, e);\n-                with_obj_sty = some(structure_of(fcx, e.span, with_obj_ty));\n+                inner_obj_ty = expr_ty(fcx.ccx.tcx, e);\n+                inner_obj_sty = some(structure_of(fcx, e.span, inner_obj_ty));\n \n \n-                alt with_obj_sty {\n+                alt inner_obj_sty {\n                   none. { }\n                   some(sty) {\n                     alt sty {\n-                      ty::ty_obj(ms) { with_obj_methods = ms; }\n+                      ty::ty_obj(ms) { inner_obj_methods = ms; }\n                       _ {\n                         // The user is trying to extend a\n                         // non-object.\n@@ -2431,9 +2431,9 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n \n             fcx.ccx.obj_infos +=\n                 ~[anon_obj(ivec::map(ast::obj_field_from_anon_obj_field,\n-                                     fields), with_obj_sty)];\n+                                     fields), inner_obj_sty)];\n \n-            methods += with_obj_methods;\n+            methods += inner_obj_methods;\n             ret methods;\n         }\n "}, {"sha": "10ee106c533fe35d9a80c1813f4741c36fac0ac6", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -529,11 +529,10 @@ type _obj =\n \n type anon_obj =\n     // New fields and methods, if they exist.\n-\n-    // with_obj: the original object being extended, if it exists.\n     {fields: option::t[anon_obj_field[]],\n      methods: (@method)[],\n-     with_obj: option::t[@expr]};\n+     // inner_obj: the original object being extended, if it exists.\n+     inner_obj: option::t[@expr]};\n \n type _mod = {view_items: (@view_item)[], items: (@item)[]};\n "}, {"sha": "8f4e780e9f8b73133a8ccb551f5ef6a146efbea9", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -322,7 +322,7 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n                    }\n                  },\n              methods: ivec::map(fld.fold_method, ao.methods),\n-             with_obj: option::map(fld.fold_expr, ao.with_obj)}\n+             inner_obj: option::map(fld.fold_expr, ao.inner_obj)}\n     }\n     let fold_anon_obj = bind fold_anon_obj_(_, fld);\n "}, {"sha": "9590fe723e6ec44c82d977237b16f1b716824347", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -868,23 +868,23 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n                                       parse_anon_obj_field, p));\n         }\n         let meths: (@ast::method)[] = ~[];\n-        let with_obj: option::t[@ast::expr] = none;\n+        let inner_obj: option::t[@ast::expr] = none;\n         expect(p, token::LBRACE);\n         while p.peek() != token::RBRACE {\n             if eat_word(p, \"with\") {\n-                with_obj = some(parse_expr(p));\n+                inner_obj = some(parse_expr(p));\n             } else { meths += ~[parse_method(p)]; }\n         }\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACE);\n         // fields and methods may be *additional* or *overriding* fields\n-        // and methods if there's a with_obj, or they may be the *only*\n-        // fields and methods if there's no with_obj.\n+        // and methods if there's a inner_obj, or they may be the *only*\n+        // fields and methods if there's no inner_obj.\n \n         // We don't need to pull \".node\" out of fields because it's not a\n         // \"spanned\".\n         let ob: ast::anon_obj =\n-            {fields: fields, methods: meths, with_obj: with_obj};\n+            {fields: fields, methods: meths, inner_obj: inner_obj};\n         ex = ast::expr_anon_obj(ob);\n     } else if (eat_word(p, \"bind\")) {\n         let e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);"}, {"sha": "f646bc1c7590e21c9626b586fa044b19e8adce79", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -984,7 +984,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         space(s.s);\n \n         // With object\n-        alt anon_obj.with_obj {\n+        alt anon_obj.inner_obj {\n           none. { }\n           some(e) { word_space(s, \"with\"); print_expr(s, e); }\n         }"}, {"sha": "cf24b59611f41e2a34071a8808412de473a02b0f", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -331,7 +331,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n             }\n           }\n         }\n-        alt anon_obj.with_obj {\n+        alt anon_obj.inner_obj {\n           none. { }\n           some(ex) { v.visit_expr(ex, e, v); }\n         }"}, {"sha": "75221e9acb36e9a002f5a84842dd1e2694b25e2d", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b24da1c2e5d94faace40a934720b3b200309fb41/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=b24da1c2e5d94faace40a934720b3b200309fb41", "patch": "@@ -356,8 +356,8 @@ fn walk_expr(v: &ast_visitor, e: @ast::expr) {\n       ast::expr_port(_) { }\n       ast::expr_chan(x) { walk_expr(v, x); }\n       ast::expr_anon_obj(anon_obj) {\n-        // Fields\n \n+        // Fields\n         alt anon_obj.fields {\n           none. { }\n           some(fields) {\n@@ -367,10 +367,9 @@ fn walk_expr(v: &ast_visitor, e: @ast::expr) {\n             }\n           }\n         }\n-        // with_obj\n-\n-        alt anon_obj.with_obj { none. { } some(e) { walk_expr(v, e); } }\n \n+        // inner_obj\n+        alt anon_obj.inner_obj { none. { } some(e) { walk_expr(v, e); } }\n \n         // Methods\n         for m: @ast::method  in anon_obj.methods {"}]}