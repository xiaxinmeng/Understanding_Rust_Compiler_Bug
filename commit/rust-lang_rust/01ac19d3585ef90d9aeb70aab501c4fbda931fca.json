{"sha": "01ac19d3585ef90d9aeb70aab501c4fbda931fca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYWMxOWQzNTg1ZWY5MGQ5YWViNzBhYWI1MDFjNGZiZGE5MzFmY2E=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-07T18:20:16Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-07T18:20:16Z"}, "message": "fix `static mut` accidental dealloc or freeze", "tree": {"sha": "5cfb704d057ea9197610a263ff1a45acadc85204", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cfb704d057ea9197610a263ff1a45acadc85204"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01ac19d3585ef90d9aeb70aab501c4fbda931fca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01ac19d3585ef90d9aeb70aab501c4fbda931fca", "html_url": "https://github.com/rust-lang/rust/commit/01ac19d3585ef90d9aeb70aab501c4fbda931fca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01ac19d3585ef90d9aeb70aab501c4fbda931fca/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c560f594119244af2a2d10c5f351b95de9f1b37", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c560f594119244af2a2d10c5f351b95de9f1b37", "html_url": "https://github.com/rust-lang/rust/commit/3c560f594119244af2a2d10c5f351b95de9f1b37"}], "stats": {"total": 148, "additions": 106, "deletions": 42}, "files": [{"sha": "30bd5beba256ad9ee7d9465e504a56d2695f45da", "filename": "src/error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01ac19d3585ef90d9aeb70aab501c4fbda931fca/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ac19d3585ef90d9aeb70aab501c4fbda931fca/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=01ac19d3585ef90d9aeb70aab501c4fbda931fca", "patch": "@@ -49,8 +49,8 @@ pub enum EvalError<'tcx> {\n     AssumptionNotHeld,\n     InlineAsm,\n     TypeNotPrimitive(Ty<'tcx>),\n-    ReallocatedFrozenMemory,\n-    DeallocatedFrozenMemory,\n+    ReallocatedStaticMemory,\n+    DeallocatedStaticMemory,\n     Layout(layout::LayoutError<'tcx>),\n     Unreachable,\n     ExpectedConcreteFunction(Function<'tcx>),\n@@ -118,9 +118,9 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"cannot evaluate inline assembly\",\n             EvalError::TypeNotPrimitive(_) =>\n                 \"expected primitive type, got nonprimitive\",\n-            EvalError::ReallocatedFrozenMemory =>\n+            EvalError::ReallocatedStaticMemory =>\n                 \"tried to reallocate frozen memory\",\n-            EvalError::DeallocatedFrozenMemory =>\n+            EvalError::DeallocatedStaticMemory =>\n                 \"tried to deallocate frozen memory\",\n             EvalError::Layout(_) =>\n                 \"rustc layout computation failed\","}, {"sha": "fbad94b67ae1249e413ad643c41c621af63c04a4", "filename": "src/eval_context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/01ac19d3585ef90d9aeb70aab501c4fbda931fca/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ac19d3585ef90d9aeb70aab501c4fbda931fca/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=01ac19d3585ef90d9aeb70aab501c4fbda931fca", "patch": "@@ -100,9 +100,11 @@ pub struct Frame<'tcx> {\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n     /// The stackframe existed to compute the initial value of a static/constant, make sure it\n-    /// isn't modifyable afterwards. The allocation of the result is frozen iff it's an\n-    /// actual allocation. `PrimVal`s are unmodifyable anyway.\n-    Freeze,\n+    /// isn't modifyable afterwards in case of constants.\n+    /// In case of `static mut`, mark the memory to ensure it's never marked as immutable through\n+    /// references or deallocated\n+    /// The bool decides whether the value is mutable (true) or not (false)\n+    MarkStatic(bool),\n     /// A regular stackframe added due to a function call will need to get forwarded to the next\n     /// block\n     Goto(mir::BasicBlock),\n@@ -170,7 +172,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // FIXME: cache these allocs\n         let ptr = self.memory.allocate(s.len() as u64, 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n-        self.memory.freeze(ptr.alloc_id)?;\n+        self.memory.mark_static(ptr.alloc_id, false)?;\n         Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u128(s.len() as u128)))\n     }\n \n@@ -194,7 +196,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ByteStr(ref bs) => {\n                 let ptr = self.memory.allocate(bs.len() as u64, 1)?;\n                 self.memory.write_bytes(ptr, bs)?;\n-                self.memory.freeze(ptr.alloc_id)?;\n+                self.memory.mark_static(ptr.alloc_id, false)?;\n                 PrimVal::Ptr(ptr)\n             }\n \n@@ -310,25 +312,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n         match frame.return_to_block {\n-            StackPopCleanup::Freeze => if let Lvalue::Global(id) = frame.return_lvalue {\n+            StackPopCleanup::MarkStatic(mutable) => if let Lvalue::Global(id) = frame.return_lvalue {\n                 let global_value = self.globals.get_mut(&id)\n-                    .expect(\"global should have been cached (freeze)\");\n+                    .expect(\"global should have been cached (freeze/static)\");\n                 match global_value.value {\n-                    Value::ByRef(ptr) => self.memory.freeze(ptr.alloc_id)?,\n+                    Value::ByRef(ptr) => self.memory.mark_static(ptr.alloc_id, mutable)?,\n                     Value::ByVal(val) => if let PrimVal::Ptr(ptr) = val {\n-                        self.memory.freeze(ptr.alloc_id)?;\n+                        self.memory.mark_static(ptr.alloc_id, mutable)?;\n                     },\n                     Value::ByValPair(val1, val2) => {\n                         if let PrimVal::Ptr(ptr) = val1 {\n-                            self.memory.freeze(ptr.alloc_id)?;\n+                            self.memory.mark_static(ptr.alloc_id, mutable)?;\n                         }\n                         if let PrimVal::Ptr(ptr) = val2 {\n-                            self.memory.freeze(ptr.alloc_id)?;\n+                            self.memory.mark_static(ptr.alloc_id, mutable)?;\n                         }\n                     },\n                 }\n                 assert!(global_value.mutable);\n-                global_value.mutable = false;\n+                global_value.mutable = mutable;\n             } else {\n                 bug!(\"StackPopCleanup::Freeze on: {:?}\", frame.return_lvalue);\n             },\n@@ -345,7 +347,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     // by a constant. We could alternatively check whether the alloc_id is frozen\n                     // before calling deallocate, but this is much simpler and is probably the\n                     // rare case.\n-                    Ok(()) | Err(EvalError::DeallocatedFrozenMemory) => {},\n+                    Ok(()) | Err(EvalError::DeallocatedStaticMemory) => {},\n                     other => return other,\n                 }\n             }\n@@ -868,9 +870,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => {\n                         let ptr = self.alloc_ptr_with_substs(global_val.ty, cid.substs)?;\n                         self.write_value_to_ptr(global_val.value, ptr, global_val.ty)?;\n-                        if !global_val.mutable {\n-                            self.memory.freeze(ptr.alloc_id)?;\n-                        }\n+                        self.memory.mark_static(ptr.alloc_id, global_val.mutable)?;\n                         let lval = self.globals.get_mut(&cid).expect(\"already checked\");\n                         *lval = Global {\n                             value: Value::ByRef(ptr),"}, {"sha": "8c2223215325a3932b3de4046a32756b7cf2a4f1", "filename": "src/memory.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/01ac19d3585ef90d9aeb70aab501c4fbda931fca/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ac19d3585ef90d9aeb70aab501c4fbda931fca/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=01ac19d3585ef90d9aeb70aab501c4fbda931fca", "patch": "@@ -38,9 +38,19 @@ pub struct Allocation {\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: u64,\n     /// Whether the allocation may be modified.\n-    /// Use the `freeze` method of `Memory` to ensure that an error occurs, if the memory of this\n+    /// Use the `mark_static` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified in the future.\n-    pub immutable: bool,\n+    pub static_kind: StaticKind,\n+}\n+\n+#[derive(Debug, PartialEq, Copy, Clone)]\n+pub enum StaticKind {\n+    /// may be deallocated without breaking miri's invariants\n+    NotStatic,\n+    /// may be modified, but never deallocated\n+    Mutable,\n+    /// may neither be modified nor deallocated\n+    Immutable,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -272,7 +282,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n-            immutable: false,\n+            static_kind: StaticKind::NotStatic,\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n@@ -290,8 +300,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if ptr.points_to_zst() {\n             return self.allocate(new_size, align);\n         }\n-        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable).ok() == Some(true) {\n-            return Err(EvalError::ReallocatedFrozenMemory);\n+        if self.get(ptr.alloc_id).ok().map_or(false, |alloc| alloc.static_kind != StaticKind::NotStatic) {\n+            return Err(EvalError::ReallocatedStaticMemory);\n         }\n \n         let size = self.get(ptr.alloc_id)?.bytes.len() as u64;\n@@ -325,8 +335,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n-        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable).ok() == Some(true) {\n-            return Err(EvalError::DeallocatedFrozenMemory);\n+        if self.get(ptr.alloc_id).ok().map_or(false, |alloc| alloc.static_kind != StaticKind::NotStatic) {\n+            return Err(EvalError::DeallocatedStaticMemory);\n         }\n \n         if let Some(alloc) = self.alloc_map.remove(&ptr.alloc_id) {\n@@ -430,8 +440,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n         match self.alloc_map.get_mut(&id) {\n-            Some(ref alloc) if alloc.immutable => Err(EvalError::ModifiedConstantMemory),\n-            Some(alloc) => Ok(alloc),\n+            Some(alloc) => match alloc.static_kind {\n+                StaticKind::Mutable |\n+                StaticKind::NotStatic => Ok(alloc),\n+                StaticKind::Immutable => Err(EvalError::ModifiedConstantMemory),\n+            },\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n                 None if id == NEVER_ALLOC_ID || id == ZST_ALLOC_ID => Err(EvalError::InvalidMemoryAccess),\n@@ -514,7 +527,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 }\n             }\n \n-            let immutable = if alloc.immutable { \" (immutable)\" } else { \"\" };\n+            let immutable = match alloc.static_kind {\n+                StaticKind::Mutable => \"(static mut)\",\n+                StaticKind::Immutable => \"(immutable)\",\n+                StaticKind::NotStatic => \"\",\n+            };\n             trace!(\"{}({} bytes){}\", msg, alloc.bytes.len(), immutable);\n \n             if !relocations.is_empty() {\n@@ -607,23 +624,28 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn freeze(&mut self, alloc_id: AllocId) -> EvalResult<'tcx> {\n+    /// mark an allocation as static, either mutable or not\n+    pub fn mark_static(&mut self, alloc_id: AllocId, mutable: bool) -> EvalResult<'tcx> {\n         // do not use `self.get_mut(alloc_id)` here, because we might have already frozen a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n-            Some(ref mut alloc) if !alloc.immutable => {\n-                alloc.immutable = true;\n+            Some(&mut Allocation { ref mut relocations, static_kind: ref mut kind @ StaticKind::NotStatic, .. }) => {\n+                *kind = if mutable {\n+                    StaticKind::Mutable\n+                } else {\n+                    StaticKind::Immutable\n+                };\n                 // take out the relocations vector to free the borrow on self, so we can call\n                 // freeze recursively\n-                mem::replace(&mut alloc.relocations, Default::default())\n+                mem::replace(relocations, Default::default())\n             },\n             None if alloc_id == NEVER_ALLOC_ID || alloc_id == ZST_ALLOC_ID => return Ok(()),\n             None if !self.functions.contains_key(&alloc_id) => return Err(EvalError::DanglingPointerDeref),\n             _ => return Ok(()),\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            self.freeze(alloc)?;\n+            self.mark_static(alloc, mutable)?;\n         }\n         // put back the relocations\n         self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;"}, {"sha": "0200e4580147e86f810c97eed72ed84f527fad49", "filename": "src/step.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01ac19d3585ef90d9aeb70aab501c4fbda931fca/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ac19d3585ef90d9aeb70aab501c4fbda931fca/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=01ac19d3585ef90d9aeb70aab501c4fbda931fca", "patch": "@@ -156,11 +156,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         self.try(|this| {\n             let mir = this.ecx.load_mir(def_id)?;\n             this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n-            let cleanup = if immutable && !mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe() {\n-                StackPopCleanup::Freeze\n-            } else {\n-                StackPopCleanup::None\n-            };\n+            let cleanup = StackPopCleanup::MarkStatic(!immutable || mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe());\n             this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::Global(cid), cleanup, Vec::new())\n         });\n     }\n@@ -210,7 +206,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                                               mir,\n                                               this.substs,\n                                               Lvalue::Global(cid),\n-                                              StackPopCleanup::Freeze,\n+                                              StackPopCleanup::MarkStatic(false),\n                                               Vec::new())\n                 });\n             }"}, {"sha": "0b43b3494438f6a42a9b6037e8305e7384d01e94", "filename": "src/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01ac19d3585ef90d9aeb70aab501c4fbda931fca/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ac19d3585ef90d9aeb70aab501c4fbda931fca/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=01ac19d3585ef90d9aeb70aab501c4fbda931fca", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }\n \n-        self.memory.freeze(vtable.alloc_id)?;\n+        self.memory.mark_static(vtable.alloc_id, false)?;\n \n         Ok(vtable)\n     }"}, {"sha": "0338a766e26278ddc53ca9f6e5d1ed6d07b936e5", "filename": "tests/run-pass/const-vec-of-fns.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/01ac19d3585ef90d9aeb70aab501c4fbda931fca/tests%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ac19d3585ef90d9aeb70aab501c4fbda931fca/tests%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconst-vec-of-fns.rs?ref=01ac19d3585ef90d9aeb70aab501c4fbda931fca", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pretty-expanded FIXME #23616\n+\n+/*!\n+ * Try to double-check that static fns have the right size (with or\n+ * without dummy env ptr, as appropriate) by iterating a size-2 array.\n+ * If the static size differs from the runtime size, the second element\n+ * should be read as a null or otherwise wrong pointer and crash.\n+ */\n+\n+fn f() { }\n+static mut CLOSURES: &'static mut [fn()] = &mut [f as fn(), f as fn()];\n+\n+pub fn main() {\n+    unsafe {\n+        for closure in &mut *CLOSURES {\n+            (*closure)()\n+        }\n+    }\n+}"}, {"sha": "be5830698b2117c7c47420668428b236331ea754", "filename": "tests/run-pass/static_mut.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/01ac19d3585ef90d9aeb70aab501c4fbda931fca/tests%2Frun-pass%2Fstatic_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ac19d3585ef90d9aeb70aab501c4fbda931fca/tests%2Frun-pass%2Fstatic_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstatic_mut.rs?ref=01ac19d3585ef90d9aeb70aab501c4fbda931fca", "patch": "@@ -0,0 +1,17 @@\n+#![allow(dead_code)]\n+\n+static mut FOO: i32 = 42;\n+static BAR: Foo = Foo(unsafe { &FOO as *const _} );\n+\n+struct Foo(*const i32);\n+\n+unsafe impl Sync for Foo {}\n+\n+fn main() {\n+    unsafe {\n+        assert_eq!(*BAR.0, 42);\n+        FOO = 5;\n+        assert_eq!(FOO, 5);\n+        assert_eq!(*BAR.0, 5);\n+    }\n+}"}]}