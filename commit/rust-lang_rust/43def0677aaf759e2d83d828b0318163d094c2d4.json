{"sha": "43def0677aaf759e2d83d828b0318163d094c2d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZGVmMDY3N2FhZjc1OWUyZDgzZDgyOGIwMzE4MTYzZDA5NGMyZDQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-02T23:27:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-02T23:32:19Z"}, "message": "tutorial: More updates for closures", "tree": {"sha": "f3c879eb3abee7e5552cf09aa796919c316ee49b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3c879eb3abee7e5552cf09aa796919c316ee49b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43def0677aaf759e2d83d828b0318163d094c2d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43def0677aaf759e2d83d828b0318163d094c2d4", "html_url": "https://github.com/rust-lang/rust/commit/43def0677aaf759e2d83d828b0318163d094c2d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43def0677aaf759e2d83d828b0318163d094c2d4/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47f43da376ebb54b6e7dbd0d8de9d192decc2dfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/47f43da376ebb54b6e7dbd0d8de9d192decc2dfe", "html_url": "https://github.com/rust-lang/rust/commit/47f43da376ebb54b6e7dbd0d8de9d192decc2dfe"}], "stats": {"total": 119, "additions": 72, "deletions": 47}, "files": [{"sha": "190c42dd461a6ce765b4cbf0d82e150ae52ff41b", "filename": "doc/tutorial.md", "status": "modified", "additions": 71, "deletions": 42, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/43def0677aaf759e2d83d828b0318163d094c2d4/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/43def0677aaf759e2d83d828b0318163d094c2d4/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=43def0677aaf759e2d83d828b0318163d094c2d4", "patch": "@@ -495,16 +495,10 @@ let s = \"a\\\n \n ## Operators\n \n-Rust's set of operators contains very few surprises. The main\n-difference with C is that `++` and `--` are missing, and that the\n-logical bitwise operators have higher precedence\u2014in C, `x & 2 > 0`\n-comes out as `x & (2 > 0)`, in Rust, it means `(x & 2) > 0`, which is\n-more likely to be what you expect (unless you are a C veteran).\n-\n-Thus, binary arithmetic is done with `*`, `/`, `%`, `+`, and `-`\n-(multiply, divide, remainder, plus, minus). `-` is also a unary prefix\n-operator (there are no unary postfix operators in Rust) that does\n-negation.\n+Rust's set of operators contains very few surprises. Binary arithmetic\n+is done with `*`, `/`, `%`, `+`, and `-` (multiply, divide, remainder,\n+plus, minus). `-` is also a unary prefix operator (there are no unary\n+postfix operators in Rust) that does negation.\n \n Binary shifting is done with `>>` (shift right), and `<<` (shift\n left). Shift right is arithmetic if the value is signed and logical if\n@@ -528,6 +522,11 @@ let y: uint = x as uint;\n assert y == 4u;\n ~~~~\n \n+The main difference with C is that `++` and `--` are missing, and that\n+the logical bitwise operators have higher precedence \u2014 in C, `x & 2 > 0`\n+comes out as `x & (2 > 0)`, in Rust, it means `(x & 2) > 0`, which is\n+more likely to be what you expect (unless you are a C veteran).\n+\n ## Attributes\n \n Every definition can be annotated with attributes. Attributes are meta\n@@ -850,33 +849,32 @@ fn bar() -> int {\n }\n ~~~~\n \n-Rust also supports _closures_, functions that can\n-access variables in the enclosing scope.\n+Rust also supports _closures_, functions that can access variables in\n+the enclosing scope.\n \n ~~~~\n+# import println = io::println;\n fn call_closure_with_ten(b: fn(int)) { b(10); }\n \n-let x = 20;\n-let closure = |arg| #info(\"x=%d, arg=%d\", x, arg);\n+let captured_var = 20;\n+let closure = |arg| println(#fmt(\"captured_var=%d, arg=%d\", captured_var, arg));\n \n call_closure_with_ten(closure);\n ~~~~\n \n-A closure is defined by listing the arguments, between bars, followed\n-by an expression that acts as the function body. The types of the\n-arguments are generally omitted, as is the return type, because\n-the compiler can almost always infer them. In the rare case where\n-the compiler needs assistance though, the arguments and return\n-types may be annotated.\n+The types of the arguments are generally omitted, as is the return\n+type, because the compiler can almost always infer them. In the rare\n+case where the compiler needs assistance though, the arguments and\n+return types may be annotated.\n \n ~~~~\n # type mygoodness = fn(str) -> str; type what_the = int;\n let bloop = |well, oh: mygoodness| -> what_the { fail oh(well) };\n ~~~~\n \n There are several forms of closure, each with its own role. The most\n-common, called a _stack closure_ and written `&fn()` has direct access\n-to local variables in the enclosing scope.\n+common, called a _stack closure_, has type `fn&` and can directly\n+access local variables in the enclosing scope.\n \n ~~~~\n let mut max = 0;\n@@ -888,10 +886,9 @@ allocated on the call stack and refers by pointer to captured\n locals. To ensure that stack closures never outlive the local\n variables to which they refer, they can only be used in argument\n position and cannot be stored in structures nor returned from\n-functions.  Despite the usage limitations stack closures are used\n+functions. Despite the usage limitations stack closures are used\n pervasively in Rust code.\n \n-\n ### Boxed closures\n \n When you need to store a closure in a data structure, a stack closure\n@@ -922,6 +919,19 @@ fn main() {\n }\n ~~~~\n \n+This example uses the long closure syntax, `fn@(s: str) ...`,\n+making the fact that we are declaring a box closure explicit. In\n+practice boxed closures are usually defined with the short closure\n+syntax introduced earlier, in which case the compiler will infer\n+the type of closure. Thus our boxed closure example could also\n+be written:\n+\n+~~~~\n+fn mk_appender(suffix: str) -> fn@(str) -> str {\n+    ret |s| s + suffix;\n+}\n+~~~~\n+\n ### Closure compatibility\n \n A nice property of Rust closures is that you can pass any kind of\n@@ -946,18 +956,11 @@ Unique closures, written `fn~` in analogy to the `~` pointer type (see\n next section), hold on to things that can safely be sent between\n processes. They copy the values they close over, much like boxed\n closures, but they also 'own' them\u2014meaning no other code can access\n-them. Unique closures mostly exist for spawning new [tasks](#tasks).\n+them. Unique closures are used in concurrent code, particularly\n+for spawning [tasks](#tasks).\n \n ### Do syntax\n \n-The compact syntax used for stack closures (`|arg1, arg2| body`) can\n-also be used to express boxed and unique closures in situations where\n-the closure style can be unambiguously derived from the context. Most\n-notably, when calling a higher-order function you do not have to use\n-the long-hand syntax for the function you're passing, since the\n-compiler can look at the argument type to find out what the parameter\n-types are.\n-\n Because closures in Rust are so versatile, they are used often, and in\n particular, functions taking closures are used as control structures\n in much the same way as `if` or `loop`. For example, this one iterates\n@@ -997,16 +1000,36 @@ of the parenthesis where it looks visually more like a typical block\n of code. The `do` expression is purely syntactic sugar for a call\n that takes a final closure argument.\n \n-# For loops\n+### For loops\n \n-To allow breaking out of loops, many iteration functions, such as\n-`vec::each`, take a function that returns a boolean, and can return\n-`false` to break off iteration.\n+`for` loops, like `do` expressions, allow functions to be used as\n+as control structures. `for` loops can be used to treat functions\n+with the proper signature as looping constructs, supporting\n+`break`, `cont` and early returns.\n \n+Take for example this `each` function that iterates over a vector,\n+breaking early when the iteratee returns `false`:\n+\n+~~~~\n+fn each<T>(v: &[T], f: fn(T) -> bool) {\n+   let mut n = 0;\n+   while n < v.len() {\n+       if !f(v[n]) {\n+           break;\n+       }\n+       n += 1;\n+   }\n+}\n ~~~~\n-vec::each(~[2, 4, 8, 5, 16], |n| {\n+\n+And using this function to iterate over a vector:\n+\n+~~~~\n+# import each = vec::each;\n+# import println = io::println;\n+each(~[2, 4, 8, 5, 16], |n| {\n     if n % 2 != 0 {\n-        io::println(\"found odd number!\");\n+        println(\"found odd number!\");\n         false\n     } else { true }\n });\n@@ -1018,9 +1041,11 @@ return `true`, and `break` and `cont` can be used, much like in a\n `while` loop, to explicitly return `false` or `true`.\n \n ~~~~\n-for vec::each(~[2, 4, 8, 5, 16]) |n| {\n+# import each = vec::each;\n+# import println = io::println;\n+for each(~[2, 4, 8, 5, 16]) |n| {\n     if n % 2 != 0 {\n-        io::println(\"found odd number!\");\n+        println(\"found odd number!\");\n         break;\n     }\n }\n@@ -1032,14 +1057,16 @@ normally allowed in blocks, in a block that appears as the body of a\n function, not just the loop body.\n \n ~~~~\n+# import each = vec::each;\n fn contains(v: ~[int], elt: int) -> bool {\n-    for vec::each(v) |x| {\n+    for each(v) |x| {\n         if (x == elt) { ret true; }\n     }\n     false\n }\n ~~~~\n \n+\n # Datatypes\n \n Rust datatypes are, by default, immutable. The core datatypes of Rust\n@@ -2579,6 +2606,8 @@ fn divide(a: float, b: float) -> float {\n #[test]\n #[should_fail]\n fn divide_by_zero() { divide(1f, 0f); }\n+\n+# fn main() { }\n ~~~~\n \n To disable a test completely, add an `#[ignore]` attribute. Running a"}, {"sha": "d41e62367fa72400982c9bc0687f12bf77631a57", "filename": "src/etc/extract-tests.py", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43def0677aaf759e2d83d828b0318163d094c2d4/src%2Fetc%2Fextract-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/43def0677aaf759e2d83d828b0318163d094c2d4/src%2Fetc%2Fextract-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract-tests.py?ref=43def0677aaf759e2d83d828b0318163d094c2d4", "patch": "@@ -50,11 +50,7 @@\n                 block += re.sub(\"^# \", \"\", line)\n         if not ignore:\n             if not re.search(r\"\\bfn main\\b\", block):\n-                if re.search(\n-                    r\"(^|\\n) *(native|use|mod|import|export)\\b\", block):\n-                    block += \"\\nfn main() {}\\n\"\n-                else:\n-                    block = \"fn main() {\\n\" + block + \"\\n}\\n\"\n+                block = \"fn main() {\\n\" + block + \"\\n}\\n\"\n             if not re.search(r\"\\buse std\\b\", block):\n                 block = \"use std;\\n\" + block;\n             if xfail:"}]}