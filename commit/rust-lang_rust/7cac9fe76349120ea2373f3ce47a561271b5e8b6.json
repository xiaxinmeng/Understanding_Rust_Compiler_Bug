{"sha": "7cac9fe76349120ea2373f3ce47a561271b5e8b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjYWM5ZmU3NjM0OTEyMGVhMjM3M2YzY2U0N2E1NjEyNzFiNWU4YjY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-04T03:18:58Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-10T23:13:12Z"}, "message": "librustuv: RAII-ify `Local::borrow`, and remove some 12 Cells.", "tree": {"sha": "495b1694a3fa4b84ede3f962b24e703363d64d80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/495b1694a3fa4b84ede3f962b24e703363d64d80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cac9fe76349120ea2373f3ce47a561271b5e8b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cac9fe76349120ea2373f3ce47a561271b5e8b6", "html_url": "https://github.com/rust-lang/rust/commit/7cac9fe76349120ea2373f3ce47a561271b5e8b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cac9fe76349120ea2373f3ce47a561271b5e8b6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "786dea207d5b891d37e596e96dd2f84c4cb59f49", "url": "https://api.github.com/repos/rust-lang/rust/commits/786dea207d5b891d37e596e96dd2f84c4cb59f49", "html_url": "https://github.com/rust-lang/rust/commit/786dea207d5b891d37e596e96dd2f84c4cb59f49"}], "stats": {"total": 388, "additions": 210, "deletions": 178}, "files": [{"sha": "09a13bdddaa841e70accea6e0199f369c9dd433e", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -162,16 +162,20 @@ pub struct ForbidSwitch {\n \n impl ForbidSwitch {\n     fn new(s: &'static str) -> ForbidSwitch {\n+        let mut sched = Local::borrow(None::<Scheduler>);\n         ForbidSwitch {\n-            msg: s, sched: Local::borrow(|s: &mut Scheduler| s.sched_id())\n+            msg: s,\n+            sched: sched.get().sched_id(),\n         }\n     }\n }\n \n impl Drop for ForbidSwitch {\n     fn drop(&mut self) {\n-        assert!(self.sched == Local::borrow(|s: &mut Scheduler| s.sched_id()),\n-                \"didnt want a scheduler switch: {}\", self.msg);\n+        let mut sched = Local::borrow(None::<Scheduler>);\n+        assert!(self.sched == sched.get().sched_id(),\n+                \"didnt want a scheduler switch: {}\",\n+                self.msg);\n     }\n }\n \n@@ -389,15 +393,16 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n #[cfg(test)]\n fn local_loop() -> &'static mut Loop {\n     unsafe {\n-        cast::transmute(Local::borrow(|sched: &mut Scheduler| {\n+        cast::transmute({\n+            let mut sched = Local::borrow(None::<Scheduler>);\n             let mut io = None;\n-            sched.event_loop.io(|i| {\n+            sched.get().event_loop.io(|i| {\n                 let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n                     cast::transmute(i);\n                 io = Some(uvio);\n             });\n             io.unwrap()\n-        }).uv_loop())\n+        }.uv_loop())\n     }\n }\n "}, {"sha": "a63dcc6de3105c97f7a196b7024cfc2d13735288", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -29,7 +29,10 @@ macro_rules! uvdebug (\n \n // get a handle for the current scheduler\n macro_rules! get_handle_to_current_scheduler(\n-    () => (Local::borrow(|sched: &mut Scheduler| sched.make_handle()))\n+    () => ({\n+        let mut sched = Local::borrow(None::<Scheduler>);\n+        sched.get().make_handle()\n+    })\n )\n \n pub fn dumb_println(args: &fmt::Arguments) {"}, {"sha": "1e9c40443458c3199eefb16c554bc298cc9a03d3", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -1080,11 +1080,10 @@ mod test {\n             };\n \n             unsafe fn local_io() -> &'static mut IoFactory {\n-                Local::borrow(|sched: &mut Scheduler| {\n-                    let mut io = None;\n-                    sched.event_loop.io(|i| io = Some(i));\n-                    cast::transmute(io.unwrap())\n-                })\n+                let mut sched = Local::borrow(None::<Scheduler>);\n+                let mut io = None;\n+                sched.get().event_loop.io(|i| io = Some(i));\n+                cast::transmute(io.unwrap())\n             }\n \n             let test_function: proc() = proc() {"}, {"sha": "c0d7a35cef8a882d9907b517464c7e4c798b2416", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -45,9 +45,10 @@ pub trait HomingIO {\n \n         let _f = ForbidUnwind::new(\"going home\");\n \n-        let current_sched_id = Local::borrow(|sched: &mut Scheduler| {\n-            sched.sched_id()\n-        });\n+        let current_sched_id = {\n+            let mut sched = Local::borrow(None::<Scheduler>);\n+            sched.get().sched_id()\n+        };\n \n         // Only need to invoke a context switch if we're not on the right\n         // scheduler.\n@@ -59,9 +60,10 @@ pub trait HomingIO {\n                 });\n             })\n         }\n-        let current_sched_id = Local::borrow(|sched: &mut Scheduler| {\n-            sched.sched_id()\n-        });\n+        let current_sched_id = {\n+            let mut sched = Local::borrow(None::<Scheduler>);\n+            sched.get().sched_id()\n+        };\n         assert!(current_sched_id == self.home().sched_id);\n \n         self.home().sched_id\n@@ -96,7 +98,8 @@ struct HomingMissile {\n \n impl HomingMissile {\n     pub fn check(&self, msg: &'static str) {\n-        let local_id = Local::borrow(|sched: &mut Scheduler| sched.sched_id());\n+        let mut sched = Local::borrow(None::<Scheduler>);\n+        let local_id = sched.get().sched_id();\n         assert!(local_id == self.io_home, \"{}\", msg);\n     }\n }"}, {"sha": "2b64c5c83fbda276edf76392023491f4292a5c02", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -169,6 +169,7 @@ pub mod raw {\n     use at_vec::capacity;\n     use cast;\n     use cast::{transmute, transmute_copy};\n+    use option::None;\n     use ptr;\n     use mem;\n     use uint;\n@@ -259,9 +260,8 @@ pub mod raw {\n             use rt::local::Local;\n             use rt::task::Task;\n \n-            Local::borrow(|task: &mut Task| {\n-                task.heap.realloc(ptr as *mut Box<()>, size) as *()\n-            })\n+            let mut task = Local::borrow(None::<Task>);\n+            task.get().heap.realloc(ptr as *mut Box<()>, size) as *()\n         }\n     }\n "}, {"sha": "82f92bdb803e4c46271493ba687dacc8b933db85", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cell::Cell;\n use c_str::{ToCStr, CString};\n use libc::{c_char, size_t};\n use option::{Option, None, Some};\n@@ -35,7 +34,8 @@ pub struct BorrowRecord {\n }\n \n fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n-    Local::borrow(|task: &mut Task| task.borrow_list.take())\n+    let mut task = Local::borrow(None::<Task>);\n+    task.get().borrow_list.take()\n }\n \n fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n@@ -44,8 +44,9 @@ fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n         None => ~[]\n     };\n     let borrows = f(borrows);\n-    let borrows = Cell::new(borrows);\n-    Local::borrow(|task: &mut Task| task.borrow_list = Some(borrows.take()))\n+\n+    let mut task = Local::borrow(None::<Task>);\n+    task.get().borrow_list = Some(borrows)\n }\n \n pub fn clear_task_borrow_list() {"}, {"sha": "d6024b7abea433dda041b11ed50186525fb6ccfe", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -25,7 +25,7 @@ use unstable::sync::UnsafeArc;\n use util;\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable, SendDeferred};\n-use cell::{Cell, RefCell};\n+use cell::RefCell;\n use clone::Clone;\n use tuple::ImmutableTuple;\n \n@@ -169,10 +169,8 @@ impl<T: Send> ChanOne<T> {\n                             Scheduler::run_task(woken_task);\n                         });\n                     } else {\n-                        let recvr = Cell::new(recvr);\n-                        Local::borrow(|sched: &mut Scheduler| {\n-                            sched.enqueue_blocked_task(recvr.take());\n-                        })\n+                        let mut sched = Local::borrow(None::<Scheduler>);\n+                        sched.get().enqueue_blocked_task(recvr);\n                     }\n                 }\n             }\n@@ -230,9 +228,8 @@ impl<T: Send> SelectInner for PortOne<T> {\n         // The optimistic check is never necessary for correctness. For testing\n         // purposes, making it randomly return false simulates a racing sender.\n         use rand::{Rand};\n-        let actually_check = Local::borrow(|sched: &mut Scheduler| {\n-            Rand::rand(&mut sched.rng)\n-        });\n+        let mut sched = Local::borrow(None::<Scheduler>);\n+        let actually_check = Rand::rand(&mut sched.get().rng);\n         if actually_check {\n             unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n         } else {"}, {"sha": "d73ad98a25b37ead1637d8d0b9b8343abb51672c", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -12,36 +12,28 @@ use option::{Option, Some, None};\n use rt::sched::Scheduler;\n use rt::task::Task;\n use rt::local_ptr;\n-use cell::Cell;\n \n-pub trait Local {\n+/// Encapsulates some task-local data.\n+pub trait Local<Borrowed> {\n     fn put(value: ~Self);\n     fn take() -> ~Self;\n     fn exists(unused_value: Option<Self>) -> bool;\n-    fn borrow<T>(f: |&mut Self| -> T) -> T;\n+    fn borrow(unused_value: Option<Self>) -> Borrowed;\n     unsafe fn unsafe_take() -> ~Self;\n     unsafe fn unsafe_borrow() -> *mut Self;\n     unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n }\n \n-impl Local for Task {\n+impl Local<local_ptr::Borrowed<Task>> for Task {\n     #[inline]\n     fn put(value: ~Task) { unsafe { local_ptr::put(value) } }\n     #[inline]\n     fn take() -> ~Task { unsafe { local_ptr::take() } }\n     fn exists(_: Option<Task>) -> bool { local_ptr::exists() }\n-    fn borrow<T>(f: |&mut Task| -> T) -> T {\n-        let mut res: Option<T> = None;\n-        let res_ptr: *mut Option<T> = &mut res;\n+    #[inline]\n+    fn borrow(_: Option<Task>) -> local_ptr::Borrowed<Task> {\n         unsafe {\n-            local_ptr::borrow(|task| {\n-                let result = f(task);\n-                *res_ptr = Some(result);\n-            })\n-        }\n-        match res {\n-            Some(r) => { r }\n-            None => { rtabort!(\"function failed in local_borrow\") }\n+            local_ptr::borrow::<Task>()\n         }\n     }\n     #[inline]\n@@ -54,13 +46,35 @@ impl Local for Task {\n     }\n }\n \n-impl Local for Scheduler {\n+/// Encapsulates a temporarily-borrowed scheduler.\n+pub struct BorrowedScheduler {\n+    priv task: local_ptr::Borrowed<Task>,\n+}\n+\n+impl BorrowedScheduler {\n+    fn new(mut task: local_ptr::Borrowed<Task>) -> BorrowedScheduler {\n+        if task.get().sched.is_none() {\n+            rtabort!(\"no scheduler\")\n+        } else {\n+            BorrowedScheduler {\n+                task: task,\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get<'a>(&'a mut self) -> &'a mut ~Scheduler {\n+        match self.task.get().sched {\n+            None => rtabort!(\"no scheduler\"),\n+            Some(ref mut sched) => sched,\n+        }\n+    }\n+}\n+\n+impl Local<BorrowedScheduler> for Scheduler {\n     fn put(value: ~Scheduler) {\n-        let value = Cell::new(value);\n-        Local::borrow(|task: &mut Task| {\n-            let task = task;\n-            task.sched = Some(value.take());\n-        });\n+        let mut task = Local::borrow(None::<Task>);\n+        task.get().sched = Some(value);\n     }\n     #[inline]\n     fn take() -> ~Scheduler {\n@@ -71,24 +85,12 @@ impl Local for Scheduler {\n         }\n     }\n     fn exists(_: Option<Scheduler>) -> bool {\n-        Local::borrow(|task: &mut Task| {\n-            match task.sched {\n-                Some(ref _task) => true,\n-                None => false\n-            }\n-        })\n+        let mut task = Local::borrow(None::<Task>);\n+        task.get().sched.is_some()\n     }\n-    fn borrow<T>(f: |&mut Scheduler| -> T) -> T {\n-        Local::borrow(|task: &mut Task| {\n-            match task.sched {\n-                Some(~ref mut task) => {\n-                    f(task)\n-                }\n-                None => {\n-                    rtabort!(\"no scheduler\")\n-                }\n-            }\n-        })\n+    #[inline]\n+    fn borrow(_: Option<Scheduler>) -> BorrowedScheduler {\n+        BorrowedScheduler::new(Local::borrow(None::<Task>))\n     }\n     unsafe fn unsafe_take() -> ~Scheduler { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut Scheduler {\n@@ -182,11 +184,11 @@ mod test {\n             let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);\n \n-            let res = Local::borrow(|_task: &mut Task| {\n-                true\n-            });\n-            assert!(res)\n-                let task: ~Task = Local::take();\n+            {\n+                let _ = Local::borrow(None::<Task>);\n+            }\n+\n+            let task: ~Task = Local::take();\n             cleanup_task(task);\n         }\n     }"}, {"sha": "e364137de4572ad5dda80efb3fe4cd7036319a41", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -304,7 +304,8 @@ pub unsafe fn local_free(ptr: *libc::c_char) {\n }\n \n pub fn live_allocs() -> *mut Box {\n-    Local::borrow(|task: &mut Task| task.heap.live_allocs)\n+    let mut task = Local::borrow(None::<Task>);\n+    task.get().heap.live_allocs\n }\n \n #[cfg(test)]"}, {"sha": "66fe9742121ff49d2feee0a55aa4d930858cc7dc", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -18,8 +18,7 @@\n #[allow(dead_code)];\n \n use cast;\n-use cell::Cell;\n-use unstable::finally::Finally;\n+use ops::Drop;\n \n #[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n #[cfg(target_os = \"android\")] // see #10686\n@@ -28,20 +27,48 @@ pub use self::native::*;\n #[cfg(not(windows), not(target_os = \"android\"))]\n pub use self::compiled::*;\n \n+/// Encapsulates a borrowed value. When this value goes out of scope, the\n+/// pointer is returned.\n+pub struct Borrowed<T> {\n+    priv val: *(),\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for Borrowed<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            if self.val.is_null() {\n+                rtabort!(\"Aiee, returning null borrowed object!\");\n+            }\n+            let val: ~T = cast::transmute(self.val);\n+            put::<T>(val);\n+            assert!(exists());\n+        }\n+    }\n+}\n+\n+impl<T> Borrowed<T> {\n+    pub fn get<'a>(&'a mut self) -> &'a mut T {\n+        unsafe {\n+            let val_ptr: &mut ~T = cast::transmute(&mut self.val);\n+            let val_ptr: &'a mut T = *val_ptr;\n+            val_ptr\n+        }\n+    }\n+}\n+\n /// Borrow the thread-local value from thread-local storage.\n /// While the value is borrowed it is not available in TLS.\n ///\n /// # Safety note\n ///\n /// Does not validate the pointer type.\n-pub unsafe fn borrow<T>(f: |&mut T|) {\n-    let mut value = take();\n-\n-    // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n-    let unsafe_ptr = cast::transmute_mut_region(&mut *value);\n-    let value_cell = Cell::new(value);\n-\n-    (|| f(unsafe_ptr)).finally(|| put(value_cell.take()));\n+#[inline]\n+pub unsafe fn borrow<T>() -> Borrowed<T> {\n+    let val: *() = cast::transmute(take::<T>());\n+    Borrowed {\n+        val: val,\n+    }\n }\n \n /// Compiled implementation of accessing the runtime local pointer. This is"}, {"sha": "f4410f7ee27ca8b6798870cf7c0cc57b5ac81aa3", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -24,7 +24,6 @@ use rt::local_ptr;\n use rt::local::Local;\n use rt::rtio::{RemoteCallback, PausibleIdleCallback, Callback};\n use borrow::{to_uint};\n-use cell::Cell;\n use rand::{XorShiftRng, Rng, Rand};\n use iter::range;\n use unstable::mutex::Mutex;\n@@ -235,12 +234,12 @@ impl Scheduler {\n         unsafe {\n             let event_loop: *mut ~EventLoop = &mut self.event_loop;\n \n-            // Our scheduler must be in the task before the event loop\n-            // is started.\n-            let self_sched = Cell::new(self);\n-            Local::borrow(|stask: &mut Task| {\n-                stask.sched = Some(self_sched.take());\n-            });\n+            {\n+                // Our scheduler must be in the task before the event loop\n+                // is started.\n+                let mut stask = Local::borrow(None::<Task>);\n+                stask.get().sched = Some(self);\n+            }\n \n             (*event_loop).run();\n         }\n@@ -751,10 +750,8 @@ impl Scheduler {\n     }\n \n     pub fn run_task_later(next_task: ~Task) {\n-        let next_task = Cell::new(next_task);\n-        Local::borrow(|sched: &mut Scheduler| {\n-            sched.enqueue_task(next_task.take());\n-        });\n+        let mut sched = Local::borrow(None::<Scheduler>);\n+        sched.get().enqueue_task(next_task);\n     }\n \n     /// Yield control to the scheduler, executing another task. This is guaranteed"}, {"sha": "0cb60c58a6d3353b7cc8c35c3f677fc0a39aab35", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -144,17 +144,15 @@ impl Task {\n                              f: proc(),\n                              home: SchedHome)\n                              -> ~Task {\n-        let f = Cell::new(f);\n-        let home = Cell::new(home);\n-        Local::borrow(|running_task: &mut Task| {\n-            let mut sched = running_task.sched.take_unwrap();\n-            let new_task = ~running_task.new_child_homed(&mut sched.stack_pool,\n-                                                         stack_size,\n-                                                         home.take(),\n-                                                         f.take());\n-            running_task.sched = Some(sched);\n-            new_task\n-        })\n+        let mut running_task = Local::borrow(None::<Task>);\n+        let mut sched = running_task.get().sched.take_unwrap();\n+        let new_task = ~running_task.get()\n+                                    .new_child_homed(&mut sched.stack_pool,\n+                                                     stack_size,\n+                                                     home,\n+                                                     f);\n+        running_task.get().sched = Some(sched);\n+        new_task\n     }\n \n     pub fn build_child(stack_size: Option<uint>, f: proc()) -> ~Task {\n@@ -165,17 +163,14 @@ impl Task {\n                             f: proc(),\n                             home: SchedHome)\n                             -> ~Task {\n-        let f = Cell::new(f);\n-        let home = Cell::new(home);\n-        Local::borrow(|running_task: &mut Task| {\n-            let mut sched = running_task.sched.take_unwrap();\n-            let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n-                                                 stack_size,\n-                                                 home.take(),\n-                                                 f.take());\n-            running_task.sched = Some(sched);\n-            new_task\n-        })\n+        let mut running_task = Local::borrow(None::<Task>);\n+        let mut sched = running_task.get().sched.take_unwrap();\n+        let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n+                                             stack_size,\n+                                             home,\n+                                             f);\n+        running_task.get().sched = Some(sched);\n+        new_task\n     }\n \n     pub fn build_root(stack_size: Option<uint>, f: proc()) -> ~Task {\n@@ -371,26 +366,25 @@ impl Task {\n     // Grab both the scheduler and the task from TLS and check if the\n     // task is executing on an appropriate scheduler.\n     pub fn on_appropriate_sched() -> bool {\n-        Local::borrow(|task: &mut Task| {\n-            let sched_id = task.sched.get_ref().sched_id();\n-            let sched_run_anything = task.sched.get_ref().run_anything;\n-            match task.task_type {\n-                GreenTask(Some(AnySched)) => {\n-                    rtdebug!(\"anysched task in sched check ****\");\n-                    sched_run_anything\n-                }\n-                GreenTask(Some(Sched(SchedHandle { sched_id: ref id, ..}))) => {\n-                    rtdebug!(\"homed task in sched check ****\");\n-                    *id == sched_id\n-                }\n-                GreenTask(None) => {\n-                    rtabort!(\"task without home\");\n-                }\n-                SchedTask => {\n-                    rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n-                }\n+        let mut task = Local::borrow(None::<Task>);\n+        let sched_id = task.get().sched.get_ref().sched_id();\n+        let sched_run_anything = task.get().sched.get_ref().run_anything;\n+        match task.get().task_type {\n+            GreenTask(Some(AnySched)) => {\n+                rtdebug!(\"anysched task in sched check ****\");\n+                sched_run_anything\n+            }\n+            GreenTask(Some(Sched(SchedHandle { sched_id: ref id, ..}))) => {\n+                rtdebug!(\"homed task in sched check ****\");\n+                *id == sched_id\n+            }\n+            GreenTask(None) => {\n+                rtabort!(\"task without home\");\n             }\n-        })\n+            SchedTask => {\n+                rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n+            }\n+        }\n     }\n }\n \n@@ -440,9 +434,10 @@ impl Coroutine {\n             unsafe {\n \n                 // Again - might work while safe, or it might not.\n-                Local::borrow(|sched: &mut Scheduler| {\n-                    sched.run_cleanup_job();\n-                });\n+                {\n+                    let mut sched = Local::borrow(None::<Scheduler>);\n+                    sched.get().run_cleanup_job();\n+                }\n \n                 // To call the run method on a task we need a direct\n                 // reference to it. The task is in TLS, so we can\n@@ -594,16 +589,19 @@ pub extern \"C\" fn rust_stack_exhausted() {\n         //  #2361 - possible implementation of not using landing pads\n \n         if in_green_task_context() {\n-            Local::borrow(|task: &mut Task| {\n-                let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-                // See the message below for why this is not emitted to the\n-                // task's logger. This has the additional conundrum of the\n-                // logger may not be initialized just yet, meaning that an FFI\n-                // call would happen to initialized it (calling out to libuv),\n-                // and the FFI call needs 2MB of stack when we just ran out.\n-                rterrln!(\"task '{}' has overflowed its stack\", n);\n-            })\n+            let mut task = Local::borrow(None::<Task>);\n+            let n = task.get()\n+                        .name\n+                        .as_ref()\n+                        .map(|n| n.as_slice())\n+                        .unwrap_or(\"<unnamed>\");\n+\n+            // See the message below for why this is not emitted to the\n+            // task's logger. This has the additional conundrum of the\n+            // logger may not be initialized just yet, meaning that an FFI\n+            // call would happen to initialized it (calling out to libuv),\n+            // and the FFI call needs 2MB of stack when we just ran out.\n+            rterrln!(\"task '{}' has overflowed its stack\", n);\n         } else {\n             rterrln!(\"stack overflow in non-task context\");\n         }"}, {"sha": "15d8c7f9aac65a6968f6c24f703dc77b51cbff2e", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -121,9 +121,9 @@ mod test {\n             let tube_clone = Cell::new(tube_clone);\n             let sched: ~Scheduler = Local::take();\n             sched.deschedule_running_task_and_then(|sched, task| {\n-                let tube_clone = Cell::new(tube_clone.take());\n+                let tube_clone = tube_clone.take();\n                 do sched.event_loop.callback {\n-                    let mut tube_clone = tube_clone.take();\n+                    let mut tube_clone = tube_clone;\n                     // The task should be blocked on this now and\n                     // sending will wake it up.\n                     tube_clone.send(1);\n@@ -148,19 +148,18 @@ mod test {\n                 callback_send(tube_clone.take(), 0);\n \n                 fn callback_send(tube: Tube<int>, i: int) {\n-                    if i == 100 { return; }\n-\n-                    let tube = Cell::new(Cell::new(tube));\n-                    Local::borrow(|sched: &mut Scheduler| {\n-                        let tube = tube.take();\n-                        do sched.event_loop.callback {\n-                            let mut tube = tube.take();\n-                            // The task should be blocked on this now and\n-                            // sending will wake it up.\n-                            tube.send(i);\n-                            callback_send(tube, i + 1);\n-                        }\n-                    })\n+                    if i == 100 {\n+                        return\n+                    }\n+\n+                    let mut sched = Local::borrow(None::<Scheduler>);\n+                    do sched.get().event_loop.callback {\n+                        let mut tube = tube;\n+                        // The task should be blocked on this now and\n+                        // sending will wake it up.\n+                        tube.send(i);\n+                        callback_send(tube, i + 1);\n+                    }\n                 }\n \n                 sched.enqueue_blocked_task(task);"}, {"sha": "24a24f2481887f600067e4af6cd947744a617538", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cac9fe76349120ea2373f3ce47a561271b5e8b6/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=7cac9fe76349120ea2373f3ce47a561271b5e8b6", "patch": "@@ -429,12 +429,11 @@ pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     use rt::task::Task;\n \n     if in_green_task_context() {\n-        Local::borrow(|task: &mut Task| {\n-            match task.name {\n-                Some(ref name) => blk(Some(name.as_slice())),\n-                None => blk(None)\n-            }\n-        })\n+        let mut task = Local::borrow(None::<Task>);\n+        match task.get().name {\n+            Some(ref name) => blk(Some(name.as_slice())),\n+            None => blk(None)\n+        }\n     } else {\n         fail!(\"no task name exists in non-green task context\")\n     }\n@@ -456,7 +455,8 @@ pub fn failing() -> bool {\n \n     use rt::task::Task;\n \n-    Local::borrow(|local: &mut Task| local.unwinder.unwinding)\n+    let mut local = Local::borrow(None::<Task>);\n+    local.get().unwinder.unwinding\n }\n \n // The following 8 tests test the following 2^3 combinations:\n@@ -601,9 +601,9 @@ fn test_try_fail() {\n \n #[cfg(test)]\n fn get_sched_id() -> int {\n-    Local::borrow(|sched: &mut ::rt::sched::Scheduler| {\n-        sched.sched_id() as int\n-    })\n+    use rt::sched::Scheduler;\n+    let mut sched = Local::borrow(None::<Scheduler>);\n+    sched.get().sched_id() as int\n }\n \n #[test]"}]}