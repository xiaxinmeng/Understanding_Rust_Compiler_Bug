{"sha": "e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MjE1YTRmNmY3YjMyZDBmMDY4ZTcyYWI5YTljOWY4NWJhYjBjZGI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-10T14:40:45Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-28T08:04:50Z"}, "message": "Use `Ident`s for path segments in HIR", "tree": {"sha": "cccfb96732fd6728ab30a6a7b8b3afad1b66f238", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cccfb96732fd6728ab30a6a7b8b3afad1b66f238"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "html_url": "https://github.com/rust-lang/rust/commit/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fe9b4d76331103e05d0347c9d36526ca3242117", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe9b4d76331103e05d0347c9d36526ca3242117", "html_url": "https://github.com/rust-lang/rust/commit/1fe9b4d76331103e05d0347c9d36526ca3242117"}], "stats": {"total": 178, "additions": 88, "deletions": 90}, "files": [{"sha": "29507474aa1eee246984a20790ad027814db8166", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -644,7 +644,7 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n-    visitor.visit_name(path_span, segment.name);\n+    visitor.visit_ident(segment.ident);\n     if let Some(ref args) = segment.args {\n         visitor.visit_generic_args(path_span, args);\n     }"}, {"sha": "5a0e9c36b910a0cef33a73a2a509ac9cd4d4a44f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -604,8 +604,8 @@ impl<'a> LoweringContext<'a> {\n         self.sess.diagnostic()\n     }\n \n-    fn str_to_ident(&self, s: &'static str) -> Name {\n-        Symbol::gensym(s)\n+    fn str_to_ident(&self, s: &'static str) -> Ident {\n+        Ident::with_empty_ctxt(Symbol::gensym(s))\n     }\n \n     fn allow_internal_unstable(&self, reason: CompilerDesugaringKind, span: Span) -> Span {\n@@ -1139,7 +1139,7 @@ impl<'a> LoweringContext<'a> {\n                 None,\n                 P(hir::Path {\n                     def: self.expect_full_def(t.id),\n-                    segments: hir_vec![hir::PathSegment::from_name(keywords::SelfType.name())],\n+                    segments: hir_vec![hir::PathSegment::from_ident(keywords::SelfType.ident())],\n                     span: t.span,\n                 }),\n             )),\n@@ -1195,7 +1195,7 @@ impl<'a> LoweringContext<'a> {\n \n                         let hir_bounds = self.lower_param_bounds(bounds, itctx);\n                         // Set the name to `impl Bound1 + Bound2`\n-                        let name = Symbol::intern(&pprust::ty_to_string(t));\n+                        let ident = Ident::from_str(&pprust::ty_to_string(t));\n                         self.in_band_ty_params.push(hir::GenericParam {\n                             id: def_node_id,\n                             name: ParamName::Plain(name),\n@@ -1214,7 +1214,7 @@ impl<'a> LoweringContext<'a> {\n                             P(hir::Path {\n                                 span,\n                                 def: Def::TyParam(DefId::local(def_index)),\n-                                segments: hir_vec![hir::PathSegment::from_name(name)],\n+                                segments: hir_vec![hir::PathSegment::from_ident(ident)],\n                             }),\n                         ))\n                     }\n@@ -1689,7 +1689,7 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         def: Def,\n         p: &Path,\n-        name: Option<Name>,\n+        ident: Option<Ident>,\n         param_mode: ParamMode,\n     ) -> hir::Path {\n         hir::Path {\n@@ -1706,7 +1706,7 @@ impl<'a> LoweringContext<'a> {\n                         ImplTraitContext::Disallowed,\n                     )\n                 })\n-                .chain(name.map(|name| hir::PathSegment::from_name(name)))\n+                .chain(ident.map(|ident| hir::PathSegment::from_ident(ident)))\n                 .collect(),\n             span: p.span,\n         }\n@@ -1769,7 +1769,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::PathSegment::new(\n-            self.lower_ident(segment.ident),\n+            segment.ident,\n             generic_args,\n             infer_types,\n         )\n@@ -3307,7 +3307,7 @@ impl<'a> LoweringContext<'a> {\n                         P(hir::Path {\n                             span: ident.span,\n                             def,\n-                            segments: hir_vec![hir::PathSegment::from_name(ident.name)],\n+                            segments: hir_vec![hir::PathSegment::from_ident(ident)],\n                         }),\n                     )),\n                 }\n@@ -3670,7 +3670,7 @@ impl<'a> LoweringContext<'a> {\n                 let e2 = self.lower_expr(e2);\n                 let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], None, false));\n                 let ty = P(self.ty_path(id, span, hir::QPath::Resolved(None, ty_path)));\n-                let new_seg = P(hir::PathSegment::from_name(Symbol::intern(\"new\")));\n+                let new_seg = P(hir::PathSegment::from_name(Ident::from_str(\"new\")));\n                 let new_path = hir::QPath::TypeRelative(ty, new_seg);\n                 let new = P(self.expr(span, hir::ExprPath(new_path), ThinVec::new()));\n                 hir::ExprCall(new, hir_vec![e1, e2])\n@@ -4340,14 +4340,14 @@ impl<'a> LoweringContext<'a> {\n         self.expr(span, hir::ExprCall(e, args), ThinVec::new())\n     }\n \n-    fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> hir::Expr {\n-        self.expr_ident_with_attrs(span, id, binding, ThinVec::new())\n+    fn expr_ident(&mut self, span: Span, ident: Ident, binding: NodeId) -> hir::Expr {\n+        self.expr_ident_with_attrs(span, ident, binding, ThinVec::new())\n     }\n \n     fn expr_ident_with_attrs(\n         &mut self,\n         span: Span,\n-        id: Name,\n+        ident: Ident,\n         binding: NodeId,\n         attrs: ThinVec<Attribute>,\n     ) -> hir::Expr {\n@@ -4356,7 +4356,7 @@ impl<'a> LoweringContext<'a> {\n             P(hir::Path {\n                 span,\n                 def: Def::Local(binding),\n-                segments: hir_vec![hir::PathSegment::from_name(id)],\n+                segments: hir_vec![hir::PathSegment::from_ident(ident)],\n             }),\n         ));\n \n@@ -4438,7 +4438,7 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         sp: Span,\n         mutbl: bool,\n-        ident: Name,\n+        ident: Ident,\n         ex: P<hir::Expr>,\n     ) -> (hir::Stmt, NodeId) {\n         let pat = if mutbl {\n@@ -4509,22 +4509,22 @@ impl<'a> LoweringContext<'a> {\n         self.pat(span, pt)\n     }\n \n-    fn pat_ident(&mut self, span: Span, name: Name) -> P<hir::Pat> {\n-        self.pat_ident_binding_mode(span, name, hir::BindingAnnotation::Unannotated)\n+    fn pat_ident(&mut self, span: Span, ident: Ident) -> P<hir::Pat> {\n+        self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n     }\n \n     fn pat_ident_binding_mode(\n         &mut self,\n         span: Span,\n-        name: Name,\n+        ident: Ident,\n         bm: hir::BindingAnnotation,\n     ) -> P<hir::Pat> {\n         let LoweredNodeId { node_id, hir_id } = self.next_id();\n \n         P(hir::Pat {\n             id: node_id,\n             hir_id,\n-            node: hir::PatKind::Binding(bm, node_id, Spanned { span, node: name }, None),\n+            node: hir::PatKind::Binding(bm, node_id, Spanned { span, node: ident.name }, None),\n             span,\n         })\n     }"}, {"sha": "44c67b6e89a320dd2f64c756d6faadf585d66b89", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -320,7 +320,7 @@ pub struct Path {\n \n impl Path {\n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n     }\n }\n \n@@ -341,7 +341,7 @@ impl fmt::Display for Path {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n-    pub name: Name,\n+    pub ident: Ident,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n@@ -359,17 +359,17 @@ pub struct PathSegment {\n \n impl PathSegment {\n     /// Convert an identifier to the corresponding segment.\n-    pub fn from_name(name: Name) -> PathSegment {\n+    pub fn from_ident(ident: Ident) -> PathSegment {\n         PathSegment {\n-            name,\n+            ident,\n             infer_types: true,\n             args: None,\n         }\n     }\n \n-    pub fn new(name: Name, args: GenericArgs, infer_types: bool) -> Self {\n+    pub fn new(ident: Ident, args: GenericArgs, infer_types: bool) -> Self {\n         PathSegment {\n-            name,\n+            ident,\n             infer_types,\n             args: if args.is_empty() {\n                 None"}, {"sha": "dc1883aebd574d33499d0202557ec9e53a535156", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -559,7 +559,7 @@ impl<'a> State<'a> {\n \n                 match kind {\n                     hir::UseKind::Single => {\n-                        if path.segments.last().unwrap().name != item.name {\n+                        if path.segments.last().unwrap().ident.name != item.name {\n                             self.s.space()?;\n                             self.word_space(\"as\")?;\n                             self.print_name(item.name)?;\n@@ -845,7 +845,8 @@ impl<'a> State<'a> {\n             hir::Visibility::Crate(ast::CrateSugar::PubCrate) => self.word_nbsp(\"pub(crate)\")?,\n             hir::Visibility::Restricted { ref path, .. } => {\n                 self.s.word(\"pub(\")?;\n-                if path.segments.len() == 1 && path.segments[0].name == keywords::Super.name() {\n+                if path.segments.len() == 1 &&\n+                   path.segments[0].ident.name == keywords::Super.name() {\n                     // Special case: `super` can print like `pub(super)`.\n                     self.s.word(\"super\")?;\n                 } else {\n@@ -1266,7 +1267,7 @@ impl<'a> State<'a> {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n-        self.print_name(segment.name)?;\n+        self.print_ident(segment.ident)?;\n \n         segment.with_generic_args(|generic_args| {\n             if !generic_args.args.is_empty() || !generic_args.bindings.is_empty() {\n@@ -1634,9 +1635,9 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 self.s.word(\"::\")?\n             }\n-            if segment.name != keywords::CrateRoot.name() &&\n-               segment.name != keywords::DollarCrate.name() {\n-               self.print_name(segment.name)?;\n+            if segment.ident.name != keywords::CrateRoot.name() &&\n+               segment.ident.name != keywords::DollarCrate.name() {\n+               self.print_ident(segment.ident)?;\n                segment.with_generic_args(|generic_args| {\n                    self.print_generic_args(generic_args, segment.infer_types,\n                                            colons_before_params)\n@@ -1665,9 +1666,9 @@ impl<'a> State<'a> {\n                     if i > 0 {\n                         self.s.word(\"::\")?\n                     }\n-                    if segment.name != keywords::CrateRoot.name() &&\n-                       segment.name != keywords::DollarCrate.name() {\n-                        self.print_name(segment.name)?;\n+                    if segment.ident.name != keywords::CrateRoot.name() &&\n+                       segment.ident.name != keywords::DollarCrate.name() {\n+                        self.print_ident(segment.ident)?;\n                         segment.with_generic_args(|generic_args| {\n                             self.print_generic_args(generic_args,\n                                                     segment.infer_types,\n@@ -1679,7 +1680,7 @@ impl<'a> State<'a> {\n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n                 let item_segment = path.segments.last().unwrap();\n-                self.print_name(item_segment.name)?;\n+                self.print_ident(item_segment.ident)?;\n                 item_segment.with_generic_args(|generic_args| {\n                     self.print_generic_args(generic_args,\n                                             item_segment.infer_types,\n@@ -1691,7 +1692,7 @@ impl<'a> State<'a> {\n                 self.print_type(qself)?;\n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n-                self.print_name(item_segment.name)?;\n+                self.print_ident(item_segment.ident)?;\n                 item_segment.with_generic_args(|generic_args| {\n                     self.print_generic_args(generic_args,\n                                             item_segment.infer_types,"}, {"sha": "feff4a5c27198e893246cfb826de7339747c0530", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -172,7 +172,7 @@ impl_stable_hash_for!(struct hir::Path {\n });\n \n impl_stable_hash_for!(struct hir::PathSegment {\n-    name,\n+    ident,\n     infer_types,\n     args\n });"}, {"sha": "70defbb0215d25319cde6b01d9f537c635f0965a", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -407,7 +407,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n                 if path.segments.len() == 1 {\n                     NonUpperCaseGlobals::check_upper_case(cx,\n                                                           \"constant in pattern\",\n-                                                          path.segments[0].name,\n+                                                          path.segments[0].ident.name,\n                                                           path.span);\n                 }\n             }"}, {"sha": "2aecbf32ec5a1e81fc53f166cee4cb5853187fa0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -830,8 +830,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             let is_local_static = if let Def::Static(..) = def { def_id.is_local() } else { false };\n             if !self.item_is_accessible(def_id) && !is_local_static {\n                 let name = match *qpath {\n-                    hir::QPath::Resolved(_, ref path) => format!(\"{}\", path),\n-                    hir::QPath::TypeRelative(_, ref segment) => segment.name.to_string(),\n+                    hir::QPath::Resolved(_, ref path) => path.to_string(),\n+                    hir::QPath::TypeRelative(_, ref segment) => segment.ident.to_string(),\n                 };\n                 let msg = format!(\"{} `{}` is private\", def.kind_name(), name);\n                 self.tcx.sess.span_err(span, &msg);"}, {"sha": "1437aa5fcc5d2ae1bf3bf6e84c8851b96181991f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -1550,16 +1550,16 @@ impl<'a> Resolver<'a> {\n             hir::Path {\n                 span,\n                 def: Def::Err,\n-                segments: iter::once(keywords::CrateRoot.name()).chain({\n-                    path_str.split(\"::\").skip(1).map(Symbol::intern)\n-                }).map(hir::PathSegment::from_name).collect(),\n+                segments: iter::once(keywords::CrateRoot.ident()).chain({\n+                    path_str.split(\"::\").skip(1).map(Ident::from_str)\n+                }).map(hir::PathSegment::from_ident).collect(),\n             }\n         } else {\n             hir::Path {\n                 span,\n                 def: Def::Err,\n-                segments: path_str.split(\"::\").map(Symbol::intern)\n-                                  .map(hir::PathSegment::from_name).collect(),\n+                segments: path_str.split(\"::\").map(Ident::from_str)\n+                                  .map(hir::PathSegment::from_ident).collect(),\n             }\n         };\n         self.resolve_hir_path_cb(&mut path, is_value, |_, _, _| errored = true);\n@@ -1572,13 +1572,11 @@ impl<'a> Resolver<'a> {\n \n     /// resolve_hir_path, but takes a callback in case there was an error\n     fn resolve_hir_path_cb<F>(&mut self, path: &mut hir::Path, is_value: bool, error_callback: F)\n-            where F: for<'c, 'b> FnOnce(&'c mut Resolver, Span, ResolutionError<'b>)\n-        {\n+        where F: for<'c, 'b> FnOnce(&'c mut Resolver, Span, ResolutionError<'b>)\n+    {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let hir::Path { ref segments, span, ref mut def } = *path;\n-        let path: Vec<Ident> = segments.iter()\n-            .map(|seg| Ident::new(seg.name, span))\n-            .collect();\n+        let path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n         match self.resolve_path(&path, Some(namespace), true, span, CrateLint::No) {\n             PathResult::Module(module) => *def = module.def().unwrap(),"}, {"sha": "1954d81d3280421ffb7c2ad42a4930df37988dab", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -873,7 +873,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                      -> (Ty<'tcx>, Def)\n     {\n         let tcx = self.tcx();\n-        let assoc_name = item_segment.name.to_ident();\n+        let assoc_name = item_segment.ident;\n \n         debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n \n@@ -962,7 +962,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             self.report_ambiguous_associated_type(span,\n                                                   \"Type\",\n                                                   &path_str,\n-                                                  &item_segment.name.as_str());\n+                                                  &item_segment.ident.as_str());\n             return tcx.types.err;\n         };\n "}, {"sha": "2b619781119c52d3100c354ec6c2c6657286f0f8", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })), 1) = (self.tcx.hir.find(parent), decl.inputs.len()) {\n                         let self_ty = self.tables.borrow().node_id_to_type(expr[0].hir_id);\n                         let self_ty = format!(\"{:?}\", self_ty);\n-                        let name = path.name.as_str();\n+                        let name = path.ident.as_str();\n                         let is_as_ref_able = (\n                             self_ty.starts_with(\"&std::option::Option\") ||\n                             self_ty.starts_with(\"&std::result::Result\") ||"}, {"sha": "e160ceec1ee34181bc9107e3497eb54f4fd26f8e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          allow_private: bool)\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n-        match self.probe_for_name(method_name.span, mode, method_name.name,\n+        match self.probe_for_name(method_name.span, mode, method_name,\n                                   IsSuggestion(false), self_ty, call_expr_id,\n                                   ProbeScope::TraitsInScope) {\n             Ok(..) => true,\n@@ -157,14 +157,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          self_expr: &'gcx hir::Expr)\n                          -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n         debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n-               segment.name,\n+               segment.ident,\n                self_ty,\n                call_expr,\n                self_expr);\n \n         let pick = self.lookup_probe(\n             span,\n-            segment.name,\n+            segment.ident,\n             self_ty,\n             call_expr,\n             ProbeScope::TraitsInScope\n@@ -192,7 +192,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // We probe again, taking all traits into account (not only those in scope).\n             let candidates =\n                 match self.lookup_probe(span,\n-                                        segment.name,\n+                                        segment.ident,\n                                         self_ty,\n                                         call_expr,\n                                         ProbeScope::AllTraits) {\n@@ -222,7 +222,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn lookup_probe(&self,\n                     span: Span,\n-                    method_name: ast::Name,\n+                    method_name: ast::Ident,\n                     self_ty: Ty<'tcx>,\n                     call_expr: &'gcx hir::Expr,\n                     scope: ProbeScope)\n@@ -289,7 +289,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = self.associated_item(trait_def_id, m_name, Namespace::Value).unwrap();\n+        let method_item =\n+            self.associated_item(trait_def_id, m_name.to_ident(), Namespace::Value).unwrap();\n         let def_id = method_item.def_id;\n         let generics = tcx.generics_of(def_id);\n         assert_eq!(generics.params.len(), 0);\n@@ -362,7 +363,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn resolve_ufcs(&self,\n                         span: Span,\n-                        method_name: ast::Name,\n+                        method_name: ast::Ident,\n                         self_ty: Ty<'tcx>,\n                         expr_id: ast::NodeId)\n                         -> Result<Def, MethodError<'tcx>> {\n@@ -385,11 +386,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`\n     /// and return it, or `None`, if no such item was defined there.\n-    pub fn associated_item(&self, def_id: DefId, item_name: ast::Name, ns: Namespace)\n+    pub fn associated_item(&self, def_id: DefId, item_name: ast::Ident, ns: Namespace)\n                            -> Option<ty::AssociatedItem> {\n         self.tcx.associated_items(def_id).find(|item| {\n             Namespace::from(item.kind) == ns &&\n-            self.tcx.hygienic_eq(item_name.to_ident(), item.name.to_ident(), def_id)\n+            self.tcx.hygienic_eq(item_name, item.name.to_ident(), def_id)\n         })\n     }\n }"}, {"sha": "ccbc0f9cfe24d5b4bf520775d355cc33200505ed", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -47,7 +47,7 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n     mode: Mode,\n-    method_name: Option<ast::Name>,\n+    method_name: Option<ast::Ident>,\n     return_type: Option<Ty<'tcx>>,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn probe_for_name(&self,\n                           span: Span,\n                           mode: Mode,\n-                          item_name: ast::Name,\n+                          item_name: ast::Ident,\n                           is_suggestion: IsSuggestion,\n                           self_ty: Ty<'tcx>,\n                           scope_expr_id: ast::NodeId,\n@@ -237,7 +237,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn probe_op<OP,R>(&'a self,\n                       span: Span,\n                       mode: Mode,\n-                      method_name: Option<ast::Name>,\n+                      method_name: Option<ast::Ident>,\n                       return_type: Option<Ty<'tcx>>,\n                       is_suggestion: IsSuggestion,\n                       self_ty: Ty<'tcx>,\n@@ -382,7 +382,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            span: Span,\n            mode: Mode,\n-           method_name: Option<ast::Name>,\n+           method_name: Option<ast::Ident>,\n            return_type: Option<Ty<'tcx>>,\n            steps: Rc<Vec<CandidateStep<'tcx>>>,\n            is_suggestion: IsSuggestion)\n@@ -422,8 +422,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     {\n         let is_accessible = if let Some(name) = self.method_name {\n             let item = candidate.item;\n-            let def_scope =\n-                self.tcx.adjust_ident(name.to_ident(), item.container.id(), self.body_id).1;\n+            let def_scope = self.tcx.adjust_ident(name, item.container.id(), self.body_id).1;\n             item.vis.is_accessible_from(def_scope, self.tcx)\n         } else {\n             true\n@@ -799,7 +798,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    fn candidate_method_names(&self) -> Vec<ast::Name> {\n+    fn candidate_method_names(&self) -> Vec<ast::Ident> {\n         let mut set = FxHashSet();\n         let mut names: Vec<_> = self.inherent_candidates\n             .iter()\n@@ -811,7 +810,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     true\n                 }\n             })\n-            .map(|candidate| candidate.item.name)\n+            .map(|candidate| candidate.item.name.to_ident())\n             .filter(|&name| set.insert(name))\n             .collect();\n "}, {"sha": "f6c66a9a14aa8decf2ee08a32dc3d37186f4700c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_method_error(&self,\n                                span: Span,\n                                rcvr_ty: Ty<'tcx>,\n-                               item_name: ast::Name,\n+                               item_name: ast::Ident,\n                                rcvr_expr: Option<&hir::Expr>,\n                                error: MethodError<'tcx>,\n                                args: Option<&'gcx [hir::Expr]>) {\n@@ -340,8 +340,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         match ty.sty {\n                             ty::TyAdt(def, substs) if !def.is_enum() => {\n                                 let variant = &def.non_enum_variant();\n-                                if let Some(index) =\n-                                        self.tcx.find_field_index(item_name.to_ident(), variant) {\n+                                if let Some(index) = self.tcx.find_field_index(item_name, variant) {\n                                     let field = &variant.fields[index];\n                                     let snippet = tcx.sess.codemap().span_to_snippet(expr.span);\n                                     let expr_string = match snippet {\n@@ -393,7 +392,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             report_function!(expr.span, expr_string);\n                         } else if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = expr.node {\n                             if let Some(segment) = path.segments.last() {\n-                                report_function!(expr.span, segment.name);\n+                                report_function!(expr.span, segment.ident);\n                             }\n                         }\n                     }\n@@ -565,7 +564,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 err: &mut DiagnosticBuilder,\n                                 span: Span,\n                                 rcvr_ty: Ty<'tcx>,\n-                                item_name: ast::Name,\n+                                item_name: ast::Ident,\n                                 rcvr_expr: Option<&hir::Expr>,\n                                 valid_out_of_scope_traits: Vec<DefId>) {\n         if self.suggest_valid_traits(err, valid_out_of_scope_traits) {"}, {"sha": "0b590e1110f59e18e18c271433649020f6e8e56a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -3006,10 +3006,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Ok(method)\n             }\n             Err(error) => {\n-                if segment.name != keywords::Invalid.name() {\n+                if segment.ident.name != keywords::Invalid.name() {\n                     self.report_method_error(span,\n                                              rcvr_t,\n-                                             segment.name,\n+                                             segment.ident,\n                                              Some(rcvr),\n                                              error,\n                                              Some(args));\n@@ -4254,15 +4254,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // errors with default match binding modes. See #44614.\n             return (*cached_def, Some(ty), slice::from_ref(&**item_segment))\n         }\n-        let item_name = item_segment.name;\n+        let item_name = item_segment.ident;\n         let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n             Ok(def) => def,\n             Err(error) => {\n                 let def = match error {\n                     method::MethodError::PrivateMatch(def, _) => def,\n                     _ => Def::Err,\n                 };\n-                if item_name != keywords::Invalid.name() {\n+                if item_name.name != keywords::Invalid.name() {\n                     self.report_method_error(span, ty, item_name, None, error, None);\n                 }\n                 def"}, {"sha": "35483e33c474fe282752138d7959449ad2eef552", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -200,10 +200,10 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             let mut segments = path.segments.into_vec();\n             let last = segments.pop().unwrap();\n \n-            let real_name = name.map(|name| Symbol::intern(&name));\n+            let real_name = name.map(|name| Ident::from_str(&name));\n \n             segments.push(hir::PathSegment::new(\n-                real_name.unwrap_or(last.name),\n+                real_name.unwrap_or(last.ident),\n                 self.generics_to_path_params(generics.clone()),\n                 false,\n             ));\n@@ -285,7 +285,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                     span: DUMMY_SP,\n                     def: Def::TyParam(param.def_id),\n                     segments: HirVec::from_vec(vec![\n-                        hir::PathSegment::from_name(param.name.as_symbol())\n+                        hir::PathSegment::from_ident(Ident::from_interned_str(param.name))\n                     ]),\n                 }),\n             )),"}, {"sha": "664a603920cb4f31f1568fd8114b988b696794c6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e8215a4f6f7b32d0f068e72ab9a9c9f85bab0cdb", "patch": "@@ -2949,7 +2949,7 @@ impl Clean<Type> for hir::Ty {\n                     segments: segments.into(),\n                 };\n                 Type::QPath {\n-                    name: p.segments.last().unwrap().name.clean(cx),\n+                    name: p.segments.last().unwrap().ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n@@ -2966,7 +2966,7 @@ impl Clean<Type> for hir::Ty {\n                     segments: vec![].into(),\n                 };\n                 Type::QPath {\n-                    name: segment.name.clean(cx),\n+                    name: segment.ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n@@ -3575,7 +3575,7 @@ pub struct PathSegment {\n impl Clean<PathSegment> for hir::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n-            name: self.name.clean(cx),\n+            name: self.ident.name.clean(cx),\n             args: self.with_generic_args(|generic_args| generic_args.clean(cx))\n         }\n     }\n@@ -3628,16 +3628,16 @@ fn strip_path(path: &Path) -> Path {\n fn qpath_to_string(p: &hir::QPath) -> String {\n     let segments = match *p {\n         hir::QPath::Resolved(_, ref path) => &path.segments,\n-        hir::QPath::TypeRelative(_, ref segment) => return segment.name.to_string(),\n+        hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n     };\n \n     let mut s = String::new();\n     for (i, seg) in segments.iter().enumerate() {\n         if i > 0 {\n             s.push_str(\"::\");\n         }\n-        if seg.name != keywords::CrateRoot.name() {\n-            s.push_str(&*seg.name.as_str());\n+        if seg.ident.name != keywords::CrateRoot.name() {\n+            s.push_str(&*seg.ident.as_str());\n         }\n     }\n     s\n@@ -4427,7 +4427,7 @@ where F: Fn(DefId) -> Def {\n         span: DUMMY_SP,\n         def: def_ctor(def_id),\n         segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n-            name: ast::Name::intern(&s),\n+            ident: ast::Ident::from_str(&s),\n             args: None,\n             infer_types: false,\n         }).collect())"}]}