{"sha": "af9b9e4ec874c4bc5c771841d491e02d02d5636a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmOWI5ZTRlYzg3NGM0YmM1Yzc3MTg0MWQ0OTFlMDJkMDJkNTYzNmE=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-08-15T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-08-14T23:24:18Z"}, "message": "MatchBranchSimplification: avoid intermediate vec allocation", "tree": {"sha": "fd0708188892cfd909db19022b39c5952a755144", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd0708188892cfd909db19022b39c5952a755144"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af9b9e4ec874c4bc5c771841d491e02d02d5636a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af9b9e4ec874c4bc5c771841d491e02d02d5636a", "html_url": "https://github.com/rust-lang/rust/commit/af9b9e4ec874c4bc5c771841d491e02d02d5636a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af9b9e4ec874c4bc5c771841d491e02d02d5636a/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fe2e2941d93da397c8ace5f410c0ab3dc5a3049", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe2e2941d93da397c8ace5f410c0ab3dc5a3049", "html_url": "https://github.com/rust-lang/rust/commit/1fe2e2941d93da397c8ace5f410c0ab3dc5a3049"}], "stats": {"total": 84, "additions": 46, "deletions": 38}, "files": [{"sha": "c24f25d652be9b794a243a793cc33a14b61d3756", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af9b9e4ec874c4bc5c771841d491e02d02d5636a/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af9b9e4ec874c4bc5c771841d491e02d02d5636a/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=af9b9e4ec874c4bc5c771841d491e02d02d5636a", "patch": "@@ -669,6 +669,17 @@ impl<I: Idx, T> IndexVec<I, T> {\n         }\n     }\n \n+    /// Returns mutable references to three distinct elements or panics otherwise.\n+    #[inline]\n+    pub fn pick3_mut(&mut self, a: I, b: I, c: I) -> (&mut T, &mut T, &mut T) {\n+        let (ai, bi, ci) = (a.index(), b.index(), c.index());\n+        assert!(ai != bi && bi != ci && ci != ai);\n+        let len = self.raw.len();\n+        assert!(ai < len && bi < len && ci < len);\n+        let ptr = self.raw.as_mut_ptr();\n+        unsafe { (&mut *ptr.add(ai), &mut *ptr.add(bi), &mut *ptr.add(ci)) }\n+    }\n+\n     pub fn convert_index_type<Ix: Idx>(self) -> IndexVec<Ix, T> {\n         IndexVec { raw: self.raw, _marker: PhantomData }\n     }"}, {"sha": "c1d574d6ef290fbfb24c1ee779fba7af69657028", "filename": "src/librustc_mir/transform/match_branches.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/af9b9e4ec874c4bc5c771841d491e02d02d5636a/src%2Flibrustc_mir%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af9b9e4ec874c4bc5c771841d491e02d02d5636a/src%2Flibrustc_mir%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmatch_branches.rs?ref=af9b9e4ec874c4bc5c771841d491e02d02d5636a", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                     ref targets,\n                     ref values,\n                     ..\n-                } if targets.len() == 2 && values.len() == 1 => {\n+                } if targets.len() == 2 && values.len() == 1 && targets[0] != targets[1] => {\n                     (place, values[0], switch_ty, targets[0], targets[1])\n                 }\n                 // Only optimize switch int statements\n@@ -89,48 +89,45 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n             // Take ownership of items now that we know we can optimize.\n             let discr = discr.clone();\n \n-            let new_stmts = first_stmts\n-                .iter()\n-                .zip(scnd_stmts.iter())\n-                .map(|(f, s)| {\n-                    match (&f.kind, &s.kind) {\n-                        (f_s, s_s) if f_s == s_s => (*f).clone(),\n+            // We already checked that first and second are different blocks,\n+            // and bb_idx has a different terminator from both of them.\n+            let (from, first, second) = bbs.pick3_mut(bb_idx, first, second);\n \n-                        (\n-                            StatementKind::Assign(box (lhs, Rvalue::Use(Operand::Constant(f_c)))),\n-                            StatementKind::Assign(box (_, Rvalue::Use(Operand::Constant(s_c)))),\n-                        ) => {\n-                            // From earlier loop we know that we are dealing with bool constants only:\n-                            let f_b = f_c.literal.try_eval_bool(tcx, param_env).unwrap();\n-                            let s_b = s_c.literal.try_eval_bool(tcx, param_env).unwrap();\n-                            if f_b == s_b {\n-                                // Same value in both blocks. Use statement as is.\n-                                (*f).clone()\n-                            } else {\n-                                // Different value between blocks. Make value conditional on switch condition.\n-                                let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n-                                let const_cmp = Operand::const_from_scalar(\n-                                    tcx,\n-                                    switch_ty,\n-                                    crate::interpret::Scalar::from_uint(val, size),\n-                                    rustc_span::DUMMY_SP,\n-                                );\n-                                let op = if f_b { BinOp::Eq } else { BinOp::Ne };\n-                                let rhs =\n-                                    Rvalue::BinaryOp(op, Operand::Copy(discr.clone()), const_cmp);\n-                                Statement {\n-                                    source_info: f.source_info,\n-                                    kind: StatementKind::Assign(box (*lhs, rhs)),\n-                                }\n+            let new_stmts = first.statements.iter().zip(second.statements.iter()).map(|(f, s)| {\n+                match (&f.kind, &s.kind) {\n+                    (f_s, s_s) if f_s == s_s => (*f).clone(),\n+\n+                    (\n+                        StatementKind::Assign(box (lhs, Rvalue::Use(Operand::Constant(f_c)))),\n+                        StatementKind::Assign(box (_, Rvalue::Use(Operand::Constant(s_c)))),\n+                    ) => {\n+                        // From earlier loop we know that we are dealing with bool constants only:\n+                        let f_b = f_c.literal.try_eval_bool(tcx, param_env).unwrap();\n+                        let s_b = s_c.literal.try_eval_bool(tcx, param_env).unwrap();\n+                        if f_b == s_b {\n+                            // Same value in both blocks. Use statement as is.\n+                            (*f).clone()\n+                        } else {\n+                            // Different value between blocks. Make value conditional on switch condition.\n+                            let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n+                            let const_cmp = Operand::const_from_scalar(\n+                                tcx,\n+                                switch_ty,\n+                                crate::interpret::Scalar::from_uint(val, size),\n+                                rustc_span::DUMMY_SP,\n+                            );\n+                            let op = if f_b { BinOp::Eq } else { BinOp::Ne };\n+                            let rhs = Rvalue::BinaryOp(op, Operand::Copy(discr.clone()), const_cmp);\n+                            Statement {\n+                                source_info: f.source_info,\n+                                kind: StatementKind::Assign(box (*lhs, rhs)),\n                             }\n                         }\n-\n-                        _ => unreachable!(),\n                     }\n-                })\n-                .collect::<Vec<_>>();\n \n-            let (from, first) = bbs.pick2_mut(bb_idx, first);\n+                    _ => unreachable!(),\n+                }\n+            });\n             from.statements.extend(new_stmts);\n             from.terminator_mut().kind = first.terminator().kind.clone();\n         }"}]}