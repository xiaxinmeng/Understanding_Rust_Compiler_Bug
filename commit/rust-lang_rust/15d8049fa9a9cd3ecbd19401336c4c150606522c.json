{"sha": "15d8049fa9a9cd3ecbd19401336c4c150606522c", "node_id": "C_kwDOAAsO6NoAKDE1ZDgwNDlmYTlhOWNkM2VjYmQxOTQwMTMzNmM0YzE1MDYwNjUyMmM", "commit": {"author": {"name": "Dorian Scheidt", "email": "dorian.scheidt@gmail.com", "date": "2022-07-20T17:26:27Z"}, "committer": {"name": "Dorian Scheidt", "email": "dorian.scheidt@gmail.com", "date": "2022-08-02T18:37:12Z"}, "message": "Support tuple fields in generate_enum_variant", "tree": {"sha": "30c3994749617c76e3ef89591df37faf63aa2100", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30c3994749617c76e3ef89591df37faf63aa2100"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15d8049fa9a9cd3ecbd19401336c4c150606522c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15d8049fa9a9cd3ecbd19401336c4c150606522c", "html_url": "https://github.com/rust-lang/rust/commit/15d8049fa9a9cd3ecbd19401336c4c150606522c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15d8049fa9a9cd3ecbd19401336c4c150606522c/comments", "author": {"login": "DorianListens", "id": 5692947, "node_id": "MDQ6VXNlcjU2OTI5NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5692947?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DorianListens", "html_url": "https://github.com/DorianListens", "followers_url": "https://api.github.com/users/DorianListens/followers", "following_url": "https://api.github.com/users/DorianListens/following{/other_user}", "gists_url": "https://api.github.com/users/DorianListens/gists{/gist_id}", "starred_url": "https://api.github.com/users/DorianListens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DorianListens/subscriptions", "organizations_url": "https://api.github.com/users/DorianListens/orgs", "repos_url": "https://api.github.com/users/DorianListens/repos", "events_url": "https://api.github.com/users/DorianListens/events{/privacy}", "received_events_url": "https://api.github.com/users/DorianListens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DorianListens", "id": 5692947, "node_id": "MDQ6VXNlcjU2OTI5NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5692947?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DorianListens", "html_url": "https://github.com/DorianListens", "followers_url": "https://api.github.com/users/DorianListens/followers", "following_url": "https://api.github.com/users/DorianListens/following{/other_user}", "gists_url": "https://api.github.com/users/DorianListens/gists{/gist_id}", "starred_url": "https://api.github.com/users/DorianListens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DorianListens/subscriptions", "organizations_url": "https://api.github.com/users/DorianListens/orgs", "repos_url": "https://api.github.com/users/DorianListens/repos", "events_url": "https://api.github.com/users/DorianListens/events{/privacy}", "received_events_url": "https://api.github.com/users/DorianListens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bea1fec7a2c949d6470f2182d34c5b349605f7a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bea1fec7a2c949d6470f2182d34c5b349605f7a1", "html_url": "https://github.com/rust-lang/rust/commit/bea1fec7a2c949d6470f2182d34c5b349605f7a1"}], "stats": {"total": 115, "additions": 111, "deletions": 4}, "files": [{"sha": "f671877e521785caacea6f03c1c11d7af90af370", "filename": "crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "modified", "additions": 111, "deletions": 4, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/15d8049fa9a9cd3ecbd19401336c4c150606522c/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d8049fa9a9cd3ecbd19401336c4c150606522c/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=15d8049fa9a9cd3ecbd19401336c4c150606522c", "patch": "@@ -1,7 +1,7 @@\n-use hir::{HasSource, InFile};\n+use hir::{HasSource, HirDisplay, InFile};\n use ide_db::assists::{AssistId, AssistKind};\n use syntax::{\n-    ast::{self, make},\n+    ast::{self, make, HasArgList},\n     AstNode,\n };\n \n@@ -50,7 +50,7 @@ pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>)\n         ctx.sema.resolve_path(&path.qualifier()?)\n     {\n         let target = path.syntax().text_range();\n-        return add_variant_to_accumulator(acc, ctx, target, e, &name_ref);\n+        return add_variant_to_accumulator(acc, ctx, target, e, &name_ref, &path);\n     }\n \n     None\n@@ -62,23 +62,65 @@ fn add_variant_to_accumulator(\n     target: syntax::TextRange,\n     adt: hir::Enum,\n     name_ref: &ast::NameRef,\n+    path: &ast::Path,\n ) -> Option<()> {\n     let db = ctx.db();\n     let InFile { file_id, value: enum_node } = adt.source(db)?.original_ast_node(db)?;\n \n-    let variant = make::variant(make::name(&name_ref.text()), None);\n     acc.add(\n         AssistId(\"generate_enum_variant\", AssistKind::Generate),\n         \"Generate variant\",\n         target,\n         |builder| {\n             builder.edit_file(file_id.original_file(db));\n             let node = builder.make_mut(enum_node);\n+            let variant = make_variant(ctx, name_ref, &path);\n             node.variant_list().map(|it| it.add_variant(variant.clone_for_update()));\n         },\n     )\n }\n \n+fn make_variant(\n+    ctx: &AssistContext<'_>,\n+    name_ref: &ast::NameRef,\n+    path: &ast::Path,\n+) -> ast::Variant {\n+    let field_list = make_field_list(ctx, path);\n+    make::variant(make::name(&name_ref.text()), field_list)\n+}\n+\n+fn make_field_list(ctx: &AssistContext<'_>, path: &ast::Path) -> Option<ast::FieldList> {\n+    let scope = ctx.sema.scope(&path.syntax())?;\n+    if let Some(call_expr) =\n+        path.syntax().parent().and_then(|it| it.parent()).and_then(ast::CallExpr::cast)\n+    {\n+        make_tuple_field_list(call_expr, ctx, &scope)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn make_tuple_field_list(\n+    call_expr: ast::CallExpr,\n+    ctx: &AssistContext<'_>,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::FieldList> {\n+    let args = call_expr.arg_list()?.args();\n+    let tuple_fields = args.map(|arg| {\n+        let ty = expr_ty(ctx, arg, &scope);\n+        make::tuple_field(None, ty)\n+    });\n+    Some(make::tuple_field_list(tuple_fields).into())\n+}\n+\n+fn expr_ty(ctx: &AssistContext<'_>, arg: ast::Expr, scope: &hir::SemanticsScope<'_>) -> ast::Type {\n+    let ty = ctx.sema.type_of_expr(&arg).map(|it| it.adjusted());\n+    let text = ty\n+        .and_then(|it| it.display_source_code(ctx.db(), scope.module().into()).ok())\n+        .unwrap_or_else(|| \"_\".to_string());\n+    make::ty(&text)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -211,6 +253,71 @@ mod m {\n fn main() {\n     m::Foo::Baz\n }\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_single_element_tuple() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(true)\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar(bool),\n+}\n+fn main() {\n+    Foo::Bar(true)\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_single_element_tuple_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(x)\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar(_),\n+}\n+fn main() {\n+    Foo::Bar(x)\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_multi_element_tuple() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+struct Struct {}\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(true, x, Struct {})\n+}\n+\",\n+            r\"\n+struct Struct {}\n+enum Foo {\n+    Bar(bool, _, Struct),\n+}\n+fn main() {\n+    Foo::Bar(true, x, Struct {})\n+}\n \",\n         )\n     }"}]}