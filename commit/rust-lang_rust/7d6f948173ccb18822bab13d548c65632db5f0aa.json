{"sha": "7d6f948173ccb18822bab13d548c65632db5f0aa", "node_id": "C_kwDOAAsO6NoAKDdkNmY5NDgxNzNjY2IxODgyMmJhYjEzZDU0OGM2NTYzMmRiNWYwYWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-04T19:56:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-04T19:56:13Z"}, "message": "Auto merge of #92556 - matthiaskrgr:rollup-s9vopuj, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #91754 (Modifications to `std::io::Stdin` on Windows so that there is no longer a 4-byte buffer minimum in read().)\n - #91884 (Constify `Box<T, A>` methods)\n - #92107 (Actually set IMAGE_SCN_LNK_REMOVE for .rmeta)\n - #92456 (Make the documentation of builtin macro attributes accessible)\n - #92507 (Suggest single quotes when char expected, str provided)\n - #92525 (intra-doc: Make `Receiver::into_iter` into a clickable link)\n - #92532 (revert #92254 \"Bump gsgdt to 0.1.3\")\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0c6d6e241b150691b700e05281607dfd6f649d22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c6d6e241b150691b700e05281607dfd6f649d22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d6f948173ccb18822bab13d548c65632db5f0aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d6f948173ccb18822bab13d548c65632db5f0aa", "html_url": "https://github.com/rust-lang/rust/commit/7d6f948173ccb18822bab13d548c65632db5f0aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d6f948173ccb18822bab13d548c65632db5f0aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b681ac06b1a6b7ea39525e59363ffee0d1a68e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b681ac06b1a6b7ea39525e59363ffee0d1a68e5", "html_url": "https://github.com/rust-lang/rust/commit/2b681ac06b1a6b7ea39525e59363ffee0d1a68e5"}, {"sha": "76c02711a5e30c71c3f4ff8bf0314578cf8b3256", "url": "https://api.github.com/repos/rust-lang/rust/commits/76c02711a5e30c71c3f4ff8bf0314578cf8b3256", "html_url": "https://github.com/rust-lang/rust/commit/76c02711a5e30c71c3f4ff8bf0314578cf8b3256"}], "stats": {"total": 544, "additions": 458, "deletions": 86}, "files": [{"sha": "1fe03a06c797450c2b2e14e777f3b8e819e4bcd9", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -1505,9 +1505,9 @@ dependencies = [\n \n [[package]]\n name = \"gsgdt\"\n-version = \"0.1.3\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cb958139bb971f37d2f5423436f137768f88b9c616b4c21d4f634dd129508d60\"\n+checksum = \"a0d876ce7262df96262a2a19531da6ff9a86048224d49580a585fc5c04617825\"\n dependencies = [\n  \"serde\",\n ]"}, {"sha": "79c24f0f17280ac73821d47a532f467fa5cf5656", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -6,8 +6,8 @@ use std::path::Path;\n \n use object::write::{self, StandardSegment, Symbol, SymbolSection};\n use object::{\n-    elf, Architecture, BinaryFormat, Endianness, FileFlags, Object, ObjectSection, SectionFlags,\n-    SectionKind, SymbolFlags, SymbolKind, SymbolScope,\n+    elf, pe, Architecture, BinaryFormat, Endianness, FileFlags, Object, ObjectSection,\n+    SectionFlags, SectionKind, SymbolFlags, SymbolKind, SymbolScope,\n };\n \n use snap::write::FrameEncoder;\n@@ -216,13 +216,12 @@ pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> Vec<u8> {\n     );\n     match file.format() {\n         BinaryFormat::Coff => {\n-            const IMAGE_SCN_LNK_REMOVE: u32 = 0;\n             file.section_mut(section).flags =\n-                SectionFlags::Coff { characteristics: IMAGE_SCN_LNK_REMOVE };\n+                SectionFlags::Coff { characteristics: pe::IMAGE_SCN_LNK_REMOVE };\n         }\n         BinaryFormat::Elf => {\n-            const SHF_EXCLUDE: u64 = 0x80000000;\n-            file.section_mut(section).flags = SectionFlags::Elf { sh_flags: SHF_EXCLUDE };\n+            file.section_mut(section).flags =\n+                SectionFlags::Elf { sh_flags: elf::SHF_EXCLUDE as u64 };\n         }\n         _ => {}\n     };"}, {"sha": "f0c73d0c2f3691f5e8983488bccdbf3bfb3ac8de", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -2041,11 +2041,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if let ValuePairs::Types(ty::error::ExpectedFound { expected, found }) =\n                     trace.values\n                 {\n-                    // If a tuple of length one was expected and the found expression has\n-                    // parentheses around it, perhaps the user meant to write `(expr,)` to\n-                    // build a tuple (issue #86100)\n                     match (expected.kind(), found.kind()) {\n                         (ty::Tuple(_), ty::Tuple(_)) => {}\n+                        // If a tuple of length one was expected and the found expression has\n+                        // parentheses around it, perhaps the user meant to write `(expr,)` to\n+                        // build a tuple (issue #86100)\n                         (ty::Tuple(_), _) if expected.tuple_fields().count() == 1 => {\n                             if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n                                 if let Some(code) =\n@@ -2060,6 +2060,41 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 }\n                             }\n                         }\n+                        // If a character was expected and the found expression is a string literal\n+                        // containing a single character, perhaps the user meant to write `'c'` to\n+                        // specify a character literal (issue #92479)\n+                        (ty::Char, ty::Ref(_, r, _)) if r.is_str() => {\n+                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n+                                if let Some(code) =\n+                                    code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n+                                {\n+                                    if code.chars().nth(1).is_none() {\n+                                        err.span_suggestion(\n+                                            span,\n+                                            \"if you meant to write a `char` literal, use single quotes\",\n+                                            format!(\"'{}'\", code),\n+                                            Applicability::MachineApplicable,\n+                                        );\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        // If a string was expected and the found expression is a character literal,\n+                        // perhaps the user meant to write `\"s\"` to specify a string literal.\n+                        (ty::Ref(_, r, _), ty::Char) if r.is_str() => {\n+                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n+                                if let Some(code) =\n+                                    code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n+                                {\n+                                    err.span_suggestion(\n+                                        span,\n+                                        \"if you meant to write a `str` literal, use double quotes\",\n+                                        format!(\"\\\"{}\\\"\", code),\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                }\n+                            }\n+                        }\n                         _ => {}\n                     }\n                 }"}, {"sha": "a9db8469384ed9b34ee081975bd9521414b71e3d", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -10,7 +10,7 @@ doctest = false\n rustc_arena = { path = \"../rustc_arena\" }\n bitflags = \"1.2.1\"\n either = \"1.5.0\"\n-gsgdt = \"0.1.3\"\n+gsgdt = \"0.1.2\"\n tracing = \"0.1\"\n rustc-rayon = \"0.3.1\"\n rustc-rayon-core = \"0.3.1\""}, {"sha": "770b52a4d4b0fbb3ffc26e9bdf3030b23e2d7e4c", "filename": "compiler/rustc_middle/src/mir/generic_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgeneric_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgeneric_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgeneric_graph.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -55,7 +55,7 @@ fn bb_to_graph_node(block: BasicBlock, body: &Body<'_>, dark_mode: bool) -> Node\n     data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n     stmts.push(terminator_head);\n \n-    Node::from_list(stmts, label, title, style)\n+    Node::new(stmts, label, title, style)\n }\n \n // Must match `[0-9A-Za-z_]*`. This does not appear in the rendered graph, so"}, {"sha": "d075658f51a3e7b3fb7c46df8619787e77b6b68b", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -323,17 +323,21 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n \n #[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n // This signature has to be the same as `Box`, otherwise an ICE will happen.\n // When an additional parameter to `Box` is added (like `A: Allocator`), this has to be added here as\n // well.\n // For example if `Box` is changed to  `struct Box<T: ?Sized, A: Allocator>(Unique<T>, A)`,\n // this function has to be changed to `fn box_free<T: ?Sized, A: Allocator>(Unique<T>, A)` as well.\n-pub(crate) unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A) {\n+pub(crate) const unsafe fn box_free<T: ?Sized, A: ~const Allocator + ~const Drop>(\n+    ptr: Unique<T>,\n+    alloc: A,\n+) {\n     unsafe {\n         let size = size_of_val(ptr.as_ref());\n         let align = min_align_of_val(ptr.as_ref());\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        alloc.deallocate(ptr.cast().into(), layout)\n+        alloc.deallocate(From::from(ptr.cast()), layout)\n     }\n }\n \n@@ -361,13 +365,22 @@ extern \"Rust\" {\n /// [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n /// [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[rustc_const_unstable(feature = \"const_alloc_error\", issue = \"92523\")]\n #[cfg(all(not(no_global_oom_handling), not(test)))]\n #[rustc_allocator_nounwind]\n #[cold]\n-pub fn handle_alloc_error(layout: Layout) -> ! {\n-    unsafe {\n-        __rust_alloc_error_handler(layout.size(), layout.align());\n+pub const fn handle_alloc_error(layout: Layout) -> ! {\n+    const fn ct_error(_: Layout) -> ! {\n+        panic!(\"allocation failed\");\n     }\n+\n+    fn rt_error(layout: Layout) -> ! {\n+        unsafe {\n+            __rust_alloc_error_handler(layout.size(), layout.align());\n+        }\n+    }\n+\n+    unsafe { core::intrinsics::const_eval_select((layout,), ct_error, rt_error) }\n }\n \n // For alloc test `std::alloc::handle_alloc_error` can be used directly."}, {"sha": "aa7344ba405a988c31598701bcf7759940ea1e2f", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 68, "deletions": 24, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -346,9 +346,13 @@ impl<T, A: Allocator> Box<T, A> {\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[must_use]\n     #[inline]\n-    pub fn new_in(x: T, alloc: A) -> Self {\n+    pub const fn new_in(x: T, alloc: A) -> Self\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let mut boxed = Self::new_uninit_in(alloc);\n         unsafe {\n             boxed.as_mut_ptr().write(x);\n@@ -372,8 +376,13 @@ impl<T, A: Allocator> Box<T, A> {\n     /// # Ok::<(), std::alloc::AllocError>(())\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError> {\n+    pub const fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>\n+    where\n+        T: ~const Drop,\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let mut boxed = Self::try_new_uninit_in(alloc)?;\n         unsafe {\n             boxed.as_mut_ptr().write(x);\n@@ -402,10 +411,14 @@ impl<T, A: Allocator> Box<T, A> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[cfg(not(no_global_oom_handling))]\n     #[must_use]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n+    pub const fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n         // That would make code size bigger.\n@@ -439,7 +452,11 @@ impl<T, A: Allocator> Box<T, A> {\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+    pub const fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         let ptr = alloc.allocate(layout)?.cast();\n         unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n@@ -466,10 +483,14 @@ impl<T, A: Allocator> Box<T, A> {\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[cfg(not(no_global_oom_handling))]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[must_use]\n-    pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n+    pub const fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n         // That would make code size bigger.\n@@ -503,7 +524,11 @@ impl<T, A: Allocator> Box<T, A> {\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    pub fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+    pub const fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         let ptr = alloc.allocate_zeroed(layout)?.cast();\n         unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n@@ -513,20 +538,22 @@ impl<T, A: Allocator> Box<T, A> {\n     /// `x` will be pinned in memory and unable to be moved.\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[must_use]\n     #[inline(always)]\n-    pub fn pin_in(x: T, alloc: A) -> Pin<Self>\n+    pub const fn pin_in(x: T, alloc: A) -> Pin<Self>\n     where\n-        A: 'static,\n+        A: 'static + ~const Allocator + ~const Drop,\n     {\n-        Self::new_in(x, alloc).into()\n+        Self::into_pin(Self::new_in(x, alloc))\n     }\n \n     /// Converts a `Box<T>` into a `Box<[T]>`\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n     #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n-    pub fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+    pub const fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n         let (raw, alloc) = Box::into_raw_with_allocator(boxed);\n         unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }\n     }\n@@ -543,8 +570,12 @@ impl<T, A: Allocator> Box<T, A> {\n     /// assert_eq!(Box::into_inner(c), 5);\n     /// ```\n     #[unstable(feature = \"box_into_inner\", issue = \"80437\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn into_inner(boxed: Self) -> T {\n+    pub const fn into_inner(boxed: Self) -> T\n+    where\n+        Self: ~const Drop,\n+    {\n         *boxed\n     }\n }\n@@ -758,8 +789,9 @@ impl<T, A: Allocator> Box<mem::MaybeUninit<T>, A> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub unsafe fn assume_init(self) -> Box<T, A> {\n+    pub const unsafe fn assume_init(self) -> Box<T, A> {\n         let (raw, alloc) = Box::into_raw_with_allocator(self);\n         unsafe { Box::from_raw_in(raw as *mut T, alloc) }\n     }\n@@ -792,8 +824,9 @@ impl<T, A: Allocator> Box<mem::MaybeUninit<T>, A> {\n     /// }\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn write(mut boxed: Self, value: T) -> Box<T, A> {\n+    pub const fn write(mut boxed: Self, value: T) -> Box<T, A> {\n         unsafe {\n             (*boxed).write(value);\n             boxed.assume_init()\n@@ -938,8 +971,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// [memory layout]: self#memory-layout\n     /// [`Layout`]: crate::Layout\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {\n+    pub const unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {\n         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n     }\n \n@@ -1035,8 +1069,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     ///\n     /// [memory layout]: self#memory-layout\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn into_raw_with_allocator(b: Self) -> (*mut T, A) {\n+    pub const fn into_raw_with_allocator(b: Self) -> (*mut T, A) {\n         let (leaked, alloc) = Box::into_unique(b);\n         (leaked.as_ptr(), alloc)\n     }\n@@ -1046,9 +1081,10 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n         issue = \"none\",\n         reason = \"use `Box::leak(b).into()` or `Unique::from(Box::leak(b))` instead\"\n     )]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n     #[doc(hidden)]\n-    pub fn into_unique(b: Self) -> (Unique<T>, A) {\n+    pub const fn into_unique(b: Self) -> (Unique<T>, A) {\n         // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n         // raw pointer for the type system. Turning it directly into a raw pointer would not be\n         // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n@@ -1064,8 +1100,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// to call it as `Box::allocator(&b)` instead of `b.allocator()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn allocator(b: &Self) -> &A {\n+    pub const fn allocator(b: &Self) -> &A {\n         &b.1\n     }\n \n@@ -1105,8 +1142,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// assert_eq!(*static_ref, [4, 2, 3]);\n     /// ```\n     #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn leak<'a>(b: Self) -> &'a mut T\n+    pub const fn leak<'a>(b: Self) -> &'a mut T\n     where\n         A: 'a,\n     {\n@@ -1119,7 +1157,8 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     ///\n     /// This is also available via [`From`].\n     #[unstable(feature = \"box_into_pin\", issue = \"62370\")]\n-    pub fn into_pin(boxed: Self) -> Pin<Self>\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+    pub const fn into_pin(boxed: Self) -> Pin<Self>\n     where\n         A: 'static,\n     {\n@@ -1131,7 +1170,8 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> const Drop for Box<T, A> {\n     fn drop(&mut self) {\n         // FIXME: Do nothing, drop is currently performed by compiler.\n     }\n@@ -1341,7 +1381,8 @@ impl<T> From<T> for Box<T> {\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized, A: Allocator> From<Box<T, A>> for Pin<Box<T, A>>\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+impl<T: ?Sized, A: Allocator> const From<Box<T, A>> for Pin<Box<T, A>>\n where\n     A: 'static,\n {\n@@ -1720,7 +1761,8 @@ impl<T: ?Sized, A: Allocator> fmt::Pointer for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+impl<T: ?Sized, A: Allocator> const Deref for Box<T, A> {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n@@ -1729,7 +1771,8 @@ impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, A: Allocator> DerefMut for Box<T, A> {\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+impl<T: ?Sized, A: Allocator> const DerefMut for Box<T, A> {\n     fn deref_mut(&mut self) -> &mut T {\n         &mut **self\n     }\n@@ -1908,7 +1951,8 @@ impl<T: ?Sized, A: Allocator> AsMut<T> for Box<T, A> {\n  *  could have a method to project a Pin<T> from it.\n  */\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized, A: Allocator> Unpin for Box<T, A> where A: 'static {}\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+impl<T: ?Sized, A: Allocator> const Unpin for Box<T, A> where A: 'static {}\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator<R> + Unpin, R, A: Allocator> Generator<R> for Box<G, A>"}, {"sha": "7e663fab16af544dbbffdbe8e9c17a41560715db", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -96,9 +96,20 @@\n #![feature(array_windows)]\n #![feature(async_stream)]\n #![feature(coerce_unsized)]\n+#![cfg_attr(not(no_global_oom_handling), feature(const_alloc_error))]\n+#![feature(const_box)]\n #![cfg_attr(not(no_global_oom_handling), feature(const_btree_new))]\n #![feature(const_cow_is_borrowed)]\n+#![feature(const_convert)]\n+#![feature(const_size_of_val)]\n+#![feature(const_align_of_val)]\n+#![feature(const_ptr_read)]\n+#![feature(const_maybe_uninit_write)]\n+#![feature(const_maybe_uninit_as_mut_ptr)]\n+#![feature(const_refs_to_cell)]\n #![feature(core_intrinsics)]\n+#![feature(const_eval_select)]\n+#![feature(const_pin)]\n #![feature(dispatch_from_dyn)]\n #![feature(exact_size_is_empty)]\n #![feature(extend_one)]\n@@ -134,8 +145,13 @@\n #![feature(box_syntax)]\n #![feature(cfg_sanitize)]\n #![feature(cfg_target_has_atomic)]\n+#![feature(const_deref)]\n #![feature(const_fn_trait_bound)]\n+#![feature(const_mut_refs)]\n+#![feature(const_ptr_write)]\n+#![feature(const_precise_live_drops)]\n #![feature(const_trait_impl)]\n+#![feature(const_try)]\n #![cfg_attr(bootstrap, feature(destructuring_assignment))]\n #![feature(dropck_eyepatch)]\n #![feature(exclusive_range_pattern)]"}, {"sha": "0d7acfed8c6a1b36f0354714fa375f9de8efd9b4", "filename": "library/alloc/tests/boxed.rs", "status": "modified", "additions": 111, "deletions": 3, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Falloc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Falloc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fboxed.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -1,6 +1,7 @@\n-use std::cell::Cell;\n-use std::mem::MaybeUninit;\n-use std::ptr::NonNull;\n+use core::alloc::{AllocError, Allocator, Layout};\n+use core::cell::Cell;\n+use core::mem::MaybeUninit;\n+use core::ptr::NonNull;\n \n #[test]\n fn uninitialized_zero_size_box() {\n@@ -57,3 +58,110 @@ fn box_deref_lval() {\n     x.set(1000);\n     assert_eq!(x.get(), 1000);\n }\n+\n+pub struct ConstAllocator;\n+\n+unsafe impl const Allocator for ConstAllocator {\n+    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        match layout.size() {\n+            0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n+            _ => unsafe {\n+                let ptr = core::intrinsics::const_allocate(layout.size(), layout.align());\n+                Ok(NonNull::new_unchecked(ptr as *mut [u8; 0] as *mut [u8]))\n+            },\n+        }\n+    }\n+\n+    unsafe fn deallocate(&self, _ptr: NonNull<u8>, layout: Layout) {\n+        match layout.size() {\n+            0 => { /* do nothing */ }\n+            _ => { /* do nothing too */ }\n+        }\n+    }\n+\n+    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        let ptr = self.allocate(layout)?;\n+        if layout.size() > 0 {\n+            unsafe {\n+                ptr.as_mut_ptr().write_bytes(0, layout.size());\n+            }\n+        }\n+        Ok(ptr)\n+    }\n+\n+    unsafe fn grow(\n+        &self,\n+        ptr: NonNull<u8>,\n+        old_layout: Layout,\n+        new_layout: Layout,\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n+        debug_assert!(\n+            new_layout.size() >= old_layout.size(),\n+            \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n+        );\n+\n+        let new_ptr = self.allocate(new_layout)?;\n+        if new_layout.size() > 0 {\n+            new_ptr.as_mut_ptr().copy_from_nonoverlapping(ptr.as_ptr(), old_layout.size());\n+            self.deallocate(ptr, old_layout);\n+        }\n+        Ok(new_ptr)\n+    }\n+\n+    unsafe fn grow_zeroed(\n+        &self,\n+        ptr: NonNull<u8>,\n+        old_layout: Layout,\n+        new_layout: Layout,\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n+        let new_ptr = self.grow(ptr, old_layout, new_layout)?;\n+        if new_layout.size() > 0 {\n+            let old_size = old_layout.size();\n+            let new_size = new_layout.size();\n+            let raw_ptr = new_ptr.as_mut_ptr();\n+            raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+        }\n+        Ok(new_ptr)\n+    }\n+\n+    unsafe fn shrink(\n+        &self,\n+        ptr: NonNull<u8>,\n+        old_layout: Layout,\n+        new_layout: Layout,\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n+        debug_assert!(\n+            new_layout.size() <= old_layout.size(),\n+            \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n+        );\n+\n+        let new_ptr = self.allocate(new_layout)?;\n+        if new_layout.size() > 0 {\n+            new_ptr.as_mut_ptr().copy_from_nonoverlapping(ptr.as_ptr(), new_layout.size());\n+            self.deallocate(ptr, old_layout);\n+        }\n+        Ok(new_ptr)\n+    }\n+\n+    fn by_ref(&self) -> &Self\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n+}\n+\n+#[test]\n+fn const_box() {\n+    const VALUE: u32 = {\n+        let mut boxed = Box::new_in(1u32, ConstAllocator);\n+        assert!(*boxed == 1);\n+\n+        *boxed = 42;\n+        assert!(*boxed == 42);\n+\n+        *boxed\n+    };\n+\n+    assert!(VALUE == 42);\n+}"}, {"sha": "eec24a5c3f7e69ea3ca90574ba44c82609c78842", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -1,8 +1,19 @@\n #![feature(allocator_api)]\n+#![feature(alloc_layout_extra)]\n #![feature(assert_matches)]\n #![feature(box_syntax)]\n #![feature(cow_is_borrowed)]\n+#![feature(const_box)]\n+#![feature(const_convert)]\n #![feature(const_cow_is_borrowed)]\n+#![feature(const_heap)]\n+#![feature(const_intrinsic_copy)]\n+#![feature(const_mut_refs)]\n+#![feature(const_nonnull_slice_from_raw_parts)]\n+#![feature(const_ptr_offset)]\n+#![feature(const_ptr_write)]\n+#![feature(const_try)]\n+#![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(new_uninit)]\n@@ -26,6 +37,7 @@\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(const_str_from_utf8)]\n+#![feature(nonnull_slice_from_raw_parts)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "d8f6c85e428cdf054e78afcdfa0f6cd1c7d66630", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -866,7 +866,6 @@ pub(crate) mod builtin {\n                   language use and is subject to change\"\n     )]\n     #[allow_internal_unstable(fmt_internals)]\n-    #[doc(hidden)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! format_args_nl {\n@@ -1428,13 +1427,21 @@ pub(crate) mod builtin {\n     }\n \n     /// Attribute macro used to apply derive macros.\n+    ///\n+    /// See [the reference] for more info.\n+    ///\n+    /// [the reference]: ../../../reference/attributes/derive.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     pub macro derive($item:item) {\n         /* compiler built-in */\n     }\n \n     /// Attribute macro applied to a function to turn it into a unit test.\n+    ///\n+    /// See [the reference] for more info.\n+    ///\n+    /// [the reference]: ../../../reference/attributes/testing.html#the-test-attribute\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n@@ -1469,7 +1476,7 @@ pub(crate) mod builtin {\n \n     /// Attribute macro applied to a static to register it as a global allocator.\n     ///\n-    /// See also [`std::alloc::GlobalAlloc`](../std/alloc/trait.GlobalAlloc.html).\n+    /// See also [`std::alloc::GlobalAlloc`](../../../std/alloc/trait.GlobalAlloc.html).\n     #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n@@ -1507,6 +1514,7 @@ pub(crate) mod builtin {\n         since = \"1.52.0\",\n         reason = \"rustc-serialize is deprecated and no longer supported\"\n     )]\n+    #[doc(hidden)] // While technically stable, using it is unstable, and deprecated. Hide it.\n     pub macro RustcDecodable($item:item) {\n         /* compiler built-in */\n     }\n@@ -1519,6 +1527,7 @@ pub(crate) mod builtin {\n         since = \"1.52.0\",\n         reason = \"rustc-serialize is deprecated and no longer supported\"\n     )]\n+    #[doc(hidden)] // While technically stable, using it is unstable, and deprecated. Hide it.\n     pub macro RustcEncodable($item:item) {\n         /* compiler built-in */\n     }"}, {"sha": "0fb8846288bee7835f415a159ff0c369dbd017a8", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -69,29 +69,26 @@ pub use crate::{\n #[doc(no_inline)]\n pub use crate::concat_bytes;\n \n+// Do not `doc(inline)` these `doc(hidden)` items.\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[allow(deprecated, deprecated_in_future)]\n-#[doc(no_inline)]\n-pub use crate::macros::builtin::{\n-    bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n-};\n+#[allow(deprecated)]\n+pub use crate::macros::builtin::{RustcDecodable, RustcEncodable};\n \n+// Do not `doc(no_inline)` so that they become doc items on their own\n+// (no public module for them to be re-exported from).\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[doc(no_inline)]\n-pub use crate::macros::builtin::derive;\n+pub use crate::macros::builtin::{bench, derive, global_allocator, test, test_case};\n \n #[unstable(\n     feature = \"cfg_accessible\",\n     issue = \"64797\",\n     reason = \"`cfg_accessible` is not fully implemented\"\n )]\n-#[doc(no_inline)]\n pub use crate::macros::builtin::cfg_accessible;\n \n #[unstable(\n     feature = \"cfg_eval\",\n     issue = \"82679\",\n     reason = \"`cfg_eval` is a recently implemented feature\"\n )]\n-#[doc(no_inline)]\n pub use crate::macros::builtin::cfg_eval;"}, {"sha": "b52bcdfca9e07152062fe44b3db98f7f6293c546", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -54,33 +54,30 @@ pub use core::prelude::v1::{\n #[doc(no_inline)]\n pub use core::prelude::v1::concat_bytes;\n \n-// FIXME: Attribute and internal derive macros are not documented because for them rustdoc generates\n-// dead links which fail link checker testing.\n+// Do not `doc(inline)` these `doc(hidden)` items.\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[allow(deprecated, deprecated_in_future)]\n-#[doc(hidden)]\n-pub use core::prelude::v1::{\n-    bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n-};\n+#[allow(deprecated)]\n+pub use core::prelude::v1::{RustcDecodable, RustcEncodable};\n \n+// Do not `doc(no_inline)` so that they become doc items on their own\n+// (no public module for them to be re-exported from).\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[doc(hidden)]\n-pub use core::prelude::v1::derive;\n+pub use core::prelude::v1::{bench, derive, global_allocator, test, test_case};\n \n+// Do not `doc(no_inline)` either.\n #[unstable(\n     feature = \"cfg_accessible\",\n     issue = \"64797\",\n     reason = \"`cfg_accessible` is not fully implemented\"\n )]\n-#[doc(hidden)]\n pub use core::prelude::v1::cfg_accessible;\n \n+// Do not `doc(no_inline)` either.\n #[unstable(\n     feature = \"cfg_eval\",\n     issue = \"82679\",\n     reason = \"`cfg_eval` is a recently implemented feature\"\n )]\n-#[doc(hidden)]\n pub use core::prelude::v1::cfg_eval;\n \n // The file so far is equivalent to src/libcore/prelude/v1.rs,"}, {"sha": "2e54321e127c0e3e882e048d3689c82774d08cbd", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -429,12 +429,13 @@ pub struct TryIter<'a, T: 'a> {\n }\n \n /// An owning iterator over messages on a [`Receiver`],\n-/// created by **Receiver::into_iter**.\n+/// created by [`into_iter`].\n ///\n /// This iterator will block whenever [`next`]\n /// is called, waiting for a new message, and [`None`] will be\n /// returned if the corresponding channel has hung up.\n ///\n+/// [`into_iter`]: Receiver::into_iter\n /// [`next`]: Iterator::next\n ///\n /// # Examples"}, {"sha": "684b8e3155e84b1a6554424e5bf5afb45748373e", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 54, "deletions": 18, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -15,7 +15,9 @@ use core::str::utf8_char_width;\n // the value over time (such as if a process calls `SetStdHandle` while it's running). See #40490.\n pub struct Stdin {\n     surrogate: u16,\n+    incomplete_utf8: IncompleteUtf8,\n }\n+\n pub struct Stdout {\n     incomplete_utf8: IncompleteUtf8,\n }\n@@ -29,6 +31,25 @@ struct IncompleteUtf8 {\n     len: u8,\n }\n \n+impl IncompleteUtf8 {\n+    // Implemented for use in Stdin::read.\n+    fn read(&mut self, buf: &mut [u8]) -> usize {\n+        // Write to buffer until the buffer is full or we run out of bytes.\n+        let to_write = cmp::min(buf.len(), self.len as usize);\n+        buf[..to_write].copy_from_slice(&self.bytes[..to_write]);\n+\n+        // Rotate the remaining bytes if not enough remaining space in buffer.\n+        if usize::from(self.len) > buf.len() {\n+            self.bytes.copy_within(to_write.., 0);\n+            self.len -= to_write as u8;\n+        } else {\n+            self.len = 0;\n+        }\n+\n+        to_write\n+    }\n+}\n+\n // Apparently Windows doesn't handle large reads on stdin or writes to stdout/stderr well (see\n // #13304 for details).\n //\n@@ -205,7 +226,7 @@ fn write_u16s(handle: c::HANDLE, data: &[u16]) -> io::Result<usize> {\n \n impl Stdin {\n     pub const fn new() -> Stdin {\n-        Stdin { surrogate: 0 }\n+        Stdin { surrogate: 0, incomplete_utf8: IncompleteUtf8::new() }\n     }\n }\n \n@@ -221,24 +242,39 @@ impl io::Read for Stdin {\n             }\n         }\n \n-        if buf.len() == 0 {\n-            return Ok(0);\n-        } else if buf.len() < 4 {\n-            return Err(io::Error::new_const(\n-                io::ErrorKind::InvalidInput,\n-                &\"Windows stdin in console mode does not support a buffer too small to \\\n-                 guarantee holding one arbitrary UTF-8 character (4 bytes)\",\n-            ));\n+        // If there are bytes in the incomplete utf-8, start with those.\n+        // (No-op if there is nothing in the buffer.)\n+        let mut bytes_copied = self.incomplete_utf8.read(buf);\n+\n+        if bytes_copied == buf.len() {\n+            return Ok(bytes_copied);\n+        } else if buf.len() - bytes_copied < 4 {\n+            // Not enough space to get a UTF-8 byte. We will use the incomplete UTF8.\n+            let mut utf16_buf = [0u16; 1];\n+            // Read one u16 character.\n+            let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, 1, &mut self.surrogate)?;\n+            // Read bytes, using the (now-empty) self.incomplete_utf8 as extra space.\n+            let read_bytes = utf16_to_utf8(&utf16_buf[..read], &mut self.incomplete_utf8.bytes)?;\n+\n+            // Read in the bytes from incomplete_utf8 until the buffer is full.\n+            self.incomplete_utf8.len = read_bytes as u8;\n+            // No-op if no bytes.\n+            bytes_copied += self.incomplete_utf8.read(&mut buf[bytes_copied..]);\n+            Ok(bytes_copied)\n+        } else {\n+            let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n+            // In the worst case, a UTF-8 string can take 3 bytes for every `u16` of a UTF-16. So\n+            // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n+            // lost.\n+            let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n+            let read =\n+                read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;\n+\n+            match utf16_to_utf8(&utf16_buf[..read], buf) {\n+                Ok(value) => return Ok(bytes_copied + value),\n+                Err(e) => return Err(e),\n+            }\n         }\n-\n-        let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n-        // In the worst case, a UTF-8 string can take 3 bytes for every `u16` of a UTF-16. So\n-        // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n-        // lost.\n-        let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n-        let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;\n-\n-        utf16_to_utf8(&utf16_buf[..read], buf)\n     }\n }\n "}, {"sha": "21bbc6f20b294341ca41140e956ff44a9f154caf", "filename": "src/test/ui/inference/char-as-str-multi.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fchar-as-str-multi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fchar-as-str-multi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fchar-as-str-multi.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -0,0 +1,6 @@\n+// When a MULTI-character string literal is used where a char should be,\n+// DO NOT suggest changing to single quotes.\n+\n+fn main() {\n+    let _: char = \"foo\"; //~ ERROR mismatched types\n+}"}, {"sha": "c3ba17a5579ad55978a625e643626d21bc0fa646", "filename": "src/test/ui/inference/char-as-str-multi.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fchar-as-str-multi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fchar-as-str-multi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fchar-as-str-multi.stderr?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/char-as-str-multi.rs:5:19\n+   |\n+LL |     let _: char = \"foo\";\n+   |            ----   ^^^^^ expected `char`, found `&str`\n+   |            |\n+   |            expected due to this\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e401492a830b46d9fba1829b300df2ee99bc334b", "filename": "src/test/ui/inference/char-as-str-single.fixed", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fchar-as-str-single.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fchar-as-str-single.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fchar-as-str-single.fixed?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -0,0 +1,11 @@\n+// When a SINGLE-character string literal is used where a char should be,\n+// suggest changing to single quotes.\n+\n+// Testing both single-byte and multi-byte characters, as we should handle both.\n+\n+// run-rustfix\n+\n+fn main() {\n+    let _: char = 'a'; //~ ERROR mismatched types\n+    let _: char = '\u4eba'; //~ ERROR mismatched types\n+}"}, {"sha": "4f23cea5354c3818046830496f2dc1abf83edc5c", "filename": "src/test/ui/inference/char-as-str-single.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fchar-as-str-single.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fchar-as-str-single.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fchar-as-str-single.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -0,0 +1,11 @@\n+// When a SINGLE-character string literal is used where a char should be,\n+// suggest changing to single quotes.\n+\n+// Testing both single-byte and multi-byte characters, as we should handle both.\n+\n+// run-rustfix\n+\n+fn main() {\n+    let _: char = \"a\"; //~ ERROR mismatched types\n+    let _: char = \"\u4eba\"; //~ ERROR mismatched types\n+}"}, {"sha": "29075c15414b223c37db00418bf785a71922979e", "filename": "src/test/ui/inference/char-as-str-single.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fchar-as-str-single.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fchar-as-str-single.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fchar-as-str-single.stderr?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -0,0 +1,29 @@\n+error[E0308]: mismatched types\n+  --> $DIR/char-as-str-single.rs:9:19\n+   |\n+LL |     let _: char = \"a\";\n+   |            ----   ^^^ expected `char`, found `&str`\n+   |            |\n+   |            expected due to this\n+   |\n+help: if you meant to write a `char` literal, use single quotes\n+   |\n+LL |     let _: char = 'a';\n+   |                   ~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/char-as-str-single.rs:10:19\n+   |\n+LL |     let _: char = \"\u4eba\";\n+   |            ----   ^^^^ expected `char`, found `&str`\n+   |            |\n+   |            expected due to this\n+   |\n+help: if you meant to write a `char` literal, use single quotes\n+   |\n+LL |     let _: char = '\u4eba';\n+   |                   ~~~~\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "09f3dec5a17554837b696b10f8da0f2a2776b9c1", "filename": "src/test/ui/inference/str-as-char.fixed", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fstr-as-char.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fstr-as-char.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fstr-as-char.fixed?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -0,0 +1,8 @@\n+// When a char literal is used where a str should be,\n+// suggest changing to double quotes.\n+\n+// run-rustfix\n+\n+fn main() {\n+    let _: &str = \"a\"; //~ ERROR mismatched types\n+}"}, {"sha": "7092a61244255fc46a25ebd5f22545bf69545ba0", "filename": "src/test/ui/inference/str-as-char.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fstr-as-char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fstr-as-char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fstr-as-char.rs?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -0,0 +1,8 @@\n+// When a char literal is used where a str should be,\n+// suggest changing to double quotes.\n+\n+// run-rustfix\n+\n+fn main() {\n+    let _: &str = 'a'; //~ ERROR mismatched types\n+}"}, {"sha": "ebbe7c80f77196d6e9b84593a0d974484df646e4", "filename": "src/test/ui/inference/str-as-char.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fstr-as-char.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Finference%2Fstr-as-char.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fstr-as-char.stderr?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/str-as-char.rs:7:19\n+   |\n+LL |     let _: &str = 'a';\n+   |            ----   ^^^ expected `&str`, found `char`\n+   |            |\n+   |            expected due to this\n+   |\n+help: if you meant to write a `str` literal, use double quotes\n+   |\n+LL |     let _: &str = \"a\";\n+   |                   ~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e065e17c280f9ae5946707807d13dbdd13c51abd", "filename": "src/test/ui/issues/issue-23589.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Fissues%2Fissue-23589.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d6f948173ccb18822bab13d548c65632db5f0aa/src%2Ftest%2Fui%2Fissues%2Fissue-23589.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23589.stderr?ref=7d6f948173ccb18822bab13d548c65632db5f0aa", "patch": "@@ -12,6 +12,11 @@ error[E0308]: mismatched types\n    |\n LL |     let v: Vec(&str) = vec!['1', '2'];\n    |                             ^^^ expected `&str`, found `char`\n+   |\n+help: if you meant to write a `str` literal, use double quotes\n+   |\n+LL |     let v: Vec(&str) = vec![\"1\", '2'];\n+   |                             ~~~\n \n error: aborting due to 2 previous errors\n "}]}