{"sha": "357bc27904d4a99c83d4b01272c34e0e54934fa5", "node_id": "C_kwDOAAsO6NoAKDM1N2JjMjc5MDRkNGE5OWM4M2Q0YjAxMjcyYzM0ZTBlNTQ5MzRmYTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-06T16:09:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-06T16:09:54Z"}, "message": "Auto merge of #97795 - Dylan-DPC:rollup-dxilagr, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #97312 (Compute lifetimes in scope at diagnostic time)\n - #97495 (Add E0788 for improper #[no_coverage] usage)\n - #97579 (Avoid creating `SmallVec`s in `global_llvm_features`)\n - #97767 (interpret: do not claim UB until we looked more into variadic functions)\n - #97787 (E0432: rust 2018 -> rust 2018 or later    in --explain message)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ebff2affafe86a6a42a39cc3881eb6f8af61fe88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebff2affafe86a6a42a39cc3881eb6f8af61fe88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/357bc27904d4a99c83d4b01272c34e0e54934fa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/357bc27904d4a99c83d4b01272c34e0e54934fa5", "html_url": "https://github.com/rust-lang/rust/commit/357bc27904d4a99c83d4b01272c34e0e54934fa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/357bc27904d4a99c83d4b01272c34e0e54934fa5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d20fd109809f20c049d6895a5be27a1fbd39daa", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d20fd109809f20c049d6895a5be27a1fbd39daa", "html_url": "https://github.com/rust-lang/rust/commit/9d20fd109809f20c049d6895a5be27a1fbd39daa"}, {"sha": "99afe260321680e09cb848180754953d4c1791d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/99afe260321680e09cb848180754953d4c1791d3", "html_url": "https://github.com/rust-lang/rust/commit/99afe260321680e09cb848180754953d4c1791d3"}], "stats": {"total": 657, "additions": 406, "deletions": 251}, "files": [{"sha": "4da09c4ef486ee55c0c5fd8ffbf4d2ba8685c4e3", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -313,6 +313,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_assoc_type_binding(&mut self, type_binding: &'hir TypeBinding<'hir>) {\n+        self.insert(type_binding.span, type_binding.hir_id, Node::TypeBinding(type_binding));\n+        self.with_parent(type_binding.hir_id, |this| {\n+            intravisit::walk_assoc_type_binding(this, type_binding)\n+        })\n+    }\n+\n     fn visit_trait_item_ref(&mut self, ii: &'hir TraitItemRef) {\n         // Do not visit the duplicate information in TraitItemRef. We want to\n         // map the actual nodes, not the duplicate ones in the *Ref."}, {"sha": "ce6c6e3215c9b430efa46ce5f1726dd1cf8403f9", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -218,15 +218,17 @@ pub fn check_tied_features(\n     sess: &Session,\n     features: &FxHashMap<&str, bool>,\n ) -> Option<&'static [&'static str]> {\n-    for tied in tied_target_features(sess) {\n-        // Tied features must be set to the same value, or not set at all\n-        let mut tied_iter = tied.iter();\n-        let enabled = features.get(tied_iter.next().unwrap());\n-        if tied_iter.any(|f| enabled != features.get(f)) {\n-            return Some(tied);\n+    if !features.is_empty() {\n+        for tied in tied_target_features(sess) {\n+            // Tied features must be set to the same value, or not set at all\n+            let mut tied_iter = tied.iter();\n+            let enabled = features.get(tied_iter.next().unwrap());\n+            if tied_iter.any(|f| enabled != features.get(f)) {\n+                return Some(tied);\n+            }\n         }\n     }\n-    None\n+    return None;\n }\n \n // Used to generate cfg variables and apply features\n@@ -440,6 +442,7 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n \n     // -Ctarget-features\n     let supported_features = supported_target_features(sess);\n+    let mut featsmap = FxHashMap::default();\n     let feats = sess\n         .opts\n         .cg\n@@ -485,35 +488,36 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n                 }\n                 diag.emit();\n             }\n-            Some((enable_disable, feature))\n+\n+            if diagnostics {\n+                // FIXME(nagisa): figure out how to not allocate a full hashset here.\n+                featsmap.insert(feature, enable_disable == '+');\n+            }\n+\n+            // rustc-specific features do not get passed down to LLVM\u2026\n+            if RUSTC_SPECIFIC_FEATURES.contains(&feature) {\n+                return None;\n+            }\n+            // ... otherwise though we run through `to_llvm_features` when\n+            // passing requests down to LLVM. This means that all in-language\n+            // features also work on the command line instead of having two\n+            // different names when the LLVM name and the Rust name differ.\n+            Some(\n+                to_llvm_features(sess, feature)\n+                    .into_iter()\n+                    .map(move |f| format!(\"{}{}\", enable_disable, f)),\n+            )\n         })\n-        .collect::<SmallVec<[(char, &str); 8]>>();\n-\n-    if diagnostics {\n-        // FIXME(nagisa): figure out how to not allocate a full hashset here.\n-        let featmap = feats.iter().map(|&(flag, feat)| (feat, flag == '+')).collect();\n-        if let Some(f) = check_tied_features(sess, &featmap) {\n-            sess.err(&format!(\n-                \"target features {} must all be enabled or disabled together\",\n-                f.join(\", \")\n-            ));\n-        }\n+        .flatten();\n+    features.extend(feats);\n+\n+    if diagnostics && let Some(f) = check_tied_features(sess, &featsmap) {\n+        sess.err(&format!(\n+            \"target features {} must all be enabled or disabled together\",\n+            f.join(\", \")\n+        ));\n     }\n \n-    features.extend(feats.into_iter().flat_map(|(enable_disable, feature)| {\n-        // rustc-specific features do not get passed down to LLVM\u2026\n-        if RUSTC_SPECIFIC_FEATURES.contains(&feature) {\n-            return SmallVec::<[_; 2]>::new();\n-        }\n-        // ... otherwise though we run through `to_llvm_features` when\n-        // passing requests down to LLVM. This means that all in-language\n-        // features also work on the command line instead of having two\n-        // different names when the LLVM name and the Rust name differ.\n-        to_llvm_features(sess, feature)\n-            .into_iter()\n-            .map(|f| format!(\"{}{}\", enable_disable, f))\n-            .collect()\n-    }));\n     features\n }\n "}, {"sha": "57d06b48ca4da44749657a307eeb8fd5cef6cce3", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -353,12 +353,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // FIXME: for variadic support, do we have to somehow determine callee's extra_args?\n                 let callee_fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n \n-                if callee_fn_abi.c_variadic != caller_fn_abi.c_variadic {\n-                    throw_ub_format!(\n-                        \"calling a c-variadic function via a non-variadic call site, or vice versa\"\n-                    );\n-                }\n-                if callee_fn_abi.c_variadic {\n+                if callee_fn_abi.c_variadic || caller_fn_abi.c_variadic {\n                     throw_unsup_format!(\"calling a c-variadic function is not supported\");\n                 }\n "}, {"sha": "0114461e38811153ba7ba0f1d6830e2ac498e2d7", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -491,6 +491,7 @@ E0784: include_str!(\"./error_codes/E0784.md\"),\n E0785: include_str!(\"./error_codes/E0785.md\"),\n E0786: include_str!(\"./error_codes/E0786.md\"),\n E0787: include_str!(\"./error_codes/E0787.md\"),\n+E0788: include_str!(\"./error_codes/E0788.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "2920e2623fbe5886bcfd29c27760d9cbc2c99e8b", "filename": "compiler/rustc_error_codes/src/error_codes/E0432.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0432.md", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0432.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0432.md?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -10,10 +10,10 @@ In Rust 2015, paths in `use` statements are relative to the crate root. To\n import items relative to the current and parent modules, use the `self::` and\n `super::` prefixes, respectively.\n \n-In Rust 2018, paths in `use` statements are relative to the current module\n-unless they begin with the name of a crate or a literal `crate::`, in which\n-case they start from the crate root. As in Rust 2015 code, the `self::` and\n-`super::` prefixes refer to the current and parent modules respectively.\n+In Rust 2018 or later, paths in `use` statements are relative to the current\n+module unless they begin with the name of a crate or a literal `crate::`, in\n+which case they start from the crate root. As in Rust 2015 code, the `self::`\n+and `super::` prefixes refer to the current and parent modules respectively.\n \n Also verify that you didn't misspell the import name and that the import exists\n in the module from where you tried to import it. Example:\n@@ -38,8 +38,8 @@ use core::any;\n # fn main() {}\n ```\n \n-In Rust 2018 the `extern crate` declaration is not required and you can instead\n-just `use` it:\n+Since Rust 2018 the `extern crate` declaration is not required and\n+you can instead just `use` it:\n \n ```edition2018\n use core::any; // No extern crate required in Rust 2018."}, {"sha": "d26f9b594550c887e86042380f35772697db1f54", "filename": "compiler/rustc_error_codes/src/error_codes/E0788.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0788.md", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0788.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0788.md?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -0,0 +1,26 @@\n+A `#[no_coverage]` attribute was applied to something which does not show up\n+in code coverage, or is too granular to be excluded from the coverage report.\n+\n+For now, this attribute can only be applied to function, method, and closure\n+definitions. In the future, it may be added to statements, blocks, and\n+expressions, and for the time being, using this attribute in those places\n+will just emit an `unused_attributes` lint instead of this error.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0788\n+#[no_coverage]\n+struct Foo;\n+\n+#[no_coverage]\n+const FOO: Foo = Foo;\n+```\n+\n+`#[no_coverage]` tells the compiler to not generate coverage instrumentation for\n+a piece of code when the `-C instrument-coverage` flag is passed. Things like\n+structs and consts are not coverable code, and thus cannot do anything with this\n+attribute.\n+\n+If you wish to apply this attribute to all methods in an impl or module,\n+manually annotate each method; it is not possible to annotate the entire impl\n+with a `#[no_coverage]` attribute."}, {"sha": "9c314f67651501c3a96df15a0667551378091afc", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -3302,6 +3302,7 @@ pub enum Node<'hir> {\n     Stmt(&'hir Stmt<'hir>),\n     PathSegment(&'hir PathSegment<'hir>),\n     Ty(&'hir Ty<'hir>),\n+    TypeBinding(&'hir TypeBinding<'hir>),\n     TraitRef(&'hir TraitRef<'hir>),\n     Binding(&'hir Pat<'hir>),\n     Pat(&'hir Pat<'hir>),\n@@ -3347,6 +3348,7 @@ impl<'hir> Node<'hir> {\n             | Node::PathSegment(PathSegment { ident, .. }) => Some(*ident),\n             Node::Lifetime(lt) => Some(lt.name.ident()),\n             Node::GenericParam(p) => Some(p.name.ident()),\n+            Node::TypeBinding(b) => Some(b.ident),\n             Node::Param(..)\n             | Node::AnonConst(..)\n             | Node::Expr(..)"}, {"sha": "fb40008d60b5d1d04e761bee7b1e8785c3811ba5", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -85,6 +85,7 @@ impl<'a> State<'a> {\n             Node::Stmt(a) => self.print_stmt(&a),\n             Node::PathSegment(a) => self.print_path_segment(&a),\n             Node::Ty(a) => self.print_type(&a),\n+            Node::TypeBinding(a) => self.print_type_binding(&a),\n             Node::TraitRef(a) => self.print_trait_ref(&a),\n             Node::Binding(a) | Node::Pat(a) => self.print_pat(&a),\n             Node::Arm(a) => self.print_arm(&a),\n@@ -1703,21 +1704,7 @@ impl<'a> State<'a> {\n \n             for binding in generic_args.bindings.iter() {\n                 start_or_comma(self);\n-                self.print_ident(binding.ident);\n-                self.print_generic_args(binding.gen_args, false, false);\n-                self.space();\n-                match generic_args.bindings[0].kind {\n-                    hir::TypeBindingKind::Equality { ref term } => {\n-                        self.word_space(\"=\");\n-                        match term {\n-                            Term::Ty(ref ty) => self.print_type(ty),\n-                            Term::Const(ref c) => self.print_anon_const(c),\n-                        }\n-                    }\n-                    hir::TypeBindingKind::Constraint { bounds } => {\n-                        self.print_bounds(\":\", bounds);\n-                    }\n-                }\n+                self.print_type_binding(binding);\n             }\n \n             if !empty.get() {\n@@ -1726,6 +1713,24 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    pub fn print_type_binding(&mut self, binding: &hir::TypeBinding<'_>) {\n+        self.print_ident(binding.ident);\n+        self.print_generic_args(binding.gen_args, false, false);\n+        self.space();\n+        match binding.kind {\n+            hir::TypeBindingKind::Equality { ref term } => {\n+                self.word_space(\"=\");\n+                match term {\n+                    Term::Ty(ref ty) => self.print_type(ty),\n+                    Term::Const(ref c) => self.print_anon_const(c),\n+                }\n+            }\n+            hir::TypeBindingKind::Constraint { bounds } => {\n+                self.print_bounds(\":\", bounds);\n+            }\n+        }\n+    }\n+\n     pub fn print_pat(&mut self, pat: &hir::Pat<'_>) {\n         self.maybe_print_comment(pat.span.lo());\n         self.ann.pre(self, AnnNode::Pat(pat));"}, {"sha": "ebda9f7588d5d48c40125a0c521a83b2d1aac33a", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -298,6 +298,7 @@ impl<'hir> Map<'hir> {\n             Node::Stmt(_)\n             | Node::PathSegment(_)\n             | Node::Ty(_)\n+            | Node::TypeBinding(_)\n             | Node::Infer(_)\n             | Node::TraitRef(_)\n             | Node::Pat(_)\n@@ -323,7 +324,8 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_parent_node(self, hir_id: HirId) -> HirId {\n-        self.find_parent_node(hir_id).unwrap()\n+        self.find_parent_node(hir_id)\n+            .unwrap_or_else(|| bug!(\"No parent for node {:?}\", self.node_to_string(hir_id)))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n@@ -973,6 +975,7 @@ impl<'hir> Map<'hir> {\n                     .with_hi(seg.args.map_or_else(|| ident_span.hi(), |args| args.span_ext.hi()))\n             }\n             Node::Ty(ty) => ty.span,\n+            Node::TypeBinding(tb) => tb.span,\n             Node::TraitRef(tr) => tr.path.span,\n             Node::Binding(pat) => pat.span,\n             Node::Pat(pat) => pat.span,\n@@ -1205,6 +1208,7 @@ fn hir_id_to_string(map: Map<'_>, id: HirId) -> String {\n         Some(Node::Stmt(_)) => node_str(\"stmt\"),\n         Some(Node::PathSegment(_)) => node_str(\"path segment\"),\n         Some(Node::Ty(_)) => node_str(\"type\"),\n+        Some(Node::TypeBinding(_)) => node_str(\"type binding\"),\n         Some(Node::TraitRef(_)) => node_str(\"trait ref\"),\n         Some(Node::Binding(_)) => node_str(\"local\"),\n         Some(Node::Pat(_)) => node_str(\"pat\"),"}, {"sha": "c71ba7b175313b380419aefc385250b89e51c99e", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -16,20 +16,6 @@ pub enum Region {\n     Free(DefId, /* lifetime decl */ DefId),\n }\n \n-/// This is used in diagnostics to improve suggestions for missing generic arguments.\n-/// It gives information on the type of lifetimes that are in scope for a particular `PathSegment`,\n-/// so that we can e.g. suggest elided-lifetimes-in-paths of the form <'_, '_> e.g.\n-#[derive(Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n-pub enum LifetimeScopeForPath {\n-    /// Contains all lifetime names that are in scope and could possibly be used in generics\n-    /// arguments of path.\n-    NonElided(Vec<LocalDefId>),\n-\n-    /// Information that allows us to suggest args of the form `<'_>` in case\n-    /// no generic arguments were provided for a path.\n-    Elided,\n-}\n-\n /// A set containing, at most, one known element.\n /// If two distinct values are inserted into a set, then it\n /// becomes `Many`, which can be used to detect ambiguities."}, {"sha": "5b48f164016f7e2ea97eab165447f32583aab378", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -1599,11 +1599,6 @@ rustc_queries! {\n         desc { \"looking up late bound vars\" }\n     }\n \n-    query lifetime_scope_map(_: LocalDefId) -> Option<FxHashMap<ItemLocalId, LifetimeScopeForPath>> {\n-        storage(ArenaCacheSelector<'tcx>)\n-        desc { \"finds the lifetime scope for an HirId of a PathSegment\" }\n-    }\n-\n     query visibility(def_id: DefId) -> ty::Visibility {\n         desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern"}, {"sha": "041e5fb4bc6a9b1c0431454b3cc8c862e1f33525", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -6,7 +6,7 @@ use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath};\n+use crate::middle::resolve_lifetime;\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation, ConstValue, Scalar};\n use crate::mir::{\n@@ -2821,10 +2821,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         )\n     }\n \n-    pub fn lifetime_scope(self, id: HirId) -> Option<&'tcx LifetimeScopeForPath> {\n-        self.lifetime_scope_map(id.owner).as_ref().and_then(|map| map.get(&id.local_id))\n-    }\n-\n     /// Whether the `def_id` counts as const fn in the current crate, considering all active\n     /// feature gates\n     pub fn is_const_fn(self, def_id: DefId) -> bool {"}, {"sha": "3d662ed5de4baa1e42feccd224b9b98c93cabbb0", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -6,9 +6,7 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use crate::middle::lib_features::LibFeatures;\n use crate::middle::privacy::AccessLevels;\n-use crate::middle::resolve_lifetime::{\n-    LifetimeScopeForPath, ObjectLifetimeDefault, Region, ResolveLifetimes,\n-};\n+use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLifetimes};\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;"}, {"sha": "5cc97d326d3d82cb2caf72f88bda9ab038dffba5", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -77,6 +77,7 @@ impl CheckAttrVisitor<'_> {\n         for attr in attrs {\n             let attr_is_valid = match attr.name_or_empty() {\n                 sym::inline => self.check_inline(hir_id, attr, span, target),\n+                sym::no_coverage => self.check_no_coverage(hir_id, attr, span, target),\n                 sym::non_exhaustive => self.check_non_exhaustive(hir_id, attr, span, target),\n                 sym::marker => self.check_marker(hir_id, attr, span, target),\n                 sym::rustc_must_implement_one_of => {\n@@ -291,6 +292,57 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    /// Checks if a `#[no_coverage]` is applied directly to a function\n+    fn check_no_coverage(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n+        match target {\n+            // no_coverage on function is fine\n+            Target::Fn\n+            | Target::Closure\n+            | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n+\n+            // function prototypes can't be covered\n+            Target::Method(MethodKind::Trait { body: false }) | Target::ForeignFn => {\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                    lint.build(\"`#[no_coverage]` is ignored on function prototypes\").emit();\n+                });\n+                true\n+            }\n+\n+            Target::Mod | Target::ForeignMod | Target::Impl | Target::Trait => {\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                    lint.build(\"`#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\").emit();\n+                });\n+                true\n+            }\n+\n+            Target::Expression | Target::Statement | Target::Arm => {\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                    lint.build(\"`#[no_coverage]` may only be applied to function definitions\")\n+                        .emit();\n+                });\n+                true\n+            }\n+\n+            _ => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    attr.span,\n+                    E0788,\n+                    \"`#[no_coverage]` must be applied to coverable code\",\n+                )\n+                .span_label(span, \"not coverable code\")\n+                .emit();\n+                false\n+            }\n+        }\n+    }\n+\n     fn check_generic_attr(\n         &self,\n         hir_id: HirId,"}, {"sha": "447f4174c10d5f6a0affc09459ea38b16263222a", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 97, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -8,12 +8,11 @@\n \n use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n use rustc_ast::walk_list;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n-use rustc_hir::hir_id::ItemLocalId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node};\n use rustc_hir::{GenericParamKind, HirIdMap};\n@@ -141,9 +140,6 @@ struct NamedRegionMap {\n     // - trait refs\n     // - bound types (like `T` in `for<'a> T<'a>: Foo`)\n     late_bound_vars: HirIdMap<Vec<ty::BoundVariableKind>>,\n-\n-    // maps `PathSegment` `HirId`s to lifetime scopes.\n-    scope_for_path: Option<FxHashMap<LocalDefId, FxHashMap<ItemLocalId, LifetimeScopeForPath>>>,\n }\n \n pub(crate) struct LifetimeContext<'a, 'tcx> {\n@@ -362,10 +358,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n             _ => None,\n         },\n         late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n-        lifetime_scope_map: |tcx, id| {\n-            let item_id = item_for(tcx, id);\n-            do_resolve(tcx, item_id, false, true).scope_for_path.unwrap().remove(&id)\n-        },\n \n         ..*providers\n     };\n@@ -406,29 +398,25 @@ fn resolve_lifetimes_trait_definition(\n     tcx: TyCtxt<'_>,\n     local_def_id: LocalDefId,\n ) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, true, false))\n+    convert_named_region_map(do_resolve(tcx, local_def_id, true))\n }\n \n /// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n /// `named_region_map`, `is_late_bound_map`, etc.\n #[tracing::instrument(level = \"debug\", skip(tcx))]\n fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, false, false))\n+    convert_named_region_map(do_resolve(tcx, local_def_id, false))\n }\n \n fn do_resolve(\n     tcx: TyCtxt<'_>,\n     local_def_id: LocalDefId,\n     trait_definition_only: bool,\n-    with_scope_for_path: bool,\n ) -> NamedRegionMap {\n     let item = tcx.hir().expect_item(local_def_id);\n-    let mut named_region_map = NamedRegionMap {\n-        defs: Default::default(),\n-        late_bound_vars: Default::default(),\n-        scope_for_path: with_scope_for_path.then(|| Default::default()),\n-    };\n+    let mut named_region_map =\n+        NamedRegionMap { defs: Default::default(), late_bound_vars: Default::default() };\n     let mut visitor = LifetimeContext {\n         tcx,\n         map: &mut named_region_map,\n@@ -524,38 +512,6 @@ fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::\n     }\n }\n \n-#[tracing::instrument(level = \"debug\")]\n-fn get_lifetime_scopes_for_path(mut scope: &Scope<'_>) -> LifetimeScopeForPath {\n-    let mut available_lifetimes = vec![];\n-    loop {\n-        match scope {\n-            Scope::Binder { lifetimes, s, .. } => {\n-                available_lifetimes.extend(lifetimes.keys());\n-                scope = s;\n-            }\n-            Scope::Body { s, .. } => {\n-                scope = s;\n-            }\n-            Scope::Elision { elide, s } => {\n-                if let Elide::Exact(_) = elide {\n-                    return LifetimeScopeForPath::Elided;\n-                } else {\n-                    scope = s;\n-                }\n-            }\n-            Scope::ObjectLifetimeDefault { s, .. } => {\n-                scope = s;\n-            }\n-            Scope::Root => {\n-                return LifetimeScopeForPath::NonElided(available_lifetimes);\n-            }\n-            Scope::Supertrait { s, .. } | Scope::TraitRefBoundary { s, .. } => {\n-                scope = s;\n-            }\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// Returns the binders in scope and the type of `Binder` that should be created for a poly trait ref.\n     fn poly_trait_ref_binder_info(&mut self) -> (Vec<ty::BoundVariableKind>, BinderScopeType) {\n@@ -1202,53 +1158,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_assoc_type_binding(&mut self, type_binding: &'tcx hir::TypeBinding<'_>) {\n-        let scope = self.scope;\n-        if let Some(scope_for_path) = self.map.scope_for_path.as_mut() {\n-            // We add lifetime scope information for `Ident`s in associated type bindings and use\n-            // the `HirId` of the type binding as the key in `LifetimeMap`\n-            let lifetime_scope = get_lifetime_scopes_for_path(scope);\n-            let map = scope_for_path.entry(type_binding.hir_id.owner).or_default();\n-            map.insert(type_binding.hir_id.local_id, lifetime_scope);\n-        }\n-        hir::intravisit::walk_assoc_type_binding(self, type_binding);\n-    }\n-\n     fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n             if let Some(ref args) = segment.args {\n                 self.visit_segment_args(path.res, depth, args);\n             }\n-\n-            let scope = self.scope;\n-            if let Some(scope_for_path) = self.map.scope_for_path.as_mut() {\n-                // Add lifetime scope information to path segment. Note we cannot call `visit_path_segment`\n-                // here because that call would yield to resolution problems due to `walk_path_segment`\n-                // being called, which processes the path segments generic args, which we have already\n-                // processed using `visit_segment_args`.\n-                let lifetime_scope = get_lifetime_scopes_for_path(scope);\n-                if let Some(hir_id) = segment.hir_id {\n-                    let map = scope_for_path.entry(hir_id.owner).or_default();\n-                    map.insert(hir_id.local_id, lifetime_scope);\n-                }\n-            }\n         }\n     }\n \n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'tcx hir::PathSegment<'tcx>) {\n-        let scope = self.scope;\n-        if let Some(scope_for_path) = self.map.scope_for_path.as_mut() {\n-            let lifetime_scope = get_lifetime_scopes_for_path(scope);\n-            if let Some(hir_id) = path_segment.hir_id {\n-                let map = scope_for_path.entry(hir_id.owner).or_default();\n-                map.insert(hir_id.local_id, lifetime_scope);\n-            }\n-        }\n-\n-        intravisit::walk_path_segment(self, path_span, path_segment);\n-    }\n-\n     fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl<'tcx>) {\n         let output = match fd.output {\n             hir::FnRetTy::DefaultReturn(_) => None,\n@@ -2227,6 +2145,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n             Node::ForeignItem(_) | Node::Ty(_) | Node::TraitRef(_) => None,\n+\n+            Node::TypeBinding(_) if let Node::TraitRef(_) = self.tcx.hir().get(self.tcx.hir().get_parent_node(parent)) => None,\n+\n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types.\n             _ => {\n@@ -2548,16 +2469,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        // If we specifically need the `scope_for_path` map, then we're in the\n-        // diagnostic pass and we don't want to emit more errors.\n-        if self.map.scope_for_path.is_some() {\n-            self.tcx.sess.delay_span_bug(\n-                rustc_span::DUMMY_SP,\n-                \"Encountered unexpected errors during diagnostics related part\",\n-            );\n-            return;\n-        }\n-\n         let mut spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n         spans.sort();\n         let mut spans_dedup = spans.clone();"}, {"sha": "58b63804b4a4ed18cb53db0b81cf70d4a8d6de5c", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -249,6 +249,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n                 | hir::Node::Stmt(..)\n                 | hir::Node::PathSegment(..)\n                 | hir::Node::Ty(..)\n+                | hir::Node::TypeBinding(..)\n                 | hir::Node::TraitRef(..)\n                 | hir::Node::Binding(..)\n                 | hir::Node::Pat(..)"}, {"sha": "2433401b7f0f5f5502ffc4eff0370a285832a7ee", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -450,21 +450,10 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     .discr_type()\n                     .to_ty(tcx),\n \n-                Node::TraitRef(trait_ref @ &TraitRef {\n-                  path, ..\n-                }) if let Some((binding, seg)) =\n-                  path\n-                      .segments\n-                      .iter()\n-                      .find_map(|seg| {\n-                          seg.args?.bindings\n-                              .iter()\n-                              .find_map(|binding| if binding.opt_const()?.hir_id == hir_id {\n-                                Some((binding, seg))\n-                              } else {\n-                                None\n-                              })\n-                      }) =>\n+                Node::TypeBinding(binding @ &TypeBinding { hir_id: binding_id, ..  })\n+                    if let Node::TraitRef(trait_ref) = tcx.hir().get(\n+                        tcx.hir().get_parent_node(binding_id)\n+                    ) =>\n                 {\n                   let Some(trait_def_id) = trait_ref.trait_def_id() else {\n                     return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");"}, {"sha": "c440e93fe0af1fdd3b516663b7faea8224113173", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 67, "deletions": 40, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -5,7 +5,6 @@ use rustc_errors::{\n };\n use rustc_hir as hir;\n use rustc_middle::hir::map::fn_sig;\n-use rustc_middle::middle::resolve_lifetime::LifetimeScopeForPath;\n use rustc_middle::ty::{self as ty, AssocItems, AssocKind, TyCtxt};\n use rustc_session::Session;\n use rustc_span::def_id::DefId;\n@@ -291,7 +290,69 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     }\n \n     // Creates lifetime name suggestions from the lifetime parameter names\n-    fn get_lifetime_args_suggestions_from_param_names(&self, num_params_to_take: usize) -> String {\n+    fn get_lifetime_args_suggestions_from_param_names(\n+        &self,\n+        path_hir_id: Option<hir::HirId>,\n+        num_params_to_take: usize,\n+    ) -> String {\n+        debug!(?path_hir_id);\n+\n+        if let Some(path_hir_id) = path_hir_id {\n+            let mut ret = Vec::new();\n+            for (id, node) in self.tcx.hir().parent_iter(path_hir_id) {\n+                debug!(?id);\n+                let params = if let Some(generics) = node.generics() {\n+                    generics.params\n+                } else if let hir::Node::Ty(ty) = node\n+                    && let hir::TyKind::BareFn(bare_fn) = ty.kind\n+                {\n+                    bare_fn.generic_params\n+                } else {\n+                    &[]\n+                };\n+                ret.extend(params.iter().filter_map(|p| {\n+                    let hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit }\n+                        = p.kind\n+                    else { return None };\n+                    let hir::ParamName::Plain(name) = p.name else { return None };\n+                    Some(name.to_string())\n+                }));\n+                // Suggest `'static` when in const/static item-like.\n+                if let hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Static { .. } | hir::ItemKind::Const { .. },\n+                    ..\n+                })\n+                | hir::Node::TraitItem(hir::TraitItem {\n+                    kind: hir::TraitItemKind::Const { .. },\n+                    ..\n+                })\n+                | hir::Node::ImplItem(hir::ImplItem {\n+                    kind: hir::ImplItemKind::Const { .. },\n+                    ..\n+                })\n+                | hir::Node::ForeignItem(hir::ForeignItem {\n+                    kind: hir::ForeignItemKind::Static { .. },\n+                    ..\n+                })\n+                | hir::Node::AnonConst(..) = node\n+                {\n+                    ret.extend(\n+                        std::iter::repeat(\"'static\".to_owned())\n+                            .take(num_params_to_take.saturating_sub(ret.len())),\n+                    );\n+                }\n+                if ret.len() >= num_params_to_take {\n+                    return ret[..num_params_to_take].join(\", \");\n+                }\n+                // We cannot refer to lifetimes defined in an outer function.\n+                if let hir::Node::Item(_) = node {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // We could not gather enough lifetime parameters in the scope.\n+        // We use the parameter names from the target type's definition instead.\n         self.gen_params\n             .params\n             .iter()\n@@ -501,44 +562,10 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         let num_params_to_take = num_missing_args;\n         let msg = format!(\"add missing {} argument{}\", self.kind(), pluralize!(num_missing_args));\n \n-        // we first try to get lifetime name suggestions from scope or elision information. If none is\n-        // available we use the parameter definitions\n-        let suggested_args = if let Some(hir_id) = self.path_segment.hir_id {\n-            if let Some(lifetimes_in_scope) = self.tcx.lifetime_scope(hir_id) {\n-                match lifetimes_in_scope {\n-                    LifetimeScopeForPath::NonElided(param_names) => {\n-                        debug!(\"NonElided(param_names: {:?})\", param_names);\n-\n-                        if param_names.len() >= num_params_to_take {\n-                            // use lifetime parameters in scope for suggestions\n-                            param_names\n-                                .iter()\n-                                .take(num_params_to_take)\n-                                .map(|def_id| {\n-                                    self.tcx.item_name(def_id.to_def_id()).to_ident_string()\n-                                })\n-                                .collect::<Vec<_>>()\n-                                .join(\", \")\n-                        } else {\n-                            // Not enough lifetime arguments in scope -> create suggestions from\n-                            // lifetime parameter names in definition. An error for the incorrect\n-                            // lifetime scope will be output later.\n-                            self.get_lifetime_args_suggestions_from_param_names(num_params_to_take)\n-                        }\n-                    }\n-                    LifetimeScopeForPath::Elided => {\n-                        debug!(\"Elided\");\n-                        // use suggestions of the form `<'_, '_>` in case lifetime can be elided\n-                        [\"'_\"].repeat(num_params_to_take).join(\",\")\n-                    }\n-                }\n-            } else {\n-                self.get_lifetime_args_suggestions_from_param_names(num_params_to_take)\n-            }\n-        } else {\n-            self.get_lifetime_args_suggestions_from_param_names(num_params_to_take)\n-        };\n-\n+        let suggested_args = self.get_lifetime_args_suggestions_from_param_names(\n+            self.path_segment.hir_id,\n+            num_params_to_take,\n+        );\n         debug!(\"suggested_args: {:?}\", &suggested_args);\n \n         match self.angle_brackets {"}, {"sha": "b395a1cfd8a62c6afdc0be95c5e3d3e8fd8da104", "filename": "src/test/ui/generic-associated-types/elided-in-expr-position.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Felided-in-expr-position.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Felided-in-expr-position.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Felided-in-expr-position.stderr?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -11,7 +11,7 @@ LL |     type Assoc<'a> where Self: 'a;\n    |          ^^^^^ --\n help: add missing lifetime argument\n    |\n-LL |     fn g(&self) -> Self::Assoc<'_>;\n+LL |     fn g(&self) -> Self::Assoc<'a>;\n    |                          ~~~~~~~~~\n \n error[E0107]: missing generics for associated type `Trait::Assoc`\n@@ -27,7 +27,7 @@ LL |     type Assoc<'a> where Self: 'a;\n    |          ^^^^^ --\n help: add missing lifetime argument\n    |\n-LL |     fn g(&self) -> Self::Assoc<'_> {\n+LL |     fn g(&self) -> Self::Assoc<'a> {\n    |                          ~~~~~~~~~\n \n error: aborting due to 2 previous errors"}, {"sha": "c664b3ee6683b4473c3be23e7629492865a1c1db", "filename": "src/test/ui/generic-associated-types/issue-81862.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81862.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81862.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81862.stderr?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -11,7 +11,7 @@ LL |     type Item<'a>;\n    |          ^^^^ --\n help: add missing lifetime argument\n    |\n-LL |     fn next(&mut self) -> Option<Self::Item<'_>>;\n+LL |     fn next(&mut self) -> Option<Self::Item<'a>>;\n    |                                        ~~~~~~~~\n \n error: aborting due to previous error"}, {"sha": "ff24c12b2bcfcbe5b5279f70b7a56f8fc707dc3e", "filename": "src/test/ui/lint/no-coverage.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/src%2Ftest%2Fui%2Flint%2Fno-coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/src%2Ftest%2Fui%2Flint%2Fno-coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fno-coverage.rs?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -0,0 +1,55 @@\n+#![feature(extern_types)]\n+#![feature(no_coverage)]\n+#![feature(type_alias_impl_trait)]\n+#![warn(unused_attributes)]\n+#![no_coverage]\n+//~^ WARN: `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n+\n+#[no_coverage]\n+//~^ WARN: `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n+trait Trait {\n+    #[no_coverage] //~ ERROR `#[no_coverage]` must be applied to coverable code\n+    const X: u32;\n+\n+    #[no_coverage] //~ ERROR `#[no_coverage]` must be applied to coverable code\n+    type T;\n+\n+    type U;\n+}\n+\n+#[no_coverage]\n+//~^ WARN: `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n+impl Trait for () {\n+    const X: u32 = 0;\n+\n+    #[no_coverage] //~ ERROR `#[no_coverage]` must be applied to coverable code\n+    type T = Self;\n+\n+    #[no_coverage] //~ ERROR `#[no_coverage]` must be applied to coverable code\n+    type U = impl Trait; //~ ERROR unconstrained opaque type\n+}\n+\n+extern \"C\" {\n+    #[no_coverage] //~ ERROR `#[no_coverage]` must be applied to coverable code\n+    static X: u32;\n+\n+    #[no_coverage] //~ ERROR `#[no_coverage]` must be applied to coverable code\n+    type T;\n+}\n+\n+#[no_coverage]\n+fn main() {\n+    #[no_coverage]\n+    //~^ WARN `#[no_coverage]` may only be applied to function definitions\n+    let _ = ();\n+\n+    match () {\n+        #[no_coverage]\n+        //~^ WARN `#[no_coverage]` may only be applied to function definitions\n+        () => (),\n+    }\n+\n+    #[no_coverage]\n+    //~^ WARN `#[no_coverage]` may only be applied to function definitions\n+    return ();\n+}"}, {"sha": "8452ccc7a03cbe5e40819c28caac78a3871627c9", "filename": "src/test/ui/lint/no-coverage.stderr", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/src%2Ftest%2Fui%2Flint%2Fno-coverage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/src%2Ftest%2Fui%2Flint%2Fno-coverage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fno-coverage.stderr?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -0,0 +1,101 @@\n+warning: `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n+  --> $DIR/no-coverage.rs:8:1\n+   |\n+LL | #[no_coverage]\n+   | ^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/no-coverage.rs:4:9\n+   |\n+LL | #![warn(unused_attributes)]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+warning: `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n+  --> $DIR/no-coverage.rs:20:1\n+   |\n+LL | #[no_coverage]\n+   | ^^^^^^^^^^^^^^\n+\n+warning: `#[no_coverage]` may only be applied to function definitions\n+  --> $DIR/no-coverage.rs:42:5\n+   |\n+LL |     #[no_coverage]\n+   |     ^^^^^^^^^^^^^^\n+\n+warning: `#[no_coverage]` may only be applied to function definitions\n+  --> $DIR/no-coverage.rs:47:9\n+   |\n+LL |         #[no_coverage]\n+   |         ^^^^^^^^^^^^^^\n+\n+warning: `#[no_coverage]` may only be applied to function definitions\n+  --> $DIR/no-coverage.rs:52:5\n+   |\n+LL |     #[no_coverage]\n+   |     ^^^^^^^^^^^^^^\n+\n+error[E0788]: `#[no_coverage]` must be applied to coverable code\n+  --> $DIR/no-coverage.rs:11:5\n+   |\n+LL |     #[no_coverage]\n+   |     ^^^^^^^^^^^^^^\n+LL |     const X: u32;\n+   |     ------------- not coverable code\n+\n+error[E0788]: `#[no_coverage]` must be applied to coverable code\n+  --> $DIR/no-coverage.rs:14:5\n+   |\n+LL |     #[no_coverage]\n+   |     ^^^^^^^^^^^^^^\n+LL |     type T;\n+   |     ------- not coverable code\n+\n+error[E0788]: `#[no_coverage]` must be applied to coverable code\n+  --> $DIR/no-coverage.rs:25:5\n+   |\n+LL |     #[no_coverage]\n+   |     ^^^^^^^^^^^^^^\n+LL |     type T = Self;\n+   |     -------------- not coverable code\n+\n+error[E0788]: `#[no_coverage]` must be applied to coverable code\n+  --> $DIR/no-coverage.rs:28:5\n+   |\n+LL |     #[no_coverage]\n+   |     ^^^^^^^^^^^^^^\n+LL |     type U = impl Trait;\n+   |     -------------------- not coverable code\n+\n+error[E0788]: `#[no_coverage]` must be applied to coverable code\n+  --> $DIR/no-coverage.rs:33:5\n+   |\n+LL |     #[no_coverage]\n+   |     ^^^^^^^^^^^^^^\n+LL |     static X: u32;\n+   |     -------------- not coverable code\n+\n+error[E0788]: `#[no_coverage]` must be applied to coverable code\n+  --> $DIR/no-coverage.rs:36:5\n+   |\n+LL |     #[no_coverage]\n+   |     ^^^^^^^^^^^^^^\n+LL |     type T;\n+   |     ------- not coverable code\n+\n+warning: `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n+  --> $DIR/no-coverage.rs:5:1\n+   |\n+LL | #![no_coverage]\n+   | ^^^^^^^^^^^^^^^\n+\n+error: unconstrained opaque type\n+  --> $DIR/no-coverage.rs:29:14\n+   |\n+LL |     type U = impl Trait;\n+   |              ^^^^^^^^^^\n+   |\n+   = note: `U` must be used in combination with a concrete type within the same module\n+\n+error: aborting due to 7 previous errors; 6 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0788`."}, {"sha": "1498337549d81f2f976ba5050cace6126002087f", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/357bc27904d4a99c83d4b01272c34e0e54934fa5/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/357bc27904d4a99c83d4b01272c34e0e54934fa5/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr?ref=357bc27904d4a99c83d4b01272c34e0e54934fa5", "patch": "@@ -171,8 +171,8 @@ LL | pub union Qux<'t, 'k, I> {\n    |           ^^^ --  --\n help: add missing lifetime argument\n    |\n-LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                       ++++\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                       +++++++++\n \n error[E0107]: this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n   --> $DIR/missing-lifetime-specifier.rs:43:44\n@@ -243,8 +243,8 @@ LL | pub union Qux<'t, 'k, I> {\n    |           ^^^ --  --\n help: add missing lifetime argument\n    |\n-LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                       ++++\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                       +++++++++\n \n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n   --> $DIR/missing-lifetime-specifier.rs:51:45\n@@ -261,8 +261,8 @@ LL | trait Tar<'t, 'k, I> {}\n    |       ^^^ --  --\n help: add missing lifetime argument\n    |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                        ++++\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                        +++++++++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lifetime-specifier.rs:51:44\n@@ -360,8 +360,8 @@ LL | trait Tar<'t, 'k, I> {}\n    |       ^^^ --  --\n help: add missing lifetime argument\n    |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                        ++++\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                        +++++++++\n \n error: aborting due to 24 previous errors\n "}]}