{"sha": "d049783b5d854ceea1dbdd2bd6ce129a95202c80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNDk3ODNiNWQ4NTRjZWVhMWRiZGQyYmQ2Y2UxMjlhOTUyMDJjODA=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-24T14:50:56Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-24T14:50:56Z"}, "message": "Simplify", "tree": {"sha": "31500482817856325fd5bd7476d4dfa867b37e5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31500482817856325fd5bd7476d4dfa867b37e5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d049783b5d854ceea1dbdd2bd6ce129a95202c80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d049783b5d854ceea1dbdd2bd6ce129a95202c80", "html_url": "https://github.com/rust-lang/rust/commit/d049783b5d854ceea1dbdd2bd6ce129a95202c80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d049783b5d854ceea1dbdd2bd6ce129a95202c80/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "066bc4f3a467ddf45954d71e970aa6c776fb9ea4", "url": "https://api.github.com/repos/rust-lang/rust/commits/066bc4f3a467ddf45954d71e970aa6c776fb9ea4", "html_url": "https://github.com/rust-lang/rust/commit/066bc4f3a467ddf45954d71e970aa6c776fb9ea4"}], "stats": {"total": 117, "additions": 64, "deletions": 53}, "files": [{"sha": "d28a80ac09a088dd26372b862edc8ad8ba885acf", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 64, "deletions": 53, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d049783b5d854ceea1dbdd2bd6ce129a95202c80/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d049783b5d854ceea1dbdd2bd6ce129a95202c80/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=d049783b5d854ceea1dbdd2bd6ce129a95202c80", "patch": "@@ -30,12 +30,12 @@ pub(crate) fn highlight_related(\n \n     let token = pick_best_token(syntax.token_at_offset(position.offset), |kind| match kind {\n         T![?] => 2, // prefer `?` when the cursor is sandwiched like `await$0?`\n-        T![await] | T![async] | T![->] | T![return] => 1,\n+        T![await] | T![async] | T![return] | T![->] => 1,\n         _ => 0,\n     })?;\n \n     match token.kind() {\n-        T![?] | T![return] | T![->] => highlight_exit_points(sema, token),\n+        T![return] | T![?] | T![->] => highlight_exit_points(sema, token),\n         T![await] | T![async] => highlight_yield_points(token),\n         _ => highlight_references(sema, &syntax, position),\n     }\n@@ -83,48 +83,43 @@ fn highlight_exit_points(\n     ) -> Option<Vec<HighlightedRange>> {\n         let mut highlights = Vec::new();\n         let body = body?;\n-        walk(&body, |node| {\n-            match_ast! {\n-                match node {\n-                    ast::ReturnExpr(expr) => if let Some(token) = expr.return_token() {\n-                        highlights.push(HighlightedRange {\n-                            access: None,\n-                            range: token.text_range(),\n-                        });\n-                    },\n-                    ast::TryExpr(try_) => if let Some(token) = try_.question_mark_token() {\n+        walk(&body, &mut |expr| {\n+            match expr {\n+                ast::Expr::ReturnExpr(expr) => {\n+                    if let Some(token) = expr.return_token() {\n+                        highlights\n+                            .push(HighlightedRange { access: None, range: token.text_range() });\n+                    }\n+                }\n+                ast::Expr::TryExpr(try_) => {\n+                    if let Some(token) = try_.question_mark_token() {\n+                        highlights\n+                            .push(HighlightedRange { access: None, range: token.text_range() });\n+                    }\n+                }\n+                ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n+                    if sema.type_of_expr(&expr).map_or(false, |ty| ty.is_never()) {\n                         highlights.push(HighlightedRange {\n                             access: None,\n-                            range: token.text_range(),\n+                            range: expr.syntax().text_range(),\n                         });\n-                    },\n-                    ast::Expr(expr) => match expr {\n-                        ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n-                            if sema.type_of_expr(&expr).map_or(false, |ty| ty.is_never()) {\n-                                highlights.push(HighlightedRange {\n-                                    access: None,\n-                                    range: expr.syntax().text_range(),\n-                                });\n-                            }\n-                        },\n-                        ast::Expr::EffectExpr(effect) => return effect.async_token().is_some() || effect.try_token().is_some(),\n-                        ast::Expr::ClosureExpr(_) => return true,\n-                        _ => (),\n-                    },\n-                    ast::Item(__) => return true,\n-                    // Don't look into const args\n-                    ast::Path(__) => return true,\n-                    _ => (),\n+                    }\n+                }\n+                ast::Expr::EffectExpr(effect) => {\n+                    return effect.async_token().is_some() || effect.try_token().is_some()\n                 }\n+                ast::Expr::ClosureExpr(_) => return true,\n+                _ => (),\n             }\n             false\n         });\n         let tail = match body {\n             ast::Expr::BlockExpr(b) => b.tail_expr(),\n             e => Some(e),\n         };\n+\n         if let Some(tail) = tail {\n-            highlights.push(HighlightedRange { access: None, range: tail.syntax().text_range() });\n+            highlights.push(HighlightedRange { access: None, range: tail.syntax().text_range() })\n         }\n         Some(highlights)\n     }\n@@ -133,7 +128,7 @@ fn highlight_exit_points(\n             match anc {\n                 ast::Fn(fn_) => hl(sema, fn_.body().map(ast::Expr::BlockExpr)),\n                 ast::ClosureExpr(closure) => hl(sema, closure.body()),\n-                ast::EffectExpr(effect) => if effect.async_token().is_some() || effect.try_token().is_some() {\n+                ast::EffectExpr(effect) => if matches!(effect.effect(), ast::Effect::Async(_) | ast::Effect::Try(_)| ast::Effect::Const(_)) {\n                     hl(sema, effect.block_expr().map(ast::Expr::BlockExpr))\n                 } else {\n                     continue;\n@@ -153,23 +148,23 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n         let mut highlights = Vec::new();\n         highlights.push(HighlightedRange { access: None, range: async_token?.text_range() });\n         if let Some(body) = body {\n-            walk(&body, |node| {\n-                match_ast! {\n-                    match node {\n-                        ast::AwaitExpr(expr) => if let Some(token) = expr.await_token() {\n-                            highlights.push(HighlightedRange {\n-                                access: None,\n-                                range: token.text_range(),\n-                            });\n-                        },\n-                        // All the following are different contexts so skip them\n-                        ast::EffectExpr(effect) => return effect.async_token().is_some() || effect.try_token().is_some(),\n-                        ast::ClosureExpr(__) => return true,\n-                        ast::Item(__) => return true,\n-                        // Don't look into const args\n-                        ast::Path(__) => return true,\n-                        _ => (),\n+            walk(&body, &mut |expr| {\n+                match expr {\n+                    ast::Expr::AwaitExpr(expr) => {\n+                        if let Some(token) = expr.await_token() {\n+                            highlights\n+                                .push(HighlightedRange { access: None, range: token.text_range() });\n+                        }\n+                    }\n+                    // All the following are different contexts so skip them\n+                    ast::Expr::EffectExpr(effect) => {\n+                        return matches!(\n+                            effect.effect(),\n+                            ast::Effect::Async(_) | ast::Effect::Try(_) | ast::Effect::Const(_)\n+                        )\n                     }\n+                    ast::Expr::ClosureExpr(__) => return true,\n+                    _ => (),\n                 }\n                 false\n             });\n@@ -190,16 +185,32 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n }\n \n /// Preorder walk the expression node skipping a node's subtrees if the callback returns `true` for the node.\n-fn walk(expr: &ast::Expr, mut cb: impl FnMut(SyntaxNode) -> bool) {\n+fn walk(expr: &ast::Expr, cb: &mut dyn FnMut(ast::Expr) -> bool) {\n     let mut preorder = expr.syntax().preorder();\n     while let Some(event) = preorder.next() {\n         let node = match event {\n             WalkEvent::Enter(node) => node,\n             WalkEvent::Leave(_) => continue,\n         };\n-        if cb(node) {\n-            preorder.skip_subtree();\n+        match ast::Stmt::cast(node.clone()) {\n+            Some(ast::Stmt::LetStmt(l)) => {\n+                if let Some(expr) = l.initializer() {\n+                    walk(&expr, cb);\n+                }\n+            }\n+            // Don't skip subtree since we want to process the expression behind this next\n+            Some(ast::Stmt::ExprStmt(_)) => continue,\n+            // skip inner items which might have their own expressions\n+            Some(ast::Stmt::Item(_)) => (),\n+            None => {\n+                if let Some(expr) = ast::Expr::cast(node) {\n+                    if !cb(expr) {\n+                        continue;\n+                    }\n+                }\n+            }\n         }\n+        preorder.skip_subtree();\n     }\n }\n \n@@ -434,7 +445,7 @@ fn foo() ->$0 u32 {\n     never();\n  // ^^^^^^^\n     never!();\n- // FIXME sema doesnt give us types for macrocalls\n+ // FIXME sema doesn't give us types for macrocalls\n \n     Never.never();\n  // ^^^^^^^^^^^^^"}]}