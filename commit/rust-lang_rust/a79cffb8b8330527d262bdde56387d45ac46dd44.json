{"sha": "a79cffb8b8330527d262bdde56387d45ac46dd44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3OWNmZmI4YjgzMzA1MjdkMjYyYmRkZTU2Mzg3ZDQ1YWM0NmRkNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-22T00:57:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-22T00:57:00Z"}, "message": "Auto merge of #50912 - varkor:exhaustive-integer-matching, r=arielb1\n\nExhaustive integer matching\n\nThis adds a new feature flag `exhaustive_integer_patterns` that enables exhaustive matching of integer types by their values. For example, the following is now accepted:\n```rust\n#![feature(exhaustive_integer_patterns)]\n#![feature(exclusive_range_pattern)]\n\nfn matcher(x: u8) {\n  match x { // ok\n    0 .. 32 => { /* foo */ }\n    32 => { /* bar */ }\n    33 ..= 255 => { /* baz */ }\n  }\n}\n```\nThis matching is permitted on all integer (signed/unsigned and char) types. Sensible error messages are also provided. For example:\n```rust\nfn matcher(x: u8) {\n  match x { //~ ERROR\n    0 .. 32 => { /* foo */ }\n  }\n}\n```\nresults in:\n```\nerror[E0004]: non-exhaustive patterns: `32u8...255u8` not covered\n --> matches.rs:3:9\n  |\n6 |   match x {\n  |         ^ pattern `32u8...255u8` not covered\n```\n\nThis implements https://github.com/rust-lang/rfcs/issues/1550 for https://github.com/rust-lang/rust/issues/50907. While there hasn't been a full RFC for this feature, it was suggested that this might be a feature that obviously complements the existing exhaustiveness checks (e.g. for `bool`) and so a feature gate would be sufficient for now.", "tree": {"sha": "449ba4ee567f5dff4b1c5f0d94be3203bae5a535", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/449ba4ee567f5dff4b1c5f0d94be3203bae5a535"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a79cffb8b8330527d262bdde56387d45ac46dd44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a79cffb8b8330527d262bdde56387d45ac46dd44", "html_url": "https://github.com/rust-lang/rust/commit/a79cffb8b8330527d262bdde56387d45ac46dd44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a79cffb8b8330527d262bdde56387d45ac46dd44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cbf339626e52e1e66a6df3097051bb981bfa964", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cbf339626e52e1e66a6df3097051bb981bfa964", "html_url": "https://github.com/rust-lang/rust/commit/1cbf339626e52e1e66a6df3097051bb981bfa964"}, {"sha": "6971c5d55d06c02c8f0b943b3d0b06ef2611c8ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/6971c5d55d06c02c8f0b943b3d0b06ef2611c8ac", "html_url": "https://github.com/rust-lang/rust/commit/6971c5d55d06c02c8f0b943b3d0b06ef2611c8ac"}], "stats": {"total": 1011, "additions": 927, "deletions": 84}, "files": [{"sha": "bafeb5dd12867c96c2184738daf90a6f3a025a02", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a79cffb8b8330527d262bdde56387d45ac46dd44", "patch": "@@ -2228,7 +2228,7 @@ pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Resul\n     }\n }\n \n-pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n+pub fn print_miri_value<'tcx, W: Write>(value: Value, ty: Ty<'tcx>, f: &mut W) -> fmt::Result {\n     use ty::TypeVariants::*;\n     // print some primitives\n     if let Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits, .. })) = value {"}, {"sha": "81f7d439feb253dde01cde4ec7b5c1d68f8f6e24", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 625, "deletions": 75, "changes": 700, "blob_url": "https://github.com/rust-lang/rust/blob/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=a79cffb8b8330527d262bdde56387d45ac46dd44", "patch": "@@ -8,6 +8,164 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/// This file includes the logic for exhaustiveness and usefulness checking for\n+/// pattern-matching. Specifically, given a list of patterns for a type, we can\n+/// tell whether:\n+/// (a) the patterns cover every possible constructor for the type [exhaustiveness]\n+/// (b) each pattern is necessary [usefulness]\n+///\n+/// The algorithm implemented here is a modified version of the one described in:\n+/// http://moscova.inria.fr/~maranget/papers/warn/index.html\n+/// However, to save future implementors from reading the original paper, I'm going\n+/// to summarise the algorithm here to hopefully save time and be a little clearer\n+/// (without being so rigorous).\n+///\n+/// The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n+/// are trying to compute a predicate `U(P, p_{m + 1})` where `P` is a list of patterns\n+/// of length `m` for a compound (product) type with `n` components (we refer to this as\n+/// a matrix). `U(P, p_{m + 1})` represents whether, given an existing list of patterns\n+/// `p_1 ..= p_m`, adding a new pattern will be \"useful\" (that is, cover previously-\n+/// uncovered values of the type).\n+///\n+/// If we have this predicate, then we can easily compute both exhaustiveness of an\n+/// entire set of patterns and the individual usefulness of each one.\n+/// (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e. adding a wildcard\n+/// match doesn't increase the number of values we're matching)\n+/// (b) a pattern `p_i` is not useful if `U(P[0..=(i-1), p_i)` is false (i.e. adding a\n+/// pattern to those that have come before it doesn't increase the number of values\n+/// we're matching).\n+///\n+/// For example, say we have the following:\n+/// ```\n+///     // x: (Option<bool>, Result<()>)\n+///     match x {\n+///         (Some(true), _) => {}\n+///         (None, Err(())) => {}\n+///         (None, Err(_)) => {}\n+///     }\n+/// ```\n+/// Here, the matrix `P` is 3 x 2 (rows x columns).\n+/// [\n+///     [Some(true), _],\n+///     [None, Err(())],\n+///     [None, Err(_)],\n+/// ]\n+/// We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n+/// `[Some(false), _]`, for instance). In addition, row 3 is not useful, because\n+/// all the values it covers are already covered by row 2.\n+///\n+/// To compute `U`, we must have two other concepts.\n+///     1. `S(c, P)` is a \"specialised matrix\", where `c` is a constructor (like `Some` or\n+///        `None`). You can think of it as filtering `P` to just the rows whose *first* pattern\n+///        can cover `c` (and expanding OR-patterns into distinct patterns), and then expanding\n+///        the constructor into all of its components.\n+///        The specialisation of a row vector is computed by `specialize`.\n+///\n+///        It is computed as follows. For each row `p_i` of P, we have four cases:\n+///             1.1. `p_(i,1) = c(r_1, .., r_a)`. Then `S(c, P)` has a corresponding row:\n+///                     r_1, .., r_a, p_(i,2), .., p_(i,n)\n+///             1.2. `p_(i,1) = c'(r_1, .., r_a')` where `c \u2260 c'`. Then `S(c, P)` has no\n+///                  corresponding row.\n+///             1.3. `p_(i,1) = _`. Then `S(c, P)` has a corresponding row:\n+///                     _, .., _, p_(i,2), .., p_(i,n)\n+///             1.4. `p_(i,1) = r_1 | r_2`. Then `S(c, P)` has corresponding rows inlined from:\n+///                     S(c, (r_1, p_(i,2), .., p_(i,n)))\n+///                     S(c, (r_2, p_(i,2), .., p_(i,n)))\n+///\n+///     2. `D(P)` is a \"default matrix\". This is used when we know there are missing\n+///        constructor cases, but there might be existing wildcard patterns, so to check the\n+///        usefulness of the matrix, we have to check all its *other* components.\n+///        The default matrix is computed inline in `is_useful`.\n+///\n+///         It is computed as follows. For each row `p_i` of P, we have three cases:\n+///             1.1. `p_(i,1) = c(r_1, .., r_a)`. Then `D(P)` has no corresponding row.\n+///             1.2. `p_(i,1) = _`. Then `D(P)` has a corresponding row:\n+///                     p_(i,2), .., p_(i,n)\n+///             1.3. `p_(i,1) = r_1 | r_2`. Then `D(P)` has corresponding rows inlined from:\n+///                     D((r_1, p_(i,2), .., p_(i,n)))\n+///                     D((r_2, p_(i,2), .., p_(i,n)))\n+///\n+///     Note that the OR-patterns are not always used directly in Rust, but are used to derive\n+///     the exhaustive integer matching rules, so they're written here for posterity.\n+///\n+/// The algorithm for computing `U`\n+/// -------------------------------\n+/// The algorithm is inductive (on the number of columns: i.e. components of tuple patterns).\n+/// That means we're going to check the components from left-to-right, so the algorithm\n+/// operates principally on the first component of the matrix and new pattern `p_{m + 1}`.\n+/// This algorithm is realised in the `is_useful` function.\n+///\n+/// Base case. (`n = 0`, i.e. an empty tuple pattern)\n+///     - If `P` already contains an empty pattern (i.e. if the number of patterns `m > 0`),\n+///       then `U(P, p_{m + 1})` is false.\n+///     - Otherwise, `P` must be empty, so `U(P, p_{m + 1})` is true.\n+///\n+/// Inductive step. (`n > 0`, i.e. whether there's at least one column\n+///                  [which may then be expanded into further columns later])\n+///     We're going to match on the new pattern, `p_{m + 1}`.\n+///         - If `p_{m + 1} == c(r_1, .., r_a)`, then we have a constructor pattern.\n+///           Thus, the usefulness of `p_{m + 1}` can be reduced to whether it is useful when\n+///           we ignore all the patterns in `P` that involve other constructors. This is where\n+///           `S(c, P)` comes in:\n+///           `U(P, p_{m + 1}) := U(S(c, P), S(c, p_{m + 1}))`\n+///           This special case is handled in `is_useful_specialized`.\n+///         - If `p_{m + 1} == _`, then we have two more cases:\n+///             + All the constructors of the first component of the type exist within\n+///               all the rows (after having expanded OR-patterns). In this case:\n+///               `U(P, p_{m + 1}) := \u2228(k \u03f5 constructors) U(S(k, P), S(k, p_{m + 1}))`\n+///               I.e. the pattern `p_{m + 1}` is only useful when all the constructors are\n+///               present *if* its later components are useful for the respective constructors\n+///               covered by `p_{m + 1}` (usually a single constructor, but all in the case of `_`).\n+///             + Some constructors are not present in the existing rows (after having expanded\n+///               OR-patterns). However, there might be wildcard patterns (`_`) present. Thus, we\n+///               are only really concerned with the other patterns leading with wildcards. This is\n+///               where `D` comes in:\n+///               `U(P, p_{m + 1}) := U(D(P), p_({m + 1},2), ..,  p_({m + 1},n))`\n+///         - If `p_{m + 1} == r_1 | r_2`, then the usefulness depends on each separately:\n+///           `U(P, p_{m + 1}) := U(P, (r_1, p_({m + 1},2), .., p_({m + 1},n)))\n+///                            || U(P, (r_2, p_({m + 1},2), .., p_({m + 1},n)))`\n+///\n+/// Modifications to the algorithm\n+/// ------------------------------\n+/// The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n+/// example uninhabited types and variable-length slice patterns. These are drawn attention to\n+/// throughout the code below. I'll make a quick note here about how exhaustive integer matching\n+/// is accounted for, though.\n+///\n+/// Exhaustive integer matching\n+/// ---------------------------\n+/// An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n+/// So to support exhaustive integer matching, we can make use of the logic in the paper for\n+/// OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n+/// they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n+/// that we have a constructor *of* constructors (the integers themselves). We then need to work\n+/// through all the inductive step rules above, deriving how the ranges would be treated as\n+/// OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n+/// There are really only four special cases here:\n+/// - When we match on a constructor that's actually a range, we have to treat it as if we would\n+///   an OR-pattern.\n+///     + It turns out that we can simply extend the case for single-value patterns in\n+///      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n+///      constructor.\n+///     + When the pattern itself is a range, you just want to tell whether any of the values in\n+///       the pattern range coincide with values in the constructor range, which is precisely\n+///       intersection.\n+///   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n+///   means that whenever the constructor is a value/range and the pattern is also a value/range,\n+///   we can simply use intersection to test usefulness.\n+/// - When we're testing for usefulness of a pattern and the pattern's first component is a\n+///   wildcard.\n+///     + If all the constructors appear in the matrix, we have a slight complication. By default,\n+///       the behaviour (i.e. a disjunction over specialised matrices for each constructor) is\n+///       invalid, because we want a disjunction over every *integer* in each range, not just a\n+///       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n+///       to form equivalence classes of subranges of the constructor range for which the behaviour\n+///       of the matrix `P` and new pattern `p_{m + 1}` are the same. This is described in more\n+///       detail in `split_grouped_constructors`.\n+///     + If some constructors are missing from the matrix, it turns out we don't need to do\n+///       anything special (because we know none of the integers are actually wildcards: i.e. we\n+///       can't span wildcards using ranges).\n+\n use self::Constructor::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n@@ -21,18 +179,22 @@ use super::{PatternFoldable, PatternFolder, compare_const_vals};\n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::layout::{Integer, IntegerExt};\n \n use rustc::mir::Field;\n use rustc::mir::interpret::ConstValue;\n use rustc::util::common::ErrorReported;\n \n+use syntax::attr::{SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n \n-use std::cmp::{self, Ordering};\n+use std::cmp::{self, Ordering, min, max};\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n+use std::ops::RangeInclusive;\n+use std::u128;\n \n pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n                                 -> &'a Pattern<'tcx>\n@@ -138,7 +300,6 @@ impl<'a, 'tcx> FromIterator<Vec<&'a Pattern<'tcx>>> for Matrix<'a, 'tcx> {\n     }\n }\n \n-//NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     /// The module in which the match occurs. This is necessary for\n@@ -165,7 +326,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             tcx,\n             module,\n             pattern_arena: &pattern_arena,\n-            byte_array_map: FxHashMap(),\n+            byte_array_map: FxHashMap::default(),\n         })\n     }\n \n@@ -273,7 +434,7 @@ impl<'tcx> Constructor<'tcx> {\n     }\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub enum Usefulness<'tcx> {\n     Useful,\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n@@ -289,7 +450,7 @@ impl<'tcx> Usefulness<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum WitnessPreference {\n     ConstructWitness,\n     LeaveOutWitness\n@@ -301,8 +462,39 @@ struct PatternContext<'tcx> {\n     max_slice_length: u64,\n }\n \n-/// A stack of patterns in reverse order of construction\n-#[derive(Clone)]\n+/// A witness of non-exhaustiveness for error reporting, represented\n+/// as a list of patterns (in reverse order of construction) with\n+/// wildcards inside to represent elements that can take any inhabitant\n+/// of the type as a value.\n+///\n+/// A witness against a list of patterns should have the same types\n+/// and length as the pattern matched against. Because Rust `match`\n+/// is always against a single pattern, at the end the witness will\n+/// have length 1, but in the middle of the algorithm, it can contain\n+/// multiple patterns.\n+///\n+/// For example, if we are constructing a witness for the match against\n+/// ```\n+/// struct Pair(Option<(u32, u32)>, bool);\n+///\n+/// match (p: Pair) {\n+///    Pair(None, _) => {}\n+///    Pair(_, false) => {}\n+/// }\n+/// ```\n+///\n+/// We'll perform the following steps:\n+/// 1. Start with an empty witness\n+///     `Witness(vec![])`\n+/// 2. Push a witness `Some(_)` against the `None`\n+///     `Witness(vec![Some(_)])`\n+/// 3. Push a witness `true` against the `false`\n+///     `Witness(vec![Some(_), true])`\n+/// 4. Apply the `Pair` constructor to the witnesses\n+///     `Witness(vec![Pair(Some(_), true)])`\n+///\n+/// The final `Pair(Some(_), true)` is then the resulting witness.\n+#[derive(Clone, Debug)]\n pub struct Witness<'tcx>(Vec<Pattern<'tcx>>);\n \n impl<'tcx> Witness<'tcx> {\n@@ -353,7 +545,7 @@ impl<'tcx> Witness<'tcx> {\n         let arity = constructor_arity(cx, ctor, ty);\n         let pat = {\n             let len = self.0.len() as u64;\n-            let mut pats = self.0.drain((len-arity) as usize..).rev();\n+            let mut pats = self.0.drain((len - arity) as usize..).rev();\n \n             match ty.sty {\n                 ty::TyAdt(..) |\n@@ -396,6 +588,7 @@ impl<'tcx> Witness<'tcx> {\n                 _ => {\n                     match *ctor {\n                         ConstantValue(value) => PatternKind::Constant { value },\n+                        ConstantRange(lo, hi, end) => PatternKind::Range { lo, hi, end },\n                         _ => PatternKind::Wild,\n                     }\n                 }\n@@ -417,18 +610,15 @@ impl<'tcx> Witness<'tcx> {\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n ///\n-/// This intentionally does not list ConstantValue specializations for\n-/// non-booleans, because we currently assume that there is always a\n-/// \"non-standard constant\" that matches. See issue #12483.\n-///\n /// We make sure to omit constructors that are statically impossible. eg for\n /// Option<!> we do not include Some(_) in the returned list of constructors.\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   pcx: PatternContext<'tcx>)\n                                   -> Vec<Constructor<'tcx>>\n {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n-    match pcx.ty.sty {\n+    let exhaustive_integer_patterns = cx.tcx.features().exhaustive_integer_patterns;\n+    let ctors = match pcx.ty.sty {\n         ty::TyBool => {\n             [true, false].iter().map(|&b| {\n                 ConstantValue(ty::Const::from_bool(cx.tcx, b))\n@@ -457,14 +647,45 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 .map(|v| Variant(v.did))\n                 .collect()\n         }\n+        ty::TyChar if exhaustive_integer_patterns => {\n+            let endpoint = |c: char| {\n+                let ty = ty::ParamEnv::empty().and(cx.tcx.types.char);\n+                ty::Const::from_bits(cx.tcx, c as u128, ty)\n+            };\n+            vec![\n+                // The valid Unicode Scalar Value ranges.\n+                ConstantRange(endpoint('\\u{0000}'), endpoint('\\u{D7FF}'), RangeEnd::Included),\n+                ConstantRange(endpoint('\\u{E000}'), endpoint('\\u{10FFFF}'), RangeEnd::Included),\n+            ]\n+        }\n+        ty::TyInt(ity) if exhaustive_integer_patterns => {\n+            // FIXME(49937): refactor these bit manipulations into interpret.\n+            let bits = Integer::from_attr(cx.tcx, SignedInt(ity)).size().bits() as u128;\n+            let min = 1u128 << (bits - 1);\n+            let max = (1u128 << (bits - 1)) - 1;\n+            let ty = ty::ParamEnv::empty().and(pcx.ty);\n+            vec![ConstantRange(ty::Const::from_bits(cx.tcx, min as u128, ty),\n+                               ty::Const::from_bits(cx.tcx, max as u128, ty),\n+                               RangeEnd::Included)]\n+        }\n+        ty::TyUint(uty) if exhaustive_integer_patterns => {\n+            // FIXME(49937): refactor these bit manipulations into interpret.\n+            let bits = Integer::from_attr(cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n+            let max = !0u128 >> (128 - bits);\n+            let ty = ty::ParamEnv::empty().and(pcx.ty);\n+            vec![ConstantRange(ty::Const::from_bits(cx.tcx, 0, ty),\n+                               ty::Const::from_bits(cx.tcx, max, ty),\n+                               RangeEnd::Included)]\n+        }\n         _ => {\n             if cx.is_uninhabited(pcx.ty) {\n                 vec![]\n             } else {\n                 vec![Single]\n             }\n         }\n-    }\n+    };\n+    ctors\n }\n \n fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n@@ -497,7 +718,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     //     `[true, ..]`\n     //     `[.., false]`\n     // Then any slice of length \u22651 that matches one of these two\n-    // patterns can be  be trivially turned to a slice of any\n+    // patterns can be trivially turned to a slice of any\n     // other length \u22651 that matches them and vice-versa - for\n     // but the slice from length 2 `[false, true]` that matches neither\n     // of these patterns can't be turned to a slice from length 1 that\n@@ -569,6 +790,189 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     cmp::max(max_fixed_len + 1, max_prefix_len + max_suffix_len)\n }\n \n+/// An inclusive interval, used for precise integer exhaustiveness checking.\n+/// `IntRange`s always store a contiguous range. This means that values are\n+/// encoded such that `0` encodes the minimum value for the integer,\n+/// regardless of the signedness.\n+/// For example, the pattern `-128...127i8` is encoded as `0..=255`.\n+/// This makes comparisons and arithmetic on interval endpoints much more\n+/// straightforward. See `signed_bias` for details.\n+///\n+/// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n+/// around the (offset) space: i.e. `range.lo <= range.hi`.\n+#[derive(Clone)]\n+struct IntRange<'tcx> {\n+    pub range: RangeInclusive<u128>,\n+    pub ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> IntRange<'tcx> {\n+    fn from_ctor(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                 ctor: &Constructor<'tcx>)\n+                 -> Option<IntRange<'tcx>> {\n+        match ctor {\n+            ConstantRange(lo, hi, end) => {\n+                assert_eq!(lo.ty, hi.ty);\n+                let ty = lo.ty;\n+                let env_ty = ty::ParamEnv::empty().and(ty);\n+                if let Some(lo) = lo.assert_bits(tcx, env_ty) {\n+                    if let Some(hi) = hi.assert_bits(tcx, env_ty) {\n+                        // Perform a shift if the underlying types are signed,\n+                        // which makes the interval arithmetic simpler.\n+                        let bias = IntRange::signed_bias(tcx, ty);\n+                        let (lo, hi) = (lo ^ bias, hi ^ bias);\n+                        // Make sure the interval is well-formed.\n+                        return if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n+                            None\n+                        } else {\n+                            let offset = (*end == RangeEnd::Excluded) as u128;\n+                            Some(IntRange { range: lo..=(hi - offset), ty })\n+                        };\n+                    }\n+                }\n+                None\n+            }\n+            ConstantValue(val) => {\n+                let ty = val.ty;\n+                if let Some(val) = val.assert_bits(tcx, ty::ParamEnv::empty().and(ty)) {\n+                    let bias = IntRange::signed_bias(tcx, ty);\n+                    let val = val ^ bias;\n+                    Some(IntRange { range: val..=val, ty })\n+                } else {\n+                    None\n+                }\n+            }\n+            Single | Variant(_) | Slice(_) => {\n+                None\n+            }\n+        }\n+    }\n+\n+    fn from_pat(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                pat: &Pattern<'tcx>)\n+                -> Option<IntRange<'tcx>> {\n+        Self::from_ctor(tcx, &match pat.kind {\n+            box PatternKind::Constant { value } => ConstantValue(value),\n+            box PatternKind::Range { lo, hi, end } => ConstantRange(lo, hi, end),\n+            _ => return None,\n+        })\n+    }\n+\n+    // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n+    fn signed_bias(tcx: TyCtxt<'_, 'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n+        match ty.sty {\n+            ty::TyInt(ity) => {\n+                let bits = Integer::from_attr(tcx, SignedInt(ity)).size().bits() as u128;\n+                1u128 << (bits - 1)\n+            }\n+            _ => 0\n+        }\n+    }\n+\n+    /// Convert a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n+    fn range_to_ctor(\n+        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        ty: Ty<'tcx>,\n+        r: RangeInclusive<u128>,\n+    ) -> Constructor<'tcx> {\n+        let bias = IntRange::signed_bias(tcx, ty);\n+        let ty = ty::ParamEnv::empty().and(ty);\n+        let (lo, hi) = r.into_inner();\n+        if lo == hi {\n+            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty))\n+        } else {\n+            ConstantRange(ty::Const::from_bits(tcx, lo ^ bias, ty),\n+                          ty::Const::from_bits(tcx, hi ^ bias, ty),\n+                          RangeEnd::Included)\n+        }\n+    }\n+\n+    /// Return a collection of ranges that spans the values covered by `ranges`, subtracted\n+    /// by the values covered by `self`: i.e. `ranges \\ self` (in set notation).\n+    fn subtract_from(self,\n+                     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                     ranges: Vec<Constructor<'tcx>>)\n+                     -> Vec<Constructor<'tcx>> {\n+        let ranges = ranges.into_iter().filter_map(|r| {\n+            IntRange::from_ctor(tcx, &r).map(|i| i.range)\n+        });\n+        let mut remaining_ranges = vec![];\n+        let ty = self.ty;\n+        let (lo, hi) = self.range.into_inner();\n+        for subrange in ranges {\n+            let (subrange_lo, subrange_hi) = subrange.into_inner();\n+            if lo > subrange_hi || subrange_lo > hi  {\n+                // The pattern doesn't intersect with the subrange at all,\n+                // so the subrange remains untouched.\n+                remaining_ranges.push(Self::range_to_ctor(tcx, ty, subrange_lo..=subrange_hi));\n+            } else {\n+                if lo > subrange_lo {\n+                    // The pattern intersects an upper section of the\n+                    // subrange, so a lower section will remain.\n+                    remaining_ranges.push(Self::range_to_ctor(tcx, ty, subrange_lo..=(lo - 1)));\n+                }\n+                if hi < subrange_hi {\n+                    // The pattern intersects a lower section of the\n+                    // subrange, so an upper section will remain.\n+                    remaining_ranges.push(Self::range_to_ctor(tcx, ty, (hi + 1)..=subrange_hi));\n+                }\n+            }\n+        }\n+        remaining_ranges\n+    }\n+\n+    fn intersection(&self, other: &Self) -> Option<Self> {\n+        let ty = self.ty;\n+        let (lo, hi) = (*self.range.start(), *self.range.end());\n+        let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n+        if lo <= other_hi && other_lo <= hi {\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// Return a set of constructors equivalent to `all_ctors \\ used_ctors`.\n+fn compute_missing_ctors<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    all_ctors: &Vec<Constructor<'tcx>>,\n+    used_ctors: &Vec<Constructor<'tcx>>,\n+) -> Vec<Constructor<'tcx>> {\n+    let mut missing_ctors = vec![];\n+\n+    for req_ctor in all_ctors {\n+        let mut refined_ctors = vec![req_ctor.clone()];\n+        for used_ctor in used_ctors {\n+            if used_ctor == req_ctor {\n+                // If a constructor appears in a `match` arm, we can\n+                // eliminate it straight away.\n+                refined_ctors = vec![]\n+            } else if tcx.features().exhaustive_integer_patterns {\n+                if let Some(interval) = IntRange::from_ctor(tcx, used_ctor) {\n+                    // Refine the required constructors for the type by subtracting\n+                    // the range defined by the current constructor pattern.\n+                    refined_ctors = interval.subtract_from(tcx, refined_ctors);\n+                }\n+            }\n+\n+            // If the constructor patterns that have been considered so far\n+            // already cover the entire range of values, then we the\n+            // constructor is not missing, and we can move on to the next one.\n+            if refined_ctors.is_empty() {\n+                break;\n+            }\n+        }\n+        // If a constructor has not been matched, then it is missing.\n+        // We add `refined_ctors` instead of `req_ctor`, because then we can\n+        // provide more detailed error information about precisely which\n+        // ranges have been omitted.\n+        missing_ctors.extend(refined_ctors);\n+    }\n+\n+    missing_ctors\n+}\n+\n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n /// The algorithm from the paper has been modified to correctly handle empty\n /// types. The changes are:\n@@ -637,16 +1041,15 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // FIXME: this might lead to \"unstable\" behavior with macro hygiene\n         // introducing uninhabited patterns for inaccessible fields. We\n         // need to figure out how to model that.\n-        ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error())\n-            .unwrap_or(v[0].ty),\n+        ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error()).unwrap_or(v[0].ty),\n         max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0])))\n     };\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n \n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n         debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n-        constructors.into_iter().map(|c|\n+        split_grouped_constructors(cx.tcx, constructors, matrix, pcx.ty).into_iter().map(|c|\n             is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n         ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n@@ -656,11 +1059,10 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             pat_constructors(cx, row[0], pcx).unwrap_or(vec![])\n         }).collect();\n         debug!(\"used_ctors = {:#?}\", used_ctors);\n+        // `all_ctors` are all the constructors for the given type, which\n+        // should all be represented (or caught with the wild pattern `_`).\n         let all_ctors = all_constructors(cx, pcx);\n         debug!(\"all_ctors = {:#?}\", all_ctors);\n-        let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n-            !used_ctors.contains(*c)\n-        }).cloned().collect();\n \n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n@@ -681,10 +1083,12 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // feature flag is not present, so this is only\n         // needed for that case.\n \n-        let is_privately_empty =\n-            all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n-        let is_declared_nonexhaustive =\n-            cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n+        // Find those constructors that are not matched by any non-wildcard patterns in the\n+        // current column.\n+        let missing_ctors = compute_missing_ctors(cx.tcx, &all_ctors, &used_ctors);\n+\n+        let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n+        let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n         debug!(\"missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n                missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n \n@@ -693,7 +1097,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive;\n \n         if missing_ctors.is_empty() && !is_non_exhaustive {\n-            all_ctors.into_iter().map(|c| {\n+            split_grouped_constructors(cx.tcx, all_ctors, matrix, pcx.ty).into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         } else {\n@@ -753,7 +1157,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     // `used_ctors` is empty.\n                     let new_witnesses = if is_non_exhaustive || used_ctors.is_empty() {\n                         // All constructors are unused. Add wild patterns\n-                        // rather than each individual constructor\n+                        // rather than each individual constructor.\n                         pats.into_iter().map(|mut witness| {\n                             witness.0.push(Pattern {\n                                 ty: pcx.ty,\n@@ -765,6 +1169,10 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     } else {\n                         pats.into_iter().flat_map(|witness| {\n                             missing_ctors.iter().map(move |ctor| {\n+                                // Extends the witness with a \"wild\" version of this\n+                                // constructor, that matches everything that can be built with\n+                                // it. For example, if `ctor` is a `Constructor::Variant` for\n+                                // `Option::Some`, this pushes the witness for `Some(_)`.\n                                 witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n                             })\n                         }).collect()\n@@ -777,14 +1185,16 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n+/// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e. `is_useful` applied\n+/// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     v: &[&'p Pattern<'tcx>],\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n-    witness: WitnessPreference) -> Usefulness<'tcx>\n-{\n+    witness: WitnessPreference,\n+) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n     let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n@@ -806,7 +1216,7 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n                     .collect()\n             ),\n             result => result\n-        },\n+        }\n         None => NotUseful\n     }\n }\n@@ -818,23 +1228,20 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n /// Slice patterns, however, can match slices of different lengths. For instance,\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n-/// Returns None in case of a catch-all, which can't be specialized.\n+/// Returns `None` in case of a catch-all, which can't be specialized.\n fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt,\n                           pat: &Pattern<'tcx>,\n                           pcx: PatternContext)\n                           -> Option<Vec<Constructor<'tcx>>>\n {\n     match *pat.kind {\n-        PatternKind::Binding { .. } | PatternKind::Wild =>\n-            None,\n-        PatternKind::Leaf { .. } | PatternKind::Deref { .. } =>\n-            Some(vec![Single]),\n-        PatternKind::Variant { adt_def, variant_index, .. } =>\n-            Some(vec![Variant(adt_def.variants[variant_index].did)]),\n-        PatternKind::Constant { value } =>\n-            Some(vec![ConstantValue(value)]),\n-        PatternKind::Range { lo, hi, end } =>\n-            Some(vec![ConstantRange(lo, hi, end)]),\n+        PatternKind::Binding { .. } | PatternKind::Wild => None,\n+        PatternKind::Leaf { .. } | PatternKind::Deref { .. } => Some(vec![Single]),\n+        PatternKind::Variant { adt_def, variant_index, .. } => {\n+            Some(vec![Variant(adt_def.variants[variant_index].did)])\n+        }\n+        PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n+        PatternKind::Range { lo, hi, end } => Some(vec![ConstantRange(lo, hi, end)]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n             ty::TyArray(_, length) => Some(vec![\n                 Slice(length.unwrap_usize(cx.tcx))\n@@ -970,13 +1377,167 @@ fn slice_pat_covered_by_constructor<'tcx>(\n     Ok(true)\n }\n \n+// Whether to evaluate a constructor using exhaustive integer matching. This is true if the\n+// constructor is a range or constant with an integer type.\n+fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n+    if tcx.features().exhaustive_integer_patterns {\n+        if let ConstantValue(value) | ConstantRange(value, _, _) = ctor {\n+            if let ty::TyChar | ty::TyInt(_) | ty::TyUint(_) = value.ty.sty {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// For exhaustive integer matching, some constructors are grouped within other constructors\n+/// (namely integer typed values are grouped within ranges). However, when specialising these\n+/// constructors, we want to be specialising for the underlying constructors (the integers), not\n+/// the groups (the ranges). Thus we need to split the groups up. Splitting them up na\u00efvely would\n+/// mean creating a separate constructor for every single value in the range, which is clearly\n+/// impractical. However, observe that for some ranges of integers, the specialisation will be\n+/// identical across all values in that range (i.e. there are equivalence classes of ranges of\n+/// constructors based on their `is_useful_specialised` outcome). These classes are grouped by\n+/// the patterns that apply to them (in the matrix `P`). We can split the range whenever the\n+/// patterns that apply to that range (specifically: the patterns that *intersect* with that range)\n+/// change.\n+/// Our solution, therefore, is to split the range constructor into subranges at every single point\n+/// the group of intersecting patterns changes (using the method described below).\n+/// And voil\u00e0! We're testing precisely those ranges that we need to, without any exhaustive matching\n+/// on actual integers. The nice thing about this is that the number of subranges is linear in the\n+/// number of rows in the matrix (i.e. the number of cases in the `match` statement), so we don't\n+/// need to be worried about matching over gargantuan ranges.\n+///\n+/// Essentially, given the first column of a matrix representing ranges, looking like the following:\n+///\n+/// |------|  |----------| |-------|    ||\n+///    |-------| |-------|            |----| ||\n+///       |---------|\n+///\n+/// We split the ranges up into equivalence classes so the ranges are no longer overlapping:\n+///\n+/// |--|--|||-||||--||---|||-------|  |-|||| ||\n+///\n+/// The logic for determining how to split the ranges is fairly straightforward: we calculate\n+/// boundaries for each interval range, sort them, then create constructors for each new interval\n+/// between every pair of boundary points. (This essentially sums up to performing the intuitive\n+/// merging operation depicted above.)\n+fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ctors: Vec<Constructor<'tcx>>,\n+    &Matrix(ref m): &Matrix<'p, 'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Vec<Constructor<'tcx>> {\n+    let mut split_ctors = Vec::with_capacity(ctors.len());\n+\n+    for ctor in ctors.into_iter() {\n+        match ctor {\n+            // For now, only ranges may denote groups of \"subconstructors\", so we only need to\n+            // special-case constant ranges.\n+            ConstantRange(..) if should_treat_range_exhaustively(tcx, &ctor) => {\n+                // We only care about finding all the subranges within the range of the constructor\n+                // range. Anything else is irrelevant, because it is guaranteed to result in\n+                // `NotUseful`, which is the default case anyway, and can be ignored.\n+                let ctor_range = IntRange::from_ctor(tcx, &ctor).unwrap();\n+\n+                /// Represents a border between 2 integers. Because the intervals spanning borders\n+                /// must be able to cover every integer, we need to be able to represent\n+                /// 2^128 + 1 such borders.\n+                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+                enum Border {\n+                    JustBefore(u128),\n+                    AfterMax,\n+                }\n+\n+                // A function for extracting the borders of an integer interval.\n+                fn range_borders(r: IntRange<'_>) -> impl Iterator<Item = Border> {\n+                    let (lo, hi) = r.range.into_inner();\n+                    let from = Border::JustBefore(lo);\n+                    let to = match hi.checked_add(1) {\n+                        Some(m) => Border::JustBefore(m),\n+                        None => Border::AfterMax,\n+                    };\n+                    vec![from, to].into_iter()\n+                }\n+\n+                // `borders` is the set of borders between equivalence classes: each equivalence\n+                // class lies between 2 borders.\n+                let row_borders = m.iter()\n+                    .flat_map(|row| IntRange::from_pat(tcx, row[0]))\n+                    .flat_map(|range| ctor_range.intersection(&range))\n+                    .flat_map(|range| range_borders(range));\n+                let ctor_borders = range_borders(ctor_range.clone());\n+                let mut borders: Vec<_> = row_borders.chain(ctor_borders).collect();\n+                borders.sort_unstable();\n+\n+                // We're going to iterate through every pair of borders, making sure that each\n+                // represents an interval of nonnegative length, and convert each such interval\n+                // into a constructor.\n+                for IntRange { range, .. } in borders.windows(2).filter_map(|window| {\n+                    match (window[0], window[1]) {\n+                        (Border::JustBefore(n), Border::JustBefore(m)) => {\n+                            if n < m {\n+                                Some(IntRange { range: n..=(m - 1), ty })\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                        (Border::JustBefore(n), Border::AfterMax) => {\n+                            Some(IntRange { range: n..=u128::MAX, ty })\n+                        }\n+                        (Border::AfterMax, _) => None,\n+                    }\n+                }) {\n+                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, range));\n+                }\n+            }\n+            // Any other constructor can be used unchanged.\n+            _ => split_ctors.push(ctor),\n+        }\n+    }\n+\n+    split_ctors\n+}\n+\n+/// Check whether there exists any shared value in either `ctor` or `pat` by intersecting them.\n+fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ctor: &Constructor<'tcx>,\n+    pat: &'p Pattern<'tcx>,\n+) -> Option<Vec<&'p Pattern<'tcx>>> {\n+    if should_treat_range_exhaustively(tcx, ctor) {\n+        match (IntRange::from_ctor(tcx, ctor), IntRange::from_pat(tcx, pat)) {\n+            (Some(ctor), Some(pat)) => {\n+                ctor.intersection(&pat).map(|_| {\n+                    let (pat_lo, pat_hi) = pat.range.into_inner();\n+                    let (ctor_lo, ctor_hi) = ctor.range.into_inner();\n+                    assert!(pat_lo <= ctor_lo && ctor_hi <= pat_hi);\n+                    vec![]\n+                })\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        // Fallback for non-ranges and ranges that involve floating-point numbers, which are not\n+        // conveniently handled by `IntRange`. For these cases, the constructor may not be a range\n+        // so intersection actually devolves into being covered by the pattern.\n+        match constructor_covered_by_range(tcx, ctor, pat) {\n+            Ok(true) => Some(vec![]),\n+            Ok(false) | Err(ErrorReported) => None,\n+        }\n+    }\n+}\n+\n fn constructor_covered_by_range<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ctor: &Constructor<'tcx>,\n-    from: &'tcx ty::Const<'tcx>, to: &'tcx ty::Const<'tcx>,\n-    end: RangeEnd,\n-    ty: Ty<'tcx>,\n+    pat: &Pattern<'tcx>,\n ) -> Result<bool, ErrorReported> {\n+    let (from, to, end, ty) = match pat.kind {\n+        box PatternKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n+        box PatternKind::Range { lo, hi, end } => (lo, hi, end, lo.ty),\n+        _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n+    };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n     let cmp_from = |c_from| compare_const_vals(tcx, c_from, from, ty::ParamEnv::empty().and(ty))\n         .map(|res| res != Ordering::Less);\n@@ -1040,15 +1601,14 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     r: &[&'p Pattern<'tcx>],\n     constructor: &Constructor<'tcx>,\n-    wild_patterns: &[&'p Pattern<'tcx>])\n-    -> Option<Vec<&'p Pattern<'tcx>>>\n-{\n+    wild_patterns: &[&'p Pattern<'tcx>],\n+) -> Option<Vec<&'p Pattern<'tcx>>> {\n     let pat = &r[0];\n \n     let head: Option<Vec<&Pattern>> = match *pat.kind {\n         PatternKind::Binding { .. } | PatternKind::Wild => {\n             Some(wild_patterns.to_owned())\n-        },\n+        }\n \n         PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n@@ -1062,6 +1622,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n         PatternKind::Leaf { ref subpatterns } => {\n             Some(patterns_for_variant(subpatterns, wild_patterns))\n         }\n+\n         PatternKind::Deref { ref subpattern } => {\n             Some(vec![subpattern])\n         }\n@@ -1090,30 +1651,21 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                         span_bug!(pat.span,\n                         \"unexpected const-val {:?} with ctor {:?}\", value, constructor)\n                     }\n-                },\n+                }\n                 _ => {\n-                    match constructor_covered_by_range(\n-                        cx.tcx,\n-                        constructor, value, value, RangeEnd::Included,\n-                        value.ty,\n-                            ) {\n-                        Ok(true) => Some(vec![]),\n-                        Ok(false) => None,\n-                        Err(ErrorReported) => None,\n-                    }\n+                    // If the constructor is a:\n+                    //      Single value: add a row if the constructor equals the pattern.\n+                    //      Range: add a row if the constructor contains the pattern.\n+                    constructor_intersects_pattern(cx.tcx, constructor, pat)\n                 }\n             }\n         }\n \n-        PatternKind::Range { lo, hi, ref end } => {\n-            match constructor_covered_by_range(\n-                cx.tcx,\n-                constructor, lo, hi, end.clone(), lo.ty,\n-            ) {\n-                Ok(true) => Some(vec![]),\n-                Ok(false) => None,\n-                Err(ErrorReported) => None,\n-            }\n+        PatternKind::Range { .. } => {\n+            // If the constructor is a:\n+            //      Single value: add a row if the pattern contains the constructor.\n+            //      Range: add a row if the constructor intersects the pattern.\n+            constructor_intersects_pattern(cx.tcx, constructor, pat)\n         }\n \n         PatternKind::Array { ref prefix, ref slice, ref suffix } |\n@@ -1123,14 +1675,12 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     let pat_len = prefix.len() + suffix.len();\n                     if let Some(slice_count) = wild_patterns.len().checked_sub(pat_len) {\n                         if slice_count == 0 || slice.is_some() {\n-                            Some(\n-                                prefix.iter().chain(\n-                                wild_patterns.iter().map(|p| *p)\n-                                                    .skip(prefix.len())\n-                                                    .take(slice_count)\n-                                                    .chain(\n-                                suffix.iter()\n-                            )).collect())\n+                            Some(prefix.iter().chain(\n+                                    wild_patterns.iter().map(|p| *p)\n+                                                 .skip(prefix.len())\n+                                                 .take(slice_count)\n+                                                 .chain(suffix.iter())\n+                            ).collect())\n                         } else {\n                             None\n                         }"}, {"sha": "7f6298fd1717391e461ef2fa44dafbf33b8e22d4", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=a79cffb8b8330527d262bdde56387d45ac46dd44", "patch": "@@ -272,7 +272,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                                                 self.tables);\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n-            let pats : Matrix = vec![vec![\n+            let pats: Matrix = vec![vec![\n                 expand_pattern(cx, pattern)\n             ]].into_iter().collect();\n \n@@ -391,7 +391,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                     printed_if_let_err = true;\n                                 }\n                             }\n-                        },\n+                        }\n \n                         hir::MatchSource::WhileLetDesugar => {\n                             // check which arm we're on."}, {"sha": "7ec9373130419e82fa26794384fce1efef9cc16a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=a79cffb8b8330527d262bdde56387d45ac46dd44", "patch": "@@ -233,7 +233,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             PatternKind::Range { lo, hi, end } => {\n                 fmt_const_val(f, lo)?;\n                 match end {\n-                    RangeEnd::Included => write!(f, \"...\")?,\n+                    RangeEnd::Included => write!(f, \"..=\")?,\n                     RangeEnd::Excluded => write!(f, \"..\")?,\n                 }\n                 fmt_const_val(f, hi)\n@@ -368,9 +368,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                     \"lower range bound must be less than upper\",\n                                 );\n                                 PatternKind::Wild\n-                            },\n-                            (RangeEnd::Included, None) |\n-                            (RangeEnd::Included, Some(Ordering::Greater)) => {\n+                            }\n+                            (RangeEnd::Included, Some(Ordering::Equal)) => {\n+                                PatternKind::Constant { value: lo }\n+                            }\n+                            (RangeEnd::Included, Some(Ordering::Less)) => {\n+                                PatternKind::Range { lo, hi, end }\n+                            }\n+                            (RangeEnd::Included, _) => {\n                                 let mut err = struct_span_err!(\n                                     self.tcx.sess,\n                                     lo_expr.span,\n@@ -390,8 +395,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 }\n                                 err.emit();\n                                 PatternKind::Wild\n-                            },\n-                            (RangeEnd::Included, Some(_)) => PatternKind::Range { lo, hi, end },\n+                            }\n                         }\n                     }\n                     _ => PatternKind::Wild"}, {"sha": "05494131f32e4c802031126871fdb9816767b1f9", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=a79cffb8b8330527d262bdde56387d45ac46dd44", "patch": "@@ -36,6 +36,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(unicode_internals)]\n #![feature(step_trait)]\n #![feature(slice_concat_ext)]\n+#![feature(if_while_or_patterns)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "71ad118ed8eacf9ec09e5f56fd8186e1af402a68", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a79cffb8b8330527d262bdde56387d45ac46dd44", "patch": "@@ -471,6 +471,9 @@ declare_features! (\n     // 'a: { break 'a; }\n     (active, label_break_value, \"1.28.0\", Some(48594), None),\n \n+    // Integer match exhaustiveness checking\n+    (active, exhaustive_integer_patterns, \"1.30.0\", Some(50907), None),\n+\n     // #[panic_implementation]\n     (active, panic_implementation, \"1.28.0\", Some(44489), None),\n "}, {"sha": "7825aaa291286c08ea26b202ac43af8e83308a63", "filename": "src/test/ui/exhaustive_integer_patterns.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs?ref=a79cffb8b8330527d262bdde56387d45ac46dd44", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(exhaustive_integer_patterns)]\n+#![feature(exclusive_range_pattern)]\n+#![deny(unreachable_patterns)]\n+\n+use std::{char, usize, u8, u16, u32, u64, u128, isize, i8, i16, i32, i64, i128};\n+\n+fn main() {\n+    let x: u8 = 0;\n+\n+    // A single range covering the entire domain.\n+    match x {\n+        0 ..= 255 => {} // ok\n+    }\n+\n+    // A combination of ranges and values.\n+    // These are currently allowed to be overlapping.\n+    match x {\n+        0 ..= 32 => {}\n+        33 => {}\n+        34 .. 128 => {}\n+        100 ..= 200 => {}\n+        200 => {} //~ ERROR unreachable pattern\n+        201 ..= 255 => {}\n+    }\n+\n+    // An incomplete set of values.\n+    match x { //~ ERROR non-exhaustive patterns\n+        0 .. 128 => {}\n+    }\n+\n+    // A more incomplete set of values.\n+    match x { //~ ERROR non-exhaustive patterns\n+        0 ..= 10 => {}\n+        20 ..= 30 => {}\n+        35 => {}\n+        70 .. 255 => {}\n+    }\n+\n+    let x: i8 = 0;\n+    match x { //~ ERROR non-exhaustive patterns\n+        -7 => {}\n+        -5..=120 => {}\n+        -2..=20 => {} //~ ERROR unreachable pattern\n+        125 => {}\n+    }\n+\n+    // Let's test other types too!\n+    let c: char = '\\u{0}';\n+    match c {\n+        '\\u{0}' ..= char::MAX => {} // ok\n+    }\n+\n+    // We can actually get away with just covering the\n+    // following two ranges, which correspond to all\n+    // valid Unicode Scalar Values.\n+    match c {\n+        '\\u{0000}' ..= '\\u{D7FF}' => {}\n+        '\\u{E000}' ..= '\\u{10_FFFF}' => {}\n+    }\n+\n+    match 0usize {\n+        0 ..= usize::MAX => {} // ok\n+    }\n+\n+    match 0u16 {\n+        0 ..= u16::MAX => {} // ok\n+    }\n+\n+    match 0u32 {\n+        0 ..= u32::MAX => {} // ok\n+    }\n+\n+    match 0u64 {\n+        0 ..= u64::MAX => {} // ok\n+    }\n+\n+    match 0u128 {\n+        0 ..= u128::MAX => {} // ok\n+    }\n+\n+    match 0isize {\n+        isize::MIN ..= isize::MAX => {} // ok\n+    }\n+\n+    match 0i8 {\n+        -128 ..= 127 => {} // ok\n+    }\n+\n+    match 0i8 { //~ ERROR non-exhaustive patterns\n+        -127 ..= 127 => {}\n+    }\n+\n+    match 0i16 {\n+        i16::MIN ..= i16::MAX => {} // ok\n+    }\n+\n+    match 0i16 { //~ ERROR non-exhaustive patterns\n+        i16::MIN ..= -1 => {}\n+        1 ..= i16::MAX => {}\n+    }\n+\n+    match 0i32 {\n+        i32::MIN ..= i32::MAX => {} // ok\n+    }\n+\n+    match 0i64 {\n+        i64::MIN ..= i64::MAX => {} // ok\n+    }\n+\n+    match 0i128 {\n+        i128::MIN ..= i128::MAX => {} // ok\n+    }\n+\n+    // Make sure that guards don't factor into the exhaustiveness checks.\n+    match 0u8 { //~ ERROR non-exhaustive patterns\n+        0 .. 128 => {}\n+        128 ..= 255 if true => {}\n+    }\n+\n+    match 0u8 {\n+        0 .. 128 => {}\n+        128 ..= 255 if false => {}\n+        128 ..= 255 => {} // ok, because previous arm was guarded\n+    }\n+\n+    // Now things start getting a bit more interesting. Testing products!\n+    match (0u8, Some(())) { //~ ERROR non-exhaustive patterns\n+        (1, _) => {}\n+        (_, None) => {}\n+    }\n+\n+    match (0u8, true) { //~ ERROR non-exhaustive patterns\n+        (0 ..= 125, false) => {}\n+        (128 ..= 255, false) => {}\n+        (0 ..= 255, true) => {}\n+    }\n+\n+    match (0u8, true) { // ok\n+        (0 ..= 125, false) => {}\n+        (128 ..= 255, false) => {}\n+        (0 ..= 255, true) => {}\n+        (125 .. 128, false) => {}\n+    }\n+\n+    match 0u8 { // ok\n+        0 .. 2 => {}\n+        1 ..= 2 => {}\n+        _ => {}\n+    }\n+\n+    const LIM: u128 = u128::MAX - 1;\n+    match 0u128 { //~ ERROR non-exhaustive patterns\n+        0 ..= LIM => {}\n+    }\n+\n+    match 0u128 { //~ ERROR non-exhaustive patterns\n+        0 ..= 4 => {}\n+    }\n+\n+    match 0u128 { //~ ERROR non-exhaustive patterns\n+        4 ..= u128::MAX => {}\n+    }\n+}"}, {"sha": "44b05a12aebd2d4b4f0aa66f3d90eb88dea51e52", "filename": "src/test/ui/exhaustive_integer_patterns.stderr", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr?ref=a79cffb8b8330527d262bdde56387d45ac46dd44", "patch": "@@ -0,0 +1,87 @@\n+error: unreachable pattern\n+  --> $DIR/exhaustive_integer_patterns.rs:32:9\n+   |\n+LL |         200 => {} //~ ERROR unreachable pattern\n+   |         ^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/exhaustive_integer_patterns.rs:13:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0004]: non-exhaustive patterns: `128u8..=255u8` not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:37:11\n+   |\n+LL |     match x { //~ ERROR non-exhaustive patterns\n+   |           ^ pattern `128u8..=255u8` not covered\n+\n+error[E0004]: non-exhaustive patterns: `11u8..=19u8`, `31u8..=34u8`, `36u8..=69u8` and 1 more not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:42:11\n+   |\n+LL |     match x { //~ ERROR non-exhaustive patterns\n+   |           ^ patterns `11u8..=19u8`, `31u8..=34u8`, `36u8..=69u8` and 1 more not covered\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustive_integer_patterns.rs:53:9\n+   |\n+LL |         -2..=20 => {} //~ ERROR unreachable pattern\n+   |         ^^^^^^^\n+\n+error[E0004]: non-exhaustive patterns: `-128i8..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:50:11\n+   |\n+LL |     match x { //~ ERROR non-exhaustive patterns\n+   |           ^ patterns `-128i8..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `-128i8` not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:99:11\n+   |\n+LL |     match 0i8 { //~ ERROR non-exhaustive patterns\n+   |           ^^^ pattern `-128i8` not covered\n+\n+error[E0004]: non-exhaustive patterns: `0i16` not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:107:11\n+   |\n+LL |     match 0i16 { //~ ERROR non-exhaustive patterns\n+   |           ^^^^ pattern `0i16` not covered\n+\n+error[E0004]: non-exhaustive patterns: `128u8..=255u8` not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:125:11\n+   |\n+LL |     match 0u8 { //~ ERROR non-exhaustive patterns\n+   |           ^^^ pattern `128u8..=255u8` not covered\n+\n+error[E0004]: non-exhaustive patterns: `(0u8, Some(_))` and `(2u8..=255u8, Some(_))` not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:137:11\n+   |\n+LL |     match (0u8, Some(())) { //~ ERROR non-exhaustive patterns\n+   |           ^^^^^^^^^^^^^^^ patterns `(0u8, Some(_))` and `(2u8..=255u8, Some(_))` not covered\n+\n+error[E0004]: non-exhaustive patterns: `(126u8..=127u8, false)` not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:142:11\n+   |\n+LL |     match (0u8, true) { //~ ERROR non-exhaustive patterns\n+   |           ^^^^^^^^^^^ pattern `(126u8..=127u8, false)` not covered\n+\n+error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211455u128` not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:162:11\n+   |\n+LL |     match 0u128 { //~ ERROR non-exhaustive patterns\n+   |           ^^^^^ pattern `340282366920938463463374607431768211455u128` not covered\n+\n+error[E0004]: non-exhaustive patterns: `5u128..=340282366920938463463374607431768211455u128` not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:166:11\n+   |\n+LL |     match 0u128 { //~ ERROR non-exhaustive patterns\n+   |           ^^^^^ pattern `5u128..=340282366920938463463374607431768211455u128` not covered\n+\n+error[E0004]: non-exhaustive patterns: `0u128..=3u128` not covered\n+  --> $DIR/exhaustive_integer_patterns.rs:170:11\n+   |\n+LL |     match 0u128 { //~ ERROR non-exhaustive patterns\n+   |           ^^^^^ pattern `0u128..=3u128` not covered\n+\n+error: aborting due to 13 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "3aa1522945548e1cf487580278cbb17a1c1b013e", "filename": "src/test/ui/feature-gate-exhaustive_integer_patterns.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Ftest%2Fui%2Ffeature-gate-exhaustive_integer_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Ftest%2Fui%2Ffeature-gate-exhaustive_integer_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-exhaustive_integer_patterns.rs?ref=a79cffb8b8330527d262bdde56387d45ac46dd44", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x: u8 = 0;\n+    match x { //~ ERROR non-exhaustive patterns: `_` not covered\n+        0 ..= 255 => {}\n+    }\n+}"}, {"sha": "63d98f6b5eb64bab2500d544f851a365f9a6be64", "filename": "src/test/ui/feature-gate-exhaustive_integer_patterns.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Ftest%2Fui%2Ffeature-gate-exhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a79cffb8b8330527d262bdde56387d45ac46dd44/src%2Ftest%2Fui%2Ffeature-gate-exhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-exhaustive_integer_patterns.stderr?ref=a79cffb8b8330527d262bdde56387d45ac46dd44", "patch": "@@ -0,0 +1,9 @@\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/feature-gate-exhaustive_integer_patterns.rs:13:11\n+   |\n+LL |     match x { //~ ERROR non-exhaustive patterns: `_` not covered\n+   |           ^ pattern `_` not covered\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0004`."}]}