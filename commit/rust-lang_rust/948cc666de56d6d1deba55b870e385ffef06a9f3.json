{"sha": "948cc666de56d6d1deba55b870e385ffef06a9f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0OGNjNjY2ZGU1NmQ2ZDFkZWJhNTViODcwZTM4NWZmZWYwNmE5ZjM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-19T07:14:42Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-20T05:28:47Z"}, "message": "rustc_resolve: move export recording into its own module.", "tree": {"sha": "384f1c2987b838be0a788d10d0958e898044cdbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/384f1c2987b838be0a788d10d0958e898044cdbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/948cc666de56d6d1deba55b870e385ffef06a9f3", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/948cc666de56d6d1deba55b870e385ffef06a9f3", "html_url": "https://github.com/rust-lang/rust/commit/948cc666de56d6d1deba55b870e385ffef06a9f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/948cc666de56d6d1deba55b870e385ffef06a9f3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1614d92f5179d3fd947fedc903bd13b0824a42de", "url": "https://api.github.com/repos/rust-lang/rust/commits/1614d92f5179d3fd947fedc903bd13b0824a42de", "html_url": "https://github.com/rust-lang/rust/commit/1614d92f5179d3fd947fedc903bd13b0824a42de"}], "stats": {"total": 284, "additions": 162, "deletions": 122}, "files": [{"sha": "e1708be30d972c02ad1845f5dd6a01d78cc64841", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 122, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/948cc666de56d6d1deba55b870e385ffef06a9f3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/948cc666de56d6d1deba55b870e385ffef06a9f3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=948cc666de56d6d1deba55b870e385ffef06a9f3", "patch": "@@ -63,9 +63,9 @@ use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n-use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n-use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n-use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, ItemConst};\n+use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemFn};\n+use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, Local};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n@@ -97,6 +97,7 @@ use std::rc::{Rc, Weak};\n use std::uint;\n \n mod check_unused;\n+mod record_exports;\n \n #[deriving(Copy)]\n struct BindingInfo {\n@@ -3708,124 +3709,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    // Export recording\n-    //\n-    // This pass simply determines what all \"export\" keywords refer to and\n-    // writes the results into the export map.\n-    //\n-    // FIXME #4953 This pass will be removed once exports change to per-item.\n-    // Then this operation can simply be performed as part of item (or import)\n-    // processing.\n-\n-    fn record_exports(&mut self) {\n-        let root_module = self.graph_root.get_module();\n-        self.record_exports_for_module_subtree(root_module);\n-    }\n-\n-    fn record_exports_for_module_subtree(&mut self,\n-                                             module_: Rc<Module>) {\n-        // If this isn't a local krate, then bail out. We don't need to record\n-        // exports for nonlocal crates.\n-\n-        match module_.def_id.get() {\n-            Some(def_id) if def_id.krate == LOCAL_CRATE => {\n-                // OK. Continue.\n-                debug!(\"(recording exports for module subtree) recording \\\n-                        exports for local module `{}`\",\n-                       self.module_to_string(&*module_));\n-            }\n-            None => {\n-                // Record exports for the root module.\n-                debug!(\"(recording exports for module subtree) recording \\\n-                        exports for root module `{}`\",\n-                       self.module_to_string(&*module_));\n-            }\n-            Some(_) => {\n-                // Bail out.\n-                debug!(\"(recording exports for module subtree) not recording \\\n-                        exports for `{}`\",\n-                       self.module_to_string(&*module_));\n-                return;\n-            }\n-        }\n-\n-        self.record_exports_for_module(&*module_);\n-        self.populate_module_if_necessary(&module_);\n-\n-        for (_, child_name_bindings) in module_.children.borrow().iter() {\n-            match child_name_bindings.get_module_if_available() {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(child_module) => {\n-                    self.record_exports_for_module_subtree(child_module);\n-                }\n-            }\n-        }\n-\n-        for (_, child_module) in module_.anonymous_children.borrow().iter() {\n-            self.record_exports_for_module_subtree(child_module.clone());\n-        }\n-    }\n-\n-    fn record_exports_for_module(&mut self, module_: &Module) {\n-        let mut exports = Vec::new();\n-\n-        self.add_exports_for_module(&mut exports, module_);\n-        match module_.def_id.get() {\n-            Some(def_id) => {\n-                self.export_map.insert(def_id.node, exports);\n-                debug!(\"(computing exports) writing exports for {} (some)\",\n-                       def_id.node);\n-            }\n-            None => {}\n-        }\n-    }\n-\n-    fn add_exports_of_namebindings(&mut self,\n-                                   exports: &mut Vec<Export>,\n-                                   name: Name,\n-                                   namebindings: &NameBindings,\n-                                   ns: Namespace) {\n-        match namebindings.def_for_namespace(ns) {\n-            Some(d) => {\n-                debug!(\"(computing exports) YES: export '{}' => {}\",\n-                       name, d.def_id());\n-                exports.push(Export {\n-                    name: name,\n-                    def_id: d.def_id()\n-                });\n-            }\n-            d_opt => {\n-                debug!(\"(computing exports) NO: {}\", d_opt);\n-            }\n-        }\n-    }\n-\n-    fn add_exports_for_module(&mut self,\n-                              exports: &mut Vec<Export>,\n-                              module_: &Module) {\n-        for (name, importresolution) in module_.import_resolutions.borrow().iter() {\n-            if !importresolution.is_public {\n-                continue\n-            }\n-            let xs = [TypeNS, ValueNS];\n-            for &ns in xs.iter() {\n-                match importresolution.target_for_namespace(ns) {\n-                    Some(target) => {\n-                        debug!(\"(computing exports) maybe export '{}'\",\n-                               token::get_name(*name));\n-                        self.add_exports_of_namebindings(exports,\n-                                                         *name,\n-                                                         &*target.bindings,\n-                                                         ns)\n-                    }\n-                    _ => ()\n-                }\n-            }\n-        }\n-    }\n-\n     // AST resolution\n     //\n     // We maintain a list of value ribs and type ribs.\n@@ -6137,7 +6020,7 @@ pub fn resolve_crate(session: &Session,\n     resolver.resolve_imports();\n     session.abort_if_errors();\n \n-    resolver.record_exports();\n+    record_exports::record(&mut resolver);\n     session.abort_if_errors();\n \n     resolver.resolve_crate(krate);"}, {"sha": "41882a94b34fd5dcb46b479523262e16029e81d0", "filename": "src/librustc_resolve/record_exports.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/948cc666de56d6d1deba55b870e385ffef06a9f3/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/948cc666de56d6d1deba55b870e385ffef06a9f3/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=948cc666de56d6d1deba55b870e385ffef06a9f3", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// Export recording\n+//\n+// This pass simply determines what all \"export\" keywords refer to and\n+// writes the results into the export map.\n+//\n+// FIXME #4953 This pass will be removed once exports change to per-item.\n+// Then this operation can simply be performed as part of item (or import)\n+// processing.\n+\n+use {Module, NameBindings, Resolver};\n+use Namespace::{mod, TypeNS, ValueNS};\n+\n+use rustc::middle::def::Export;\n+use syntax::ast;\n+use syntax::parse::token;\n+\n+use std::rc::Rc;\n+\n+struct ExportRecorder<'a, 'b:'a> {\n+    resolver: &'a mut Resolver<'b>\n+}\n+\n+// Deref and DerefMut impls allow treating ExportRecorder as Resolver.\n+impl<'a, 'b> Deref<Resolver<'b>> for ExportRecorder<'a, 'b> {\n+    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n+        &*self.resolver\n+    }\n+}\n+\n+impl<'a, 'b> DerefMut<Resolver<'b>> for ExportRecorder<'a, 'b> {\n+    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n+        &mut *self.resolver\n+    }\n+}\n+\n+impl<'a, 'b> ExportRecorder<'a, 'b> {\n+    fn record_exports_for_module_subtree(&mut self,\n+                                         module_: Rc<Module>) {\n+        // If this isn't a local krate, then bail out. We don't need to record\n+        // exports for nonlocal crates.\n+\n+        match module_.def_id.get() {\n+            Some(def_id) if def_id.krate == ast::LOCAL_CRATE => {\n+                // OK. Continue.\n+                debug!(\"(recording exports for module subtree) recording \\\n+                        exports for local module `{}`\",\n+                       self.module_to_string(&*module_));\n+            }\n+            None => {\n+                // Record exports for the root module.\n+                debug!(\"(recording exports for module subtree) recording \\\n+                        exports for root module `{}`\",\n+                       self.module_to_string(&*module_));\n+            }\n+            Some(_) => {\n+                // Bail out.\n+                debug!(\"(recording exports for module subtree) not recording \\\n+                        exports for `{}`\",\n+                       self.module_to_string(&*module_));\n+                return;\n+            }\n+        }\n+\n+        self.record_exports_for_module(&*module_);\n+        self.populate_module_if_necessary(&module_);\n+\n+        for (_, child_name_bindings) in module_.children.borrow().iter() {\n+            match child_name_bindings.get_module_if_available() {\n+                None => {\n+                    // Nothing to do.\n+                }\n+                Some(child_module) => {\n+                    self.record_exports_for_module_subtree(child_module);\n+                }\n+            }\n+        }\n+\n+        for (_, child_module) in module_.anonymous_children.borrow().iter() {\n+            self.record_exports_for_module_subtree(child_module.clone());\n+        }\n+    }\n+\n+    fn record_exports_for_module(&mut self, module_: &Module) {\n+        let mut exports = Vec::new();\n+\n+        self.add_exports_for_module(&mut exports, module_);\n+        match module_.def_id.get() {\n+            Some(def_id) => {\n+                self.export_map.insert(def_id.node, exports);\n+                debug!(\"(computing exports) writing exports for {} (some)\",\n+                       def_id.node);\n+            }\n+            None => {}\n+        }\n+    }\n+\n+    fn add_exports_of_namebindings(&mut self,\n+                                   exports: &mut Vec<Export>,\n+                                   name: ast::Name,\n+                                   namebindings: &NameBindings,\n+                                   ns: Namespace) {\n+        match namebindings.def_for_namespace(ns) {\n+            Some(d) => {\n+                debug!(\"(computing exports) YES: export '{}' => {}\",\n+                       name, d.def_id());\n+                exports.push(Export {\n+                    name: name,\n+                    def_id: d.def_id()\n+                });\n+            }\n+            d_opt => {\n+                debug!(\"(computing exports) NO: {}\", d_opt);\n+            }\n+        }\n+    }\n+\n+    fn add_exports_for_module(&mut self,\n+                              exports: &mut Vec<Export>,\n+                              module_: &Module) {\n+        for (name, importresolution) in module_.import_resolutions.borrow().iter() {\n+            if !importresolution.is_public {\n+                continue\n+            }\n+            let xs = [TypeNS, ValueNS];\n+            for &ns in xs.iter() {\n+                match importresolution.target_for_namespace(ns) {\n+                    Some(target) => {\n+                        debug!(\"(computing exports) maybe export '{}'\",\n+                               token::get_name(*name));\n+                        self.add_exports_of_namebindings(exports,\n+                                                         *name,\n+                                                         &*target.bindings,\n+                                                         ns)\n+                    }\n+                    _ => ()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn record(resolver: &mut Resolver) {\n+    let mut recorder = ExportRecorder { resolver: resolver };\n+    let root_module = recorder.graph_root.get_module();\n+    recorder.record_exports_for_module_subtree(root_module);\n+}"}]}