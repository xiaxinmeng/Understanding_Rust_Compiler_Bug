{"sha": "bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZmQ1YzQ4YjdlYzk2Y2MyOGJlZjJjYzVlMjliNGFlMGNlNmMzYWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-26T11:45:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-26T11:45:13Z"}, "message": "Auto merge of #40501 - jseyfried:shadow_builtin_macros, r=nrc\n\nAllow `use` macro imports to shadow global macros\n\nTerminology:\n - global scope: builtin macros, macros from the prelude, `#[macro_use]`, or `#![plugin(..)]`.\n - legacy scope: crate-local `macro_rules!`.\n - modern scope: `use` macro imports, `macro` (once implemented).\n\nToday, the legacy scope can shadow the global scope (modulo RFC 1560 expanded shadowing restrictions). However, the modern scope cannot shadow or be shadowed by either the global or legacy scopes, leading to ambiguity errors.\n\nThis PR allows the modern scope to shadow the global scope (subject to some restrictions).\nMore specifically, a name in the global scope is as shadowable as a glob import in the module `self`. In other words, we imagine a special, implicit glob import in each module item:\n```rust\nmod foo {\n    #[lexical_only] // Not accessible via `foo::<name>`, like pre-RFC 1560 `use` imports.\n    #[shadowable_by_legacy_scope] // for back-compat\n    use <global_macros>::*;\n}\n```\n\nr? @nrc", "tree": {"sha": "e67351baebb80578728a3ee602759f7ab05f52f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e67351baebb80578728a3ee602759f7ab05f52f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "html_url": "https://github.com/rust-lang/rust/commit/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dd4e2db785c8ec360a989f69891b1e97dd4d369", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dd4e2db785c8ec360a989f69891b1e97dd4d369", "html_url": "https://github.com/rust-lang/rust/commit/7dd4e2db785c8ec360a989f69891b1e97dd4d369"}, {"sha": "d64d3814c4a23fcb8440959bec77090fbbb25d7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d64d3814c4a23fcb8440959bec77090fbbb25d7d", "html_url": "https://github.com/rust-lang/rust/commit/d64d3814c4a23fcb8440959bec77090fbbb25d7d"}], "stats": {"total": 246, "additions": 175, "deletions": 71}, "files": [{"sha": "86e0d0039d1a7c4a517308a66177409be5516995", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "patch": "@@ -539,7 +539,7 @@ impl<'a> Resolver<'a> {\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        if self.builtin_macros.insert(name, binding).is_some() && !allow_shadowing {\n+        if self.global_macros.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";"}, {"sha": "879d8816488b20e8a1e8fc420b4215ee59e986a2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "patch": "@@ -75,7 +75,7 @@ use std::mem::replace;\n use std::rc::Rc;\n \n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding, LegacyScope};\n+use macros::{InvocationData, LegacyBinding, LegacyScope, MacroBinding};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -1174,7 +1174,7 @@ pub struct Resolver<'a> {\n \n     crate_loader: &'a mut CrateLoader,\n     macro_names: FxHashSet<Name>,\n-    builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n+    global_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n     lexical_macro_resolutions: Vec<(Name, &'a Cell<LegacyScope<'a>>)>,\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n     macro_defs: FxHashMap<Mark, DefId>,\n@@ -1372,7 +1372,7 @@ impl<'a> Resolver<'a> {\n \n             crate_loader: crate_loader,\n             macro_names: FxHashSet(),\n-            builtin_macros: FxHashMap(),\n+            global_macros: FxHashMap(),\n             lexical_macro_resolutions: Vec::new(),\n             macro_map: FxHashMap(),\n             macro_exports: Vec::new(),\n@@ -2429,9 +2429,9 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n         }\n-        let is_builtin = self.builtin_macros.get(&path[0].name).cloned()\n+        let is_global = self.global_macros.get(&path[0].name).cloned()\n             .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n-        if primary_ns != MacroNS && (is_builtin || self.macro_names.contains(&path[0].name)) {\n+        if primary_ns != MacroNS && (is_global || self.macro_names.contains(&path[0].name)) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n@@ -2566,6 +2566,7 @@ impl<'a> Resolver<'a> {\n                 self.resolve_ident_in_module(module, ident, ns, false, record_used)\n             } else if opt_ns == Some(MacroNS) {\n                 self.resolve_lexical_macro_path_segment(ident, ns, record_used)\n+                    .map(MacroBinding::binding)\n             } else {\n                 match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n@@ -3223,7 +3224,7 @@ impl<'a> Resolver<'a> {\n             };\n             let msg1 = format!(\"`{}` could refer to the name {} here\", name, participle(b1));\n             let msg2 = format!(\"`{}` could also refer to the name {} here\", name, participle(b2));\n-            let note = if !lexical && b1.is_glob_import() {\n+            let note = if b1.expansion == Mark::root() || !lexical && b1.is_glob_import() {\n                 format!(\"consider adding an explicit import of `{}` to disambiguate\", name)\n             } else if let Def::Macro(..) = b1.def() {\n                 format!(\"macro-expanded {} do not shadow\",\n@@ -3243,11 +3244,15 @@ impl<'a> Resolver<'a> {\n                 let msg = format!(\"`{}` is ambiguous\", name);\n                 self.session.add_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n             } else {\n-                self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n-                    .span_note(b1.span, &msg1)\n-                    .span_note(b2.span, &msg2)\n-                    .note(&note)\n-                    .emit();\n+                let mut err =\n+                    self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name));\n+                err.span_note(b1.span, &msg1);\n+                match b2.def() {\n+                    Def::Macro(..) if b2.span == DUMMY_SP =>\n+                        err.note(&format!(\"`{}` is also a builtin macro\", name)),\n+                    _ => err.span_note(b2.span, &msg2),\n+                };\n+                err.note(&note).emit();\n             }\n         }\n \n@@ -3361,22 +3366,21 @@ impl<'a> Resolver<'a> {\n         if self.proc_macro_enabled { return; }\n \n         for attr in attrs {\n-            let name = unwrap_or!(attr.name(), continue);\n-            let maybe_binding = self.builtin_macros.get(&name).cloned().or_else(|| {\n-                let ident = Ident::with_empty_ctxt(name);\n-                self.resolve_lexical_macro_path_segment(ident, MacroNS, None).ok()\n-            });\n-\n-            if let Some(binding) = maybe_binding {\n-                if let SyntaxExtension::AttrProcMacro(..) = *binding.get_macro(self) {\n+            if attr.path.segments.len() > 1 {\n+                continue\n+            }\n+            let ident = attr.path.segments[0].identifier;\n+            let result = self.resolve_lexical_macro_path_segment(ident, MacroNS, None);\n+            if let Ok(binding) = result {\n+                if let SyntaxExtension::AttrProcMacro(..) = *binding.binding().get_macro(self) {\n                     attr::mark_known(attr);\n \n                     let msg = \"attribute procedural macros are experimental\";\n                     let feature = \"proc_macro\";\n \n                     feature_err(&self.session.parse_sess, feature,\n                                 attr.span, GateIssue::Language, msg)\n-                        .span_note(binding.span, \"procedural macro imported here\")\n+                        .span_note(binding.span(), \"procedural macro imported here\")\n                         .emit();\n                 }\n             }"}, {"sha": "3d6c6896549a4bb8f5996bc7615526b73218f41e", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 71, "deletions": 45, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "patch": "@@ -81,11 +81,29 @@ pub struct LegacyBinding<'a> {\n     pub span: Span,\n }\n \n+#[derive(Copy, Clone)]\n pub enum MacroBinding<'a> {\n     Legacy(&'a LegacyBinding<'a>),\n+    Global(&'a NameBinding<'a>),\n     Modern(&'a NameBinding<'a>),\n }\n \n+impl<'a> MacroBinding<'a> {\n+    pub fn span(self) -> Span {\n+        match self {\n+            MacroBinding::Legacy(binding) => binding.span,\n+            MacroBinding::Global(binding) | MacroBinding::Modern(binding) => binding.span,\n+        }\n+    }\n+\n+    pub fn binding(self) -> &'a NameBinding<'a> {\n+        match self {\n+            MacroBinding::Global(binding) | MacroBinding::Modern(binding) => binding,\n+            MacroBinding::Legacy(_) => panic!(\"unexpected MacroBinding::Legacy\"),\n+        }\n+    }\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -171,7 +189,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             vis: ty::Visibility::Invisible,\n             expansion: Mark::root(),\n         });\n-        self.builtin_macros.insert(ident.name, binding);\n+        self.global_macros.insert(ident.name, binding);\n     }\n \n     fn resolve_imports(&mut self) {\n@@ -189,7 +207,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 attr::mark_known(&attrs[i]);\n             }\n \n-            match self.builtin_macros.get(&name).cloned() {\n+            match self.global_macros.get(&name).cloned() {\n                 Some(binding) => match *binding.get_macro(self) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n@@ -221,7 +239,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     }\n                     let trait_name = traits[j].segments[0].identifier.name;\n                     let legacy_name = Symbol::intern(&format!(\"derive_{}\", trait_name));\n-                    if !self.builtin_macros.contains_key(&legacy_name) {\n+                    if !self.global_macros.contains_key(&legacy_name) {\n                         continue\n                     }\n                     let span = traits.remove(j).span;\n@@ -378,18 +396,18 @@ impl<'a> Resolver<'a> {\n         }\n \n         let name = path[0].name;\n-        let result = match self.resolve_legacy_scope(&invocation.legacy_scope, name, false) {\n-            Some(MacroBinding::Legacy(binding)) => Ok(Def::Macro(binding.def_id, MacroKind::Bang)),\n-            Some(MacroBinding::Modern(binding)) => Ok(binding.def_ignoring_ambiguity()),\n-            None => match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n-                Ok(binding) => Ok(binding.def_ignoring_ambiguity()),\n-                Err(Determinacy::Undetermined) if !force =>\n-                    return Err(Determinacy::Undetermined),\n+        let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, name, false);\n+        let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n+            Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n+        } else {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n+                Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n+                Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 Err(_) => {\n                     self.found_unresolved_macro = true;\n                     Err(Determinacy::Determined)\n                 }\n-            },\n+            }\n         };\n \n         self.current_module.legacy_macro_resolutions.borrow_mut()\n@@ -403,42 +421,56 @@ impl<'a> Resolver<'a> {\n                                               ident: Ident,\n                                               ns: Namespace,\n                                               record_used: Option<Span>)\n-                                              -> Result<&'a NameBinding<'a>, Determinacy> {\n-        let mut module = self.current_module;\n-        let mut potential_expanded_shadower: Option<&NameBinding> = None;\n+                                              -> Result<MacroBinding<'a>, Determinacy> {\n+        let mut module = Some(self.current_module);\n+        let mut potential_illegal_shadower = Err(Determinacy::Determined);\n+        let determinacy =\n+            if record_used.is_some() { Determinacy::Determined } else { Determinacy::Undetermined };\n         loop {\n-            // Since expanded macros may not shadow the lexical scope (enforced below),\n-            // we can ignore unresolved invocations (indicated by the penultimate argument).\n-            match self.resolve_ident_in_module(module, ident, ns, true, record_used) {\n+            let result = if let Some(module) = module {\n+                // Since expanded macros may not shadow the lexical scope and\n+                // globs may not shadow global macros (both enforced below),\n+                // we resolve with restricted shadowing (indicated by the penultimate argument).\n+                self.resolve_ident_in_module(module, ident, ns, true, record_used)\n+                    .map(MacroBinding::Modern)\n+            } else {\n+                self.global_macros.get(&ident.name).cloned().ok_or(determinacy)\n+                    .map(MacroBinding::Global)\n+            };\n+\n+            match result.map(MacroBinding::binding) {\n                 Ok(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,\n-                        None => return Ok(binding),\n+                        None => return result,\n                     };\n-                    match potential_expanded_shadower {\n-                        Some(shadower) if shadower.def() != binding.def() => {\n+                    if let Ok(MacroBinding::Modern(shadower)) = potential_illegal_shadower {\n+                        if shadower.def() != binding.def() {\n                             let name = ident.name;\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: span, name: name, b1: shadower, b2: binding, lexical: true,\n                                 legacy: false,\n                             });\n-                            return Ok(shadower);\n+                            return potential_illegal_shadower;\n                         }\n-                        _ if binding.expansion == Mark::root() => return Ok(binding),\n-                        _ => potential_expanded_shadower = Some(binding),\n+                    }\n+                    if binding.expansion != Mark::root() ||\n+                       (binding.is_glob_import() && module.unwrap().def().is_some()) {\n+                        potential_illegal_shadower = result;\n+                    } else {\n+                        return result;\n                     }\n                 },\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {}\n             }\n \n-            match module.kind {\n-                ModuleKind::Block(..) => module = module.parent.unwrap(),\n-                ModuleKind::Def(..) => return match potential_expanded_shadower {\n-                    Some(binding) => Ok(binding),\n-                    None if record_used.is_some() => Err(Determinacy::Determined),\n-                    None => Err(Determinacy::Undetermined),\n+            module = match module {\n+                Some(module) => match module.kind {\n+                    ModuleKind::Block(..) => module.parent,\n+                    ModuleKind::Def(..) => None,\n                 },\n+                None => return potential_illegal_shadower,\n             }\n         }\n     }\n@@ -488,11 +520,11 @@ impl<'a> Resolver<'a> {\n \n         let binding = if let Some(binding) = binding {\n             MacroBinding::Legacy(binding)\n-        } else if let Some(binding) = self.builtin_macros.get(&name).cloned() {\n+        } else if let Some(binding) = self.global_macros.get(&name).cloned() {\n             if !self.use_extern_macros {\n                 self.record_use(Ident::with_empty_ctxt(name), MacroNS, binding, DUMMY_SP);\n             }\n-            MacroBinding::Modern(binding)\n+            MacroBinding::Global(binding)\n         } else {\n             return None;\n         };\n@@ -524,21 +556,15 @@ impl<'a> Resolver<'a> {\n             let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n             match (legacy_resolution, resolution) {\n-                (Some(legacy_resolution), Ok(resolution)) => {\n-                    let (legacy_span, participle) = match legacy_resolution {\n-                        MacroBinding::Modern(binding)\n-                            if binding.def() == resolution.def() => continue,\n-                        MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n-                        MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n-                    };\n-                    let msg1 = format!(\"`{}` could refer to the macro {} here\", ident, participle);\n+                (Some(MacroBinding::Legacy(legacy_binding)), Ok(MacroBinding::Modern(binding))) => {\n+                    let msg1 = format!(\"`{}` could refer to the macro defined here\", ident);\n                     let msg2 = format!(\"`{}` could also refer to the macro imported here\", ident);\n                     self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n-                        .span_note(legacy_span, &msg1)\n-                        .span_note(resolution.span, &msg2)\n+                        .span_note(legacy_binding.span, &msg1)\n+                        .span_note(binding.span, &msg2)\n                         .emit();\n                 },\n-                (Some(MacroBinding::Modern(binding)), Err(_)) => {\n+                (Some(MacroBinding::Global(binding)), Ok(MacroBinding::Global(_))) => {\n                     self.record_use(ident, MacroNS, binding, span);\n                     self.err_if_macro_use_proc_macro(ident.name, span, binding);\n                 },\n@@ -567,11 +593,11 @@ impl<'a> Resolver<'a> {\n             find_best_match_for_name(self.macro_names.iter(), name, None)\n         } else {\n             None\n-        // Then check builtin macros.\n+        // Then check global macros.\n         }.or_else(|| {\n             // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n-            let builtin_macros = self.builtin_macros.clone();\n-            let names = builtin_macros.iter().filter_map(|(name, binding)| {\n+            let global_macros = self.global_macros.clone();\n+            let names = global_macros.iter().filter_map(|(name, binding)| {\n                 if binding.get_macro(self).kind() == kind {\n                     Some(name)\n                 } else {"}, {"sha": "43654c8ce6f6875b13aa5009fabec257024ae784", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "patch": "@@ -145,7 +145,7 @@ impl<'a> Resolver<'a> {\n                                    module: Module<'a>,\n                                    ident: Ident,\n                                    ns: Namespace,\n-                                   ignore_unresolved_invocations: bool,\n+                                   restricted_shadowing: bool,\n                                    record_used: Option<Span>)\n                                    -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.populate_module_if_necessary(module);\n@@ -158,9 +158,8 @@ impl<'a> Resolver<'a> {\n             if let Some(binding) = resolution.binding {\n                 if let Some(shadowed_glob) = resolution.shadows_glob {\n                     let name = ident.name;\n-                    // If we ignore unresolved invocations, we must forbid\n-                    // expanded shadowing to avoid time travel.\n-                    if ignore_unresolved_invocations &&\n+                    // Forbid expanded shadowing to avoid time travel.\n+                    if restricted_shadowing &&\n                        binding.expansion != Mark::root() &&\n                        ns != MacroNS && // In MacroNS, `try_define` always forbids this shadowing\n                        binding.def() != shadowed_glob.def() {\n@@ -215,7 +214,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let no_unresolved_invocations =\n-            ignore_unresolved_invocations || module.unresolved_invocations.borrow().is_empty();\n+            restricted_shadowing || module.unresolved_invocations.borrow().is_empty();\n         match resolution.binding {\n             // In `MacroNS`, expanded bindings do not shadow (enforced in `try_define`).\n             Some(binding) if no_unresolved_invocations || ns == MacroNS =>\n@@ -225,6 +224,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Check if the globs are determined\n+        if restricted_shadowing && module.def().is_some() {\n+            return Err(Determined);\n+        }\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {"}, {"sha": "2b3ba1b4aa7a79f0e58ec079996732b04c886e64", "filename": "src/test/compile-fail/imports/shadow_builtin_macros.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs?ref=bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+\n+#![feature(use_extern_macros)]\n+\n+mod foo {\n+    extern crate two_macros;\n+    pub use self::two_macros::m as panic;\n+}\n+\n+mod m1 {\n+    use foo::panic; // ok\n+    fn f() { panic!(); }\n+}\n+\n+mod m2 {\n+    use foo::*; //~ NOTE `panic` could refer to the name imported here\n+    fn f() { panic!(); } //~ ERROR ambiguous\n+    //~| NOTE `panic` is also a builtin macro\n+    //~| NOTE consider adding an explicit import of `panic` to disambiguate\n+}\n+\n+mod m3 {\n+    ::two_macros::m!(use foo::panic;); //~ NOTE `panic` could refer to the name imported here\n+    //~| NOTE in this expansion\n+    fn f() { panic!(); } //~ ERROR ambiguous\n+    //~| NOTE `panic` is also a builtin macro\n+    //~| NOTE macro-expanded macro imports do not shadow\n+}\n+\n+mod m4 {\n+    macro_rules! panic { () => {} } // ok\n+    panic!();\n+}\n+\n+mod m5 {\n+    macro_rules! m { () => {\n+        macro_rules! panic { () => {} } //~ ERROR `panic` is already in scope\n+        //~| NOTE macro-expanded `macro_rules!`s may not shadow existing macros\n+    } }\n+    m!(); //~ NOTE in this expansion\n+    //~| NOTE in this expansion\n+    panic!();\n+}\n+\n+#[macro_use(n)] //~ NOTE `n` could also refer to the name imported here\n+extern crate two_macros;\n+mod bar {\n+    pub use two_macros::m as n;\n+}\n+\n+mod m6 {\n+    use bar::n; // ok\n+    n!();\n+}\n+\n+mod m7 {\n+    use bar::*; //~ NOTE `n` could refer to the name imported here\n+    n!(); //~ ERROR ambiguous\n+    //~| NOTE consider adding an explicit import of `n` to disambiguate\n+}\n+\n+fn main() {}"}]}