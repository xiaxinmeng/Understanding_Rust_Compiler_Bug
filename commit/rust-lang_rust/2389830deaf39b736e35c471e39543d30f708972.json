{"sha": "2389830deaf39b736e35c471e39543d30f708972", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzODk4MzBkZWFmMzliNzM2ZTM1YzQ3MWUzOTU0M2QzMGY3MDg5NzI=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-02-17T22:31:59Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-04-11T22:45:00Z"}, "message": "Highlight and simplify mismatched types\n\nShorten mismatched types errors by replacing subtypes that are not\ndifferent with `_`, and highlighting only the subtypes that are\ndifferent.\n\nGiven a file\n\n```rust\nstruct X<T1, T2> {\n    x: T1,\n    y: T2,\n}\n\nfn foo() -> X<X<String, String>, String> {\n    X { x: X {x: \"\".to_string(), y: 2}, y: \"\".to_string()}\n}\n\nfn bar() -> Option<String> {\n    \"\".to_string()\n}\n```\n\nprovide the following output\n\n```rust\nerror[E0308]: mismatched types\n  --> file.rs:6:5\n   |\n 6 |     X { x: X {x: \"\".to_string(), y: 2}, y: \"\".to_string()}\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `std::string::String`, found {integer}\n   |\n   = note: expected type `X<X<_, std::string::String>, _>`\n                                 ^^^^^^^^^^^^^^^^^^^   // < highlighted\n              found type `X<X<_, {integer}>, _>`\n                                 ^^^^^^^^^             // < highlighted\n\nerror[E0308]: mismatched types\n  --> file.rs:6:5\n   |\n10 |     \"\".to_string()\n   |     ^^^^^^^^^^^^^^ expected struct `std::option::Option`, found `std::string::String`\n   |\n   = note: expected type `Option<std::string::String>`\n                          ^^^^^^^                   ^  // < highlighted\n              found type `std::string::String`\n```", "tree": {"sha": "917dc0793faa980bbbd9742b321809d9d78644fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/917dc0793faa980bbbd9742b321809d9d78644fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2389830deaf39b736e35c471e39543d30f708972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2389830deaf39b736e35c471e39543d30f708972", "html_url": "https://github.com/rust-lang/rust/commit/2389830deaf39b736e35c471e39543d30f708972", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2389830deaf39b736e35c471e39543d30f708972/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "url": "https://api.github.com/repos/rust-lang/rust/commits/d616f47cd03a65fed13be2ee5527f24f6a4f7f92", "html_url": "https://github.com/rust-lang/rust/commit/d616f47cd03a65fed13be2ee5527f24f6a4f7f92"}], "stats": {"total": 517, "additions": 485, "deletions": 32}, "files": [{"sha": "dcbe50de2e9b2ec8ac6ba66a6a56bb94faf3131e", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 279, "deletions": 9, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -70,7 +70,7 @@ use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, Issue32330};\n use ty::error::TypeError;\n use syntax_pos::{Pos, Span};\n-use errors::DiagnosticBuilder;\n+use errors::{DiagnosticBuilder, DiagnosticStyledString};\n \n mod note;\n \n@@ -365,6 +365,262 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Given that `other_ty` is the same as a type argument for `name` in `sub`, populate `value`\n+    /// highlighting `name` and every type argument that isn't at `pos` (which is `other_ty`), and\n+    /// populate `other_value` with `other_ty`.\n+    ///\n+    /// ```text\n+    /// Foo<Bar<Qux>>\n+    /// ^^^^--------^ this is highlighted\n+    /// |   |\n+    /// |   this type argument is exactly the same as the other type, not highlighted\n+    /// this is highlighted\n+    /// Bar<Qux>\n+    /// -------- this type is the same as a type argument in the other type, not highlighted\n+    /// ```\n+    fn highlight_outer(&self,\n+                       mut value: &mut DiagnosticStyledString,\n+                       mut other_value: &mut DiagnosticStyledString,\n+                       name: String,\n+                       sub: &ty::subst::Substs<'tcx>,\n+                       pos: usize,\n+                       other_ty: &ty::Ty<'tcx>) {\n+        // `value` and `other_value` hold two incomplete type representation for display.\n+        // `name` is the path of both types being compared. `sub`\n+        value.push_highlighted(name);\n+        let len = sub.len();\n+        if len > 0 {\n+            value.push_highlighted(\"<\");\n+        }\n+\n+        // Output the lifetimes fot the first type\n+        let lifetimes = sub.regions().map(|lifetime| {\n+            let s = format!(\"{}\", lifetime);\n+            if s.is_empty() {\n+                \"'_\".to_string()\n+            } else {\n+                s\n+            }\n+        }).collect::<Vec<_>>().join(\", \");\n+        if !lifetimes.is_empty() {\n+            if sub.regions().count() < len {\n+                value.push_normal(lifetimes + &\", \");\n+            } else {\n+                value.push_normal(lifetimes);\n+            }\n+        }\n+\n+        // Highlight all the type arguments that aren't at `pos` and compare the type argument at\n+        // `pos` and `other_ty`.\n+        for (i, type_arg) in sub.types().enumerate() {\n+            if i == pos {\n+                let values = self.cmp(type_arg, other_ty);\n+                value.0.extend((values.0).0);\n+                other_value.0.extend((values.1).0);\n+            } else {\n+                value.push_highlighted(format!(\"{}\", type_arg));\n+            }\n+\n+            if len > 0 && i != len - 1 {\n+                value.push_normal(\", \");\n+            }\n+            //self.push_comma(&mut value, &mut other_value, len, i);\n+        }\n+        if len > 0 {\n+            value.push_highlighted(\">\");\n+        }\n+    }\n+\n+    /// If `other_ty` is the same as a type argument present in `sub`, highlight `path` in `t1_out`,\n+    /// as that is the difference to the other type.\n+    ///\n+    /// For the following code:\n+    ///\n+    /// ```norun\n+    /// let x: Foo<Bar<Qux>> = foo::<Bar<Qux>>();\n+    /// ```\n+    ///\n+    /// The type error output will behave in the following way:\n+    ///\n+    /// ```text\n+    /// Foo<Bar<Qux>>\n+    /// ^^^^--------^ this is highlighted\n+    /// |   |\n+    /// |   this type argument is exactly the same as the other type, not highlighted\n+    /// this is highlighted\n+    /// Bar<Qux>\n+    /// -------- this type is the same as a type argument in the other type, not highlighted\n+    /// ```\n+    fn cmp_type_arg(&self,\n+                    mut t1_out: &mut DiagnosticStyledString,\n+                    mut t2_out: &mut DiagnosticStyledString,\n+                    path: String,\n+                    sub: &ty::subst::Substs<'tcx>,\n+                    other_path: String,\n+                    other_ty: &ty::Ty<'tcx>) -> Option<()> {\n+        for (i, ta) in sub.types().enumerate() {\n+            if &ta == other_ty {\n+                self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n+                return Some(());\n+            }\n+            if let &ty::TyAdt(def, _) = &ta.sty {\n+                let path_ = self.tcx.item_path_str(def.did.clone());\n+                if path_ == other_path {\n+                    self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n+                    return Some(());\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Add a `,` to the type representation only if it is appropriate.\n+    fn push_comma(&self,\n+                  value: &mut DiagnosticStyledString,\n+                  other_value: &mut DiagnosticStyledString,\n+                  len: usize,\n+                  pos: usize) {\n+        if len > 0 && pos != len - 1 {\n+            value.push_normal(\", \");\n+            other_value.push_normal(\", \");\n+        }\n+    }\n+\n+    /// Compare two given types, eliding parts that are the same between them and highlighting\n+    /// relevant differences, and return two representation of those types for highlighted printing.\n+    fn cmp(&self, t1: ty::Ty<'tcx>, t2: ty::Ty<'tcx>)\n+        -> (DiagnosticStyledString, DiagnosticStyledString)\n+    {\n+        match (&t1.sty, &t2.sty) {\n+            (&ty::TyAdt(def1, sub1), &ty::TyAdt(def2, sub2)) => {\n+                let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n+                let path1 = self.tcx.item_path_str(def1.did.clone());\n+                let path2 = self.tcx.item_path_str(def2.did.clone());\n+                if def1.did == def2.did {\n+                    // Easy case. Replace same types with `_` to shorten the output and highlight\n+                    // the differing ones.\n+                    //     let x: Foo<Bar, Qux> = y::<Foo<Quz, Qux>>();\n+                    //     Foo<Bar, _>\n+                    //     Foo<Quz, _>\n+                    //         ---  ^ type argument elided\n+                    //         |\n+                    //         highlighted in output\n+                    values.0.push_normal(path1);\n+                    values.1.push_normal(path2);\n+\n+                    // Only draw `<...>` if there're lifetime/type arguments.\n+                    let len = sub1.len();\n+                    if len > 0 {\n+                        values.0.push_normal(\"<\");\n+                        values.1.push_normal(\"<\");\n+                    }\n+\n+                    fn lifetime_display(lifetime: &Region) -> String {\n+                        let s = format!(\"{}\", lifetime);\n+                        if s.is_empty() {\n+                            \"'_\".to_string()\n+                        } else {\n+                            s\n+                        }\n+                    }\n+                    // At one point we'd like to elide all lifetimes here, they are irrelevant for\n+                    // all diagnostics that use this output\n+                    //\n+                    //     Foo<'x, '_, Bar>\n+                    //     Foo<'y, '_, Qux>\n+                    //         ^^  ^^  --- type arguments are not elided\n+                    //         |   |\n+                    //         |   elided as they were the same\n+                    //         not elided, they were different, but irrelevant\n+                    let lifetimes = sub1.regions().zip(sub2.regions());\n+                    for (i, lifetimes) in lifetimes.enumerate() {\n+                        let l1 = lifetime_display(lifetimes.0);\n+                        let l2 = lifetime_display(lifetimes.1);\n+                        if l1 == l2 {\n+                            values.0.push_normal(\"'_\");\n+                            values.1.push_normal(\"'_\");\n+                        } else {\n+                            values.0.push_highlighted(l1);\n+                            values.1.push_highlighted(l2);\n+                        }\n+                        self.push_comma(&mut values.0, &mut values.1, len, i);\n+                    }\n+\n+                    // We're comparing two types with the same path, so we compare the type\n+                    // arguments for both. If they are the same, do not highlight and elide from the\n+                    // output.\n+                    //     Foo<_, Bar>\n+                    //     Foo<_, Qux>\n+                    //         ^ elided type as this type argument was the same in both sides\n+                    let type_arguments = sub1.types().zip(sub2.types());\n+                    let regions_len = sub1.regions().collect::<Vec<_>>().len();\n+                    for (i, (ta1, ta2)) in type_arguments.enumerate() {\n+                        let i = i + regions_len;\n+                        if ta1 == ta2 {\n+                            values.0.push_normal(\"_\");\n+                            values.1.push_normal(\"_\");\n+                        } else {\n+                            let (x1, x2) = self.cmp(ta1, ta2);\n+                            (values.0).0.extend(x1.0);\n+                            (values.1).0.extend(x2.0);\n+                        }\n+                        self.push_comma(&mut values.0, &mut values.1, len, i);\n+                    }\n+\n+                    // Close the type argument bracket.\n+                    // Only draw `<...>` if there're lifetime/type arguments.\n+                    if len > 0 {\n+                        values.0.push_normal(\">\");\n+                        values.1.push_normal(\">\");\n+                    }\n+                    values\n+                } else {\n+                    // Check for case:\n+                    //     let x: Foo<Bar<Qux> = foo::<Bar<Qux>>();\n+                    //     Foo<Bar<Qux>\n+                    //         ------- this type argument is exactly the same as the other type\n+                    //     Bar<Qux>\n+                    if self.cmp_type_arg(&mut values.0,\n+                                         &mut values.1,\n+                                         path1.clone(),\n+                                         sub1,\n+                                         path2.clone(),\n+                                         &t2).is_some() {\n+                        return values;\n+                    }\n+                    // Check for case:\n+                    //     let x: Bar<Qux> = y:<Foo<Bar<Qux>>>();\n+                    //     Bar<Qux>\n+                    //     Foo<Bar<Qux>>\n+                    //         ------- this type argument is exactly the same as the other type\n+                    if self.cmp_type_arg(&mut values.1,\n+                                         &mut values.0,\n+                                         path2,\n+                                         sub2,\n+                                         path1,\n+                                         &t1).is_some() {\n+                        return values;\n+                    }\n+\n+                    // We couldn't find anything in common, highlight everything.\n+                    //     let x: Bar<Qux> = y::<Foo<Zar>>();\n+                    (DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n+                     DiagnosticStyledString::highlighted(format!(\"{}\", t2)))\n+                }\n+            }\n+            _ => {\n+                if t1 == t2 {\n+                    // The two types are the same, elide and don't highlight.\n+                    (DiagnosticStyledString::normal(\"_\"), DiagnosticStyledString::normal(\"_\"))\n+                } else {\n+                    // We couldn't find anything in common, highlight everything.\n+                    (DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n+                     DiagnosticStyledString::highlighted(format!(\"{}\", t2)))\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn note_type_err(&self,\n                          diag: &mut DiagnosticBuilder<'tcx>,\n                          cause: &ObligationCause<'tcx>,\n@@ -397,14 +653,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((expected, found)) = expected_found {\n             match (terr, is_simple_error, expected == found) {\n-                (&TypeError::Sorts(ref values), false,  true) => {\n+                (&TypeError::Sorts(ref values), false, true) => {\n                     diag.note_expected_found_extra(\n-                        &\"type\", &expected, &found,\n+                        &\"type\", expected, found,\n                         &format!(\" ({})\", values.expected.sort_string(self.tcx)),\n                         &format!(\" ({})\", values.found.sort_string(self.tcx)));\n                 }\n                 (_, false,  _) => {\n-                    diag.note_expected_found(&\"type\", &expected, &found);\n+                    diag.note_expected_found(&\"type\", expected, found);\n                 }\n                 _ => (),\n             }\n@@ -472,26 +728,40 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         diag\n     }\n \n-    /// Returns a string of the form \"expected `{}`, found `{}`\".\n-    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<(String, String)> {\n+    fn values_str(&self, values: &ValuePairs<'tcx>)\n+        -> Option<(DiagnosticStyledString, DiagnosticStyledString)>\n+    {\n         match *values {\n-            infer::Types(ref exp_found) => self.expected_found_str(exp_found),\n+            infer::Types(ref exp_found) => self.expected_found_str_ty(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n             infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n         }\n     }\n \n+    fn expected_found_str_ty(&self,\n+                             exp_found: &ty::error::ExpectedFound<ty::Ty<'tcx>>)\n+                             -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        if exp_found.references_error() {\n+            return None;\n+        }\n+\n+        Some(self.cmp(exp_found.expected, exp_found.found))\n+    }\n+\n+    /// Returns a string of the form \"expected `{}`, found `{}`\".\n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>)\n-        -> Option<(String, String)>\n+        -> Option<(DiagnosticStyledString, DiagnosticStyledString)>\n     {\n         let exp_found = self.resolve_type_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n \n-        Some((format!(\"{}\", exp_found.expected), format!(\"{}\", exp_found.found)))\n+        Some((DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.expected)),\n+              DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.found))))\n     }\n \n     fn report_generic_bound_failure(&self,"}, {"sha": "8b753e0d22be7c4bf2b37a7beed1e0e507b620ac", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -20,6 +20,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         match *origin {\n             infer::Subtype(ref trace) => {\n                 if let Some((expected, found)) = self.values_str(&trace.values) {\n+                    let expected = expected.content();\n+                    let found = found.content();\n                     // FIXME: do we want a \"the\" here?\n                     err.span_note(trace.cause.span,\n                                   &format!(\"...so that {} (expected {}, found {})\","}, {"sha": "3c51fd546c7c2606341ce30f835e943ec87b2b37", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -2218,7 +2218,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `DefId` is really just an interned def-path).\n     ///\n     /// Note that if `id` is not local to this crate, the result will\n-    //  be a non-local `DefPath`.\n+    ///  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> hir_map::DefPath {\n         if id.is_local() {\n             self.hir.def_path(id)"}, {"sha": "9715ace3e2e2e5a6eb43f32d725c98a68ce15c1e", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -35,6 +35,46 @@ pub struct SubDiagnostic {\n     pub render_span: Option<RenderSpan>,\n }\n \n+#[derive(PartialEq, Eq)]\n+pub struct DiagnosticStyledString(pub Vec<StringPart>);\n+\n+impl DiagnosticStyledString {\n+    pub fn new() -> DiagnosticStyledString {\n+        DiagnosticStyledString(vec![])\n+    }\n+    pub fn push_normal<S: Into<String>>(&mut self, t: S) {\n+        self.0.push(StringPart::Normal(t.into()));\n+    }\n+    pub fn push_highlighted<S: Into<String>>(&mut self, t: S) {\n+        self.0.push(StringPart::Highlighted(t.into()));\n+    }\n+    pub fn normal<S: Into<String>>(t: S) -> DiagnosticStyledString {\n+        DiagnosticStyledString(vec![StringPart::Normal(t.into())])\n+    }\n+\n+    pub fn highlighted<S: Into<String>>(t: S) -> DiagnosticStyledString {\n+        DiagnosticStyledString(vec![StringPart::Highlighted(t.into())])\n+    }\n+\n+    pub fn content(&self) -> String {\n+        self.0.iter().map(|x| x.content()).collect::<String>()\n+    }\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub enum StringPart {\n+    Normal(String),\n+    Highlighted(String),\n+}\n+\n+impl StringPart {\n+    pub fn content(&self) -> String {\n+        match self {\n+            &StringPart::Normal(ref s) | & StringPart::Highlighted(ref s) => s.to_owned()\n+        }\n+    }\n+}\n+\n impl Diagnostic {\n     pub fn new(level: Level, message: &str) -> Self {\n         Diagnostic::new_with_code(level, None, message)\n@@ -81,30 +121,38 @@ impl Diagnostic {\n \n     pub fn note_expected_found(&mut self,\n                                label: &fmt::Display,\n-                               expected: &fmt::Display,\n-                               found: &fmt::Display)\n+                               expected: DiagnosticStyledString,\n+                               found: DiagnosticStyledString)\n                                -> &mut Self\n     {\n         self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n     }\n \n     pub fn note_expected_found_extra(&mut self,\n                                      label: &fmt::Display,\n-                                     expected: &fmt::Display,\n-                                     found: &fmt::Display,\n+                                     expected: DiagnosticStyledString,\n+                                     found: DiagnosticStyledString,\n                                      expected_extra: &fmt::Display,\n                                      found_extra: &fmt::Display)\n                                      -> &mut Self\n     {\n+        let mut msg: Vec<_> = vec![(format!(\"expected {} `\", label), Style::NoStyle)];\n+        msg.extend(expected.0.iter()\n+                   .map(|x| match *x {\n+                       StringPart::Normal(ref s) => (s.to_owned(), Style::NoStyle),\n+                       StringPart::Highlighted(ref s) => (s.to_owned(), Style::Highlight),\n+                   }));\n+        msg.push((format!(\"`{}\\n\", expected_extra), Style::NoStyle));\n+        msg.push((format!(\"   found {} `\", label), Style::NoStyle));\n+        msg.extend(found.0.iter()\n+                   .map(|x| match *x {\n+                       StringPart::Normal(ref s) => (s.to_owned(), Style::NoStyle),\n+                       StringPart::Highlighted(ref s) => (s.to_owned(), Style::Highlight),\n+                   }));\n+        msg.push((format!(\"`{}\", found_extra), Style::NoStyle));\n+\n         // For now, just attach these as notes\n-        self.highlighted_note(vec![\n-            (format!(\"expected {} `\", label), Style::NoStyle),\n-            (format!(\"{}\", expected), Style::Highlight),\n-            (format!(\"`{}\\n\", expected_extra), Style::NoStyle),\n-            (format!(\"   found {} `\", label), Style::NoStyle),\n-            (format!(\"{}\", found), Style::Highlight),\n-            (format!(\"`{}\", found_extra), Style::NoStyle),\n-        ]);\n+        self.highlighted_note(msg);\n         self\n     }\n "}, {"sha": "7b27f13951b61b5babf4bc9c32ab37c71f5d8f10", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use Diagnostic;\n+use DiagnosticStyledString;\n+\n use Level;\n use Handler;\n use std::fmt::{self, Debug};\n@@ -115,14 +117,14 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     forward!(pub fn note_expected_found(&mut self,\n                                         label: &fmt::Display,\n-                                        expected: &fmt::Display,\n-                                        found: &fmt::Display)\n+                                        expected: DiagnosticStyledString,\n+                                        found: DiagnosticStyledString)\n                                         -> &mut Self);\n \n     forward!(pub fn note_expected_found_extra(&mut self,\n                                               label: &fmt::Display,\n-                                              expected: &fmt::Display,\n-                                              found: &fmt::Display,\n+                                              expected: DiagnosticStyledString,\n+                                              found: DiagnosticStyledString,\n                                               expected_extra: &fmt::Display,\n                                               found_extra: &fmt::Display)\n                                               -> &mut Self);"}, {"sha": "da29e354a7014eeae31e26f438f63fac7dad4d74", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -203,7 +203,7 @@ impl error::Error for ExplicitBug {\n     }\n }\n \n-pub use diagnostic::{Diagnostic, SubDiagnostic};\n+pub use diagnostic::{Diagnostic, SubDiagnostic, DiagnosticStyledString, StringPart};\n pub use diagnostic_builder::DiagnosticBuilder;\n \n /// A handler deals with errors; certain errors"}, {"sha": "6956a043cc694a4a8ee04375b23c0e658948e10c", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n 16 |     x.push(y);\n    |            ^ lifetime mismatch\n    |\n-   = note: expected type `Ref<'a, i32>`\n-              found type `Ref<'_, i32>`\n+   = note: expected type `Ref<'a, _>`\n+              found type `Ref<'_, _>`\n note: the anonymous lifetime #2 defined on the body at 15:51...\n   --> $DIR/ex2a-push-one-existing-name.rs:15:52\n    |"}, {"sha": "990ae65ba9854193bfcf0f0d3918b60bcae13000", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n 16 |     x.push(y);\n    |            ^ lifetime mismatch\n    |\n-   = note: expected type `Ref<'_, i32>`\n-              found type `Ref<'_, i32>`\n+   = note: expected type `Ref<'_, _>`\n+              found type `Ref<'_, _>`\n note: the anonymous lifetime #3 defined on the body at 15:43...\n   --> $DIR/ex2b-push-no-existing-names.rs:15:44\n    |"}, {"sha": "82f6c71ec1c2eb36314a56c70547593c393920d6", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -27,7 +27,7 @@ note: but, the lifetime must be valid for the lifetime 'b as defined on the body\n 17 | |     x.push(z);\n 18 | | }\n    | |_^ ...ending here\n-note: ...so that expression is assignable (expected Ref<'b, i32>, found Ref<'_, i32>)\n+note: ...so that expression is assignable (expected Ref<'b, _>, found Ref<'_, _>)\n   --> $DIR/ex2c-push-inference-variable.rs:17:12\n    |\n 17 |     x.push(z);"}, {"sha": "c448ad955fab4ec7e360a52f80a45d2f2bdd39fb", "filename": "src/test/ui/mismatched_types/abridged.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.rs?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Bar {\n+    Qux,\n+    Zar,\n+}\n+\n+struct Foo {\n+    bar: usize,\n+}\n+\n+struct X<T1, T2> {\n+    x: T1,\n+    y: T2,\n+}\n+\n+fn a() -> Foo {\n+    Some(Foo { bar: 1 })\n+}\n+\n+fn a2() -> Foo {\n+    Ok(Foo { bar: 1})\n+}\n+\n+fn b() -> Option<Foo> {\n+    Foo { bar: 1 }\n+}\n+\n+fn c() -> Result<Foo, Bar> {\n+    Foo { bar: 1 }\n+}\n+\n+fn d() -> X<X<String, String>, String> {\n+    X {\n+        x: X {\n+            x: \"\".to_string(),\n+            y: 2,\n+        },\n+        y: 3,\n+    }\n+}\n+\n+fn e() -> X<X<String, String>, String> {\n+    X {\n+        x: X {\n+            x: \"\".to_string(),\n+            y: 2,\n+        },\n+        y: \"\".to_string(),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c67c6113d17c54c0aab0dda783643e25158b69bb", "filename": "src/test/ui/mismatched_types/abridged.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2389830deaf39b736e35c471e39543d30f708972/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2389830deaf39b736e35c471e39543d30f708972/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr?ref=2389830deaf39b736e35c471e39543d30f708972", "patch": "@@ -0,0 +1,70 @@\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:26:5\n+   |\n+26 |     Some(Foo { bar: 1 })\n+   |     ^^^^^^^^^^^^^^^^^^^^ expected struct `Foo`, found enum `std::option::Option`\n+   |\n+   = note: expected type `Foo`\n+              found type `std::option::Option<Foo>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:30:5\n+   |\n+30 |     Ok(Foo { bar: 1})\n+   |     ^^^^^^^^^^^^^^^^^ expected struct `Foo`, found enum `std::result::Result`\n+   |\n+   = note: expected type `Foo`\n+              found type `std::result::Result<Foo, _>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:34:5\n+   |\n+34 |     Foo { bar: 1 }\n+   |     ^^^^^^^^^^^^^^ expected enum `std::option::Option`, found struct `Foo`\n+   |\n+   = note: expected type `std::option::Option<Foo>`\n+              found type `Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:38:5\n+   |\n+38 |     Foo { bar: 1 }\n+   |     ^^^^^^^^^^^^^^ expected enum `std::result::Result`, found struct `Foo`\n+   |\n+   = note: expected type `std::result::Result<Foo, Bar>`\n+              found type `Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:42:5\n+   |\n+42 |       X {\n+   |  _____^ starting here...\n+43 | |         x: X {\n+44 | |             x: \"\".to_string(),\n+45 | |             y: 2,\n+46 | |         },\n+47 | |         y: 3,\n+48 | |     }\n+   | |_____^ ...ending here: expected struct `std::string::String`, found integral variable\n+   |\n+   = note: expected type `X<X<_, std::string::String>, std::string::String>`\n+              found type `X<X<_, {integer}>, {integer}>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:52:5\n+   |\n+52 |       X {\n+   |  _____^ starting here...\n+53 | |         x: X {\n+54 | |             x: \"\".to_string(),\n+55 | |             y: 2,\n+56 | |         },\n+57 | |         y: \"\".to_string(),\n+58 | |     }\n+   | |_____^ ...ending here: expected struct `std::string::String`, found integral variable\n+   |\n+   = note: expected type `X<X<_, std::string::String>, _>`\n+              found type `X<X<_, {integer}>, _>`\n+\n+error: aborting due to 6 previous errors\n+"}]}