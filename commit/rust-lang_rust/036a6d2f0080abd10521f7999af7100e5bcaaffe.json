{"sha": "036a6d2f0080abd10521f7999af7100e5bcaaffe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNmE2ZDJmMDA4MGFiZDEwNTIxZjc5OTlhZjcxMDBlNWJjYWFmZmU=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-31T23:14:59Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-01T20:52:37Z"}, "message": "Document task killing design and relaxed barrier rationale.", "tree": {"sha": "e78b403dc5d7735ffe7360b93b719dd83b372050", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e78b403dc5d7735ffe7360b93b719dd83b372050"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/036a6d2f0080abd10521f7999af7100e5bcaaffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/036a6d2f0080abd10521f7999af7100e5bcaaffe", "html_url": "https://github.com/rust-lang/rust/commit/036a6d2f0080abd10521f7999af7100e5bcaaffe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/036a6d2f0080abd10521f7999af7100e5bcaaffe/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "880246618b6c28adc76e5e68247aa5a9302320f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/880246618b6c28adc76e5e68247aa5a9302320f8", "html_url": "https://github.com/rust-lang/rust/commit/880246618b6c28adc76e5e68247aa5a9302320f8"}], "stats": {"total": 58, "additions": 57, "deletions": 1}, "files": [{"sha": "208af522d80e1166fdce0ea45039a6000035d66c", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/036a6d2f0080abd10521f7999af7100e5bcaaffe/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036a6d2f0080abd10521f7999af7100e5bcaaffe/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=036a6d2f0080abd10521f7999af7100e5bcaaffe", "patch": "@@ -8,7 +8,63 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Task death: asynchronous killing, linked failure, exit code propagation.\n+/*!\n+\n+Task death: asynchronous killing, linked failure, exit code propagation.\n+\n+This file implements two orthogonal building-blocks for communicating failure\n+between tasks. One is 'linked failure' or 'task killing', that is, a failing\n+task causing other tasks to fail promptly (even those that are blocked on\n+pipes or I/O). The other is 'exit code propagation', which affects the result\n+observed by the parent of a task::try task that itself spawns child tasks\n+(such as any #[test] function). In both cases the data structures live in\n+KillHandle.\n+\n+I. Task killing.\n+\n+The model for killing involves two atomic flags, the \"kill flag\" and the\n+\"unkillable flag\". Operations on the kill flag include:\n+\n+- In the taskgroup code (task/spawn.rs), tasks store a clone of their\n+  KillHandle in their shared taskgroup. Another task in the group that fails\n+  will use that handle to call kill().\n+- When a task blocks, it turns its ~Task into a BlockedTask by storing a\n+  the transmuted ~Task pointer inside the KillHandle's kill flag. A task\n+  trying to block and a task trying to kill it can simultaneously access the\n+  kill flag, after which the task will get scheduled and fail (no matter who\n+  wins the race). Likewise, a task trying to wake a blocked task normally and\n+  a task trying to kill it can simultaneously access the flag; only one will\n+  get the task to reschedule it.\n+\n+Operations on the unkillable flag include:\n+\n+- When a task becomes unkillable, it swaps on the flag to forbid any killer\n+  from waking it up while it's blocked inside the unkillable section. If a\n+  kill was already pending, the task fails instead of becoming unkillable.\n+- When a task is done being unkillable, it restores the flag to the normal\n+  running state. If a kill was received-but-blocked during the unkillable\n+  section, the task fails at this later point.\n+- When a task tries to kill another task, before swapping on the kill flag, it\n+  first swaps on the unkillable flag, to see if it's \"allowed\" to wake up the\n+  task. If it isn't, the killed task will receive the signal when it becomes\n+  killable again. (Of course, a task trying to wake the task normally (e.g.\n+  sending on a channel) does not access the unkillable flag at all.)\n+\n+Why do we not need acquire/release barriers on any of the kill flag swaps?\n+This is because barriers establish orderings between accesses on different\n+memory locations, but each kill-related operation is only a swap on a single\n+location, so atomicity is all that matters. The exception is kill(), which\n+does a swap on both flags in sequence. kill() needs no barriers because it\n+does not matter if its two accesses are seen reordered on another CPU: if a\n+killer does perform both writes, it means it saw a KILL_RUNNING in the\n+unkillable flag, which means an unkillable task will see KILL_KILLED and fail\n+immediately (rendering the subsequent write to the kill flag unnecessary).\n+\n+II. Exit code propagation.\n+\n+FIXME(#7544): Decide on the ultimate model for this and document it.\n+\n+*/\n \n use cast;\n use cell::Cell;"}]}