{"sha": "d85abd77b98ff5925621c18f2ffe121640d17c80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NWFiZDc3Yjk4ZmY1OTI1NjIxYzE4ZjJmZmUxMjE2NDBkMTdjODA=", "commit": {"author": {"name": "Kevin DeLorey", "email": "2295721+kdelorey@users.noreply.github.com", "date": "2020-02-09T18:24:34Z"}, "committer": {"name": "Kevin DeLorey", "email": "2295721+kdelorey@users.noreply.github.com", "date": "2020-02-09T18:24:59Z"}, "message": "Added a utility function that can be used to determine the missing impl items.", "tree": {"sha": "e63952b8b78cd8c2b3c14cb721f141b9a5185275", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e63952b8b78cd8c2b3c14cb721f141b9a5185275"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d85abd77b98ff5925621c18f2ffe121640d17c80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d85abd77b98ff5925621c18f2ffe121640d17c80", "html_url": "https://github.com/rust-lang/rust/commit/d85abd77b98ff5925621c18f2ffe121640d17c80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d85abd77b98ff5925621c18f2ffe121640d17c80/comments", "author": {"login": "kdelorey", "id": 2295721, "node_id": "MDQ6VXNlcjIyOTU3MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/2295721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kdelorey", "html_url": "https://github.com/kdelorey", "followers_url": "https://api.github.com/users/kdelorey/followers", "following_url": "https://api.github.com/users/kdelorey/following{/other_user}", "gists_url": "https://api.github.com/users/kdelorey/gists{/gist_id}", "starred_url": "https://api.github.com/users/kdelorey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kdelorey/subscriptions", "organizations_url": "https://api.github.com/users/kdelorey/orgs", "repos_url": "https://api.github.com/users/kdelorey/repos", "events_url": "https://api.github.com/users/kdelorey/events{/privacy}", "received_events_url": "https://api.github.com/users/kdelorey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kdelorey", "id": 2295721, "node_id": "MDQ6VXNlcjIyOTU3MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/2295721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kdelorey", "html_url": "https://github.com/kdelorey", "followers_url": "https://api.github.com/users/kdelorey/followers", "following_url": "https://api.github.com/users/kdelorey/following{/other_user}", "gists_url": "https://api.github.com/users/kdelorey/gists{/gist_id}", "starred_url": "https://api.github.com/users/kdelorey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kdelorey/subscriptions", "organizations_url": "https://api.github.com/users/kdelorey/orgs", "repos_url": "https://api.github.com/users/kdelorey/repos", "events_url": "https://api.github.com/users/kdelorey/events{/privacy}", "received_events_url": "https://api.github.com/users/kdelorey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a957c473fdb79880c39b73dc9e0c923093cf16ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/a957c473fdb79880c39b73dc9e0c923093cf16ac", "html_url": "https://github.com/rust-lang/rust/commit/a957c473fdb79880c39b73dc9e0c923093cf16ac"}], "stats": {"total": 213, "additions": 95, "deletions": 118}, "files": [{"sha": "cb124eaf0d2c8a6f08ff07f173e6ded1f3231481", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85abd77b98ff5925621c18f2ffe121640d17c80/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85abd77b98ff5925621c18f2ffe121640d17c80/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=d85abd77b98ff5925621c18f2ffe121640d17c80", "patch": "@@ -9,7 +9,7 @@ mod assist_ctx;\n mod marks;\n #[cfg(test)]\n mod doc_tests;\n-mod utils;\n+pub mod utils;\n pub mod ast_transform;\n \n use ra_db::FileRange;"}, {"sha": "7bc21c6e4e3efd1d4f7063c5bac7a1e157c6285c", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d85abd77b98ff5925621c18f2ffe121640d17c80/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85abd77b98ff5925621c18f2ffe121640d17c80/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=d85abd77b98ff5925621c18f2ffe121640d17c80", "patch": "@@ -1,10 +1,83 @@\n //! Assorted functions shared by several assists.\n \n use ra_syntax::{\n-    ast::{self, make},\n-    T,\n+    ast::{self, make, NameOwner},\n+    AstNode, T,\n };\n \n+use hir::db::HirDatabase;\n+\n+use rustc_hash::FxHashSet;\n+\n+pub fn get_missing_impl_items(\n+    db: &impl HirDatabase,\n+    analyzer: &hir::SourceAnalyzer,\n+    impl_block: &ast::ImplBlock,\n+) -> Vec<hir::AssocItem> {\n+    // since the names are unique only to each associated type (fn/type/const),\n+    // create buckets of each already implemented type that we'll use in the\n+    // lookup later.\n+    let mut impl_fns = FxHashSet::default();\n+    let mut impl_type = FxHashSet::default();\n+    let mut impl_const = FxHashSet::default();\n+\n+    if let Some(item_list) = impl_block.item_list() {\n+        for item in item_list.impl_items() {\n+            match item {\n+                ast::ImplItem::FnDef(f) => {\n+                    if let Some(n) = f.name() {\n+                        impl_fns.insert(n.syntax().to_string());\n+                    }\n+                }\n+\n+                ast::ImplItem::TypeAliasDef(t) => {\n+                    if let Some(n) = t.name() {\n+                        impl_type.insert(n.syntax().to_string());\n+                    }\n+                }\n+\n+                ast::ImplItem::ConstDef(c) => {\n+                    if let Some(n) = c.name() {\n+                        impl_const.insert(n.syntax().to_string());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    resolve_target_trait(db, analyzer, impl_block).map_or(vec![], |target_trait| {\n+        target_trait\n+            .items(db)\n+            .iter()\n+            .filter(|i| match i {\n+                hir::AssocItem::Function(f) => !impl_fns.contains(&f.name(db).to_string()),\n+                hir::AssocItem::TypeAlias(t) => !impl_type.contains(&t.name(db).to_string()),\n+                hir::AssocItem::Const(c) => {\n+                    c.name(db).map(|n| !impl_const.contains(&n.to_string())).unwrap_or_default()\n+                }\n+            })\n+            .map(|i| i.clone())\n+            .collect()\n+    })\n+}\n+\n+fn resolve_target_trait(\n+    db: &impl HirDatabase,\n+    analyzer: &hir::SourceAnalyzer,\n+    impl_block: &ast::ImplBlock,\n+) -> Option<hir::Trait> {\n+    let ast_path = impl_block\n+        .target_trait()\n+        .map(|it| it.syntax().clone())\n+        .and_then(ast::PathType::cast)?\n+        .path()?;\n+\n+    match analyzer.resolve_path(db, &ast_path) {\n+        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def),\n+        _ => None,\n+    }\n+}\n+\n pub(crate) fn invert_boolean_expression(expr: ast::Expr) -> ast::Expr {\n     if let Some(expr) = invert_special_case(&expr) {\n         return expr;"}, {"sha": "4bdc6ba232b84c6ce2f9d13f6569177893167650", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d85abd77b98ff5925621c18f2ffe121640d17c80/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85abd77b98ff5925621c18f2ffe121640d17c80/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=d85abd77b98ff5925621c18f2ffe121640d17c80", "patch": "@@ -76,6 +76,6 @@ pub(crate) fn completions(db: &RootDatabase, position: FilePosition) -> Option<C\n     complete_postfix::complete_postfix(&mut acc, &ctx);\n     complete_macro_in_item_position::complete_macro_in_item_position(&mut acc, &ctx);\n     complete_trait_impl::complete_trait_impl(&mut acc, &ctx);\n-    \n+\n     Some(acc)\n }"}, {"sha": "e2854ee977766cb2f84deaeae57205d6b53a4c18", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 18, "deletions": 114, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/d85abd77b98ff5925621c18f2ffe121640d17c80/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85abd77b98ff5925621c18f2ffe121640d17c80/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=d85abd77b98ff5925621c18f2ffe121640d17c80", "patch": "@@ -1,124 +1,27 @@\n-use crate::completion::{CompletionContext, Completions, CompletionItem, CompletionKind, CompletionItemKind};\n+use crate::completion::{\n+    CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n+};\n \n-use ra_syntax::ast::{self, NameOwner, AstNode};\n-\n-use hir::{self, db::HirDatabase, Docs};\n+use hir::{self, Docs};\n \n+use ra_assists::utils::get_missing_impl_items;\n \n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n     let impl_block = ctx.impl_block.as_ref();\n     let item_list = impl_block.and_then(|i| i.item_list());\n \n-    if item_list.is_none() \n-    || impl_block.is_none() \n-    || ctx.function_syntax.is_some() {\n+    if item_list.is_none() || impl_block.is_none() || ctx.function_syntax.is_some() {\n         return;\n     }\n \n-    let item_list = item_list.unwrap();\n     let impl_block = impl_block.unwrap();\n \n-    let target_trait = resolve_target_trait(ctx.db, &ctx.analyzer, &impl_block);\n-    if target_trait.is_none() {\n-        return;\n-    }\n-\n-    let target_trait = target_trait.unwrap();\n-\n-    let trait_items = target_trait.items(ctx.db);\n-    let missing_items = trait_items\n-        .iter()\n-        .filter(|i| {\n-            match i {\n-                hir::AssocItem::Function(f) => {\n-                    let f_name = f.name(ctx.db).to_string();\n-\n-                    item_list\n-                        .impl_items()\n-                        .find(|impl_item| {\n-                            match impl_item {\n-                                ast::ImplItem::FnDef(impl_f) => {\n-                                    if let Some(n) = impl_f.name() { \n-                                        f_name == n.syntax().to_string()\n-                                    } else { \n-                                        false\n-                                    }\n-                                },\n-                                _ => false\n-                            }\n-                        }).is_none()\n-                },\n-                hir::AssocItem::Const(c) => {\n-                    let c_name = c.name(ctx.db)\n-                        .map(|f| f.to_string());\n-\n-                    if c_name.is_none() {\n-                        return false;\n-                    }\n-\n-                    let c_name = c_name.unwrap();\n-\n-                    item_list\n-                        .impl_items()\n-                        .find(|impl_item| {\n-                            match impl_item {\n-                                ast::ImplItem::ConstDef(c) => {\n-                                    if let Some(n) = c.name() { \n-                                        c_name == n.syntax().to_string()\n-                                    } else { \n-                                        false\n-                                    }\n-                                },\n-                                _ => false\n-                            }\n-                        }).is_none()\n-                },\n-                hir::AssocItem::TypeAlias(t) => {\n-                    let t_name = t.name(ctx.db).to_string();\n-\n-                    item_list\n-                        .impl_items()\n-                        .find(|impl_item| {\n-                            match impl_item {\n-                                ast::ImplItem::TypeAliasDef(t) => {\n-                                    if let Some(n) = t.name() { \n-                                        t_name == n.syntax().to_string()\n-                                    } else { \n-                                        false\n-                                    }\n-                                },\n-                                _ => false\n-                            }\n-                        }).is_none()\n-                }\n-            }\n-        });\n-\n-    for item in missing_items {\n+    for item in get_missing_impl_items(ctx.db, &ctx.analyzer, impl_block) {\n         match item {\n-            hir::AssocItem::Function(f) => add_function_impl(acc, ctx, f),\n-            hir::AssocItem::TypeAlias(t) => add_type_alias_impl(acc, ctx, t),\n-            _ => {},\n-        }\n-    }\n-}\n-\n-fn resolve_target_trait(\n-    db: &impl HirDatabase,\n-    analyzer: &hir::SourceAnalyzer,\n-    impl_block: &ast::ImplBlock\n-) -> Option<hir::Trait> {\n-    let ast_path = impl_block\n-        .target_trait()\n-        .map(|it| it.syntax().clone())\n-        .and_then(ast::PathType::cast)?\n-        .path()?;\n-\n-    match analyzer.resolve_path(db, &ast_path) {\n-        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => {\n-            Some(def)\n+            hir::AssocItem::Function(f) => add_function_impl(acc, ctx, &f),\n+            hir::AssocItem::TypeAlias(t) => add_type_alias_impl(acc, ctx, &t),\n+            _ => {}\n         }\n-        _ => None,\n     }\n }\n \n@@ -144,20 +47,21 @@ fn add_function_impl(acc: &mut Completions, ctx: &CompletionContext, func: &hir:\n     } else {\n         CompletionItemKind::Function\n     };\n-    \n+\n     let snippet = {\n         let mut s = format!(\"{}\", display);\n         s.push_str(\" {}\");\n         s\n     };\n \n-    builder\n-        .insert_text(snippet)\n-        .kind(completion_kind)\n-        .add_to(acc);\n+    builder.insert_text(snippet).kind(completion_kind).add_to(acc);\n }\n \n-fn add_type_alias_impl(acc: &mut Completions, ctx: &CompletionContext, type_alias: &hir::TypeAlias) {\n+fn add_type_alias_impl(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    type_alias: &hir::TypeAlias,\n+) {\n     let snippet = format!(\"type {} = \", type_alias.name(ctx.db).to_string());\n \n     CompletionItem::new(CompletionKind::Magic, ctx.source_range(), snippet.clone())\n@@ -290,4 +194,4 @@ mod tests {\n         ]\n         \"###);\n     }\n-}\n\\ No newline at end of file\n+}"}]}