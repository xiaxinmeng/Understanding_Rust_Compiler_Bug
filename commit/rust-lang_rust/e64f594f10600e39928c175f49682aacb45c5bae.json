{"sha": "e64f594f10600e39928c175f49682aacb45c5bae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NGY1OTRmMTA2MDBlMzk5MjhjMTc1ZjQ5NjgyYWFjYjQ1YzViYWU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-02T15:50:18Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-15T10:26:56Z"}, "message": "Extend --pretty flowgraph=ID to include dataflow results in output.\n\nUse one or more of the following `-Z` flag options to tell the\ngraphviz renderer to include the corresponding dataflow sets (after\nthe iterative constraint propagation reaches a fixed-point solution):\n\n  * `-Z flowgraph-print-loans` : loans computed via middle::borrowck\n  * `-Z flowgraph-print-moves` : moves computed via middle::borrowck::move_data\n  * `-Z flowgraph-print-assigns` : assignments, via middle::borrowck::move_data\n  * `-Z flowgraph-print-all` : all of the available sets are included.\n\nFix #15016.\n\n----\n\nThis also adds a module, `syntax::ast_map::blocks`, that captures a\ncommon abstraction shared amongst code blocks and procedure-like\nthings.  As part of this, moved `ast_map.rs` to subdir\n`ast_map/mod.rs`, to follow our directory layout conventions.\n\n(incorporated review feedback from huon, acrichto.)", "tree": {"sha": "6d9c7729ae0f2f96d032e2735688c97aac5c016a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d9c7729ae0f2f96d032e2735688c97aac5c016a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e64f594f10600e39928c175f49682aacb45c5bae", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e64f594f10600e39928c175f49682aacb45c5bae", "html_url": "https://github.com/rust-lang/rust/commit/e64f594f10600e39928c175f49682aacb45c5bae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e64f594f10600e39928c175f49682aacb45c5bae/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "996263a01589c5d2bd2a5ad559abac267296ad71", "url": "https://api.github.com/repos/rust-lang/rust/commits/996263a01589c5d2bd2a5ad559abac267296ad71", "html_url": "https://github.com/rust-lang/rust/commit/996263a01589c5d2bd2a5ad559abac267296ad71"}], "stats": {"total": 674, "additions": 627, "deletions": 47}, "files": [{"sha": "a3653fa9735901353a3cf331b895fc614e296e0f", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=e64f594f10600e39928c175f49682aacb45c5bae", "patch": "@@ -434,10 +434,37 @@ impl<'a> LabelText<'a> {\n     /// Renders text as string suitable for a label in a .dot file.\n     pub fn escape(&self) -> String {\n         match self {\n-            &LabelStr(ref s) => s.as_slice().escape_default().to_string(),\n-            &EscStr(ref s) => LabelText::escape_str(s.as_slice()).to_string(),\n+            &LabelStr(ref s) => s.as_slice().escape_default(),\n+            &EscStr(ref s) => LabelText::escape_str(s.as_slice()),\n         }\n     }\n+\n+    /// Decomposes content into string suitable for making EscStr that\n+    /// yields same content as self.  The result obeys the law\n+    /// render(`lt`) == render(`EscStr(lt.pre_escaped_content())`) for\n+    /// all `lt: LabelText`.\n+    fn pre_escaped_content(self) -> str::MaybeOwned<'a> {\n+        match self {\n+            EscStr(s) => s,\n+            LabelStr(s) => if s.as_slice().contains_char('\\\\') {\n+                str::Owned(s.as_slice().escape_default())\n+            } else {\n+                s\n+            },\n+        }\n+    }\n+\n+    /// Puts `prefix` on a line above this label, with a blank line separator.\n+    pub fn prefix_line(self, prefix: LabelText) -> LabelText {\n+        prefix.suffix_line(self)\n+    }\n+\n+    /// Puts `suffix` on a line below this label, with a blank line separator.\n+    pub fn suffix_line(self, suffix: LabelText) -> LabelText {\n+        let prefix = self.pre_escaped_content().into_string();\n+        let suffix = suffix.pre_escaped_content();\n+        EscStr(str::Owned(prefix.append(r\"\\n\\n\").append(suffix.as_slice())))\n+    }\n }\n \n pub type Nodes<'a,N> = MaybeOwnedVector<'a,N>;\n@@ -664,10 +691,7 @@ mod tests {\n         let mut writer = MemWriter::new();\n         render(&g, &mut writer).unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        match r.read_to_string() {\n-            Ok(string) => Ok(string.to_string()),\n-            Err(err) => Err(err),\n-        }\n+        r.read_to_string()\n     }\n \n     // All of the tests use raw-strings as the format for the expected outputs,"}, {"sha": "9fe32c6fbcb789cbd9d6d711652ba598e78c379c", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=e64f594f10600e39928c175f49682aacb45c5bae", "patch": "@@ -179,7 +179,11 @@ debugging_opts!(\n         AST_JSON,\n         AST_JSON_NOEXPAND,\n         LS,\n-        SAVE_ANALYSIS\n+        SAVE_ANALYSIS,\n+        FLOWGRAPH_PRINT_LOANS,\n+        FLOWGRAPH_PRINT_MOVES,\n+        FLOWGRAPH_PRINT_ASSIGNS,\n+        FLOWGRAPH_PRINT_ALL\n     ]\n     0\n )\n@@ -215,7 +219,15 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"ast-json-noexpand\", \"Print the pre-expansion AST as JSON and halt\", AST_JSON_NOEXPAND),\n      (\"ls\", \"List the symbols defined by a library crate\", LS),\n      (\"save-analysis\", \"Write syntax and type analysis information \\\n-                        in addition to normal output\", SAVE_ANALYSIS))\n+                        in addition to normal output\", SAVE_ANALYSIS),\n+     (\"flowgraph-print-loans\", \"Include loan analysis data in \\\n+                       --pretty flowgraph output\", FLOWGRAPH_PRINT_LOANS),\n+     (\"flowgraph-print-moves\", \"Include move analysis data in \\\n+                       --pretty flowgraph output\", FLOWGRAPH_PRINT_MOVES),\n+     (\"flowgraph-print-assigns\", \"Include assignment analysis data in \\\n+                       --pretty flowgraph output\", FLOWGRAPH_PRINT_ASSIGNS),\n+     (\"flowgraph-print-all\", \"Include all dataflow analysis data in \\\n+                       --pretty flowgraph output\", FLOWGRAPH_PRINT_ALL))\n }\n \n /// Declare a macro that will define all CodegenOptions fields and parsers all"}, {"sha": "ca9cbe1306e6e5b6b9d14547a817f3f4813817ea", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 78, "deletions": 16, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=e64f594f10600e39928c175f49682aacb45c5bae", "patch": "@@ -19,6 +19,9 @@ use lib::llvm::{ContextRef, ModuleRef};\n use lint;\n use metadata::common::LinkMeta;\n use metadata::creader;\n+use middle::borrowck::{FnPartsWithCFG};\n+use middle::borrowck;\n+use borrowck_dot = middle::borrowck::graphviz;\n use middle::cfg;\n use middle::cfg::graphviz::LabelledCFG;\n use middle::{trans, freevars, stability, kind, ty, typeck, reachable};\n@@ -40,6 +43,7 @@ use std::io;\n use std::io::fs;\n use std::io::MemReader;\n use syntax::ast;\n+use syntax::ast_map::blocks;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n use syntax::diagnostics;\n@@ -662,6 +666,25 @@ impl pprust::PpAnn for TypedAnnotation {\n     }\n }\n \n+fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {\n+    let print_loans   = config::FLOWGRAPH_PRINT_LOANS;\n+    let print_moves   = config::FLOWGRAPH_PRINT_MOVES;\n+    let print_assigns = config::FLOWGRAPH_PRINT_ASSIGNS;\n+    let print_all     = config::FLOWGRAPH_PRINT_ALL;\n+    let opt = |print_which| sess.debugging_opt(print_which);\n+    let mut variants = Vec::new();\n+    if opt(print_all) || opt(print_loans) {\n+        variants.push(borrowck_dot::Loans);\n+    }\n+    if opt(print_all) || opt(print_moves) {\n+        variants.push(borrowck_dot::Moves);\n+    }\n+    if opt(print_all) || opt(print_assigns) {\n+        variants.push(borrowck_dot::Assigns);\n+    }\n+    variants\n+}\n+\n pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n@@ -733,10 +756,17 @@ pub fn pretty_print_input(sess: Session,\n                 sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n                                    nodeid).as_slice())\n             });\n-            let block = match node {\n-                syntax::ast_map::NodeBlock(block) => block,\n-                _ => {\n-                    let message = format!(\"--pretty=flowgraph needs block, got {:?}\",\n+            let code = blocks::Code::from_node(node);\n+            match code {\n+                Some(code) => {\n+                    let variants = gather_flowgraph_variants(&sess);\n+                    let analysis = phase_3_run_analysis_passes(sess, &krate,\n+                                                               ast_map, id);\n+                    print_flowgraph(variants, analysis, code, out)\n+                }\n+                None => {\n+                    let message = format!(\"--pretty=flowgraph needs \\\n+                                           block, fn, or method; got {:?}\",\n                                           node);\n \n                     // point to what was found, if there's an\n@@ -746,10 +776,7 @@ pub fn pretty_print_input(sess: Session,\n                         None => sess.fatal(message.as_slice())\n                     }\n                 }\n-            };\n-            let analysis = phase_3_run_analysis_passes(sess, &krate,\n-                                                       ast_map, id);\n-            print_flowgraph(analysis, block, out)\n+            }\n         }\n         _ => {\n             pprust::print_crate(sess.codemap(),\n@@ -765,17 +792,52 @@ pub fn pretty_print_input(sess: Session,\n \n }\n \n-fn print_flowgraph<W:io::Writer>(analysis: CrateAnalysis,\n-                                 block: ast::P<ast::Block>,\n+fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n+                                 analysis: CrateAnalysis,\n+                                 code: blocks::Code,\n                                  mut out: W) -> io::IoResult<()> {\n     let ty_cx = &analysis.ty_cx;\n-    let cfg = cfg::CFG::new(ty_cx, &*block);\n-    let lcfg = LabelledCFG { ast_map: &ty_cx.map,\n-                             cfg: &cfg,\n-                             name: format!(\"block{}\", block.id), };\n+    let cfg = match code {\n+        blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n+        blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, fn_like.body()),\n+    };\n     debug!(\"cfg: {:?}\", cfg);\n-    let r = dot::render(&lcfg, &mut out);\n-    return expand_err_details(r);\n+\n+    match code {\n+        _ if variants.len() == 0 => {\n+            let lcfg = LabelledCFG {\n+                ast_map: &ty_cx.map,\n+                cfg: &cfg,\n+                name: format!(\"node_{}\", code.id()),\n+            };\n+            let r = dot::render(&lcfg, &mut out);\n+            return expand_err_details(r);\n+        }\n+        blocks::BlockCode(_) => {\n+            ty_cx.sess.err(\"--pretty flowgraph with -Z flowgraph-print \\\n+                            annotations requires fn-like node id.\");\n+            return Ok(())\n+        }\n+        blocks::FnLikeCode(fn_like) => {\n+            let fn_parts = FnPartsWithCFG::from_fn_like(&fn_like, &cfg);\n+            let (bccx, analysis_data) =\n+                borrowck::build_borrowck_dataflow_data_for_fn(ty_cx, fn_parts);\n+\n+            let lcfg = LabelledCFG {\n+                ast_map: &ty_cx.map,\n+                cfg: &cfg,\n+                name: format!(\"node_{}\", code.id()),\n+            };\n+            let lcfg = borrowck_dot::DataflowLabeller {\n+                inner: lcfg,\n+                variants: variants,\n+                borrowck_ctxt: &bccx,\n+                analysis_data: &analysis_data,\n+            };\n+            let r = dot::render(&lcfg, &mut out);\n+            return expand_err_details(r);\n+        }\n+    }\n \n     fn expand_err_details(r: io::IoResult<()>) -> io::IoResult<()> {\n         r.map_err(|ioerr| {"}, {"sha": "e2ddb4a703aa3e4ee009177c1554c3bc8e48e218", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=e64f594f10600e39928c175f49682aacb45c5bae", "patch": "@@ -0,0 +1,148 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module provides linkage between rustc::middle::graph and\n+//! libgraphviz traits, specialized to attaching borrowck analysis\n+//! data to rendered labels.\n+\n+/// For clarity, rename the graphviz crate locally to dot.\n+use dot = graphviz;\n+pub use middle::cfg::graphviz::{Node, Edge};\n+use cfg_dot = middle::cfg::graphviz;\n+\n+use middle::borrowck;\n+use middle::borrowck::{BorrowckCtxt, LoanPath};\n+use middle::cfg::{CFGIndex};\n+use middle::dataflow::{DataFlowOperator, DataFlowContext, EntryOrExit};\n+use middle::dataflow;\n+\n+use std::rc::Rc;\n+use std::str;\n+\n+#[deriving(Show)]\n+pub enum Variant {\n+    Loans,\n+    Moves,\n+    Assigns,\n+}\n+\n+impl Variant {\n+    pub fn short_name(&self) -> &'static str {\n+        match *self {\n+            Loans   => \"loans\",\n+            Moves   => \"moves\",\n+            Assigns => \"assigns\",\n+        }\n+    }\n+}\n+\n+pub struct DataflowLabeller<'a> {\n+    pub inner: cfg_dot::LabelledCFG<'a>,\n+    pub variants: Vec<Variant>,\n+    pub borrowck_ctxt: &'a BorrowckCtxt<'a>,\n+    pub analysis_data: &'a borrowck::AnalysisData<'a>,\n+}\n+\n+impl<'a> DataflowLabeller<'a> {\n+    fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n+        let id = n.val1().data.id;\n+        debug!(\"dataflow_for({}, id={}) {}\", e, id, self.variants);\n+        let mut sets = \"\".to_string();\n+        let mut seen_one = false;\n+        for &variant in self.variants.iter() {\n+            if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n+            sets.push_str(variant.short_name());\n+            sets.push_str(\": \");\n+            sets.push_str(self.dataflow_for_variant(e, n, variant).as_slice());\n+        }\n+        sets\n+    }\n+\n+    fn dataflow_for_variant(&self, e: EntryOrExit, n: &Node, v: Variant) -> String {\n+        let cfgidx = n.val0();\n+        match v {\n+            Loans   => self.dataflow_loans_for(e, cfgidx),\n+            Moves   => self.dataflow_moves_for(e, cfgidx),\n+            Assigns => self.dataflow_assigns_for(e, cfgidx),\n+        }\n+    }\n+\n+    fn build_set<O:DataFlowOperator>(&self,\n+                                     e: EntryOrExit,\n+                                     cfgidx: CFGIndex,\n+                                     dfcx: &DataFlowContext<'a, O>,\n+                                     to_lp: |uint| -> Rc<LoanPath>) -> String {\n+        let mut saw_some = false;\n+        let mut set = \"{\".to_string();\n+        dfcx.each_bit_for_node(e, cfgidx, |index| {\n+            let lp = to_lp(index);\n+            if saw_some {\n+                set.push_str(\", \");\n+            }\n+            let loan_str = self.borrowck_ctxt.loan_path_to_string(&*lp);\n+            set.push_str(loan_str.as_slice());\n+            saw_some = true;\n+            true\n+        });\n+        set.append(\"}\")\n+    }\n+\n+    fn dataflow_loans_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n+        let dfcx = &self.analysis_data.loans;\n+        let loan_index_to_path = |loan_index| {\n+            let all_loans = &self.analysis_data.all_loans;\n+            all_loans.get(loan_index).loan_path()\n+        };\n+        self.build_set(e, cfgidx, dfcx, loan_index_to_path)\n+    }\n+\n+    fn dataflow_moves_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n+        let dfcx = &self.analysis_data.move_data.dfcx_moves;\n+        let move_index_to_path = |move_index| {\n+            let move_data = &self.analysis_data.move_data.move_data;\n+            let moves = move_data.moves.borrow();\n+            let move = moves.get(move_index);\n+            move_data.path_loan_path(move.path)\n+        };\n+        self.build_set(e, cfgidx, dfcx, move_index_to_path)\n+    }\n+\n+    fn dataflow_assigns_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n+        let dfcx = &self.analysis_data.move_data.dfcx_assign;\n+        let assign_index_to_path = |assign_index| {\n+            let move_data = &self.analysis_data.move_data.move_data;\n+            let assignments = move_data.var_assignments.borrow();\n+            let assignment = assignments.get(assign_index);\n+            move_data.path_loan_path(assignment.path)\n+        };\n+        self.build_set(e, cfgidx, dfcx, assign_index_to_path)\n+    }\n+}\n+\n+impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a> {\n+    fn graph_id(&'a self) -> dot::Id<'a> { self.inner.graph_id() }\n+    fn node_id(&'a self, n: &Node<'a>) -> dot::Id<'a> { self.inner.node_id(n) }\n+    fn node_label(&'a self, n: &Node<'a>) -> dot::LabelText<'a> {\n+        let prefix = self.dataflow_for(dataflow::Entry, n);\n+        let suffix = self.dataflow_for(dataflow::Exit, n);\n+        let inner_label = self.inner.node_label(n);\n+        inner_label\n+            .prefix_line(dot::LabelStr(str::Owned(prefix)))\n+            .suffix_line(dot::LabelStr(str::Owned(suffix)))\n+    }\n+    fn edge_label(&'a self, e: &Edge<'a>) -> dot::LabelText<'a> { self.inner.edge_label(e) }\n+}\n+\n+impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a> {\n+    fn nodes(&self) -> dot::Nodes<'a, Node<'a>> { self.inner.nodes() }\n+    fn edges(&self) -> dot::Edges<'a, Edge<'a>> { self.inner.edges() }\n+    fn source(&self, edge: &Edge<'a>) -> Node<'a> { self.inner.source(edge) }\n+    fn target(&self, edge: &Edge<'a>) -> Node<'a> { self.inner.target(edge) }\n+}"}, {"sha": "77b3cfafa63afaa26d6f05fabd7052f212259d82", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 78, "deletions": 8, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=e64f594f10600e39928c175f49682aacb45c5bae", "patch": "@@ -28,6 +28,7 @@ use std::gc::{Gc, GC};\n use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_map::blocks::{FnLikeNode, FnParts};\n use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -50,6 +51,8 @@ pub mod check_loans;\n \n pub mod gather_loans;\n \n+pub mod graphviz;\n+\n pub mod move_data;\n \n #[deriving(Clone)]\n@@ -116,46 +119,107 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n     }\n }\n \n+/// Collection of conclusions determined via borrow checker analyses.\n+pub struct AnalysisData<'a> {\n+    pub all_loans: Vec<Loan>,\n+    pub loans: DataFlowContext<'a, LoanDataFlowOperator>,\n+    pub move_data: move_data::FlowedMoveData<'a>,\n+}\n+\n fn borrowck_fn(this: &mut BorrowckCtxt,\n                fk: &FnKind,\n                decl: &ast::FnDecl,\n                body: &ast::Block,\n                sp: Span,\n                id: ast::NodeId) {\n     debug!(\"borrowck_fn(id={})\", id);\n+    let cfg = cfg::CFG::new(this.tcx, body);\n+    let AnalysisData { all_loans,\n+                       loans: loan_dfcx,\n+                       move_data:flowed_moves } =\n+        build_borrowck_dataflow_data(this, fk, decl, &cfg, body, sp, id);\n+\n+    check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n+                             all_loans.as_slice(), decl, body);\n+\n+    visit::walk_fn(this, fk, decl, body, sp, ());\n+}\n \n+fn build_borrowck_dataflow_data<'a>(this: &mut BorrowckCtxt<'a>,\n+                                    fk: &FnKind,\n+                                    decl: &ast::FnDecl,\n+                                    cfg: &cfg::CFG,\n+                                    body: &ast::Block,\n+                                    sp: Span,\n+                                    id: ast::NodeId) -> AnalysisData<'a> {\n     // Check the body of fn items.\n     let id_range = ast_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, decl, body);\n-    let cfg = cfg::CFG::new(this.tcx, body);\n \n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n                              \"borrowck\",\n                              Some(decl),\n-                             &cfg,\n+                             cfg,\n                              LoanDataFlowOperator,\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n         loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n         loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n     }\n-    loan_dfcx.add_kills_from_flow_exits(&cfg);\n-    loan_dfcx.propagate(&cfg, body);\n+    loan_dfcx.add_kills_from_flow_exits(cfg);\n+    loan_dfcx.propagate(cfg, body);\n \n     let flowed_moves = move_data::FlowedMoveData::new(move_data,\n                                                       this.tcx,\n-                                                      &cfg,\n+                                                      cfg,\n                                                       id_range,\n                                                       decl,\n                                                       body);\n \n-    check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n-                             all_loans.as_slice(), decl, body);\n+    AnalysisData { all_loans: all_loans,\n+                   loans: loan_dfcx,\n+                   move_data:flowed_moves }\n+}\n \n-    visit::walk_fn(this, fk, decl, body, sp, ());\n+/// This and a `ty::ctxt` is all you need to run the dataflow analyses\n+/// used in the borrow checker.\n+pub struct FnPartsWithCFG<'a> {\n+    pub fn_parts: FnParts<'a>,\n+    pub cfg:  &'a cfg::CFG,\n+}\n+\n+impl<'a> FnPartsWithCFG<'a> {\n+    pub fn from_fn_like(f: &'a FnLikeNode,\n+                        g: &'a cfg::CFG) -> FnPartsWithCFG<'a> {\n+        FnPartsWithCFG { fn_parts: f.to_fn_parts(), cfg: g }\n+    }\n+}\n+\n+/// Accessor for introspective clients inspecting `AnalysisData` and\n+/// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n+pub fn build_borrowck_dataflow_data_for_fn<'a>(\n+    tcx: &'a ty::ctxt,\n+    input: FnPartsWithCFG<'a>) -> (BorrowckCtxt<'a>, AnalysisData<'a>) {\n+\n+    let mut bccx = BorrowckCtxt {\n+        tcx: tcx,\n+        stats: box(GC) BorrowStats {\n+            loaned_paths_same: Cell::new(0),\n+            loaned_paths_imm: Cell::new(0),\n+            stable_paths: Cell::new(0),\n+            guaranteed_paths: Cell::new(0),\n+        }\n+    };\n+\n+    let p = input.fn_parts;\n+\n+    let dataflow_data = build_borrowck_dataflow_data(\n+        &mut bccx, &p.kind, p.decl, input.cfg, p.body, p.span, p.id);\n+\n+    (bccx, dataflow_data)\n }\n \n // ----------------------------------------------------------------------\n@@ -198,6 +262,12 @@ pub struct Loan {\n     cause: euv::LoanCause,\n }\n \n+impl Loan {\n+    pub fn loan_path(&self) -> Rc<LoanPath> {\n+        self.loan_path.clone()\n+    }\n+}\n+\n #[deriving(PartialEq, Eq, Hash)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs"}, {"sha": "a9c312fc0a455462e60dbc67953dc27aba9c6bfb", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=e64f594f10600e39928c175f49682aacb45c5bae", "patch": "@@ -189,7 +189,7 @@ impl MoveData {\n         }\n     }\n \n-    fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath> {\n+    pub fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath> {\n         self.paths.borrow().get(index.get()).loan_path.clone()\n     }\n \n@@ -534,7 +534,7 @@ impl MoveData {\n impl<'a> FlowedMoveData<'a> {\n     pub fn new(move_data: MoveData,\n                tcx: &'a ty::ctxt,\n-               cfg: &'a cfg::CFG,\n+               cfg: &cfg::CFG,\n                id_range: ast_util::IdRange,\n                decl: &ast::FnDecl,\n                body: &ast::Block)"}, {"sha": "e9bcdff070de1764d9e8d0c47ce0c03b913364b9", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=e64f594f10600e39928c175f49682aacb45c5bae", "patch": "@@ -117,3 +117,4 @@ impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a>\n     fn source(&self, edge: &Edge<'a>) -> Node<'a> { self.cfg.source(edge) }\n     fn target(&self, edge: &Edge<'a>) -> Node<'a> { self.cfg.target(edge) }\n }\n+"}, {"sha": "b28c0158584e6c96a06c054a5115ce14fa429d19", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=e64f594f10600e39928c175f49682aacb45c5bae", "patch": "@@ -28,6 +28,9 @@ use syntax::visit;\n use syntax::print::{pp, pprust};\n use util::nodemap::NodeMap;\n \n+#[deriving(Show)]\n+pub enum EntryOrExit { Entry, Exit }\n+\n #[deriving(Clone)]\n pub struct DataFlowContext<'a, O> {\n     tcx: &'a ty::ctxt,\n@@ -93,17 +96,18 @@ fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n }\n \n impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n-    fn has_bitset(&self, n: ast::NodeId) -> bool {\n+    fn has_bitset_for_nodeid(&self, n: ast::NodeId) -> bool {\n         assert!(n != ast::DUMMY_NODE_ID);\n         match self.nodeid_to_index.find(&n) {\n             None => false,\n-            Some(&cfgidx) => {\n-                let node_id = cfgidx.node_id();\n-                node_id < self.index_to_bitset.len() &&\n-                    self.index_to_bitset.get(node_id).is_some()\n-            }\n+            Some(&cfgidx) => self.has_bitset_for_cfgidx(cfgidx),\n         }\n     }\n+    fn has_bitset_for_cfgidx(&self, cfgidx: CFGIndex) -> bool {\n+        let node_id = cfgidx.node_id();\n+        node_id < self.index_to_bitset.len() &&\n+            self.index_to_bitset.get(node_id).is_some()\n+    }\n     fn get_bitset_index(&self, cfgidx: CFGIndex) -> uint {\n         let node_id = cfgidx.node_id();\n         self.index_to_bitset.get(node_id).unwrap()\n@@ -160,7 +164,7 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n             pprust::NodePat(pat) => pat.id\n         };\n \n-        if self.has_bitset(id) {\n+        if self.has_bitset_for_nodeid(id) {\n             let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n             let (start, end) = self.compute_id_range_frozen(cfgidx);\n             let on_entry = self.on_entry.slice(start, end);\n@@ -287,7 +291,7 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     }\n \n     fn apply_gen_kill(&mut self, cfgidx: CFGIndex, bits: &mut [uint]) {\n-        //! Applies the gen and kill sets for `id` to `bits`\n+        //! Applies the gen and kill sets for `cfgidx` to `bits`\n         debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n         let (start, end) = self.compute_id_range(cfgidx);\n@@ -300,6 +304,21 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n     }\n \n+    fn apply_gen_kill_frozen(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n+        //! Applies the gen and kill sets for `cfgidx` to `bits`\n+        //! Only useful after `propagate()` has been called.\n+        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n+               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n+        let (start, end) = self.compute_id_range_frozen(cfgidx);\n+        let gens = self.gens.slice(start, end);\n+        bitwise(bits, gens, &Union);\n+        let kills = self.kills.slice(start, end);\n+        bitwise(bits, kills, &Subtract);\n+\n+        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [after]\",\n+               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n+    }\n+\n     fn compute_id_range_frozen(&self, cfgidx: CFGIndex) -> (uint, uint) {\n         let n = self.get_bitset_index(cfgidx);\n         let start = n * self.words_per_id;\n@@ -327,21 +346,45 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n                                     -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n-        if !self.has_bitset(id) {\n+        if !self.has_bitset_for_nodeid(id) {\n             return true;\n         }\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        self.each_bit_for_node(Entry, cfgidx, f)\n+    }\n+\n+    pub fn each_bit_for_node(&self,\n+                             e: EntryOrExit,\n+                             cfgidx: CFGIndex,\n+                             f: |uint| -> bool)\n+                             -> bool {\n+        //! Iterates through each bit that is set on entry/exit to `cfgidx`.\n+        //! Only useful after `propagate()` has been called.\n+        if !self.has_bitset_for_cfgidx(cfgidx) {\n+            return true;\n+        }\n         let (start, end) = self.compute_id_range_frozen(cfgidx);\n         let on_entry = self.on_entry.slice(start, end);\n-        debug!(\"{:s} each_bit_on_entry_frozen(id={:?}, on_entry={})\",\n-               self.analysis_name, id, bits_to_string(on_entry));\n-        self.each_bit(on_entry, f)\n+        let temp_bits;\n+        let slice = match e {\n+            Entry => on_entry,\n+            Exit => {\n+                let mut t = on_entry.to_owned();\n+                self.apply_gen_kill_frozen(cfgidx, t.as_mut_slice());\n+                temp_bits = t;\n+                temp_bits.as_slice()\n+            }\n+        };\n+        debug!(\"{:s} each_bit_for_node({}, cfgidx={}) bits={}\",\n+               self.analysis_name, e, cfgidx, bits_to_string(slice));\n+        self.each_bit(slice, f)\n     }\n \n     pub fn each_gen_bit_frozen(&self, id: ast::NodeId, f: |uint| -> bool)\n                                -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n-        if !self.has_bitset(id) {\n+        //! Only useful after `propagate()` has been called.\n+        if !self.has_bitset_for_nodeid(id) {\n             return true;\n         }\n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);"}, {"sha": "1280b884f117a05a2c0819e98c764d95cd29516d", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=e64f594f10600e39928c175f49682aacb45c5bae", "patch": "@@ -0,0 +1,218 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module provides a simplified abstraction for working with\n+//! code blocks identified by their integer node-id.  In particular,\n+//! it captures a common set of attributes that all \"function-like\n+//! things\" (represented by `FnLike` instances) share.  For example,\n+//! all `FnLike` instances have a type signature (be it explicit or\n+//! inferred).  And all `FnLike` instances have a body, i.e. the code\n+//! that is run when the function-like thing it represents is invoked.\n+//!\n+//! With the above abstraction in place, one can treat the program\n+//! text as a collection of blocks of code (and most such blocks are\n+//! nested within a uniquely determined `FnLike`), and users can ask\n+//! for the `Code` associated with a particular NodeId.\n+\n+use abi;\n+use ast::{P, Block, FnDecl, NodeId};\n+use ast;\n+use ast_map::{Node};\n+use ast_map;\n+use ast_util;\n+use codemap::Span;\n+use visit;\n+\n+/// An FnLikeNode is a Node that is like a fn, in that it has a decl\n+/// and a body (as well as a NodeId, a span, etc).\n+///\n+/// More specifically, it is one of either:\n+///   - A function item,\n+///   - A closure expr (i.e. an ExprFnBlock or ExprProc), or\n+///   - The default implementation for a trait method.\n+///\n+/// To construct one, use the `Code::from_node` function.\n+pub struct FnLikeNode { node: ast_map::Node }\n+\n+/// MaybeFnLike wraps a method that indicates if an object\n+/// corresponds to some FnLikeNode.\n+pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n+\n+/// Components shared by fn-like things (fn items, methods, closures).\n+pub struct FnParts<'a> {\n+    pub decl: P<FnDecl>,\n+    pub body: P<Block>,\n+    pub kind: visit::FnKind<'a>,\n+    pub span: Span,\n+    pub id:   NodeId,\n+}\n+\n+impl MaybeFnLike for ast::Item {\n+    fn is_fn_like(&self) -> bool {\n+        match self.node { ast::ItemFn(..) => true, _ => false, }\n+    }\n+}\n+\n+impl MaybeFnLike for ast::TraitMethod {\n+    fn is_fn_like(&self) -> bool {\n+        match *self { ast::Provided(_) => true, _ => false, }\n+    }\n+}\n+\n+impl MaybeFnLike for ast::Expr {\n+    fn is_fn_like(&self) -> bool {\n+        match self.node {\n+            ast::ExprFnBlock(..) | ast::ExprProc(..) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// Carries either an FnLikeNode or a Block, as these are the two\n+/// constructs that correspond to \"code\" (as in, something from which\n+/// we can construct a control-flow graph).\n+pub enum Code {\n+    FnLikeCode(FnLikeNode),\n+    BlockCode(P<Block>),\n+}\n+\n+impl Code {\n+    pub fn id(&self) -> ast::NodeId {\n+        match *self {\n+            FnLikeCode(node) => node.id(),\n+            BlockCode(block) => block.id,\n+        }\n+    }\n+\n+    /// Attempts to construct a Code from presumed FnLike or Block node input.\n+    pub fn from_node(node: Node) -> Option<Code> {\n+        fn new(node: Node) -> FnLikeNode { FnLikeNode { node: node } }\n+        match node {\n+            ast_map::NodeItem(item) if item.is_fn_like() =>\n+                Some(FnLikeCode(new(node))),\n+            ast_map::NodeTraitMethod(tm) if tm.is_fn_like() =>\n+                Some(FnLikeCode(new(node))),\n+            ast_map::NodeMethod(_) =>\n+                Some(FnLikeCode(new(node))),\n+            ast_map::NodeExpr(e) if e.is_fn_like() =>\n+                Some(FnLikeCode(new(node))),\n+            ast_map::NodeBlock(block) =>\n+                Some(BlockCode(block)),\n+            _ =>\n+                None,\n+        }\n+    }\n+}\n+\n+/// These are all the components one can extract from a fn item for\n+/// use when implementing FnLikeNode operations.\n+struct ItemFnParts<'a> {\n+    ident:    ast::Ident,\n+    decl:     P<ast::FnDecl>,\n+    style:    ast::FnStyle,\n+    abi:      abi::Abi,\n+    generics: &'a ast::Generics,\n+    body:     P<Block>,\n+    id:       ast::NodeId,\n+    span:     Span\n+}\n+\n+/// These are all the components one can extract from a closure expr\n+/// for use when implementing FnLikeNode operations.\n+struct ClosureParts {\n+    decl: P<FnDecl>,\n+    body: P<Block>,\n+    id: NodeId,\n+    span: Span\n+}\n+\n+impl ClosureParts {\n+    fn new(d: P<FnDecl>, b: P<Block>, id: NodeId, s: Span) -> ClosureParts {\n+        ClosureParts { decl: d, body: b, id: id, span: s }\n+    }\n+}\n+\n+impl FnLikeNode {\n+    pub fn to_fn_parts<'a>(&'a self) -> FnParts<'a> {\n+        FnParts {\n+            decl: self.decl(),\n+            body: self.body(),\n+            kind: self.kind(),\n+            span: self.span(),\n+            id:   self.id(),\n+        }\n+    }\n+\n+    pub fn body<'a>(&'a self) -> P<Block> {\n+        self.handle(|i: ItemFnParts|     i.body,\n+                    |m: &'a ast::Method| ast_util::method_body(m),\n+                    |c: ClosureParts|    c.body)\n+    }\n+\n+    pub fn decl<'a>(&'a self) -> P<FnDecl> {\n+        self.handle(|i: ItemFnParts|     i.decl,\n+                    |m: &'a ast::Method| ast_util::method_fn_decl(m),\n+                    |c: ClosureParts|    c.decl)\n+    }\n+\n+    pub fn span<'a>(&'a self) -> Span {\n+        self.handle(|i: ItemFnParts|     i.span,\n+                    |m: &'a ast::Method| m.span,\n+                    |c: ClosureParts|    c.span)\n+    }\n+\n+    pub fn id<'a>(&'a self) -> NodeId {\n+        self.handle(|i: ItemFnParts|     i.id,\n+                    |m: &'a ast::Method| m.id,\n+                    |c: ClosureParts|    c.id)\n+    }\n+\n+    pub fn kind<'a>(&'a self) -> visit::FnKind<'a> {\n+        let item = |p: ItemFnParts<'a>| -> visit::FnKind<'a> {\n+            visit::FkItemFn(p.ident, p.generics, p.style, p.abi)\n+        };\n+        let closure = |_: ClosureParts| {\n+            visit::FkFnBlock\n+        };\n+        let method = |m: &'a ast::Method| {\n+            visit::FkMethod(ast_util::method_ident(m), ast_util::method_generics(m), m)\n+        };\n+        self.handle(item, method, closure)\n+    }\n+\n+    fn handle<'a, A>(&'a self,\n+                     item_fn: |ItemFnParts<'a>| -> A,\n+                     method: |&'a ast::Method| -> A,\n+                     closure: |ClosureParts| -> A) -> A {\n+        match self.node {\n+            ast_map::NodeItem(ref i) => match i.node {\n+                ast::ItemFn(decl, style, abi, ref generics, block) =>\n+                    item_fn(ItemFnParts{\n+                        ident: i.ident, decl: decl, style: style, body: block,\n+                        generics: generics, abi: abi, id: i.id, span: i.span\n+                    }),\n+                _ => fail!(\"item FnLikeNode that is not fn-like\"),\n+            },\n+            ast_map::NodeTraitMethod(ref t) => match **t {\n+                ast::Provided(ref m) => method(&**m),\n+                _ => fail!(\"trait method FnLikeNode that is not fn-like\"),\n+            },\n+            ast_map::NodeMethod(ref m) => method(&**m),\n+            ast_map::NodeExpr(ref e) => match e.node {\n+                ast::ExprFnBlock(ref decl, ref block) =>\n+                    closure(ClosureParts::new(*decl, *block, e.id, e.span)),\n+                ast::ExprProc(ref decl, ref block) =>\n+                    closure(ClosureParts::new(*decl, *block, e.id, e.span)),\n+                _ => fail!(\"expr FnLikeNode that is not fn-like\"),\n+            },\n+            _ => fail!(\"other FnLikeNode that is not fn-like\"),\n+        }\n+    }\n+}"}, {"sha": "50e487b63db1f66bdf4d35a7239b687e653c6fa1", "filename": "src/libsyntax/ast_map/mod.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f594f10600e39928c175f49682aacb45c5bae/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=e64f594f10600e39928c175f49682aacb45c5bae", "patch": "@@ -24,6 +24,8 @@ use std::gc::{Gc, GC};\n use std::iter;\n use std::slice;\n \n+pub mod blocks;\n+\n #[deriving(Clone, PartialEq)]\n pub enum PathElem {\n     PathMod(Name),", "previous_filename": "src/libsyntax/ast_map.rs"}]}