{"sha": "442fbc473e10d1efe3359b19f342d11097259fc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MmZiYzQ3M2UxMGQxZWZlMzM1OWIxOWYzNDJkMTEwOTcyNTlmYzQ=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-04T21:35:58Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-24T17:25:15Z"}, "message": "Replace enum LintId with an extensible alternative", "tree": {"sha": "2cd1c9fa79cd37a0453b8c4a1b3fe9b0d05eed9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cd1c9fa79cd37a0453b8c4a1b3fe9b0d05eed9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/442fbc473e10d1efe3359b19f342d11097259fc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/442fbc473e10d1efe3359b19f342d11097259fc4", "html_url": "https://github.com/rust-lang/rust/commit/442fbc473e10d1efe3359b19f342d11097259fc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/442fbc473e10d1efe3359b19f342d11097259fc4/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455", "url": "https://api.github.com/repos/rust-lang/rust/commits/69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455", "html_url": "https://github.com/rust-lang/rust/commit/69b6bc5eee9174d0f2ef1e4ff60a6ed06aedf455"}], "stats": {"total": 1510, "additions": 744, "deletions": 766}, "files": [{"sha": "d815e3d8a86e66379b0b742a871ccab6aeae8dfa", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -70,7 +70,8 @@ pub struct Options {\n     pub gc: bool,\n     pub optimize: OptLevel,\n     pub debuginfo: DebugInfoLevel,\n-    pub lint_opts: Vec<(lint::LintId, lint::Level)> ,\n+    pub lint_opts: Vec<(String, lint::Level)>,\n+    pub describe_lints: bool,\n     pub output_types: Vec<back::link::OutputType> ,\n     // This was mutable for rustpkg, which updates search paths based on the\n     // parsed code. It remains mutable in case its replacements wants to use\n@@ -104,6 +105,7 @@ pub fn basic_options() -> Options {\n         optimize: No,\n         debuginfo: NoDebugInfo,\n         lint_opts: Vec::new(),\n+        describe_lints: false,\n         output_types: Vec::new(),\n         addl_lib_search_paths: RefCell::new(HashSet::new()),\n         maybe_sysroot: None,\n@@ -585,30 +587,15 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let no_trans = matches.opt_present(\"no-trans\");\n     let no_analysis = matches.opt_present(\"no-analysis\");\n \n-    let lint_levels = [lint::Allow, lint::Warn,\n-                       lint::Deny, lint::Forbid];\n-    let mut lint_opts = Vec::new();\n-    let lint_dict = lint::get_lint_dict();\n-    for level in lint_levels.iter() {\n-        let level_name = lint::level_to_str(*level);\n-\n-        let level_short = level_name.slice_chars(0, 1);\n-        let level_short = level_short.to_ascii().to_upper().into_str();\n-        let flags = matches.opt_strs(level_short.as_slice())\n-                           .move_iter()\n-                           .collect::<Vec<_>>()\n-                           .append(matches.opt_strs(level_name).as_slice());\n-        for lint_name in flags.iter() {\n-            let lint_name = lint_name.replace(\"-\", \"_\").into_string();\n-            match lint_dict.find_equiv(&lint_name) {\n-              None => {\n-                early_error(format!(\"unknown {} flag: {}\",\n-                                    level_name,\n-                                    lint_name).as_slice());\n-              }\n-              Some(lint) => {\n-                lint_opts.push((lint.lint, *level));\n-              }\n+    let mut lint_opts = vec!();\n+    let mut describe_lints = false;\n+\n+    for &level in [lint::Allow, lint::Warn, lint::Deny, lint::Forbid].iter() {\n+        for lint_name in matches.opt_strs(level.as_str()).move_iter() {\n+            if lint_name.as_slice() == \"help\" {\n+                describe_lints = true;\n+            } else {\n+                lint_opts.push((lint_name.replace(\"-\", \"_\").into_string(), level));\n             }\n         }\n     }\n@@ -752,6 +739,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         optimize: opt_level,\n         debuginfo: debuginfo,\n         lint_opts: lint_opts,\n+        describe_lints: describe_lints,\n         output_types: output_types,\n         addl_lib_search_paths: RefCell::new(addl_lib_search_paths),\n         maybe_sysroot: sysroot_opt,"}, {"sha": "2aa2746959fcbbd037f3103380de4391070da751", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -767,15 +767,15 @@ pub fn collect_crate_types(session: &Session,\n                 }\n                 Some(ref n) if n.equiv(&(\"bin\")) => Some(config::CrateTypeExecutable),\n                 Some(_) => {\n-                    session.add_lint(lint::UnknownCrateType,\n+                    session.add_lint(lint::builtin::unknown_crate_type,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"invalid `crate_type` \\\n                                       value\".to_string());\n                     None\n                 }\n                 _ => {\n-                    session.add_lint(lint::UnknownCrateType,\n+                    session.add_lint(lint::builtin::unknown_crate_type,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"`crate_type` requires a \\"}, {"sha": "623698f6c71ae7a596bb0132f0db8e303e5e7594", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -17,7 +17,6 @@ use lint;\n use metadata;\n \n use std::any::AnyRefExt;\n-use std::cmp;\n use std::io;\n use std::os;\n use std::str;\n@@ -50,6 +49,12 @@ fn run_compiler(args: &[String]) {\n         None => return\n     };\n \n+    let sopts = config::build_session_options(&matches);\n+    if sopts.describe_lints {\n+        describe_lints();\n+        return;\n+    }\n+\n     let (input, input_file_path) = match matches.free.len() {\n         0u => early_error(\"no input filename given\"),\n         1u => {\n@@ -66,7 +71,6 @@ fn run_compiler(args: &[String]) {\n         _ => early_error(\"multiple input filenames provided\")\n     };\n \n-    let sopts = config::build_session_options(&matches);\n     let sess = build_session(sopts, input_file_path);\n     let cfg = config::build_configuration(&sess);\n     let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n@@ -124,7 +128,7 @@ Additional help:\n                              config::optgroups().as_slice()));\n }\n \n-fn describe_warnings() {\n+fn describe_lints() {\n     println!(\"\n Available lint options:\n     -W <foo>           Warn about <foo>\n@@ -133,30 +137,32 @@ Available lint options:\n     -F <foo>           Forbid <foo> (deny, and deny all overrides)\n \");\n \n-    let lint_dict = lint::get_lint_dict();\n-    let mut lint_dict = lint_dict.move_iter()\n-                                 .map(|(k, v)| (v, k))\n-                                 .collect::<Vec<(lint::LintSpec, &'static str)> >();\n-    lint_dict.as_mut_slice().sort();\n+    let mut builtin_specs = lint::builtin_lint_specs();\n+    builtin_specs.sort_by(|x, y| {\n+        match x.default_level.cmp(&y.default_level) {\n+            Equal => x.name.cmp(&y.name),\n+            r => r,\n+        }\n+    });\n+\n+    // FIXME: What if someone uses combining characters or East Asian fullwidth\n+    // characters in a lint name?!?!?\n+    let max_name_len = builtin_specs.iter()\n+        .map(|&s| s.name.char_len())\n+        .max().unwrap_or(0);\n+    let padded = |x: &str| {\n+        format!(\"{}{}\", \" \".repeat(max_name_len - x.char_len()), x)\n+    };\n \n-    let mut max_key = 0;\n-    for &(_, name) in lint_dict.iter() {\n-        max_key = cmp::max(name.len(), max_key);\n-    }\n-    fn padded(max: uint, s: &str) -> String {\n-        format!(\"{}{}\", \" \".repeat(max - s.len()), s)\n-    }\n     println!(\"\\nAvailable lint checks:\\n\");\n-    println!(\"    {}  {:7.7s}  {}\",\n-             padded(max_key, \"name\"), \"default\", \"meaning\");\n-    println!(\"    {}  {:7.7s}  {}\\n\",\n-             padded(max_key, \"----\"), \"-------\", \"-------\");\n-    for (spec, name) in lint_dict.move_iter() {\n-        let name = name.replace(\"_\", \"-\");\n+    println!(\"    {}  {:7.7s}  {}\", padded(\"name\"), \"default\", \"meaning\");\n+    println!(\"    {}  {:7.7s}  {}\", padded(\"----\"), \"-------\", \"-------\");\n+    println!(\"\");\n+\n+    for spec in builtin_specs.move_iter() {\n+        let name = spec.name.replace(\"_\", \"-\");\n         println!(\"    {}  {:7.7s}  {}\",\n-                 padded(max_key, name.as_slice()),\n-                 lint::level_to_str(spec.default),\n-                 spec.desc);\n+            padded(name.as_slice()), spec.default_level.as_str(), spec.desc);\n     }\n     println!(\"\");\n }\n@@ -214,12 +220,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n         return None;\n     }\n \n-    let lint_flags = matches.opt_strs(\"W\").move_iter().collect::<Vec<_>>().append(\n-                                    matches.opt_strs(\"warn\").as_slice());\n-    if lint_flags.iter().any(|x| x.as_slice() == \"help\") {\n-        describe_warnings();\n-        return None;\n-    }\n+    // Don't handle -W help here, because we might first load plugins.\n \n     let r = matches.opt_strs(\"Z\");\n     if r.iter().any(|x| x.as_slice() == \"help\") {"}, {"sha": "7f20059b65703eb778f0e7b5eb96e4a799207301", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -106,16 +106,17 @@ impl Session {\n         self.diagnostic().handler().unimpl(msg)\n     }\n     pub fn add_lint(&self,\n-                    lint: lint::LintId,\n+                    lint: &'static lint::Lint,\n                     id: ast::NodeId,\n                     sp: Span,\n                     msg: String) {\n+        let lint_id = lint::LintId::of(lint);\n         let mut lints = self.lints.borrow_mut();\n         match lints.find_mut(&id) {\n-            Some(arr) => { arr.push((lint, sp, msg)); return; }\n+            Some(arr) => { arr.push((lint_id, sp, msg)); return; }\n             None => {}\n         }\n-        lints.insert(id, vec!((lint, sp, msg)));\n+        lints.insert(id, vec!((lint_id, sp, msg)));\n     }\n     pub fn next_node_id(&self) -> ast::NodeId {\n         self.reserve_node_ids(1)"}, {"sha": "b7c1ebcda988060e0c4d47653be3895a1e1b9afc", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -409,7 +409,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n                                                      directive not necessary\");\n                         }\n                         None => {\n-                            sess.add_lint(lint::UnknownFeatures,\n+                            sess.add_lint(lint::builtin::unknown_features,\n                                           ast::CRATE_NODE_ID,\n                                           mi.span,\n                                           \"unknown feature\".to_string());"}, {"sha": "0703b1fab603e2d0ddbd4245c98c2257fafad084", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -127,6 +127,15 @@ pub mod lib {\n     pub mod llvmdeps;\n }\n \n+// A private module so that macro-expanded idents like\n+// `::rustc::lint::Lint` will also work in `rustc` itself.\n+//\n+// `libstd` uses the same trick.\n+#[doc(hidden)]\n+mod rustc {\n+    pub use lint;\n+}\n+\n pub fn main() {\n     let args = std::os::args().iter()\n                               .map(|x| x.to_string())"}, {"sha": "7fbefbf94160d1f0fd1d6d0aa37d1305a980055e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 341, "deletions": 124, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -19,7 +19,7 @@ use middle::privacy::ExportedItems;\n use middle::{typeck, ty, def, pat_util};\n use util::ppaux::{ty_to_str};\n use util::nodemap::NodeSet;\n-use lint::{Context, LintPass};\n+use lint::{Context, LintPass, LintArray};\n use lint;\n \n use std::cmp;\n@@ -41,40 +41,25 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::{ast, ast_util, visit};\n \n-/// Doesn't actually warn; just gathers information for use by\n-/// checks in trans.\n-#[deriving(Default)]\n-pub struct GatherNodeLevels;\n-\n-impl LintPass for GatherNodeLevels {\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        match it.node {\n-            ast::ItemEnum(..) => {\n-                match cx.cur.find(&(lint::VariantSizeDifference as uint)) {\n-                    Some(&(lvl, src)) if lvl != lint::Allow => {\n-                        cx.insert_node_level(it.id, lint::VariantSizeDifference, lvl, src);\n-                    },\n-                    _ => { }\n-                }\n-            },\n-            _ => { }\n-        }\n-    }\n-}\n+declare_lint!(while_true, Warn,\n+    \"suggest using `loop { }` instead of `while true { }`\")\n \n #[deriving(Default)]\n pub struct WhileTrue;\n \n impl LintPass for WhileTrue {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(while_true)\n+    }\n+\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             ast::ExprWhile(cond, _) => {\n                 match cond.node {\n                     ast::ExprLit(lit) => {\n                         match lit.node {\n                             ast::LitBool(true) => {\n-                                cx.span_lint(lint::WhileTrue,\n-                                             e.span,\n+                                cx.span_lint(while_true, e.span,\n                                              \"denote infinite loops with loop \\\n                                               { ... }\");\n                             }\n@@ -89,24 +74,39 @@ impl LintPass for WhileTrue {\n     }\n }\n \n+declare_lint!(unnecessary_typecast, Allow,\n+    \"detects unnecessary type casts, that can be removed\")\n+\n #[deriving(Default)]\n pub struct UnusedCasts;\n \n impl LintPass for UnusedCasts {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(unnecessary_typecast)\n+    }\n+\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             ast::ExprCast(expr, ty) => {\n                 let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), ty);\n                 if  ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n-                    cx.span_lint(lint::UnnecessaryTypecast, ty.span,\n-                                 \"unnecessary type cast\");\n+                    cx.span_lint(unnecessary_typecast, ty.span, \"unnecessary type cast\");\n                 }\n             }\n             _ => ()\n         }\n     }\n }\n \n+declare_lint!(unsigned_negate, Warn,\n+    \"using an unary minus operator on unsigned type\")\n+\n+declare_lint!(type_limits, Warn,\n+    \"comparisons made useless by limits of the types involved\")\n+\n+declare_lint!(type_overflow, Warn,\n+    \"literal out of range for its type\")\n+\n pub struct TypeLimits {\n     /// Id of the last visited negated expression\n     negated_expr_id: ast::NodeId,\n@@ -121,14 +121,18 @@ impl Default for TypeLimits {\n }\n \n impl LintPass for TypeLimits {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(unsigned_negate, type_limits, type_overflow)\n+    }\n+\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             ast::ExprUnary(ast::UnNeg, expr) => {\n                 match expr.node  {\n                     ast::ExprLit(lit) => {\n                         match lit.node {\n                             ast::LitUint(..) => {\n-                                cx.span_lint(lint::UnsignedNegate, e.span,\n+                                cx.span_lint(unsigned_negate, e.span,\n                                              \"negation of unsigned int literal may \\\n                                              be unintentional\");\n                             },\n@@ -139,7 +143,7 @@ impl LintPass for TypeLimits {\n                         let t = ty::expr_ty(cx.tcx, expr);\n                         match ty::get(t).sty {\n                             ty::ty_uint(_) => {\n-                                cx.span_lint(lint::UnsignedNegate, e.span,\n+                                cx.span_lint(unsigned_negate, e.span,\n                                              \"negation of unsigned int variable may \\\n                                              be unintentional\");\n                             },\n@@ -157,7 +161,7 @@ impl LintPass for TypeLimits {\n             },\n             ast::ExprBinary(binop, l, r) => {\n                 if is_comparison(binop) && !check_limits(cx.tcx, binop, l, r) {\n-                    cx.span_lint(lint::TypeLimits, e.span,\n+                    cx.span_lint(type_limits, e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n             },\n@@ -178,7 +182,7 @@ impl LintPass for TypeLimits {\n                             lit_val *= -1;\n                         }\n                         if  lit_val < min || lit_val > max {\n-                            cx.span_lint(lint::TypeOverflow, e.span,\n+                            cx.span_lint(type_overflow, e.span,\n                                          \"literal out of range for its type\");\n                         }\n                     },\n@@ -194,7 +198,7 @@ impl LintPass for TypeLimits {\n                             _ => fail!()\n                         };\n                         if  lit_val < min || lit_val > max {\n-                            cx.span_lint(lint::TypeOverflow, e.span,\n+                            cx.span_lint(type_overflow, e.span,\n                                          \"literal out of range for its type\");\n                         }\n                     },\n@@ -300,30 +304,37 @@ impl LintPass for TypeLimits {\n     }\n }\n \n+declare_lint!(ctypes, Warn,\n+    \"proper use of libc types in foreign modules\")\n+\n #[deriving(Default)]\n pub struct CTypes;\n \n impl LintPass for CTypes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(ctypes)\n+    }\n+\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         fn check_ty(cx: &Context, ty: &ast::Ty) {\n             match ty.node {\n                 ast::TyPath(_, _, id) => {\n                     match cx.tcx.def_map.borrow().get_copy(&id) {\n                         def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n-                            cx.span_lint(lint::CTypes, ty.span,\n-                                    \"found rust type `int` in foreign module, while \\\n-                                    libc::c_int or libc::c_long should be used\");\n+                            cx.span_lint(ctypes, ty.span,\n+                                \"found rust type `int` in foreign module, while \\\n+                                 libc::c_int or libc::c_long should be used\");\n                         }\n                         def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n-                            cx.span_lint(lint::CTypes, ty.span,\n-                                    \"found rust type `uint` in foreign module, while \\\n-                                    libc::c_uint or libc::c_ulong should be used\");\n+                            cx.span_lint(ctypes, ty.span,\n+                                \"found rust type `uint` in foreign module, while \\\n+                                 libc::c_uint or libc::c_ulong should be used\");\n                         }\n                         def::DefTy(def_id) => {\n                             if !adt::is_ffi_safe(cx.tcx, def_id) {\n-                                cx.span_lint(lint::CTypes, ty.span,\n-                                             \"found enum type without foreign-function-safe \\\n-                                              representation annotation in foreign module\");\n+                                cx.span_lint(ctypes, ty.span,\n+                                    \"found enum type without foreign-function-safe \\\n+                                     representation annotation in foreign module\");\n                                 // hmm... this message could be more helpful\n                             }\n                         }\n@@ -356,54 +367,64 @@ impl LintPass for CTypes {\n     }\n }\n \n+declare_lint!(managed_heap_memory, Allow,\n+    \"use of managed (@ type) heap memory\")\n+\n+declare_lint!(owned_heap_memory, Allow,\n+    \"use of owned (Box type) heap memory\")\n+\n+declare_lint!(heap_memory, Allow,\n+    \"use of any (Box type or @ type) heap memory\")\n+\n #[deriving(Default)]\n pub struct HeapMemory;\n \n impl HeapMemory {\n     fn check_heap_type(&self, cx: &Context, span: Span, ty: ty::t) {\n-        let xs = [lint::ManagedHeapMemory, lint::OwnedHeapMemory, lint::HeapMemory];\n-        for &lint in xs.iter() {\n-            if cx.get_level(lint) == lint::Allow { continue }\n-\n-            let mut n_box = 0;\n-            let mut n_uniq = 0;\n-            ty::fold_ty(cx.tcx, ty, |t| {\n-                match ty::get(t).sty {\n-                    ty::ty_box(_) => {\n-                        n_box += 1;\n-                    }\n-                    ty::ty_uniq(_) |\n-                    ty::ty_trait(box ty::TyTrait {\n-                        store: ty::UniqTraitStore, ..\n-                    }) |\n-                    ty::ty_closure(box ty::ClosureTy {\n-                        store: ty::UniqTraitStore,\n-                        ..\n-                    }) => {\n-                        n_uniq += 1;\n-                    }\n+        let mut n_box = 0;\n+        let mut n_uniq = 0;\n+        ty::fold_ty(cx.tcx, ty, |t| {\n+            match ty::get(t).sty {\n+                ty::ty_box(_) => {\n+                    n_box += 1;\n+                }\n+                ty::ty_uniq(_) |\n+                ty::ty_trait(box ty::TyTrait {\n+                    store: ty::UniqTraitStore, ..\n+                }) |\n+                ty::ty_closure(box ty::ClosureTy {\n+                    store: ty::UniqTraitStore,\n+                    ..\n+                }) => {\n+                    n_uniq += 1;\n+                }\n \n-                    _ => ()\n-                };\n-                t\n-            });\n+                _ => ()\n+            };\n+            t\n+        });\n \n-            if n_uniq > 0 && lint != lint::ManagedHeapMemory {\n-                let s = ty_to_str(cx.tcx, ty);\n-                let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-                cx.span_lint(lint, span, m.as_slice());\n-            }\n+        if n_uniq > 0 {\n+            let s = ty_to_str(cx.tcx, ty);\n+            let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n+            cx.span_lint(owned_heap_memory, span, m.as_slice());\n+            cx.span_lint(heap_memory, span, m.as_slice());\n+        }\n \n-            if n_box > 0 && lint != lint::OwnedHeapMemory {\n-                let s = ty_to_str(cx.tcx, ty);\n-                let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n-                cx.span_lint(lint, span, m.as_slice());\n-            }\n+        if n_box > 0 {\n+            let s = ty_to_str(cx.tcx, ty);\n+            let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n+            cx.span_lint(managed_heap_memory, span, m.as_slice());\n+            cx.span_lint(heap_memory, span, m.as_slice());\n         }\n     }\n }\n \n impl LintPass for HeapMemory {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(managed_heap_memory, owned_heap_memory, heap_memory)\n+    }\n+\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         match it.node {\n             ast::ItemFn(..) |\n@@ -434,6 +455,9 @@ impl LintPass for HeapMemory {\n     }\n }\n \n+declare_lint!(raw_pointer_deriving, Warn,\n+    \"uses of #[deriving] with raw pointers are rarely correct\")\n+\n struct RawPtrDerivingVisitor<'a> {\n     cx: &'a Context<'a>\n }\n@@ -442,7 +466,7 @@ impl<'a> visit::Visitor<()> for RawPtrDerivingVisitor<'a> {\n     fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n         static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n         match ty.node {\n-            ast::TyPtr(..) => self.cx.span_lint(lint::RawPointerDeriving, ty.span, MSG),\n+            ast::TyPtr(..) => self.cx.span_lint(raw_pointer_deriving, ty.span, MSG),\n             _ => {}\n         }\n         visit::walk_ty(self, ty, ());\n@@ -465,6 +489,10 @@ impl Default for RawPointerDeriving {\n }\n \n impl LintPass for RawPointerDeriving {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(raw_pointer_deriving)\n+    }\n+\n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n         if !attr::contains_name(item.attrs.as_slice(), \"automatically_derived\") {\n             return\n@@ -495,10 +523,17 @@ impl LintPass for RawPointerDeriving {\n     }\n }\n \n+declare_lint!(unused_attribute, Warn,\n+    \"detects attributes that were not used by the compiler\")\n+\n #[deriving(Default)]\n pub struct UnusedAttribute;\n \n impl LintPass for UnusedAttribute {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(unused_attribute)\n+    }\n+\n     fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n         static ATTRIBUTE_WHITELIST: &'static [&'static str] = &'static [\n             // FIXME: #14408 whitelist docs since rustdoc looks at them\n@@ -556,45 +591,59 @@ impl LintPass for UnusedAttribute {\n         }\n \n         if !attr::is_used(attr) {\n-            cx.span_lint(lint::UnusedAttribute, attr.span, \"unused attribute\");\n+            cx.span_lint(unused_attribute, attr.span, \"unused attribute\");\n             if CRATE_ATTRS.contains(&attr.name().get()) {\n                 let msg = match attr.node.style {\n                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n                                       attribute: add an exclamation mark: #![foo]\",\n                     ast::AttrInner => \"crate-level attribute should be in the \\\n                                        root module\",\n                 };\n-                cx.span_lint(lint::UnusedAttribute, attr.span, msg);\n+                cx.span_lint(unused_attribute, attr.span, msg);\n             }\n         }\n     }\n }\n \n+declare_lint!(path_statement, Warn,\n+    \"path statements with no effect\")\n+\n #[deriving(Default)]\n pub struct PathStatement;\n \n impl LintPass for PathStatement {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(path_statement)\n+    }\n+\n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         match s.node {\n             ast::StmtSemi(expr, _) => {\n                 match expr.node {\n-                    ast::ExprPath(_) => {\n-                        cx.span_lint(lint::PathStatement,\n-                                     s.span,\n-                                     \"path statement with no effect\");\n-                    }\n-                    _ => {}\n+                    ast::ExprPath(_) => cx.span_lint(path_statement, s.span,\n+                                                     \"path statement with no effect\"),\n+                    _ => ()\n                 }\n             }\n             _ => ()\n         }\n     }\n }\n \n+declare_lint!(unused_must_use, Warn,\n+    \"unused result of a type flagged as #[must_use]\")\n+\n+declare_lint!(unused_result, Allow,\n+    \"unused result of an expression in a statement\")\n+\n #[deriving(Default)]\n-pub struct UnusedMustUse;\n+pub struct UnusedResult;\n+\n+impl LintPass for UnusedResult {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(unused_must_use, unused_result)\n+    }\n \n-impl LintPass for UnusedMustUse {\n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         let expr = match s.node {\n             ast::StmtSemi(expr, _) => expr,\n@@ -620,7 +669,7 @@ impl LintPass for UnusedMustUse {\n                         ast_map::NodeItem(it) => {\n                             if attr::contains_name(it.attrs.as_slice(),\n                                                    \"must_use\") {\n-                                cx.span_lint(lint::UnusedMustUse, s.span,\n+                                cx.span_lint(unused_must_use, s.span,\n                                              \"unused result which must be used\");\n                                 warned = true;\n                             }\n@@ -630,7 +679,7 @@ impl LintPass for UnusedMustUse {\n                 } else {\n                     csearch::get_item_attrs(&cx.tcx.sess.cstore, did, |attrs| {\n                         if attr::contains_name(attrs.as_slice(), \"must_use\") {\n-                            cx.span_lint(lint::UnusedMustUse, s.span,\n+                            cx.span_lint(unused_must_use, s.span,\n                                          \"unused result which must be used\");\n                             warned = true;\n                         }\n@@ -640,21 +689,28 @@ impl LintPass for UnusedMustUse {\n             _ => {}\n         }\n         if !warned {\n-            cx.span_lint(lint::UnusedResult, s.span, \"unused result\");\n+            cx.span_lint(unused_result, s.span, \"unused result\");\n         }\n     }\n }\n \n+declare_lint!(deprecated_owned_vector, Allow,\n+    \"use of a `~[T]` vector\")\n+\n #[deriving(Default)]\n pub struct DeprecatedOwnedVector;\n \n impl LintPass for DeprecatedOwnedVector {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(deprecated_owned_vector)\n+    }\n+\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         let t = ty::expr_ty(cx.tcx, e);\n         match ty::get(t).sty {\n             ty::ty_uniq(t) => match ty::get(t).sty {\n                 ty::ty_vec(_, None) => {\n-                    cx.span_lint(lint::DeprecatedOwnedVector, e.span,\n+                    cx.span_lint(deprecated_owned_vector, e.span,\n                                  \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n                 }\n                 _ => {}\n@@ -664,10 +720,17 @@ impl LintPass for DeprecatedOwnedVector {\n     }\n }\n \n+declare_lint!(non_camel_case_types, Warn,\n+    \"types, variants and traits should have camel case names\")\n+\n #[deriving(Default)]\n pub struct NonCamelCaseTypes;\n \n impl LintPass for NonCamelCaseTypes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(non_camel_case_types)\n+    }\n+\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         fn is_camel_case(ident: ast::Ident) -> bool {\n             let ident = token::get_ident(ident);\n@@ -690,8 +753,7 @@ impl LintPass for NonCamelCaseTypes {\n             let s = token::get_ident(ident);\n \n             if !is_camel_case(ident) {\n-                cx.span_lint(lint::\n-                    NonCamelCaseTypes, span,\n+                cx.span_lint(non_camel_case_types, span,\n                     format!(\"{} `{}` should have a camel case name such as `{}`\",\n                         sort, s, to_camel_case(s.get())).as_slice());\n             }\n@@ -744,6 +806,9 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n     }\n }\n \n+declare_lint!(non_snake_case_functions, Warn,\n+    \"methods and functions should have snake case names\")\n+\n #[deriving(Default)]\n pub struct NonSnakeCaseFunctions;\n \n@@ -785,14 +850,18 @@ impl NonSnakeCaseFunctions {\n         let s = token::get_ident(ident);\n \n         if !is_snake_case(ident) {\n-            cx.span_lint(lint::NonSnakeCaseFunctions, span,\n+            cx.span_lint(non_snake_case_functions, span,\n                 format!(\"{} `{}` should have a snake case name such as `{}`\",\n                     sort, s, to_snake_case(s.get())).as_slice());\n         }\n     }\n }\n \n impl LintPass for NonSnakeCaseFunctions {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(non_snake_case_functions)\n+    }\n+\n     fn check_fn(&mut self, cx: &Context,\n                 fk: &visit::FnKind, _: &ast::FnDecl,\n                 _: &ast::Block, span: Span, _: ast::NodeId) {\n@@ -815,10 +884,17 @@ impl LintPass for NonSnakeCaseFunctions {\n     }\n }\n \n+declare_lint!(non_uppercase_statics, Allow,\n+    \"static constants should have uppercase identifiers\")\n+\n #[deriving(Default)]\n pub struct NonUppercaseStatics;\n \n impl LintPass for NonUppercaseStatics {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(non_uppercase_statics)\n+    }\n+\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         match it.node {\n             // only check static constants\n@@ -828,7 +904,7 @@ impl LintPass for NonUppercaseStatics {\n                 // ones (some scripts don't have a concept of\n                 // upper/lowercase)\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(lint::NonUppercaseStatics, it.span,\n+                    cx.span_lint(non_uppercase_statics, it.span,\n                         format!(\"static constant `{}` should have an uppercase name \\\n                             such as `{}`\", s.get(),\n                             s.get().chars().map(|c| c.to_uppercase())\n@@ -838,6 +914,18 @@ impl LintPass for NonUppercaseStatics {\n             _ => {}\n         }\n     }\n+}\n+\n+declare_lint!(non_uppercase_pattern_statics, Warn,\n+    \"static constants in match patterns should be all caps\")\n+\n+#[deriving(Default)]\n+pub struct NonUppercasePatternStatics;\n+\n+impl LintPass for NonUppercasePatternStatics {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(non_uppercase_pattern_statics)\n+    }\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n@@ -847,7 +935,7 @@ impl LintPass for NonUppercaseStatics {\n                 let ident = path.segments.last().unwrap().identifier;\n                 let s = token::get_ident(ident);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(lint::NonUppercasePatternStatics, path.span,\n+                    cx.span_lint(non_uppercase_pattern_statics, path.span,\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n                             name such as `{}`\", s.get(),\n                             s.get().chars().map(|c| c.to_uppercase())\n@@ -859,10 +947,17 @@ impl LintPass for NonUppercaseStatics {\n     }\n }\n \n+declare_lint!(uppercase_variables, Warn,\n+    \"variable and structure field names should start with a lowercase character\")\n+\n #[deriving(Default)]\n pub struct UppercaseVariables;\n \n impl LintPass for UppercaseVariables {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(uppercase_variables)\n+    }\n+\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         match &p.node {\n             &ast::PatIdent(_, ref path, _) => {\n@@ -873,9 +968,7 @@ impl LintPass for UppercaseVariables {\n                         let ident = path.segments.last().unwrap().identifier;\n                         let s = token::get_ident(ident);\n                         if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n-                            cx.span_lint(lint::\n-                                UppercaseVariables,\n-                                path.span,\n+                            cx.span_lint(uppercase_variables, path.span,\n                                 \"variable names should start with a lowercase character\");\n                         }\n                     }\n@@ -893,8 +986,7 @@ impl LintPass for UppercaseVariables {\n                 ast::StructField_ { kind: ast::NamedField(ident, _), .. } => {\n                     let s = token::get_ident(ident);\n                     if s.get().char_at(0).is_uppercase() {\n-                        cx.span_lint(lint::UppercaseVariables,\n-                            sf.span,\n+                        cx.span_lint(uppercase_variables, sf.span,\n                             \"structure field names should start with a lowercase character\");\n                     }\n                 }\n@@ -904,23 +996,29 @@ impl LintPass for UppercaseVariables {\n     }\n }\n \n+declare_lint!(unnecessary_parens, Warn,\n+    \"`if`, `match`, `while` and `return` do not need parentheses\")\n+\n #[deriving(Default)]\n pub struct UnnecessaryParens;\n \n impl UnnecessaryParens {\n     fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str) {\n         match value.node {\n             ast::ExprParen(_) => {\n-                cx.span_lint(lint::UnnecessaryParens, value.span,\n-                             format!(\"unnecessary parentheses around {}\",\n-                                     msg).as_slice())\n+                cx.span_lint(unnecessary_parens, value.span,\n+                    format!(\"unnecessary parentheses around {}\", msg).as_slice())\n             }\n             _ => {}\n         }\n     }\n }\n \n impl LintPass for UnnecessaryParens {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(unnecessary_parens)\n+    }\n+\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         let (value, msg) = match e.node {\n             ast::ExprIf(cond, _, _) => (cond, \"`if` condition\"),\n@@ -949,40 +1047,56 @@ impl LintPass for UnnecessaryParens {\n     }\n }\n \n+declare_lint!(unused_unsafe, Warn,\n+    \"unnecessary use of an `unsafe` block\")\n+\n #[deriving(Default)]\n pub struct UnusedUnsafe;\n \n impl LintPass for UnusedUnsafe {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(unused_unsafe)\n+    }\n+\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             ast::ExprBlock(ref blk) => {\n                 if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n                     !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n-                    cx.span_lint(lint::UnusedUnsafe, blk.span,\n-                                 \"unnecessary `unsafe` block\");\n+                    cx.span_lint(unused_unsafe, blk.span, \"unnecessary `unsafe` block\");\n                 }\n             }\n             _ => ()\n         }\n     }\n }\n \n+declare_lint!(unsafe_block, Allow,\n+    \"usage of an `unsafe` block\")\n+\n #[deriving(Default)]\n pub struct UnsafeBlock;\n \n impl LintPass for UnsafeBlock {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(unsafe_block)\n+    }\n+\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n-                cx.span_lint(lint::UnsafeBlock, blk.span, \"usage of an `unsafe` block\");\n+                cx.span_lint(unsafe_block, blk.span, \"usage of an `unsafe` block\");\n             }\n             _ => ()\n         }\n     }\n }\n \n+declare_lint!(unused_mut, Warn,\n+    \"detect mut variables which don't need to be mutable\")\n+\n #[deriving(Default)]\n pub struct UnusedMut;\n \n@@ -1016,14 +1130,18 @@ impl UnusedMut {\n         let used_mutables = cx.tcx.used_mut_nodes.borrow();\n         for (_, v) in mutables.iter() {\n             if !v.iter().any(|e| used_mutables.contains(e)) {\n-                cx.span_lint(lint::UnusedMut, cx.tcx.map.span(*v.get(0)),\n-                             \"variable does not need to be mutable\");\n+                cx.span_lint(unused_mut, cx.tcx.map.span(*v.get(0)),\n+                    \"variable does not need to be mutable\");\n             }\n         }\n     }\n }\n \n impl LintPass for UnusedMut {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(unused_mut)\n+    }\n+\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             ast::ExprMatch(_, ref arms) => {\n@@ -1063,10 +1181,17 @@ enum Allocation {\n     BoxAllocation\n }\n \n+declare_lint!(unnecessary_allocation, Warn,\n+    \"detects unnecessary allocations that can be eliminated\")\n+\n #[deriving(Default)]\n pub struct UnnecessaryAllocation;\n \n impl LintPass for UnnecessaryAllocation {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(unnecessary_allocation)\n+    }\n+\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         // Warn if string and vector literals with sigils, or boxing expressions,\n         // are immediately borrowed.\n@@ -1086,27 +1211,24 @@ impl LintPass for UnnecessaryAllocation {\n             _ => return\n         };\n \n-        let report = |msg| {\n-            cx.span_lint(lint::UnnecessaryAllocation, e.span, msg);\n-        };\n-\n         match cx.tcx.adjustments.borrow().find(&e.id) {\n             Some(adjustment) => {\n                 match *adjustment {\n                     ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n                         match (allocation, autoref) {\n                             (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n-                                report(\"unnecessary allocation, the sigil can be \\\n-                                        removed\");\n+                                cx.span_lint(unnecessary_allocation, e.span,\n+                                    \"unnecessary allocation, the sigil can be removed\");\n                             }\n                             (BoxAllocation,\n                              Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n-                                report(\"unnecessary allocation, use & instead\");\n+                                cx.span_lint(unnecessary_allocation, e.span,\n+                                    \"unnecessary allocation, use & instead\");\n                             }\n                             (BoxAllocation,\n                              Some(ty::AutoPtr(_, ast::MutMutable))) => {\n-                                report(\"unnecessary allocation, use &mut \\\n-                                        instead\");\n+                                cx.span_lint(unnecessary_allocation, e.span,\n+                                    \"unnecessary allocation, use &mut instead\");\n                             }\n                             _ => ()\n                         }\n@@ -1119,6 +1241,9 @@ impl LintPass for UnnecessaryAllocation {\n     }\n }\n \n+declare_lint!(missing_doc, Allow,\n+    \"detects missing documentation for public members\")\n+\n pub struct MissingDoc {\n     /// Set of nodes exported from this module.\n     exported_items: Option<ExportedItems>,\n@@ -1175,15 +1300,17 @@ impl MissingDoc {\n             }\n         });\n         if !has_doc {\n-            cx.span_lint(lint::MissingDoc,\n-                         sp,\n-                         format!(\"missing documentation for {}\",\n-                                 desc).as_slice());\n+            cx.span_lint(missing_doc, sp,\n+                format!(\"missing documentation for {}\", desc).as_slice());\n         }\n     }\n }\n \n impl LintPass for MissingDoc {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(missing_doc)\n+    }\n+\n     fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n@@ -1268,12 +1395,25 @@ impl LintPass for MissingDoc {\n     }\n }\n \n+declare_lint!(deprecated, Warn,\n+    \"detects use of #[deprecated] items\")\n+\n+declare_lint!(experimental, Warn,\n+    \"detects use of #[experimental] items\")\n+\n+declare_lint!(unstable, Allow,\n+    \"detects use of #[unstable] items (incl. items with no stability attribute)\")\n+\n /// Checks for use of items with #[deprecated], #[experimental] and\n /// #[unstable] (or none of them) attributes.\n #[deriving(Default)]\n pub struct Stability;\n \n impl LintPass for Stability {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(deprecated, experimental, unstable)\n+    }\n+\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         let id = match e.node {\n             ast::ExprPath(..) | ast::ExprStruct(..) => {\n@@ -1342,13 +1482,13 @@ impl LintPass for Stability {\n \n         let (lint, label) = match stability {\n             // no stability attributes == Unstable\n-            None => (lint::Unstable, \"unmarked\"),\n+            None => (unstable, \"unmarked\"),\n             Some(attr::Stability { level: attr::Unstable, .. }) =>\n-                    (lint::Unstable, \"unstable\"),\n+                    (unstable, \"unstable\"),\n             Some(attr::Stability { level: attr::Experimental, .. }) =>\n-                    (lint::Experimental, \"experimental\"),\n+                    (experimental, \"experimental\"),\n             Some(attr::Stability { level: attr::Deprecated, .. }) =>\n-                    (lint::Deprecated, \"deprecated\"),\n+                    (deprecated, \"deprecated\"),\n             _ => return\n         };\n \n@@ -1362,3 +1502,80 @@ impl LintPass for Stability {\n         cx.span_lint(lint, e.span, msg.as_slice());\n     }\n }\n+\n+/// Doesn't actually warn; just gathers information for use by\n+/// checks in trans.\n+#[deriving(Default)]\n+pub struct GatherNodeLevels;\n+\n+impl LintPass for GatherNodeLevels {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!()\n+    }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemEnum(..) => {\n+                let lint_id = lint::LintId::of(variant_size_difference);\n+                match cx.get_level_source(lint_id) {\n+                    lvlsrc @ (lvl, _) if lvl != lint::Allow => {\n+                        cx.insert_node_level(it.id, lint_id, lvlsrc);\n+                    },\n+                    _ => { }\n+                }\n+            },\n+            _ => { }\n+        }\n+    }\n+}\n+\n+declare_lint!(pub unused_imports, Warn,\n+    \"imports that are never used\")\n+\n+declare_lint!(pub unnecessary_qualification, Allow,\n+    \"detects unnecessarily qualified names\")\n+\n+declare_lint!(pub unrecognized_lint, Warn,\n+    \"unrecognized lint attribute\")\n+\n+declare_lint!(pub unused_variable, Warn,\n+    \"detect variables which are not used in any way\")\n+\n+declare_lint!(pub dead_assignment, Warn,\n+    \"detect assignments that will never be read\")\n+\n+declare_lint!(pub dead_code, Warn,\n+    \"detect piece of code that will never be used\")\n+\n+declare_lint!(pub visible_private_types, Warn,\n+    \"detect use of private types in exported type signatures\")\n+\n+declare_lint!(pub unreachable_code, Warn,\n+    \"detects unreachable code\")\n+\n+declare_lint!(pub warnings, Warn,\n+    \"mass-change the level for lints which produce warnings\")\n+\n+declare_lint!(pub unknown_features, Deny,\n+    \"unknown features found in crate-level #[feature] directives\")\n+\n+declare_lint!(pub unknown_crate_type, Deny,\n+    \"unknown crate type found in #[crate_type] directive\")\n+\n+declare_lint!(pub variant_size_difference, Allow,\n+    \"detects enums with widely varying variant sizes\")\n+\n+/// Does nothing as a lint pass, but registers some `Lint`s\n+/// which are used by other parts of the compiler.\n+#[deriving(Default)]\n+pub struct HardwiredLints;\n+\n+impl LintPass for HardwiredLints {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(\n+            unused_imports, unnecessary_qualification, unrecognized_lint,\n+            unused_variable, dead_assignment, dead_code, visible_private_types,\n+            unreachable_code, warnings, unknown_features, unknown_crate_type,\n+            variant_size_difference)\n+    }\n+}"}, {"sha": "1664dd6f309f8b7c532f9f50a40641892f66ebee", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 264, "deletions": 521, "changes": 785, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -41,37 +41,97 @@\n //! this file, use `span_lint` instead of `add_lint`.\n \n #![allow(non_camel_case_types)]\n+#![macro_escape]\n \n-use driver::session;\n-use middle::dead::DEAD_CODE_LINT_STR;\n use middle::privacy::ExportedItems;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::infer;\n+use driver::session::Session;\n \n use std::collections::HashMap;\n use std::rc::Rc;\n use std::gc::Gc;\n use std::to_str::ToStr;\n use std::cell::RefCell;\n use std::default::Default;\n-use std::collections::SmallIntMap;\n+use std::hash::Hash;\n+use std::tuple::Tuple2;\n+use std::hash;\n use syntax::ast_util::IdVisitingOperation;\n use syntax::attr::AttrMetaMethods;\n+use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::parse::token::InternedString;\n use syntax::visit::{Visitor, FnKind};\n use syntax::{ast, ast_util, visit};\n \n-mod builtin;\n+#[macro_export]\n+macro_rules! lint_initializer (\n+    ($name:ident, $level:ident, $desc:expr) => (\n+        ::rustc::lint::Lint {\n+            name: stringify!($name),\n+            default_level: ::rustc::lint::$level,\n+            desc: $desc,\n+        }\n+    )\n+)\n+\n+#[macro_export]\n+macro_rules! declare_lint (\n+    // FIXME(#14660): deduplicate\n+    (pub $name:ident, $level:ident, $desc:expr) => (\n+        pub static $name: &'static ::rustc::lint::Lint\n+            = &lint_initializer!($name, $level, $desc);\n+    );\n+    ($name:ident, $level:ident, $desc:expr) => (\n+        static $name: &'static ::rustc::lint::Lint\n+            = &lint_initializer!($name, $level, $desc);\n+    );\n+)\n+\n+#[macro_export]\n+macro_rules! lint_array ( ($( $lint:expr ),*) => (\n+    {\n+        static array: LintArray = &[ $( $lint ),* ];\n+        array\n+    }\n+))\n \n-/// Trait for types providing lint checks. Each method checks a single syntax\n-/// node, and should not invoke methods recursively (unlike `Visitor`).  Each\n-/// method has a default do-nothing implementation. The trait also contains a\n-/// few lint-specific methods with no equivalent in `Visitor`.\n+pub mod builtin;\n+\n+/// Specification of a single lint.\n+pub struct Lint {\n+    /// An identifier for the lint, written with underscores,\n+    /// e.g. \"unused_imports\". This identifies the lint in\n+    /// attributes and in command-line arguments. On the\n+    /// command line, underscores become dashes.\n+    pub name: &'static str,\n+\n+    /// Default level for the lint.\n+    pub default_level: Level,\n+\n+    /// Description of the lint or the issue it detects,\n+    /// e.g. \"imports that are never used\"\n+    pub desc: &'static str,\n+}\n+\n+type LintArray = &'static [&'static Lint];\n+\n+/// Trait for types providing lint checks. Each `check` method checks a single\n+/// syntax node, and should not invoke methods recursively (unlike `Visitor`).\n+/// By default they do nothing.\n //\n-// FIXME: eliminate the duplication with `Visitor`\n+// FIXME: eliminate the duplication with `Visitor`. But this also\n+// contains a few lint-specific methods with no equivalent in `Visitor`.\n trait LintPass {\n+    /// Get descriptions of the lints this `LintPass` object can emit.\n+    ///\n+    /// NB: there is no enforcement that the object only emits lints it registered.\n+    /// And some `rustc` internal `LintPass`es register lints to be emitted by other\n+    /// parts of the compiler. If you want enforced access restrictions for your\n+    /// `Lint`, make it a private `static` item in its own module.\n+    fn get_lints(&self) -> LintArray;\n+\n     fn check_crate(&mut self, _: &Context, _: &ExportedItems, _: &ast::Crate) { }\n     fn check_ident(&mut self, _: &Context, _: Span, _: ast::Ident) { }\n     fn check_mod(&mut self, _: &Context, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n@@ -116,63 +176,37 @@ trait LintPass {\n \n type LintPassObject = Box<LintPass + 'static>;\n \n-#[deriving(Clone, Show, PartialEq, PartialOrd, Eq, Ord, Hash)]\n-pub enum LintId {\n-    CTypes,\n-    UnusedImports,\n-    UnnecessaryQualification,\n-    WhileTrue,\n-    PathStatement,\n-    UnrecognizedLint,\n-    NonCamelCaseTypes,\n-    NonUppercaseStatics,\n-    NonUppercasePatternStatics,\n-    NonSnakeCaseFunctions,\n-    UppercaseVariables,\n-    UnnecessaryParens,\n-    TypeLimits,\n-    TypeOverflow,\n-    UnusedUnsafe,\n-    UnsafeBlock,\n-    UnusedAttribute,\n-    UnknownFeatures,\n-    UnknownCrateType,\n-    UnsignedNegate,\n-    VariantSizeDifference,\n-\n-    ManagedHeapMemory,\n-    OwnedHeapMemory,\n-    HeapMemory,\n-\n-    UnusedVariable,\n-    DeadAssignment,\n-    UnusedMut,\n-    UnnecessaryAllocation,\n-    DeadCode,\n-    VisiblePrivateTypes,\n-    UnnecessaryTypecast,\n-\n-    MissingDoc,\n-    UnreachableCode,\n-\n-    Deprecated,\n-    Experimental,\n-    Unstable,\n-\n-    UnusedMustUse,\n-    UnusedResult,\n-\n-    Warnings,\n-\n-    RawPointerDeriving,\n+/// Identifies a lint known to the compiler.\n+#[deriving(Clone)]\n+pub struct LintId {\n+    // Identity is based on pointer equality of this field.\n+    lint: &'static Lint,\n+}\n+\n+impl PartialEq for LintId {\n+    fn eq(&self, other: &LintId) -> bool {\n+        (self.lint as *Lint) == (other.lint as *Lint)\n+    }\n+}\n+\n+impl Eq for LintId { }\n+\n+impl<S: hash::Writer> Hash<S> for LintId {\n+    fn hash(&self, state: &mut S) {\n+        let ptr = self.lint as *Lint;\n+        ptr.hash(state);\n+    }\n }\n \n-pub fn level_to_str(lv: Level) -> &'static str {\n-    match lv {\n-      Allow => \"allow\",\n-      Warn => \"warn\",\n-      Deny => \"deny\",\n-      Forbid => \"forbid\"\n+impl LintId {\n+    pub fn of(lint: &'static Lint) -> LintId {\n+        LintId {\n+            lint: lint,\n+        }\n+    }\n+\n+    pub fn as_str(&self) -> &'static str {\n+        self.lint.name\n     }\n }\n \n@@ -181,14 +215,26 @@ pub enum Level {\n     Allow, Warn, Deny, Forbid\n }\n \n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n-pub struct LintSpec {\n-    pub default: Level,\n-    pub lint: LintId,\n-    pub desc: &'static str,\n-}\n+impl Level {\n+    pub fn as_str(self) -> &'static str {\n+        match self {\n+            Allow => \"allow\",\n+            Warn => \"warn\",\n+            Deny => \"deny\",\n+            Forbid => \"forbid\",\n+        }\n+    }\n \n-pub type LintDict = HashMap<&'static str, LintSpec>;\n+    pub fn from_str(x: &str) -> Option<Level> {\n+        match x {\n+            \"allow\" => Some(Allow),\n+            \"warn\" => Some(Warn),\n+            \"deny\" => Some(Deny),\n+            \"forbid\" => Some(Forbid),\n+            _ => None,\n+        }\n+    }\n+}\n \n // this is public for the lints that run in trans\n #[deriving(PartialEq)]\n@@ -198,331 +244,49 @@ pub enum LintSource {\n     CommandLine\n }\n \n-static lint_table: &'static [(&'static str, LintSpec)] = &[\n-    (\"ctypes\",\n-     LintSpec {\n-        lint: CTypes,\n-        desc: \"proper use of libc types in foreign modules\",\n-        default: Warn\n-     }),\n-\n-    (\"unused_imports\",\n-     LintSpec {\n-        lint: UnusedImports,\n-        desc: \"imports that are never used\",\n-        default: Warn\n-     }),\n-\n-    (\"unnecessary_qualification\",\n-     LintSpec {\n-        lint: UnnecessaryQualification,\n-        desc: \"detects unnecessarily qualified names\",\n-        default: Allow\n-     }),\n-\n-    (\"while_true\",\n-     LintSpec {\n-        lint: WhileTrue,\n-        desc: \"suggest using `loop { }` instead of `while true { }`\",\n-        default: Warn\n-     }),\n-\n-    (\"path_statement\",\n-     LintSpec {\n-        lint: PathStatement,\n-        desc: \"path statements with no effect\",\n-        default: Warn\n-     }),\n-\n-    (\"unrecognized_lint\",\n-     LintSpec {\n-        lint: UnrecognizedLint,\n-        desc: \"unrecognized lint attribute\",\n-        default: Warn\n-     }),\n-\n-    (\"non_camel_case_types\",\n-     LintSpec {\n-        lint: NonCamelCaseTypes,\n-        desc: \"types, variants and traits should have camel case names\",\n-        default: Warn\n-     }),\n-\n-    (\"non_uppercase_statics\",\n-     LintSpec {\n-         lint: NonUppercaseStatics,\n-         desc: \"static constants should have uppercase identifiers\",\n-         default: Allow\n-     }),\n-\n-    (\"non_uppercase_pattern_statics\",\n-     LintSpec {\n-         lint: NonUppercasePatternStatics,\n-         desc: \"static constants in match patterns should be all caps\",\n-         default: Warn\n-     }),\n-\n-    (\"non_snake_case_functions\",\n-     LintSpec {\n-         lint: NonSnakeCaseFunctions,\n-         desc: \"methods and functions should have snake case names\",\n-         default: Warn\n-     }),\n-\n-    (\"uppercase_variables\",\n-     LintSpec {\n-         lint: UppercaseVariables,\n-         desc: \"variable and structure field names should start with a lowercase character\",\n-         default: Warn\n-     }),\n-\n-     (\"unnecessary_parens\",\n-     LintSpec {\n-        lint: UnnecessaryParens,\n-        desc: \"`if`, `match`, `while` and `return` do not need parentheses\",\n-        default: Warn\n-     }),\n-\n-    (\"managed_heap_memory\",\n-     LintSpec {\n-        lint: ManagedHeapMemory,\n-        desc: \"use of managed (@ type) heap memory\",\n-        default: Allow\n-     }),\n-\n-    (\"owned_heap_memory\",\n-     LintSpec {\n-        lint: OwnedHeapMemory,\n-        desc: \"use of owned (Box type) heap memory\",\n-        default: Allow\n-     }),\n-\n-    (\"heap_memory\",\n-     LintSpec {\n-        lint: HeapMemory,\n-        desc: \"use of any (Box type or @ type) heap memory\",\n-        default: Allow\n-     }),\n-\n-    (\"type_limits\",\n-     LintSpec {\n-        lint: TypeLimits,\n-        desc: \"comparisons made useless by limits of the types involved\",\n-        default: Warn\n-     }),\n-\n-    (\"type_overflow\",\n-     LintSpec {\n-        lint: TypeOverflow,\n-        desc: \"literal out of range for its type\",\n-        default: Warn\n-     }),\n-\n-\n-    (\"unused_unsafe\",\n-     LintSpec {\n-        lint: UnusedUnsafe,\n-        desc: \"unnecessary use of an `unsafe` block\",\n-        default: Warn\n-    }),\n-\n-    (\"unsafe_block\",\n-     LintSpec {\n-        lint: UnsafeBlock,\n-        desc: \"usage of an `unsafe` block\",\n-        default: Allow\n-    }),\n-\n-    (\"unused_attribute\",\n-     LintSpec {\n-         lint: UnusedAttribute,\n-         desc: \"detects attributes that were not used by the compiler\",\n-         default: Warn\n-    }),\n-\n-    (\"unused_variable\",\n-     LintSpec {\n-        lint: UnusedVariable,\n-        desc: \"detect variables which are not used in any way\",\n-        default: Warn\n-    }),\n-\n-    (\"dead_assignment\",\n-     LintSpec {\n-        lint: DeadAssignment,\n-        desc: \"detect assignments that will never be read\",\n-        default: Warn\n-    }),\n-\n-    (\"unnecessary_typecast\",\n-     LintSpec {\n-        lint: UnnecessaryTypecast,\n-        desc: \"detects unnecessary type casts, that can be removed\",\n-        default: Allow,\n-    }),\n-\n-    (\"unused_mut\",\n-     LintSpec {\n-        lint: UnusedMut,\n-        desc: \"detect mut variables which don't need to be mutable\",\n-        default: Warn\n-    }),\n-\n-    (\"unnecessary_allocation\",\n-     LintSpec {\n-        lint: UnnecessaryAllocation,\n-        desc: \"detects unnecessary allocations that can be eliminated\",\n-        default: Warn\n-    }),\n-\n-    (DEAD_CODE_LINT_STR,\n-     LintSpec {\n-        lint: DeadCode,\n-        desc: \"detect piece of code that will never be used\",\n-        default: Warn\n-    }),\n-    (\"visible_private_types\",\n-     LintSpec {\n-        lint: VisiblePrivateTypes,\n-        desc: \"detect use of private types in exported type signatures\",\n-        default: Warn\n-    }),\n-\n-    (\"missing_doc\",\n-     LintSpec {\n-        lint: MissingDoc,\n-        desc: \"detects missing documentation for public members\",\n-        default: Allow\n-    }),\n-\n-    (\"unreachable_code\",\n-     LintSpec {\n-        lint: UnreachableCode,\n-        desc: \"detects unreachable code\",\n-        default: Warn\n-    }),\n-\n-    (\"deprecated\",\n-     LintSpec {\n-        lint: Deprecated,\n-        desc: \"detects use of #[deprecated] items\",\n-        default: Warn\n-    }),\n-\n-    (\"experimental\",\n-     LintSpec {\n-        lint: Experimental,\n-        desc: \"detects use of #[experimental] items\",\n-        // FIXME #6875: Change to Warn after std library stabilization is complete\n-        default: Allow\n-    }),\n-\n-    (\"unstable\",\n-     LintSpec {\n-        lint: Unstable,\n-        desc: \"detects use of #[unstable] items (incl. items with no stability attribute)\",\n-        default: Allow\n-    }),\n-\n-    (\"warnings\",\n-     LintSpec {\n-        lint: Warnings,\n-        desc: \"mass-change the level for lints which produce warnings\",\n-        default: Warn\n-    }),\n-\n-    (\"unknown_features\",\n-     LintSpec {\n-        lint: UnknownFeatures,\n-        desc: \"unknown features found in crate-level #[feature] directives\",\n-        default: Deny,\n-    }),\n-\n-    (\"unknown_crate_type\",\n-    LintSpec {\n-        lint: UnknownCrateType,\n-        desc: \"unknown crate type found in #[crate_type] directive\",\n-        default: Deny,\n-    }),\n-\n-    (\"unsigned_negate\",\n-    LintSpec {\n-        lint: UnsignedNegate,\n-        desc: \"using an unary minus operator on unsigned type\",\n-        default: Warn\n-    }),\n-\n-    (\"variant_size_difference\",\n-    LintSpec {\n-        lint: VariantSizeDifference,\n-        desc: \"detects enums with widely varying variant sizes\",\n-        default: Allow,\n-    }),\n-\n-    (\"unused_must_use\",\n-    LintSpec {\n-        lint: UnusedMustUse,\n-        desc: \"unused result of a type flagged as #[must_use]\",\n-        default: Warn,\n-    }),\n-\n-    (\"unused_result\",\n-    LintSpec {\n-        lint: UnusedResult,\n-        desc: \"unused result of an expression in a statement\",\n-        default: Allow,\n-    }),\n-\n-    (\"raw_pointer_deriving\",\n-     LintSpec {\n-        lint: RawPointerDeriving,\n-        desc: \"uses of #[deriving] with raw pointers are rarely correct\",\n-        default: Warn,\n-    }),\n-];\n-\n-/*\n-  Pass names should not contain a '-', as the compiler normalizes\n-  '-' to '_' in command-line flags\n- */\n-pub fn get_lint_dict() -> LintDict {\n-    lint_table.iter().map(|&(k, v)| (k, v)).collect()\n-}\n+pub type LevelSource = (Level, LintSource);\n \n struct Context<'a> {\n-    /// All known lint modes (string versions)\n-    dict: LintDict,\n-    /// Current levels of each lint warning\n-    cur: SmallIntMap<(Level, LintSource)>,\n-    /// Context we're checking in (used to access fields like sess)\n+    /// Trait objects for each lint pass.\n+    lint_objects: Vec<RefCell<LintPassObject>>,\n+\n+    /// Lints indexed by name.\n+    lints_by_name: HashMap<&'static str, LintId>,\n+\n+    /// Current levels of each lint, and where they were set.\n+    levels: HashMap<LintId, LevelSource>,\n+\n+    /// Context we're checking in (used to access fields like sess).\n     tcx: &'a ty::ctxt,\n \n     /// When recursing into an attributed node of the ast which modifies lint\n     /// levels, this stack keeps track of the previous lint levels of whatever\n     /// was modified.\n-    level_stack: Vec<(LintId, Level, LintSource)>,\n+    level_stack: Vec<(LintId, LevelSource)>,\n \n     /// Level of lints for certain NodeIds, stored here because the body of\n     /// the lint needs to run in trans.\n-    node_levels: RefCell<HashMap<(ast::NodeId, LintId), (Level, LintSource)>>,\n-\n-    /// Trait objects for each lint.\n-    lints: Vec<RefCell<LintPassObject>>,\n+    node_levels: RefCell<HashMap<(ast::NodeId, LintId), LevelSource>>,\n }\n \n-/// Convenience macro for calling a `LintPass` method on every lint in the context.\n+/// Convenience macro for calling a `LintPass` method on every pass in the context.\n macro_rules! run_lints ( ($cx:expr, $f:ident, $($args:expr),*) => (\n-    for tl in $cx.lints.iter() {\n-        tl.borrow_mut().$f($cx, $($args),*);\n+    for obj in $cx.lint_objects.iter() {\n+        obj.borrow_mut().$f($cx, $($args),*);\n     }\n ))\n \n-pub fn emit_lint(level: Level, src: LintSource, msg: &str, span: Span,\n-                 lint_str: &str, tcx: &ty::ctxt) {\n+/// Emit a lint as a `span_warn` or `span_err` (or not at all)\n+/// according to `level`.  This lives outside of `Context` so\n+/// it can be used by checks in trans that run after the main\n+/// lint phase is finished.\n+pub fn emit_lint(sess: &Session, lint: &'static Lint,\n+                 lvlsrc: LevelSource, span: Span, msg: &str) {\n+    let (level, source) = lvlsrc;\n     if level == Allow { return }\n \n     let mut note = None;\n-    let msg = match src {\n+    let msg = match source {\n         Default => {\n             format!(\"{}, #[{}({})] on by default\", msg,\n                 level_to_str(level), lint_str)\n@@ -532,75 +296,50 @@ pub fn emit_lint(level: Level, src: LintSource, msg: &str, span: Span,\n                 match level {\n                     Warn => 'W', Deny => 'D', Forbid => 'F',\n                     Allow => fail!()\n-                }, lint_str.replace(\"_\", \"-\"))\n+                }, lint.name.replace(\"_\", \"-\"))\n         },\n         Node(src) => {\n             note = Some(src);\n-            msg.to_str()\n+            msg.to_string()\n         }\n     };\n \n     match level {\n-        Warn =>          { tcx.sess.span_warn(span, msg.as_slice()); }\n-        Deny | Forbid => { tcx.sess.span_err(span, msg.as_slice());  }\n+        Warn =>          { sess.span_warn(span, msg.as_slice()); }\n+        Deny | Forbid => { sess.span_err(span, msg.as_slice());  }\n         Allow => fail!(),\n     }\n \n-    for &span in note.iter() {\n-        tcx.sess.span_note(span, \"lint level defined here\");\n+    for span in note.move_iter() {\n+        sess.span_note(span, \"lint level defined here\");\n     }\n }\n \n-pub fn lint_to_str(lint: LintId) -> &'static str {\n-    for &(name, lspec) in lint_table.iter() {\n-        if lspec.lint == lint {\n-            return name;\n-        }\n-    }\n-\n-    fail!(\"unrecognized lint: {}\", lint);\n-}\n-\n impl<'a> Context<'a> {\n-    fn get_level(&self, lint: LintId) -> Level {\n-        match self.cur.find(&(lint as uint)) {\n-          Some(&(lvl, _)) => lvl,\n-          None => Allow\n+    fn get_level_source(&self, lint: LintId) -> LevelSource {\n+        match self.levels.find(&lint) {\n+            Some(&s) => s,\n+            None => (Allow, Default),\n         }\n     }\n \n-    fn get_source(&self, lint: LintId) -> LintSource {\n-        match self.cur.find(&(lint as uint)) {\n-          Some(&(_, src)) => src,\n-          None => Default\n-        }\n-    }\n-\n-    fn set_level(&mut self, lint: LintId, level: Level, src: LintSource) {\n-        if level == Allow {\n-            self.cur.remove(&(lint as uint));\n+    fn set_level(&mut self, lint: LintId, lvlsrc: LevelSource) {\n+        if lvlsrc.val0() == Allow {\n+            self.levels.remove(&lint);\n         } else {\n-            self.cur.insert(lint as uint, (level, src));\n+            self.levels.insert(lint, lvlsrc);\n         }\n     }\n \n-    fn lint_to_str(&self, lint: LintId) -> &'static str {\n-        for (k, v) in self.dict.iter() {\n-            if v.lint == lint {\n-                return *k;\n-            }\n-        }\n-        fail!(\"unregistered lint {}\", lint);\n-    }\n-\n-    fn span_lint(&self, lint: LintId, span: Span, msg: &str) {\n-        let (level, src) = match self.cur.find(&(lint as uint)) {\n-            None => { return }\n-            Some(&(Warn, src)) => (self.get_level(Warnings), src),\n+    fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n+        let (level, src) = match self.levels.find(&LintId::of(lint)) {\n+            None => return,\n+            Some(&(Warn, src))\n+                => (self.get_level_source(LintId::of(builtin::warnings)).val0(), src),\n             Some(&pair) => pair,\n         };\n \n-        emit_lint(level, src, msg, span, self.lint_to_str(lint), self.tcx);\n+        emit_lint(&self.tcx.sess, lint, (level, src), span, msg);\n     }\n \n     /**\n@@ -615,44 +354,31 @@ impl<'a> Context<'a> {\n         // current dictionary of lint information. Along the way, keep a history\n         // of what we changed so we can roll everything back after invoking the\n         // specified closure\n+        let lint_attrs = self.gather_lint_attrs(attrs);\n         let mut pushed = 0u;\n-        each_lint(&self.tcx.sess, attrs, |meta, level, lintname| {\n-            match self.dict.find_equiv(&lintname) {\n-                None => {\n-                    self.span_lint(\n-                        UnrecognizedLint,\n-                        meta.span,\n-                        format!(\"unknown `{}` attribute: `{}`\",\n-                                level_to_str(level), lintname).as_slice());\n-                }\n-                Some(lint) => {\n-                    let lint = lint.lint;\n-                    let now = self.get_level(lint);\n-                    if now == Forbid && level != Forbid {\n-                        self.tcx.sess.span_err(meta.span,\n-                        format!(\"{}({}) overruled by outer forbid({})\",\n-                                level_to_str(level),\n-                                lintname,\n-                                lintname).as_slice());\n-                    } else if now != level {\n-                        let src = self.get_source(lint);\n-                        self.level_stack.push((lint, now, src));\n-                        pushed += 1;\n-                        self.set_level(lint, level, Node(meta.span));\n-                    }\n-                }\n+        for (lint_id, level, span) in lint_attrs.move_iter() {\n+            let now = self.get_level_source(lint_id).val0();\n+            if now == Forbid && level != Forbid {\n+                let lint_name = lint_id.as_str();\n+                self.tcx.sess.span_err(span,\n+                format!(\"{}({}) overruled by outer forbid({})\",\n+                        level.as_str(), lint_name, lint_name).as_slice());\n+            } else if now != level {\n+                let src = self.get_level_source(lint_id).val1();\n+                self.level_stack.push((lint_id, (now, src)));\n+                pushed += 1;\n+                self.set_level(lint_id, (level, Node(span)));\n             }\n-            true\n-        });\n+        }\n \n         run_lints!(self, enter_lint_attrs, attrs);\n         f(self);\n         run_lints!(self, exit_lint_attrs, attrs);\n \n         // rollback\n         for _ in range(0, pushed) {\n-            let (lint, lvl, src) = self.level_stack.pop().unwrap();\n-            self.set_level(lint, lvl, src);\n+            let (lint, lvlsrc) = self.level_stack.pop().unwrap();\n+            self.set_level(lint, lvlsrc);\n         }\n     }\n \n@@ -665,65 +391,49 @@ impl<'a> Context<'a> {\n         f(&mut v);\n     }\n \n-    fn insert_node_level(&self, id: ast::NodeId, lint: LintId, lvl: Level, src: LintSource) {\n-        self.node_levels.borrow_mut().insert((id, lint), (lvl, src));\n+    fn insert_node_level(&self, id: ast::NodeId, lint: LintId, lvlsrc: LevelSource) {\n+        self.node_levels.borrow_mut().insert((id, lint), lvlsrc);\n     }\n-}\n \n-/// Check that every lint from the list of attributes satisfies `f`.\n-/// Return true if that's the case. Otherwise return false.\n-pub fn each_lint(sess: &session::Session,\n-                 attrs: &[ast::Attribute],\n-                 f: |Gc<ast::MetaItem>, Level, InternedString| -> bool)\n-                 -> bool {\n-    let xs = [Allow, Warn, Deny, Forbid];\n-    for &level in xs.iter() {\n-        let level_name = level_to_str(level);\n-        for attr in attrs.iter().filter(|m| m.check_name(level_name)) {\n+    fn gather_lint_attrs(&mut self, attrs: &[ast::Attribute]) -> Vec<(LintId, Level, Span)> {\n+        // Doing this as an iterator is messy due to multiple borrowing.\n+        // Allocating and copying these should be quick.\n+        let mut out = vec!();\n+        for attr in attrs.iter() {\n+            let level = match Level::from_str(attr.name().get()) {\n+                None => continue,\n+                Some(lvl) => lvl,\n+            };\n+\n+            attr::mark_used(attr);\n+\n             let meta = attr.node.value;\n             let metas = match meta.node {\n                 ast::MetaList(_, ref metas) => metas,\n                 _ => {\n-                    sess.span_err(meta.span, \"malformed lint attribute\");\n+                    self.tcx.sess.span_err(meta.span, \"malformed lint attribute\");\n                     continue;\n                 }\n             };\n+\n             for meta in metas.iter() {\n                 match meta.node {\n-                    ast::MetaWord(ref lintname) => {\n-                        if !f(*meta, level, (*lintname).clone()) {\n-                            return false;\n+                    ast::MetaWord(ref lint_name) => {\n+                        match self.lints_by_name.find_equiv(lint_name) {\n+                            Some(lint_id) => out.push((*lint_id, level, meta.span)),\n+\n+                            None => self.span_lint(builtin::unrecognized_lint,\n+                                meta.span,\n+                                format!(\"unknown `{}` attribute: `{}`\",\n+                                    level.as_str(), lint_name).as_slice()),\n                         }\n                     }\n-                    _ => {\n-                        sess.span_err(meta.span, \"malformed lint attribute\");\n-                    }\n+                    _ => self.tcx.sess.span_err(meta.span, \"malformed lint attribute\"),\n                 }\n             }\n         }\n+        out\n     }\n-    true\n-}\n-\n-/// Check from a list of attributes if it contains the appropriate\n-/// `#[level(lintname)]` attribute (e.g. `#[allow(dead_code)]).\n-pub fn contains_lint(attrs: &[ast::Attribute],\n-                     level: Level,\n-                     lintname: &'static str)\n-                     -> bool {\n-    let level_name = level_to_str(level);\n-    for attr in attrs.iter().filter(|m| m.name().equiv(&level_name)) {\n-        if attr.meta_item_list().is_none() {\n-            continue\n-        }\n-        let list = attr.meta_item_list().unwrap();\n-        for meta_item in list.iter() {\n-            if meta_item.name().equiv(&lintname) {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n }\n \n impl<'a> AstConv for Context<'a>{\n@@ -912,59 +622,90 @@ impl<'a> Visitor<()> for Context<'a> {\n     }\n }\n \n+// Output any lints that were previously added to the session.\n impl<'a> IdVisitingOperation for Context<'a> {\n     fn visit_id(&self, id: ast::NodeId) {\n         match self.tcx.sess.lints.borrow_mut().pop(&id) {\n             None => {}\n-            Some(l) => {\n-                for (lint, span, msg) in l.move_iter() {\n-                    self.span_lint(lint, span, msg.as_slice())\n+            Some(lints) => {\n+                for (lint_id, span, msg) in lints.move_iter() {\n+                    self.span_lint(lint_id.lint, span, msg.as_slice())\n                 }\n             }\n         }\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   exported_items: &ExportedItems,\n-                   krate: &ast::Crate) {\n+fn builtin_lints() -> Vec<Box<LintPass>> {\n     macro_rules! builtin_lints (( $($name:ident),*, ) => (\n         vec!($(\n             {\n                 let obj: builtin::$name = Default::default();\n-                RefCell::new(box obj as LintPassObject)\n+                box obj as LintPassObject\n             }\n         ),*)\n     ))\n \n-    let builtin_lints = builtin_lints!(\n-        GatherNodeLevels, WhileTrue, UnusedCasts, TypeLimits, CTypes,\n-        HeapMemory, RawPointerDeriving, UnusedAttribute,\n-        PathStatement, UnusedMustUse, DeprecatedOwnedVector,\n-        NonCamelCaseTypes, NonSnakeCaseFunctions, NonUppercaseStatics,\n-        UppercaseVariables, UnnecessaryParens, UnusedUnsafe, UnsafeBlock,\n-        UnusedMut, UnnecessaryAllocation, MissingDoc, Stability,\n-    );\n+    builtin_lints!(\n+        WhileTrue, UnusedCasts, TypeLimits, CTypes, HeapMemory,\n+        RawPointerDeriving, UnusedAttribute, PathStatement,\n+        UnusedResult, DeprecatedOwnedVector, NonCamelCaseTypes,\n+        NonSnakeCaseFunctions, NonUppercaseStatics,\n+        NonUppercasePatternStatics, UppercaseVariables,\n+        UnnecessaryParens, UnusedUnsafe, UnsafeBlock, UnusedMut,\n+        UnnecessaryAllocation, MissingDoc, Stability,\n+\n+        GatherNodeLevels, HardwiredLints,\n+    )\n+}\n+\n+/// Get specs for all builtin lints.  Used for `-W help`.\n+pub fn builtin_lint_specs() -> Vec<&'static Lint> {\n+    builtin_lints().move_iter()\n+        .flat_map(|x| x.get_lints().iter().map(|&y| y))\n+        .collect()\n+}\n+\n+pub fn check_crate(tcx: &ty::ctxt,\n+                   exported_items: &ExportedItems,\n+                   krate: &ast::Crate) {\n+    let lints = builtin_lints().move_iter().map(|x| RefCell::new(x)).collect();\n \n     let mut cx = Context {\n-        dict: get_lint_dict(),\n-        cur: SmallIntMap::new(),\n+        lint_objects: lints,\n+        lints_by_name: HashMap::new(),\n+        levels: HashMap::new(),\n         tcx: tcx,\n         level_stack: Vec::new(),\n         node_levels: RefCell::new(HashMap::new()),\n-        lints: builtin_lints,\n     };\n \n-    // Install default lint levels, followed by the command line levels, and\n-    // then actually visit the whole crate.\n-    for (_, spec) in cx.dict.iter() {\n-        if spec.default != Allow {\n-            cx.cur.insert(spec.lint as uint, (spec.default, Default));\n+    // Index the lints by name, and set the default levels.\n+    for obj in cx.lint_objects.iter() {\n+        for &lint in obj.borrow_mut().get_lints().iter() {\n+            let id = LintId::of(lint);\n+            if !cx.lints_by_name.insert(lint.name, id) {\n+                cx.tcx.sess.err(format!(\"duplicate specification of lint {}\",\n+                    lint.name).as_slice());\n+            }\n+            if lint.default_level != Allow {\n+                cx.levels.insert(id, (lint.default_level, Default));\n+            }\n         }\n     }\n-    for &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n-        cx.set_level(lint, level, CommandLine);\n+\n+    // Set command line lint levels.\n+    for &(ref lint_name, level) in tcx.sess.opts.lint_opts.iter() {\n+        match cx.lints_by_name.find_equiv(&lint_name.as_slice()) {\n+            Some(&lint_id) => cx.set_level(lint_id, (level, CommandLine)),\n+            None => cx.tcx.sess.err(format!(\"unknown {} flag: {}\",\n+                level.as_str(), lint_name).as_slice()),\n+        }\n     }\n+\n+    tcx.sess.abort_if_errors();\n+\n+    // Visit the whole crate.\n     cx.with_lint_attrs(krate.attrs.as_slice(), |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n@@ -983,8 +724,10 @@ pub fn check_crate(tcx: &ty::ctxt,\n     // in the iteration code.\n     for (id, v) in tcx.sess.lints.borrow().iter() {\n         for &(lint, span, ref msg) in v.iter() {\n-            tcx.sess.span_bug(span, format!(\"unprocessed lint {} at {}: {}\",\n-                                            lint, tcx.map.node_to_str(*id), *msg).as_slice())\n+            tcx.sess.span_bug(span,\n+                format!(\"unprocessed lint {} at {}: {}\",\n+                    lint.as_str(), tcx.map.node_to_str(*id), *msg)\n+                .as_slice())\n         }\n     }\n "}, {"sha": "98c045dd8a463e7847329a8a3f8c6b1956378bcb", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -13,7 +13,7 @@\n // from live codes are live, and everything else is dead.\n \n use middle::def;\n-use lint::{Allow, contains_lint, DeadCode};\n+use lint;\n use middle::privacy;\n use middle::ty;\n use middle::typeck;\n@@ -23,14 +23,13 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, is_local};\n+use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-pub static DEAD_CODE_LINT_STR: &'static str = \"dead_code\";\n-\n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n@@ -266,8 +265,24 @@ impl<'a> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a> {\n }\n \n fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n-    contains_lint(attrs, Allow, DEAD_CODE_LINT_STR)\n-    || attr::contains_name(attrs.as_slice(), \"lang\")\n+    if attr::contains_name(attrs.as_slice(), \"lang\") {\n+        return true;\n+    }\n+\n+    // FIXME: use the lint attr parsing already in rustc::lint\n+    for attr in attrs.iter().filter(|a| a.check_name(\"allow\")) {\n+        match attr.node.value.node {\n+            ast::MetaList(_, ref metas) => for meta in metas.iter() {\n+                match meta.node {\n+                    ast::MetaWord(ref name) if name.get() == \"dead_code\"\n+                        => return true,\n+                    _ => (),\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+    false\n }\n \n // This visitor seeds items that\n@@ -446,7 +461,7 @@ impl<'a> DeadVisitor<'a> {\n                       ident: ast::Ident) {\n         self.tcx\n             .sess\n-            .add_lint(DeadCode,\n+            .add_lint(lint::builtin::dead_code,\n                       id,\n                       span,\n                       format!(\"code is never used: `{}`\","}, {"sha": "5841a13280bf36450bc561c896d0820c61265690", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -107,7 +107,7 @@ use middle::freevars;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;\n-use lint::{UnusedVariable, DeadAssignment};\n+use lint;\n use util::nodemap::NodeMap;\n \n use std::fmt;\n@@ -1560,11 +1560,11 @@ impl<'a> Liveness<'a> {\n                 };\n \n                 if is_assigned {\n-                    self.ir.tcx.sess.add_lint(UnusedVariable, id, sp,\n+                    self.ir.tcx.sess.add_lint(lint::builtin::unused_variable, id, sp,\n                         format!(\"variable `{}` is assigned to, but never used\",\n                                 *name));\n                 } else {\n-                    self.ir.tcx.sess.add_lint(UnusedVariable, id, sp,\n+                    self.ir.tcx.sess.add_lint(lint::builtin::unused_variable, id, sp,\n                         format!(\"unused variable: `{}`\", *name));\n                 }\n             }\n@@ -1582,7 +1582,7 @@ impl<'a> Liveness<'a> {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n-                self.ir.tcx.sess.add_lint(DeadAssignment, id, sp,\n+                self.ir.tcx.sess.add_lint(lint::builtin::dead_assignment, id, sp,\n                     format!(\"value assigned to `{}` is never read\", *name));\n             }\n         }"}, {"sha": "86a2483885037dbc2bfa3724c9eb119ef91b52eb", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -1394,7 +1394,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n             ast::TyPath(ref p, _, path_id) => {\n                 if self.path_is_private_type(path_id) {\n                     self.tcx.sess.add_lint(\n-                        lint::VisiblePrivateTypes,\n+                        lint::builtin::visible_private_types,\n                         path_id, p.span,\n                         \"private type in exported type \\\n                          signature\".to_string());"}, {"sha": "f0abcc272826e70ad7f27f23210fa11fd1a6bbba", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -15,9 +15,9 @@ use metadata::csearch;\n use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use middle::def::*;\n use middle::lang_items::LanguageItems;\n-use lint::{UnnecessaryQualification, UnusedImports};\n use middle::pat_util::pat_bindings;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace};\n+use lint;\n use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n use syntax::ast::*;\n@@ -4632,7 +4632,7 @@ impl<'a> Resolver<'a> {\n             match (def, unqualified_def) {\n                 (Some((d, _)), Some((ud, _))) if d == ud => {\n                     self.session\n-                        .add_lint(UnnecessaryQualification,\n+                        .add_lint(lint::builtin::unnecessary_qualification,\n                                   id,\n                                   path.span,\n                                   \"unnecessary qualification\".to_string());\n@@ -5487,7 +5487,7 @@ impl<'a> Resolver<'a> {\n                         if !self.used_imports.contains(&(id, TypeNS)) &&\n                            !self.used_imports.contains(&(id, ValueNS)) {\n                             self.session\n-                                .add_lint(UnusedImports,\n+                                .add_lint(lint::builtin::unused_imports,\n                                           id,\n                                           p.span,\n                                           \"unused import\".to_string());\n@@ -5511,7 +5511,7 @@ impl<'a> Resolver<'a> {\n \n         if !self.used_imports.contains(&(id, TypeNS)) &&\n            !self.used_imports.contains(&(id, ValueNS)) {\n-            self.session.add_lint(UnusedImports,\n+            self.session.add_lint(lint::builtin::unused_imports,\n                                   id,\n                                   span,\n                                   \"unused import\".to_string());"}, {"sha": "5513a44a2ab59a72f64748a785b0625bfbd8b1f3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -1552,48 +1552,50 @@ fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span, id: ast::NodeId) {\n     let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n \n-    let (lvl, src) = ccx.tcx.node_lint_levels.borrow()\n-                        .find(&(id, lint::VariantSizeDifference))\n-                        .map_or((lint::Allow, lint::Default), |&(lvl,src)| (lvl, src));\n-\n-    if lvl != lint::Allow {\n-        let avar = adt::represent_type(ccx, ty::node_id_to_type(ccx.tcx(), id));\n-        match *avar {\n-            adt::General(_, ref variants) => {\n-                for var in variants.iter() {\n-                    let mut size = 0;\n-                    for field in var.fields.iter().skip(1) {\n-                        // skip the discriminant\n-                        size += llsize_of_real(ccx, sizing_type_of(ccx, *field));\n+    let levels = ccx.tcx.node_lint_levels.borrow();\n+    match levels.find(&(id, lint::LintId::of(lint::builtin::variant_size_difference))) {\n+        None | Some(&(lint::Allow, _)) => (),\n+        Some(&lvlsrc) => {\n+            let avar = adt::represent_type(ccx, ty::node_id_to_type(ccx.tcx(), id));\n+            match *avar {\n+                adt::General(_, ref variants) => {\n+                    for var in variants.iter() {\n+                        let mut size = 0;\n+                        for field in var.fields.iter().skip(1) {\n+                            // skip the discriminant\n+                            size += llsize_of_real(ccx, sizing_type_of(ccx, *field));\n+                        }\n+                        sizes.push(size);\n                     }\n-                    sizes.push(size);\n-                }\n-            },\n-            _ => { /* its size is either constant or unimportant */ }\n-        }\n+                },\n+                _ => { /* its size is either constant or unimportant */ }\n+            }\n \n-        let (largest, slargest, largest_index) = sizes.iter().enumerate().fold((0, 0, 0),\n-            |(l, s, li), (idx, &size)|\n-                if size > l {\n-                    (size, l, idx)\n-                } else if size > s {\n-                    (l, size, li)\n-                } else {\n-                    (l, s, li)\n-                }\n-        );\n-\n-        // we only warn if the largest variant is at least thrice as large as\n-        // the second-largest.\n-        if largest > slargest * 3 && slargest > 0 {\n-            lint::emit_lint(lvl, src,\n-                            format!(\"enum variant is more than three times larger \\\n-                                    ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest).as_slice(),\n-                            sp, lint::lint_to_str(lint::VariantSizeDifference), ccx.tcx());\n-\n-            ccx.sess().span_note(enum_def.variants.get(largest_index).span,\n-                                 \"this variant is the largest\");\n+            let (largest, slargest, largest_index) = sizes.iter().enumerate().fold((0, 0, 0),\n+                |(l, s, li), (idx, &size)|\n+                    if size > l {\n+                        (size, l, idx)\n+                    } else if size > s {\n+                        (l, size, li)\n+                    } else {\n+                        (l, s, li)\n+                    }\n+            );\n+\n+            // we only warn if the largest variant is at least thrice as large as\n+            // the second-largest.\n+            if largest > slargest * 3 && slargest > 0 {\n+                // Use lint::emit_lint rather than sess.add_lint because the lint-printing\n+                // pass for the latter already ran.\n+                lint::emit_lint(&ccx.tcx().sess, lint::builtin::variant_size_difference,\n+                                lvlsrc, sp,\n+                                format!(\"enum variant is more than three times larger \\\n+                                        ({} bytes) than the next largest (ignoring padding)\",\n+                                        largest).as_slice());\n+\n+                ccx.sess().span_note(enum_def.variants.get(largest_index).span,\n+                                     \"this variant is the largest\");\n+            }\n         }\n     }\n }"}, {"sha": "b0e838a442b8d910e84c694de28c96a86c66c6d1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -368,7 +368,7 @@ pub struct ctxt {\n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n \n     pub node_lint_levels: RefCell<HashMap<(ast::NodeId, lint::LintId),\n-                                          (lint::Level, lint::LintSource)>>,\n+                                          lint::LevelSource>>,\n \n     /// The types that must be asserted to be the same size for `transmute`\n     /// to be valid. We gather up these restrictions in the intrinsicck pass"}, {"sha": "bb781307668217528a15fac99a1ec4757f587dfb", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -79,7 +79,6 @@ type parameter).\n \n use middle::const_eval;\n use middle::def;\n-use lint::UnreachableCode;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::subst;\n@@ -111,6 +110,7 @@ use middle::typeck::{require_same_types, vtable_map};\n use middle::typeck::{MethodCall, MethodMap};\n use middle::typeck::{TypeAndSubsts};\n use middle::lang_items::TypeIdLangItem;\n+use lint;\n use util::common::{block_query, indenter, loop_query};\n use util::ppaux;\n use util::ppaux::{UserString, Repr};\n@@ -3416,7 +3416,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                 fcx.ccx\n                    .tcx\n                    .sess\n-                   .add_lint(UnreachableCode,\n+                   .add_lint(lint::builtin::unreachable_code,\n                              s_id,\n                              s.span,\n                              \"unreachable statement\".to_string());\n@@ -3443,7 +3443,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                 fcx.ccx\n                    .tcx\n                    .sess\n-                   .add_lint(UnreachableCode,\n+                   .add_lint(lint::builtin::unreachable_code,\n                              e.id,\n                              e.span,\n                              \"unreachable expression\".to_string());"}, {"sha": "ef8367dfc76132ebdba13a8ff4f654e0cc4fafc0", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442fbc473e10d1efe3359b19f342d11097259fc4/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=442fbc473e10d1efe3359b19f342d11097259fc4", "patch": "@@ -75,11 +75,13 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n \n     let input = FileInput(cpath.clone());\n \n+    let warning_lint = lint::builtin::warnings.name.to_string();\n+\n     let sessopts = driver::config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(driver::config::CrateTypeRlib),\n-        lint_opts: vec!((lint::Warnings, lint::Allow)),\n+        lint_opts: vec!((warning_lint, lint::Allow)),\n         ..rustc::driver::config::basic_options().clone()\n     };\n "}]}