{"sha": "257d279fe47bbf3431c76f0942654c1bcf60d501", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1N2QyNzlmZTQ3YmJmMzQzMWM3NmYwOTQyNjU0YzFiY2Y2MGQ1MDE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-05-23T13:59:42Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-06-27T12:00:34Z"}, "message": "Make FileMap::{lines, multibyte_chars, non_narrow_chars} non-mutable.", "tree": {"sha": "b7230231778da7b5345f80ea6565c67ce9b14843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7230231778da7b5345f80ea6565c67ce9b14843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/257d279fe47bbf3431c76f0942654c1bcf60d501", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/257d279fe47bbf3431c76f0942654c1bcf60d501", "html_url": "https://github.com/rust-lang/rust/commit/257d279fe47bbf3431c76f0942654c1bcf60d501", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/257d279fe47bbf3431c76f0942654c1bcf60d501/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c20824323cf7ed6ad95cb8d7b780a7934927a753", "url": "https://api.github.com/repos/rust-lang/rust/commits/c20824323cf7ed6ad95cb8d7b780a7934927a753", "html_url": "https://github.com/rust-lang/rust/commit/c20824323cf7ed6ad95cb8d7b780a7934927a753"}], "stats": {"total": 259, "additions": 121, "deletions": 138}, "files": [{"sha": "a7a6a71474f002126f0aa1160cd37ac2239c1dae", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=257d279fe47bbf3431c76f0942654c1bcf60d501", "patch": "@@ -455,27 +455,21 @@ impl<'a> HashStable<StableHashingContext<'a>> for FileMap {\n         src_hash.hash_stable(hcx, hasher);\n \n         // We only hash the relative position within this filemap\n-        lines.with_lock(|lines| {\n-            lines.len().hash_stable(hcx, hasher);\n-            for &line in lines.iter() {\n-                stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n-            }\n-        });\n+        lines.len().hash_stable(hcx, hasher);\n+        for &line in lines.iter() {\n+            stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n+        }\n \n         // We only hash the relative position within this filemap\n-        multibyte_chars.with_lock(|multibyte_chars| {\n-            multibyte_chars.len().hash_stable(hcx, hasher);\n-            for &char_pos in multibyte_chars.iter() {\n-                stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n-            }\n-        });\n+        multibyte_chars.len().hash_stable(hcx, hasher);\n+        for &char_pos in multibyte_chars.iter() {\n+            stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n+        }\n \n-        non_narrow_chars.with_lock(|non_narrow_chars| {\n-            non_narrow_chars.len().hash_stable(hcx, hasher);\n-            for &char_pos in non_narrow_chars.iter() {\n-                stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n-            }\n-        });\n+        non_narrow_chars.len().hash_stable(hcx, hasher);\n+        for &char_pos in non_narrow_chars.iter() {\n+            stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n+        }\n     }\n }\n "}, {"sha": "7aa6f3a55ad749a3195cbff6b0ec20c6ae71e0d2", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=257d279fe47bbf3431c76f0942654c1bcf60d501", "patch": "@@ -623,7 +623,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n         let len = BytePos::decode(self)?;\n \n         let file_lo = self.file_index_to_file(file_lo_index);\n-        let lo = file_lo.lines.borrow()[line_lo - 1] + col_lo;\n+        let lo = file_lo.lines[line_lo - 1] + col_lo;\n         let hi = lo + len;\n \n         let expn_info_tag = u8::decode(self)?;"}, {"sha": "a01e0b608646d22c34189b2e09c1a099c5dbd064", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=257d279fe47bbf3431c76f0942654c1bcf60d501", "patch": "@@ -1138,9 +1138,9 @@ impl<'a, 'tcx> CrateMetadata {\n                                       src_hash,\n                                       start_pos,\n                                       end_pos,\n-                                      lines,\n-                                      multibyte_chars,\n-                                      non_narrow_chars,\n+                                      mut lines,\n+                                      mut multibyte_chars,\n+                                      mut non_narrow_chars,\n                                       name_hash,\n                                       .. } = filemap_to_import;\n \n@@ -1151,15 +1151,12 @@ impl<'a, 'tcx> CrateMetadata {\n             // `CodeMap::new_imported_filemap()` will then translate those\n             // coordinates to their new global frame of reference when the\n             // offset of the FileMap is known.\n-            let mut lines = lines.into_inner();\n             for pos in &mut lines {\n                 *pos = *pos - start_pos;\n             }\n-            let mut multibyte_chars = multibyte_chars.into_inner();\n             for mbc in &mut multibyte_chars {\n                 mbc.pos = mbc.pos - start_pos;\n             }\n-            let mut non_narrow_chars = non_narrow_chars.into_inner();\n             for swc in &mut non_narrow_chars {\n                 *swc = *swc - start_pos;\n             }"}, {"sha": "000f1607514858b9b508099707defd2a7c077555", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=257d279fe47bbf3431c76f0942654c1bcf60d501", "patch": "@@ -250,16 +250,7 @@ impl CodeMap {\n     /// Creates a new filemap and sets its line information.\n     /// This does not ensure that only one FileMap exists per file name.\n     pub fn new_filemap_and_lines(&self, filename: &Path, src: &str) -> Lrc<FileMap> {\n-        let fm = self.new_filemap(filename.to_owned().into(), src.to_owned());\n-        let mut byte_pos: u32 = fm.start_pos.0;\n-        for line in src.lines() {\n-            // register the start of this line\n-            fm.next_line(BytePos(byte_pos));\n-\n-            // update byte_pos to include this line and the \\n at the end\n-            byte_pos += line.len() as u32 + 1;\n-        }\n-        fm\n+        self.new_filemap(filename.to_owned().into(), src.to_owned())\n     }\n \n \n@@ -305,9 +296,9 @@ impl CodeMap {\n             external_src: Lock::new(ExternalSource::AbsentOk),\n             start_pos,\n             end_pos,\n-            lines: Lock::new(file_local_lines),\n-            multibyte_chars: Lock::new(file_local_multibyte_chars),\n-            non_narrow_chars: Lock::new(file_local_non_narrow_chars),\n+            lines: file_local_lines,\n+            multibyte_chars: file_local_multibyte_chars,\n+            non_narrow_chars: file_local_non_narrow_chars,\n             name_hash,\n         });\n \n@@ -345,21 +336,22 @@ impl CodeMap {\n         match self.lookup_line(pos) {\n             Ok(FileMapAndLine { fm: f, line: a }) => {\n                 let line = a + 1; // Line numbers start at 1\n-                let linebpos = (*f.lines.borrow())[a];\n+                let linebpos = f.lines[a];\n                 let linechpos = self.bytepos_to_file_charpos(linebpos);\n                 let col = chpos - linechpos;\n \n                 let col_display = {\n-                    let non_narrow_chars = f.non_narrow_chars.borrow();\n-                    let start_width_idx = non_narrow_chars\n+                    let start_width_idx = f\n+                        .non_narrow_chars\n                         .binary_search_by_key(&linebpos, |x| x.pos())\n                         .unwrap_or_else(|x| x);\n-                    let end_width_idx = non_narrow_chars\n+                    let end_width_idx = f\n+                        .non_narrow_chars\n                         .binary_search_by_key(&pos, |x| x.pos())\n                         .unwrap_or_else(|x| x);\n                     let special_chars = end_width_idx - start_width_idx;\n-                    let non_narrow: usize =\n-                        non_narrow_chars[start_width_idx..end_width_idx]\n+                    let non_narrow: usize = f\n+                        .non_narrow_chars[start_width_idx..end_width_idx]\n                         .into_iter()\n                         .map(|x| x.width())\n                         .sum();\n@@ -380,12 +372,12 @@ impl CodeMap {\n             }\n             Err(f) => {\n                 let col_display = {\n-                    let non_narrow_chars = f.non_narrow_chars.borrow();\n-                    let end_width_idx = non_narrow_chars\n+                    let end_width_idx = f\n+                        .non_narrow_chars\n                         .binary_search_by_key(&pos, |x| x.pos())\n                         .unwrap_or_else(|x| x);\n-                    let non_narrow: usize =\n-                        non_narrow_chars[0..end_width_idx]\n+                    let non_narrow: usize = f\n+                        .non_narrow_chars[0..end_width_idx]\n                         .into_iter()\n                         .map(|x| x.width())\n                         .sum();\n@@ -830,7 +822,7 @@ impl CodeMap {\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        for mbc in map.multibyte_chars.borrow().iter() {\n+        for mbc in map.multibyte_chars.iter() {\n             debug!(\"{}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 // every character is at least one byte, so we only"}, {"sha": "dcc71e787785289558e18a8872aac5dc23a15c4d", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=257d279fe47bbf3431c76f0942654c1bcf60d501", "patch": "@@ -51,11 +51,7 @@ pub struct StringReader<'a> {\n     pub ch: Option<char>,\n     pub filemap: Lrc<syntax_pos::FileMap>,\n     /// Stop reading src at this index.\n-    end_src_index: usize,\n-    /// Whether to record new-lines and multibyte chars in filemap.\n-    /// This is only necessary the first time a filemap is lexed.\n-    /// If part of a filemap is being re-lexed, this should be set to false.\n-    save_new_lines_and_multibyte: bool,\n+    pub end_src_index: usize,\n     // cached:\n     peek_tok: token::Token,\n     peek_span: Span,\n@@ -188,7 +184,6 @@ impl<'a> StringReader<'a> {\n             ch: Some('\\n'),\n             filemap,\n             end_src_index: src.len(),\n-            save_new_lines_and_multibyte: true,\n             // dummy values; not read\n             peek_tok: token::Eof,\n             peek_span: syntax_pos::DUMMY_SP,\n@@ -225,7 +220,6 @@ impl<'a> StringReader<'a> {\n         let mut sr = StringReader::new_raw_internal(sess, begin.fm, None);\n \n         // Seek the lexer to the right byte range.\n-        sr.save_new_lines_and_multibyte = false;\n         sr.next_pos = span.lo();\n         sr.end_src_index = sr.src_index(span.hi());\n \n@@ -458,18 +452,6 @@ impl<'a> StringReader<'a> {\n             let next_ch = char_at(&self.src, next_src_index);\n             let next_ch_len = next_ch.len_utf8();\n \n-            if self.ch.unwrap() == '\\n' {\n-                if self.save_new_lines_and_multibyte {\n-                    self.filemap.next_line(self.next_pos);\n-                }\n-            }\n-            if next_ch_len > 1 {\n-                if self.save_new_lines_and_multibyte {\n-                    self.filemap.record_multibyte_char(self.next_pos, next_ch_len);\n-                }\n-            }\n-            self.filemap.record_width(self.next_pos, next_ch);\n-\n             self.ch = Some(next_ch);\n             self.pos = self.next_pos;\n             self.next_pos = self.next_pos + Pos::from_usize(next_ch_len);"}, {"sha": "266737dd7b66aee6deb9e98d73f205ca5e72b0b8", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 88, "deletions": 70, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257d279fe47bbf3431c76f0942654c1bcf60d501/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=257d279fe47bbf3431c76f0942654c1bcf60d501", "patch": "@@ -779,11 +779,11 @@ pub struct FileMap {\n     /// The end position of this source in the CodeMap\n     pub end_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n-    pub lines: Lock<Vec<BytePos>>,\n+    pub lines: Vec<BytePos>,\n     /// Locations of multi-byte characters in the source code\n-    pub multibyte_chars: Lock<Vec<MultiByteChar>>,\n+    pub multibyte_chars: Vec<MultiByteChar>,\n     /// Width of characters that are not narrow in the source code\n-    pub non_narrow_chars: Lock<Vec<NonNarrowChar>>,\n+    pub non_narrow_chars: Vec<NonNarrowChar>,\n     /// A hash of the filename, used for speeding up the incr. comp. hashing.\n     pub name_hash: u128,\n }\n@@ -797,7 +797,7 @@ impl Encodable for FileMap {\n             s.emit_struct_field(\"start_pos\", 4, |s| self.start_pos.encode(s))?;\n             s.emit_struct_field(\"end_pos\", 5, |s| self.end_pos.encode(s))?;\n             s.emit_struct_field(\"lines\", 6, |s| {\n-                let lines = self.lines.borrow();\n+                let lines = &self.lines[..];\n                 // store the length\n                 s.emit_u32(lines.len() as u32)?;\n \n@@ -843,10 +843,10 @@ impl Encodable for FileMap {\n                 Ok(())\n             })?;\n             s.emit_struct_field(\"multibyte_chars\", 7, |s| {\n-                (*self.multibyte_chars.borrow()).encode(s)\n+                self.multibyte_chars.encode(s)\n             })?;\n             s.emit_struct_field(\"non_narrow_chars\", 8, |s| {\n-                (*self.non_narrow_chars.borrow()).encode(s)\n+                self.non_narrow_chars.encode(s)\n             })?;\n             s.emit_struct_field(\"name_hash\", 9, |s| {\n                 self.name_hash.encode(s)\n@@ -914,9 +914,9 @@ impl Decodable for FileMap {\n                 src: None,\n                 src_hash,\n                 external_src: Lock::new(ExternalSource::AbsentOk),\n-                lines: Lock::new(lines),\n-                multibyte_chars: Lock::new(multibyte_chars),\n-                non_narrow_chars: Lock::new(non_narrow_chars),\n+                lines,\n+                multibyte_chars,\n+                non_narrow_chars,\n                 name_hash,\n             })\n         })\n@@ -949,6 +949,9 @@ impl FileMap {\n         };\n         let end_pos = start_pos.to_usize() + src.len();\n \n+        let (lines, multibyte_chars, non_narrow_chars) =\n+            Self::find_newlines_and_special_chars(&src[..], start_pos);\n+\n         FileMap {\n             name,\n             name_was_remapped,\n@@ -959,34 +962,81 @@ impl FileMap {\n             external_src: Lock::new(ExternalSource::Unneeded),\n             start_pos,\n             end_pos: Pos::from_usize(end_pos),\n-            lines: Lock::new(Vec::new()),\n-            multibyte_chars: Lock::new(Vec::new()),\n-            non_narrow_chars: Lock::new(Vec::new()),\n+            lines,\n+            multibyte_chars,\n+            non_narrow_chars,\n             name_hash,\n         }\n     }\n \n-    /// EFFECT: register a start-of-line offset in the\n-    /// table of line-beginnings.\n-    /// UNCHECKED INVARIANT: these offsets must be added in the right\n-    /// order and must be in the right places; there is shared knowledge\n-    /// about what ends a line between this file and parse.rs\n-    /// WARNING: pos param here is the offset relative to start of CodeMap,\n-    /// and CodeMap will append a newline when adding a filemap without a newline at the end,\n-    /// so the safe way to call this is with value calculated as\n-    /// filemap.start_pos + newline_offset_relative_to_the_start_of_filemap.\n-    pub fn next_line(&self, pos: BytePos) {\n-        // the new charpos must be > the last one (or it's the first one).\n-        let mut lines = self.lines.borrow_mut();\n-        let line_len = lines.len();\n-        assert!(line_len == 0 || ((*lines)[line_len - 1] < pos));\n-        lines.push(pos);\n+    fn find_newlines_and_special_chars(src: &str, filemap_start_pos: BytePos)\n+        -> (Vec<BytePos>, Vec<MultiByteChar>, Vec<NonNarrowChar>) {\n+\n+        let mut index = 0;\n+        let mut lines = vec![filemap_start_pos];\n+        let mut multibyte_chars = vec![];\n+        let mut non_narrow_chars = vec![];\n+\n+        while index < src.len() {\n+            let byte_pos = BytePos::from_usize(index) + filemap_start_pos;\n+            let byte = src.as_bytes()[index];\n+\n+            if byte.is_ascii() {\n+                match byte {\n+                    b'\\n' => {\n+                        lines.push(byte_pos + BytePos(1));\n+                    }\n+                    b'\\t' => {\n+                        // Tabs will consume 4 columns.\n+                        non_narrow_chars.push(NonNarrowChar::new(byte_pos, 4));\n+                    }\n+                    c => if c.is_ascii_control() {\n+                        // Assume control characters are zero width.\n+                        non_narrow_chars.push(NonNarrowChar::new(byte_pos, 0));\n+                    }\n+                }\n+\n+                index += 1;\n+            } else {\n+                let c = (&src[index..]).chars().next().unwrap();\n+                let c_len = c.len_utf8();\n+\n+                if c_len > 1 {\n+                    assert!(c_len >=2 && c_len <= 4);\n+                    let mbc = MultiByteChar {\n+                        pos: byte_pos,\n+                        bytes: c_len,\n+                    };\n+                    multibyte_chars.push(mbc);\n+                }\n+\n+                // Assume control characters are zero width.\n+                // FIXME: How can we decide between `width` and `width_cjk`?\n+                let c_width = unicode_width::UnicodeWidthChar::width(c).unwrap_or(0);\n+\n+                if c_width != 1 {\n+                    non_narrow_chars.push(NonNarrowChar::new(byte_pos, c_width));\n+                }\n+\n+                index += c_len;\n+            }\n+        }\n+\n+        // The loop above optimistically registers a new line *after* each of \\n\n+        // it encounters. If that point is already outside the filemap, remove\n+        // it again.\n+        if let Some(&last_line_start) = lines.last() {\n+            if last_line_start == filemap_start_pos + BytePos::from_usize(src.len()) {\n+                lines.pop();\n+            }\n+        }\n+\n+        (lines, multibyte_chars, non_narrow_chars)\n     }\n \n     /// Return the BytePos of the beginning of the current line.\n     pub fn line_begin_pos(&self) -> BytePos {\n-        let lines = self.lines.borrow();\n-        match lines.last() {\n+        match self.lines.last() {\n             Some(&line_pos) => line_pos,\n             None => self.start_pos,\n         }\n@@ -1040,8 +1090,7 @@ impl FileMap {\n         }\n \n         let begin = {\n-            let lines = self.lines.borrow();\n-            let line = if let Some(line) = lines.get(line_number) {\n+            let line = if let Some(line) = self.lines.get(line_number) {\n                 line\n             } else {\n                 return None;\n@@ -1059,35 +1108,6 @@ impl FileMap {\n         }\n     }\n \n-    pub fn record_multibyte_char(&self, pos: BytePos, bytes: usize) {\n-        assert!(bytes >=2 && bytes <= 4);\n-        let mbc = MultiByteChar {\n-            pos,\n-            bytes,\n-        };\n-        self.multibyte_chars.borrow_mut().push(mbc);\n-    }\n-\n-    #[inline]\n-    pub fn record_width(&self, pos: BytePos, ch: char) {\n-        let width = match ch {\n-            '\\t' =>\n-                // Tabs will consume 4 columns.\n-                4,\n-            '\\n' =>\n-                // Make newlines take one column so that displayed spans can point them.\n-                1,\n-            ch =>\n-                // Assume control characters are zero width.\n-                // FIXME: How can we decide between `width` and `width_cjk`?\n-                unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0),\n-        };\n-        // Only record non-narrow characters.\n-        if width != 1 {\n-            self.non_narrow_chars.borrow_mut().push(NonNarrowChar::new(pos, width));\n-        }\n-    }\n-\n     pub fn is_real_file(&self) -> bool {\n         self.name.is_real()\n     }\n@@ -1100,21 +1120,20 @@ impl FileMap {\n         self.end_pos.0 - self.start_pos.0\n     }\n     pub fn count_lines(&self) -> usize {\n-        self.lines.borrow().len()\n+        self.lines.len()\n     }\n \n     /// Find the line containing the given position. The return value is the\n     /// index into the `lines` array of this FileMap, not the 1-based line\n     /// number. If the filemap is empty or the position is located before the\n     /// first line, None is returned.\n     pub fn lookup_line(&self, pos: BytePos) -> Option<usize> {\n-        let lines = self.lines.borrow();\n-        if lines.len() == 0 {\n+        if self.lines.len() == 0 {\n             return None;\n         }\n \n-        let line_index = lookup_line(&lines[..], pos);\n-        assert!(line_index < lines.len() as isize);\n+        let line_index = lookup_line(&self.lines[..], pos);\n+        assert!(line_index < self.lines.len() as isize);\n         if line_index >= 0 {\n             Some(line_index as usize)\n         } else {\n@@ -1127,12 +1146,11 @@ impl FileMap {\n             return (self.start_pos, self.end_pos);\n         }\n \n-        let lines = self.lines.borrow();\n-        assert!(line_index < lines.len());\n-        if line_index == (lines.len() - 1) {\n-            (lines[line_index], self.end_pos)\n+        assert!(line_index < self.lines.len());\n+        if line_index == (self.lines.len() - 1) {\n+            (self.lines[line_index], self.end_pos)\n         } else {\n-            (lines[line_index], lines[line_index + 1])\n+            (self.lines[line_index], self.lines[line_index + 1])\n         }\n     }\n "}]}