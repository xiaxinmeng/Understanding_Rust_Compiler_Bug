{"sha": "1a68a98824cab9122bb39920d09415ff34a3944e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNjhhOTg4MjRjYWI5MTIyYmIzOTkyMGQwOTQxNWZmMzRhMzk0NGU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-03T09:57:54Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-03T09:57:54Z"}, "message": "Disallow writing to function arguments again\n\nRemove implicit copying hack.\n\nCloses #1118", "tree": {"sha": "322a122fe33ac78370e068433f217dca064cf725", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/322a122fe33ac78370e068433f217dca064cf725"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a68a98824cab9122bb39920d09415ff34a3944e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a68a98824cab9122bb39920d09415ff34a3944e", "html_url": "https://github.com/rust-lang/rust/commit/1a68a98824cab9122bb39920d09415ff34a3944e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a68a98824cab9122bb39920d09415ff34a3944e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1deaf9700244eb44d789a284e8ba8e43d03aea7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1deaf9700244eb44d789a284e8ba8e43d03aea7d", "html_url": "https://github.com/rust-lang/rust/commit/1deaf9700244eb44d789a284e8ba8e43d03aea7d"}], "stats": {"total": 220, "additions": 107, "deletions": 113}, "files": [{"sha": "74d13c9a4ca00c3e3d006a0d2d86010daaaef407", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -504,7 +504,7 @@ fn early_error(msg: str) -> ! {\n }\n \n fn main(args: [str]) {\n-    let binary = vec::shift(args);\n+    let args = args, binary = vec::shift(args);\n     let match =\n         alt getopts::getopts(args, opts()) {\n           getopts::success(m) { m }"}, {"sha": "5946b337b489fdc1a4717e950a5ac7766e85e55a", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -118,6 +118,7 @@ fn find_library_crate(sess: session::session, ident: ast::ident,\n    -> option::t<{ident: str, data: @[u8]}> {\n \n     attr::require_unique_names(sess, metas);\n+    let metas = metas;\n \n     // Metadata \"name\" will be used to find the crate. Use `ident'\n     // as \"name\" if the attribute is not explicitly specified"}, {"sha": "940ce38fa40b585ec771a4ab82884c7c9f8923dd", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -132,7 +132,7 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n }\n \n fn visit_block(cx: @ctx, b: ast::blk, sc: scope, v: vt<scope>) {\n-    let bs = sc.bs;\n+    let bs = sc.bs, sc = sc;\n     for stmt in b.node.stmts {\n         alt stmt.node {\n           ast::stmt_decl(@{node: ast::decl_item(it), _}, _) {"}, {"sha": "7f5b523aba583c8fa3ebcb5179934b237bc6333b", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -15,7 +15,7 @@ type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n    {ex: @expr, ds: @[deref]} {\n     fn maybe_auto_unbox(tcx: ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n-        let ds = [];\n+        let ds = [], t = t;\n         while true {\n             alt ty::struct(tcx, t) {\n               ty::ty_box(mt) {\n@@ -44,7 +44,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n         }\n         ret {t: t, ds: ds};\n     }\n-    let ds: [deref] = [];\n+    let ds: [deref] = [], ex = ex;\n     while true {\n         alt copy ex.node {\n           expr_field(base, ident) {\n@@ -237,6 +237,8 @@ fn is_immutable_def(def: def) -> option::t<str> {\n       def_use(_) {\n         some(\"static item\")\n       }\n+      def_arg(_, by_ref.) | def_arg(_, by_val.) |\n+      def_arg(_, mode_infer.) { some(\"argument\") }\n       def_obj_field(_, imm.) { some(\"immutable object field\") }\n       def_upvar(_, inner, mut) {\n         if !mut { some(\"upvar\") } else { is_immutable_def(*inner) }"}, {"sha": "7745f8b94c2927b69e5ba60e629ff2ebaa25e622", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -502,6 +502,7 @@ fn ns_name(ns: namespace) -> str {\n \n fn unresolved_err(e: env, sc: scopes, sp: span, name: ident, kind: str) {\n     fn find_fn_or_mod_scope(sc: scopes) -> option::t<scope> {\n+        let sc = sc;\n         while true {\n             alt sc {\n               cons(cur, rest) {\n@@ -671,6 +672,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n     let closing = [];\n     // Used to determine whether obj fields are in scope\n     let left_fn_level2 = false;\n+    let sc = sc;\n     while true {\n         alt copy sc {\n           nil. { ret none::<def>; }\n@@ -1191,6 +1193,7 @@ fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n     let saw_mod = false;\n     let saw_type = false;\n     let saw_value = false;\n+    let entries = entries;\n     fn dup(e: env, sp: span, word: str, name: ident) {\n         e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n     }"}, {"sha": "e5e5b721a045bb1a6bb22750533bca89848d0366", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -929,7 +929,7 @@ fn trans_stack_local_derived_tydesc(cx: @block_ctxt, llsz: ValueRef,\n     let llmyroottydesc = alloca(cx, bcx_ccx(cx).tydesc_type);\n \n     // By convention, desc 0 is the root descriptor.\n-    llroottydesc = Load(cx, llroottydesc);\n+    let llroottydesc = Load(cx, llroottydesc);\n     Store(cx, llroottydesc, llmyroottydesc);\n \n     // Store a pointer to the rest of the descriptors.\n@@ -1352,7 +1352,7 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n     // everything to a pointer to the type that the glue acts on).\n     let bcx = alt ty::struct(bcx_tcx(bcx), t) {\n       ty::ty_box(body_mt) {\n-        v = PointerCast(bcx, v, type_of_1(bcx, t));\n+        let v = PointerCast(bcx, v, type_of_1(bcx, t));\n         let body = GEPi(bcx, v, [0, abi::box_rc_field_body]);\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         if !bcx_ccx(bcx).sess.get_opts().do_gc {\n@@ -1361,7 +1361,7 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n       }\n       ty::ty_uniq(content_mt) {\n         check trans_uniq::type_is_unique_box(bcx, t);\n-        v = PointerCast(bcx, v, type_of_1(bcx, t));\n+        let v = PointerCast(bcx, v, type_of_1(bcx, t));\n         trans_uniq::make_free_glue(bcx, v, t)\n       }\n       ty::ty_vec(_) | ty::ty_str. {\n@@ -1388,7 +1388,7 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n         // Call through the closure's own fields-drop glue first.\n         // Then free the body.\n         let ccx = bcx_ccx(bcx);\n-        v = PointerCast(bcx, v, T_opaque_closure_ptr(ccx));\n+        let v = PointerCast(bcx, v, T_opaque_closure_ptr(ccx));\n         let body = GEPi(bcx, v, [0, abi::box_rc_field_body]);\n         let bindings =\n             GEPi(bcx, body, [0, abi::closure_elt_bindings]);\n@@ -1448,7 +1448,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     // Silly check\n     check type_is_tup_like(cx, tup_ty);\n     let drop_flag = GEP_tup_like(cx, tup_ty, rs, [0, 0]);\n-    cx = drop_flag.bcx;\n+    let cx = drop_flag.bcx;\n     let null_test = IsNull(cx, Load(cx, drop_flag.val));\n     CondBr(cx, null_test, next_cx.llbb, drop_cx.llbb);\n     cx = drop_cx;\n@@ -1487,7 +1487,7 @@ fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr: ValueRef, t: ty::t)\n     let free_cx = new_sub_block_ctxt(cx, \"free\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let llbox_ty = T_opaque_obj_ptr(ccx);\n-    box_ptr = PointerCast(cx, box_ptr, llbox_ty);\n+    let box_ptr = PointerCast(cx, box_ptr, llbox_ty);\n     let null_test = IsNull(cx, box_ptr);\n     CondBr(cx, null_test, next_cx.llbb, rc_adj_cx.llbb);\n     let rc_ptr =\n@@ -1640,6 +1640,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         if std::vec::len::<ty::t>(variant.args) == 0u { ret cx; }\n         let fn_ty = variant.ctor_ty;\n         let ccx = bcx_ccx(cx);\n+        let cx = cx;\n         alt ty::struct(ccx.tcx, fn_ty) {\n           ty::ty_fn(_, args, _, _, _) {\n             let j = 0u;\n@@ -1661,6 +1662,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n     /*\n     Typestate constraint that shows the unimpl case doesn't happen?\n     */\n+    let cx = cx;\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_rec(fields) {\n         let i: int = 0;\n@@ -2054,7 +2056,7 @@ fn copy_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n \n fn copy_val_no_check(bcx: @block_ctxt, action: copy_action, dst: ValueRef,\n                      src: ValueRef, t: ty::t) -> @block_ctxt {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx_ccx(bcx), bcx = bcx;\n     if ty::type_is_scalar(ccx.tcx, t) || ty::type_is_native(ccx.tcx, t) {\n         Store(bcx, src, dst);\n         ret bcx;\n@@ -2084,7 +2086,7 @@ fn copy_val_no_check(bcx: @block_ctxt, action: copy_action, dst: ValueRef,\n fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> @block_ctxt {\n     let src_val = src.val;\n-    let tcx = bcx_tcx(cx);\n+    let tcx = bcx_tcx(cx), cx = cx;\n     if ty::type_is_scalar(tcx, t) || ty::type_is_native(tcx, t) {\n         if src.kind == owned { src_val = Load(cx, src_val); }\n         Store(cx, src_val, dst);\n@@ -2230,17 +2232,16 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n                  id: ast::node_id, dest: dest) -> @block_ctxt {\n     if dest == ignore { ret bcx; }\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx_ccx(bcx), bcx = bcx;\n     let fty = node_id_type(ccx, id);\n     check returns_non_ty_var(ccx, fty);\n     let llfnty = type_of_fn_from_ty(ccx, sp, fty, 0u);\n     let sub_cx = extend_path(bcx.fcx.lcx, ccx.names.next(\"anon\"));\n     let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n-    let copying =\n-        f.proto == ast::proto_shared(ast::sugar_normal)\n-        || f.proto == ast::proto_shared(ast::sugar_sexy);\n+    let copying = f.proto == ast::proto_shared(ast::sugar_normal)\n+               || f.proto == ast::proto_shared(ast::sugar_sexy);\n     let env;\n     alt f.proto {\n       ast::proto_block. | ast::proto_shared(_) {\n@@ -2300,7 +2301,7 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n     if op == ast::add && ty::type_is_sequence(bcx_tcx(cx), intype) {\n         ret tvec::trans_add(cx, intype, lhs, rhs, dest);\n     }\n-    let val = alt op {\n+    let cx = cx, val = alt op {\n       ast::add. {\n         if is_float { FAdd(cx, lhs, rhs) }\n         else { Add(cx, lhs, rhs) }\n@@ -2573,9 +2574,9 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n             new_loop_scope_block_ctxt(bcx, option::some(next_cx),\n                                       outer_next_cx, \"for loop scope\");\n         Br(bcx, scope_cx.llbb);\n-        curr = PointerCast(bcx, curr, T_ptr(type_of_or_i8(bcx, t)));\n-        bcx = trans_alt::bind_irrefutable_pat(scope_cx, local.node.pat, curr,\n-                                              false);\n+        let curr = PointerCast(bcx, curr, T_ptr(type_of_or_i8(bcx, t)));\n+        let bcx = trans_alt::bind_irrefutable_pat(scope_cx, local.node.pat,\n+                                                  curr, false);\n         bcx = trans_block_dps(bcx, body, ignore);\n         Br(bcx, next_cx.llbb);\n         ret next_cx;\n@@ -2649,7 +2650,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     // Finally, synthesize a type for that whole vector.\n     let closure_ty: ty::t = ty::mk_tup(tcx, closure_tys);\n \n-    let temp_cleanups = [];\n+    let temp_cleanups = [], bcx = bcx;\n     // Allocate a box that can hold something closure-sized.\n     let (closure, box) = if copying {\n         let r = trans_malloc_boxed(bcx, closure_ty);\n@@ -2903,7 +2904,7 @@ fn lval_static_fn(bcx: @block_ctxt, tpt: ty::ty_param_kinds_and_ty,\n         trans_external_path(bcx, fn_id, tpt)\n     };\n     let tys = ty::node_id_to_type_params(bcx_tcx(bcx), id);\n-    let gen = none;\n+    let gen = none, bcx = bcx;\n     if std::vec::len::<ty::t>(tys) != 0u {\n         let tydescs = [], tis = [];\n         for t in tys {\n@@ -3736,7 +3737,7 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n     // This will be needed if this is a generic call, because the callee has\n     // to cast her view of the arguments to the caller's view.\n     let arg_tys = type_of_explicit_args(ccx, cx.sp, args);\n-    let i = 0u;\n+    let i = 0u, outer_cx = outer_cx;\n     for e: @ast::expr in es {\n         let is_referenced = alt ret_style {\n           ast::return_ref(_, arg_n) { i + 1u == arg_n }\n@@ -3838,7 +3839,7 @@ fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n                              args: [@ast::expr], dest: dest) -> @block_ctxt {\n     let ccx = bcx_ccx(bcx);\n     let f_res = trans_callee(bcx, f);\n-    let llfn = f_res.val; bcx = f_res.bcx;\n+    let llfn = f_res.val, bcx = f_res.bcx;\n \n     // Translate the callee.\n     let { params: _, ty: fn_ty } = ty::expr_ty_params_and_ty(bcx_tcx(bcx), f);\n@@ -4033,6 +4034,7 @@ fn trans_landing_pad(bcx: @block_ctxt,\n fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx.fcx.lcx.ccx, id);\n+    let bcx = bcx;\n     let addr = alt dest {\n       ignore. {\n         for ex in elts { bcx = trans_expr(bcx, ex, ignore); }\n@@ -4057,6 +4059,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n              base: option::t<@ast::expr>, id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(bcx), id);\n+    let bcx = bcx;\n     let addr = alt dest {\n       ignore. {\n         for fld in fields {\n@@ -4116,6 +4119,7 @@ fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n // trans_expr_save_in. For intermediates where you don't care about lval-ness,\n // use trans_temp_expr.\n fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n+    let bcx = bcx;\n     if expr_is_lval(bcx_tcx(bcx), e) {\n         ret trans_lval(bcx, e);\n     } else {\n@@ -4429,6 +4433,7 @@ fn trans_check_expr(cx: @block_ctxt, e: @ast::expr, s: str) -> @block_ctxt {\n \n fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option::t<span>,\n                    fail_expr: option::t<@ast::expr>) -> @block_ctxt {\n+    let bcx = bcx;\n     alt fail_expr {\n       some(expr) {\n         let tcx = bcx_tcx(bcx);\n@@ -4483,7 +4488,7 @@ fn trans_fail_value(bcx: @block_ctxt, sp_opt: option::t<span>,\n fn trans_break_cont(sp: span, bcx: @block_ctxt, to_end: bool)\n     -> @block_ctxt {\n     // Locate closest loop block, outputting cleanup as we go.\n-    let cleanup_cx = bcx;\n+    let cleanup_cx = bcx, bcx = bcx;\n     while true {\n         bcx = trans_block_cleanups(bcx, cleanup_cx);\n         alt copy cleanup_cx.kind {\n@@ -4524,7 +4529,7 @@ fn trans_cont(sp: span, cx: @block_ctxt) -> @block_ctxt {\n }\n \n fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n-    let cleanup_cx = bcx;\n+    let cleanup_cx = bcx, bcx = bcx;\n     alt e {\n       some(x) {\n         if ast_util::ret_by_ref(bcx.fcx.ret_style) {\n@@ -4582,6 +4587,7 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n       }\n     };\n \n+    let bcx = bcx;\n     alt local.node.init {\n       some(init) {\n         if init.op == ast::init_assign ||\n@@ -4730,7 +4736,7 @@ fn trans_block_cleanups(bcx: @block_ctxt, cleanup_cx: @block_ctxt) ->\n     if cleanup_cx.kind == NON_SCOPE_BLOCK {\n         assert (std::vec::len::<cleanup>(cleanup_cx.cleanups) == 0u);\n     }\n-    let i = std::vec::len::<cleanup>(cleanup_cx.cleanups);\n+    let i = std::vec::len::<cleanup>(cleanup_cx.cleanups), bcx = bcx;\n     while i > 0u {\n         i -= 1u;\n         let c = cleanup_cx.cleanups[i];\n@@ -4863,6 +4869,7 @@ fn trans_block(bcx: @block_ctxt, b: ast::blk) -> @block_ctxt {\n \n fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n     -> @block_ctxt {\n+    let bcx = bcx;\n     block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n     for s: @ast::stmt in b.node.stmts {\n         bcx = trans_stmt(bcx, *s);\n@@ -4998,41 +5005,25 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: option::t<ty::t>,\n }\n \n fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n-                        arg_tys: [ty::arg], ignore_mut: bool)\n-    -> @block_ctxt {\n-    let arg_n: uint = 0u;\n+                        arg_tys: [ty::arg]) -> @block_ctxt {\n+    let arg_n: uint = 0u, bcx = bcx;\n     for arg in arg_tys {\n         let id = args[arg_n].id;\n-        let mutated = !ignore_mut && fcx.lcx.ccx.mut_map.contains_key(id);\n         let argval = alt fcx.llargs.get(id) { local_mem(v) { v } };\n         alt arg.mode {\n           ast::by_mut_ref. { }\n           ast::by_move. { add_clean(bcx, argval, arg.ty); }\n           ast::by_val. {\n-            if mutated || !ty::type_is_immediate(bcx_tcx(bcx), arg.ty) {\n+            if !ty::type_is_immediate(bcx_tcx(bcx), arg.ty) {\n                 let {bcx: cx, val: alloc} = alloc_ty(bcx, arg.ty);\n                 bcx = cx;\n                 Store(bcx, argval, alloc);\n-                if mutated {\n-                    bcx = take_ty(bcx, alloc, arg.ty);\n-                    add_clean(bcx, alloc, arg.ty);\n-                }\n                 fcx.llargs.insert(id, local_mem(alloc));\n             } else {\n                 fcx.llargs.insert(id, local_imm(argval));\n             }\n           }\n-          ast::by_ref. {\n-            // Overwrite the llargs entry for locally mutated params\n-            // with a local alloca.\n-            if mutated {\n-                let {bcx: cx, val: alloc} = alloc_ty(bcx, arg.ty);\n-                bcx = copy_val(cx, INIT, alloc,\n-                               load_if_immediate(cx, argval, arg.ty), arg.ty);\n-                fcx.llargs.insert(id, local_mem(alloc));\n-                add_clean(bcx, alloc, arg.ty);\n-            }\n-          }\n+          ast::by_ref. {}\n         }\n         arg_n += 1u;\n     }\n@@ -5129,7 +5120,7 @@ fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n     let block_ty = node_id_type(cx.ccx, f.body.node.id);\n \n     let arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n-    bcx = copy_args_to_allocas(fcx, bcx, f.decl.inputs, arg_tys, false);\n+    bcx = copy_args_to_allocas(fcx, bcx, f.decl.inputs, arg_tys);\n \n     maybe_load_env(fcx);\n \n@@ -5254,7 +5245,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     let arg_tys = arg_tys_of_fn(ccx, variant.node.id);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n-    bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys, true);\n+    bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n     // Cast the tag to a type we can GEP into.\n     let llblobptr =\n@@ -5991,7 +5982,7 @@ fn decl_crate_map(sess: session::session, mapname: str,\n     let n_subcrates = 1;\n     let cstore = sess.get_cstore();\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n-    if !sess.get_opts().library { mapname = \"toplevel\"; }\n+    let mapname = sess.get_opts().library ? mapname : \"toplevel\";\n     let sym_name = \"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n     let maptype = T_struct([int_type, arrtype]);"}, {"sha": "9990e9dbfef2c4ab05329cc84d8edc5a201073c8", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -44,7 +44,7 @@ tag opt_result {\n     range_result(result, result);\n }\n fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx_ccx(bcx), bcx = bcx;\n     alt o {\n       lit(l) {\n         alt l.node {\n@@ -249,7 +249,7 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n                         vdefs: {tg: def_id, var: def_id}, val: ValueRef) ->\n    {vals: [ValueRef], bcx: @block_ctxt} {\n-    let ccx = bcx.fcx.lcx.ccx;\n+    let ccx = bcx.fcx.lcx.ccx, bcx = bcx;\n     let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n     let blobptr = val;\n     let variants = ty::tag_variants(ccx.tcx, vdefs.tg);\n@@ -348,6 +348,7 @@ fn pick_col(m: match) -> uint {\n \n fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n                     &exits: [exit_node]) {\n+    let bcx = bcx;\n     if vec::len(m) == 0u { Br(bcx, f()); ret; }\n     if vec::len(m[0].pats) == 0u {\n         let data = m[0].data;\n@@ -543,7 +544,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n                 let le = trans::trans_compare(ge.bcx, ast::le, test_val, t,\n                                               rend.val, t);\n                 let in_range = rslt(le.bcx, And(le.bcx, ge.val, le.val));\n-                /*let*/ bcx = in_range.bcx; //XXX uncomment for assertion\n+                bcx = in_range.bcx;\n                 let cleanup_cx =\n                     trans::trans_block_cleanups(bcx, compare_cx);\n                 bcx = new_sub_block_ctxt(bcx, \"compare_next\");\n@@ -580,7 +581,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n                      ids: ast_util::pat_id_map) -> bool {\n     let our_block = bcx.llbb as uint;\n-    let success = true;\n+    let success = true, bcx = bcx;\n     ids.items {|name, node_id|\n         let llbbs = [];\n         let vals = [];\n@@ -679,7 +680,7 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n // Not alt-related, but similar to the pattern-munging code above\n fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n                         make_copy: bool) -> @block_ctxt {\n-    let ccx = bcx.fcx.lcx.ccx;\n+    let ccx = bcx.fcx.lcx.ccx, bcx = bcx;\n     alt pat.node {\n       ast::pat_bind(_) {\n         if make_copy || ccx.copy_map.contains_key(pat.id) {\n@@ -690,9 +691,8 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n             check non_ty_var(ccx, ty);\n             let llty = trans::type_of(ccx, pat.span, ty);\n             let alloc = trans::alloca(bcx, llty);\n-            bcx =\n-                trans::copy_val(bcx, trans::INIT, alloc,\n-                                trans::load_if_immediate(bcx, val, ty), ty);\n+            bcx = trans::copy_val(bcx, trans::INIT, alloc,\n+                                  trans::load_if_immediate(bcx, val, ty), ty);\n             bcx.fcx.lllocals.insert(pat.id, local_mem(alloc));\n             trans_common::add_clean(bcx, alloc, ty);\n         } else { bcx.fcx.lllocals.insert(pat.id, local_mem(val)); }"}, {"sha": "73fed9205acc60a60ec4882accd63c27128042d1", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -54,7 +54,7 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n     // Both regular arguments and type parameters are handled here.\n     create_llargs_for_fn_args(fcx, none::<ty::t>, fn_args, ty_params);\n     let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n-    bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys, true);\n+    bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n     // Pick up the type of this object by looking at our own output type, that\n     // is, the output type of the object constructor we're building.\n@@ -216,6 +216,7 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n // itself.\n fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n                   id: ast::node_id, dest: trans::dest) -> @block_ctxt {\n+    let bcx = bcx;\n     if dest == trans::ignore {\n         alt anon_obj.inner_obj {\n           some(e) { ret trans::trans_expr(bcx, e, trans::ignore); }"}, {"sha": "b63aee9ae1dba66f635ec01c6452ae92be8839fb", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -99,7 +99,7 @@ fn make_free_glue(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) ->\n \n fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n-    let ccx = bcx_ccx(bcx);\n+    let ccx = bcx_ccx(bcx), bcx = bcx;\n     if dest == trans::ignore {\n         for arg in args {\n             bcx = trans::trans_expr(bcx, arg, trans::ignore);\n@@ -150,10 +150,9 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let ccx = bcx_ccx(cx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n     let dynamic = ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty);\n-    if dynamic {\n-        lhsptr = PointerCast(cx, lhsptr, T_ptr(T_ptr(ccx.opaque_vec_type)));\n-        rhs = PointerCast(cx, rhs, T_ptr(ccx.opaque_vec_type));\n-    }\n+    let (lhsptr, rhs) = !dynamic ? (lhsptr, rhs) :\n+        (PointerCast(cx, lhsptr, T_ptr(T_ptr(ccx.opaque_vec_type))),\n+         PointerCast(cx, rhs, T_ptr(ccx.opaque_vec_type)));\n     let strings = alt ty::struct(bcx_tcx(cx), vec_ty) {\n       ty::ty_str. { true }\n       ty::ty_vec(_) { false }\n@@ -271,7 +270,7 @@ fn iter_vec_raw(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n-    vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n+    let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n     let data_ptr = get_dataptr(bcx, vptr, llunitty);\n \n     // Calculate the last pointer address we want to handle.\n@@ -302,7 +301,7 @@ fn iter_vec_raw(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n fn iter_vec(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n             f: iter_vec_block) -> @block_ctxt {\n     let ccx = bcx_ccx(bcx);\n-    vptr = PointerCast(bcx, vptr, T_ptr(ccx.opaque_vec_type));\n+    let vptr = PointerCast(bcx, vptr, T_ptr(ccx.opaque_vec_type));\n     ret iter_vec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n }\n "}, {"sha": "be79474536d37a4c33e0c55bd3543ae547533f3e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -1693,9 +1693,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                  element_ty: ty::t, body: ast::blk,\n                  node_id: ast::node_id) -> bool {\n         let locid = lookup_local(fcx, local.span, local.node.id);\n-        element_ty =\n-            demand::simple(fcx, local.span, element_ty,\n-                           ty::mk_var(fcx.ccx.tcx, locid));\n+        let element_ty = demand::simple(fcx, local.span, element_ty,\n+                                        ty::mk_var(fcx.ccx.tcx, locid));\n         let bot = check_decl_local(fcx, local);\n         check_block(fcx, body);\n         // Unify type of decl with element type of the seq"}, {"sha": "685b93941b91987c2250d1c0484296e72a7f6a35", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -158,17 +158,6 @@ fn consume_block_comment(rdr: reader) {\n     be consume_whitespace_and_comments(rdr);\n }\n \n-fn string_to_int(s: str) -> int {\n-    let negative = false;\n-    if str::char_at(s, 0u) == '-' {\n-        negative = true;\n-        s = str::substr(s, 1u, str::byte_len(s) - 1u);\n-    }\n-    let accum_int: int = 0;\n-    for c: u8 in s { accum_int *= 10; accum_int += dec_digit_val(c as char); }\n-    ret if negative { -accum_int } else { accum_int };\n-}\n-\n fn scan_exponent(rdr: reader) -> option::t<str> {\n     let c = rdr.curr();\n     let rslt = \"\";\n@@ -210,7 +199,7 @@ fn scan_dec_digits(rdr: reader) -> str {\n }\n \n fn scan_number(c: char, rdr: reader) -> token::token {\n-    let accum_int = 0;\n+    let accum_int = 0, c = c;\n     let num_str: str = \"\";\n     let n = rdr.next();\n     if c == '0' && n == 'x' {\n@@ -233,7 +222,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n         }\n     } else {\n         num_str = scan_dec_digits_with_prefix(rdr);\n-        accum_int = string_to_int(num_str);\n+        accum_int = std::int::from_str(num_str);\n     }\n     c = rdr.curr();\n     n = rdr.next();\n@@ -321,8 +310,8 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n }\n \n fn scan_numeric_escape(rdr: reader, n_hex_digits: uint) -> char {\n-    let accum_int = 0;\n-    while n_hex_digits != 0u {\n+    let accum_int = 0, i = n_hex_digits;\n+    while i != 0u {\n         let n = rdr.curr();\n         rdr.bump();\n         if !is_hex_digit(n) {\n@@ -331,7 +320,7 @@ fn scan_numeric_escape(rdr: reader, n_hex_digits: uint) -> char {\n         }\n         accum_int *= 16;\n         accum_int += hex_digit_val(n);\n-        n_hex_digits -= 1u;\n+        i -= 1u;\n     }\n     ret accum_int as char;\n }"}, {"sha": "66a3b3440e83470e1163cccf27814c887950a318", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -1038,6 +1038,7 @@ fn parse_dot_or_call_expr(p: parser) -> @ast::expr {\n fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n     let lo = e.span.lo;\n     let hi = e.span.hi;\n+    let e = e;\n     while true {\n         alt p.peek() {\n           token::LPAREN. {"}, {"sha": "d369f26f256ae27e8b2645ae5c93380f25dea9a8", "filename": "src/lib/aio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -157,7 +157,7 @@ fn iotask(c: chan<ctx>) {\n \n     log \"io task init\";\n     // Spawn our request task\n-    let reqtask = task::spawn_joinable(c, request_task);\n+    let reqtask = task::spawn_joinable(copy c, request_task);\n \n     log \"uv run task init\";\n     // Enter IO loop. This never returns until aio_stop is called."}, {"sha": "0b8a701e7aacc3e8b2b76f5eb8a9e978ac5d3b73", "filename": "src/lib/float.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffloat.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -17,18 +17,19 @@ num - The float value\n digits: The number of significant digits\n */\n fn to_str(num: float, digits: uint) -> str {\n-    let accum = if num < 0.0 { num = -num; \"-\" } else { \"\" };\n+    let (num, accum) = num < 0.0 ? (-num, \"-\") : (num, \"\");\n     let trunc = num as uint;\n     let frac = num - (trunc as float);\n     accum += uint::str(trunc);\n     if frac == 0.0 || digits == 0u { ret accum; }\n     accum += \".\";\n-    while digits > 0u && frac > 0.0 {\n+    let i = digits;\n+    while i > 0u && frac > 0.0 {\n         frac *= 10.0;\n         let digit = frac as uint;\n         accum += uint::str(digit);\n         frac -= digit as float;\n-        digits -= 1u;\n+        i -= 1u;\n     }\n     ret accum;\n }\n@@ -60,7 +61,7 @@ Returns:\n Otherwise, the floating-point number represented [num].\n */\n fn from_str(num: str) -> float {\n-   num = str::trim(num);\n+   let num = str::trim(num);\n \n    let pos = 0u;                  //Current byte position in the string.\n                                   //Used to walk the string in O(n)."}, {"sha": "65edaf75dc31229a280fc563340cf8145cddf487", "filename": "src/lib/int.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -80,7 +80,8 @@ Function: range\n Iterate over the range [`lo`..`hi`)\n */\n fn range(lo: int, hi: int, it: block(int)) {\n-    while lo < hi { it(lo); lo += 1; }\n+    let i = lo;\n+    while i < hi { it(i); i += 1; }\n }\n \n /*"}, {"sha": "c2e9b0cec69383063e856fd833a768f1183e0c29", "filename": "src/lib/io.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -132,31 +132,31 @@ obj new_reader(rdr: buf_reader) {\n     fn read_le_uint(size: uint) -> uint {\n         let val = 0u;\n         let pos = 0u;\n-        while size > 0u {\n+        let i = size;\n+        while i > 0u {\n             val += (rdr.read_byte() as uint) << pos;\n             pos += 8u;\n-            size -= 1u;\n+            i -= 1u;\n         }\n         ret val;\n     }\n     fn read_le_int(size: uint) -> int {\n-        let val = 0u;\n-        let pos = 0u;\n-        while size > 0u {\n+        let val = 0u, pos = 0u, i = size;\n+        while i > 0u {\n             val += (rdr.read_byte() as uint) << pos;\n             pos += 8u;\n-            size -= 1u;\n+            i -= 1u;\n         }\n         ret val as int;\n     }\n \n     // FIXME deal with eof?\n     fn read_be_uint(sz: uint) -> uint {\n-        let val = 0u;\n+        let val = 0u, i = sz;\n \n-        while sz > 0u {\n-            sz -= 1u;\n-            val += (rdr.read_byte() as uint) << sz * 8u;\n+        while i > 0u {\n+            i -= 1u;\n+            val += (rdr.read_byte() as uint) << i * 8u;\n         }\n         ret val;\n     }\n@@ -324,8 +324,8 @@ type writer =\n     };\n \n fn uint_to_le_bytes(n: uint, size: uint) -> [u8] {\n-    let bytes: [u8] = [];\n-    while size > 0u { bytes += [n & 255u as u8]; n >>= 8u; size -= 1u; }\n+    let bytes: [u8] = [], i = size, n = n;\n+    while i > 0u { bytes += [n & 255u as u8]; n >>= 8u; i -= 1u; }\n     ret bytes;\n }\n "}, {"sha": "ecc635d073fee55802330de79c4751039df1bef3", "filename": "src/lib/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -277,7 +277,7 @@ fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     if w == 1u { ret {ch: b0 as char, next: i + 1u}; }\n     let val = 0u;\n     let end = i + w;\n-    i += 1u;\n+    let i = i + 1u;\n     while i < end {\n         let byte = s[i];\n         assert (byte & 192u8 == tag_cont_u8);"}, {"sha": "94c9fbca4e4ce5fcd3fad9fd414c661fa0c7160f", "filename": "src/lib/term.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -76,6 +76,7 @@ fn color_supported() -> bool {\n fn set_color(writer: io::buf_writer, first_char: u8, color: u8) {\n     assert (color < 16u8);\n     esc(writer);\n+    let color = color;\n     if color >= 8u8 { writer.write(['1' as u8, ';' as u8]); color -= 8u8; }\n     writer.write([first_char, ('0' as u8) + color, 'm' as u8]);\n }"}, {"sha": "649aa338d301dd6f8b68261f8894e2172507f201", "filename": "src/lib/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -334,7 +334,7 @@ fn default_test_to_task(&&f: default_test_fn) -> joinable {\n         configure_test_task();\n         f();\n     }\n-    ret task::spawn_joinable(f, run_task);\n+    ret task::spawn_joinable(copy f, run_task);\n }\n \n // Call from within a test task to make sure it's set up correctly"}, {"sha": "3109e5dc50ffeae4189578d11f65f14732e180a7", "filename": "src/lib/u64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fu64.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -52,6 +52,7 @@ fn to_str(n: u64, radix: uint) -> str {\n \n     let s = \"\";\n \n+    let n = n;\n     while n > 0u64 { s = digit(n % r64) + s; n /= r64; }\n     ret s;\n }"}, {"sha": "c2f7aba7ce70dd1a341fa4b93edf17e12c5f6360", "filename": "src/lib/u8.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fu8.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -55,7 +55,8 @@ Function: range\n Iterate over the range [`lo`..`hi`)\n */\n fn range(lo: u8, hi: u8, it: block(u8)) {\n-    while lo < hi { it(lo); lo += 1u8; }\n+    let i = lo;\n+    while i < hi { it(i); i += 1u8; }\n }\n \n // Local Variables:"}, {"sha": "a9ea4d03c9097263756f7a331966ed23895dc312", "filename": "src/lib/uint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -61,7 +61,8 @@ Function: range\n Iterate over the range [`lo`..`hi`)\n */\n fn range(lo: uint, hi: uint, it: block(uint)) {\n-    while lo < hi { it(lo); lo += 1u; }\n+    let i = lo;\n+    while i < hi { it(i); i += 1u; }\n }\n \n /*"}, {"sha": "8a3339a065c0dd05158711ff7ce9b9c626f037be", "filename": "src/test/run-pass/issue-507.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fissue-507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fissue-507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-507.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -18,7 +18,7 @@ import std::comm::recv;\n fn grandchild(c: chan<int>) { send(c, 42); }\n \n fn child(c: chan<int>) {\n-    let _grandchild = task::spawn_joinable(c, grandchild);\n+    let _grandchild = task::spawn_joinable(copy c, grandchild);\n     join(_grandchild);\n }\n "}, {"sha": "27fedd2222f36f70315d27ad7db40e9c9f580ba1", "filename": "src/test/run-pass/move-4-unique.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fmove-4-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fmove-4-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-4-unique.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -2,6 +2,7 @@ use std;\n import std::uint;\n \n fn test(foo: ~{a: int, b: int, c: int}) -> ~{a: int, b: int, c: int} {\n+    let foo = foo;\n     let bar <- foo;\n     let baz <- bar;\n     let quux <- baz;"}, {"sha": "76a4fa009243425468873087d3312746185a823d", "filename": "src/test/run-pass/move-4.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fmove-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fmove-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-4.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -3,6 +3,7 @@ use std;\n import std::uint;\n \n fn test(foo: @{a: int, b: int, c: int}) -> @{a: int, b: int, c: int} {\n+    let foo = foo;\n     let bar <- foo;\n     let baz <- bar;\n     let quux <- baz;"}, {"sha": "f08897a2fa3aa63af485071b87e2c6cf860f9520", "filename": "src/test/run-pass/obj-docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fobj-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fobj-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-docs.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -41,7 +41,7 @@ fn main() {\n     }\n \n     obj sender(c: chan<int>) {\n-        fn take(z: int) { send(c, z); }\n+        fn take(z: int) { send(c, copy z); }\n     }\n \n     fn give_ints(t: taker) { t.take(1); t.take(2); t.take(3); }"}, {"sha": "d0c450aaeba10693cb3dc11919b2f0a2d09a2829", "filename": "src/test/run-pass/obj-self-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fobj-self-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fobj-self-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-self-2.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -2,8 +2,8 @@\n \n fn main() {\n     obj foo() {\n-        fn m1(i: int) { i += 1; log \"hi!\"; }\n-        fn m2(i: int) { i += 1; self.m1(i); }\n+        fn m1(i: int) { let i = i + 1; log \"hi!\"; }\n+        fn m2(i: int) { let i = i + 1; self.m1(i); }\n     }\n     let a = foo();\n     let i: int = 0;"}, {"sha": "16aa3a609711fcc5bf6184d73ca48f20db559394", "filename": "src/test/run-pass/obj-self-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fobj-self-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a68a98824cab9122bb39920d09415ff34a3944e/src%2Ftest%2Frun-pass%2Fobj-self-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-self-3.rs?ref=1a68a98824cab9122bb39920d09415ff34a3944e", "patch": "@@ -2,9 +2,9 @@\n \n fn main() {\n     obj foo() {\n-        fn m1(i: int) -> int { i += 1; ret i; }\n+        fn m1(i: int) -> int { let i = i + 1; ret i; }\n         fn m2(i: int) -> int { ret self.m1(i); }\n-        fn m3(i: int) -> int { i += 1; ret self.m1(i); }\n+        fn m3(i: int) -> int { let i = i + 1; ret self.m1(i); }\n     }\n     let a = foo();\n     let i: int = 0;"}]}