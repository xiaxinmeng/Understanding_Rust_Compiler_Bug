{"sha": "bc552fc417a8a8c5d75b4a613390f64f48929dca", "node_id": "C_kwDOAAsO6NoAKGJjNTUyZmM0MTdhOGE4YzVkNzViNGE2MTMzOTBmNjRmNDg5MjlkY2E", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-10-28T14:12:24Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-10-28T14:12:24Z"}, "message": "Move instantiate_opaque_types to rustc_infer.\n\nIt does not depend on anything from rustc_trait_selection anymore.", "tree": {"sha": "889c7e324b2b8a626b8a7950aae17f70bca7ec19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/889c7e324b2b8a626b8a7950aae17f70bca7ec19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc552fc417a8a8c5d75b4a613390f64f48929dca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc552fc417a8a8c5d75b4a613390f64f48929dca", "html_url": "https://github.com/rust-lang/rust/commit/bc552fc417a8a8c5d75b4a613390f64f48929dca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc552fc417a8a8c5d75b4a613390f64f48929dca/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8f06b249bda659c8a271d3581aca36a31761923", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f06b249bda659c8a271d3581aca36a31761923", "html_url": "https://github.com/rust-lang/rust/commit/a8f06b249bda659c8a271d3581aca36a31761923"}], "stats": {"total": 577, "additions": 283, "deletions": 294}, "files": [{"sha": "7e6a481ca69a1b76f62008c1282b3ea676662ac0", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=bc552fc417a8a8c5d75b4a613390f64f48929dca", "patch": "@@ -36,7 +36,6 @@ use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::opaque_types::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;"}, {"sha": "e2e07f2072e498ea907e7fb176ed0ff9e9d811f2", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 278, "deletions": 2, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=bc552fc417a8a8c5d75b4a613390f64f48929dca", "patch": "@@ -1,8 +1,12 @@\n-use crate::infer::InferCtxt;\n+use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::{InferCtxt, InferOk};\n+use crate::traits;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n-use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::ty::fold::BottomUpFolder;\n+use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n \n@@ -52,6 +56,49 @@ pub struct OpaqueTypeDecl<'tcx> {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    /// Replaces all opaque types in `value` with fresh inference variables\n+    /// and creates appropriate obligations. For example, given the input:\n+    ///\n+    ///     impl Iterator<Item = impl Debug>\n+    ///\n+    /// this method would create two type variables, `?0` and `?1`. It would\n+    /// return the type `?0` but also the obligations:\n+    ///\n+    ///     ?0: Iterator<Item = ?1>\n+    ///     ?1: Debug\n+    ///\n+    /// Moreover, it returns an `OpaqueTypeMap` that would map `?0` to\n+    /// info about the `impl Iterator<..>` type and `?1` to info about\n+    /// the `impl Debug` type.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `parent_def_id` -- the `DefId` of the function in which the opaque type\n+    ///   is defined\n+    /// - `body_id` -- the body-id with which the resulting obligations should\n+    ///   be associated\n+    /// - `param_env` -- the in-scope parameter environment to be used for\n+    ///   obligations\n+    /// - `value` -- the value within which we are instantiating opaque types\n+    /// - `value_span` -- the span where the value came from, used in error reporting\n+    pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n+        &self,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: T,\n+        value_span: Span,\n+    ) -> InferOk<'tcx, T> {\n+        debug!(\n+            \"instantiate_opaque_types(value={:?}, body_id={:?}, \\\n+             param_env={:?}, value_span={:?})\",\n+            value, body_id, param_env, value_span,\n+        );\n+        let mut instantiator =\n+            Instantiator { infcx: self, body_id, param_env, value_span, obligations: vec![] };\n+        let value = instantiator.instantiate_opaque_types_in_map(value);\n+        InferOk { value, obligations: instantiator.obligations }\n+    }\n+\n     /// Given the map `opaque_types` containing the opaque\n     /// `impl Trait` types whose underlying, hidden types are being\n     /// inferred, this method adds constraints to the regions\n@@ -359,3 +406,232 @@ where\n         ControlFlow::CONTINUE\n     }\n }\n+\n+struct Instantiator<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    body_id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    value_span: Span,\n+    obligations: Vec<traits::PredicateObligation<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n+    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n+        let tcx = self.infcx.tcx;\n+        value.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            ty_op: |ty| {\n+                if ty.references_error() {\n+                    return tcx.ty_error();\n+                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n+                    // Check that this is `impl Trait` type is\n+                    // declared by `parent_def_id` -- i.e., one whose\n+                    // value we are inferring.  At present, this is\n+                    // always true during the first phase of\n+                    // type-check, but not always true later on during\n+                    // NLL. Once we support named opaque types more fully,\n+                    // this same scenario will be able to arise during all phases.\n+                    //\n+                    // Here is an example using type alias `impl Trait`\n+                    // that indicates the distinction we are checking for:\n+                    //\n+                    // ```rust\n+                    // mod a {\n+                    //   pub type Foo = impl Iterator;\n+                    //   pub fn make_foo() -> Foo { .. }\n+                    // }\n+                    //\n+                    // mod b {\n+                    //   fn foo() -> a::Foo { a::make_foo() }\n+                    // }\n+                    // ```\n+                    //\n+                    // Here, the return type of `foo` references an\n+                    // `Opaque` indeed, but not one whose value is\n+                    // presently being inferred. You can get into a\n+                    // similar situation with closure return types\n+                    // today:\n+                    //\n+                    // ```rust\n+                    // fn foo() -> impl Iterator { .. }\n+                    // fn bar() {\n+                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                    // }\n+                    // ```\n+                    if let Some(def_id) = def_id.as_local() {\n+                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+                        let parent_def_id = self.infcx.defining_use_anchor;\n+                        let def_scope_default = || {\n+                            let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n+                            parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n+                        };\n+                        let (in_definition_scope, origin) =\n+                            match tcx.hir().expect_item(opaque_hir_id).kind {\n+                                // Anonymous `impl Trait`\n+                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                                    impl_trait_fn: Some(parent),\n+                                    origin,\n+                                    ..\n+                                }) => (parent == parent_def_id.to_def_id(), origin),\n+                                // Named `type Foo = impl Bar;`\n+                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                                    impl_trait_fn: None,\n+                                    origin,\n+                                    ..\n+                                }) => (\n+                                    may_define_opaque_type(tcx, parent_def_id, opaque_hir_id),\n+                                    origin,\n+                                ),\n+                                _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n+                            };\n+                        if in_definition_scope {\n+                            let opaque_type_key =\n+                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n+                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n+                        }\n+\n+                        debug!(\n+                            \"instantiate_opaque_types_in_map: \\\n+                             encountered opaque outside its definition scope \\\n+                             def_id={:?}\",\n+                            def_id,\n+                        );\n+                    }\n+                }\n+\n+                ty\n+            },\n+            lt_op: |lt| lt,\n+            ct_op: |ct| ct,\n+        })\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn fold_opaque_ty(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        origin: hir::OpaqueTyOrigin,\n+    ) -> Ty<'tcx> {\n+        let infcx = self.infcx;\n+        let tcx = infcx.tcx;\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n+        // Use the same type variable if the exact same opaque type appears more\n+        // than once in the return type (e.g., if it's passed to a type alias).\n+        if let Some(opaque_defn) = infcx.inner.borrow().opaque_types.get(&opaque_type_key) {\n+            debug!(\"re-using cached concrete type {:?}\", opaque_defn.concrete_ty.kind());\n+            return opaque_defn.concrete_ty;\n+        }\n+\n+        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::TypeInference,\n+            span: self.value_span,\n+        });\n+\n+        // Ideally, we'd get the span where *this specific `ty` came\n+        // from*, but right now we just use the span from the overall\n+        // value being folded. In simple cases like `-> impl Foo`,\n+        // these are the same span, but not in cases like `-> (impl\n+        // Foo, impl Bar)`.\n+        let definition_span = self.value_span;\n+\n+        {\n+            let mut infcx = self.infcx.inner.borrow_mut();\n+            infcx.opaque_types.insert(\n+                OpaqueTypeKey { def_id, substs },\n+                OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n+            );\n+            infcx.opaque_types_vars.insert(ty_var, ty);\n+        }\n+\n+        debug!(\"generated new type inference var {:?}\", ty_var.kind());\n+\n+        let item_bounds = tcx.explicit_item_bounds(def_id);\n+\n+        self.obligations.reserve(item_bounds.len());\n+        for (predicate, _) in item_bounds {\n+            debug!(?predicate);\n+            let predicate = predicate.subst(tcx, substs);\n+            debug!(?predicate);\n+\n+            // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n+            let predicate = predicate.fold_with(&mut BottomUpFolder {\n+                tcx,\n+                ty_op: |ty| match ty.kind() {\n+                    ty::Projection(projection_ty) => infcx.infer_projection(\n+                        self.param_env,\n+                        *projection_ty,\n+                        traits::ObligationCause::misc(self.value_span, self.body_id),\n+                        0,\n+                        &mut self.obligations,\n+                    ),\n+                    _ => ty,\n+                },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            });\n+            debug!(?predicate);\n+\n+            if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n+                if projection.ty.references_error() {\n+                    // No point on adding these obligations since there's a type error involved.\n+                    return tcx.ty_error();\n+                }\n+            }\n+            // Change the predicate to refer to the type variable,\n+            // which will be the concrete type instead of the opaque type.\n+            // This also instantiates nested instances of `impl Trait`.\n+            let predicate = self.instantiate_opaque_types_in_map(predicate);\n+\n+            let cause =\n+                traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);\n+\n+            // Require that the predicate holds for the concrete type.\n+            debug!(?predicate);\n+            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n+        }\n+\n+        ty_var\n+    }\n+}\n+\n+/// Returns `true` if `opaque_hir_id` is a sibling or a child of a sibling of `def_id`.\n+///\n+/// Example:\n+/// ```rust\n+/// pub mod foo {\n+///     pub mod bar {\n+///         pub trait Bar { .. }\n+///\n+///         pub type Baz = impl Bar;\n+///\n+///         fn f1() -> Baz { .. }\n+///     }\n+///\n+///     fn f2() -> bar::Baz { .. }\n+/// }\n+/// ```\n+///\n+/// Here, `def_id` is the `LocalDefId` of the defining use of the opaque type (e.g., `f1` or `f2`),\n+/// and `opaque_hir_id` is the `HirId` of the definition of the opaque type `Baz`.\n+/// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n+fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: LocalDefId, opaque_hir_id: hir::HirId) -> bool {\n+    let mut hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+\n+    // Named opaque types can be defined by any siblings or children of siblings.\n+    let scope = tcx.hir().get_defining_scope(opaque_hir_id);\n+    // We walk up the node tree until we hit the root or the scope of the opaque type.\n+    while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n+        hir_id = tcx.hir().get_parent_item(hir_id);\n+    }\n+    // Syntactically, we are allowed to define the concrete type if:\n+    let res = hir_id == scope;\n+    trace!(\n+        \"may_define_opaque_type(def={:?}, opaque_node={:?}) = {}\",\n+        tcx.hir().find(hir_id),\n+        tcx.hir().get(opaque_hir_id),\n+        res\n+    );\n+    res\n+}"}, {"sha": "75d57d78e3b0294be8d2138590248c775ddb6048", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 5, "deletions": 288, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=bc552fc417a8a8c5d75b4a613390f64f48929dca", "patch": "@@ -1,25 +1,14 @@\n-use crate::traits::{self, ObligationCause, PredicateObligation};\n+use crate::traits;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n-use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferCtxt, InferOk};\n-use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n+use rustc_infer::infer::InferCtxt;\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::Span;\n \n pub trait InferCtxtExt<'tcx> {\n-    fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n-        &self,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n-        value_span: Span,\n-    ) -> InferOk<'tcx, T>;\n-\n     fn infer_opaque_definition_from_instantiation(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n@@ -29,49 +18,6 @@ pub trait InferCtxtExt<'tcx> {\n }\n \n impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n-    /// Replaces all opaque types in `value` with fresh inference variables\n-    /// and creates appropriate obligations. For example, given the input:\n-    ///\n-    ///     impl Iterator<Item = impl Debug>\n-    ///\n-    /// this method would create two type variables, `?0` and `?1`. It would\n-    /// return the type `?0` but also the obligations:\n-    ///\n-    ///     ?0: Iterator<Item = ?1>\n-    ///     ?1: Debug\n-    ///\n-    /// Moreover, it returns an `OpaqueTypeMap` that would map `?0` to\n-    /// info about the `impl Iterator<..>` type and `?1` to info about\n-    /// the `impl Debug` type.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `parent_def_id` -- the `DefId` of the function in which the opaque type\n-    ///   is defined\n-    /// - `body_id` -- the body-id with which the resulting obligations should\n-    ///   be associated\n-    /// - `param_env` -- the in-scope parameter environment to be used for\n-    ///   obligations\n-    /// - `value` -- the value within which we are instantiating opaque types\n-    /// - `value_span` -- the span where the value came from, used in error reporting\n-    fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n-        &self,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n-        value_span: Span,\n-    ) -> InferOk<'tcx, T> {\n-        debug!(\n-            \"instantiate_opaque_types(value={:?}, body_id={:?}, \\\n-             param_env={:?}, value_span={:?})\",\n-            value, body_id, param_env, value_span,\n-        );\n-        let mut instantiator =\n-            Instantiator { infcx: self, body_id, param_env, value_span, obligations: vec![] };\n-        let value = instantiator.instantiate_opaque_types_in_map(value);\n-        InferOk { value, obligations: instantiator.obligations }\n-    }\n-\n     /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n     /// (*), computes the \"definition type\" for an opaque type\n@@ -375,235 +321,6 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n     }\n }\n \n-struct Instantiator<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    body_id: hir::HirId,\n-    param_env: ty::ParamEnv<'tcx>,\n-    value_span: Span,\n-    obligations: Vec<PredicateObligation<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n-    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n-        let tcx = self.infcx.tcx;\n-        value.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            ty_op: |ty| {\n-                if ty.references_error() {\n-                    return tcx.ty_error();\n-                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n-                    // Check that this is `impl Trait` type is\n-                    // declared by `parent_def_id` -- i.e., one whose\n-                    // value we are inferring.  At present, this is\n-                    // always true during the first phase of\n-                    // type-check, but not always true later on during\n-                    // NLL. Once we support named opaque types more fully,\n-                    // this same scenario will be able to arise during all phases.\n-                    //\n-                    // Here is an example using type alias `impl Trait`\n-                    // that indicates the distinction we are checking for:\n-                    //\n-                    // ```rust\n-                    // mod a {\n-                    //   pub type Foo = impl Iterator;\n-                    //   pub fn make_foo() -> Foo { .. }\n-                    // }\n-                    //\n-                    // mod b {\n-                    //   fn foo() -> a::Foo { a::make_foo() }\n-                    // }\n-                    // ```\n-                    //\n-                    // Here, the return type of `foo` references an\n-                    // `Opaque` indeed, but not one whose value is\n-                    // presently being inferred. You can get into a\n-                    // similar situation with closure return types\n-                    // today:\n-                    //\n-                    // ```rust\n-                    // fn foo() -> impl Iterator { .. }\n-                    // fn bar() {\n-                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                    // }\n-                    // ```\n-                    if let Some(def_id) = def_id.as_local() {\n-                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let parent_def_id = self.infcx.defining_use_anchor;\n-                        let def_scope_default = || {\n-                            let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n-                        };\n-                        let (in_definition_scope, origin) =\n-                            match tcx.hir().expect_item(opaque_hir_id).kind {\n-                                // Anonymous `impl Trait`\n-                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                    impl_trait_fn: Some(parent),\n-                                    origin,\n-                                    ..\n-                                }) => (parent == parent_def_id.to_def_id(), origin),\n-                                // Named `type Foo = impl Bar;`\n-                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                    impl_trait_fn: None,\n-                                    origin,\n-                                    ..\n-                                }) => (\n-                                    may_define_opaque_type(tcx, parent_def_id, opaque_hir_id),\n-                                    origin,\n-                                ),\n-                                _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n-                            };\n-                        if in_definition_scope {\n-                            let opaque_type_key =\n-                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n-                        }\n-\n-                        debug!(\n-                            \"instantiate_opaque_types_in_map: \\\n-                             encountered opaque outside its definition scope \\\n-                             def_id={:?}\",\n-                            def_id,\n-                        );\n-                    }\n-                }\n-\n-                ty\n-            },\n-            lt_op: |lt| lt,\n-            ct_op: |ct| ct,\n-        })\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn fold_opaque_ty(\n-        &mut self,\n-        ty: Ty<'tcx>,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        origin: hir::OpaqueTyOrigin,\n-    ) -> Ty<'tcx> {\n-        let infcx = self.infcx;\n-        let tcx = infcx.tcx;\n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n-        // Use the same type variable if the exact same opaque type appears more\n-        // than once in the return type (e.g., if it's passed to a type alias).\n-        if let Some(opaque_defn) = infcx.inner.borrow().opaque_types.get(&opaque_type_key) {\n-            debug!(\"re-using cached concrete type {:?}\", opaque_defn.concrete_ty.kind());\n-            return opaque_defn.concrete_ty;\n-        }\n-\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::TypeInference,\n-            span: self.value_span,\n-        });\n-\n-        // Ideally, we'd get the span where *this specific `ty` came\n-        // from*, but right now we just use the span from the overall\n-        // value being folded. In simple cases like `-> impl Foo`,\n-        // these are the same span, but not in cases like `-> (impl\n-        // Foo, impl Bar)`.\n-        let definition_span = self.value_span;\n-\n-        {\n-            let mut infcx = self.infcx.inner.borrow_mut();\n-            infcx.opaque_types.insert(\n-                OpaqueTypeKey { def_id, substs },\n-                OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n-            );\n-            infcx.opaque_types_vars.insert(ty_var, ty);\n-        }\n-\n-        debug!(\"generated new type inference var {:?}\", ty_var.kind());\n-\n-        let item_bounds = tcx.explicit_item_bounds(def_id);\n-\n-        self.obligations.reserve(item_bounds.len());\n-        for (predicate, _) in item_bounds {\n-            debug!(?predicate);\n-            let predicate = predicate.subst(tcx, substs);\n-            debug!(?predicate);\n-\n-            // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n-            let predicate = predicate.fold_with(&mut BottomUpFolder {\n-                tcx,\n-                ty_op: |ty| match ty.kind() {\n-                    ty::Projection(projection_ty) => infcx.infer_projection(\n-                        self.param_env,\n-                        *projection_ty,\n-                        ObligationCause::misc(self.value_span, self.body_id),\n-                        0,\n-                        &mut self.obligations,\n-                    ),\n-                    _ => ty,\n-                },\n-                lt_op: |lt| lt,\n-                ct_op: |ct| ct,\n-            });\n-            debug!(?predicate);\n-\n-            if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n-                if projection.ty.references_error() {\n-                    // No point on adding these obligations since there's a type error involved.\n-                    return tcx.ty_error();\n-                }\n-            }\n-            // Change the predicate to refer to the type variable,\n-            // which will be the concrete type instead of the opaque type.\n-            // This also instantiates nested instances of `impl Trait`.\n-            let predicate = self.instantiate_opaque_types_in_map(predicate);\n-\n-            let cause =\n-                traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);\n-\n-            // Require that the predicate holds for the concrete type.\n-            debug!(?predicate);\n-            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n-        }\n-\n-        ty_var\n-    }\n-}\n-\n-/// Returns `true` if `opaque_hir_id` is a sibling or a child of a sibling of `def_id`.\n-///\n-/// Example:\n-/// ```rust\n-/// pub mod foo {\n-///     pub mod bar {\n-///         pub trait Bar { .. }\n-///\n-///         pub type Baz = impl Bar;\n-///\n-///         fn f1() -> Baz { .. }\n-///     }\n-///\n-///     fn f2() -> bar::Baz { .. }\n-/// }\n-/// ```\n-///\n-/// Here, `def_id` is the `LocalDefId` of the defining use of the opaque type (e.g., `f1` or `f2`),\n-/// and `opaque_hir_id` is the `HirId` of the definition of the opaque type `Baz`.\n-/// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n-fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: LocalDefId, opaque_hir_id: hir::HirId) -> bool {\n-    let mut hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-    // Named opaque types can be defined by any siblings or children of siblings.\n-    let scope = tcx.hir().get_defining_scope(opaque_hir_id);\n-    // We walk up the node tree until we hit the root or the scope of the opaque type.\n-    while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n-        hir_id = tcx.hir().get_parent_item(hir_id);\n-    }\n-    // Syntactically, we are allowed to define the concrete type if:\n-    let res = hir_id == scope;\n-    trace!(\n-        \"may_define_opaque_type(def={:?}, opaque_node={:?}) = {}\",\n-        tcx.hir().find(hir_id),\n-        tcx.hir().get(opaque_hir_id),\n-        res\n-    );\n-    res\n-}\n-\n /// Given a set of predicates that apply to an object type, returns\n /// the region bounds that the (erased) `Self` type must\n /// outlive. Precisely *because* the `Self` type is erased, the"}, {"sha": "a8160313228b6381b02f6e1633fce45ae07e639b", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=bc552fc417a8a8c5d75b4a613390f64f48929dca", "patch": "@@ -6,7 +6,6 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::traits::Obligation;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyS};\n use rustc_span::{MultiSpan, Span};\n-use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,"}, {"sha": "5040c4db95163a48473aace18608b6d7a7d55623", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=bc552fc417a8a8c5d75b4a613390f64f48929dca", "patch": "@@ -21,7 +21,6 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_ty_utils::representability::{self, Representability};"}, {"sha": "5179b425f88e2eb54c45d496f9cd0ff8e92846d5", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc552fc417a8a8c5d75b4a613390f64f48929dca/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=bc552fc417a8a8c5d75b4a613390f64f48929dca", "patch": "@@ -35,7 +35,6 @@ use rustc_span::source_map::{original_sp, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{self, BytePos, MultiSpan, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,"}]}