{"sha": "62374ee4ad00a4cc8a4807ed13823a49e2e8422d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMzc0ZWU0YWQwMGE0Y2M4YTQ4MDdlZDEzODIzYTQ5ZTJlODQyMmQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-09T01:10:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-09T01:10:01Z"}, "message": "Rollup merge of #70834 - yoshuawuyts:future-pending-ready, r=sfackler\n\nAdd core::future::{pending,ready}\n\nAdds two future constructors to `core`: `future::ready` and `future::pending`. These functions enable constructing futures of any type that either immediately resolve, or never resolve which is an incredible useful tool when writing documentation.\n\nThese functions have prior art in both the `futures` and `async-std` crates. This implementation has been adapted from the `futures` crate.\n\n## Examples\n\nIn https://github.com/rust-lang/rust/pull/70817 we propose adding the `ready!` macro. In the example we use an `async fn` which does not return a future that implements `Unpin`, which leads to the use of `unsafe`. Instead had we had `future::ready` available, we could've written the same example without using `unsafe`:\n\n```rust\nuse core::task::{Context, Poll};\nuse core::future::{self, Future};\nuse core::pin::Pin;\n\npub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n    let mut fut = future::ready(42_u8);\n    let num = ready!(Pin::new(fut).poll(cx));\n    // ... use num\n\n    Poll::Ready(())\n}\n```\n\n## Why future::ready?\n\nArguably `future::ready` and `async {}` can be considered equivalent. The main differences are that `future::ready` returns a future that implements `Unpin`, and the returned future is a concrete type. This is useful for traits that require a future as an associated type that can sometimes be a no-op ([example](https://docs.rs/http-service/0.4.0/http_service/trait.HttpService.html#associatedtype.ConnectionFuture)).\n\nThe final, minor argument is that `future::ready` and `future::pending` form a counterpart to the enum members of `Poll`: `Ready` and `Pending`. These functions form a conceptual bridge between `Poll` and `Future`, and can be used as a useful teaching device.\n\n## References\n- [`futures::future::ready`](https://docs.rs/futures/0.3.4/futures/future/fn.ready.html)\n- [`futures::future::pending`](https://docs.rs/futures/0.3.4/futures/future/fn.pending.html)\n- [`async_std::future::pending`](https://docs.rs/async-std/1.5.0/async_std/future/fn.pending.html)\n- [`async_std::future::ready`](https://docs.rs/async-std/1.5.0/async_std/future/fn.ready.html)", "tree": {"sha": "7f01d456117042d0970296ce9705acce68fd1667", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f01d456117042d0970296ce9705acce68fd1667"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62374ee4ad00a4cc8a4807ed13823a49e2e8422d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetgLrCRBK7hj4Ov3rIwAAdHIIAKBA8MOuxw9+jBcPYhhd27Ql\n9ahllh5Bibcri9zy5BXCQ8/dc6NiIbTK5Cp54LEnetKl95kCvhXJf6ILLww2Q9jQ\nPr6mWUvbMxzN7DlI91H2xR6k1LHoOAEa9WZ1cuum64wyC0f7IKE1r8rCpHCgeWDk\nOMhsdZREX11saZG0a2FqY1wI+lTcmJBSR2V1sgZDlPlAU0ICWXFEql/saGIRSf9E\ngBXTWCWXyasZUWNkPMQ1+eqMzqnzsrNhO1AIAPD7jtDl0/DWoJbIrvzU4eqaoPcp\neylrj7YEGrGM8uHqNC+SIBMkfeBYVYF1dDPiz+3DlP/TWw9JcFLKArLuhPjUAAI=\n=ycLb\n-----END PGP SIGNATURE-----\n", "payload": "tree 7f01d456117042d0970296ce9705acce68fd1667\nparent 7ebd87a7a1e0e21767422e115c9455ef6e6d4bee\nparent 029515d9164bddc0928c159d375aadfc7f256b28\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588986601 +0200\ncommitter GitHub <noreply@github.com> 1588986601 +0200\n\nRollup merge of #70834 - yoshuawuyts:future-pending-ready, r=sfackler\n\nAdd core::future::{pending,ready}\n\nAdds two future constructors to `core`: `future::ready` and `future::pending`. These functions enable constructing futures of any type that either immediately resolve, or never resolve which is an incredible useful tool when writing documentation.\n\nThese functions have prior art in both the `futures` and `async-std` crates. This implementation has been adapted from the `futures` crate.\n\n## Examples\n\nIn https://github.com/rust-lang/rust/pull/70817 we propose adding the `ready!` macro. In the example we use an `async fn` which does not return a future that implements `Unpin`, which leads to the use of `unsafe`. Instead had we had `future::ready` available, we could've written the same example without using `unsafe`:\n\n```rust\nuse core::task::{Context, Poll};\nuse core::future::{self, Future};\nuse core::pin::Pin;\n\npub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n    let mut fut = future::ready(42_u8);\n    let num = ready!(Pin::new(fut).poll(cx));\n    // ... use num\n\n    Poll::Ready(())\n}\n```\n\n## Why future::ready?\n\nArguably `future::ready` and `async {}` can be considered equivalent. The main differences are that `future::ready` returns a future that implements `Unpin`, and the returned future is a concrete type. This is useful for traits that require a future as an associated type that can sometimes be a no-op ([example](https://docs.rs/http-service/0.4.0/http_service/trait.HttpService.html#associatedtype.ConnectionFuture)).\n\nThe final, minor argument is that `future::ready` and `future::pending` form a counterpart to the enum members of `Poll`: `Ready` and `Pending`. These functions form a conceptual bridge between `Poll` and `Future`, and can be used as a useful teaching device.\n\n## References\n- [`futures::future::ready`](https://docs.rs/futures/0.3.4/futures/future/fn.ready.html)\n- [`futures::future::pending`](https://docs.rs/futures/0.3.4/futures/future/fn.pending.html)\n- [`async_std::future::pending`](https://docs.rs/async-std/1.5.0/async_std/future/fn.pending.html)\n- [`async_std::future::ready`](https://docs.rs/async-std/1.5.0/async_std/future/fn.ready.html)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62374ee4ad00a4cc8a4807ed13823a49e2e8422d", "html_url": "https://github.com/rust-lang/rust/commit/62374ee4ad00a4cc8a4807ed13823a49e2e8422d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62374ee4ad00a4cc8a4807ed13823a49e2e8422d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "html_url": "https://github.com/rust-lang/rust/commit/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee"}, {"sha": "029515d9164bddc0928c159d375aadfc7f256b28", "url": "https://api.github.com/repos/rust-lang/rust/commits/029515d9164bddc0928c159d375aadfc7f256b28", "html_url": "https://github.com/rust-lang/rust/commit/029515d9164bddc0928c159d375aadfc7f256b28"}], "stats": {"total": 110, "additions": 110, "deletions": 0}, "files": [{"sha": "b5a102916a07ebc970bb47f3264d4567d399c0ba", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62374ee4ad00a4cc8a4807ed13823a49e2e8422d/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62374ee4ad00a4cc8a4807ed13823a49e2e8422d/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=62374ee4ad00a4cc8a4807ed13823a49e2e8422d", "patch": "@@ -10,9 +10,17 @@ use crate::{\n };\n \n mod future;\n+mod pending;\n+mod ready;\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::future::Future;\n \n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+pub use pending::{pending, Pending};\n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+pub use ready::{ready, Ready};\n+\n /// This type is needed because:\n ///\n /// a) Generators cannot implement `for<'a, 'b> Generator<&'a mut Context<'b>>`, so we need to pass"}, {"sha": "74887b68aa0fadf95eaa9b7504f2ffdd3ae51c5c", "filename": "src/libcore/future/pending.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/62374ee4ad00a4cc8a4807ed13823a49e2e8422d/src%2Flibcore%2Ffuture%2Fpending.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62374ee4ad00a4cc8a4807ed13823a49e2e8422d/src%2Flibcore%2Ffuture%2Fpending.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fpending.rs?ref=62374ee4ad00a4cc8a4807ed13823a49e2e8422d", "patch": "@@ -0,0 +1,57 @@\n+use crate::future::Future;\n+use crate::marker;\n+use crate::pin::Pin;\n+use crate::task::{Context, Poll};\n+\n+/// Creates a future which never resolves, representing a computation that never\n+/// finishes.\n+///\n+/// This `struct` is created by the [`pending`] function. See its\n+/// documentation for more.\n+///\n+/// [`pending`]: fn.pending.html\n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+#[derive(Debug)]\n+#[must_use = \"futures do nothing unless you `.await` or poll them\"]\n+pub struct Pending<T> {\n+    _data: marker::PhantomData<T>,\n+}\n+\n+/// Creates a future which never resolves, representing a computation that never\n+/// finishes.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// #![feature(future_readiness_fns)]\n+/// use core::future;\n+///\n+/// # async fn run() {\n+/// let future = future::pending();\n+/// let () = future.await;\n+/// unreachable!();\n+/// # }\n+/// ```\n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+pub fn pending<T>() -> Pending<T> {\n+    Pending { _data: marker::PhantomData }\n+}\n+\n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+impl<T> Future for Pending<T> {\n+    type Output = T;\n+\n+    fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<T> {\n+        Poll::Pending\n+    }\n+}\n+\n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+impl<T> Unpin for Pending<T> {}\n+\n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+impl<T> Clone for Pending<T> {\n+    fn clone(&self) -> Self {\n+        pending()\n+    }\n+}"}, {"sha": "31b39d7fb6cd5c8f7b0096c83855e9b6e0c695d0", "filename": "src/libcore/future/ready.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/62374ee4ad00a4cc8a4807ed13823a49e2e8422d/src%2Flibcore%2Ffuture%2Fready.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62374ee4ad00a4cc8a4807ed13823a49e2e8422d/src%2Flibcore%2Ffuture%2Fready.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fready.rs?ref=62374ee4ad00a4cc8a4807ed13823a49e2e8422d", "patch": "@@ -0,0 +1,45 @@\n+use crate::future::Future;\n+use crate::pin::Pin;\n+use crate::task::{Context, Poll};\n+\n+/// Creates a future that is immediately ready with a value.\n+///\n+/// This `struct` is created by the [`ready`] function. See its\n+/// documentation for more.\n+///\n+/// [`ready`]: fn.ready.html\n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+#[derive(Debug, Clone)]\n+#[must_use = \"futures do nothing unless you `.await` or poll them\"]\n+pub struct Ready<T>(Option<T>);\n+\n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+impl<T> Unpin for Ready<T> {}\n+\n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+impl<T> Future for Ready<T> {\n+    type Output = T;\n+\n+    #[inline]\n+    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<T> {\n+        Poll::Ready(self.0.take().expect(\"Ready polled after completion\"))\n+    }\n+}\n+\n+/// Creates a future that is immediately ready with a value.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(future_readiness_fns)]\n+/// use core::future;\n+///\n+/// # async fn run() {\n+/// let a = future::ready(1);\n+/// assert_eq!(a.await, 1);\n+/// # }\n+/// ```\n+#[unstable(feature = \"future_readiness_fns\", issue = \"70921\")]\n+pub fn ready<T>(t: T) -> Ready<T> {\n+    Ready(Some(t))\n+}"}]}