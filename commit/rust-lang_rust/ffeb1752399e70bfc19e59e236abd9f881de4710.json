{"sha": "ffeb1752399e70bfc19e59e236abd9f881de4710", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZWIxNzUyMzk5ZTcwYmZjMTllNTllMjM2YWJkOWY4ODFkZTQ3MTA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-09-14T18:37:34Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-09-14T19:35:26Z"}, "message": "Remove stuff that's either unimplemented or misleading.", "tree": {"sha": "0b9bc5f6041a77f12a8b94e6e492aeeba2e6b8f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b9bc5f6041a77f12a8b94e6e492aeeba2e6b8f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffeb1752399e70bfc19e59e236abd9f881de4710", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffeb1752399e70bfc19e59e236abd9f881de4710", "html_url": "https://github.com/rust-lang/rust/commit/ffeb1752399e70bfc19e59e236abd9f881de4710", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffeb1752399e70bfc19e59e236abd9f881de4710/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2812f3cf2499ca6ccd8d1c0edc1cd586a2bb32be", "url": "https://api.github.com/repos/rust-lang/rust/commits/2812f3cf2499ca6ccd8d1c0edc1cd586a2bb32be", "html_url": "https://github.com/rust-lang/rust/commit/2812f3cf2499ca6ccd8d1c0edc1cd586a2bb32be"}], "stats": {"total": 38, "additions": 10, "deletions": 28}, "files": [{"sha": "e904899613a5b9c8c4e14bafb70391744ea497b1", "filename": "doc/rust.texi", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ffeb1752399e70bfc19e59e236abd9f881de4710/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/ffeb1752399e70bfc19e59e236abd9f881de4710/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=ffeb1752399e70bfc19e59e236abd9f881de4710", "patch": "@@ -214,9 +214,10 @@ programmer once it has been compiled.\n Rust compiles to native code. Rust compilation units are large and the\n compilation model is designed around multi-file, whole-library or\n whole-program optimization. The compiled units are standard loadable objects\n-(ELF, PE, Mach-O) containing standard metadata (DWARF) and are compatible with\n-existing, standard low-level tools (disassemblers, debuggers, profilers,\n-dynamic loaders).\n+(ELF, PE, Mach-O) containing standard debug information (DWARF) and are\n+compatible with existing, standard low-level tools (disassemblers, debuggers,\n+profilers, dynamic loaders). The compiled units include custom metadata that\n+carries full type and version information.\n \n The Rust runtime library is a small collection of support code for scheduling,\n memory management, inter-task communication, reflection and runtime\n@@ -245,14 +246,14 @@ roles.\n @item Static control over memory allocation, packing and aliasing.\n \n Many values in Rust are allocated @emph{within} their containing stack-frame\n-or parent structure. Numbers, records and tags are all allocated this\n+or parent structure. Numbers, records, tuples and tags are all allocated this\n way. To allocate such values in the heap, they must be explicitly\n @emph{boxed}. A @dfn{box} is a pointer to a heap allocation that holds another\n value, its @emph{content}. Boxes may be either shared or unique, depending\n on which sort of storage management is desired.\n \n-Boxing and unboxing in Rust is explicit, though in many cases (such as\n-name-component dereferencing) Rust will automatically ``reach through'' the\n+Boxing and unboxing in Rust is explicit, though in some cases (such as\n+name-component dereferencing) Rust will automatically dereference a\n box to access its content. Box values can be passed and assigned\n independently, like pointers in C; the difference is that in Rust they always\n point to live contents, and are not subject to pointer arithmetic.\n@@ -351,21 +352,6 @@ and object restriction are performed explicitly on object values, which are\n little more than order-insensitive records of methods sharing a common private\n value.\n \n-@sp 1\n-@item Dynamic type\n-\n-Rust includes support for values of a top type, @code{any}, that can hold any\n-type of value whatsoever. An @code{any} value is a pair of a type code and a\n-boxed value of that type. Injection into an @code{any} and projection by\n-type-case-selection is integrated into the language.\n-\n-@sp 1\n-@item Dynamic metaprogramming (reflection)\n-\n-Rust supports run-time reflection on the structure of a crate, using a\n-combination of custom descriptor structures and the DWARF metadata tables used\n-to support crate linkage and other runtime services.\n-\n @sp 1\n @item Static metaprogramming (syntactic extension)\n \n@@ -384,13 +370,10 @@ control stack, frees all of its owned resources (executing destructors) and\n enters the @emph{dead} state. Failure is idempotent and non-recoverable.\n \n @sp 1\n-@item Signal handling\n+@item Supervision hierarchy\n \n-Rust has a system for propagating task-failures and other spontaneous\n-events between tasks. Some signals can be trapped and redirected to\n-channels; other signals are fatal and result in task-failure. Tasks\n-can designate other tasks to handle signals for them. This permits\n-organizing tasks into mutually-supervising or mutually-failing groups.\n+Rust has a system for propagating task-failures, either directly to a\n+supervisor task, or indirectly by sending a message into a channel.\n \n @sp 1\n @item Resource types with deterministic destruction\n@@ -510,7 +493,6 @@ of St. Andrews (St. Andrews, Fife, UK).\n Additional specific influences can be seen from the following languages:\n @itemize\n @item The structural algebraic types and compilation manager of SML.\n-@c @item The syntax-extension systems of Camlp4 and the Common Lisp readtable.\n @item The deterministic destructor system of C++.\n @end itemize\n "}]}