{"sha": "d7e1f0006a9fdb520d05e76d1b67cf326e70124c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZTFmMDAwNmE5ZmRiNTIwZDA1ZTc2ZDFiNjdjZjMyNmU3MDEyNGM=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-29T23:03:26Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-29T23:05:45Z"}, "message": "Put arguments of the fail attribute on the same line as println!", "tree": {"sha": "61aa005117eab4400ef4e5738a15081d1446dd9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61aa005117eab4400ef4e5738a15081d1446dd9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7e1f0006a9fdb520d05e76d1b67cf326e70124c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e1f0006a9fdb520d05e76d1b67cf326e70124c", "html_url": "https://github.com/rust-lang/rust/commit/d7e1f0006a9fdb520d05e76d1b67cf326e70124c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7e1f0006a9fdb520d05e76d1b67cf326e70124c/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "052ba6c5df9d67dd56ec069f588ab6efba0fadd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/052ba6c5df9d67dd56ec069f588ab6efba0fadd0", "html_url": "https://github.com/rust-lang/rust/commit/052ba6c5df9d67dd56ec069f588ab6efba0fadd0"}], "stats": {"total": 106, "additions": 55, "deletions": 51}, "files": [{"sha": "19c6bdc24841a212d7bf796f9c70381e349672a3", "filename": "src/attr.rs", "status": "modified", "additions": 13, "deletions": 48, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d7e1f0006a9fdb520d05e76d1b67cf326e70124c/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e1f0006a9fdb520d05e76d1b67cf326e70124c/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=d7e1f0006a9fdb520d05e76d1b67cf326e70124c", "patch": "@@ -15,12 +15,12 @@ use config::lists::*;\n use config::IndentStyle;\n use expr::rewrite_literal;\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n+use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use types::{rewrite_path, PathContext};\n use utils::{count_newlines, mk_sp};\n \n-use std::borrow::Cow;\n use syntax::ast;\n use syntax::source_map::{BytePos, Span, DUMMY_SP};\n \n@@ -216,56 +216,21 @@ impl Rewrite for ast::MetaItem {\n             }\n             ast::MetaItemKind::List(ref list) => {\n                 let path = rewrite_path(context, PathContext::Type, None, &self.ident, shape)?;\n-\n-                let has_comma = ::expr::span_ends_with_comma(context, self.span);\n-                let trailing_comma = if has_comma { \",\" } else { \"\" };\n-                let combine = list.len() == 1 && match list[0].node {\n-                    ast::NestedMetaItemKind::Literal(..) => false,\n-                    ast::NestedMetaItemKind::MetaItem(ref inner_meta_item) => {\n-                        match inner_meta_item.node {\n-                            ast::MetaItemKind::List(..) => rewrite_path(\n-                                context,\n-                                PathContext::Type,\n-                                None,\n-                                &inner_meta_item.ident,\n-                                shape,\n-                            )\n-                            .map_or(false, |s| s.len() + path.len() + 2 <= shape.width),\n-                            _ => false,\n-                        }\n-                    }\n-                };\n-\n-                let argument_shape = argument_shape(\n-                    path.len() + 1,\n-                    2 + trailing_comma.len(),\n-                    combine,\n-                    shape,\n+                let has_trailing_comma = ::expr::span_ends_with_comma(context, self.span);\n+                overflow::rewrite_with_parens(\n                     context,\n-                )?;\n-                let item_str = format_arg_list(\n+                    &path,\n                     list.iter(),\n-                    |nested_meta_item| nested_meta_item.span.lo(),\n-                    |nested_meta_item| nested_meta_item.span.hi(),\n-                    |nested_meta_item| nested_meta_item.rewrite(context, argument_shape),\n+                    // 1 = \"]\"\n+                    shape.sub_width(1)?,\n                     self.span,\n-                    context,\n-                    argument_shape,\n-                    // 3 = \"()\" and \"]\"\n-                    shape\n-                        .offset_left(path.len())?\n-                        .sub_width(3 + trailing_comma.len())?,\n-                    Some(context.config.width_heuristics().fn_call_width),\n-                    combine,\n-                )?;\n-\n-                let indent = if item_str.starts_with('\\n') {\n-                    shape.indent.to_string_with_newline(context.config)\n-                } else {\n-                    Cow::Borrowed(\"\")\n-                };\n-\n-                format!(\"{}({}{}{})\", path, item_str, trailing_comma, indent)\n+                    context.config.width_heuristics().fn_call_width,\n+                    Some(if has_trailing_comma {\n+                        SeparatorTactic::Always\n+                    } else {\n+                        SeparatorTactic::Never\n+                    }),\n+                )?\n             }\n             ast::MetaItemKind::NameValue(ref literal) => {\n                 let path = rewrite_path(context, PathContext::Type, None, &self.ident, shape)?;"}, {"sha": "a7fc9728666769162579e33d9d5aba5a6d785675", "filename": "src/overflow.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d7e1f0006a9fdb520d05e76d1b67cf326e70124c/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e1f0006a9fdb520d05e76d1b67cf326e70124c/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=d7e1f0006a9fdb520d05e76d1b67cf326e70124c", "patch": "@@ -67,10 +67,17 @@ const SPECIAL_MACRO_WHITELIST: &[(&str, usize)] = &[\n     (\"debug_assert_ne!\", 2),\n ];\n \n+const SPECIAL_ATTR_WHITELIST: &[(&str, usize)] = &[\n+    // From the `failure` crate.\n+    (\"fail\", 0),\n+];\n+\n+#[derive(Debug)]\n pub enum OverflowableItem<'a> {\n     Expr(&'a ast::Expr),\n     GenericParam(&'a ast::GenericParam),\n     MacroArg(&'a MacroArg),\n+    NestedMetaItem(&'a ast::NestedMetaItem),\n     SegmentParam(&'a SegmentParam<'a>),\n     StructField(&'a ast::StructField),\n     TuplePatField(&'a TuplePatField<'a>),\n@@ -98,6 +105,7 @@ impl<'a> OverflowableItem<'a> {\n             OverflowableItem::Expr(expr) => f(*expr),\n             OverflowableItem::GenericParam(gp) => f(*gp),\n             OverflowableItem::MacroArg(macro_arg) => f(*macro_arg),\n+            OverflowableItem::NestedMetaItem(nmi) => f(*nmi),\n             OverflowableItem::SegmentParam(sp) => f(*sp),\n             OverflowableItem::StructField(sf) => f(*sf),\n             OverflowableItem::TuplePatField(pat) => f(*pat),\n@@ -109,6 +117,13 @@ impl<'a> OverflowableItem<'a> {\n         match self {\n             OverflowableItem::Expr(expr) => is_simple_expr(expr),\n             OverflowableItem::MacroArg(MacroArg::Expr(expr)) => is_simple_expr(expr),\n+            OverflowableItem::NestedMetaItem(nested_meta_item) => match nested_meta_item.node {\n+                ast::NestedMetaItemKind::Literal(..) => true,\n+                ast::NestedMetaItemKind::MetaItem(ref meta_item) => match meta_item.node {\n+                    ast::MetaItemKind::Word => true,\n+                    _ => false,\n+                },\n+            },\n             _ => false,\n         }\n     }\n@@ -149,6 +164,12 @@ impl<'a> OverflowableItem<'a> {\n                 MacroArg::Pat(..) => false,\n                 MacroArg::Item(..) => len == 1,\n             },\n+            OverflowableItem::NestedMetaItem(nested_meta_item) if len == 1 => {\n+                match nested_meta_item.node {\n+                    ast::NestedMetaItemKind::Literal(..) => false,\n+                    ast::NestedMetaItemKind::MetaItem(..) => true,\n+                }\n+            }\n             OverflowableItem::SegmentParam(seg) => match seg {\n                 SegmentParam::Type(ty) => can_be_overflowed_type(context, ty, len),\n                 _ => false,\n@@ -158,6 +179,14 @@ impl<'a> OverflowableItem<'a> {\n             _ => false,\n         }\n     }\n+\n+    fn whitelist(&self) -> &'static [(&'static str, usize)] {\n+        match self {\n+            OverflowableItem::MacroArg(..) => SPECIAL_MACRO_WHITELIST,\n+            OverflowableItem::NestedMetaItem(..) => SPECIAL_ATTR_WHITELIST,\n+            _ => &[],\n+        }\n+    }\n }\n \n pub trait IntoOverflowableItem<'a>: Rewrite + Spanned {\n@@ -201,7 +230,7 @@ macro impl_into_overflowable_item_for_rustfmt_types {\n     }\n }\n \n-impl_into_overflowable_item_for_ast_node!(Expr, GenericParam, StructField, Ty);\n+impl_into_overflowable_item_for_ast_node!(Expr, GenericParam, NestedMetaItem, StructField, Ty);\n impl_into_overflowable_item_for_rustfmt_types!([MacroArg], [SegmentParam, TuplePatField]);\n \n pub fn into_overflowable_list<'a, T>(\n@@ -655,7 +684,7 @@ fn last_item_shape(\n     shape: Shape,\n     args_max_width: usize,\n ) -> Option<Shape> {\n-    if items.len() == 1 && !lists.iter().next()?.is_nested_call() {\n+    if items.len() == 1 && !lists.get(0)?.is_nested_call() {\n         return Some(shape);\n     }\n     let offset = items.iter().rev().skip(1).fold(0, |acc, i| {"}, {"sha": "bd4af3f7bba41c83db630d040aaefcec13e7abfe", "filename": "src/patterns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7e1f0006a9fdb520d05e76d1b67cf326e70124c/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e1f0006a9fdb520d05e76d1b67cf326e70124c/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=d7e1f0006a9fdb520d05e76d1b67cf326e70124c", "patch": "@@ -264,6 +264,7 @@ impl Rewrite for FieldPat {\n     }\n }\n \n+#[derive(Debug)]\n pub enum TuplePatField<'a> {\n     Pat(&'a ptr::P<ast::Pat>),\n     Dotdot(Span),"}, {"sha": "2488f3b428d80e565275040332ea1d3bd4efa946", "filename": "src/spanned.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d7e1f0006a9fdb520d05e76d1b67cf326e70124c/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e1f0006a9fdb520d05e76d1b67cf326e70124c/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=d7e1f0006a9fdb520d05e76d1b67cf326e70124c", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::{ast, ptr, source_map::Span};\n+use syntax::{\n+    ast, ptr,\n+    source_map::{self, Span},\n+};\n \n use macros::MacroArg;\n use utils::{mk_sp, outer_attributes};\n@@ -26,6 +29,12 @@ impl<T: Spanned> Spanned for ptr::P<T> {\n     }\n }\n \n+impl<T> Spanned for source_map::Spanned<T> {\n+    fn span(&self) -> Span {\n+        self.span\n+    }\n+}\n+\n macro_rules! span_with_attrs_lo_hi {\n     ($this:ident, $lo:expr, $hi:expr) => {{\n         let attrs = outer_attributes(&$this.attrs);"}]}