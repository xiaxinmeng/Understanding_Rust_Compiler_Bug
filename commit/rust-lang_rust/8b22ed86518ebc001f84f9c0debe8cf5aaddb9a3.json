{"sha": "8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMjJlZDg2NTE4ZWJjMDAxZjg0ZjljMGRlYmU4Y2Y1YWFkZGI5YTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-12-22T22:17:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-06T02:05:51Z"}, "message": "Add assert-dep-graph testing mechanism and tests", "tree": {"sha": "db6f5f38da95a74db835623fb51b8675d6206d45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db6f5f38da95a74db835623fb51b8675d6206d45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "html_url": "https://github.com/rust-lang/rust/commit/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "html_url": "https://github.com/rust-lang/rust/commit/d48f48f61f996478e972e2dd6f3070eaf3ed45d7"}], "stats": {"total": 782, "additions": 782, "deletions": 0}, "files": [{"sha": "0892cf1b5d33ec4ba5ba5858db71289a7ff8e7cc", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -27,6 +27,7 @@\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n+#![feature(into_cow)]\n #![feature(iter_arith)]\n #![feature(libc)]\n #![feature(path_relative_from)]"}, {"sha": "924700f0ae5916c263fb15a23555e838cfc5c793", "filename": "src/librustc_trans/trans/assert_dep_graph.rs", "status": "added", "additions": 430, "deletions": 0, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -0,0 +1,430 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass is only used for the UNIT TESTS and DEBUGGING NEEDS\n+//! around dependency graph construction. It serves two purposes; it\n+//! will dump graphs in graphviz form to disk, and it searches for\n+//! `#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]`\n+//! annotations. These annotations can be used to test whether paths\n+//! exist in the graph. We report errors on each\n+//! `rustc_if_this_changed` annotation. If a path exists in all\n+//! cases, then we would report \"all path(s) exist\". Otherwise, we\n+//! report: \"no path to `foo`\" for each case where no path exists.\n+//! `compile-fail` tests can then be used to check when paths exist or\n+//! do not.\n+//!\n+//! The full form of the `rustc_if_this_changed` annotation is\n+//! `#[rustc_if_this_changed(id)]`. The `\"id\"` is optional and\n+//! defaults to `\"id\"` if omitted.\n+//!\n+//! Example:\n+//!\n+//! ```\n+//! #[rustc_if_this_changed]\n+//! fn foo() { }\n+//!\n+//! #[rustc_then_this_would_need(\"trans\")] //~ ERROR no path from `foo`\n+//! fn bar() { }\n+//!\n+//! #[rustc_then_this_would_need(\"trans\")] //~ ERROR OK\n+//! fn baz() { foo(); }\n+//! ```\n+\n+use graphviz as dot;\n+use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::ty;\n+use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n+use rustc_front::hir;\n+use rustc_front::intravisit::Visitor;\n+use std::borrow::IntoCow;\n+use std::env;\n+use std::fs::File;\n+use std::io::Write;\n+use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n+\n+const IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n+const THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n+const ID: &'static str = \"id\";\n+\n+pub fn assert_dep_graph(tcx: &ty::ctxt) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    if tcx.sess.opts.dump_dep_graph {\n+        dump_graph(tcx);\n+    }\n+\n+    // Find annotations supplied by user (if any).\n+    let (if_this_changed, then_this_would_need) = {\n+        let mut visitor = IfThisChanged { tcx: tcx,\n+                                          if_this_changed: FnvHashMap(),\n+                                          then_this_would_need: FnvHashMap() };\n+        tcx.map.krate().visit_all_items(&mut visitor);\n+        (visitor.if_this_changed, visitor.then_this_would_need)\n+    };\n+\n+    // Check paths.\n+    check_paths(tcx, &if_this_changed, &then_this_would_need);\n+}\n+\n+type SourceHashMap = FnvHashMap<InternedString,\n+                                FnvHashSet<(Span, DefId, DepNode)>>;\n+type TargetHashMap = FnvHashMap<InternedString,\n+                                FnvHashSet<(Span, InternedString, ast::NodeId, DepNode)>>;\n+\n+struct IfThisChanged<'a, 'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    if_this_changed: SourceHashMap,\n+    then_this_would_need: TargetHashMap,\n+}\n+\n+impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n+    fn process_attrs(&mut self, node_id: ast::NodeId, def_id: DefId) {\n+        for attr in self.tcx.get_attrs(def_id).iter() {\n+            if attr.check_name(IF_THIS_CHANGED) {\n+                let mut id = None;\n+                for meta_item in attr.meta_item_list().unwrap_or_default() {\n+                    match meta_item.node {\n+                        ast::MetaWord(ref s) if id.is_none() => id = Some(s.clone()),\n+                        _ => {\n+                            self.tcx.sess.span_err(\n+                                meta_item.span,\n+                                &format!(\"unexpected meta-item {:?}\", meta_item.node));\n+                        }\n+                    }\n+                }\n+                let id = id.unwrap_or(InternedString::new(ID));\n+                self.if_this_changed.entry(id)\n+                                    .or_insert(FnvHashSet())\n+                                    .insert((attr.span, def_id, DepNode::Hir(def_id)));\n+            } else if attr.check_name(THEN_THIS_WOULD_NEED) {\n+                let mut dep_node_interned = None;\n+                let mut id = None;\n+                for meta_item in attr.meta_item_list().unwrap_or_default() {\n+                    match meta_item.node {\n+                        ast::MetaWord(ref s) if dep_node_interned.is_none() =>\n+                            dep_node_interned = Some(s.clone()),\n+                        ast::MetaWord(ref s) if id.is_none() =>\n+                            id = Some(s.clone()),\n+                        _ => {\n+                            self.tcx.sess.span_err(\n+                                meta_item.span,\n+                                &format!(\"unexpected meta-item {:?}\", meta_item.node));\n+                        }\n+                    }\n+                }\n+                let dep_node_str = dep_node_interned.as_ref().map(|s| &**s);\n+                macro_rules! match_depnode_name {\n+                    ($input:expr, $def_id:expr, match { $($variant:ident,)* } else $y:expr) => {\n+                        match $input {\n+                            $(Some(stringify!($variant)) => DepNode::$variant($def_id),)*\n+                            _ => $y\n+                        }\n+                    }\n+                }\n+                let dep_node = match_depnode_name! {\n+                    dep_node_str, def_id, match {\n+                        CollectItem,\n+                        BorrowCheck,\n+                        TransCrateItem,\n+                        TypeckItemType,\n+                        TypeckItemBody,\n+                        ImplOrTraitItems,\n+                        ItemSignature,\n+                        FieldTy,\n+                        TraitItemDefIds,\n+                        InherentImpls,\n+                        ImplItems,\n+                        TraitImpls,\n+                        ReprHints,\n+                    } else {\n+                        self.tcx.sess.span_fatal(\n+                            attr.span,\n+                            &format!(\"unrecognized DepNode variant {:?}\", dep_node_str));\n+                    }\n+                };\n+                let id = id.unwrap_or(InternedString::new(ID));\n+                self.then_this_would_need\n+                    .entry(id)\n+                    .or_insert(FnvHashSet())\n+                    .insert((attr.span, dep_node_interned.clone().unwrap(), node_id, dep_node));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let def_id = self.tcx.map.local_def_id(item.id);\n+        self.process_attrs(item.id, def_id);\n+    }\n+}\n+\n+fn check_paths(tcx: &ty::ctxt,\n+               if_this_changed: &SourceHashMap,\n+               then_this_would_need: &TargetHashMap)\n+{\n+    // Return early here so as not to construct the query, which is not cheap.\n+    if if_this_changed.is_empty() {\n+        return;\n+    }\n+    let query = tcx.dep_graph.query();\n+    for (id, sources) in if_this_changed {\n+        let targets = match then_this_would_need.get(id) {\n+            Some(targets) => targets,\n+            None => {\n+                for &(source_span, _, _) in sources.iter().take(1) {\n+                    tcx.sess.span_err(\n+                        source_span,\n+                        &format!(\"no targets for id `{}`\", id));\n+                }\n+                continue;\n+            }\n+        };\n+\n+        for &(_, source_def_id, source_dep_node) in sources {\n+            let dependents = query.dependents(source_dep_node);\n+            for &(target_span, ref target_pass, _, ref target_dep_node) in targets {\n+                if !dependents.contains(&target_dep_node) {\n+                    tcx.sess.span_err(\n+                        target_span,\n+                        &format!(\"no path from `{}` to `{}`\",\n+                                 tcx.item_path_str(source_def_id),\n+                                 target_pass));\n+                } else {\n+                    tcx.sess.span_err(\n+                        target_span,\n+                        &format!(\"OK\"));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn dump_graph(tcx: &ty::ctxt) {\n+    let path: String = env::var(\"RUST_DEP_GRAPH\").unwrap_or_else(|_| format!(\"dep_graph\"));\n+    let query = tcx.dep_graph.query();\n+\n+    let nodes = match env::var(\"RUST_DEP_GRAPH_FILTER\") {\n+        Ok(string) => {\n+            // Expect one of: \"-> target\", \"source -> target\", or \"source ->\".\n+            let parts: Vec<_> = string.split(\"->\").collect();\n+            if parts.len() > 2 {\n+                panic!(\"Invalid RUST_DEP_GRAPH_FILTER: expected '[source] -> [target]'\");\n+            }\n+            let sources = node_set(&query, &parts[0]);\n+            let targets = node_set(&query, &parts[1]);\n+            filter_nodes(&query, &sources, &targets)\n+        }\n+        Err(_) => {\n+            query.nodes()\n+                 .into_iter()\n+                 .collect()\n+        }\n+    };\n+    let edges = filter_edges(&query, &nodes);\n+\n+    { // dump a .txt file with just the edges:\n+        let txt_path = format!(\"{}.txt\", path);\n+        let mut file = File::create(&txt_path).unwrap();\n+        for &(source, target) in &edges {\n+            write!(file, \"{:?} -> {:?}\\n\", source, target).unwrap();\n+        }\n+    }\n+\n+    { // dump a .dot file in graphviz format:\n+        let dot_path = format!(\"{}.dot\", path);\n+        let mut v = Vec::new();\n+        dot::render(&GraphvizDepGraph(nodes, edges), &mut v).unwrap();\n+        File::create(&dot_path).and_then(|mut f| f.write_all(&v)).unwrap();\n+    }\n+}\n+\n+pub struct GraphvizDepGraph(FnvHashSet<DepNode>, Vec<(DepNode, DepNode)>);\n+\n+impl<'a, 'tcx> dot::GraphWalk<'a, DepNode, (DepNode, DepNode)> for GraphvizDepGraph {\n+    fn nodes(&self) -> dot::Nodes<DepNode> {\n+        let nodes: Vec<_> = self.0.iter().cloned().collect();\n+        nodes.into_cow()\n+    }\n+    fn edges(&self) -> dot::Edges<(DepNode, DepNode)> {\n+        self.1[..].into_cow()\n+    }\n+    fn source(&self, edge: &(DepNode, DepNode)) -> DepNode {\n+        edge.0\n+    }\n+    fn target(&self, edge: &(DepNode, DepNode)) -> DepNode {\n+        edge.1\n+    }\n+}\n+\n+impl<'a, 'tcx> dot::Labeller<'a, DepNode, (DepNode, DepNode)> for GraphvizDepGraph {\n+    fn graph_id(&self) -> dot::Id {\n+        dot::Id::new(\"DependencyGraph\").unwrap()\n+    }\n+    fn node_id(&self, n: &DepNode) -> dot::Id {\n+        let s: String =\n+            format!(\"{:?}\", n).chars()\n+                              .map(|c| if c == '_' || c.is_alphanumeric() { c } else { '_' })\n+                              .collect();\n+        debug!(\"n={:?} s={:?}\", n, s);\n+        dot::Id::new(s).unwrap()\n+    }\n+    fn node_label(&self, n: &DepNode) -> dot::LabelText {\n+        dot::LabelText::label(format!(\"{:?}\", n))\n+    }\n+}\n+\n+// Given an optional filter like `\"x,y,z\"`, returns either `None` (no\n+// filter) or the set of nodes whose labels contain all of those\n+// substrings.\n+fn node_set(query: &DepGraphQuery, filter: &str) -> Option<FnvHashSet<DepNode>> {\n+    debug!(\"node_set(filter={:?})\", filter);\n+\n+    if filter.trim().is_empty() {\n+        return None;\n+    }\n+\n+    let filters: Vec<&str> = filter.split(\"&\").map(|s| s.trim()).collect();\n+\n+    debug!(\"node_set: filters={:?}\", filters);\n+\n+    Some(query.nodes()\n+         .into_iter()\n+         .filter(|n| {\n+             let s = format!(\"{:?}\", n);\n+             filters.iter().all(|f| s.contains(f))\n+         })\n+        .collect())\n+}\n+\n+fn filter_nodes(query: &DepGraphQuery,\n+                sources: &Option<FnvHashSet<DepNode>>,\n+                targets: &Option<FnvHashSet<DepNode>>)\n+                -> FnvHashSet<DepNode>\n+{\n+    if let &Some(ref sources) = sources {\n+        if let &Some(ref targets) = targets {\n+            walk_between(query, sources, targets)\n+        } else {\n+            walk_nodes(query, sources, OUTGOING)\n+        }\n+    } else if let &Some(ref targets) = targets {\n+        walk_nodes(query, targets, INCOMING)\n+    } else {\n+        query.nodes().into_iter().collect()\n+    }\n+}\n+\n+fn walk_nodes(query: &DepGraphQuery,\n+              starts: &FnvHashSet<DepNode>,\n+              direction: Direction)\n+              -> FnvHashSet<DepNode>\n+{\n+    let mut set = FnvHashSet();\n+    for start in starts {\n+        debug!(\"walk_nodes: start={:?} outgoing?={:?}\", start, direction == OUTGOING);\n+        if set.insert(*start) {\n+            let mut stack = vec![query.indices[start]];\n+            while let Some(index) = stack.pop() {\n+                for (_, edge) in query.graph.adjacent_edges(index, direction) {\n+                    let neighbor_index = edge.source_or_target(direction);\n+                    let neighbor = query.graph.node_data(neighbor_index);\n+                    if set.insert(*neighbor) {\n+                        stack.push(neighbor_index);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    set\n+}\n+\n+fn walk_between(query: &DepGraphQuery,\n+                sources: &FnvHashSet<DepNode>,\n+                targets: &FnvHashSet<DepNode>)\n+                -> FnvHashSet<DepNode>\n+{\n+    // This is a bit tricky. We want to include a node only if it is:\n+    // (a) reachable from a source and (b) will reach a target. And we\n+    // have to be careful about cycles etc.  Luckily efficiency is not\n+    // a big concern!\n+\n+    #[derive(Copy, Clone, PartialEq)]\n+    enum State { Undecided, Deciding, Included, Excluded }\n+\n+    let mut node_states = vec![State::Undecided; query.graph.len_nodes()];\n+\n+    for &target in targets {\n+        node_states[query.indices[&target].0] = State::Included;\n+    }\n+\n+    for source in sources.iter().map(|n| query.indices[n]) {\n+        recurse(query, &mut node_states, source);\n+    }\n+\n+    return query.nodes()\n+                .into_iter()\n+                .filter(|n| {\n+                    let index = query.indices[n];\n+                    node_states[index.0] == State::Included\n+                })\n+                .collect();\n+\n+    fn recurse(query: &DepGraphQuery,\n+               node_states: &mut [State],\n+               node: NodeIndex)\n+               -> bool\n+    {\n+        match node_states[node.0] {\n+            // known to reach a target\n+            State::Included => return true,\n+\n+            // known not to reach a target\n+            State::Excluded => return false,\n+\n+            // backedge, not yet known, say false\n+            State::Deciding => return false,\n+\n+            State::Undecided => { }\n+        }\n+\n+        node_states[node.0] = State::Deciding;\n+\n+        for neighbor_index in query.graph.successor_nodes(node) {\n+            if recurse(query, node_states, neighbor_index) {\n+                node_states[node.0] = State::Included;\n+            }\n+        }\n+\n+        // if we didn't find a path to target, then set to excluded\n+        if node_states[node.0] == State::Deciding {\n+            node_states[node.0] = State::Excluded;\n+            false\n+        } else {\n+            assert!(node_states[node.0] == State::Included);\n+            true\n+        }\n+    }\n+}\n+\n+fn filter_edges(query: &DepGraphQuery,\n+                nodes: &FnvHashSet<DepNode>)\n+                -> Vec<(DepNode, DepNode)>\n+{\n+    query.edges()\n+         .into_iter()\n+         .filter(|&(source, target)| nodes.contains(&source) && nodes.contains(&target))\n+         .collect()\n+}"}, {"sha": "810803762a85362f86a11925e6d394b009011ae0", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -51,6 +51,7 @@ use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use trans::_match;\n use trans::adt;\n+use trans::assert_dep_graph;\n use trans::attributes;\n use trans::build::*;\n use trans::builder::{Builder, noname};\n@@ -3142,6 +3143,8 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n+    assert_dep_graph::assert_dep_graph(tcx);\n+\n     CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,"}, {"sha": "1fbc0d5c0152930a29acf337990a4ddf7d51ecb3", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -20,6 +20,7 @@ mod macros;\n \n mod adt;\n mod asm;\n+mod assert_dep_graph;\n mod attributes;\n mod base;\n mod basic_block;"}, {"sha": "c281571305b8bc7de8f4df9c4af3af69a4b368f0", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -326,6 +326,14 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                        \"the `#[rustc_error]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\")),\n+    (\"rustc_if_this_changed\", Whitelisted, Gated(\"rustc_attrs\",\n+                                       \"the `#[rustc_if_this_changed]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\")),\n+    (\"rustc_then_this_would_need\", Whitelisted, Gated(\"rustc_attrs\",\n+                                       \"the `#[rustc_if_this_changed]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\")),\n     (\"rustc_move_fragments\", Normal, Gated(\"rustc_attrs\",\n                                            \"the `#[rustc_move_fragments]` attribute \\\n                                             is just used for rustc unit tests \\"}, {"sha": "8e46603711fea335439a389c19dd15e10f5b4b55", "filename": "src/test/compile-fail/dep-graph-caller-callee.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-caller-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-caller-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-caller-callee.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that two unrelated functions have no trans dependency.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+fn main() { }\n+\n+mod x {\n+    #[rustc_if_this_changed]\n+    pub fn x() { }\n+}\n+\n+mod y {\n+    use x;\n+\n+    // These dependencies SHOULD exist:\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR OK\n+    pub fn y() {\n+        x::x();\n+    }\n+}\n+\n+mod z {\n+    use y;\n+\n+    // These are expected to yield errors, because changes to `x`\n+    // affect the BODY of `y`, but not its signature.\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path\n+    pub fn z() {\n+        y::y();\n+    }\n+}"}, {"sha": "2c4fe5c96b806cbb22d27b498038055ab80810aa", "filename": "src/test/compile-fail/dep-graph-struct-signature.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that two unrelated functions have no trans dependency.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+fn main() { }\n+\n+#[rustc_if_this_changed]\n+struct WillChange {\n+    x: u32,\n+    y: u32\n+}\n+\n+struct WontChange {\n+    x: u32,\n+    y: u32\n+}\n+\n+// these are valid dependencies\n+mod signatures {\n+    use WillChange;\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    trait Bar {\n+        fn do_something(x: WillChange);\n+    }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    fn some_fn(x: WillChange) { }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    fn new_foo(x: u32, y: u32) -> WillChange {\n+        WillChange { x: x, y: y }\n+    }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    impl WillChange {\n+        fn new(x: u32, y: u32) -> WillChange { loop { } }\n+    }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    impl WillChange {\n+        fn method(&self, x: u32) { }\n+    }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    struct WillChanges {\n+        x: WillChange,\n+        y: WillChange\n+    }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    fn indirect(x: WillChange) { }\n+}\n+\n+// these are invalid dependencies, though sometimes we create edges\n+// anyway.\n+mod invalid_signatures {\n+    use WontChange;\n+\n+    // FIXME due to the variance pass having overly conservative edges,\n+    // we incorrectly think changes are needed here\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    trait A {\n+        fn do_something_else_twice(x: WontChange);\n+    }\n+\n+    // FIXME due to the variance pass having overly conservative edges,\n+    // we incorrectly think changes are needed here\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    fn b(x: WontChange) { }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path from `WillChange`\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR no path from `WillChange`\n+    fn c(x: u32) { }\n+}\n+"}, {"sha": "1003f92f161913513332aa71e4ce88238fea83d5", "filename": "src/test/compile-fail/dep-graph-trait-impl-two-traits-same-method.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that two unrelated functions have no trans dependency.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+fn main() { }\n+\n+pub trait Foo: Sized {\n+    fn method(self) { }\n+}\n+\n+pub trait Bar: Sized {\n+    fn method(self) { }\n+}\n+\n+mod x {\n+    use {Foo, Bar};\n+\n+    #[rustc_if_this_changed]\n+    impl Foo for u32 { }\n+\n+    impl Bar for char { }\n+}\n+\n+mod y {\n+    use {Foo, Bar};\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    pub fn with_char() {\n+        char::method('a');\n+    }\n+}\n+\n+mod z {\n+    use y;\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    pub fn z() {\n+        y::with_char();\n+    }\n+}"}, {"sha": "34a9dbfd62a6284d3e120012c17c9a759d620c0f", "filename": "src/test/compile-fail/dep-graph-trait-impl-two-traits.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that adding an impl to a trait `Foo` does not affect functions\n+// that only use `Bar`.\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+fn main() { }\n+\n+pub trait Foo: Sized {\n+    fn foo(self) { }\n+}\n+\n+pub trait Bar: Sized {\n+    fn bar(self) { }\n+}\n+\n+mod x {\n+    use {Foo, Bar};\n+\n+    #[rustc_if_this_changed]\n+    impl Foo for char { }\n+\n+    impl Bar for char { }\n+}\n+\n+mod y {\n+    use {Foo, Bar};\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    pub fn call_bar() {\n+        char::bar('a');\n+    }\n+}\n+\n+mod z {\n+    use y;\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    pub fn z() {\n+        y::call_bar();\n+    }\n+}"}, {"sha": "9ad782a0a6369d298bad3f3ac666c34d2d5a342a", "filename": "src/test/compile-fail/dep-graph-trait-impl.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that two unrelated functions have no trans dependency.\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+fn main() { }\n+\n+pub trait Foo: Sized {\n+    fn method(self) { }\n+}\n+\n+mod x {\n+    use Foo;\n+\n+    #[rustc_if_this_changed]\n+    impl Foo for char { }\n+\n+    impl Foo for u32 { }\n+}\n+\n+mod y {\n+    use Foo;\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR OK\n+    pub fn with_char() {\n+        char::method('a');\n+    }\n+\n+    // TODO open an issue on this, problem is that we fail to track\n+    // the tcx fulfillment cache\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path\n+    pub fn take_foo_with_char() {\n+        take_foo::<char>('a');\n+    }\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR OK\n+    pub fn with_u32() {\n+        u32::method(22);\n+    }\n+\n+    // TODO same issue as above\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path\n+    pub fn take_foo_with_u32() {\n+        take_foo::<u32>(22);\n+    }\n+\n+    pub fn take_foo<T:Foo>(t: T) { }\n+}\n+\n+mod z {\n+    use y;\n+\n+    // These are expected to yield errors, because changes to `x`\n+    // affect the BODY of `y`, but not its signature.\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path\n+    pub fn z() {\n+        y::with_char();\n+        y::with_u32();\n+    }\n+}"}, {"sha": "fa204a5c76cc75f11125d4fa118af4ee8cf037b1", "filename": "src/test/compile-fail/dep-graph-unrelated.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3/src%2Ftest%2Fcompile-fail%2Fdep-graph-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-unrelated.rs?ref=8b22ed86518ebc001f84f9c0debe8cf5aaddb9a3", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that two unrelated functions have no trans dependency.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+#[rustc_if_this_changed]\n+fn main() { }\n+\n+#[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path from `main`\n+fn bar() { }"}]}