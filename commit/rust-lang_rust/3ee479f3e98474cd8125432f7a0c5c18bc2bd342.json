{"sha": "3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZTQ3OWYzZTk4NDc0Y2Q4MTI1NDMyZjdhMGM1YzE4YmMyYmQzNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-19T01:37:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-19T01:37:25Z"}, "message": "auto merge of #6577 : brson/rust/io-upstream, r=pcwalton\n\nr?\r\n\r\nThis is all of my scheduler work on #4419 from the last 3 weeks or so. I've had a few failed pull requests so far but I think the problems are ironed out.\r\n\r\n* TCP\r\n* The beginnings of runtime embedding APIs\r\n* Porting various corners of core to be compatible with both schedulers\r\n* libuv timer bindings\r\n* Further refinement of I/O error handling, including a new, incomplete, `read_error` condition\r\n* Incomplete refactoring to make tasks work without coroutines and user-space scheduling\r\n* Implementations of Reader/Writer extension methods\r\n* Implementations of the most important part of core::comm\r\n\r\nI'm particularly happy with how easy the [comm types on top of the scheduler](https://github.com/brson/rust/blob/io-upstream/src/libcore/rt/comm.rs). Note that these implementations do not use pipes. If anything here needs careful review though it's this code.\r\n\r\nThis branch passes 95% of the run-pass tests (with `TESTARGS=--newrt`)\r\n\r\nIn the next week I'll probably spend some time adding preliminary multithreading and seeing how close we are to removing the old runtime.", "tree": {"sha": "b105fbefbc8b0fce8abc62152a9bd6b9af1a6abe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b105fbefbc8b0fce8abc62152a9bd6b9af1a6abe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "html_url": "https://github.com/rust-lang/rust/commit/3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24c2be3323f088dc0e8024fc503198b2a535a09e", "url": "https://api.github.com/repos/rust-lang/rust/commits/24c2be3323f088dc0e8024fc503198b2a535a09e", "html_url": "https://github.com/rust-lang/rust/commit/24c2be3323f088dc0e8024fc503198b2a535a09e"}, {"sha": "8daa5ec9eac7148674cd63e5281c56925a3bc7b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8daa5ec9eac7148674cd63e5281c56925a3bc7b7", "html_url": "https://github.com/rust-lang/rust/commit/8daa5ec9eac7148674cd63e5281c56925a3bc7b7"}], "stats": {"total": 5551, "additions": 4138, "deletions": 1413}, "files": [{"sha": "59eb915c239fee0ee376ccce41434a602b999d22", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 436, "deletions": 245, "changes": 681, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -22,8 +22,10 @@ use vec;\n use vec::OwnedVector;\n use util::replace;\n use unstable::sync::{Exclusive, exclusive};\n+use rtcomm = rt::comm;\n+use rt;\n \n-use pipes::{recv, try_recv, wait_many, peek, PacketHeader};\n+use pipes::{wait_many, PacketHeader};\n \n // FIXME #5160: Making this public exposes some plumbing from\n // pipes. Needs some refactoring\n@@ -59,76 +61,14 @@ pub trait Peekable<T> {\n     fn peek(&self) -> bool;\n }\n \n-\n-// Streams - Make pipes a little easier in general.\n-\n-/*proto! streamp (\n-    Open:send<T: Owned> {\n-        data(T) -> Open<T>\n-    }\n-)*/\n-\n-#[allow(non_camel_case_types)]\n-pub mod streamp {\n-    priv use core::kinds::Owned;\n-\n-    pub fn init<T: Owned>() -> (client::Open<T>, server::Open<T>) {\n-        pub use core::pipes::HasBuffer;\n-        ::core::pipes::entangle()\n-    }\n-\n-    #[allow(non_camel_case_types)]\n-    pub enum Open<T> { pub data(T, server::Open<T>), }\n-\n-    #[allow(non_camel_case_types)]\n-    pub mod client {\n-        priv use core::kinds::Owned;\n-\n-        #[allow(non_camel_case_types)]\n-        pub fn try_data<T: Owned>(pipe: Open<T>, x_0: T) ->\n-            ::core::option::Option<Open<T>> {\n-            {\n-                use super::data;\n-                let (c, s) = ::core::pipes::entangle();\n-                let message = data(x_0, s);\n-                if ::core::pipes::send(pipe, message) {\n-                    ::core::pipes::rt::make_some(c)\n-                } else { ::core::pipes::rt::make_none() }\n-            }\n-        }\n-\n-        #[allow(non_camel_case_types)]\n-        pub fn data<T: Owned>(pipe: Open<T>, x_0: T) -> Open<T> {\n-            {\n-                use super::data;\n-                let (c, s) = ::core::pipes::entangle();\n-                let message = data(x_0, s);\n-                ::core::pipes::send(pipe, message);\n-                c\n-            }\n-        }\n-\n-        #[allow(non_camel_case_types)]\n-        pub type Open<T> = ::core::pipes::SendPacket<super::Open<T>>;\n-    }\n-\n-    #[allow(non_camel_case_types)]\n-    pub mod server {\n-        #[allow(non_camel_case_types)]\n-        pub type Open<T> = ::core::pipes::RecvPacket<super::Open<T>>;\n-    }\n-}\n-\n /// An endpoint that can send many messages.\n-#[unsafe_mut_field(endp)]\n pub struct Chan<T> {\n-    endp: Option<streamp::client::Open<T>>\n+    inner: Either<pipesy::Chan<T>, rtcomm::Chan<T>>\n }\n \n /// An endpoint that can receive many messages.\n-#[unsafe_mut_field(endp)]\n pub struct Port<T> {\n-    endp: Option<streamp::server::Open<T>>,\n+    inner: Either<pipesy::Port<T>, rtcomm::Port<T>>\n }\n \n /** Creates a `(Port, Chan)` pair.\n@@ -137,100 +77,75 @@ These allow sending or receiving an unlimited number of messages.\n \n */\n pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n-    let (c, s) = streamp::init();\n-\n-    (Port {\n-        endp: Some(s)\n-    }, Chan {\n-        endp: Some(c)\n-    })\n+    let (port, chan) = match rt::context() {\n+        rt::OldTaskContext => match pipesy::stream() {\n+            (p, c) => (Left(p), Left(c))\n+        },\n+        _ => match rtcomm::stream() {\n+            (p, c) => (Right(p), Right(c))\n+        }\n+    };\n+    let port = Port { inner: port };\n+    let chan = Chan { inner: chan };\n+    return (port, chan);\n }\n \n impl<T: Owned> GenericChan<T> for Chan<T> {\n-    #[inline(always)]\n     fn send(&self, x: T) {\n-        unsafe {\n-            let self_endp = transmute_mut(&self.endp);\n-            let endp = replace(self_endp, None);\n-            *self_endp = Some(streamp::client::data(endp.unwrap(), x))\n+        match self.inner {\n+            Left(ref chan) => chan.send(x),\n+            Right(ref chan) => chan.send(x)\n         }\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n-    #[inline(always)]\n     fn try_send(&self, x: T) -> bool {\n-        unsafe {\n-            let self_endp = transmute_mut(&self.endp);\n-            let endp = replace(self_endp, None);\n-            match streamp::client::try_data(endp.unwrap(), x) {\n-                Some(next) => {\n-                    *self_endp = Some(next);\n-                    true\n-                }\n-                None => false\n-            }\n+        match self.inner {\n+            Left(ref chan) => chan.try_send(x),\n+            Right(ref chan) => chan.try_send(x)\n         }\n     }\n }\n \n impl<T: Owned> GenericPort<T> for Port<T> {\n-    #[inline(always)]\n     fn recv(&self) -> T {\n-        unsafe {\n-            let self_endp = transmute_mut(&self.endp);\n-            let endp = replace(self_endp, None);\n-            let streamp::data(x, endp) = recv(endp.unwrap());\n-            *self_endp = Some(endp);\n-            x\n+        match self.inner {\n+            Left(ref port) => port.recv(),\n+            Right(ref port) => port.recv()\n         }\n     }\n \n-    #[inline(always)]\n     fn try_recv(&self) -> Option<T> {\n-        unsafe {\n-            let self_endp = transmute_mut(&self.endp);\n-            let endp = replace(self_endp, None);\n-            match try_recv(endp.unwrap()) {\n-                Some(streamp::data(x, endp)) => {\n-                    *self_endp = Some(endp);\n-                    Some(x)\n-                }\n-                None => None\n-            }\n+        match self.inner {\n+            Left(ref port) => port.try_recv(),\n+            Right(ref port) => port.try_recv()\n         }\n     }\n }\n \n impl<T: Owned> Peekable<T> for Port<T> {\n-    #[inline(always)]\n     fn peek(&self) -> bool {\n-        unsafe {\n-            let self_endp = transmute_mut(&self.endp);\n-            let mut endp = replace(self_endp, None);\n-            let peek = match endp {\n-                Some(ref mut endp) => peek(endp),\n-                None => fail!(\"peeking empty stream\")\n-            };\n-            *self_endp = endp;\n-            peek\n+        match self.inner {\n+            Left(ref port) => port.peek(),\n+            Right(ref port) => port.peek()\n         }\n     }\n }\n \n impl<T: Owned> Selectable for Port<T> {\n     fn header(&mut self) -> *mut PacketHeader {\n-            match self.endp {\n-                Some(ref mut endp) => endp.header(),\n-                None => fail!(\"peeking empty stream\")\n-            }\n+        match self.inner {\n+            Left(ref mut port) => port.header(),\n+            Right(_) => fail!(\"can't select on newsched ports\")\n+        }\n     }\n }\n \n /// Treat many ports as one.\n #[unsafe_mut_field(ports)]\n pub struct PortSet<T> {\n-    ports: ~[Port<T>],\n+    ports: ~[pipesy::Port<T>],\n }\n \n pub impl<T: Owned> PortSet<T> {\n@@ -241,6 +156,11 @@ pub impl<T: Owned> PortSet<T> {\n     }\n \n     fn add(&self, port: Port<T>) {\n+        let Port { inner } = port;\n+        let port = match inner {\n+            Left(p) => p,\n+            Right(_) => fail!(\"PortSet not implemented\")\n+        };\n         unsafe {\n             let self_ports = transmute_mut(&self.ports);\n             self_ports.push(port)\n@@ -288,7 +208,7 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n         for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n-            let port: &Port<T> = &self.ports[i];\n+            let port: &pipesy::Port<T> = &self.ports[i];\n             if port.peek() {\n                 return true;\n             }\n@@ -299,12 +219,17 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n \n /// A channel that can be shared between many senders.\n pub struct SharedChan<T> {\n-    ch: Exclusive<Chan<T>>\n+    ch: Exclusive<pipesy::Chan<T>>\n }\n \n impl<T: Owned> SharedChan<T> {\n     /// Converts a `chan` into a `shared_chan`.\n     pub fn new(c: Chan<T>) -> SharedChan<T> {\n+        let Chan { inner } = c;\n+        let c = match inner {\n+            Left(c) => c,\n+            Right(_) => fail!(\"SharedChan not implemented\")\n+        };\n         SharedChan { ch: exclusive(c) }\n     }\n }\n@@ -335,180 +260,446 @@ impl<T: Owned> ::clone::Clone for SharedChan<T> {\n     }\n }\n \n-/*proto! oneshot (\n-    Oneshot:send<T:Owned> {\n-        send(T) -> !\n+pub struct PortOne<T> {\n+    inner: Either<pipesy::PortOne<T>, rtcomm::PortOne<T>>\n+}\n+\n+pub struct ChanOne<T> {\n+    inner: Either<pipesy::ChanOne<T>, rtcomm::ChanOne<T>>\n+}\n+\n+pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+    let (port, chan) = match rt::context() {\n+        rt::OldTaskContext => match pipesy::oneshot() {\n+            (p, c) => (Left(p), Left(c)),\n+        },\n+        _ => match rtcomm::oneshot() {\n+            (p, c) => (Right(p), Right(c))\n+        }\n+    };\n+    let port = PortOne { inner: port };\n+    let chan = ChanOne { inner: chan };\n+    return (port, chan);\n+}\n+\n+impl<T: Owned> PortOne<T> {\n+    pub fn recv(self) -> T {\n+        let PortOne { inner } = self;\n+        match inner {\n+            Left(p) => p.recv(),\n+            Right(p) => p.recv()\n+        }\n     }\n-)*/\n \n-#[allow(non_camel_case_types)]\n-pub mod oneshot {\n-    priv use core::kinds::Owned;\n-    use ptr::to_mut_unsafe_ptr;\n+    pub fn try_recv(self) -> Option<T> {\n+        let PortOne { inner } = self;\n+        match inner {\n+            Left(p) => p.try_recv(),\n+            Right(p) => p.try_recv()\n+        }\n+    }\n+}\n \n-    pub fn init<T: Owned>() -> (client::Oneshot<T>, server::Oneshot<T>) {\n-        pub use core::pipes::HasBuffer;\n+impl<T: Owned> ChanOne<T> {\n+    pub fn send(self, data: T) {\n+        let ChanOne { inner } = self;\n+        match inner {\n+            Left(p) => p.send(data),\n+            Right(p) => p.send(data)\n+        }\n+    }\n \n-        let buffer = ~::core::pipes::Buffer {\n-            header: ::core::pipes::BufferHeader(),\n-            data: __Buffer {\n-                Oneshot: ::core::pipes::mk_packet::<Oneshot<T>>()\n-            },\n-        };\n-        do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n-            data.Oneshot.set_buffer(buffer);\n-            to_mut_unsafe_ptr(&mut data.Oneshot)\n+    pub fn try_send(self, data: T) -> bool {\n+        let ChanOne { inner } = self;\n+        match inner {\n+            Left(p) => p.try_send(data),\n+            Right(p) => p.try_send(data)\n         }\n     }\n-    #[allow(non_camel_case_types)]\n-    pub enum Oneshot<T> { pub send(T), }\n-    #[allow(non_camel_case_types)]\n-    pub struct __Buffer<T> {\n-        Oneshot: ::core::pipes::Packet<Oneshot<T>>,\n+}\n+\n+pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n+    let PortOne { inner } = port;\n+    match inner {\n+        Left(p) => pipesy::recv_one(p),\n+        Right(p) => p.recv()\n     }\n+}\n \n-    #[allow(non_camel_case_types)]\n-    pub mod client {\n+pub fn try_recv_one<T: Owned>(port: PortOne<T>) -> Option<T> {\n+    let PortOne { inner } = port;\n+    match inner {\n+        Left(p) => pipesy::try_recv_one(p),\n+        Right(p) => p.try_recv()\n+    }\n+}\n+\n+pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n+    let ChanOne { inner } = chan;\n+    match inner {\n+        Left(c) => pipesy::send_one(c, data),\n+        Right(c) => c.send(data)\n+    }\n+}\n+\n+pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n+    let ChanOne { inner } = chan;\n+    match inner {\n+        Left(c) => pipesy::try_send_one(c, data),\n+        Right(c) => c.try_send(data)\n+    }\n+}\n \n+mod pipesy {\n+\n+    use kinds::Owned;\n+    use option::{Option, Some, None};\n+    use pipes::{recv, try_recv, peek, PacketHeader};\n+    use super::{GenericChan, GenericSmartChan, GenericPort, Peekable, Selectable};\n+    use cast::transmute_mut;\n+    use util::replace;\n+\n+    /*proto! oneshot (\n+        Oneshot:send<T:Owned> {\n+            send(T) -> !\n+        }\n+    )*/\n+\n+    #[allow(non_camel_case_types)]\n+    pub mod oneshot {\n         priv use core::kinds::Owned;\n+        use ptr::to_mut_unsafe_ptr;\n \n-        #[allow(non_camel_case_types)]\n-        pub fn try_send<T: Owned>(pipe: Oneshot<T>, x_0: T) ->\n-            ::core::option::Option<()> {\n-            {\n-                use super::send;\n-                let message = send(x_0);\n-                if ::core::pipes::send(pipe, message) {\n-                    ::core::pipes::rt::make_some(())\n-                } else { ::core::pipes::rt::make_none() }\n+        pub fn init<T: Owned>() -> (client::Oneshot<T>, server::Oneshot<T>) {\n+            pub use core::pipes::HasBuffer;\n+\n+            let buffer = ~::core::pipes::Buffer {\n+                header: ::core::pipes::BufferHeader(),\n+                data: __Buffer {\n+                    Oneshot: ::core::pipes::mk_packet::<Oneshot<T>>()\n+                },\n+            };\n+            do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n+                data.Oneshot.set_buffer(buffer);\n+                to_mut_unsafe_ptr(&mut data.Oneshot)\n             }\n         }\n+        #[allow(non_camel_case_types)]\n+        pub enum Oneshot<T> { pub send(T), }\n+        #[allow(non_camel_case_types)]\n+        pub struct __Buffer<T> {\n+            Oneshot: ::core::pipes::Packet<Oneshot<T>>,\n+        }\n \n         #[allow(non_camel_case_types)]\n-        pub fn send<T: Owned>(pipe: Oneshot<T>, x_0: T) {\n-            {\n-                use super::send;\n-                let message = send(x_0);\n-                ::core::pipes::send(pipe, message);\n+        pub mod client {\n+\n+            priv use core::kinds::Owned;\n+\n+            #[allow(non_camel_case_types)]\n+            pub fn try_send<T: Owned>(pipe: Oneshot<T>, x_0: T) ->\n+                ::core::option::Option<()> {\n+                {\n+                    use super::send;\n+                    let message = send(x_0);\n+                    if ::core::pipes::send(pipe, message) {\n+                        ::core::pipes::rt::make_some(())\n+                    } else { ::core::pipes::rt::make_none() }\n+                }\n+            }\n+\n+            #[allow(non_camel_case_types)]\n+            pub fn send<T: Owned>(pipe: Oneshot<T>, x_0: T) {\n+                {\n+                    use super::send;\n+                    let message = send(x_0);\n+                    ::core::pipes::send(pipe, message);\n+                }\n             }\n+\n+            #[allow(non_camel_case_types)]\n+            pub type Oneshot<T> =\n+                ::core::pipes::SendPacketBuffered<super::Oneshot<T>,\n+            super::__Buffer<T>>;\n         }\n \n         #[allow(non_camel_case_types)]\n-        pub type Oneshot<T> =\n-            ::core::pipes::SendPacketBuffered<super::Oneshot<T>,\n-                                              super::__Buffer<T>>;\n+        pub mod server {\n+            #[allow(non_camel_case_types)]\n+            pub type Oneshot<T> =\n+                ::core::pipes::RecvPacketBuffered<super::Oneshot<T>,\n+            super::__Buffer<T>>;\n+        }\n     }\n \n-    #[allow(non_camel_case_types)]\n-    pub mod server {\n-        #[allow(non_camel_case_types)]\n-        pub type Oneshot<T> =\n-            ::core::pipes::RecvPacketBuffered<super::Oneshot<T>,\n-                                              super::__Buffer<T>>;\n+    /// The send end of a oneshot pipe.\n+    pub struct ChanOne<T> {\n+        contents: oneshot::client::Oneshot<T>\n     }\n-}\n \n-/// The send end of a oneshot pipe.\n-pub struct ChanOne<T> {\n-    contents: oneshot::client::Oneshot<T>\n-}\n+    impl<T> ChanOne<T> {\n+        pub fn new(contents: oneshot::client::Oneshot<T>) -> ChanOne<T> {\n+            ChanOne {\n+                contents: contents\n+            }\n+        }\n+    }\n+\n+    /// The receive end of a oneshot pipe.\n+    pub struct PortOne<T> {\n+        contents: oneshot::server::Oneshot<T>\n+    }\n \n-impl<T> ChanOne<T> {\n-    pub fn new(contents: oneshot::client::Oneshot<T>) -> ChanOne<T> {\n-        ChanOne {\n-            contents: contents\n+    impl<T> PortOne<T> {\n+        pub fn new(contents: oneshot::server::Oneshot<T>) -> PortOne<T> {\n+            PortOne {\n+                contents: contents\n+            }\n         }\n     }\n-}\n \n-/// The receive end of a oneshot pipe.\n-pub struct PortOne<T> {\n-    contents: oneshot::server::Oneshot<T>\n-}\n+    /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n+    pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+        let (chan, port) = oneshot::init();\n+        (PortOne::new(port), ChanOne::new(chan))\n+    }\n \n-impl<T> PortOne<T> {\n-    pub fn new(contents: oneshot::server::Oneshot<T>) -> PortOne<T> {\n-        PortOne {\n-            contents: contents\n+    pub impl<T: Owned> PortOne<T> {\n+        fn recv(self) -> T { recv_one(self) }\n+        fn try_recv(self) -> Option<T> { try_recv_one(self) }\n+        fn unwrap(self) -> oneshot::server::Oneshot<T> {\n+            match self {\n+                PortOne { contents: s } => s\n+            }\n         }\n     }\n-}\n \n-/// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n-    let (chan, port) = oneshot::init();\n-    (PortOne::new(port), ChanOne::new(chan))\n-}\n+    pub impl<T: Owned> ChanOne<T> {\n+        fn send(self, data: T) { send_one(self, data) }\n+        fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n+        fn unwrap(self) -> oneshot::client::Oneshot<T> {\n+            match self {\n+                ChanOne { contents: s } => s\n+            }\n+        }\n+    }\n \n-pub impl<T: Owned> PortOne<T> {\n-    fn recv(self) -> T { recv_one(self) }\n-    fn try_recv(self) -> Option<T> { try_recv_one(self) }\n-    fn unwrap(self) -> oneshot::server::Oneshot<T> {\n-        match self {\n-            PortOne { contents: s } => s\n+    /**\n+    * Receive a message from a oneshot pipe, failing if the connection was\n+    * closed.\n+    */\n+    pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n+        match port {\n+            PortOne { contents: port } => {\n+                let oneshot::send(message) = recv(port);\n+                message\n+            }\n         }\n     }\n-}\n \n-pub impl<T: Owned> ChanOne<T> {\n-    fn send(self, data: T) { send_one(self, data) }\n-    fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n-    fn unwrap(self) -> oneshot::client::Oneshot<T> {\n-        match self {\n-            ChanOne { contents: s } => s\n+    /// Receive a message from a oneshot pipe unless the connection was closed.\n+    pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n+        match port {\n+            PortOne { contents: port } => {\n+                let message = try_recv(port);\n+\n+                if message.is_none() {\n+                    None\n+                } else {\n+                    let oneshot::send(message) = message.unwrap();\n+                    Some(message)\n+                }\n+            }\n         }\n     }\n-}\n \n-/**\n- * Receive a message from a oneshot pipe, failing if the connection was\n- * closed.\n- */\n-pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n-    match port {\n-        PortOne { contents: port } => {\n-            let oneshot::send(message) = recv(port);\n-            message\n+    /// Send a message on a oneshot pipe, failing if the connection was closed.\n+    pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n+        match chan {\n+            ChanOne { contents: chan } => oneshot::client::send(chan, data),\n         }\n     }\n-}\n \n-/// Receive a message from a oneshot pipe unless the connection was closed.\n-pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n-    match port {\n-        PortOne { contents: port } => {\n-            let message = try_recv(port);\n+    /**\n+    * Send a message on a oneshot pipe, or return false if the connection was\n+    * closed.\n+    */\n+    pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n+        match chan {\n+            ChanOne { contents: chan } => {\n+                oneshot::client::try_send(chan, data).is_some()\n+            }\n+        }\n+    }\n+\n+    // Streams - Make pipes a little easier in general.\n+\n+    /*proto! streamp (\n+        Open:send<T: Owned> {\n+            data(T) -> Open<T>\n+        }\n+    )*/\n+\n+    #[allow(non_camel_case_types)]\n+    pub mod streamp {\n+        priv use core::kinds::Owned;\n+\n+        pub fn init<T: Owned>() -> (client::Open<T>, server::Open<T>) {\n+            pub use core::pipes::HasBuffer;\n+            ::core::pipes::entangle()\n+        }\n+\n+        #[allow(non_camel_case_types)]\n+        pub enum Open<T> { pub data(T, server::Open<T>), }\n+\n+        #[allow(non_camel_case_types)]\n+        pub mod client {\n+            priv use core::kinds::Owned;\n+\n+            #[allow(non_camel_case_types)]\n+            pub fn try_data<T: Owned>(pipe: Open<T>, x_0: T) ->\n+                ::core::option::Option<Open<T>> {\n+                {\n+                    use super::data;\n+                    let (c, s) = ::core::pipes::entangle();\n+                    let message = data(x_0, s);\n+                    if ::core::pipes::send(pipe, message) {\n+                        ::core::pipes::rt::make_some(c)\n+                    } else { ::core::pipes::rt::make_none() }\n+                }\n+            }\n \n-            if message.is_none() {\n-                None\n-            } else {\n-                let oneshot::send(message) = message.unwrap();\n-                Some(message)\n+            #[allow(non_camel_case_types)]\n+            pub fn data<T: Owned>(pipe: Open<T>, x_0: T) -> Open<T> {\n+                {\n+                    use super::data;\n+                    let (c, s) = ::core::pipes::entangle();\n+                    let message = data(x_0, s);\n+                    ::core::pipes::send(pipe, message);\n+                    c\n+                }\n             }\n+\n+            #[allow(non_camel_case_types)]\n+            pub type Open<T> = ::core::pipes::SendPacket<super::Open<T>>;\n+        }\n+\n+        #[allow(non_camel_case_types)]\n+        pub mod server {\n+            #[allow(non_camel_case_types)]\n+            pub type Open<T> = ::core::pipes::RecvPacket<super::Open<T>>;\n         }\n     }\n-}\n \n-/// Send a message on a oneshot pipe, failing if the connection was closed.\n-pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n-    match chan {\n-        ChanOne { contents: chan } => oneshot::client::send(chan, data),\n+    /// An endpoint that can send many messages.\n+    #[unsafe_mut_field(endp)]\n+    pub struct Chan<T> {\n+        endp: Option<streamp::client::Open<T>>\n     }\n-}\n \n-/**\n- * Send a message on a oneshot pipe, or return false if the connection was\n- * closed.\n- */\n-pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n-    match chan {\n-        ChanOne { contents: chan } => {\n-            oneshot::client::try_send(chan, data).is_some()\n+    /// An endpoint that can receive many messages.\n+    #[unsafe_mut_field(endp)]\n+    pub struct Port<T> {\n+        endp: Option<streamp::server::Open<T>>,\n+    }\n+\n+    /** Creates a `(Port, Chan)` pair.\n+\n+    These allow sending or receiving an unlimited number of messages.\n+\n+    */\n+    pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n+        let (c, s) = streamp::init();\n+\n+        (Port {\n+            endp: Some(s)\n+        }, Chan {\n+            endp: Some(c)\n+        })\n+    }\n+\n+    impl<T: Owned> GenericChan<T> for Chan<T> {\n+        #[inline(always)]\n+        fn send(&self, x: T) {\n+            unsafe {\n+                let self_endp = transmute_mut(&self.endp);\n+                let endp = replace(self_endp, None);\n+                *self_endp = Some(streamp::client::data(endp.unwrap(), x))\n+            }\n         }\n     }\n-}\n \n+    impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+        #[inline(always)]\n+        fn try_send(&self, x: T) -> bool {\n+            unsafe {\n+                let self_endp = transmute_mut(&self.endp);\n+                let endp = replace(self_endp, None);\n+                match streamp::client::try_data(endp.unwrap(), x) {\n+                    Some(next) => {\n+                        *self_endp = Some(next);\n+                        true\n+                    }\n+                    None => false\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<T: Owned> GenericPort<T> for Port<T> {\n+        #[inline(always)]\n+        fn recv(&self) -> T {\n+            unsafe {\n+                let self_endp = transmute_mut(&self.endp);\n+                let endp = replace(self_endp, None);\n+                let streamp::data(x, endp) = recv(endp.unwrap());\n+                *self_endp = Some(endp);\n+                x\n+            }\n+        }\n+\n+        #[inline(always)]\n+        fn try_recv(&self) -> Option<T> {\n+            unsafe {\n+                let self_endp = transmute_mut(&self.endp);\n+                let endp = replace(self_endp, None);\n+                match try_recv(endp.unwrap()) {\n+                    Some(streamp::data(x, endp)) => {\n+                        *self_endp = Some(endp);\n+                        Some(x)\n+                    }\n+                    None => None\n+                }\n+            }\n+        }\n+    }\n \n+    impl<T: Owned> Peekable<T> for Port<T> {\n+        #[inline(always)]\n+        fn peek(&self) -> bool {\n+            unsafe {\n+                let self_endp = transmute_mut(&self.endp);\n+                let mut endp = replace(self_endp, None);\n+                let peek = match endp {\n+                    Some(ref mut endp) => peek(endp),\n+                    None => fail!(\"peeking empty stream\")\n+                };\n+                *self_endp = endp;\n+                peek\n+            }\n+        }\n+    }\n+\n+    impl<T: Owned> Selectable for Port<T> {\n+        fn header(&mut self) -> *mut PacketHeader {\n+            match self.endp {\n+                Some(ref mut endp) => endp.header(),\n+                None => fail!(\"peeking empty stream\")\n+            }\n+    }\n+}\n+\n+}\n \n /// Returns the index of an endpoint that is ready to receive.\n pub fn selecti<T: Selectable>(endpoints: &mut [T]) -> uint {"}, {"sha": "eb94e9ca0286962293d31861eb7930c5158fb04c", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -205,8 +205,11 @@ mod unicode;\n #[path = \"num/cmath.rs\"]\n mod cmath;\n mod stackwalk;\n+\n+// XXX: This shouldn't be pub, and it should be reexported under 'unstable'\n+// but name resolution doesn't work without it being pub.\n #[path = \"rt/mod.rs\"]\n-mod rt;\n+pub mod rt;\n \n // A curious inner-module that's not exported that contains the binding\n // 'core' so that macro-expanded references to core::error and such"}, {"sha": "b192333999ac46be29cead81ec737d6108771a89", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -10,17 +10,16 @@\n \n //! Logging\n \n-pub mod rustrt {\n-    use libc;\n-\n-    pub extern {\n-        unsafe fn rust_log_console_on();\n-        unsafe fn rust_log_console_off();\n-        unsafe fn rust_log_str(level: u32,\n-                               string: *libc::c_char,\n-                               size: libc::size_t);\n-    }\n-}\n+use option::*;\n+use either::*;\n+use rt;\n+use rt::logging::{Logger, StdErrLogger};\n+use io;\n+use libc;\n+use repr;\n+use vec;\n+use cast;\n+use str;\n \n /// Turns on logging to stdout globally\n pub fn console_on() {\n@@ -55,8 +54,46 @@ pub fn log_type<T>(level: u32, object: &T) {\n     let bytes = do io::with_bytes_writer |writer| {\n         repr::write_repr(writer, object);\n     };\n+\n+    match rt::context() {\n+        rt::OldTaskContext => {\n+            unsafe {\n+                let len = bytes.len() as libc::size_t;\n+                rustrt::rust_log_str(level, cast::transmute(vec::raw::to_ptr(bytes)), len);\n+            }\n+        }\n+        _ => {\n+            // XXX: Bad allocation\n+            let msg = str::from_bytes(bytes);\n+            newsched_log_str(msg);\n+        }\n+    }\n+}\n+\n+fn newsched_log_str(msg: ~str) {\n     unsafe {\n-        let len = bytes.len() as libc::size_t;\n-        rustrt::rust_log_str(level, transmute(vec::raw::to_ptr(bytes)), len);\n+        match rt::local_services::unsafe_try_borrow_local_services() {\n+            Some(local) => {\n+                // Use the available logger\n+                (*local).logger.log(Left(msg));\n+            }\n+            None => {\n+                // There is no logger anywhere, just write to stderr\n+                let mut logger = StdErrLogger;\n+                logger.log(Left(msg));\n+            }\n+        }\n+    }\n+}\n+\n+pub mod rustrt {\n+    use libc;\n+\n+    pub extern {\n+        unsafe fn rust_log_console_on();\n+        unsafe fn rust_log_console_off();\n+        unsafe fn rust_log_str(level: u32,\n+                               string: *libc::c_char,\n+                               size: libc::size_t);\n     }\n }"}, {"sha": "fda48b6ffb7d9140c845846ab0b90fefb5d26651", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -30,10 +30,24 @@ macro_rules! rtdebug (\n     ($( $arg:expr),+) => ( $(let _ = $arg)*; )\n )\n \n+macro_rules! rtassert (\n+    ( $arg:expr ) => ( {\n+        if !$arg {\n+            abort!(\"assertion failed: %s\", stringify!($arg));\n+        }\n+    } )\n+)\n+\n macro_rules! abort(\n     ($( $msg:expr),+) => ( {\n         rtdebug!($($msg),+);\n \n-        unsafe { ::libc::abort(); }\n+        do_abort();\n+\n+        // NB: This is in a fn to avoid putting the `unsafe` block in a macro,\n+        // which causes spurious 'unnecessary unsafe block' warnings.\n+        fn do_abort() -> ! {\n+            unsafe { ::libc::abort(); }\n+        }\n     } )\n )"}, {"sha": "72e62c8039204eb1b77aa28877d0bc6fa4f433cc", "filename": "src/libcore/os.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -147,23 +147,25 @@ pub mod win32 {\n \n /*\n Accessing environment variables is not generally threadsafe.\n-This uses a per-runtime lock to serialize access.\n-FIXME #4726: It would probably be appropriate to make this a real global\n+Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: &fn() -> T) -> T {\n-    use unstable::global::global_data_clone_create;\n-    use unstable::sync::{Exclusive, exclusive};\n-\n-    struct SharedValue(());\n-    type ValueMutex = Exclusive<SharedValue>;\n-    fn key(_: ValueMutex) { }\n+    use unstable::finally::Finally;\n \n     unsafe {\n-        let lock: ValueMutex = global_data_clone_create(key, || {\n-            ~exclusive(SharedValue(()))\n-        });\n+        return do (|| {\n+            rust_take_env_lock();\n+            f()\n+        }).finally {\n+            rust_drop_env_lock();\n+        };\n+    }\n \n-        lock.with_imm(|_| f() )\n+    extern {\n+        #[fast_ffi]\n+        fn rust_take_env_lock();\n+        #[fast_ffi]\n+        fn rust_drop_env_lock();\n     }\n }\n \n@@ -749,7 +751,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n             use os::win32::{\n                 as_utf16_p\n             };\n-            use unstable::exchange_alloc::{malloc_raw, free_raw};\n+            use rt::global_heap::{malloc_raw, free_raw};\n             #[nolink]\n             extern {\n                 unsafe fn rust_list_dir_wfd_size() -> libc::size_t;"}, {"sha": "4b5732b2d3aecf7ad6fc017f1e4b25696c218d7f", "filename": "src/libcore/rt/comm.rs", "status": "added", "additions": 625, "deletions": 0, "changes": 625, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcomm.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -0,0 +1,625 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Ports and channels.\n+//!\n+//! XXX: Carefully consider whether the sequentially consistent\n+//! atomics here can be converted to acq/rel. I'm not sure they can,\n+//! because there is data being transerred in both directions (the payload\n+//! goes from sender to receiver and the task pointer goes the other way).\n+\n+use option::*;\n+use cast;\n+use util;\n+use ops::Drop;\n+use kinds::Owned;\n+use rt::sched::Coroutine;\n+use rt::local_sched;\n+#[cfg(stage0)]\n+use unstable::intrinsics::{atomic_xchg};\n+#[cfg(not(stage0))]\n+use unstable::intrinsics::{atomic_xchg, atomic_load};\n+use util::Void;\n+use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n+use cell::Cell;\n+\n+/// A combined refcount / ~Task pointer.\n+///\n+/// Can be equal to the following values:\n+///\n+/// * 2 - both endpoints are alive\n+/// * 1 - either the sender or the receiver is dead, determined by context\n+/// * <ptr> - A pointer to a blocked Task that can be transmuted to ~Task\n+type State = int;\n+\n+static STATE_BOTH: State = 2;\n+static STATE_ONE: State = 1;\n+\n+/// The heap-allocated structure shared between two endpoints.\n+struct Packet<T> {\n+    state: State,\n+    payload: Option<T>,\n+}\n+\n+/// A one-shot channel.\n+pub struct ChanOne<T> {\n+    // XXX: Hack extra allocation to make by-val self work\n+    inner: ~ChanOneHack<T>\n+}\n+\n+\n+/// A one-shot port.\n+pub struct PortOne<T> {\n+    // XXX: Hack extra allocation to make by-val self work\n+    inner: ~PortOneHack<T>\n+}\n+\n+pub struct ChanOneHack<T> {\n+    void_packet: *mut Void,\n+    suppress_finalize: bool\n+}\n+\n+pub struct PortOneHack<T> {\n+    void_packet: *mut Void,\n+    suppress_finalize: bool\n+}\n+\n+pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+    let packet: ~Packet<T> = ~Packet {\n+        state: STATE_BOTH,\n+        payload: None\n+    };\n+\n+    unsafe {\n+        let packet: *mut Void = cast::transmute(packet);\n+        let port = PortOne {\n+            inner: ~PortOneHack {\n+                void_packet: packet,\n+                suppress_finalize: false\n+            }\n+        };\n+        let chan = ChanOne {\n+            inner: ~ChanOneHack {\n+                void_packet: packet,\n+                suppress_finalize: false\n+            }\n+        };\n+        return (port, chan);\n+    }\n+}\n+\n+impl<T> ChanOne<T> {\n+\n+    pub fn send(self, val: T) {\n+        self.try_send(val);\n+    }\n+\n+    pub fn try_send(self, val: T) -> bool {\n+        let mut this = self;\n+        let mut recvr_active = true;\n+        let packet = this.inner.packet();\n+\n+        unsafe {\n+\n+            // Install the payload\n+            assert!((*packet).payload.is_none());\n+            (*packet).payload = Some(val);\n+\n+            // Atomically swap out the old state to figure out what\n+            // the port's up to, issuing a release barrier to prevent\n+            // reordering of the payload write. This also issues an\n+            // acquire barrier that keeps the subsequent access of the\n+            // ~Task pointer from being reordered.\n+            let oldstate = atomic_xchg(&mut (*packet).state, STATE_ONE);\n+            match oldstate {\n+                STATE_BOTH => {\n+                    // Port is not waiting yet. Nothing to do\n+                }\n+                STATE_ONE => {\n+                    // Port has closed. Need to clean up.\n+                    let _packet: ~Packet<T> = cast::transmute(this.inner.void_packet);\n+                    recvr_active = false;\n+                }\n+                task_as_state => {\n+                    // Port is blocked. Wake it up.\n+                    let recvr: ~Coroutine = cast::transmute(task_as_state);\n+                    let sched = local_sched::take();\n+                    sched.schedule_task(recvr);\n+                }\n+            }\n+        }\n+\n+        // Suppress the synchronizing actions in the finalizer. We're done with the packet.\n+        this.inner.suppress_finalize = true;\n+        return recvr_active;\n+    }\n+}\n+\n+\n+impl<T> PortOne<T> {\n+    pub fn recv(self) -> T {\n+        match self.try_recv() {\n+            Some(val) => val,\n+            None => {\n+                fail!(\"receiving on closed channel\");\n+            }\n+        }\n+    }\n+\n+    pub fn try_recv(self) -> Option<T> {\n+        let mut this = self;\n+        let packet = this.inner.packet();\n+\n+        // XXX: Optimize this to not require the two context switches when data is available\n+\n+        // Switch to the scheduler to put the ~Task into the Packet state.\n+        let sched = local_sched::take();\n+        do sched.deschedule_running_task_and_then |task| {\n+            unsafe {\n+                // Atomically swap the task pointer into the Packet state, issuing\n+                // an acquire barrier to prevent reordering of the subsequent read\n+                // of the payload. Also issues a release barrier to prevent reordering\n+                // of any previous writes to the task structure.\n+                let task_as_state: State = cast::transmute(task);\n+                let oldstate = atomic_xchg(&mut (*packet).state, task_as_state);\n+                match oldstate {\n+                    STATE_BOTH => {\n+                        // Data has not been sent. Now we're blocked.\n+                    }\n+                    STATE_ONE => {\n+                        // Channel is closed. Switch back and check the data.\n+                        let task: ~Coroutine = cast::transmute(task_as_state);\n+                        let sched = local_sched::take();\n+                        sched.resume_task_immediately(task);\n+                    }\n+                    _ => util::unreachable()\n+                }\n+            }\n+        }\n+\n+        // Task resumes.\n+\n+        // No further memory barrier is needed here to access the\n+        // payload. Some scenarios:\n+        //\n+        // 1) We encountered STATE_ONE above - the atomic_xchg was the acq barrier. We're fine.\n+        // 2) We encountered STATE_BOTH above and blocked. The sending task then ran us\n+        //    and ran on its thread. The sending task issued a read barrier when taking the\n+        //    pointer to the receiving task.\n+        // 3) We encountered STATE_BOTH above and blocked, but the receiving task (this task)\n+        //    is pinned to some other scheduler, so the sending task had to give us to\n+        //    a different scheduler for resuming. That send synchronized memory.\n+\n+        unsafe {\n+            let payload = util::replace(&mut (*packet).payload, None);\n+\n+            // The sender has closed up shop. Drop the packet.\n+            let _packet: ~Packet<T> = cast::transmute(this.inner.void_packet);\n+            // Suppress the synchronizing actions in the finalizer. We're done with the packet.\n+            this.inner.suppress_finalize = true;\n+            return payload;\n+        }\n+    }\n+}\n+\n+impl<T> Peekable<T> for PortOne<T> {\n+    #[cfg(stage0)]\n+    fn peek(&self) -> bool { fail!() }\n+\n+    #[cfg(not(stage0))]\n+    fn peek(&self) -> bool {\n+        unsafe {\n+            let packet: *mut Packet<T> = self.inner.packet();\n+            let oldstate = atomic_load(&mut (*packet).state);\n+            match oldstate {\n+                STATE_BOTH => false,\n+                STATE_ONE => (*packet).payload.is_some(),\n+                _ => util::unreachable()\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for ChanOneHack<T> {\n+    fn finalize(&self) {\n+        if self.suppress_finalize { return }\n+\n+        unsafe {\n+            let this = cast::transmute_mut(self);\n+            let oldstate = atomic_xchg(&mut (*this.packet()).state, STATE_ONE);\n+            match oldstate {\n+                STATE_BOTH => {\n+                    // Port still active. It will destroy the Packet.\n+                },\n+                STATE_ONE => {\n+                    let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n+                },\n+                task_as_state => {\n+                    // The port is blocked waiting for a message we will never send. Wake it.\n+                    assert!((*this.packet()).payload.is_none());\n+                    let recvr: ~Coroutine = cast::transmute(task_as_state);\n+                    let sched = local_sched::take();\n+                    sched.schedule_task(recvr);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for PortOneHack<T> {\n+    fn finalize(&self) {\n+        if self.suppress_finalize { return }\n+\n+        unsafe {\n+            let this = cast::transmute_mut(self);\n+            let oldstate = atomic_xchg(&mut (*this.packet()).state, STATE_ONE);\n+            match oldstate {\n+                STATE_BOTH => {\n+                    // Chan still active. It will destroy the packet.\n+                },\n+                STATE_ONE => {\n+                    let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n+                }\n+                _ => {\n+                    util::unreachable()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> ChanOneHack<T> {\n+    fn packet(&self) -> *mut Packet<T> {\n+        unsafe {\n+            let p: *mut ~Packet<T> = cast::transmute(&self.void_packet);\n+            let p: *mut Packet<T> = &mut **p;\n+            return p;\n+        }\n+    }\n+}\n+\n+impl<T> PortOneHack<T> {\n+    fn packet(&self) -> *mut Packet<T> {\n+        unsafe {\n+            let p: *mut ~Packet<T> = cast::transmute(&self.void_packet);\n+            let p: *mut Packet<T> = &mut **p;\n+            return p;\n+        }\n+    }\n+}\n+\n+struct StreamPayload<T> {\n+    val: T,\n+    next: PortOne<StreamPayload<T>>\n+}\n+\n+/// A channel with unbounded size.\n+pub struct Chan<T> {\n+    // FIXME #5372. Using Cell because we don't take &mut self\n+    next: Cell<ChanOne<StreamPayload<T>>>\n+}\n+\n+/// An port with unbounded size.\n+pub struct Port<T> {\n+    // FIXME #5372. Using Cell because we don't take &mut self\n+    next: Cell<PortOne<StreamPayload<T>>>\n+}\n+\n+pub fn stream<T: Owned>() -> (Port<T>, Chan<T>) {\n+    let (pone, cone) = oneshot();\n+    let port = Port { next: Cell(pone) };\n+    let chan = Chan { next: Cell(cone) };\n+    return (port, chan);\n+}\n+\n+impl<T: Owned> GenericChan<T> for Chan<T> {\n+    fn send(&self, val: T) {\n+        self.try_send(val);\n+    }\n+}\n+\n+impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+    fn try_send(&self, val: T) -> bool {\n+        let (next_pone, next_cone) = oneshot();\n+        let cone = self.next.take();\n+        self.next.put_back(next_cone);\n+        cone.try_send(StreamPayload { val: val, next: next_pone })\n+    }\n+}\n+\n+impl<T> GenericPort<T> for Port<T> {\n+    fn recv(&self) -> T {\n+        match self.try_recv() {\n+            Some(val) => val,\n+            None => {\n+                fail!(\"receiving on closed channel\");\n+            }\n+        }\n+    }\n+\n+    fn try_recv(&self) -> Option<T> {\n+        let pone = self.next.take();\n+        match pone.try_recv() {\n+            Some(StreamPayload { val, next }) => {\n+                self.next.put_back(next);\n+                Some(val)\n+            }\n+            None => None\n+        }\n+    }\n+}\n+\n+impl<T> Peekable<T> for Port<T> {\n+    fn peek(&self) -> bool {\n+        self.next.with_mut_ref(|p| p.peek())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use option::*;\n+    use rt::test::*;\n+    use cell::Cell;\n+    use iter::Times;\n+\n+    #[test]\n+    fn oneshot_single_thread_close_port_first() {\n+        // Simple test of closing without sending\n+        do run_in_newsched_task {\n+            let (port, _chan) = oneshot::<int>();\n+            { let _p = port; }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_close_chan_first() {\n+        // Simple test of closing without sending\n+        do run_in_newsched_task {\n+            let (_port, chan) = oneshot::<int>();\n+            { let _c = chan; }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_send_port_close() {\n+        // Testing that the sender cleans up the payload if receiver is closed\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<~int>();\n+            { let _p = port; }\n+            chan.send(~0);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_recv_chan_close() {\n+        // Receiving on a closed chan will fail\n+        do run_in_newsched_task {\n+            let res = do spawntask_try {\n+                let (port, chan) = oneshot::<~int>();\n+                { let _c = chan; }\n+                port.recv();\n+            };\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_send_then_recv() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<~int>();\n+            chan.send(~10);\n+            assert!(port.recv() == ~10);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_send_open() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            assert!(chan.try_send(10));\n+            assert!(port.recv() == 10);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_send_closed() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            { let _p = port; }\n+            assert!(!chan.try_send(10));\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_recv_open() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            chan.send(10);\n+            assert!(port.try_recv() == Some(10));\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_recv_closed() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            { let _c = chan; }\n+            assert!(port.try_recv() == None);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_peek_data() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            assert!(!port.peek());\n+            chan.send(10);\n+            assert!(port.peek());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_peek_close() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            { let _c = chan; }\n+            assert!(!port.peek());\n+            assert!(!port.peek());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_peek_open() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<int>();\n+            assert!(!port.peek());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_task_recv_then_send() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<~int>();\n+            let port_cell = Cell(port);\n+            do spawntask_immediately {\n+                assert!(port_cell.take().recv() == ~10);\n+            }\n+\n+            chan.send(~10);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_task_recv_then_close() {\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot::<~int>();\n+            let port_cell = Cell(port);\n+            let chan_cell = Cell(chan);\n+            do spawntask_later {\n+                let _cell = chan_cell.take();\n+            }\n+            let res = do spawntask_try {\n+                assert!(port_cell.take().recv() == ~10);\n+            };\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_close_stress() {\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = oneshot::<int>();\n+                let port_cell = Cell(port);\n+                let _thread = do spawntask_thread {\n+                    let _p = port_cell.take();\n+                };\n+                let _chan = chan;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_send_close_stress() {\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = oneshot::<int>();\n+                let chan_cell = Cell(chan);\n+                let port_cell = Cell(port);\n+                let _thread1 = do spawntask_thread {\n+                    let _p = port_cell.take();\n+                };\n+                let _thread2 = do spawntask_thread {\n+                    let c = chan_cell.take();\n+                    c.send(1);\n+                };\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_recv_close_stress() {\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = oneshot::<int>();\n+                let chan_cell = Cell(chan);\n+                let port_cell = Cell(port);\n+                let _thread1 = do spawntask_thread {\n+                    let port_cell = Cell(port_cell.take());\n+                    let res = do spawntask_try {\n+                        port_cell.take().recv();\n+                    };\n+                    assert!(res.is_err());\n+                };\n+                let _thread2 = do spawntask_thread {\n+                    let chan_cell = Cell(chan_cell.take());\n+                    do spawntask {\n+                        chan_cell.take();\n+                    }\n+                };\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_send_recv_stress() {\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = oneshot::<~int>();\n+                let chan_cell = Cell(chan);\n+                let port_cell = Cell(port);\n+                let _thread1 = do spawntask_thread {\n+                    chan_cell.take().send(~10);\n+                };\n+                let _thread2 = do spawntask_thread {\n+                    assert!(port_cell.take().recv() == ~10);\n+                };\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn stream_send_recv_stress() {\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = stream::<~int>();\n+\n+                send(chan, 0);\n+                recv(port, 0);\n+\n+                fn send(chan: Chan<~int>, i: int) {\n+                    if i == 10 { return }\n+\n+                    let chan_cell = Cell(chan);\n+                    let _thread = do spawntask_thread {\n+                        let chan = chan_cell.take();\n+                        chan.send(~i);\n+                        send(chan, i + 1);\n+                    };\n+                }\n+\n+                fn recv(port: Port<~int>, i: int) {\n+                    if i == 10 { return }\n+\n+                    let port_cell = Cell(port);\n+                    let _thread = do spawntask_thread {\n+                        let port = port_cell.take();\n+                        assert!(port.recv() == ~i);\n+                        recv(port, i + 1);\n+                    };\n+                }\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "2add314fd1196df4b50ac3e16717fc80e482e20c", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -84,6 +84,7 @@ pub impl Context {\n }\n \n extern {\n+    #[rust_stack]\n     fn swap_registers(out_regs: *mut Registers, in_regs: *Registers);\n }\n \n@@ -111,9 +112,9 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp:\n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -4);\n \n-    unsafe { *sp = arg as uint; }\n+    unsafe { *sp = arg as uint };\n     let sp = mut_offset(sp, -1);\n-    unsafe { *sp = 0; } // The final return address\n+    unsafe { *sp = 0 }; // The final return address\n \n     regs.esp = sp as u32;\n     regs.eip = fptr as u32;\n@@ -195,7 +196,7 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp:\n \n fn align_down(sp: *mut uint) -> *mut uint {\n     unsafe {\n-        let sp = transmute::<*mut uint, uint>(sp);\n+        let sp: uint = transmute(sp);\n         let sp = sp & !(16 - 1);\n         transmute::<uint, *mut uint>(sp)\n     }"}, {"sha": "ce7ff87b44580c37fc22423cda6de3790a9813d4", "filename": "src/libcore/rt/global_heap.rs", "status": "renamed", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fglobal_heap.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use sys::{TypeDesc, size_of};\n-use libc::{c_void, size_t};\n+use libc::{c_void, size_t, uintptr_t};\n use c_malloc = libc::malloc;\n use c_free = libc::free;\n use managed::raw::{BoxHeaderRepr, BoxRepr};\n@@ -34,7 +34,7 @@ pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n     box.header.prev = null();\n     box.header.next = null();\n \n-    let exchange_count = &mut *rust_get_exchange_count_ptr();\n+    let exchange_count = &mut *exchange_count_ptr();\n     atomic_xadd(exchange_count, 1);\n \n     return transmute(box);\n@@ -52,7 +52,7 @@ pub unsafe fn malloc_raw(size: uint) -> *c_void {\n }\n \n pub unsafe fn free(ptr: *c_void) {\n-    let exchange_count = &mut *rust_get_exchange_count_ptr();\n+    let exchange_count = &mut *exchange_count_ptr();\n     atomic_xsub(exchange_count, 1);\n \n     assert!(ptr.is_not_null());\n@@ -77,7 +77,11 @@ fn align_to(size: uint, align: uint) -> uint {\n     (size + align - 1) & !(align - 1)\n }\n \n+fn exchange_count_ptr() -> *mut int {\n+    // XXX: Need mutable globals\n+    unsafe { transmute(&rust_exchange_count) }\n+}\n+\n extern {\n-    #[rust_stack]\n-    fn rust_get_exchange_count_ptr() -> *mut int;\n+    static rust_exchange_count: uintptr_t;\n }", "previous_filename": "src/libcore/unstable/exchange_alloc.rs"}, {"sha": "ceff2ecd77de065f7e84eadeb7d9e22235380b02", "filename": "src/libcore/rt/io/extensions.rs", "status": "modified", "additions": 667, "deletions": 233, "changes": 900, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fextensions.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -13,22 +13,53 @@\n // XXX: Not sure how this should be structured\n // XXX: Iteration should probably be considered separately\n \n+use uint;\n+use int;\n+use vec;\n+use rt::io::{Reader, Writer};\n+use rt::io::{read_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n+use option::{Option, Some, None};\n+use unstable::finally::Finally;\n+use util;\n+use cast;\n+use io::{u64_to_le_bytes, u64_to_be_bytes};\n+\n pub trait ReaderUtil {\n \n-    /// Reads `len` bytes and gives you back a new vector\n+    /// Reads a single byte. Returns `None` on EOF.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as the `read` method. Returns\n+    /// `None` if the condition is handled.\n+    fn read_byte(&mut self) -> Option<u8>;\n+\n+    /// Reads `len` bytes and appends them to a vector.\n+    ///\n+    /// May push fewer than the requested number of bytes on error\n+    /// or EOF. Returns true on success, false on EOF or error.\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `io_error` condition on error. Returns an empty\n-    /// vector if the condition is handled.\n+    /// Raises the same conditions as `read`. Additionally raises `read_error`\n+    /// on EOF. If `read_error` is handled then `push_bytes` may push less\n+    /// than the requested number of bytes.\n+    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint);\n+\n+    /// Reads `len` bytes and gives you back a new vector of length `len`\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the same conditions as `read`. Additionally raises `read_error`\n+    /// on EOF. If `read_error` is handled then the returned vector may\n+    /// contain less than the requested number of bytes.\n     fn read_bytes(&mut self, len: uint) -> ~[u8];\n \n     /// Reads all remaining bytes from the stream.\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `io_error` condition on error. Returns an empty\n-    /// vector if the condition is handled.\n+    /// Raises the same conditions as the `read` method.\n     fn read_to_end(&mut self) -> ~[u8];\n \n }\n@@ -37,433 +68,836 @@ pub trait ReaderByteConversions {\n     /// Reads `n` little-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_uint_n(&mut self, nbytes: uint) -> u64;\n \n     /// Reads `n` little-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_int_n(&mut self, nbytes: uint) -> i64;\n \n     /// Reads `n` big-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_uint_n(&mut self, nbytes: uint) -> u64;\n \n     /// Reads `n` big-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_int_n(&mut self, nbytes: uint) -> i64;\n \n     /// Reads a little-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_uint(&mut self) -> uint;\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_int(&mut self) -> int;\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_uint(&mut self) -> uint;\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_int(&mut self) -> int;\n \n     /// Reads a big-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_u64(&mut self) -> u64;\n \n     /// Reads a big-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_u32(&mut self) -> u32;\n \n     /// Reads a big-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_u16(&mut self) -> u16;\n \n     /// Reads a big-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_i64(&mut self) -> i64;\n \n     /// Reads a big-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_i32(&mut self) -> i32;\n \n     /// Reads a big-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_i16(&mut self) -> i16;\n \n     /// Reads a big-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_f64(&mut self) -> f64;\n \n     /// Reads a big-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_f32(&mut self) -> f32;\n \n     /// Reads a little-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_u64(&mut self) -> u64;\n \n     /// Reads a little-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_u32(&mut self) -> u32;\n \n     /// Reads a little-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_u16(&mut self) -> u16;\n \n     /// Reads a little-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_i64(&mut self) -> i64;\n \n     /// Reads a little-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_i32(&mut self) -> i32;\n \n     /// Reads a little-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_i16(&mut self) -> i16;\n \n     /// Reads a little-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_f64(&mut self) -> f64;\n \n     /// Reads a little-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_f32(&mut self) -> f32;\n \n     /// Read a u8.\n     ///\n     /// `u8`s are 1 byte.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_u8(&mut self) -> u8;\n \n     /// Read an i8.\n     ///\n     /// `i8`s are 1 byte.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_i8(&mut self) -> i8;\n \n }\n \n pub trait WriterByteConversions {\n     /// Write the result of passing n through `int::to_str_bytes`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_int(&mut self, n: int);\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_uint(&mut self, n: uint);\n \n     /// Write a little-endian uint (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_uint(&mut self, n: uint);\n \n     /// Write a little-endian int (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_int(&mut self, n: int);\n \n     /// Write a big-endian uint (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_uint(&mut self, n: uint);\n \n     /// Write a big-endian int (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_int(&mut self, n: int);\n \n     /// Write a big-endian u64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n-    fn write_be_u64(&mut self, n: u64);\n+    fn write_be_u64_(&mut self, n: u64);\n \n     /// Write a big-endian u32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_u32(&mut self, n: u32);\n \n     /// Write a big-endian u16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_u16(&mut self, n: u16);\n \n     /// Write a big-endian i64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_i64(&mut self, n: i64);\n \n     /// Write a big-endian i32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_i32(&mut self, n: i32);\n \n     /// Write a big-endian i16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_i16(&mut self, n: i16);\n \n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_f64(&mut self, f: f64);\n \n     /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_f32(&mut self, f: f32);\n \n     /// Write a little-endian u64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n-    fn write_le_u64(&mut self, n: u64);\n+    fn write_le_u64_(&mut self, n: u64);\n \n     /// Write a little-endian u32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_u32(&mut self, n: u32);\n \n     /// Write a little-endian u16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_u16(&mut self, n: u16);\n \n     /// Write a little-endian i64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_i64(&mut self, n: i64);\n \n     /// Write a little-endian i32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_i32(&mut self, n: i32);\n \n     /// Write a little-endian i16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_i16(&mut self, n: i16);\n \n     /// Write a little-endian IEEE754 double-precision floating-point\n     /// (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_f64(&mut self, f: f64);\n \n     /// Write a litten-endian IEEE754 single-precision floating-point\n     /// (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_f32(&mut self, f: f32);\n \n     /// Write a u8 (1 byte).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_u8(&mut self, n: u8);\n \n     /// Write a i8 (1 byte).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_i8(&mut self, n: i8);\n }\n+\n+impl<T: Reader> ReaderUtil for T {\n+    fn read_byte(&mut self) -> Option<u8> {\n+        let mut buf = [0];\n+        match self.read(buf) {\n+            Some(0) => {\n+                debug!(\"read 0 bytes. trying again\");\n+                self.read_byte()\n+            }\n+            Some(1) => Some(buf[0]),\n+            Some(_) => util::unreachable(),\n+            None => None\n+        }\n+    }\n+\n+    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) {\n+        unsafe {\n+            let start_len = buf.len();\n+            let mut total_read = 0;\n+\n+            vec::reserve_at_least(buf, start_len + len);\n+            vec::raw::set_len(buf, start_len + len);\n+\n+            do (|| {\n+                while total_read < len {\n+                    let slice = vec::mut_slice(*buf, start_len + total_read, buf.len());\n+                    match self.read(slice) {\n+                        Some(nread) => {\n+                            total_read += nread;\n+                        }\n+                        None => {\n+                            read_error::cond.raise(standard_error(EndOfFile));\n+                            break;\n+                        }\n+                    }\n+                }\n+            }).finally {\n+                vec::raw::set_len(buf, start_len + total_read);\n+            }\n+        }\n+    }\n+\n+    fn read_bytes(&mut self, len: uint) -> ~[u8] {\n+        let mut buf = vec::with_capacity(len);\n+        self.push_bytes(&mut buf, len);\n+        return buf;\n+    }\n+\n+    fn read_to_end(&mut self) -> ~[u8] {\n+        let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n+        let mut keep_reading = true;\n+        do read_error::cond.trap(|e| {\n+            if e.kind == EndOfFile {\n+                keep_reading = false;\n+            } else {\n+                read_error::cond.raise(e)\n+            }\n+        }).in {\n+            while keep_reading {\n+                self.push_bytes(&mut buf, DEFAULT_BUF_SIZE)\n+            }\n+        }\n+        return buf;\n+    }\n+}\n+\n+impl<T: Reader> ReaderByteConversions for T {\n+    fn read_le_uint_n(&mut self, nbytes: uint) -> u64 {\n+        assert!(nbytes > 0 && nbytes <= 8);\n+\n+        let mut val = 0u64, pos = 0, i = nbytes;\n+        while i > 0 {\n+            val += (self.read_u8() as u64) << pos;\n+            pos += 8;\n+            i -= 1;\n+        }\n+        val\n+    }\n+\n+    fn read_le_int_n(&mut self, nbytes: uint) -> i64 {\n+        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n+    }\n+\n+    fn read_be_uint_n(&mut self, nbytes: uint) -> u64 {\n+        assert!(nbytes > 0 && nbytes <= 8);\n+\n+        let mut val = 0u64, i = nbytes;\n+        while i > 0 {\n+            i -= 1;\n+            val += (self.read_u8() as u64) << i * 8;\n+        }\n+        val\n+    }\n+\n+    fn read_be_int_n(&mut self, nbytes: uint) -> i64 {\n+        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n+    }\n+\n+    fn read_le_uint(&mut self) -> uint {\n+        self.read_le_uint_n(uint::bytes) as uint\n+    }\n+\n+    fn read_le_int(&mut self) -> int {\n+        self.read_le_int_n(int::bytes) as int\n+    }\n+\n+    fn read_be_uint(&mut self) -> uint {\n+        self.read_be_uint_n(uint::bytes) as uint\n+    }\n+\n+    fn read_be_int(&mut self) -> int {\n+        self.read_be_int_n(int::bytes) as int\n+    }\n+\n+    fn read_be_u64(&mut self) -> u64 {\n+        self.read_be_uint_n(8) as u64\n+    }\n+\n+    fn read_be_u32(&mut self) -> u32 {\n+        self.read_be_uint_n(4) as u32\n+    }\n+\n+    fn read_be_u16(&mut self) -> u16 {\n+        self.read_be_uint_n(2) as u16\n+    }\n+\n+    fn read_be_i64(&mut self) -> i64 {\n+        self.read_be_int_n(8) as i64\n+    }\n+\n+    fn read_be_i32(&mut self) -> i32 {\n+        self.read_be_int_n(4) as i32\n+    }\n+\n+    fn read_be_i16(&mut self) -> i16 {\n+        self.read_be_int_n(2) as i16\n+    }\n+\n+    fn read_be_f64(&mut self) -> f64 {\n+        unsafe {\n+            cast::transmute::<u64, f64>(self.read_be_u64())\n+        }\n+    }\n+\n+    fn read_be_f32(&mut self) -> f32 {\n+        unsafe {\n+            cast::transmute::<u32, f32>(self.read_be_u32())\n+        }\n+    }\n+\n+    fn read_le_u64(&mut self) -> u64 {\n+        self.read_le_uint_n(8) as u64\n+    }\n+\n+    fn read_le_u32(&mut self) -> u32 {\n+        self.read_le_uint_n(4) as u32\n+    }\n+\n+    fn read_le_u16(&mut self) -> u16 {\n+        self.read_le_uint_n(2) as u16\n+    }\n+\n+    fn read_le_i64(&mut self) -> i64 {\n+        self.read_le_int_n(8) as i64\n+    }\n+\n+    fn read_le_i32(&mut self) -> i32 {\n+        self.read_le_int_n(4) as i32\n+    }\n+\n+    fn read_le_i16(&mut self) -> i16 {\n+        self.read_le_int_n(2) as i16\n+    }\n+\n+    fn read_le_f64(&mut self) -> f64 {\n+        unsafe {\n+            cast::transmute::<u64, f64>(self.read_le_u64())\n+        }\n+    }\n+\n+    fn read_le_f32(&mut self) -> f32 {\n+        unsafe {\n+            cast::transmute::<u32, f32>(self.read_le_u32())\n+        }\n+    }\n+\n+    fn read_u8(&mut self) -> u8 {\n+        match self.read_byte() {\n+            Some(b) => b as u8,\n+            None => 0\n+        }\n+    }\n+\n+    fn read_i8(&mut self) -> i8 {\n+        match self.read_byte() {\n+            Some(b) => b as i8,\n+            None => 0\n+        }\n+    }\n+\n+}\n+\n+impl<T: Writer> WriterByteConversions for T {\n+    fn write_int(&mut self, n: int) {\n+        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n+    }\n+\n+    fn write_uint(&mut self, n: uint) {\n+        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n+    }\n+\n+    fn write_le_uint(&mut self, n: uint) {\n+        u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_le_int(&mut self, n: int) {\n+        u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_be_uint(&mut self, n: uint) {\n+        u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_be_int(&mut self, n: int) {\n+        u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n+    }\n+\n+    fn write_be_u64_(&mut self, n: u64) {\n+        u64_to_be_bytes(n, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_be_u32(&mut self, n: u32) {\n+        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_be_u16(&mut self, n: u16) {\n+        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_be_i64(&mut self, n: i64) {\n+        u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_be_i32(&mut self, n: i32) {\n+        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_be_i16(&mut self, n: i16) {\n+        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_be_f64(&mut self, f: f64) {\n+        unsafe {\n+            self.write_be_u64_(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_be_f32(&mut self, f: f32) {\n+        unsafe {\n+            self.write_be_u32(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_le_u64_(&mut self, n: u64) {\n+        u64_to_le_bytes(n, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_le_u32(&mut self, n: u32) {\n+        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_le_u16(&mut self, n: u16) {\n+        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_le_i64(&mut self, n: i64) {\n+        u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n+    }\n+\n+    fn write_le_i32(&mut self, n: i32) {\n+        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+    }\n+\n+    fn write_le_i16(&mut self, n: i16) {\n+        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+    }\n+\n+    fn write_le_f64(&mut self, f: f64) {\n+        unsafe {\n+            self.write_le_u64_(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_le_f32(&mut self, f: f32) {\n+        unsafe {\n+            self.write_le_u32(cast::transmute(f))\n+        }\n+    }\n+\n+    fn write_u8(&mut self, n: u8) {\n+        self.write([n])\n+    }\n+\n+    fn write_i8(&mut self, n: i8) {\n+        self.write([n as u8])\n+    }\n+}\n+\n+fn extend_sign(val: u64, nbytes: uint) -> i64 {\n+    let shift = (8 - nbytes) * 8;\n+    (val << shift) as i64 >> shift\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{ReaderUtil, ReaderByteConversions, WriterByteConversions};\n+    use u64;\n+    use i32;\n+    use option::{Some, None};\n+    use cell::Cell;\n+    use rt::io::mem::{MemReader, MemWriter};\n+    use rt::io::mock::MockReader;\n+    use rt::io::{read_error, placeholder_error};\n+\n+    #[test]\n+    fn read_byte() {\n+        let mut reader = MemReader::new(~[10]);\n+        let byte = reader.read_byte();\n+        assert!(byte == Some(10));\n+    }\n+\n+    #[test]\n+    fn read_byte_0_bytes() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    Some(0)\n+                } else {\n+                    buf[0] = 10;\n+                    Some(1)\n+                }\n+            }\n+        };\n+        let byte = reader.read_byte();\n+        assert!(byte == Some(10));\n+    }\n+\n+    #[test]\n+    fn read_byte_eof() {\n+        let mut reader = MockReader::new();\n+        reader.read = |_| None;\n+        let byte = reader.read_byte();\n+        assert!(byte == None);\n+    }\n+\n+    #[test]\n+    fn read_byte_error() {\n+        let mut reader = MockReader::new();\n+        reader.read = |_| {\n+            read_error::cond.raise(placeholder_error());\n+            None\n+        };\n+        do read_error::cond.trap(|_| {\n+        }).in {\n+            let byte = reader.read_byte();\n+            assert!(byte == None);\n+        }\n+    }\n+\n+    #[test]\n+    fn read_bytes() {\n+        let mut reader = MemReader::new(~[10, 11, 12, 13]);\n+        let bytes = reader.read_bytes(4);\n+        assert!(bytes == ~[10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    fn read_bytes_partial() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    buf[1] = 11;\n+                    Some(2)\n+                } else {\n+                    buf[0] = 12;\n+                    buf[1] = 13;\n+                    Some(2)\n+                }\n+            }\n+        };\n+        let bytes = reader.read_bytes(4);\n+        assert!(bytes == ~[10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    fn read_bytes_eof() {\n+        let mut reader = MemReader::new(~[10, 11]);\n+        do read_error::cond.trap(|_| {\n+        }).in {\n+            assert!(reader.read_bytes(4) == ~[10, 11]);\n+        }\n+    }\n+\n+    #[test]\n+    fn push_bytes() {\n+        let mut reader = MemReader::new(~[10, 11, 12, 13]);\n+        let mut buf = ~[8, 9];\n+        reader.push_bytes(&mut buf, 4);\n+        assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    fn push_bytes_partial() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    buf[1] = 11;\n+                    Some(2)\n+                } else {\n+                    buf[0] = 12;\n+                    buf[1] = 13;\n+                    Some(2)\n+                }\n+            }\n+        };\n+        let mut buf = ~[8, 9];\n+        reader.push_bytes(&mut buf, 4);\n+        assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    fn push_bytes_eof() {\n+        let mut reader = MemReader::new(~[10, 11]);\n+        let mut buf = ~[8, 9];\n+        do read_error::cond.trap(|_| {\n+        }).in {\n+            reader.push_bytes(&mut buf, 4);\n+            assert!(buf == ~[8, 9, 10, 11]);\n+        }\n+    }\n+\n+    #[test]\n+    fn push_bytes_error() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    Some(1)\n+                } else {\n+                    read_error::cond.raise(placeholder_error());\n+                    None\n+                }\n+            }\n+        };\n+        let mut buf = ~[8, 9];\n+        do read_error::cond.trap(|_| { } ).in {\n+            reader.push_bytes(&mut buf, 4);\n+        }\n+        assert!(buf == ~[8, 9, 10]);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn push_bytes_fail_reset_len() {\n+        use unstable::finally::Finally;\n+\n+        // push_bytes unsafely sets the vector length. This is testing that\n+        // upon failure the length is reset correctly.\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    Some(1)\n+                } else {\n+                    read_error::cond.raise(placeholder_error());\n+                    None\n+                }\n+            }\n+        };\n+        let buf = @mut ~[8, 9];\n+        do (|| {\n+            reader.push_bytes(&mut *buf, 4);\n+        }).finally {\n+            // NB: Using rtassert here to trigger abort on failure since this is a should_fail test\n+            rtassert!(*buf == ~[8, 9, 10]);\n+        }\n+    }\n+\n+    #[test]\n+    fn read_to_end() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    buf[1] = 11;\n+                    Some(2)\n+                } else if *count == 1 {\n+                    *count = 2;\n+                    buf[0] = 12;\n+                    buf[1] = 13;\n+                    Some(2)\n+                } else {\n+                    None\n+                }\n+            }\n+        };\n+        let buf = reader.read_to_end();\n+        assert!(buf == ~[10, 11, 12, 13]);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn read_to_end_error() {\n+        let mut reader = MockReader::new();\n+        let count = Cell(0);\n+        reader.read = |buf| {\n+            do count.with_mut_ref |count| {\n+                if *count == 0 {\n+                    *count = 1;\n+                    buf[0] = 10;\n+                    buf[1] = 11;\n+                    Some(2)\n+                } else {\n+                    read_error::cond.raise(placeholder_error());\n+                    None\n+                }\n+            }\n+        };\n+        let buf = reader.read_to_end();\n+        assert!(buf == ~[10, 11]);\n+    }\n+\n+    // XXX: Some problem with resolve here\n+    /*#[test]\n+    fn test_read_write_le() {\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+        let mut writer = MemWriter::new();\n+        for uints.each |i| {\n+            writer.write_le_u64(*i);\n+        }\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        for uints.each |i| {\n+            assert!(reader.read_le_u64() == *i);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_write_be() {\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+        let mut writer = MemWriter::new();\n+        for uints.each |i| {\n+            writer.write_be_u64(*i);\n+        }\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        for uints.each |i| {\n+            assert!(reader.read_be_u64() == *i);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_be_int_n() {\n+        let ints = [i32::min_value, -123456, -42, -5, 0, 1, i32::max_value];\n+\n+        let mut writer = MemWriter::new();\n+        for ints.each |i| {\n+            writer.write_be_i32(*i);\n+        }\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        for ints.each |i| {\n+            // this tests that the sign extension is working\n+            // (comparing the values as i32 would not test this)\n+            assert!(reader.read_be_int_n(4) == *i as i64);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_f32() {\n+        //big-endian floating-point 8.1250\n+        let buf = ~[0x41, 0x02, 0x00, 0x00];\n+\n+        let mut writer = MemWriter::new();\n+        writer.write(buf);\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        let f = reader.read_be_f32();\n+        assert!(f == 8.1250);\n+    }\n+\n+    #[test]\n+    fn test_read_write_f32() {\n+        let f:f32 = 8.1250;\n+\n+        let mut writer = MemWriter::new();\n+        writer.write_be_f32(f);\n+        writer.write_le_f32(f);\n+\n+        let mut reader = MemReader::new(writer.inner());\n+        assert!(reader.read_be_f32() == 8.1250);\n+        assert!(reader.read_le_f32() == 8.1250);\n+    }*/\n+\n+}"}, {"sha": "1f61cf25fbdd4dc52596aea401a6071e2ed648fe", "filename": "src/libcore/rt/io/file.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Ffile.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::*;\n use super::support::PathLike;\n-use super::{Reader, Writer, Seek, Close};\n+use super::{Reader, Writer, Seek};\n use super::SeekStyle;\n \n /// # XXX\n@@ -69,10 +69,6 @@ impl Seek for FileStream {\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n-impl Close for FileStream {\n-    fn close(&mut self) { fail!() }\n-}\n-\n #[test]\n #[ignore]\n fn super_simple_smoke_test_lets_go_read_some_files_and_have_a_good_time() {"}, {"sha": "b580b752bd985c8242eba880ed6c6d32344a6f7b", "filename": "src/libcore/rt/io/mock.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmock.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use option::{Option, None};\n+use rt::io::{Reader, Writer};\n+\n+pub struct MockReader {\n+    read: ~fn(buf: &mut [u8]) -> Option<uint>,\n+    eof: ~fn() -> bool\n+}\n+\n+impl MockReader {\n+    pub fn new() -> MockReader {\n+        MockReader {\n+            read: |_| None,\n+            eof: || false\n+        }\n+    }\n+}\n+\n+impl Reader for MockReader {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { (self.read)(buf) }\n+    fn eof(&mut self) -> bool { (self.eof)() }\n+}\n+\n+pub struct MockWriter {\n+    write: ~fn(buf: &[u8]),\n+    flush: ~fn()\n+}\n+\n+impl MockWriter {\n+    pub fn new() -> MockWriter {\n+        MockWriter {\n+            write: |_| (),\n+            flush: || ()\n+        }\n+    }\n+}\n+\n+impl Writer for MockWriter {\n+    fn write(&mut self, buf: &[u8]) { (self.write)(buf) }\n+    fn flush(&mut self) { (self.flush)() }\n+}\n\\ No newline at end of file"}, {"sha": "802e069a738f000dfc1ad4a21f6044bd3ebb62aa", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 57, "deletions": 16, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -187,7 +187,7 @@ In particular code written to ignore errors and expect conditions to be unhandle\n will start passing around null or zero objects when wrapped in a condition handler.\n \n * XXX: How should we use condition handlers that return values?\n-\n+* XXX: Should EOF raise default conditions when EOF is not an error?\n \n # Issues withi/o scheduler affinity, work stealing, task pinning\n \n@@ -238,6 +238,7 @@ Out of scope\n * How does I/O relate to the Iterator trait?\n * std::base64 filters\n * Using conditions is a big unknown since we don't have much experience with them\n+* Too many uses of OtherIoError\n \n */\n \n@@ -252,20 +253,26 @@ pub use self::stdio::println;\n \n pub use self::file::FileStream;\n pub use self::net::ip::IpAddr;\n+#[cfg(not(stage0))]\n pub use self::net::tcp::TcpListener;\n+#[cfg(not(stage0))]\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n \n // Some extension traits that all Readers and Writers get.\n+#[cfg(not(stage0))] // Requires condition! fixes\n pub use self::extensions::ReaderUtil;\n+#[cfg(not(stage0))] // Requires condition! fixes\n pub use self::extensions::ReaderByteConversions;\n+#[cfg(not(stage0))] // Requires condition! fixes\n pub use self::extensions::WriterByteConversions;\n \n /// Synchronous, non-blocking file I/O.\n pub mod file;\n \n /// Synchronous, non-blocking network I/O.\n pub mod net {\n+    #[cfg(not(stage0))]\n     pub mod tcp;\n     pub mod udp;\n     pub mod ip;\n@@ -291,6 +298,7 @@ pub mod flate;\n pub mod comm_adapters;\n \n /// Extension traits\n+#[cfg(not(stage0))] // Requires condition! fixes\n mod extensions;\n \n /// Non-I/O things needed by the I/O module\n@@ -312,6 +320,12 @@ pub mod native {\n     }\n }\n \n+/// Mock implementations for testing\n+mod mock;\n+\n+/// The default buffer size for various I/O operations\n+/// XXX: Not pub\n+pub static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n \n /// The type passed to I/O condition handlers to indicate error\n ///\n@@ -326,12 +340,16 @@ pub struct IoError {\n \n #[deriving(Eq)]\n pub enum IoErrorKind {\n+    PreviousIoError,\n+    OtherIoError,\n+    EndOfFile,\n     FileNotFound,\n-    FilePermission,\n+    PermissionDenied,\n     ConnectionFailed,\n     Closed,\n-    OtherIoError,\n-    PreviousIoError\n+    ConnectionRefused,\n+    ConnectionReset,\n+    BrokenPipe\n }\n \n // XXX: Can't put doc comments on macros\n@@ -341,19 +359,36 @@ condition! {\n     /*pub*/ io_error: super::IoError -> ();\n }\n \n+// XXX: Can't put doc comments on macros\n+// Raised by `read` on error\n+condition! {\n+    // FIXME (#6009): uncomment `pub` after expansion support lands.\n+    /*pub*/ read_error: super::IoError -> ();\n+}\n+\n pub trait Reader {\n     /// Read bytes, up to the length of `buf` and place them in `buf`.\n-    /// Returns the number of bytes read, or `None` on EOF.\n+    /// Returns the number of bytes read. The number of bytes read my\n+    /// be less than the number requested, even 0. Returns `None` on EOF.\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `io_error` condition on error, then returns `None`.\n+    /// Raises the `read_error` condition on error. If the condition\n+    /// is handled then no guarantee is made about the number of bytes\n+    /// read and the contents of `buf`. If the condition is handled\n+    /// returns `None` (XXX see below).\n     ///\n     /// # XXX\n     ///\n+    /// * Should raise_default error on eof?\n+    /// * If the condition is handled it should still return the bytes read,\n+    ///   in which case there's no need to return Option - but then you *have*\n+    ///   to install a handler to detect eof.\n+    ///\n     /// This doesn't take a `len` argument like the old `read`.\n     /// Will people often need to slice their vectors to call this\n     /// and will that be annoying?\n+    /// Is it actually possible for 0 bytes to be read successfully?\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint>;\n \n     /// Return whether the Reader has reached the end of the stream.\n@@ -383,16 +418,7 @@ pub trait Writer {\n     fn flush(&mut self);\n }\n \n-/// I/O types that may be closed\n-///\n-/// Any further operations performed on a closed resource will raise\n-/// on `io_error`\n-pub trait Close {\n-    /// Close the I/O resource\n-    fn close(&mut self);\n-}\n-\n-pub trait Stream: Reader + Writer + Close { }\n+pub trait Stream: Reader + Writer { }\n \n pub enum SeekStyle {\n     /// Seek from the beginning of the stream\n@@ -466,6 +492,21 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n                 detail: None\n             }\n         }\n+        EndOfFile => {\n+            IoError {\n+                kind: EndOfFile,\n+                desc: \"End of file\",\n+                detail: None\n+            }\n+        }\n         _ => fail!()\n     }\n }\n+\n+pub fn placeholder_error() -> IoError {\n+    IoError {\n+        kind: OtherIoError,\n+        desc: \"Placeholder error. You shouldn't be seeing this\",\n+        detail: None\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "31c90336a24c28abe506d86dffd6a13d2cd40765", "filename": "src/libcore/rt/io/native/file.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -40,10 +40,6 @@ impl Writer for FileDesc {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for FileDesc {\n-    fn close(&mut self) { fail!() }\n-}\n-\n impl Seek for FileDesc {\n     fn tell(&self) -> u64 { fail!() }\n \n@@ -72,10 +68,6 @@ impl Writer for CFile {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for CFile {\n-    fn close(&mut self) { fail!() }\n-}\n-\n impl Seek for CFile {\n     fn tell(&self) -> u64 { fail!() }\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }"}, {"sha": "a833e92fc10880071f4cd2632db5e8c6910cc99c", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 306, "deletions": 24, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -8,67 +8,349 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n-use super::super::*;\n-use super::ip::IpAddr;\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use rt::sched::local_sched::unsafe_borrow_io;\n+use rt::io::net::ip::IpAddr;\n+use rt::io::{Reader, Writer, Listener};\n+use rt::io::{io_error, read_error, EndOfFile};\n+use rt::rtio::{IoFactory,\n+               RtioTcpListener, RtioTcpListenerObject,\n+               RtioTcpStream, RtioTcpStreamObject};\n \n-pub struct TcpStream;\n+pub struct TcpStream {\n+    rtstream: ~RtioTcpStreamObject\n+}\n \n impl TcpStream {\n-    pub fn connect(_addr: IpAddr) -> Option<TcpStream> {\n-        fail!()\n+    fn new(s: ~RtioTcpStreamObject) -> TcpStream {\n+        TcpStream {\n+            rtstream: s\n+        }\n+    }\n+\n+    pub fn connect(addr: IpAddr) -> Option<TcpStream> {\n+        let stream = unsafe {\n+            rtdebug!(\"borrowing io to connect\");\n+            let io = unsafe_borrow_io();\n+            rtdebug!(\"about to connect\");\n+            (*io).tcp_connect(addr)\n+        };\n+\n+        match stream {\n+            Ok(s) => {\n+                Some(TcpStream::new(s))\n+            }\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to connect: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n     }\n }\n \n impl Reader for TcpStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let bytes_read = self.rtstream.read(buf);\n+        match bytes_read {\n+            Ok(read) => Some(read),\n+            Err(ioerr) => {\n+                // EOF is indicated by returning None\n+                if ioerr.kind != EndOfFile {\n+                    read_error::cond.raise(ioerr);\n+                }\n+                return None;\n+            }\n+        }\n+    }\n \n     fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for TcpStream {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, buf: &[u8]) {\n+        let res = self.rtstream.write(buf);\n+        match res {\n+            Ok(_) => (),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n \n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for TcpStream {\n-    fn close(&mut self) { fail!() }\n+pub struct TcpListener {\n+    rtlistener: ~RtioTcpListenerObject,\n }\n \n-pub struct TcpListener;\n-\n impl TcpListener {\n-    pub fn bind(_addr: IpAddr) -> Option<TcpListener> {\n-        fail!()\n+    pub fn bind(addr: IpAddr) -> Option<TcpListener> {\n+        let listener = unsafe { (*unsafe_borrow_io()).tcp_bind(addr) };\n+        match listener {\n+            Ok(l) => {\n+                Some(TcpListener {\n+                    rtlistener: l\n+                })\n+            }\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n     }\n }\n \n impl Listener<TcpStream> for TcpListener {\n-    fn accept(&mut self) -> Option<TcpStream> { fail!() }\n+    fn accept(&mut self) -> Option<TcpStream> {\n+        let rtstream = self.rtlistener.accept();\n+        match rtstream {\n+            Ok(s) => {\n+                Some(TcpStream::new(s))\n+            }\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n+    }\n }\n \n #[cfg(test)]\n mod test {\n+    use super::*;\n+    use int;\n+    use cell::Cell;\n+    use rt::test::*;\n+    use rt::io::net::ip::Ipv4;\n+    use rt::io::*;\n \n     #[test] #[ignore]\n+    fn bind_error() {\n+        do run_in_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == PermissionDenied);\n+                called = true;\n+            }).in {\n+                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let listener = TcpListener::bind(addr);\n+                assert!(listener.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn connect_error() {\n+        do run_in_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == ConnectionRefused);\n+                called = true;\n+            }).in {\n+                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let stream = TcpStream::connect(addr);\n+                assert!(stream.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n     fn smoke_test() {\n-        /*do run_in_newsched_task {\n+        do run_in_newsched_task {\n             let addr = next_test_ip4();\n \n-            do spawn_immediately {\n-                let listener = TcpListener::bind(addr);\n-                do listener.accept() {\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                stream.read(buf);\n+                assert!(buf[0] == 99);\n+            }\n+\n+            do spawntask_immediately {\n+                let mut stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn read_eof() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn read_eof_twice() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let mut buf = [0];\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+                let nread = stream.read(buf);\n+                assert!(nread.is_none());\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn write_close() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                let mut stream = listener.accept();\n+                let buf = [0];\n+                loop {\n+                    let mut stop = false;\n+                    do io_error::cond.trap(|e| {\n+                        // NB: ECONNRESET on linux, EPIPE on mac\n+                        assert!(e.kind == ConnectionReset || e.kind == BrokenPipe);\n+                        stop = true;\n+                    }).in {\n+                        stream.write(buf);\n+                    }\n+                    if stop { break }\n+                }\n+            }\n+\n+            do spawntask_immediately {\n+                let _stream = TcpStream::connect(addr);\n+                // Close\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_serial() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            let max = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for max.times {\n+                    let mut stream = listener.accept();\n                     let mut buf = [0];\n-                    listener.read(buf);\n+                    stream.read(buf);\n                     assert!(buf[0] == 99);\n                 }\n             }\n \n-            do spawn_immediately {\n-                let stream = TcpStream::connect(addr);\n-                stream.write([99]);\n+            do spawntask_immediately {\n+                for max.times {\n+                    let mut stream = TcpStream::connect(addr);\n+                    stream.write([99]);\n+                }\n             }\n-        }*/\n+        }\n     }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_greedy_schedule() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |i| {\n+                    let stream = Cell(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_immediately {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == i as u8);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_immediately {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([i as u8]);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |_| {\n+                    let stream = Cell(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_later {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == 99);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_later {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([99]);\n+                }\n+            }\n+        }\n+    }\n+\n }"}, {"sha": "bb5457e334ddaf3303ce07ba65f4121e6765db44", "filename": "src/libcore/rt/io/net/udp.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -32,10 +32,6 @@ impl Writer for UdpStream {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for UdpStream {\n-    fn close(&mut self) { fail!() }\n-}\n-\n pub struct UdpListener;\n \n impl UdpListener {"}, {"sha": "b85b7dd059d82f7f1cefd6cae9ac2636d2031858", "filename": "src/libcore/rt/io/net/unix.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -32,10 +32,6 @@ impl Writer for UnixStream {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for UnixStream {\n-    fn close(&mut self) { fail!() }\n-}\n-\n pub struct UnixListener;\n \n impl UnixListener {"}, {"sha": "6ae747f8b4b4c2da517b5c9bdaa6050d4004135e", "filename": "src/libcore/rt/io/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Foption.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -18,7 +18,7 @@\n \n use option::*;\n use super::{Reader, Writer, Listener};\n-use super::{standard_error, PreviousIoError, io_error, IoError};\n+use super::{standard_error, PreviousIoError, io_error, read_error, IoError};\n \n fn prev_io_error() -> IoError {\n     standard_error(PreviousIoError)\n@@ -45,7 +45,7 @@ impl<R: Reader> Reader for Option<R> {\n         match *self {\n             Some(ref mut reader) => reader.read(buf),\n             None => {\n-                io_error::cond.raise(prev_io_error());\n+                read_error::cond.raise(prev_io_error());\n                 None\n             }\n         }\n@@ -79,7 +79,7 @@ mod test {\n     use option::*;\n     use super::super::mem::*;\n     use rt::test::*;\n-    use super::super::{PreviousIoError, io_error};\n+    use super::super::{PreviousIoError, io_error, read_error};\n \n     #[test]\n     fn test_option_writer() {\n@@ -133,7 +133,7 @@ mod test {\n         let mut buf = [];\n \n         let mut called = false;\n-        do io_error::cond.trap(|err| {\n+        do read_error::cond.trap(|err| {\n             assert!(err.kind == PreviousIoError);\n             called = true;\n         }).in {"}, {"sha": "247fe9544088bfa54984725fed476bf9a83d95f4", "filename": "src/libcore/rt/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fstdio.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::{Reader, Writer, Close};\n+use super::{Reader, Writer};\n \n pub fn stdin() -> StdReader { fail!() }\n \n@@ -39,10 +39,6 @@ impl Reader for StdReader {\n     fn eof(&mut self) -> bool { fail!() }\n }\n \n-impl Close for StdReader {\n-    fn close(&mut self) { fail!() }\n-}\n-\n pub struct StdWriter;\n \n impl StdWriter {\n@@ -55,6 +51,3 @@ impl Writer for StdWriter {\n     fn flush(&mut self) { fail!() }\n }\n \n-impl Close for StdWriter {\n-    fn close(&mut self) { fail!() }\n-}"}, {"sha": "895354d2218e568bb5da409088d1815c0a9c0c4e", "filename": "src/libcore/rt/local_sched.rs", "status": "renamed", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_sched.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -13,18 +13,21 @@\n use prelude::*;\n use ptr::mut_null;\n use libc::c_void;\n-use cast::transmute;\n+use cast;\n+use cell::Cell;\n \n-use super::Scheduler;\n-use super::super::rtio::IoFactoryObject;\n-use tls = super::super::thread_local_storage;\n-#[cfg(test)] use super::super::uvio::UvEventLoop;\n+use rt::sched::Scheduler;\n+use rt::rtio::{EventLoop, IoFactoryObject};\n+use tls = rt::thread_local_storage;\n+use unstable::finally::Finally;\n+\n+#[cfg(test)] use rt::uv::uvio::UvEventLoop;\n \n /// Give the Scheduler to thread-local storage\n pub fn put(sched: ~Scheduler) {\n     unsafe {\n         let key = tls_key();\n-        let void_sched: *mut c_void = transmute::<~Scheduler, *mut c_void>(sched);\n+        let void_sched: *mut c_void = cast::transmute(sched);\n         tls::set(key, void_sched);\n     }\n }\n@@ -34,8 +37,8 @@ pub fn take() -> ~Scheduler {\n     unsafe {\n         let key = tls_key();\n         let void_sched: *mut c_void = tls::get(key);\n-        assert!(void_sched.is_not_null());\n-        let sched = transmute::<*mut c_void, ~Scheduler>(void_sched);\n+        rtassert!(void_sched.is_not_null());\n+        let sched: ~Scheduler = cast::transmute(void_sched);\n         tls::set(key, mut_null());\n         return sched;\n     }\n@@ -55,8 +58,18 @@ pub fn exists() -> bool {\n /// While the scheduler is borrowed it is not available in TLS.\n pub fn borrow(f: &fn(&mut Scheduler)) {\n     let mut sched = take();\n-    f(sched);\n-    put(sched);\n+\n+    // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n+    unsafe {\n+        let unsafe_sched = cast::transmute_mut_region(&mut *sched);\n+        let sched = Cell(sched);\n+\n+        do (|| {\n+            f(unsafe_sched);\n+        }).finally {\n+            put(sched.take());\n+        }\n+    }\n }\n \n /// Borrow a mutable reference to the thread-local Scheduler\n@@ -65,33 +78,35 @@ pub fn borrow(f: &fn(&mut Scheduler)) {\n ///\n /// Because this leaves the Scheduler in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n-pub unsafe fn unsafe_borrow() -> &mut Scheduler {\n+pub unsafe fn unsafe_borrow() -> *mut Scheduler {\n     let key = tls_key();\n     let mut void_sched: *mut c_void = tls::get(key);\n-    assert!(void_sched.is_not_null());\n+    rtassert!(void_sched.is_not_null());\n     {\n-        let void_sched_ptr = &mut void_sched;\n-        let sched: &mut ~Scheduler = {\n-            transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n-        };\n-        let sched: &mut Scheduler = &mut **sched;\n+        let sched: *mut *mut c_void = &mut void_sched;\n+        let sched: *mut ~Scheduler = sched as *mut ~Scheduler;\n+        let sched: *mut Scheduler = &mut **sched;\n         return sched;\n     }\n }\n \n-pub unsafe fn unsafe_borrow_io() -> &mut IoFactoryObject {\n+pub unsafe fn unsafe_borrow_io() -> *mut IoFactoryObject {\n     let sched = unsafe_borrow();\n-    return sched.event_loop.io().unwrap();\n+    let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n+    return io;\n }\n \n fn tls_key() -> tls::Key {\n-    maybe_tls_key().get()\n+    match maybe_tls_key() {\n+        Some(key) => key,\n+        None => abort!(\"runtime tls key not initialized\")\n+    }\n }\n \n fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n-        let key: *mut c_void = rust_get_sched_tls_key();\n-        let key: &mut tls::Key = transmute(key);\n+        let key: *mut c_void = rust_get_rt_tls_key();\n+        let key: &mut tls::Key = cast::transmute(key);\n         let key = *key;\n         // Check that the key has been initialized.\n \n@@ -105,7 +120,7 @@ fn maybe_tls_key() -> Option<tls::Key> {\n         // another thread. I think this is fine since the only action\n         // they could take if it was initialized would be to check the\n         // thread-local value and see that it's not set.\n-        if key != 0 {\n+        if key != -1 {\n             return Some(key);\n         } else {\n             return None;\n@@ -114,7 +129,8 @@ fn maybe_tls_key() -> Option<tls::Key> {\n }\n \n extern {\n-    fn rust_get_sched_tls_key() -> *mut c_void;\n+    #[fast_ffi]\n+    fn rust_get_rt_tls_key() -> *mut c_void;\n }\n \n #[test]", "previous_filename": "src/libcore/rt/sched/local_sched.rs"}, {"sha": "8d6873be8cd564e429fa86e81a5c5325ec2f1ef2", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -23,19 +23,19 @@ use libc::{c_void, uintptr_t};\n use cast::transmute;\n use super::sched::local_sched;\n use super::local_heap::LocalHeap;\n+use rt::logging::StdErrLogger;\n \n pub struct LocalServices {\n     heap: LocalHeap,\n     gc: GarbageCollector,\n     storage: LocalStorage,\n-    logger: Logger,\n+    logger: StdErrLogger,\n     unwinder: Option<Unwinder>,\n     destroyed: bool\n }\n \n pub struct GarbageCollector;\n pub struct LocalStorage(*c_void, Option<~fn(*c_void)>);\n-pub struct Logger;\n \n pub struct Unwinder {\n     unwinding: bool,\n@@ -47,7 +47,7 @@ impl LocalServices {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n-            logger: Logger,\n+            logger: StdErrLogger,\n             unwinder: Some(Unwinder { unwinding: false }),\n             destroyed: false\n         }\n@@ -58,7 +58,7 @@ impl LocalServices {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n-            logger: Logger,\n+            logger: StdErrLogger,\n             unwinder: None,\n             destroyed: false\n         }\n@@ -169,19 +169,27 @@ pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n     }\n }\n \n-pub unsafe fn unsafe_borrow_local_services() -> &mut LocalServices {\n-    use cast::transmute_mut_region;\n-\n-    match local_sched::unsafe_borrow().current_task {\n+pub unsafe fn unsafe_borrow_local_services() -> *mut LocalServices {\n+    match (*local_sched::unsafe_borrow()).current_task {\n         Some(~ref mut task) => {\n-            transmute_mut_region(&mut task.local_services)\n+            let s: *mut LocalServices = &mut task.local_services;\n+            return s;\n         }\n         None => {\n-            fail!(\"no local services for schedulers yet\")\n+            // Don't fail. Infinite recursion\n+            abort!(\"no local services for schedulers yet\")\n         }\n     }\n }\n \n+pub unsafe fn unsafe_try_borrow_local_services() -> Option<*mut LocalServices> {\n+    if local_sched::exists() {\n+        Some(unsafe_borrow_local_services())\n+    } else {\n+        None\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use rt::test::*;\n@@ -229,4 +237,34 @@ mod test {\n             let _ = r.next();\n         }\n     }\n+\n+    #[test]\n+    fn logging() {\n+        do run_in_newsched_task() {\n+            info!(\"here i am. logging in a newsched task\");\n+        }\n+    }\n+\n+    #[test]\n+    fn comm_oneshot() {\n+        use comm::*;\n+\n+        do run_in_newsched_task {\n+            let (port, chan) = oneshot();\n+            send_one(chan, 10);\n+            assert!(recv_one(port) == 10);\n+        }\n+    }\n+\n+    #[test]\n+    fn comm_stream() {\n+        use comm::*;\n+\n+        do run_in_newsched_task() {\n+            let (port, chan) = stream();\n+            chan.send(10);\n+            assert!(port.recv() == 10);\n+        }\n+    }\n }\n+"}, {"sha": "a0d0539768912b1a0c36f7ce23f61a054018bb94", "filename": "src/libcore/rt/logging.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flogging.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use either::*;\n+\n+pub trait Logger {\n+    fn log(&mut self, msg: Either<~str, &'static str>);\n+}\n+\n+pub struct StdErrLogger;\n+\n+impl Logger for StdErrLogger {\n+    fn log(&mut self, msg: Either<~str, &'static str>) {\n+        use io::{Writer, WriterUtil};\n+\n+        let s: &str = match msg {\n+            Left(ref s) => {\n+                let s: &str = *s;\n+                s\n+            }\n+            Right(ref s) => {\n+                let s: &str = *s;\n+                s\n+            }\n+        };\n+        let dbg = ::libc::STDERR_FILENO as ::io::fd_t;\n+        dbg.write_str(s);\n+        dbg.write_str(\"\\n\");\n+        dbg.flush();\n+    }\n+}\n+\n+/// Configure logging by traversing the crate map and setting the\n+/// per-module global logging flags based on the logging spec\n+pub fn init(crate_map: *u8) {\n+    use os;\n+    use str;\n+    use ptr;\n+    use option::{Some, None};\n+    use libc::c_char;\n+\n+    let log_spec = os::getenv(\"RUST_LOG\");\n+    match log_spec {\n+        Some(spec) => {\n+            do str::as_c_str(spec) |s| {\n+                unsafe {\n+                    rust_update_log_settings(crate_map, s);\n+                }\n+            }\n+        }\n+        None => {\n+            unsafe {\n+                rust_update_log_settings(crate_map, ptr::null());\n+            }\n+        }\n+    }\n+\n+    extern {\n+        fn rust_update_log_settings(crate_map: *u8, settings: *c_char);\n+    }\n+}"}, {"sha": "dab627188d0f57dd9467c365b91376a1239b6b51", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 133, "deletions": 38, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -8,70 +8,164 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! The Rust runtime, including the scheduler and I/O interface */\n+/*! The Rust Runtime, including the task scheduler and I/O\n+\n+The `rt` module provides the private runtime infrastructure necessary\n+to support core language features like the exchange and local heap,\n+the garbage collector, logging, local data and unwinding. It also\n+implements the default task scheduler and task model. Initialization\n+routines are provided for setting up runtime resources in common\n+configurations, including that used by `rustc` when generating\n+executables.\n+\n+It is intended that the features provided by `rt` can be factored in a\n+way such that the core library can be built with different 'profiles'\n+for different use cases, e.g. excluding the task scheduler. A number\n+of runtime features though are critical to the functioning of the\n+language and an implementation must be provided regardless of the\n+execution environment.\n+\n+Of foremost importance is the global exchange heap, in the module\n+`global_heap`. Very little practical Rust code can be written without\n+access to the global heap. Unlike most of `rt` the global heap is\n+truly a global resource and generally operates independently of the\n+rest of the runtime.\n+\n+All other runtime features are 'local', either thread-local or\n+task-local.  Those critical to the functioning of the language are\n+defined in the module `local_services`. Local services are those which\n+are expected to be available to Rust code generally but rely on\n+thread- or task-local state. These currently include the local heap,\n+the garbage collector, local storage, logging and the stack unwinder.\n+Local services are primarily implemented for tasks, but may also\n+be implemented for use outside of tasks.\n+\n+The relationship between `rt` and the rest of the core library is\n+not entirely clear yet and some modules will be moving into or\n+out of `rt` as development proceeds.\n+\n+Several modules in `core` are clients of `rt`:\n+\n+* `core::task` - The user-facing interface to the Rust task model.\n+* `core::task::local_data` - The interface to local data.\n+* `core::gc` - The garbage collector.\n+* `core::unstable::lang` - Miscellaneous lang items, some of which rely on `core::rt`.\n+* `core::condition` - Uses local data.\n+* `core::cleanup` - Local heap destruction.\n+* `core::io` - In the future `core::io` will use an `rt` implementation.\n+* `core::logging`\n+* `core::pipes`\n+* `core::comm`\n+* `core::stackwalk`\n+\n+*/\n \n #[doc(hidden)];\n \n-use libc::c_char;\n use ptr::Ptr;\n \n-#[path = \"sched/mod.rs\"]\n+/// The global (exchange) heap.\n+pub mod global_heap;\n+\n+/// The Scheduler and Coroutine types.\n mod sched;\n+\n+/// Thread-local access to the current Scheduler.\n+pub mod local_sched;\n+\n+/// Synchronous I/O.\n+#[path = \"io/mod.rs\"]\n+pub mod io;\n+\n+/// Thread-local implementations of language-critical runtime features like @.\n+pub mod local_services;\n+\n+/// The EventLoop and internal synchronous I/O interface.\n mod rtio;\n-pub mod uvll;\n-mod uvio;\n+\n+/// libuv and default rtio implementation.\n #[path = \"uv/mod.rs\"]\n-mod uv;\n-#[path = \"io/mod.rs\"]\n-mod io;\n+pub mod uv;\n+\n // FIXME #5248: The import in `sched` doesn't resolve unless this is pub!\n+/// Bindings to pthread/windows thread-local storage.\n pub mod thread_local_storage;\n+\n+/// A parallel work-stealing dequeue.\n mod work_queue;\n+\n+/// Stack segments and caching.\n mod stack;\n+\n+/// CPU context swapping.\n mod context;\n+\n+/// Bindings to system threading libraries.\n mod thread;\n+\n+/// The runtime configuration, read from environment variables\n pub mod env;\n-pub mod local_services;\n+\n+/// The local, managed heap\n mod local_heap;\n \n+/// The Logger trait and implementations\n+pub mod logging;\n+\n /// Tools for testing the runtime\n-#[cfg(test)]\n pub mod test;\n \n-pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n-\n-    use self::sched::{Scheduler, Task};\n-    use self::uvio::UvEventLoop;\n-    use sys::Closure;\n-    use ptr;\n-    use cast;\n+/// Reference counting\n+pub mod rc;\n+\n+/// A simple single-threaded channel type for passing buffered data between\n+/// scheduler and task context\n+pub mod tube;\n+\n+/// Simple reimplementation of core::comm\n+pub mod comm;\n+\n+/// Set up a default runtime configuration, given compiler-supplied arguments.\n+///\n+/// This is invoked by the `start` _language item_ (unstable::lang) to\n+/// run a Rust executable.\n+///\n+/// # Arguments\n+///\n+/// * `argc` & `argv` - The argument vector. On Unix this information is used\n+///   by os::args.\n+/// * `crate_map` - Runtime information about the executing crate, mostly for logging\n+///\n+/// # Return value\n+///\n+/// The return value is used as the process return code. 0 on success, 101 on error.\n+pub fn start(_argc: int, _argv: **u8, crate_map: *u8, main: ~fn()) -> int {\n+\n+    use self::sched::{Scheduler, Coroutine};\n+    use self::uv::uvio::UvEventLoop;\n+\n+    init(crate_map);\n \n     let loop_ = ~UvEventLoop::new();\n     let mut sched = ~Scheduler::new(loop_);\n+    let main_task = ~Coroutine::new(&mut sched.stack_pool, main);\n \n-    let main_task = ~do Task::new(&mut sched.stack_pool) {\n-\n-        unsafe {\n-            // `main` is an `fn() -> ()` that doesn't take an environment\n-            // XXX: Could also call this as an `extern \"Rust\" fn` once they work\n-            let main = Closure {\n-                code: main as *(),\n-                env: ptr::null(),\n-            };\n-            let mainfn: &fn() = cast::transmute(main);\n-\n-            mainfn();\n-        }\n-    };\n-\n-    sched.task_queue.push_back(main_task);\n+    sched.enqueue_task(main_task);\n     sched.run();\n \n     return 0;\n }\n \n+/// One-time runtime initialization. Currently all this does is set up logging\n+/// based on the RUST_LOG environment variable.\n+pub fn init(crate_map: *u8) {\n+    logging::init(crate_map);\n+}\n+\n /// Possible contexts in which Rust code may be executing.\n /// Different runtime services are available depending on context.\n+/// Mostly used for determining if we're using the new scheduler\n+/// or the old scheduler.\n #[deriving(Eq)]\n pub enum RuntimeContext {\n     // Only the exchange heap is available\n@@ -84,6 +178,7 @@ pub enum RuntimeContext {\n     OldTaskContext\n }\n \n+/// Determine the current RuntimeContext\n pub fn context() -> RuntimeContext {\n \n     use task::rt::rust_task;\n@@ -118,26 +213,26 @@ pub fn context() -> RuntimeContext {\n #[test]\n fn test_context() {\n     use unstable::run_in_bare_thread;\n-    use self::sched::{local_sched, Task};\n-    use self::uvio::UvEventLoop;\n+    use self::sched::{local_sched, Coroutine};\n+    use rt::uv::uvio::UvEventLoop;\n     use cell::Cell;\n \n     assert!(context() == OldTaskContext);\n     do run_in_bare_thread {\n         assert!(context() == GlobalContext);\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n+        let task = ~do Coroutine::new(&mut sched.stack_pool) {\n             assert!(context() == TaskContext);\n             let sched = local_sched::take();\n             do sched.deschedule_running_task_and_then() |task| {\n                 assert!(context() == SchedulerContext);\n                 let task = Cell(task);\n                 do local_sched::borrow |sched| {\n-                    sched.task_queue.push_back(task.take());\n+                    sched.enqueue_task(task.take());\n                 }\n             }\n         };\n-        sched.task_queue.push_back(task);\n+        sched.enqueue_task(task);\n         sched.run();\n     }\n }"}, {"sha": "1c0c8c14fdfa6404fa2be80abf552c6a55b26ef8", "filename": "src/libcore/rt/rc.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frc.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An owned, task-local, reference counted type\n+//!\n+//! # Safety note\n+//!\n+//! XXX There is currently no type-system mechanism for enforcing that\n+//! reference counted types are both allocated on the exchange heap\n+//! and also non-sendable\n+//!\n+//! This doesn't prevent borrowing multiple aliasable mutable pointers\n+\n+use ops::Drop;\n+use clone::Clone;\n+use libc::c_void;\n+use cast;\n+\n+pub struct RC<T> {\n+    p: *c_void // ~(uint, T)\n+}\n+\n+impl<T> RC<T> {\n+    pub fn new(val: T) -> RC<T> {\n+        unsafe {\n+            let v = ~(1, val);\n+            let p: *c_void = cast::transmute(v);\n+            RC { p: p }\n+        }\n+    }\n+\n+    fn get_mut_state(&mut self) -> *mut (uint, T) {\n+        unsafe {\n+            let p: &mut ~(uint, T) = cast::transmute(&mut self.p);\n+            let p: *mut (uint, T) = &mut **p;\n+            return p;\n+        }\n+    }\n+\n+    fn get_state(&self) -> *(uint, T) {\n+        unsafe {\n+            let p: &~(uint, T) = cast::transmute(&self.p);\n+            let p: *(uint, T) = &**p;\n+            return p;\n+        }\n+    }\n+\n+    pub fn unsafe_borrow_mut(&mut self) -> *mut T {\n+        unsafe {\n+            match *self.get_mut_state() {\n+                (_, ref mut p) => {\n+                    let p: *mut T = p;\n+                    return p;\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn refcount(&self) -> uint {\n+        unsafe {\n+            match *self.get_state() {\n+                (count, _) => count\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for RC<T> {\n+    fn finalize(&self) {\n+        assert!(self.refcount() > 0);\n+\n+        unsafe {\n+            // XXX: Mutable finalizer\n+            let this: &mut RC<T> = cast::transmute_mut(self);\n+\n+            match *this.get_mut_state() {\n+                (ref mut count, _) => {\n+                    *count = *count - 1\n+                }\n+            }\n+\n+            if this.refcount() == 0 {\n+                let _: ~(uint, T) = cast::transmute(this.p);\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for RC<T> {\n+    fn clone(&self) -> RC<T> {\n+        unsafe {\n+            // XXX: Mutable clone\n+            let this: &mut RC<T> = cast::transmute_mut(self);\n+\n+            match *this.get_mut_state() {\n+                (ref mut count, _) => {\n+                    *count = *count + 1;\n+                }\n+            }\n+        }\n+\n+        RC { p: self.p }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::RC;\n+\n+    #[test]\n+    fn smoke_test() {\n+        unsafe {\n+            let mut v1 = RC::new(100);\n+            assert!(*v1.unsafe_borrow_mut() == 100);\n+            assert!(v1.refcount() == 1);\n+\n+            let mut v2 = v1.clone();\n+            assert!(*v2.unsafe_borrow_mut() == 100);\n+            assert!(v2.refcount() == 2);\n+\n+            *v2.unsafe_borrow_mut() = 200;\n+            assert!(*v2.unsafe_borrow_mut() == 200);\n+            assert!(*v1.unsafe_borrow_mut() == 200);\n+\n+            let v3 = v2.clone();\n+            assert!(v3.refcount() == 3);\n+            {\n+                let _v1 = v1;\n+                let _v2 = v2;\n+            }\n+            assert!(v3.refcount() == 1);\n+        }\n+    }\n+}"}, {"sha": "4b5eda22ff5de7999534237995f56ab875405dab", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -11,32 +11,35 @@\n use option::*;\n use result::*;\n \n+use rt::io::IoError;\n use super::io::net::ip::IpAddr;\n+use rt::uv::uvio;\n \n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n-pub type EventLoopObject = super::uvio::UvEventLoop;\n-pub type IoFactoryObject = super::uvio::UvIoFactory;\n-pub type StreamObject = super::uvio::UvStream;\n-pub type TcpListenerObject = super::uvio::UvTcpListener;\n+pub type EventLoopObject = uvio::UvEventLoop;\n+pub type IoFactoryObject = uvio::UvIoFactory;\n+pub type RtioTcpStreamObject = uvio::UvTcpStream;\n+pub type RtioTcpListenerObject = uvio::UvTcpListener;\n \n pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n+    fn callback_ms(&mut self, ms: u64, ~fn());\n     /// The asynchronous I/O services. Not all event loops may provide one\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n }\n \n pub trait IoFactory {\n-    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject>;\n-    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject>;\n+    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError>;\n+    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError>;\n }\n \n-pub trait TcpListener {\n-    fn listen(&mut self) -> Option<~StreamObject>;\n+pub trait RtioTcpListener {\n+    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n }\n \n-pub trait Stream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), ()>;\n+pub trait RtioTcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n }"}, {"sha": "c66f20e01b2d7546b18007081c45a867c2c76e9d", "filename": "src/libcore/rt/sched.rs", "status": "renamed", "additions": 220, "deletions": 161, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -19,27 +19,23 @@ use super::context::Context;\n use super::local_services::LocalServices;\n use cell::Cell;\n \n-#[cfg(test)] use super::uvio::UvEventLoop;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use int;\n-\n // A more convenient name for external callers, e.g. `local_sched::take()`\n pub mod local_sched;\n \n-/// The Scheduler is responsible for coordinating execution of Tasks\n+/// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by\n /// thread local storage and the running task is owned by the\n /// scheduler.\n pub struct Scheduler {\n-    task_queue: WorkQueue<~Task>,\n+    priv work_queue: WorkQueue<~Coroutine>,\n     stack_pool: StackPool,\n     /// The event loop used to drive the scheduler and perform I/O\n     event_loop: ~EventLoopObject,\n     /// The scheduler's saved context.\n     /// Always valid when a task is executing, otherwise not\n     priv saved_context: Context,\n     /// The currently executing task\n-    current_task: Option<~Task>,\n+    current_task: Option<~Coroutine>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n     priv cleanup_job: Option<CleanupJob>\n@@ -49,17 +45,17 @@ pub struct Scheduler {\n // complaining\n type UnsafeTaskReceiver = sys::Closure;\n trait ClosureConverter {\n-    fn from_fn(&fn(~Task)) -> Self;\n-    fn to_fn(self) -> &fn(~Task);\n+    fn from_fn(&fn(~Coroutine)) -> Self;\n+    fn to_fn(self) -> &fn(~Coroutine);\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n-    fn from_fn(f: &fn(~Task)) -> UnsafeTaskReceiver { unsafe { transmute(f) } }\n-    fn to_fn(self) -> &fn(~Task) { unsafe { transmute(self) } }\n+    fn from_fn(f: &fn(~Coroutine)) -> UnsafeTaskReceiver { unsafe { transmute(f) } }\n+    fn to_fn(self) -> &fn(~Coroutine) { unsafe { transmute(self) } }\n }\n \n enum CleanupJob {\n     DoNothing,\n-    GiveTask(~Task, UnsafeTaskReceiver)\n+    GiveTask(~Coroutine, UnsafeTaskReceiver)\n }\n \n pub impl Scheduler {\n@@ -76,7 +72,7 @@ pub impl Scheduler {\n \n         Scheduler {\n             event_loop: event_loop,\n-            task_queue: WorkQueue::new(),\n+            work_queue: WorkQueue::new(),\n             stack_pool: StackPool::new(),\n             saved_context: Context::empty(),\n             current_task: None,\n@@ -91,43 +87,56 @@ pub impl Scheduler {\n     fn run(~self) -> ~Scheduler {\n         assert!(!self.in_task_context());\n \n-        // Give ownership of the scheduler (self) to the thread\n-        local_sched::put(self);\n+        let mut self_sched = self;\n \n         unsafe {\n-            let scheduler = local_sched::unsafe_borrow();\n-            fn run_scheduler_once() {\n-                let scheduler = local_sched::take();\n-                if scheduler.resume_task_from_queue() {\n-                    // Ok, a task ran. Nice! We'll do it again later\n-                    do local_sched::borrow |scheduler| {\n-                        scheduler.event_loop.callback(run_scheduler_once);\n-                    }\n-                }\n-            }\n+            let event_loop: *mut ~EventLoopObject = {\n+                let event_loop: *mut ~EventLoopObject = &mut self_sched.event_loop;\n+                event_loop\n+            };\n \n-            scheduler.event_loop.callback(run_scheduler_once);\n-            scheduler.event_loop.run();\n+            // Give ownership of the scheduler (self) to the thread\n+            local_sched::put(self_sched);\n+\n+            (*event_loop).run();\n         }\n \n-        return local_sched::take();\n+        let sched = local_sched::take();\n+        assert!(sched.work_queue.is_empty());\n+        return sched;\n+    }\n+\n+    /// Schedule a task to be executed later.\n+    ///\n+    /// Pushes the task onto the work stealing queue and tells the event loop\n+    /// to run it later. Always use this instead of pushing to the work queue\n+    /// directly.\n+    fn enqueue_task(&mut self, task: ~Coroutine) {\n+        self.work_queue.push_front(task);\n+        self.event_loop.callback(resume_task_from_queue);\n+\n+        fn resume_task_from_queue() {\n+            let scheduler = local_sched::take();\n+            scheduler.resume_task_from_queue();\n+        }\n     }\n \n     // * Scheduler-context operations\n \n-    fn resume_task_from_queue(~self) -> bool {\n+    fn resume_task_from_queue(~self) {\n         assert!(!self.in_task_context());\n \n+        rtdebug!(\"looking in work queue for task to schedule\");\n+\n         let mut this = self;\n-        match this.task_queue.pop_front() {\n+        match this.work_queue.pop_front() {\n             Some(task) => {\n+                rtdebug!(\"resuming task from work queue\");\n                 this.resume_task_immediately(task);\n-                return true;\n             }\n             None => {\n                 rtdebug!(\"no tasks in queue\");\n                 local_sched::put(this);\n-                return false;\n             }\n         }\n     }\n@@ -151,20 +160,31 @@ pub impl Scheduler {\n         abort!(\"control reached end of task\");\n     }\n \n-    fn schedule_new_task(~self, task: ~Task) {\n+    fn schedule_new_task(~self, task: ~Coroutine) {\n         assert!(self.in_task_context());\n \n         do self.switch_running_tasks_and_then(task) |last_task| {\n             let last_task = Cell(last_task);\n             do local_sched::borrow |sched| {\n-                sched.task_queue.push_front(last_task.take());\n+                sched.enqueue_task(last_task.take());\n+            }\n+        }\n+    }\n+\n+    fn schedule_task(~self, task: ~Coroutine) {\n+        assert!(self.in_task_context());\n+\n+        do self.switch_running_tasks_and_then(task) |last_task| {\n+            let last_task = Cell(last_task);\n+            do local_sched::borrow |sched| {\n+                sched.enqueue_task(last_task.take());\n             }\n         }\n     }\n \n     // Core scheduling ops\n \n-    fn resume_task_immediately(~self, task: ~Task) {\n+    fn resume_task_immediately(~self, task: ~Coroutine) {\n         let mut this = self;\n         assert!(!this.in_task_context());\n \n@@ -179,18 +199,18 @@ pub impl Scheduler {\n         // Take pointers to both the task and scheduler's saved registers.\n         unsafe {\n             let sched = local_sched::unsafe_borrow();\n-            let (sched_context, _, next_task_context) = sched.get_contexts();\n+            let (sched_context, _, next_task_context) = (*sched).get_contexts();\n             let next_task_context = next_task_context.unwrap();\n             // Context switch to the task, restoring it's registers\n             // and saving the scheduler's\n             Context::swap(sched_context, next_task_context);\n \n             let sched = local_sched::unsafe_borrow();\n             // The running task should have passed ownership elsewhere\n-            assert!(sched.current_task.is_none());\n+            assert!((*sched).current_task.is_none());\n \n             // Running tasks may have asked us to do some cleanup\n-            sched.run_cleanup_job();\n+            (*sched).run_cleanup_job();\n         }\n     }\n \n@@ -202,40 +222,44 @@ pub impl Scheduler {\n     /// The closure here is a *stack* closure that lives in the\n     /// running task.  It gets transmuted to the scheduler's lifetime\n     /// and called while the task is blocked.\n-    fn deschedule_running_task_and_then(~self, f: &fn(~Task)) {\n+    fn deschedule_running_task_and_then(~self, f: &fn(~Coroutine)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n         rtdebug!(\"blocking task\");\n \n-        let blocked_task = this.current_task.swap_unwrap();\n-        let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n-        let f_opaque = ClosureConverter::from_fn(f_fake_region);\n-        this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n+        unsafe {\n+            let blocked_task = this.current_task.swap_unwrap();\n+            let f_fake_region = transmute::<&fn(~Coroutine), &fn(~Coroutine)>(f);\n+            let f_opaque = ClosureConverter::from_fn(f_fake_region);\n+            this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n+        }\n \n         local_sched::put(this);\n \n-        let sched = unsafe { local_sched::unsafe_borrow() };\n-        let (sched_context, last_task_context, _) = sched.get_contexts();\n-        let last_task_context = last_task_context.unwrap();\n-        Context::swap(last_task_context, sched_context);\n+        unsafe {\n+            let sched = local_sched::unsafe_borrow();\n+            let (sched_context, last_task_context, _) = (*sched).get_contexts();\n+            let last_task_context = last_task_context.unwrap();\n+            Context::swap(last_task_context, sched_context);\n \n-        // We could be executing in a different thread now\n-        let sched = unsafe { local_sched::unsafe_borrow() };\n-        sched.run_cleanup_job();\n+            // We could be executing in a different thread now\n+            let sched = local_sched::unsafe_borrow();\n+            (*sched).run_cleanup_job();\n+        }\n     }\n \n     /// Switch directly to another task, without going through the scheduler.\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n-    fn switch_running_tasks_and_then(~self, next_task: ~Task, f: &fn(~Task)) {\n+    fn switch_running_tasks_and_then(~self, next_task: ~Coroutine, f: &fn(~Coroutine)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n \n         let old_running_task = this.current_task.swap_unwrap();\n-        let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n+        let f_fake_region = unsafe { transmute::<&fn(~Coroutine), &fn(~Coroutine)>(f) };\n         let f_opaque = ClosureConverter::from_fn(f_fake_region);\n         this.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n         this.current_task = Some(next_task);\n@@ -244,14 +268,14 @@ pub impl Scheduler {\n \n         unsafe {\n             let sched = local_sched::unsafe_borrow();\n-            let (_, last_task_context, next_task_context) = sched.get_contexts();\n+            let (_, last_task_context, next_task_context) = (*sched).get_contexts();\n             let last_task_context = last_task_context.unwrap();\n             let next_task_context = next_task_context.unwrap();\n             Context::swap(last_task_context, next_task_context);\n \n             // We could be executing in a different thread now\n             let sched = local_sched::unsafe_borrow();\n-            sched.run_cleanup_job();\n+            (*sched).run_cleanup_job();\n         }\n     }\n \n@@ -301,7 +325,7 @@ pub impl Scheduler {\n         // because borrowck thinks the three patterns are conflicting\n         // borrows\n         unsafe {\n-            let last_task = transmute::<Option<&Task>, Option<&mut Task>>(last_task);\n+            let last_task = transmute::<Option<&Coroutine>, Option<&mut Coroutine>>(last_task);\n             let last_task_context = match last_task {\n                 Some(t) => Some(&mut t.saved_context), None => None\n             };\n@@ -316,9 +340,9 @@ pub impl Scheduler {\n     }\n }\n \n-static TASK_MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n+static MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n \n-pub struct Task {\n+pub struct Coroutine {\n     /// The segment of stack on which the task is currently running or,\n     /// if the task is blocked, on which the task will resume execution\n     priv current_stack_segment: StackSegment,\n@@ -329,19 +353,19 @@ pub struct Task {\n     local_services: LocalServices\n }\n \n-pub impl Task {\n-    fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n-        Task::with_local(stack_pool, LocalServices::new(), start)\n+pub impl Coroutine {\n+    fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n+        Coroutine::with_local(stack_pool, LocalServices::new(), start)\n     }\n \n     fn with_local(stack_pool: &mut StackPool,\n                   local_services: LocalServices,\n-                  start: ~fn()) -> Task {\n-        let start = Task::build_start_wrapper(start);\n-        let mut stack = stack_pool.take_segment(TASK_MIN_STACK_SIZE);\n+                  start: ~fn()) -> Coroutine {\n+        let start = Coroutine::build_start_wrapper(start);\n+        let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);\n         // NB: Context holds a pointer to that ~fn\n         let initial_context = Context::new(start, &mut stack);\n-        return Task {\n+        return Coroutine {\n             current_stack_segment: stack,\n             saved_context: initial_context,\n             local_services: local_services\n@@ -356,10 +380,10 @@ pub impl Task {\n             // have asked us to do some cleanup.\n             unsafe {\n                 let sched = local_sched::unsafe_borrow();\n-                sched.run_cleanup_job();\n+                (*sched).run_cleanup_job();\n \n                 let sched = local_sched::unsafe_borrow();\n-                let task = sched.current_task.get_mut_ref();\n+                let task = (*sched).current_task.get_mut_ref();\n                 // FIXME #6141: shouldn't neet to put `start()` in another closure\n                 task.local_services.run(||start());\n             }\n@@ -373,125 +397,160 @@ pub impl Task {\n     /// Destroy the task and try to reuse its components\n     fn recycle(~self, stack_pool: &mut StackPool) {\n         match self {\n-            ~Task {current_stack_segment, _} => {\n+            ~Coroutine {current_stack_segment, _} => {\n                 stack_pool.give_segment(current_stack_segment);\n             }\n         }\n     }\n }\n \n-#[test]\n-fn test_simple_scheduling() {\n-    do run_in_bare_thread {\n-        let mut task_ran = false;\n-        let task_ran_ptr: *mut bool = &mut task_ran;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            unsafe { *task_ran_ptr = true; }\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n-        assert!(task_ran);\n+#[cfg(test)]\n+mod test {\n+    use int;\n+    use cell::Cell;\n+    use rt::uv::uvio::UvEventLoop;\n+    use unstable::run_in_bare_thread;\n+    use task::spawn;\n+    use rt::test::*;\n+    use super::*;\n+\n+    #[test]\n+    fn test_simple_scheduling() {\n+        do run_in_bare_thread {\n+            let mut task_ran = false;\n+            let task_ran_ptr: *mut bool = &mut task_ran;\n+\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                unsafe { *task_ran_ptr = true; }\n+            };\n+            sched.enqueue_task(task);\n+            sched.run();\n+            assert!(task_ran);\n+        }\n     }\n-}\n \n-#[test]\n-fn test_several_tasks() {\n-    do run_in_bare_thread {\n-        let total = 10;\n-        let mut task_count = 0;\n-        let task_count_ptr: *mut int = &mut task_count;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        for int::range(0, total) |_| {\n-            let task = ~do Task::new(&mut sched.stack_pool) {\n-                unsafe { *task_count_ptr = *task_count_ptr + 1; }\n-            };\n-            sched.task_queue.push_back(task);\n+    #[test]\n+    fn test_several_tasks() {\n+        do run_in_bare_thread {\n+            let total = 10;\n+            let mut task_count = 0;\n+            let task_count_ptr: *mut int = &mut task_count;\n+\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            for int::range(0, total) |_| {\n+                let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                    unsafe { *task_count_ptr = *task_count_ptr + 1; }\n+                };\n+                sched.enqueue_task(task);\n+            }\n+            sched.run();\n+            assert!(task_count == total);\n         }\n-        sched.run();\n-        assert!(task_count == total);\n     }\n-}\n \n-#[test]\n-fn test_swap_tasks_then() {\n-    do run_in_bare_thread {\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task1 = ~do Task::new(&mut sched.stack_pool) {\n-            unsafe { *count_ptr = *count_ptr + 1; }\n-            let mut sched = local_sched::take();\n-            let task2 = ~do Task::new(&mut sched.stack_pool) {\n+    #[test]\n+    fn test_swap_tasks_then() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            let task1 = ~do Coroutine::new(&mut sched.stack_pool) {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n-            };\n-            // Context switch directly to the new task\n-            do sched.switch_running_tasks_and_then(task2) |task1| {\n-                let task1 = Cell(task1);\n-                do local_sched::borrow |sched| {\n-                    sched.task_queue.push_front(task1.take());\n+                let mut sched = local_sched::take();\n+                let task2 = ~do Coroutine::new(&mut sched.stack_pool) {\n+                    unsafe { *count_ptr = *count_ptr + 1; }\n+                };\n+                // Context switch directly to the new task\n+                do sched.switch_running_tasks_and_then(task2) |task1| {\n+                    let task1 = Cell(task1);\n+                    do local_sched::borrow |sched| {\n+                        sched.enqueue_task(task1.take());\n+                    }\n                 }\n-            }\n-            unsafe { *count_ptr = *count_ptr + 1; }\n-        };\n-        sched.task_queue.push_back(task1);\n-        sched.run();\n-        assert!(count == 3);\n+                unsafe { *count_ptr = *count_ptr + 1; }\n+            };\n+            sched.enqueue_task(task1);\n+            sched.run();\n+            assert!(count == 3);\n+        }\n     }\n-}\n \n-#[bench] #[test] #[ignore(reason = \"long test\")]\n-fn test_run_a_lot_of_tasks_queued() {\n-    do run_in_bare_thread {\n-        static MAX: int = 1000000;\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n+    #[bench] #[test] #[ignore(reason = \"long test\")]\n+    fn test_run_a_lot_of_tasks_queued() {\n+        do run_in_bare_thread {\n+            static MAX: int = 1000000;\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n \n-        let mut sched = ~UvEventLoop::new_scheduler();\n+            let mut sched = ~UvEventLoop::new_scheduler();\n \n-        let start_task = ~do Task::new(&mut sched.stack_pool) {\n-            run_task(count_ptr);\n-        };\n-        sched.task_queue.push_back(start_task);\n-        sched.run();\n+            let start_task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                run_task(count_ptr);\n+            };\n+            sched.enqueue_task(start_task);\n+            sched.run();\n \n-        assert!(count == MAX);\n+            assert!(count == MAX);\n \n-        fn run_task(count_ptr: *mut int) {\n-            do local_sched::borrow |sched| {\n-                let task = ~do Task::new(&mut sched.stack_pool) {\n-                    unsafe {\n-                        *count_ptr = *count_ptr + 1;\n-                        if *count_ptr != MAX {\n-                            run_task(count_ptr);\n+            fn run_task(count_ptr: *mut int) {\n+                do local_sched::borrow |sched| {\n+                    let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                        unsafe {\n+                            *count_ptr = *count_ptr + 1;\n+                            if *count_ptr != MAX {\n+                                run_task(count_ptr);\n+                            }\n                         }\n+                    };\n+                    sched.enqueue_task(task);\n+                }\n+            };\n+        }\n+    }\n+\n+    #[test]\n+    fn test_block_task() {\n+        do run_in_bare_thread {\n+            let mut sched = ~UvEventLoop::new_scheduler();\n+            let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                let sched = local_sched::take();\n+                assert!(sched.in_task_context());\n+                do sched.deschedule_running_task_and_then() |task| {\n+                    let task = Cell(task);\n+                    do local_sched::borrow |sched| {\n+                        assert!(!sched.in_task_context());\n+                        sched.enqueue_task(task.take());\n                     }\n-                };\n-                sched.task_queue.push_back(task);\n-            }\n-        };\n+                }\n+            };\n+            sched.enqueue_task(task);\n+            sched.run();\n+        }\n     }\n-}\n \n-#[test]\n-fn test_block_task() {\n-    do run_in_bare_thread {\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n-            let sched = local_sched::take();\n-            assert!(sched.in_task_context());\n-            do sched.deschedule_running_task_and_then() |task| {\n-                let task = Cell(task);\n-                do local_sched::borrow |sched| {\n-                    assert!(!sched.in_task_context());\n-                    sched.task_queue.push_back(task.take());\n+    #[test]\n+    fn test_io_callback() {\n+        // This is a regression test that when there are no schedulable tasks\n+        // in the work queue, but we are performing I/O, that once we do put\n+        // something in the work queue again the scheduler picks it up and doesn't\n+        // exit before emptying the work queue\n+        do run_in_newsched_task {\n+            do spawn {\n+                let sched = local_sched::take();\n+                do sched.deschedule_running_task_and_then |task| {\n+                    let mut sched = local_sched::take();\n+                    let task = Cell(task);\n+                    do sched.event_loop.callback_ms(10) {\n+                        rtdebug!(\"in callback\");\n+                        let mut sched = local_sched::take();\n+                        sched.enqueue_task(task.take());\n+                        local_sched::put(sched);\n+                    }\n+                    local_sched::put(sched);\n                 }\n             }\n-        };\n-        sched.task_queue.push_back(task);\n-        sched.run();\n+        }\n     }\n }", "previous_filename": "src/libcore/rt/sched/mod.rs"}, {"sha": "cab9c3390b2d7189122fc9e230572e4bedfb72a7", "filename": "src/libcore/rt/stack.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fstack.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -11,21 +11,36 @@\n use container::Container;\n use ptr::Ptr;\n use vec;\n+use ops::Drop;\n+use libc::{c_uint, uintptr_t};\n \n pub struct StackSegment {\n-    buf: ~[u8]\n+    buf: ~[u8],\n+    valgrind_id: c_uint\n }\n \n pub impl StackSegment {\n     fn new(size: uint) -> StackSegment {\n-        // Crate a block of uninitialized values\n-        let mut stack = vec::with_capacity(size);\n         unsafe {\n+            // Crate a block of uninitialized values\n+            let mut stack = vec::with_capacity(size);\n             vec::raw::set_len(&mut stack, size);\n+\n+            let mut stk = StackSegment {\n+                buf: stack,\n+                valgrind_id: 0\n+            };\n+\n+            // XXX: Using the FFI to call a C macro. Slow\n+            stk.valgrind_id = rust_valgrind_stack_register(stk.start(), stk.end());\n+            return stk;\n         }\n+    }\n \n-        StackSegment {\n-            buf: stack\n+    /// Point to the low end of the allocated stack\n+    fn start(&self) -> *uint {\n+        unsafe {\n+            vec::raw::to_ptr(self.buf) as *uint\n         }\n     }\n \n@@ -35,6 +50,15 @@ pub impl StackSegment {\n     }\n }\n \n+impl Drop for StackSegment {\n+    fn finalize(&self) {\n+        unsafe {\n+            // XXX: Using the FFI to call a C macro. Slow\n+            rust_valgrind_stack_deregister(self.valgrind_id);\n+        }\n+    }\n+}\n+\n pub struct StackPool(());\n \n impl StackPool {\n@@ -47,3 +71,8 @@ impl StackPool {\n     fn give_segment(&self, _stack: StackSegment) {\n     }\n }\n+\n+extern {\n+    fn rust_valgrind_stack_register(start: *uintptr_t, end: *uintptr_t) -> c_uint;\n+    fn rust_valgrind_stack_deregister(id: c_uint);\n+}"}, {"sha": "d739d0110ba35683e5db3a72b459b286cfc512c6", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 86, "deletions": 15, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -8,27 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use uint;\n+use option::*;\n use cell::Cell;\n use result::{Result, Ok, Err};\n use super::io::net::ip::{IpAddr, Ipv4};\n use rt::local_services::LocalServices;\n+use rt::thread::Thread;\n \n /// Creates a new scheduler in a new thread and runs a task in it,\n /// then waits for the scheduler to exit. Failure of the task\n /// will abort the process.\n pub fn run_in_newsched_task(f: ~fn()) {\n+    use super::sched::*;\n     use unstable::run_in_bare_thread;\n-    use super::sched::Task;\n-    use super::uvio::UvEventLoop;\n+    use rt::uv::uvio::UvEventLoop;\n \n     let f = Cell(f);\n \n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~Task::with_local(&mut sched.stack_pool,\n-                                     LocalServices::without_unwinding(),\n-                                     f.take());\n-        sched.task_queue.push_back(task);\n+        let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                          LocalServices::without_unwinding(),\n+                                          f.take());\n+        sched.enqueue_task(task);\n         sched.run();\n     }\n }\n@@ -38,9 +41,9 @@ pub fn spawntask(f: ~fn()) {\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::with_local(&mut sched.stack_pool,\n-                                 LocalServices::without_unwinding(),\n-                                 f);\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n         let sched = local_sched::take();\n@@ -53,17 +56,57 @@ pub fn spawntask_immediately(f: ~fn()) {\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::with_local(&mut sched.stack_pool,\n-                                 LocalServices::without_unwinding(),\n-                                 f);\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n         do local_sched::borrow |sched| {\n-            sched.task_queue.push_front(task.take());\n+            sched.enqueue_task(task.take());\n+        }\n+    }\n+}\n+\n+/// Create a new task and run it right now. Aborts on failure\n+pub fn spawntask_later(f: ~fn()) {\n+    use super::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n+\n+    sched.enqueue_task(task);\n+    local_sched::put(sched);\n+}\n+\n+/// Spawn a task and either run it immediately or run it later\n+pub fn spawntask_random(f: ~fn()) {\n+    use super::sched::*;\n+    use rand::{Rand, rng};\n+\n+    let mut rng = rng();\n+    let run_now: bool = Rand::rand(&mut rng);\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n+\n+    if run_now {\n+        do sched.switch_running_tasks_and_then(task) |task| {\n+            let task = Cell(task);\n+            do local_sched::borrow |sched| {\n+                sched.enqueue_task(task.take());\n+            }\n         }\n+    } else {\n+        sched.enqueue_task(task);\n+        local_sched::put(sched);\n     }\n }\n \n+\n /// Spawn a task and wait for it to finish, returning whether it completed successfully or failed\n pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n     use cell::Cell;\n@@ -82,7 +125,7 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n         let old_task = Cell(old_task);\n         let f = f.take();\n         let mut sched = local_sched::take();\n-        let new_task = ~do Task::new(&mut sched.stack_pool) {\n+        let new_task = ~do Coroutine::new(&mut sched.stack_pool) {\n             do (|| {\n                 (f.take())()\n             }).finally {\n@@ -92,7 +135,7 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n                 do sched.switch_running_tasks_and_then(old_task.take()) |new_task| {\n                     let new_task = Cell(new_task);\n                     do local_sched::borrow |sched| {\n-                        sched.task_queue.push_front(new_task.take());\n+                        sched.enqueue_task(new_task.take());\n                     }\n                 }\n             }\n@@ -104,6 +147,23 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n     if !failed { Ok(()) } else { Err(()) }\n }\n \n+// Spawn a new task in a new scheduler and return a thread handle.\n+pub fn spawntask_thread(f: ~fn()) -> Thread {\n+    use rt::sched::*;\n+    use rt::uv::uvio::UvEventLoop;\n+\n+    let f = Cell(f);\n+    let thread = do Thread::start {\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                          LocalServices::without_unwinding(),\n+                                          f.take());\n+        sched.enqueue_task(task);\n+        sched.run();\n+    };\n+    return thread;\n+}\n+\n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n     unsafe {\n@@ -118,3 +178,14 @@ pub fn next_test_port() -> u16 {\n pub fn next_test_ip4() -> IpAddr {\n     Ipv4(127, 0, 0, 1, next_test_port())\n }\n+\n+/// Get a constant that represents the number of times to repeat stress tests. Default 1.\n+pub fn stress_factor() -> uint {\n+    use os::getenv;\n+\n+    match getenv(\"RUST_RT_STRESS\") {\n+        Some(val) => uint::from_str(val).get(),\n+        None => 1\n+    }\n+}\n+"}, {"sha": "6a08c0f59b18359d91dcb65c94991a8f8d3bd6a0", "filename": "src/libcore/rt/thread_local_storage.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread_local_storage.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -46,8 +46,11 @@ type pthread_key_t = ::libc::c_uint;\n \n #[cfg(unix)]\n extern {\n+    #[fast_ffi]\n     fn pthread_key_create(key: *mut pthread_key_t, dtor: *u8) -> c_int;\n+    #[fast_ffi]\n     fn pthread_setspecific(key: pthread_key_t, value: *mut c_void) -> c_int;\n+    #[fast_ffi]\n     fn pthread_getspecific(key: pthread_key_t) -> *mut c_void;\n }\n "}, {"sha": "bc9269f08faa938a268d66d0d7e587280bf46f55", "filename": "src/libcore/rt/tube.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftube.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A very simple unsynchronized channel type for sending buffered data from\n+//! scheduler context to task context.\n+//!\n+//! XXX: This would be safer to use if split into two types like Port/Chan\n+\n+use option::*;\n+use clone::Clone;\n+use super::rc::RC;\n+use rt::sched::Coroutine;\n+use rt::{context, TaskContext, SchedulerContext};\n+use rt::local_sched;\n+use vec::OwnedVector;\n+use container::Container;\n+\n+struct TubeState<T> {\n+    blocked_task: Option<~Coroutine>,\n+    buf: ~[T]\n+}\n+\n+pub struct Tube<T> {\n+    p: RC<TubeState<T>>\n+}\n+\n+impl<T> Tube<T> {\n+    pub fn new() -> Tube<T> {\n+        Tube {\n+            p: RC::new(TubeState {\n+                blocked_task: None,\n+                buf: ~[]\n+            })\n+        }\n+    }\n+\n+    pub fn send(&mut self, val: T) {\n+        rtdebug!(\"tube send\");\n+        assert!(context() == SchedulerContext);\n+\n+        unsafe {\n+            let state = self.p.unsafe_borrow_mut();\n+            (*state).buf.push(val);\n+\n+            if (*state).blocked_task.is_some() {\n+                // There's a waiting task. Wake it up\n+                rtdebug!(\"waking blocked tube\");\n+                let task = (*state).blocked_task.swap_unwrap();\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+        }\n+    }\n+\n+    pub fn recv(&mut self) -> T {\n+        assert!(context() == TaskContext);\n+\n+        unsafe {\n+            let state = self.p.unsafe_borrow_mut();\n+            if !(*state).buf.is_empty() {\n+                return (*state).buf.shift();\n+            } else {\n+                // Block and wait for the next message\n+                rtdebug!(\"blocking on tube recv\");\n+                assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n+                assert!((*state).blocked_task.is_none());\n+                let sched = local_sched::take();\n+                do sched.deschedule_running_task_and_then |task| {\n+                    (*state).blocked_task = Some(task);\n+                }\n+                rtdebug!(\"waking after tube recv\");\n+                let buf = &mut (*state).buf;\n+                assert!(!buf.is_empty());\n+                return buf.shift();\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Tube<T> {\n+    fn clone(&self) -> Tube<T> {\n+        Tube { p: self.p.clone() }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use int;\n+    use cell::Cell;\n+    use rt::local_sched;\n+    use rt::test::*;\n+    use rt::rtio::EventLoop;\n+    use super::*;\n+\n+    #[test]\n+    fn simple_test() {\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone_cell = Cell(tube_clone);\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                let mut tube_clone = tube_clone_cell.take();\n+                tube_clone.send(1);\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            assert!(tube.recv() == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn blocking_test() {\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone = Cell(Cell(Cell(tube_clone)));\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                let tube_clone = tube_clone.take();\n+                do local_sched::borrow |sched| {\n+                    let tube_clone = tube_clone.take();\n+                    do sched.event_loop.callback {\n+                        let mut tube_clone = tube_clone.take();\n+                        // The task should be blocked on this now and\n+                        // sending will wake it up.\n+                        tube_clone.send(1);\n+                    }\n+                }\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            assert!(tube.recv() == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn many_blocking_test() {\n+        static MAX: int = 100;\n+\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone = Cell(tube_clone);\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                callback_send(tube_clone.take(), 0);\n+\n+                fn callback_send(tube: Tube<int>, i: int) {\n+                    if i == 100 { return; }\n+\n+                    let tube = Cell(Cell(tube));\n+                    do local_sched::borrow |sched| {\n+                        let tube = tube.take();\n+                        do sched.event_loop.callback {\n+                            let mut tube = tube.take();\n+                            // The task should be blocked on this now and\n+                            // sending will wake it up.\n+                            tube.send(i);\n+                            callback_send(tube, i + 1);\n+                        }\n+                    }\n+                }\n+\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            for int::range(0, MAX) |i| {\n+                let j = tube.recv();\n+                assert!(j == i);\n+            }\n+        }\n+    }\n+}"}, {"sha": "2d14505509759b70e8409c4f36afd9657240268e", "filename": "src/libcore/rt/uv/file.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Ffile.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -11,15 +11,11 @@\n use prelude::*;\n use ptr::null;\n use libc::c_void;\n-use super::{UvError, Callback, Request, NativeHandle, Loop};\n-use super::super::uvll;\n-use super::super::uvll::*;\n-\n-pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n-impl Callback for FsCallback { }\n+use rt::uv::{Request, NativeHandle, Loop, FsCallback};\n+use rt::uv::uvll;\n+use rt::uv::uvll::*;\n \n pub struct FsRequest(*uvll::uv_fs_t);\n-\n impl Request for FsRequest;\n \n impl FsRequest {"}, {"sha": "2cf0b5c4872889d94e61e82dd1579b6eaeec1d68", "filename": "src/libcore/rt/uv/idle.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fidle.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::c_int;\n+use option::Some;\n+use rt::uv::uvll;\n+use rt::uv::{Watcher, Loop, NativeHandle, IdleCallback, NullCallback};\n+use rt::uv::status_to_maybe_uv_error;\n+\n+pub struct IdleWatcher(*uvll::uv_idle_t);\n+impl Watcher for IdleWatcher { }\n+\n+pub impl IdleWatcher {\n+    fn new(loop_: &mut Loop) -> IdleWatcher {\n+        unsafe {\n+            let handle = uvll::idle_new();\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::idle_init(loop_.native_handle(), handle));\n+            let mut watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher\n+        }\n+    }\n+\n+    fn start(&mut self, cb: IdleCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.idle_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n+        };\n+\n+        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+            let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            let data = idle_watcher.get_watcher_data();\n+            let cb: &IdleCallback = data.idle_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(idle_watcher, status);\n+        }\n+    }\n+\n+    fn stop(&mut self) {\n+        // NB: Not resetting the Rust idle_cb to None here because `stop` is likely\n+        // called from *within* the idle callback, causing a use after free\n+\n+        unsafe {\n+            assert!(0 == uvll::idle_stop(self.native_handle()));\n+        }\n+    }\n+\n+    fn close(self, cb: NullCallback) {\n+        {\n+            let mut this = self;\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb) };\n+\n+        extern fn close_cb(handle: *uvll::uv_idle_t) {\n+            unsafe {\n+                let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+                {\n+                    let data = idle_watcher.get_watcher_data();\n+                    data.close_cb.swap_unwrap()();\n+                }\n+                idle_watcher.drop_watcher_data();\n+                uvll::idle_delete(handle);\n+            }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n+    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n+        IdleWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &IdleWatcher(ptr) => ptr }\n+    }\n+}"}, {"sha": "99a5252c88a663397b382b2a788ad5d4091e61d8", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 159, "deletions": 194, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -10,7 +10,7 @@\n \n /*!\n \n-Bindings to libuv.\n+Bindings to libuv, along with the default implementation of `core::rt::rtio`.\n \n UV types consist of the event loop (Loop), Watchers, Requests and\n Callbacks.\n@@ -38,56 +38,63 @@ use container::Container;\n use option::*;\n use str::raw::from_c_str;\n use to_str::ToStr;\n+use ptr::Ptr;\n+use libc;\n use vec;\n use ptr;\n-use ptr::Ptr;\n+use cast;\n+use str;\n+use option::*;\n+use str::raw::from_c_str;\n+use to_str::ToStr;\n use libc::{c_void, c_int, size_t, malloc, free};\n use cast::transmute;\n use ptr::null;\n-use super::uvll;\n use unstable::finally::Finally;\n \n+use rt::io::IoError;\n+\n #[cfg(test)] use unstable::run_in_bare_thread;\n \n-pub use self::file::{FsRequest, FsCallback};\n+pub use self::file::FsRequest;\n pub use self::net::{StreamWatcher, TcpWatcher};\n-pub use self::net::{ReadCallback, AllocCallback, ConnectionCallback, ConnectCallback};\n+pub use self::idle::IdleWatcher;\n+pub use self::timer::TimerWatcher;\n+\n+/// The implementation of `rtio` for libuv\n+pub mod uvio;\n+\n+/// C bindings to libuv\n+pub mod uvll;\n \n pub mod file;\n pub mod net;\n+pub mod idle;\n+pub mod timer;\n \n-/// A trait for callbacks to implement. Provides a little extra type safety\n-/// for generic, unsafe interop functions like `set_watcher_callback`.\n-pub trait Callback { }\n-\n-pub trait Request { }\n+/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n+/// with dtors may not be destructured, but tuple structs can,\n+/// but the results are not correct.\n+pub struct Loop {\n+    handle: *uvll::uv_loop_t\n+}\n \n /// The trait implemented by uv 'watchers' (handles). Watchers are\n /// non-owning wrappers around the uv handles and are not completely\n /// safe - there may be multiple instances for a single underlying\n /// handle.  Watchers are generally created, then `start`ed, `stop`ed\n /// and `close`ed, but due to their complex life cycle may not be\n /// entirely memory safe if used in unanticipated patterns.\n-pub trait Watcher {\n-    fn event_loop(&self) -> Loop;\n-}\n+pub trait Watcher { }\n \n-pub type NullCallback = ~fn();\n-impl Callback for NullCallback { }\n+pub trait Request { }\n \n /// A type that wraps a native handle\n pub trait NativeHandle<T> {\n     pub fn from_native_handle(T) -> Self;\n     pub fn native_handle(&self) -> T;\n }\n \n-/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n-/// with dtors may not be destructured, but tuple structs can,\n-/// but the results are not correct.\n-pub struct Loop {\n-    handle: *uvll::uv_loop_t\n-}\n-\n pub impl Loop {\n     fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n@@ -113,64 +120,74 @@ impl NativeHandle<*uvll::uv_loop_t> for Loop {\n     }\n }\n \n-pub struct IdleWatcher(*uvll::uv_idle_t);\n+// XXX: The uv alloc callback also has a *uv_handle_t arg\n+pub type AllocCallback = ~fn(uint) -> Buf;\n+pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n+pub type NullCallback = ~fn();\n+pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n+pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n+pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n+pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n \n-impl Watcher for IdleWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n+\n+/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n+struct WatcherData {\n+    read_cb: Option<ReadCallback>,\n+    write_cb: Option<ConnectionCallback>,\n+    connect_cb: Option<ConnectionCallback>,\n+    close_cb: Option<NullCallback>,\n+    alloc_cb: Option<AllocCallback>,\n+    idle_cb: Option<IdleCallback>,\n+    timer_cb: Option<TimerCallback>\n }\n \n-pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n-impl Callback for IdleCallback { }\n+pub trait WatcherInterop {\n+    fn event_loop(&self) -> Loop;\n+    fn install_watcher_data(&mut self);\n+    fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n+    fn drop_watcher_data(&mut self);\n+}\n \n-pub impl IdleWatcher {\n-    fn new(loop_: &mut Loop) -> IdleWatcher {\n+impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n+    /// Get the uv event loop from a Watcher\n+    pub fn event_loop(&self) -> Loop {\n         unsafe {\n-            let handle = uvll::idle_new();\n-            assert!(handle.is_not_null());\n-            assert!(0 == uvll::idle_init(loop_.native_handle(), handle));\n-            uvll::set_data_for_uv_handle(handle, null::<()>());\n-            NativeHandle::from_native_handle(handle)\n+            let handle = self.native_handle();\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            NativeHandle::from_native_handle(loop_)\n         }\n     }\n \n-    fn start(&mut self, cb: IdleCallback) {\n-\n-        set_watcher_callback(self, cb);\n+    pub fn install_watcher_data(&mut self) {\n         unsafe {\n-            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n-        };\n-\n-        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-            let idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            let cb: &IdleCallback = borrow_callback_from_watcher(&idle_watcher);\n-            let status = status_to_maybe_uv_error(handle, status);\n-            (*cb)(idle_watcher, status);\n+            let data = ~WatcherData {\n+                read_cb: None,\n+                write_cb: None,\n+                connect_cb: None,\n+                close_cb: None,\n+                alloc_cb: None,\n+                idle_cb: None,\n+                timer_cb: None\n+            };\n+            let data = transmute::<~WatcherData, *c_void>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), data);\n         }\n     }\n \n-    fn stop(&mut self) {\n-        unsafe { assert!(0 == uvll::idle_stop(self.native_handle())); }\n-    }\n-\n-    fn close(self) {\n-        unsafe { uvll::close(self.native_handle(), close_cb) };\n-\n-        extern fn close_cb(handle: *uvll::uv_idle_t) {\n-            let mut idle_watcher = NativeHandle::from_native_handle(handle);\n-            drop_watcher_callback::<uvll::uv_idle_t, IdleWatcher, IdleCallback>(&mut idle_watcher);\n-            unsafe { uvll::idle_delete(handle) };\n+    pub fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData {\n+        unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n+            return &mut **data;\n         }\n     }\n-}\n \n-impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n-    fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n-        IdleWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_idle_t {\n-        match self { &IdleWatcher(ptr) => ptr }\n+    pub fn drop_watcher_data(&mut self) {\n+        unsafe {\n+            let data = uvll::get_data_for_uv_handle(self.native_handle());\n+            let _data = transmute::<*c_void, ~WatcherData>(data);\n+            uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n+        }\n     }\n }\n \n@@ -198,6 +215,10 @@ pub impl UvError {\n             from_c_str(desc_str)\n         }\n     }\n+\n+    fn is_eof(&self) -> bool {\n+        self.code == uvll::EOF\n+    }\n }\n \n impl ToStr for UvError {\n@@ -213,148 +234,74 @@ fn error_smoke_test() {\n     assert!(err.to_str() == ~\"EOF: end of file\");\n }\n \n-\n-/// Given a uv handle, convert a callback status to a UvError\n-// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n-pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n-    if status != -1 {\n-        None\n-    } else {\n-        unsafe {\n-            rtdebug!(\"handle: %x\", handle as uint);\n-            let loop_ = uvll::get_loop_for_uv_handle(handle);\n-            rtdebug!(\"loop: %x\", loop_ as uint);\n-            let err = uvll::last_error(loop_);\n-            Some(UvError(err))\n-        }\n-    }\n-}\n-\n-/// Get the uv event loop from a Watcher\n-pub fn loop_from_watcher<H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &W) -> Loop {\n-\n-    let handle = watcher.native_handle();\n-    let loop_ = unsafe { uvll::get_loop_for_uv_handle(handle) };\n-    NativeHandle::from_native_handle(loop_)\n-}\n-\n-/// Set the custom data on a handle to a callback Note: This is only\n-/// suitable for watchers that make just one type of callback.  For\n-/// others use WatcherData\n-pub fn set_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W, cb: CB) {\n-\n-    drop_watcher_callback::<H, W, CB>(watcher);\n-    // XXX: Boxing the callback so it fits into a\n-    // pointer. Unfortunate extra allocation\n-    let boxed_cb = ~cb;\n-    let data = unsafe { transmute::<~CB, *c_void>(boxed_cb) };\n-    unsafe { uvll::set_data_for_uv_handle(watcher.native_handle(), data) };\n-}\n-\n-/// Delete a callback from a handle's custom data\n-pub fn drop_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) {\n-\n+pub fn last_uv_error<H, W: Watcher + NativeHandle<*H>>(watcher: &W) -> UvError {\n     unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        if handle_data.is_not_null() {\n-            // Take ownership of the callback and drop it\n-            let _cb = transmute::<*c_void, ~CB>(handle_data);\n-            // Make sure the pointer is zeroed\n-            uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n-        }\n+        let loop_ = watcher.event_loop();\n+        UvError(uvll::last_error(loop_.native_handle()))\n     }\n }\n \n-/// Take a pointer to the callback installed as custom data\n-pub fn borrow_callback_from_watcher<H, W: Watcher + NativeHandle<*H>,\n-                                CB: Callback>(watcher: &W) -> &CB {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        assert!(handle_data.is_not_null());\n-        let cb = transmute::<&*c_void, &~CB>(&handle_data);\n-        return &**cb;\n-    }\n-}\n+pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n \n-/// Take ownership of the callback installed as custom data\n-pub fn take_callback_from_watcher<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) -> CB {\n+    // XXX: Could go in str::raw\n+    unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n+        let s = s as *u8;\n+        let mut curr = s, len = 0u;\n+        while *curr != 0u8 {\n+            len += 1u;\n+            curr = ptr::offset(s, len);\n+        }\n \n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        assert!(handle_data.is_not_null());\n-        uvll::set_data_for_uv_handle(handle, null::<()>());\n-        let cb: ~CB = transmute::<*c_void, ~CB>(handle_data);\n-        let cb = match cb { ~cb => cb };\n-        return cb;\n+        str::raw::buf_as_slice(s, len, |d| cast::transmute(d))\n     }\n-}\n \n-/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n-struct WatcherData {\n-    read_cb: Option<ReadCallback>,\n-    write_cb: Option<ConnectionCallback>,\n-    connect_cb: Option<ConnectionCallback>,\n-    close_cb: Option<NullCallback>,\n-    alloc_cb: Option<AllocCallback>,\n-    buf: Option<Buf>\n-}\n \n-pub fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n     unsafe {\n-        let data = ~WatcherData {\n-            read_cb: None,\n-            write_cb: None,\n-            connect_cb: None,\n-            close_cb: None,\n-            alloc_cb: None,\n-            buf: None\n+        // Importing error constants\n+        use rt::uv::uvll::*;\n+        use rt::io::*;\n+\n+        // uv error descriptions are static\n+        let c_desc = uvll::strerror(&*uverr);\n+        let desc = c_str_to_static_slice(c_desc);\n+\n+        let kind = match uverr.code {\n+            UNKNOWN => OtherIoError,\n+            OK => OtherIoError,\n+            EOF => EndOfFile,\n+            EACCES => PermissionDenied,\n+            ECONNREFUSED => ConnectionRefused,\n+            ECONNRESET => ConnectionReset,\n+            EPIPE => BrokenPipe,\n+            e => {\n+                rtdebug!(\"e %u\", e as uint);\n+                // XXX: Need to map remaining uv error types\n+                OtherIoError\n+            }\n         };\n-        let data = transmute::<~WatcherData, *c_void>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), data);\n-    }\n-}\n \n-pub fn get_watcher_data<'r, H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &'r mut W) -> &'r mut WatcherData {\n-\n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n-        return &mut **data;\n-    }\n-}\n-\n-pub fn drop_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let _data = transmute::<*c_void, ~WatcherData>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n+        IoError {\n+            kind: kind,\n+            desc: desc,\n+            detail: None\n+        }\n     }\n }\n \n-#[test]\n-fn test_slice_to_uv_buf() {\n-    let slice = [0, .. 20];\n-    let buf = slice_to_uv_buf(slice);\n-\n-    assert!(buf.len == 20);\n-\n-    unsafe {\n-        let base = transmute::<*u8, *mut u8>(buf.base);\n-        (*base) = 1;\n-        (*ptr::mut_offset(base, 1)) = 2;\n+/// Given a uv handle, convert a callback status to a UvError\n+// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n+pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n+    if status != -1 {\n+        None\n+    } else {\n+        unsafe {\n+            rtdebug!(\"handle: %x\", handle as uint);\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            rtdebug!(\"loop: %x\", loop_ as uint);\n+            let err = uvll::last_error(loop_);\n+            Some(UvError(err))\n+        }\n     }\n-\n-    assert!(slice[0] == 1);\n-    assert!(slice[1] == 2);\n }\n \n /// The uv buffer type\n@@ -394,6 +341,24 @@ pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n     }\n }\n \n+#[test]\n+fn test_slice_to_uv_buf() {\n+    let slice = [0, .. 20];\n+    let buf = slice_to_uv_buf(slice);\n+\n+    assert!(buf.len == 20);\n+\n+    unsafe {\n+        let base = transmute::<*u8, *mut u8>(buf.base);\n+        (*base) = 1;\n+        (*ptr::mut_offset(base, 1)) = 2;\n+    }\n+\n+    assert!(slice[0] == 1);\n+    assert!(slice[1] == 2);\n+}\n+\n+\n #[test]\n fn loop_smoke_test() {\n     do run_in_bare_thread {\n@@ -409,7 +374,7 @@ fn idle_new_then_close() {\n     do run_in_bare_thread {\n         let mut loop_ = Loop::new();\n         let idle_watcher = { IdleWatcher::new(&mut loop_) };\n-        idle_watcher.close();\n+        idle_watcher.close(||());\n     }\n }\n \n@@ -425,7 +390,7 @@ fn idle_smoke_test() {\n             assert!(status.is_none());\n             if unsafe { *count_ptr == 10 } {\n                 idle_watcher.stop();\n-                idle_watcher.close();\n+                idle_watcher.close(||());\n             } else {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n             }\n@@ -449,7 +414,7 @@ fn idle_start_stop_start() {\n                 assert!(status.is_none());\n                 let mut idle_watcher = idle_watcher;\n                 idle_watcher.stop();\n-                idle_watcher.close();\n+                idle_watcher.close(||());\n             }\n         }\n         loop_.run();"}, {"sha": "bdd5588014c01436aa4934abfe064b4115746107", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 145, "deletions": 156, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -10,21 +10,15 @@\n \n use prelude::*;\n use libc::{size_t, ssize_t, c_int, c_void};\n-use cast::transmute_mut_region;\n-use super::super::uvll;\n-use super::super::uvll::*;\n-use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCallback,\n-            loop_from_watcher, status_to_maybe_uv_error,\n-            install_watcher_data, get_watcher_data, drop_watcher_data,\n-            vec_to_uv_buf, vec_from_uv_buf};\n-use super::super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n-\n-#[cfg(test)] use cell::Cell;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::super::thread::Thread;\n-#[cfg(test)] use super::super::test::*;\n-\n-fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n+use rt::uv::uvll;\n+use rt::uv::uvll::*;\n+use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback};\n+use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n+             status_to_maybe_uv_error};\n+use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n+use rt::uv::last_uv_error;\n+\n+fn ip4_as_uv_ip4<T>(addr: IpAddr, f: &fn(*sockaddr_in) -> T) -> T {\n     match addr {\n         Ipv4(a, b, c, d, p) => {\n             unsafe {\n@@ -34,7 +28,7 @@ fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n                                                 c as uint,\n                                                 d as uint), p as int);\n                 do (|| {\n-                    f(addr);\n+                    f(addr)\n                 }).finally {\n                     free_ip4_addr(addr);\n                 }\n@@ -47,34 +41,23 @@ fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n // uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n // and uv_file_t\n pub struct StreamWatcher(*uvll::uv_stream_t);\n-\n-impl Watcher for StreamWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n-\n-pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n-impl Callback for ReadCallback { }\n-\n-// XXX: The uv alloc callback also has a *uv_handle_t arg\n-pub type AllocCallback = ~fn(uint) -> Buf;\n-impl Callback for AllocCallback { }\n+impl Watcher for StreamWatcher { }\n \n pub impl StreamWatcher {\n \n     fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n-        // XXX: Borrowchk problems\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        data.alloc_cb = Some(alloc);\n-        data.read_cb = Some(cb);\n+        {\n+            let data = self.get_watcher_data();\n+            data.alloc_cb = Some(alloc);\n+            data.read_cb = Some(cb);\n+        }\n \n         let handle = self.native_handle();\n         unsafe { uvll::read_start(handle, alloc_cb, read_cb); }\n \n         extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = get_watcher_data(&mut stream_watcher);\n+            let data = stream_watcher.get_watcher_data();\n             let alloc_cb = data.alloc_cb.get_ref();\n             return (*alloc_cb)(suggested_size as uint);\n         }\n@@ -83,7 +66,7 @@ pub impl StreamWatcher {\n             rtdebug!(\"buf addr: %x\", buf.base as uint);\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = get_watcher_data(&mut stream_watcher);\n+            let data = stream_watcher.get_watcher_data();\n             let cb = data.read_cb.get_ref();\n             let status = status_to_maybe_uv_error(stream, nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n@@ -98,31 +81,27 @@ pub impl StreamWatcher {\n         unsafe { uvll::read_stop(handle); }\n     }\n \n-    // XXX: Needs to take &[u8], not ~[u8]\n-    fn write(&mut self, msg: ~[u8], cb: ConnectionCallback) {\n-        // XXX: Borrowck\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        assert!(data.write_cb.is_none());\n-        data.write_cb = Some(cb);\n+    fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.write_cb.is_none());\n+            data.write_cb = Some(cb);\n+        }\n \n         let req = WriteRequest::new();\n-        let buf = vec_to_uv_buf(msg);\n-        assert!(data.buf.is_none());\n-        data.buf = Some(buf);\n         let bufs = [buf];\n         unsafe {\n             assert!(0 == uvll::write(req.native_handle(),\n-                                          self.native_handle(),\n-                                          bufs, write_cb));\n+                                     self.native_handle(),\n+                                     bufs, write_cb));\n         }\n \n         extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n             let cb = {\n-                let data = get_watcher_data(&mut stream_watcher);\n-                let _vec = vec_from_uv_buf(data.buf.swap_unwrap());\n+                let data = stream_watcher.get_watcher_data();\n                 let cb = data.write_cb.swap_unwrap();\n                 cb\n             };\n@@ -142,7 +121,7 @@ pub impl StreamWatcher {\n     fn close(self, cb: NullCallback) {\n         {\n             let mut this = self;\n-            let data = get_watcher_data(&mut this);\n+            let data = this.get_watcher_data();\n             assert!(data.close_cb.is_none());\n             data.close_cb = Some(cb);\n         }\n@@ -152,9 +131,10 @@ pub impl StreamWatcher {\n         extern fn close_cb(handle: *uvll::uv_stream_t) {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n             {\n-                get_watcher_data(&mut stream_watcher).close_cb.swap_unwrap()();\n+                let data = stream_watcher.get_watcher_data();\n+                data.close_cb.swap_unwrap()();\n             }\n-            drop_watcher_data(&mut stream_watcher);\n+            stream_watcher.drop_watcher_data();\n             unsafe { free_handle(handle as *c_void) }\n         }\n     }\n@@ -171,37 +151,32 @@ impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n }\n \n pub struct TcpWatcher(*uvll::uv_tcp_t);\n-\n-impl Watcher for TcpWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n-\n-pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n-impl Callback for ConnectionCallback { }\n+impl Watcher for TcpWatcher { }\n \n pub impl TcpWatcher {\n     fn new(loop_: &mut Loop) -> TcpWatcher {\n         unsafe {\n             let handle = malloc_handle(UV_TCP);\n             assert!(handle.is_not_null());\n             assert!(0 == uvll::tcp_init(loop_.native_handle(), handle));\n-            let mut watcher = NativeHandle::from_native_handle(handle);\n-            install_watcher_data(&mut watcher);\n+            let mut watcher: TcpWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n             return watcher;\n         }\n     }\n \n-    fn bind(&mut self, address: IpAddr) {\n+    fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n         match address {\n             Ipv4(*) => {\n                 do ip4_as_uv_ip4(address) |addr| {\n                     let result = unsafe {\n                         uvll::tcp_bind(self.native_handle(), addr)\n                     };\n-                    // XXX: bind is likely to fail. need real error handling\n-                    assert!(result == 0);\n+                    if result == 0 {\n+                        Ok(())\n+                    } else {\n+                        Err(last_uv_error(self))\n+                    }\n                 }\n             }\n             _ => fail!()\n@@ -210,8 +185,8 @@ pub impl TcpWatcher {\n \n     fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n         unsafe {\n-            assert!(get_watcher_data(self).connect_cb.is_none());\n-            get_watcher_data(self).connect_cb = Some(cb);\n+            assert!(self.get_watcher_data().connect_cb.is_none());\n+            self.get_watcher_data().connect_cb = Some(cb);\n \n             let connect_handle = ConnectRequest::new().native_handle();\n             match address {\n@@ -232,7 +207,7 @@ pub impl TcpWatcher {\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n                 let cb: ConnectionCallback = {\n-                    let data = get_watcher_data(&mut stream_watcher);\n+                    let data = stream_watcher.get_watcher_data();\n                     data.connect_cb.swap_unwrap()\n                 };\n                 let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n@@ -242,10 +217,11 @@ pub impl TcpWatcher {\n     }\n \n     fn listen(&mut self, cb: ConnectionCallback) {\n-        // XXX: Borrowck\n-        let data = get_watcher_data(unsafe { transmute_mut_region(self) });\n-        assert!(data.connect_cb.is_none());\n-        data.connect_cb = Some(cb);\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.connect_cb.is_none());\n+            data.connect_cb = Some(cb);\n+        }\n \n         unsafe {\n             static BACKLOG: c_int = 128; // XXX should be configurable\n@@ -257,9 +233,10 @@ pub impl TcpWatcher {\n         extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = get_watcher_data(&mut stream_watcher).connect_cb.swap_unwrap();\n-            let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n-            cb(stream_watcher, status);\n+            let data = stream_watcher.get_watcher_data();\n+            let cb = data.connect_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(stream_watcher, status);\n         }\n     }\n \n@@ -277,12 +254,8 @@ impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n     }\n }\n \n-pub type ConnectCallback = ~fn(ConnectRequest, Option<UvError>);\n-impl Callback for ConnectCallback { }\n-\n // uv_connect_t is a subclass of uv_req_t\n struct ConnectRequest(*uvll::uv_connect_t);\n-\n impl Request for ConnectRequest { }\n \n impl ConnectRequest {\n@@ -355,93 +328,109 @@ impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n }\n \n \n-#[test]\n-fn connect_close() {\n-    do run_in_bare_thread() {\n-        let mut loop_ = Loop::new();\n-        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        // Connect to a port where nobody is listening\n-        let addr = next_test_ip4();\n-        do tcp_watcher.connect(addr) |stream_watcher, status| {\n-            rtdebug!(\"tcp_watcher.connect!\");\n-            assert!(status.is_some());\n-            assert!(status.get().name() == ~\"ECONNREFUSED\");\n-            stream_watcher.close(||());\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use util::ignore;\n+    use cell::Cell;\n+    use vec;\n+    use unstable::run_in_bare_thread;\n+    use rt::thread::Thread;\n+    use rt::test::*;\n+    use rt::uv::{Loop, AllocCallback};\n+    use rt::uv::{vec_from_uv_buf, vec_to_uv_buf, slice_to_uv_buf};\n+\n+    #[test]\n+    fn connect_close() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            // Connect to a port where nobody is listening\n+            let addr = next_test_ip4();\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"tcp_watcher.connect!\");\n+                assert!(status.is_some());\n+                assert!(status.get().name() == ~\"ECONNREFUSED\");\n+                stream_watcher.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n         }\n-        loop_.run();\n-        loop_.close();\n     }\n-}\n \n-#[test]\n-fn listen() {\n-    do run_in_bare_thread() {\n-        static MAX: int = 10;\n-        let mut loop_ = Loop::new();\n-        let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        let addr = next_test_ip4();\n-        server_tcp_watcher.bind(addr);\n-        let loop_ = loop_;\n-        rtdebug!(\"listening\");\n-        do server_tcp_watcher.listen |server_stream_watcher, status| {\n-            rtdebug!(\"listened!\");\n-            assert!(status.is_none());\n-            let mut server_stream_watcher = server_stream_watcher;\n-            let mut loop_ = loop_;\n-            let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-            let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-            server_stream_watcher.accept(client_tcp_watcher);\n-            let count_cell = Cell(0);\n-            let server_stream_watcher = server_stream_watcher;\n-            rtdebug!(\"starting read\");\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0))\n-            };\n-            do client_tcp_watcher.read_start(alloc)\n-                |stream_watcher, nread, buf, status| {\n-\n-                rtdebug!(\"i'm reading!\");\n-                let buf = vec_from_uv_buf(buf);\n-                let mut count = count_cell.take();\n-                if status.is_none() {\n-                    rtdebug!(\"got %d bytes\", nread);\n-                    let buf = buf.unwrap();\n-                    for buf.slice(0, nread as uint).each |byte| {\n-                        assert!(*byte == count as u8);\n-                        rtdebug!(\"%u\", *byte as uint);\n-                        count += 1;\n-                    }\n-                } else {\n-                    assert!(count == MAX);\n-                    do stream_watcher.close {\n-                        server_stream_watcher.close(||());\n+    #[test]\n+    fn listen() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip4();\n+            server_tcp_watcher.bind(addr);\n+            let loop_ = loop_;\n+            rtdebug!(\"listening\");\n+            do server_tcp_watcher.listen |server_stream_watcher, status| {\n+                rtdebug!(\"listened!\");\n+                assert!(status.is_none());\n+                let mut server_stream_watcher = server_stream_watcher;\n+                let mut loop_ = loop_;\n+                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                let count_cell = Cell(0);\n+                let server_stream_watcher = server_stream_watcher;\n+                rtdebug!(\"starting read\");\n+                let alloc: AllocCallback = |size| {\n+                    vec_to_uv_buf(vec::from_elem(size, 0))\n+                };\n+                do client_tcp_watcher.read_start(alloc)\n+                    |stream_watcher, nread, buf, status| {\n+\n+                    rtdebug!(\"i'm reading!\");\n+                    let buf = vec_from_uv_buf(buf);\n+                    let mut count = count_cell.take();\n+                    if status.is_none() {\n+                        rtdebug!(\"got %d bytes\", nread);\n+                        let buf = buf.unwrap();\n+                        for buf.slice(0, nread as uint).each |byte| {\n+                            assert!(*byte == count as u8);\n+                            rtdebug!(\"%u\", *byte as uint);\n+                            count += 1;\n+                        }\n+                    } else {\n+                        assert!(count == MAX);\n+                        do stream_watcher.close {\n+                            server_stream_watcher.close(||());\n+                        }\n                     }\n+                    count_cell.put_back(count);\n                 }\n-                count_cell.put_back(count);\n             }\n-        }\n \n-        let _client_thread = do Thread::start {\n-            rtdebug!(\"starting client thread\");\n-            let mut loop_ = Loop::new();\n-            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"connecting\");\n-                assert!(status.is_none());\n-                let mut stream_watcher = stream_watcher;\n-                let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n-                do stream_watcher.write(msg) |stream_watcher, status| {\n-                    rtdebug!(\"writing\");\n+            let _client_thread = do Thread::start {\n+                rtdebug!(\"starting client thread\");\n+                let mut loop_ = Loop::new();\n+                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+                do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                    rtdebug!(\"connecting\");\n                     assert!(status.is_none());\n-                    stream_watcher.close(||());\n+                    let mut stream_watcher = stream_watcher;\n+                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n+                    let buf = slice_to_uv_buf(msg);\n+                    let msg_cell = Cell(msg);\n+                    do stream_watcher.write(buf) |stream_watcher, status| {\n+                        rtdebug!(\"writing\");\n+                        assert!(status.is_none());\n+                        let msg_cell = Cell(msg_cell.take());\n+                        stream_watcher.close(||ignore(msg_cell.take()));\n+                    }\n                 }\n-            }\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            let mut loop_ = loop_;\n             loop_.run();\n             loop_.close();\n-        };\n-\n-        let mut loop_ = loop_;\n-        loop_.run();\n-        loop_.close();\n+        }\n     }\n }"}, {"sha": "5557a58098751bceab944e81df1c2e6e6ff709cd", "filename": "src/libcore/rt/uv/timer.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Ftimer.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -0,0 +1,183 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{c_void, c_int};\n+use option::Some;\n+use rt::uv::uvll;\n+use rt::uv::{Watcher, Loop, NativeHandle, TimerCallback, NullCallback};\n+use rt::uv::status_to_maybe_uv_error;\n+\n+pub struct TimerWatcher(*uvll::uv_timer_t);\n+impl Watcher for TimerWatcher { }\n+\n+impl TimerWatcher {\n+    pub fn new(loop_: &mut Loop) -> TimerWatcher {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_TIMER);\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::timer_init(loop_.native_handle(), handle));\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    pub fn start(&mut self, timeout: u64, repeat: u64, cb: TimerCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.timer_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            uvll::timer_start(self.native_handle(), timer_cb, timeout, repeat);\n+        }\n+\n+        extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            let data = watcher.get_watcher_data();\n+            let cb = data.timer_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(watcher, status);\n+        }\n+    }\n+\n+    pub fn stop(&mut self) {\n+        unsafe {\n+            uvll::timer_stop(self.native_handle());\n+        }\n+    }\n+\n+    pub fn close(self, cb: NullCallback) {\n+        let mut watcher = self;\n+        {\n+            let data = watcher.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            uvll::close(watcher.native_handle(), close_cb);\n+        }\n+\n+        extern fn close_cb(handle: *uvll::uv_timer_t) {\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            {\n+                let data = watcher.get_watcher_data();\n+                data.close_cb.swap_unwrap()();\n+            }\n+            watcher.drop_watcher_data();\n+            unsafe {\n+                uvll::free_handle(handle as *c_void);\n+            }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_timer_t> for TimerWatcher {\n+    fn from_native_handle(handle: *uvll::uv_timer_t) -> TimerWatcher {\n+        TimerWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &TimerWatcher(ptr) => ptr }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rt::uv::Loop;\n+    use unstable::run_in_bare_thread;\n+\n+    #[test]\n+    fn smoke_test() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 0) |timer, status| {\n+                assert!(status.is_none());\n+                unsafe { *count_ptr += 1 };\n+                timer.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn start_twice() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 0) |timer, status| {\n+                let mut timer = timer;\n+                assert!(status.is_none());\n+                unsafe { *count_ptr += 1 };\n+                do timer.start(10, 0) |timer, status| {\n+                    assert!(status.is_none());\n+                    unsafe { *count_ptr += 1 };\n+                    timer.close(||());\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 2);\n+        }\n+    }\n+\n+    #[test]\n+    fn repeat_stop() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 20) |timer, status| {\n+                assert!(status.is_none());\n+                unsafe {\n+                    *count_ptr += 1;\n+\n+                    if *count_ptr == 10 {\n+\n+                        // Stop the timer and do something else\n+                        let mut timer = timer;\n+                        timer.stop();\n+                        // Freeze timer so it can be captured\n+                        let timer = timer;\n+\n+                        let mut loop_ = timer.event_loop();\n+                        let mut timer2 = TimerWatcher::new(&mut loop_);\n+                        do timer2.start(10, 0) |timer2, _| {\n+\n+                            unsafe { *count_ptr += 1; }\n+\n+                            timer2.close(||());\n+\n+                            // Restart the original timer\n+                            let mut timer = timer;\n+                            do timer.start(10, 0) |timer, _| {\n+                                unsafe { *count_ptr += 1; }\n+                                timer.close(||());\n+                            }\n+                        }\n+                    }\n+                };\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 12);\n+        }\n+    }\n+\n+}"}, {"sha": "ce4eb6aff870126c0ae1fc7390e5484ec414e4e3", "filename": "src/libcore/rt/uv/uvio.rs", "status": "renamed", "additions": 162, "deletions": 129, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -10,20 +10,24 @@\n \n use option::*;\n use result::*;\n-\n-use super::io::net::ip::IpAddr;\n-use super::uv::*;\n-use super::rtio::*;\n use ops::Drop;\n use old_iter::CopyableIter;\n use cell::{Cell, empty_cell};\n use cast::transmute;\n-use super::sched::{Scheduler, local_sched};\n+use clone::Clone;\n+use rt::io::IoError;\n+use rt::io::net::ip::IpAddr;\n+use rt::uv::*;\n+use rt::uv::idle::IdleWatcher;\n+use rt::rtio::*;\n+use rt::sched::{Scheduler, local_sched};\n+use rt::io::{standard_error, OtherIoError};\n+use rt::tube::Tube;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use uint;\n #[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::test::*;\n+#[cfg(test)] use rt::test::*;\n \n pub struct UvEventLoop {\n     uvio: UvIoFactory\n@@ -64,7 +68,16 @@ impl EventLoop for UvEventLoop {\n             assert!(status.is_none());\n             let mut idle_watcher = idle_watcher;\n             idle_watcher.stop();\n-            idle_watcher.close();\n+            idle_watcher.close(||());\n+            f();\n+        }\n+    }\n+\n+    fn callback_ms(&mut self, ms: u64, f: ~fn()) {\n+        let mut timer =  TimerWatcher::new(self.uvio.uv_loop());\n+        do timer.start(ms, 0) |timer, status| {\n+            assert!(status.is_none());\n+            timer.close(||());\n             f();\n         }\n     }\n@@ -100,11 +113,11 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn connect(&mut self, addr: IpAddr) -> Option<~StreamObject> {\n+    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError> {\n         // Create a cell in the task to hold the result. We will fill\n         // the cell before resuming the task.\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n@@ -122,125 +135,151 @@ impl IoFactory for UvIoFactory {\n             // Wait for a connection\n             do tcp_watcher.connect(addr) |stream_watcher, status| {\n                 rtdebug!(\"connect: in connect callback\");\n-                let maybe_stream = if status.is_none() {\n+                if status.is_none() {\n                     rtdebug!(\"status is none\");\n-                    Some(~UvStream(stream_watcher))\n+                    let res = Ok(~UvTcpStream { watcher: stream_watcher });\n+\n+                    // Store the stream in the task's stack\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+\n+                    // Context switch\n+                    let scheduler = local_sched::take();\n+                    scheduler.resume_task_immediately(task_cell.take());\n                 } else {\n                     rtdebug!(\"status is some\");\n-                    stream_watcher.close(||());\n-                    None\n+                    let task_cell = Cell(task_cell.take());\n+                    do stream_watcher.close {\n+                        let res = Err(uv_error_to_io_error(status.get()));\n+                        unsafe { (*result_cell_ptr).put_back(res); }\n+                        let scheduler = local_sched::take();\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n                 };\n-\n-                // Store the stream in the task's stack\n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n \n-    fn bind(&mut self, addr: IpAddr) -> Option<~TcpListenerObject> {\n+    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError> {\n         let mut watcher = TcpWatcher::new(self.uv_loop());\n-        watcher.bind(addr);\n-        return Some(~UvTcpListener(watcher));\n+        match watcher.bind(addr) {\n+            Ok(_) => Ok(~UvTcpListener::new(watcher)),\n+            Err(uverr) => {\n+                let scheduler = local_sched::take();\n+                do scheduler.deschedule_running_task_and_then |task| {\n+                    let task_cell = Cell(task);\n+                    do watcher.as_stream().close {\n+                        let scheduler = local_sched::take();\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                }\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n     }\n }\n \n-pub struct UvTcpListener(TcpWatcher);\n+// FIXME #6090: Prefer newtype structs but Drop doesn't work\n+pub struct UvTcpListener {\n+    watcher: TcpWatcher,\n+    listening: bool,\n+    incoming_streams: Tube<Result<~RtioTcpStreamObject, IoError>>\n+}\n \n impl UvTcpListener {\n-    fn watcher(&self) -> TcpWatcher {\n-        match self { &UvTcpListener(w) => w }\n+    fn new(watcher: TcpWatcher) -> UvTcpListener {\n+        UvTcpListener {\n+            watcher: watcher,\n+            listening: false,\n+            incoming_streams: Tube::new()\n+        }\n     }\n \n-    fn close(&self) {\n-        // XXX: Need to wait until close finishes before returning\n-        self.watcher().as_stream().close(||());\n-    }\n+    fn watcher(&self) -> TcpWatcher { self.watcher }\n }\n \n impl Drop for UvTcpListener {\n     fn finalize(&self) {\n-        // XXX: Again, this never gets called. Use .close() instead\n-        //self.watcher().as_stream().close(||());\n+        let watcher = self.watcher();\n+        let scheduler = local_sched::take();\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let task_cell = Cell(task);\n+            do watcher.as_stream().close {\n+                let scheduler = local_sched::take();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n     }\n }\n \n-impl TcpListener for UvTcpListener {\n+impl RtioTcpListener for UvTcpListener {\n \n-    fn listen(&mut self) -> Option<~StreamObject> {\n+    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n         rtdebug!(\"entering listen\");\n-        let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n-\n-        let server_tcp_watcher = self.watcher();\n \n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n+        if self.listening {\n+            return self.incoming_streams.recv();\n+        }\n \n-        do scheduler.deschedule_running_task_and_then |task| {\n-            let task_cell = Cell(task);\n-            let mut server_tcp_watcher = server_tcp_watcher;\n-            do server_tcp_watcher.listen |server_stream_watcher, status| {\n-                let maybe_stream = if status.is_none() {\n-                    let mut server_stream_watcher = server_stream_watcher;\n-                    let mut loop_ = loop_from_watcher(&server_stream_watcher);\n-                    let client_tcp_watcher = TcpWatcher::new(&mut loop_).as_stream();\n-                    // XXX: Needs to be surfaced in interface\n-                    server_stream_watcher.accept(client_tcp_watcher);\n-                    Some(~UvStream::new(client_tcp_watcher))\n-                } else {\n-                    None\n-                };\n+        self.listening = true;\n \n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n+        let server_tcp_watcher = self.watcher();\n+        let incoming_streams_cell = Cell(self.incoming_streams.clone());\n+\n+        let incoming_streams_cell = Cell(incoming_streams_cell.take());\n+        let mut server_tcp_watcher = server_tcp_watcher;\n+        do server_tcp_watcher.listen |server_stream_watcher, status| {\n+            let maybe_stream = if status.is_none() {\n+                let mut server_stream_watcher = server_stream_watcher;\n+                let mut loop_ = server_stream_watcher.event_loop();\n+                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let client_tcp_watcher = client_tcp_watcher.as_stream();\n+                // XXX: Need's to be surfaced in interface\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                Ok(~UvTcpStream { watcher: client_tcp_watcher })\n+            } else {\n+                Err(standard_error(OtherIoError))\n+            };\n \n-                rtdebug!(\"resuming task from listen\");\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n+            let mut incoming_streams = incoming_streams_cell.take();\n+            incoming_streams.send(maybe_stream);\n+            incoming_streams_cell.put_back(incoming_streams);\n         }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+        return self.incoming_streams.recv();\n     }\n }\n \n-pub struct UvStream(StreamWatcher);\n-\n-impl UvStream {\n-    fn new(watcher: StreamWatcher) -> UvStream {\n-        UvStream(watcher)\n-    }\n-\n-    fn watcher(&self) -> StreamWatcher {\n-        match self { &UvStream(w) => w }\n-    }\n+// FIXME #6090: Prefer newtype structs but Drop doesn't work\n+pub struct UvTcpStream {\n+    watcher: StreamWatcher\n+}\n \n-    // XXX: finalize isn't working for ~UvStream???\n-    fn close(&self) {\n-        // XXX: Need to wait until this finishes before returning\n-        self.watcher().close(||());\n-    }\n+impl UvTcpStream {\n+    fn watcher(&self) -> StreamWatcher { self.watcher }\n }\n \n-impl Drop for UvStream {\n+impl Drop for UvTcpStream {\n     fn finalize(&self) {\n-        rtdebug!(\"closing stream\");\n-        //self.watcher().close(||());\n+        rtdebug!(\"closing tcp stream\");\n+        let watcher = self.watcher();\n+        let scheduler = local_sched::take();\n+        do scheduler.deschedule_running_task_and_then |task| {\n+            let task_cell = Cell(task);\n+            do watcher.close {\n+                let scheduler = local_sched::take();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n     }\n }\n \n-impl Stream for UvStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()> {\n+impl RtioTcpStream for UvTcpStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n@@ -271,7 +310,7 @@ impl Stream for UvStream {\n                     assert!(nread >= 0);\n                     Ok(nread as uint)\n                 } else {\n-                    Err(())\n+                    Err(uv_error_to_io_error(status.unwrap()))\n                 };\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n@@ -285,24 +324,22 @@ impl Stream for UvStream {\n         return result_cell.take();\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&[u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |task| {\n             let mut watcher = watcher;\n             let task_cell = Cell(task);\n-            let buf = unsafe { &*buf_ptr };\n-            // XXX: OMGCOPIES\n-            let buf = buf.to_vec();\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n             do watcher.write(buf) |_watcher, status| {\n                 let result = if status.is_none() {\n                     Ok(())\n                 } else {\n-                    Err(())\n+                    Err(uv_error_to_io_error(status.unwrap()))\n                 };\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n@@ -320,10 +357,12 @@ impl Stream for UvStream {\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n-        let io = unsafe { local_sched::unsafe_borrow_io() };\n-        let addr = next_test_ip4();\n-        let maybe_chan = io.connect(addr);\n-        assert!(maybe_chan.is_none());\n+        unsafe {\n+            let io = local_sched::unsafe_borrow_io();\n+            let addr = next_test_ip4();\n+            let maybe_chan = (*io).tcp_connect(addr);\n+            assert!(maybe_chan.is_err());\n+        }\n     }\n }\n \n@@ -336,26 +375,23 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n+                let mut listener = (*io).tcp_bind(addr).unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n                 assert!(nread == 8);\n                 for uint::range(0, nread) |i| {\n                     rtdebug!(\"%u\", buf[i] as uint);\n                     assert!(buf[i] == i as u8);\n                 }\n-                stream.close();\n-                listener.close();\n             }\n         }\n \n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut stream = io.connect(addr).unwrap();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n             }\n         }\n     }\n@@ -368,8 +404,8 @@ fn test_read_and_block() {\n \n         do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut listener = io.bind(addr).unwrap();\n-            let mut stream = listener.listen().unwrap();\n+            let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n+            let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n             let expected = 32;\n@@ -392,26 +428,24 @@ fn test_read_and_block() {\n                 do scheduler.deschedule_running_task_and_then |task| {\n                     let task = Cell(task);\n                     do local_sched::borrow |scheduler| {\n-                        scheduler.task_queue.push_back(task.take());\n+                        scheduler.enqueue_task(task.take());\n                     }\n                 }\n             }\n \n             // Make sure we had multiple reads\n             assert!(reads > 1);\n-\n-            stream.close();\n-            listener.close();\n         }\n \n         do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.close();\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            }\n         }\n \n     }\n@@ -426,34 +460,33 @@ fn test_read_read_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n+                let mut listener = (*io).tcp_bind(addr).unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let buf = [1, .. 2048];\n                 let mut total_bytes_written = 0;\n                 while total_bytes_written < MAX {\n                     stream.write(buf);\n                     total_bytes_written += buf.len();\n                 }\n-                stream.close();\n-                listener.close();\n             }\n         }\n \n         do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            let mut buf = [0, .. 2048];\n-            let mut total_bytes_read = 0;\n-            while total_bytes_read < MAX {\n-                let nread = stream.read(buf).unwrap();\n-                rtdebug!(\"read %u bytes\", nread as uint);\n-                total_bytes_read += nread;\n-                for uint::range(0, nread) |i| {\n-                    assert!(buf[i] == 1);\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let mut buf = [0, .. 2048];\n+                let mut total_bytes_read = 0;\n+                while total_bytes_read < MAX {\n+                    let nread = stream.read(buf).unwrap();\n+                    rtdebug!(\"read %u bytes\", nread as uint);\n+                    total_bytes_read += nread;\n+                    for uint::range(0, nread) |i| {\n+                        assert!(buf[i] == 1);\n+                    }\n                 }\n+                rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n             }\n-            rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n-            stream.close();\n         }\n     }\n }", "previous_filename": "src/libcore/rt/uvio.rs"}, {"sha": "94e1703b263de45fa4c5ac86f5c76ac02a6b115b", "filename": "src/libcore/rt/uv/uvll.rs", "status": "renamed", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -33,6 +33,15 @@ use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n use libc::{malloc, free};\n use prelude::*;\n \n+pub static UNKNOWN: c_int = -1;\n+pub static OK: c_int = 0;\n+pub static EOF: c_int = 1;\n+pub static EADDRINFO: c_int = 2;\n+pub static EACCES: c_int = 3;\n+pub static ECONNREFUSED: c_int = 12;\n+pub static ECONNRESET: c_int = 13;\n+pub static EPIPE: c_int = 36;\n+\n pub struct uv_err_t {\n     code: c_int,\n     sys_errno_: c_int\n@@ -260,9 +269,9 @@ pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n     return rust_uv_timer_init(loop_ptr, timer_ptr);\n }\n-pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n-                          repeat: uint) -> c_int {\n-    return rust_uv_timer_start(timer_ptr, cb, timeout as c_uint, repeat as c_uint);\n+pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: u64,\n+                          repeat: u64) -> c_int {\n+    return rust_uv_timer_start(timer_ptr, cb, timeout, repeat);\n }\n pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n     return rust_uv_timer_stop(timer_ptr);\n@@ -423,8 +432,8 @@ extern {\n                           timer_handle: *uv_timer_t) -> c_int;\n     fn rust_uv_timer_start(timer_handle: *uv_timer_t,\n                            cb: *u8,\n-                           timeout: c_uint,\n-                           repeat: c_uint) -> c_int;\n+                           timeout: libc::uint64_t,\n+                           repeat: libc::uint64_t) -> c_int;\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n \n     fn rust_uv_malloc_buf_base_of(sug_size: size_t) -> *u8;", "previous_filename": "src/libcore/rt/uvll.rs"}, {"sha": "f82b5847ef2b8a7562588357d39f2eee252721f6", "filename": "src/libcore/rt/work_queue.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fwork_queue.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -46,4 +46,8 @@ pub impl<T> WorkQueue<T> {\n             None\n         }\n     }\n+\n+    fn is_empty(&self) -> bool {\n+        return self.queue.is_empty();\n+    }\n }"}, {"sha": "50a739ec67df7616268578fb6c0f5fca7a2542e4", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -202,10 +202,12 @@ impl FailWithCause for &'static str {\n \n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n-    use rt::{context, OldTaskContext};\n-    use rt::local_services::unsafe_borrow_local_services;\n+    use option::Option;\n+    use rt::{context, OldTaskContext, TaskContext};\n+    use rt::local_services::{unsafe_borrow_local_services, Unwinder};\n \n-    match context() {\n+    let context = context();\n+    match context {\n         OldTaskContext => {\n             unsafe {\n                 gc::cleanup_stack_for_failure();\n@@ -214,11 +216,26 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n             }\n         }\n         _ => {\n-            // XXX: Need to print the failure message\n-            gc::cleanup_stack_for_failure();\n             unsafe {\n+                // XXX: Bad re-allocations. fail! needs some refactoring\n+                let msg = str::raw::from_c_str(msg);\n+                let file = str::raw::from_c_str(file);\n+\n+                let outmsg = fmt!(\"%s at line %i of file %s\", msg, line as int, file);\n+\n+                // XXX: Logging doesn't work correctly in non-task context because it\n+                // invokes the local heap\n+                if context == TaskContext {\n+                    error!(outmsg);\n+                } else {\n+                    rtdebug!(\"%s\", outmsg);\n+                }\n+\n+                gc::cleanup_stack_for_failure();\n+\n                 let local_services = unsafe_borrow_local_services();\n-                match local_services.unwinder {\n+                let unwinder: &mut Option<Unwinder> = &mut (*local_services).unwinder;\n+                match *unwinder {\n                     Some(ref mut unwinder) => unwinder.begin_unwind(),\n                     None => abort!(\"failure without unwinder. aborting process\")\n                 }"}, {"sha": "be4e639e94c32e2e1f9cb8568e195a686ac0f0b3", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -36,7 +36,7 @@ impl Handle {\n                 }\n                 _ => {\n                     let local_services = unsafe_borrow_local_services();\n-                    NewHandle(&mut local_services.storage)\n+                    NewHandle(&mut (*local_services).storage)\n                 }\n             }\n         }"}, {"sha": "a6edee38e188a6668d0b5fdd6c76e9a63ca9de88", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -43,6 +43,7 @@ use task::rt::{task_id, sched_id};\n use util;\n use util::replace;\n use unstable::finally::Finally;\n+use rt::{context, OldTaskContext};\n \n #[cfg(test)] use comm::SharedChan;\n \n@@ -558,23 +559,33 @@ pub fn get_scheduler() -> Scheduler {\n  * ~~~\n  */\n pub unsafe fn unkillable<U>(f: &fn() -> U) -> U {\n-    let t = rt::rust_get_task();\n-    do (|| {\n-        rt::rust_task_inhibit_kill(t);\n+    if context() == OldTaskContext {\n+        let t = rt::rust_get_task();\n+        do (|| {\n+            rt::rust_task_inhibit_kill(t);\n+            f()\n+        }).finally {\n+            rt::rust_task_allow_kill(t);\n+        }\n+    } else {\n+        // FIXME #6377\n         f()\n-    }).finally {\n-        rt::rust_task_allow_kill(t);\n     }\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n-    let t = rt::rust_get_task();\n-    do (|| {\n-        rt::rust_task_allow_kill(t);\n+    if context() == OldTaskContext {\n+        let t = rt::rust_get_task();\n+        do (|| {\n+            rt::rust_task_allow_kill(t);\n+            f()\n+        }).finally {\n+            rt::rust_task_inhibit_kill(t);\n+        }\n+    } else {\n+        // FIXME #6377\n         f()\n-    }).finally {\n-        rt::rust_task_inhibit_kill(t);\n     }\n }\n \n@@ -583,14 +594,19 @@ pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n  * For use with exclusive ARCs, which use pthread mutexes directly.\n  */\n pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n-    let t = rt::rust_get_task();\n-    do (|| {\n-        rt::rust_task_inhibit_kill(t);\n-        rt::rust_task_inhibit_yield(t);\n+    if context() == OldTaskContext {\n+        let t = rt::rust_get_task();\n+        do (|| {\n+            rt::rust_task_inhibit_kill(t);\n+            rt::rust_task_inhibit_yield(t);\n+            f()\n+        }).finally {\n+            rt::rust_task_allow_yield(t);\n+            rt::rust_task_allow_kill(t);\n+        }\n+    } else {\n+        // FIXME #6377\n         f()\n-    }).finally {\n-        rt::rust_task_allow_yield(t);\n-        rt::rust_task_allow_kill(t);\n     }\n }\n "}, {"sha": "5f9642604d0c14c761c9310d101d1f55eb859a2f", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -581,7 +581,7 @@ fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::new(&mut sched.stack_pool, f);\n+    let task = ~Coroutine::new(&mut sched.stack_pool, f);\n     sched.schedule_new_task(task);\n }\n "}, {"sha": "1249392484d235e98176bfc3f406154d3ea03f9f", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -16,12 +16,12 @@ use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int, STDERR_FILENO};\n use managed::raw::BoxRepr;\n use str;\n use sys;\n-use unstable::exchange_alloc;\n use cast::transmute;\n use rt::{context, OldTaskContext};\n use rt::local_services::borrow_local_services;\n use option::{Option, Some, None};\n use io;\n+use rt::global_heap;\n \n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n@@ -153,7 +153,7 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n #[lang=\"exchange_malloc\"]\n #[inline(always)]\n pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    transmute(exchange_alloc::malloc(transmute(td), transmute(size)))\n+    transmute(global_heap::malloc(transmute(td), transmute(size)))\n }\n \n /// Because this code is so perf. sensitive, use a static constant so that\n@@ -233,7 +233,7 @@ impl DebugPrints for io::fd_t {\n #[lang=\"exchange_free\"]\n #[inline(always)]\n pub unsafe fn exchange_free(ptr: *c_char) {\n-    exchange_alloc::free(transmute(ptr))\n+    global_heap::free(transmute(ptr))\n }\n \n #[lang=\"malloc\"]\n@@ -423,18 +423,31 @@ pub unsafe fn strdup_uniq(ptr: *c_uchar, len: uint) -> ~str {\n #[lang=\"start\"]\n pub fn start(main: *u8, argc: int, argv: **c_char,\n              crate_map: *u8) -> int {\n-    use libc::getenv;\n-    use rt::start;\n+    use rt;\n+    use sys::Closure;\n+    use ptr;\n+    use cast;\n+    use os;\n \n     unsafe {\n-        let use_old_rt = do str::as_c_str(\"RUST_NEWRT\") |s| {\n-            getenv(s).is_null()\n-        };\n+        let use_old_rt = os::getenv(\"RUST_NEWRT\").is_none();\n         if use_old_rt {\n             return rust_start(main as *c_void, argc as c_int, argv,\n                               crate_map as *c_void) as int;\n         } else {\n-            return start(main, argc, argv, crate_map);\n+            return do rt::start(argc, argv as **u8, crate_map) {\n+                unsafe {\n+                    // `main` is an `fn() -> ()` that doesn't take an environment\n+                    // XXX: Could also call this as an `extern \"Rust\" fn` once they work\n+                    let main = Closure {\n+                        code: main as *(),\n+                        env: ptr::null(),\n+                    };\n+                    let mainfn: &fn() = cast::transmute(main);\n+\n+                    mainfn();\n+                }\n+            };\n         }\n     }\n "}, {"sha": "18a6262f17de99b2b78ccef78a120b8a8e1d57c0", "filename": "src/libcore/unstable/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibcore%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fmod.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -19,7 +19,6 @@ pub mod at_exit;\n pub mod global;\n pub mod finally;\n pub mod weak_task;\n-pub mod exchange_alloc;\n pub mod intrinsics;\n pub mod simd;\n pub mod extfmt;"}, {"sha": "93b6540a40d28b13a85fcdf9c96d8712ac91d91a", "filename": "src/libstd/future.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -25,8 +25,7 @@\n \n use core::cast;\n use core::cell::Cell;\n-use core::comm::{PortOne, oneshot, send_one};\n-use core::pipes::recv;\n+use core::comm::{PortOne, oneshot, send_one, recv_one};\n use core::task;\n use core::util::replace;\n \n@@ -107,11 +106,8 @@ pub fn from_port<A:Owned>(port: PortOne<A>) -> Future<A> {\n      */\n \n     let port = Cell(port);\n-    do from_fn || {\n-        let port = port.take().unwrap();\n-        match recv(port) {\n-            oneshot::send(data) => data\n-        }\n+    do from_fn {\n+        recv_one(port.take())\n     }\n }\n "}, {"sha": "bc7703ec30a1c69ebc60aab43545aa2690fe5732", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -819,8 +819,8 @@ extern {\n     unsafe fn rust_uv_timer_start(\n         timer_handle: *uv_timer_t,\n         cb: *u8,\n-        timeout: libc::c_uint,\n-        repeat: libc::c_uint) -> libc::c_int;\n+        timeout: libc::uint64_t,\n+        repeat: libc::uint64_t) -> libc::c_int;\n     unsafe fn rust_uv_timer_stop(handle: *uv_timer_t) -> libc::c_int;\n \n     unsafe fn rust_uv_getaddrinfo(loop_ptr: *libc::c_void,\n@@ -1084,8 +1084,8 @@ pub unsafe fn timer_init(loop_ptr: *libc::c_void,\n }\n pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n                       repeat: uint) -> libc::c_int {\n-    return rust_uv_timer_start(timer_ptr, cb, timeout as libc::c_uint,\n-                                    repeat as libc::c_uint);\n+    return rust_uv_timer_start(timer_ptr, cb, timeout as libc::uint64_t,\n+                               repeat as libc::uint64_t);\n }\n pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> libc::c_int {\n     return rust_uv_timer_stop(timer_ptr);"}, {"sha": "3889650d012e094592785461bf192f0b07d26b4d", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -15,11 +15,10 @@ use sort;\n \n use core::cell::Cell;\n use core::cmp;\n-use core::comm::{PortOne, oneshot, send_one};\n+use core::comm::{PortOne, oneshot, send_one, recv_one};\n use core::either::{Either, Left, Right};\n use core::hashmap::HashMap;\n use core::io;\n-use core::pipes::recv;\n use core::run;\n use core::to_bytes;\n use core::util::replace;\n@@ -389,9 +388,7 @@ fn unwrap<T:Owned +\n         None => fail!(),\n         Some(Left(v)) => v,\n         Some(Right(port)) => {\n-            let (exe, v) = match recv(port.unwrap()) {\n-                oneshot::send(data) => data\n-            };\n+            let (exe, v) = recv_one(port);\n \n             let s = json_encode(&v);\n "}, {"sha": "1a64066b5a946468505d7dcede48ba8b4cc4ab2a", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -830,14 +830,14 @@ rust_get_rt_env() {\n }\n \n #ifndef _WIN32\n-pthread_key_t sched_key;\n+pthread_key_t rt_key = -1;\n #else\n-DWORD sched_key;\n+DWORD rt_key = -1;\n #endif\n \n extern \"C\" void*\n-rust_get_sched_tls_key() {\n-    return &sched_key;\n+rust_get_rt_tls_key() {\n+    return &rt_key;\n }\n \n // Initialize the global state required by the new scheduler\n@@ -852,10 +852,10 @@ rust_initialize_global_state() {\n     if (!initialized) {\n \n #ifndef _WIN32\n-        assert(!pthread_key_create(&sched_key, NULL));\n+        assert(!pthread_key_create(&rt_key, NULL));\n #else\n-        sched_key = TlsAlloc();\n-        assert(sched_key != TLS_OUT_OF_INDEXES);\n+        rt_key = TlsAlloc();\n+        assert(rt_key != TLS_OUT_OF_INDEXES);\n #endif\n \n         initialized = true;"}, {"sha": "ed38be3550f74f1ab6ce1d2a0654e2e316e39200", "filename": "src/rt/rust_env.cpp", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_env.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_env.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.cpp?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -13,6 +13,7 @@\n // that might come from the environment is loaded here, once, during\n // init.\n \n+#include \"sync/lock_and_signal.h\"\n #include \"rust_env.h\"\n \n // The environment variables that the runtime knows about\n@@ -26,6 +27,18 @@\n #define RUST_DEBUG_MEM \"RUST_DEBUG_MEM\"\n #define RUST_DEBUG_BORROW \"RUST_DEBUG_BORROW\"\n \n+static lock_and_signal env_lock;\n+\n+extern \"C\" CDECL void\n+rust_take_env_lock() {\n+    env_lock.lock();\n+}\n+\n+extern \"C\" CDECL void\n+rust_drop_env_lock() {\n+    env_lock.unlock();\n+}\n+\n #if defined(__WIN32__)\n static int\n get_num_cpus() {\n@@ -119,6 +132,8 @@ copyenv(const char* name) {\n \n rust_env*\n load_env(int argc, char **argv) {\n+    scoped_lock with(env_lock);\n+\n     rust_env *env = (rust_env*)malloc(sizeof(rust_env));\n \n     env->num_sched_threads = (size_t)get_num_threads();\n@@ -141,3 +156,4 @@ free_env(rust_env *env) {\n     free(env->rust_seed);\n     free(env);\n }\n+"}, {"sha": "89257dc9f6e432172d4cb5729b89cc851cecfbdf", "filename": "src/rt/rust_exchange_alloc.cpp", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_exchange_alloc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_exchange_alloc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_exchange_alloc.cpp?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -15,14 +15,15 @@\n #include <string.h>\n #include <stdio.h>\n \n-uintptr_t exchange_count = 0;\n+extern uintptr_t rust_exchange_count;\n+uintptr_t rust_exchange_count = 0;\n \n void *\n rust_exchange_alloc::malloc(size_t size) {\n   void *value = ::malloc(size);\n   assert(value);\n \n-  sync::increment(exchange_count);\n+  sync::increment(rust_exchange_count);\n \n   return value;\n }\n@@ -36,20 +37,15 @@ rust_exchange_alloc::realloc(void *ptr, size_t size) {\n \n void\n rust_exchange_alloc::free(void *ptr) {\n-  sync::decrement(exchange_count);\n+  sync::decrement(rust_exchange_count);\n   ::free(ptr);\n }\n \n-extern \"C\" uintptr_t *\n-rust_get_exchange_count_ptr() {\n-  return &exchange_count;\n-}\n-\n void\n rust_check_exchange_count_on_exit() {\n-  if (exchange_count != 0) {\n+  if (rust_exchange_count != 0) {\n     printf(\"exchange heap not empty on exit\\n\");\n-    printf(\"%d dangling allocations\\n\", (int)exchange_count);\n+    printf(\"%d dangling allocations\\n\", (int)rust_exchange_count);\n     abort();\n   }\n }"}, {"sha": "df24f569495b49314c751e81e7df3d714c3817fb", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -324,6 +324,10 @@ void update_log_settings(void* crate_map, char* settings) {\n     free(buffer);\n }\n \n+extern \"C\" CDECL void\n+rust_update_log_settings(void* crate_map, char* settings) {\n+    update_log_settings(crate_map, settings);\n+}\n \n //\n // Local Variables:"}, {"sha": "a609ac573245d625e9831404ec8b821edb275fe0", "filename": "src/rt/rust_stack.cpp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_stack.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_stack.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_stack.cpp?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -92,3 +92,14 @@ destroy_exchange_stack(rust_exchange_alloc *exchange, stk_seg *stk) {\n     deregister_valgrind_stack(stk);\n     exchange->free(stk);\n }\n+\n+\n+extern \"C\" CDECL unsigned int\n+rust_valgrind_stack_register(void *start, void *end) {\n+  return VALGRIND_STACK_REGISTER(start, end);\n+}\n+\n+extern \"C\" CDECL void\n+rust_valgrind_stack_deregister(unsigned int id) {\n+  VALGRIND_STACK_DEREGISTER(id);\n+}"}, {"sha": "fefcbbcacf7d499fdc0dc7ed53b350c096549969", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -229,7 +229,7 @@ rust_uv_timer_init(uv_loop_t* loop, uv_timer_t* timer) {\n \n extern \"C\" int\n rust_uv_timer_start(uv_timer_t* the_timer, uv_timer_cb cb,\n-                        uint32_t timeout, uint32_t repeat) {\n+                    int64_t timeout, int64_t repeat) {\n     return uv_timer_start(the_timer, cb, timeout, repeat);\n }\n "}, {"sha": "cdc282440b830cae3574488909cad94bcdd412af", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -195,8 +195,8 @@ rust_register_exit_function\n rust_get_global_data_ptr\n rust_inc_kernel_live_count\n rust_dec_kernel_live_count\n-rust_get_exchange_count_ptr\n-rust_get_sched_tls_key\n+rust_exchange_count\n+rust_get_rt_tls_key\n swap_registers\n rust_readdir\n rust_opendir\n@@ -234,3 +234,8 @@ rust_try\n rust_begin_unwind\n rust_take_task_borrow_list\n rust_set_task_borrow_list\n+rust_valgrind_stack_register\n+rust_valgrind_stack_deregister\n+rust_take_env_lock\n+rust_drop_env_lock\n+rust_update_log_settings"}, {"sha": "3a0b4b6d40da9fc43be27663a6aac23068bcdacd", "filename": "src/test/run-pass/core-rt-smoke.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Ftest%2Frun-pass%2Fcore-rt-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee479f3e98474cd8125432f7a0c5c18bc2bd342/src%2Ftest%2Frun-pass%2Fcore-rt-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-rt-smoke.rs?ref=3ee479f3e98474cd8125432f7a0c5c18bc2bd342", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+\n+// A simple test of starting the runtime manually\n+\n+#[start]\n+fn start(argc: int, argv: **u8, crate_map: *u8) -> int {\n+    do core::rt::start(argc, argv, crate_map) {\n+        debug!(\"creating my own runtime is joy\");\n+    }\n+}\n\\ No newline at end of file"}]}