{"sha": "8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMGY0ZjVkM2FhNmRlYWM0ZWY4YjM3MWJkMDQzZjVjMWRmMmMyNTQ=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2016-02-03T18:27:32Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2016-02-03T23:34:53Z"}, "message": "Avoid quadratic growth of functions due to cleanups\n\nIf a new cleanup is added to a cleanup scope, the cached exits for that\nscope are cleared, so all previous cleanups have to be translated\nagain. In the worst case this means that we get N distinct landing pads\nwhere the last one has N cleanups, then N-1 and so on.\n\nAs new cleanups are to be executed before older ones, we can instead\ncache the number of already translated cleanups in addition to the\nblock that contains them, and then only translate new ones, if any and\nthen jump to the cached ones, getting away with linear growth instead.\n\nFor the crate in #31381 this reduces the compile time for an optimized\nbuild from >20 minutes (I cancelled the build at that point) to about 11\nseconds. Testing a few crates that come with rustc show compile time\nimprovements somewhere between 1 and 8%. The \"big\" winner being\nrustc_platform_intrinsics which features code similar to that in #31381.\n\nFixes #31381", "tree": {"sha": "9734ce3a276f99e3f83bab6f87a1726ac73cf12c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9734ce3a276f99e3f83bab6f87a1726ac73cf12c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254", "html_url": "https://github.com/rust-lang/rust/commit/8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d4e94a501d77248e6c8bbf08b8489a823bc7c29", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d4e94a501d77248e6c8bbf08b8489a823bc7c29", "html_url": "https://github.com/rust-lang/rust/commit/2d4e94a501d77248e6c8bbf08b8489a823bc7c29"}], "stats": {"total": 84, "additions": 71, "deletions": 13}, "files": [{"sha": "7c98868dfe7c6c55dbf3a86cd9b1392743b427f4", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254", "patch": "@@ -200,6 +200,7 @@ pub enum UnwindKind {\n pub struct CachedEarlyExit {\n     label: EarlyExitLabel,\n     cleanup_block: BasicBlockRef,\n+    last_cleanup: usize,\n }\n \n pub trait Cleanup<'tcx> {\n@@ -560,7 +561,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         for scope in self.scopes.borrow_mut().iter_mut().rev() {\n             if scope.kind.is_ast_with_id(cleanup_scope) {\n                 scope.cleanups.push(cleanup);\n-                scope.clear_cached_exits();\n+                scope.cached_landing_pad = None;\n                 return;\n             } else {\n                 // will be adding a cleanup to some enclosing scope\n@@ -585,7 +586,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         let mut scopes = self.scopes.borrow_mut();\n         let scope = &mut (*scopes)[custom_scope.index];\n         scope.cleanups.push(cleanup);\n-        scope.clear_cached_exits();\n+        scope.cached_landing_pad = None;\n     }\n \n     /// Returns true if there are pending cleanups that should execute on panic.\n@@ -723,6 +724,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         let orig_scopes_len = self.scopes_len();\n         let mut prev_llbb;\n         let mut popped_scopes = vec!();\n+        let mut skip = 0;\n \n         // First we pop off all the cleanup stacks that are\n         // traversed until the exit is reached, pushing them\n@@ -769,20 +771,25 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 }\n             }\n \n+            // Pop off the scope, since we may be generating\n+            // unwinding code for it.\n+            let top_scope = self.pop_scope();\n+            let cached_exit = top_scope.cached_early_exit(label);\n+            popped_scopes.push(top_scope);\n+\n             // Check if we have already cached the unwinding of this\n             // scope for this label. If so, we can stop popping scopes\n             // and branch to the cached label, since it contains the\n             // cleanups for any subsequent scopes.\n-            if let Some(exit) = self.top_scope(|s| s.cached_early_exit(label)) {\n+            if let Some((exit, last_cleanup)) = cached_exit {\n                 prev_llbb = exit;\n+                skip = last_cleanup;\n                 break;\n             }\n \n-            // Pop off the scope, since we will be generating\n-            // unwinding code for it. If we are searching for a loop exit,\n+            // If we are searching for a loop exit,\n             // and this scope is that loop, then stop popping and set\n             // `prev_llbb` to the appropriate exit block from the loop.\n-            popped_scopes.push(self.pop_scope());\n             let scope = popped_scopes.last().unwrap();\n             match label {\n                 UnwindExit(..) | ReturnExit => { }\n@@ -826,13 +833,15 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let bcx_in = self.new_block(&name[..], None);\n                 let exit_label = label.start(bcx_in);\n                 let mut bcx_out = bcx_in;\n-                for cleanup in scope.cleanups.iter().rev() {\n+                let len = scope.cleanups.len();\n+                for cleanup in scope.cleanups.iter().rev().take(len - skip) {\n                     bcx_out = cleanup.trans(bcx_out, scope.debug_loc);\n                 }\n+                skip = 0;\n                 exit_label.branch(bcx_out, prev_llbb);\n                 prev_llbb = bcx_in.llbb;\n \n-                scope.add_cached_early_exit(exit_label, prev_llbb);\n+                scope.add_cached_early_exit(exit_label, prev_llbb, len);\n             }\n             self.push_scope(scope);\n         }\n@@ -938,18 +947,20 @@ impl<'blk, 'tcx> CleanupScope<'blk, 'tcx> {\n \n     fn cached_early_exit(&self,\n                          label: EarlyExitLabel)\n-                         -> Option<BasicBlockRef> {\n-        self.cached_early_exits.iter().\n+                         -> Option<(BasicBlockRef, usize)> {\n+        self.cached_early_exits.iter().rev().\n             find(|e| e.label == label).\n-            map(|e| e.cleanup_block)\n+            map(|e| (e.cleanup_block, e.last_cleanup))\n     }\n \n     fn add_cached_early_exit(&mut self,\n                              label: EarlyExitLabel,\n-                             blk: BasicBlockRef) {\n+                             blk: BasicBlockRef,\n+                             last_cleanup: usize) {\n         self.cached_early_exits.push(\n             CachedEarlyExit { label: label,\n-                              cleanup_block: blk });\n+                              cleanup_block: blk,\n+                              last_cleanup: last_cleanup});\n     }\n \n     /// True if this scope has cleanups that need unwinding"}, {"sha": "2ac8de6d802947e3fc43c899b0c6513699c45702", "filename": "src/test/codegen/drop.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254/src%2Ftest%2Fcodegen%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254/src%2Ftest%2Fcodegen%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdrop.rs?ref=8c0f4f5d3aa6deac4ef8b371bd043f5c1df2c254", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+struct SomeUniqueName;\n+\n+impl Drop for SomeUniqueName {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+pub fn possibly_unwinding() {\n+}\n+\n+// CHECK-LABEL: @droppy\n+#[no_mangle]\n+pub fn droppy() {\n+// Check that there are exactly 6 drop calls. The cleanups for the unwinding should be reused, so\n+// that's one new drop call per call to possibly_unwinding(), and finally 3 drop calls for the\n+// regular function exit. We used to have problems with quadratic growths of drop calls in such\n+// functions.\n+// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n+// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n+// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n+// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n+// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n+// CHECK: call{{.*}}SomeUniqueName{{.*}}drop\n+// CHECK-NOT: call{{.*}}SomeUniqueName{{.*}}drop\n+// The next line checks for the } that ends the function definition\n+// CHECK-LABEL: {{^[}]}}\n+    let _s = SomeUniqueName;\n+    possibly_unwinding();\n+    let _s = SomeUniqueName;\n+    possibly_unwinding();\n+    let _s = SomeUniqueName;\n+    possibly_unwinding();\n+}"}]}