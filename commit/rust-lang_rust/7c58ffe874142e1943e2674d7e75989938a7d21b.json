{"sha": "7c58ffe874142e1943e2674d7e75989938a7d21b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNThmZmU4NzQxNDJlMTk0M2UyNjc0ZDdlNzU5ODk5MzhhN2QyMWI=", "commit": {"author": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-01-31T12:24:57Z"}, "committer": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-11T09:47:40Z"}, "message": "Invert control in struct_lint_level.\n\nCaller now passes in a `decorate` function, which is only run if the\nlint is allowed.", "tree": {"sha": "1a8486c1492d3038d9cc6e4032c69f2aa10a4d99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a8486c1492d3038d9cc6e4032c69f2aa10a4d99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c58ffe874142e1943e2674d7e75989938a7d21b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c58ffe874142e1943e2674d7e75989938a7d21b", "html_url": "https://github.com/rust-lang/rust/commit/7c58ffe874142e1943e2674d7e75989938a7d21b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c58ffe874142e1943e2674d7e75989938a7d21b/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc4242d9052a42cdf329c3a2430d02a3b3d415cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4242d9052a42cdf329c3a2430d02a3b3d415cb", "html_url": "https://github.com/rust-lang/rust/commit/dc4242d9052a42cdf329c3a2430d02a3b3d415cb"}], "stats": {"total": 2429, "additions": 1299, "deletions": 1130}, "files": [{"sha": "01390f2c7195b27dc392e096a2e5c2438e242a12", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -1701,7 +1701,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         sub: Region<'tcx>,\n     ) {\n         self.construct_generic_bound_failure(region_scope_tree, span, origin, bound_kind, sub)\n-            .emit()\n+            .emit();\n     }\n \n     pub fn construct_generic_bound_failure("}, {"sha": "e7291d7a4ab0dc1b3770e794593dd6e80f445598", "filename": "src/librustc/lint.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -11,6 +11,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n use rustc_span::{Span, Symbol};\n \n+\n /// How a lint level was set.\n #[derive(Clone, Copy, PartialEq, Eq, HashStable)]\n pub enum LintSource {\n@@ -174,20 +175,37 @@ impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     }\n }\n \n-pub fn struct_lint_level<'a>(\n-    sess: &'a Session,\n+\n+pub struct LintDiagnosticBuilder<'a>(DiagnosticBuilder<'a>);\n+\n+impl<'a> LintDiagnosticBuilder<'a> {\n+    /// Return the inner DiagnosticBuilder, first setting the primary message to `msg`.\n+    pub fn build(mut self, msg: &str) -> DiagnosticBuilder<'a> {\n+        self.0.set_primary_message(msg);\n+        self.0\n+    }\n+\n+    /// Create a LintDiagnosticBuilder from some existing DiagnosticBuilder.\n+    pub fn new(err: DiagnosticBuilder<'a>) -> LintDiagnosticBuilder<'a>{\n+        LintDiagnosticBuilder(err)\n+    }\n+}\n+\n+pub fn struct_lint_level<'s>(\n+    sess: &'s Session,\n     lint: &'static Lint,\n     level: Level,\n     src: LintSource,\n     span: Option<MultiSpan>,\n-    msg: &str,\n-) -> DiagnosticBuilder<'a> {\n+    decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>)) {\n+\n+    // FIXME: Move the guts of this function into a fn which takes dyn Fn to reduce code bloat.\n     let mut err = match (level, span) {\n-        (Level::Allow, _) => return sess.diagnostic().struct_dummy(),\n-        (Level::Warn, Some(span)) => sess.struct_span_warn(span, msg),\n-        (Level::Warn, None) => sess.struct_warn(msg),\n-        (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n-        (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(msg),\n+        (Level::Allow, _) => { return; },\n+        (Level::Warn, Some(span)) => sess.struct_span_warn(span, \"\"),\n+        (Level::Warn, None) => sess.struct_warn(\"\"),\n+        (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, \"\"),\n+        (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(\"\"),\n     };\n \n     // Check for future incompatibility lints and issue a stronger warning.\n@@ -209,7 +227,7 @@ pub fn struct_lint_level<'a>(\n             err.cancel();\n             // Don't continue further, since we don't want to have\n             // `diag_span_note_once` called for a diagnostic that isn't emitted.\n-            return err;\n+            return;\n         }\n     }\n \n@@ -299,7 +317,8 @@ pub fn struct_lint_level<'a>(\n         err.note(&citation);\n     }\n \n-    return err;\n+    // Finally, run `decorate`. This function is also responsible for emitting the diagnostic.\n+    decorate(LintDiagnosticBuilder::new(err));\n }\n \n /// Returns whether `span` originates in a foreign crate's external macro."}, {"sha": "dd30fb23c2e7681a47b7d84493a0225d3b2a53ae", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -222,11 +222,13 @@ fn late_report_deprecation(\n         return;\n     }\n \n-    let mut diag = tcx.struct_span_lint_hir(lint, hir_id, span, message);\n-    if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n-        deprecation_suggestion(&mut diag, suggestion, span);\n-    }\n-    diag.emit();\n+    tcx.struct_span_lint_hir(lint, hir_id, span, |lint| {\n+        let mut diag = lint.build(message);\n+        if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n+            deprecation_suggestion(&mut diag, suggestion, span);\n+        }\n+        diag.emit()\n+    });\n     if hir_id == hir::DUMMY_HIR_ID {\n         span_bug!(span, \"emitted a {} lint with dummy HIR id: {:?}\", lint.name, def_id);\n     }\n@@ -387,8 +389,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n     /// not `None`, a deprecated lint attached to `id` will be emitted.\n     pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n-        let soft_handler =\n-            |lint, span, msg: &_| self.lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, msg);\n+        let soft_handler = |lint, span, msg: &_| {\n+            self.struct_span_lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, |lint| {\n+                lint.build(msg).emit()\n+            })\n+        };\n         match self.eval_stability(def_id, id, span) {\n             EvalResult::Allow => {}\n             EvalResult::Deny { feature, reason, issue, is_soft } => {"}, {"sha": "bb84458cf7b0ba5a5e3f228762093fd3d537af44", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 50, "deletions": 31, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -83,18 +83,15 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n         message: &str,\n-    ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n-        self.struct_generic(tcx, message, None)\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+    ) -> Result<(), ErrorHandled> {\n+        self.struct_generic(tcx, message, emit, None)\n     }\n \n     pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n-        let err = self.struct_error(tcx, message);\n-        match err {\n-            Ok(mut err) => {\n-                err.emit();\n-                ErrorHandled::Reported\n-            }\n-            Err(err) => err,\n+        match self.struct_error(tcx, message, |mut e| e.emit()) {\n+            Ok(_) => ErrorHandled::Reported,\n+            Err(x) => x,\n         }\n     }\n \n@@ -105,9 +102,11 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         lint_root: hir::HirId,\n         span: Option<Span>,\n     ) -> ErrorHandled {\n-        let lint = self.struct_generic(tcx, message, Some(lint_root));\n-        match lint {\n-            Ok(mut lint) => {\n+        match self.struct_generic(\n+            tcx,\n+            message,\n+            |mut lint: DiagnosticBuilder<'_>| {\n+                // Apply the span.\n                 if let Some(span) = span {\n                     let primary_spans = lint.span.primary_spans().to_vec();\n                     // point at the actual error as the primary span\n@@ -121,18 +120,26 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                     }\n                 }\n                 lint.emit();\n+            }\n+        , Some(lint_root)) {\n+            Ok(_) => {\n                 ErrorHandled::Reported\n             }\n             Err(err) => err,\n         }\n     }\n \n+   /// Sets the message passed in via `message`, then adds the span labels for you, before applying\n+   /// further modifications in `emit`. It's up to you to call emit(), stash(..), etc. within the\n+   /// `emit` method. If you don't need to do any additional processing, just use\n+   /// struct_generic.\n     fn struct_generic(\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n         message: &str,\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n         lint_root: Option<hir::HirId>,\n-    ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n+    ) -> Result<(), ErrorHandled> {\n         let must_error = match self.error {\n             InterpError::MachineStop(_) => bug!(\"CTFE does not stop\"),\n             err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n@@ -143,7 +150,22 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             _ => false,\n         };\n         trace!(\"reporting const eval failure at {:?}\", self.span);\n-        let mut err = if let (Some(lint_root), false) = (lint_root, must_error) {\n+\n+        let add_span_labels = |err: &mut DiagnosticBuilder<'_>| {\n+            if !must_error {\n+                err.span_label(self.span, self.error.to_string());\n+            }\n+            // Skip the last, which is just the environment of the constant.  The stacktrace\n+            // is sometimes empty because we create \"fake\" eval contexts in CTFE to do work\n+            // on constant values.\n+            if self.stacktrace.len() > 0 {\n+                for frame_info in &self.stacktrace[..self.stacktrace.len() - 1] {\n+                    err.span_label(frame_info.call_site, frame_info.to_string());\n+                }\n+            }\n+        };\n+\n+        if let (Some(lint_root), false) = (lint_root, must_error) {\n             let hir_id = self\n                 .stacktrace\n                 .iter()\n@@ -155,25 +177,22 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                 rustc_session::lint::builtin::CONST_ERR,\n                 hir_id,\n                 tcx.span,\n-                message,\n-            )\n-        } else if must_error {\n-            struct_error(tcx, &self.error.to_string())\n+                |lint| {\n+                    let mut err = lint.build(message);\n+                    add_span_labels(&mut err);\n+                    emit(err);\n+                },\n+            );\n         } else {\n-            struct_error(tcx, message)\n+            let mut err = if must_error {\n+                struct_error(tcx, &self.error.to_string())\n+            } else {\n+                struct_error(tcx, message)\n+            };\n+            add_span_labels(&mut err);\n+            emit(err);\n         };\n-        if !must_error {\n-            err.span_label(self.span, self.error.to_string());\n-        }\n-        // Skip the last, which is just the environment of the constant.  The stacktrace\n-        // is sometimes empty because we create \"fake\" eval contexts in CTFE to do work\n-        // on constant values.\n-        if self.stacktrace.len() > 0 {\n-            for frame_info in &self.stacktrace[..self.stacktrace.len() - 1] {\n-                err.span_label(frame_info.call_site, frame_info.to_string());\n-            }\n-        }\n-        Ok(err)\n+        Ok(())\n     }\n }\n "}, {"sha": "0e6347897d2bae661dd0c5e2fde095dc368990ae", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -227,37 +227,39 @@ fn object_safety_violations_for_trait(\n             {\n                 // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n                 // It's also hard to get a use site span, so we use the method definition span.\n-                let mut err = tcx.struct_span_lint_hir(\n+                tcx.struct_span_lint_hir(\n                     WHERE_CLAUSES_OBJECT_SAFETY,\n                     hir::CRATE_HIR_ID,\n                     *span,\n-                    &format!(\n-                        \"the trait `{}` cannot be made into an object\",\n-                        tcx.def_path_str(trait_def_id)\n-                    ),\n+                    |lint| {\n+                        let mut err = lint.build(&format!(\n+                            \"the trait `{}` cannot be made into an object\",\n+                            tcx.def_path_str(trait_def_id)\n+                        ));\n+                        let node = tcx.hir().get_if_local(trait_def_id);\n+                        let msg = if let Some(hir::Node::Item(item)) = node {\n+                            err.span_label(item.ident.span, \"this trait cannot be made into an object...\");\n+                            format!(\"...because {}\", violation.error_msg())\n+                        } else {\n+                            format!(\n+                                \"the trait cannot be made into an object because {}\",\n+                                violation.error_msg()\n+                            )\n+                        };\n+                        err.span_label(*span, &msg);\n+                        match (node, violation.solution()) {\n+                            (Some(_), Some((note, None))) => {\n+                                err.help(&note);\n+                            }\n+                            (Some(_), Some((note, Some((sugg, span))))) => {\n+                                err.span_suggestion(span, &note, sugg, Applicability::MachineApplicable);\n+                            }\n+                            // Only provide the help if its a local trait, otherwise it's not actionable.\n+                            _ => {}\n+                        }\n+                        err.emit();\n+                    },\n                 );\n-                let node = tcx.hir().get_if_local(trait_def_id);\n-                let msg = if let Some(hir::Node::Item(item)) = node {\n-                    err.span_label(item.ident.span, \"this trait cannot be made into an object...\");\n-                    format!(\"...because {}\", violation.error_msg())\n-                } else {\n-                    format!(\n-                        \"the trait cannot be made into an object because {}\",\n-                        violation.error_msg()\n-                    )\n-                };\n-                err.span_label(*span, &msg);\n-                match (node, violation.solution()) {\n-                    (Some(_), Some((note, None))) => {\n-                        err.help(&note);\n-                    }\n-                    (Some(_), Some((note, Some((sugg, span))))) => {\n-                        err.span_suggestion(span, &note, sugg, Applicability::MachineApplicable);\n-                    }\n-                    // Only provide the help if its a local trait, otherwise it's not actionable.\n-                    _ => {}\n-                }\n-                err.emit();\n                 false\n             } else {\n                 true"}, {"sha": "33a78ae896b3510d4030c390e9b0cfaa6d98ea01", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 63, "deletions": 51, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -22,6 +22,7 @@ use rustc_hir::def_id::DefId;\n use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n use rustc_span::DUMMY_SP;\n+use rustc::lint::LintDiagnosticBuilder;\n \n use super::util::impl_trait_ref_and_oblig;\n use super::{FulfillmentContext, SelectionContext};\n@@ -317,22 +318,69 @@ pub(super) fn specialization_graph_provider(\n             };\n \n             if let Some(overlap) = overlap {\n-                let msg = format!(\n-                    \"conflicting implementations of trait `{}`{}:{}\",\n-                    overlap.trait_desc,\n-                    overlap\n-                        .self_desc\n-                        .clone()\n-                        .map_or(String::new(), |ty| { format!(\" for type `{}`\", ty) }),\n-                    match used_to_be_allowed {\n-                        Some(FutureCompatOverlapErrorKind::Issue33140) => \" (E0119)\",\n-                        _ => \"\",\n-                    }\n-                );\n                 let impl_span =\n                     tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n-                let mut err = match used_to_be_allowed {\n-                    None => struct_span_err!(tcx.sess, impl_span, E0119, \"{}\", msg),\n+\n+                // Work to be done after we've built the DiagnosticBuilder. We have to define it\n+                // now because the struct_lint methods don't return back the DiagnosticBuilder\n+                // that's passed in.\n+                let decorate = |err: LintDiagnosticBuilder<'_>| {\n+                    let msg = format!(\n+                        \"conflicting implementations of trait `{}`{}:{}\",\n+                        overlap.trait_desc,\n+                        overlap\n+                            .self_desc\n+                            .clone()\n+                            .map_or(String::new(), |ty| { format!(\" for type `{}`\", ty) }),\n+                        match used_to_be_allowed {\n+                            Some(FutureCompatOverlapErrorKind::Issue33140) => \" (E0119)\",\n+                            _ => \"\",\n+                        }\n+                    );\n+                    let mut err = err.build(&msg);\n+                    match tcx.span_of_impl(overlap.with_impl) {\n+                        Ok(span) => {\n+                            err.span_label(\n+                                tcx.sess.source_map().def_span(span),\n+                                \"first implementation here\".to_string(),\n+                            );\n+\n+                            err.span_label(\n+                                impl_span,\n+                                format!(\n+                                    \"conflicting implementation{}\",\n+                                    overlap\n+                                        .self_desc\n+                                        .map_or(String::new(), |ty| format!(\" for `{}`\", ty))\n+                                ),\n+                            );\n+                        }\n+                        Err(cname) => {\n+                            let msg = match to_pretty_impl_header(tcx, overlap.with_impl) {\n+                                Some(s) => {\n+                                    format!(\"conflicting implementation in crate `{}`:\\n- {}\", cname, s)\n+                                }\n+                                None => format!(\"conflicting implementation in crate `{}`\", cname),\n+                            };\n+                            err.note(&msg);\n+                        }\n+                    }\n+\n+                    for cause in &overlap.intercrate_ambiguity_causes {\n+                        cause.add_intercrate_ambiguity_hint(&mut err);\n+                    }\n+\n+                    if overlap.involves_placeholder {\n+                        coherence::add_placeholder_note(&mut err);\n+                    }\n+                    err.emit()\n+                };\n+\n+                match used_to_be_allowed {\n+                    None => {\n+                        let err = struct_span_err!(tcx.sess, impl_span, E0119, \"\");\n+                        decorate(LintDiagnosticBuilder::new(err));\n+                    }\n                     Some(kind) => {\n                         let lint = match kind {\n                             FutureCompatOverlapErrorKind::Issue33140 => {\n@@ -344,47 +392,11 @@ pub(super) fn specialization_graph_provider(\n                             lint,\n                             tcx.hir().as_local_hir_id(impl_def_id).unwrap(),\n                             impl_span,\n-                            &msg,\n+                            decorate,\n                         )\n                     }\n                 };\n \n-                match tcx.span_of_impl(overlap.with_impl) {\n-                    Ok(span) => {\n-                        err.span_label(\n-                            tcx.sess.source_map().def_span(span),\n-                            \"first implementation here\".to_string(),\n-                        );\n-                        err.span_label(\n-                            impl_span,\n-                            format!(\n-                                \"conflicting implementation{}\",\n-                                overlap\n-                                    .self_desc\n-                                    .map_or(String::new(), |ty| format!(\" for `{}`\", ty))\n-                            ),\n-                        );\n-                    }\n-                    Err(cname) => {\n-                        let msg = match to_pretty_impl_header(tcx, overlap.with_impl) {\n-                            Some(s) => {\n-                                format!(\"conflicting implementation in crate `{}`:\\n- {}\", cname, s)\n-                            }\n-                            None => format!(\"conflicting implementation in crate `{}`\", cname),\n-                        };\n-                        err.note(&msg);\n-                    }\n-                }\n-\n-                for cause in &overlap.intercrate_ambiguity_causes {\n-                    cause.add_intercrate_ambiguity_hint(&mut err);\n-                }\n-\n-                if overlap.involves_placeholder {\n-                    coherence::add_placeholder_note(&mut err);\n-                }\n-\n-                err.emit();\n             }\n         } else {\n             let parent = tcx.impl_parent(impl_def_id).unwrap_or(trait_id);"}, {"sha": "a885f9e9600935729352e75cc98c77fd117b188a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -42,14 +42,14 @@ use crate::ty::{InferConst, ParamConst};\n use crate::ty::{List, TyKind, TyS};\n use crate::util::common::ErrorReported;\n use rustc_attr as attr;\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{\n     hash_stable_hashmap, HashStable, StableHasher, StableVec,\n };\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n-use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, DefIndex, LOCAL_CRATE};\n@@ -2551,16 +2551,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_goals(xs))\n     }\n \n-    pub fn lint_hir(\n-        self,\n-        lint: &'static Lint,\n-        hir_id: HirId,\n-        span: impl Into<MultiSpan>,\n-        msg: &str,\n-    ) {\n-        self.struct_span_lint_hir(lint, hir_id, span.into(), msg).emit()\n-    }\n-\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n     pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n@@ -2604,20 +2594,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint: &'static Lint,\n         hir_id: HirId,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'tcx> {\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>)\n+    ) {\n         let (level, src) = self.lint_level_at_node(lint, hir_id);\n-        struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n+        struct_lint_level(self.sess, lint, level, src, Some(span.into()), decorate);\n     }\n \n     pub fn struct_lint_node(\n         self,\n         lint: &'static Lint,\n         id: HirId,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'tcx> {\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         let (level, src) = self.lint_level_at_node(lint, id);\n-        struct_lint_level(self.sess, lint, level, src, None, msg)\n+        struct_lint_level(self.sess, lint, level, src, None, decorate);\n     }\n \n     pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx StableVec<TraitCandidate>> {"}, {"sha": "e5381a58dab55e772ec9ec820968e6e65e0fd4aa", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -37,7 +37,7 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n                 .span_label(span, format!(\"expected one of {}\", expected.join(\", \")))\n                 .emit();\n         }\n-        AttrError::MissingSince => struct_span_err!(diag, span, E0542, \"missing 'since'\").emit(),\n+        AttrError::MissingSince => { struct_span_err!(diag, span, E0542, \"missing 'since'\").emit(); },\n         AttrError::MissingFeature => {\n             struct_span_err!(diag, span, E0546, \"missing 'feature'\").emit();\n         }\n@@ -639,7 +639,7 @@ fn gate_cfg(gated_cfg: &GatedCfg, cfg_span: Span, sess: &ParseSess, features: &F\n     let (cfg, feature, has_feature) = gated_cfg;\n     if !has_feature(features) && !cfg_span.allows_unstable(*feature) {\n         let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n-        feature_err(sess, *feature, cfg_span, &explain).emit()\n+        feature_err(sess, *feature, cfg_span, &explain).emit();\n     }\n }\n "}, {"sha": "189b5bd0f9e87e576f7a7f490e972dd8c55b8fe1", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -194,6 +194,7 @@ impl Diagnostic {\n         found_extra: &dyn fmt::Display,\n     ) -> &mut Self {\n         let expected_label = format!(\"expected {}\", expected_label);\n+\n         let found_label = format!(\"found {}\", found_label);\n         let (found_padding, expected_padding) = if expected_label.len() > found_label.len() {\n             (expected_label.len() - found_label.len(), 0)"}, {"sha": "84bfa07d267da9a776a7aa07e4ad6ce3fd855598", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -106,7 +106,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     ///\n     /// See `emit` and `delay_as_bug` for details.\n     pub fn emit_unless(&mut self, delay: bool) {\n-        if delay { self.delay_as_bug() } else { self.emit() }\n+        if delay { self.delay_as_bug(); } else { self.emit(); }\n     }\n \n     /// Stashes diagnostic for possible later improvement in a different,\n@@ -369,6 +369,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n     crate fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> DiagnosticBuilder<'a> {\n+        debug!(\"Created new diagnostic\");\n         DiagnosticBuilder(Box::new(DiagnosticBuilderInner {\n             handler,\n             diagnostic,"}, {"sha": "9e583d7e19d79c7c10a1a138d1ea56ce88e6658a", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -1113,7 +1113,7 @@ pub fn expr_to_string(\n     err_msg: &str,\n ) -> Option<(Symbol, ast::StrStyle)> {\n     expr_to_spanned_string(cx, expr, err_msg)\n-        .map_err(|err| err.map(|mut err| err.emit()))\n+        .map_err(|err| err.map(|mut err| { err.emit(); }))\n         .ok()\n         .map(|(symbol, style, _)| (symbol, style))\n }"}, {"sha": "a91d735622f4e0710b3ba463373f4e328c1ea4f0", "filename": "src/librustc_lint/array_into_iter.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -77,20 +77,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIntoIter {\n                 // to an array or to a slice.\n                 _ => bug!(\"array type coerced to something other than array or slice\"),\n             };\n-            let msg = format!(\n+            cx.struct_span_lint(ARRAY_INTO_ITER, *span, |lint| {\n+                lint.build(&format!(\n                 \"this method call currently resolves to `<&{} as IntoIterator>::into_iter` (due \\\n                     to autoref coercions), but that might change in the future when \\\n                     `IntoIterator` impls for arrays are added.\",\n                 target,\n-            );\n-            cx.struct_span_lint(ARRAY_INTO_ITER, *span, &msg)\n+                ))\n                 .span_suggestion(\n                     call.ident.span,\n                     \"use `.iter()` instead of `.into_iter()` to avoid ambiguity\",\n                     \"iter\".into(),\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();\n+            })\n         }\n     }\n }"}, {"sha": "e84ef713b42d331114647b3da31e03131013d2d3", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 209, "deletions": 183, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -77,14 +77,16 @@ impl EarlyLintPass for WhileTrue {\n                     if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n                         let condition_span = cx.sess.source_map().def_span(e.span);\n-                        cx.struct_span_lint(WHILE_TRUE, condition_span, msg)\n-                            .span_suggestion_short(\n+                        cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n+                            lint.build(msg)\n+                                .span_suggestion_short(\n                                 condition_span,\n                                 \"use `loop`\",\n                                 \"loop\".to_owned(),\n                                 Applicability::MachineApplicable,\n                             )\n                             .emit();\n+                        })\n                     }\n                 }\n             }\n@@ -174,29 +176,31 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                     if cx.tcx.find_field_index(ident, &variant)\n                         == Some(cx.tcx.field_index(fieldpat.hir_id, cx.tables))\n                     {\n-                        let mut err = cx.struct_span_lint(\n+                        cx.struct_span_lint(\n                             NON_SHORTHAND_FIELD_PATTERNS,\n                             fieldpat.span,\n-                            &format!(\"the `{}:` in this pattern is redundant\", ident),\n-                        );\n-                        let binding = match binding_annot {\n-                            hir::BindingAnnotation::Unannotated => None,\n-                            hir::BindingAnnotation::Mutable => Some(\"mut\"),\n-                            hir::BindingAnnotation::Ref => Some(\"ref\"),\n-                            hir::BindingAnnotation::RefMut => Some(\"ref mut\"),\n-                        };\n-                        let ident = if let Some(binding) = binding {\n-                            format!(\"{} {}\", binding, ident)\n-                        } else {\n-                            ident.to_string()\n-                        };\n-                        err.span_suggestion(\n-                            fieldpat.span,\n-                            \"use shorthand field pattern\",\n-                            ident,\n-                            Applicability::MachineApplicable,\n+                            |lint| {\n+                                let mut err = lint.build(&format!(\"the `{}:` in this pattern is redundant\", ident));\n+                                let binding = match binding_annot {\n+                                    hir::BindingAnnotation::Unannotated => None,\n+                                    hir::BindingAnnotation::Mutable => Some(\"mut\"),\n+                                    hir::BindingAnnotation::Ref => Some(\"ref\"),\n+                                    hir::BindingAnnotation::RefMut => Some(\"ref mut\"),\n+                                };\n+                                let ident = if let Some(binding) = binding {\n+                                    format!(\"{} {}\", binding, ident)\n+                                } else {\n+                                    ident.to_string()\n+                                };\n+                                err.span_suggestion(\n+                                    fieldpat.span,\n+                                    \"use shorthand field pattern\",\n+                                    ident,\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                err.emit();\n+                            }\n                         );\n-                        err.emit();\n                     }\n                 }\n             }\n@@ -643,17 +647,19 @@ impl EarlyLintPass for AnonymousParameters {\n                                 cx.struct_span_lint(\n                                     ANONYMOUS_PARAMETERS,\n                                     arg.pat.span,\n-                                    \"anonymous parameters are deprecated and will be \\\n-                                     removed in the next edition.\",\n-                                )\n-                                .span_suggestion(\n-                                    arg.pat.span,\n-                                    \"try naming the parameter or explicitly \\\n-                                    ignoring it\",\n-                                    format!(\"_: {}\", ty_snip),\n-                                    appl,\n+                                    |lint| {\n+                                    lint.build(\"anonymous parameters are deprecated and will be \\\n+                                     removed in the next edition.\")\n+                                        .span_suggestion(\n+                                            arg.pat.span,\n+                                            \"try naming the parameter or explicitly \\\n+                                            ignoring it\",\n+                                            format!(\"_: {}\", ty_snip),\n+                                            appl,\n+                                        )\n+                                        .emit();\n+                                    },\n                                 )\n-                                .emit();\n                             }\n                         }\n                         _ => (),\n@@ -687,14 +693,16 @@ fn lint_deprecated_attr(\n     msg: &str,\n     suggestion: Option<&str>,\n ) {\n-    cx.struct_span_lint(DEPRECATED, attr.span, &msg)\n-        .span_suggestion_short(\n-            attr.span,\n-            suggestion.unwrap_or(\"remove this attribute\"),\n-            String::new(),\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+    cx.struct_span_lint(DEPRECATED, attr.span, |lint| {\n+        lint.build(msg)\n+            .span_suggestion_short(\n+                attr.span,\n+                suggestion.unwrap_or(\"remove this attribute\"),\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+    })\n }\n \n impl EarlyLintPass for DeprecatedAttr {\n@@ -759,21 +767,20 @@ impl UnusedDocComment {\n             let span = sugared_span.take().unwrap_or_else(|| attr.span);\n \n             if attr.is_doc_comment() || attr.check_name(sym::doc) {\n-                let mut err = cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, \"unused doc comment\");\n-\n-                err.span_label(\n-                    node_span,\n-                    format!(\"rustdoc does not generate documentation for {}\", node_kind),\n-                );\n-\n-                if is_macro_expansion {\n-                    err.help(\n-                        \"to document an item produced by a macro, \\\n-                              the macro must produce the documentation as part of its expansion\",\n+                cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, |lint| {\n+                    let mut err = lint.build(\"unused doc comment\");\n+                    err.span_label(\n+                        node_span,\n+                        format!(\"rustdoc does not generate documentation for {}\", node_kind),\n                     );\n-                }\n-\n-                err.emit();\n+                    if is_macro_expansion {\n+                        err.help(\n+                            \"to document an item produced by a macro, \\\n+                                  the macro must produce the documentation as part of its expansion\",\n+                        );\n+                    }\n+                    err.emit();\n+                });\n             }\n         }\n     }\n@@ -831,20 +838,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n                             GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                                let mut err = cx.struct_span_lint(\n+                                cx.struct_span_lint(\n                                     NO_MANGLE_GENERIC_ITEMS,\n                                     it.span,\n-                                    \"functions generic over types or consts must be mangled\",\n-                                );\n-                                err.span_suggestion_short(\n-                                    no_mangle_attr.span,\n-                                    \"remove this attribute\",\n-                                    String::new(),\n-                                    // Use of `#[no_mangle]` suggests FFI intent; correct\n-                                    // fix may be to monomorphize source by hand\n-                                    Applicability::MaybeIncorrect,\n+                                    |lint| {\n+                                        lint.build(\"functions generic over types or consts must be mangled\")\n+                                            .span_suggestion_short(\n+                                                no_mangle_attr.span,\n+                                                \"remove this attribute\",\n+                                                String::new(),\n+                                                // Use of `#[no_mangle]` suggests FFI intent; correct\n+                                                // fix may be to monomorphize source by hand\n+                                                Applicability::MaybeIncorrect,\n+                                            )\n+                                            .emit();\n+                                    },\n                                 );\n-                                err.emit();\n                                 break;\n                             }\n                         }\n@@ -856,25 +865,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     let msg = \"const items should never be `#[no_mangle]`\";\n-                    let mut err = cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n-\n-                    // account for \"pub const\" (#45562)\n-                    let start = cx\n-                        .tcx\n-                        .sess\n-                        .source_map()\n-                        .span_to_snippet(it.span)\n-                        .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n-                        .unwrap_or(0) as u32;\n-                    // `const` is 5 chars\n-                    let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n-                    err.span_suggestion(\n-                        const_span,\n-                        \"try a static value\",\n-                        \"pub static\".to_owned(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n+                    cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, |lint| {\n+                        let mut err = lint.build(msg);\n+\n+                        // account for \"pub const\" (#45562)\n+                        let start = cx\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(it.span)\n+                            .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n+                            .unwrap_or(0) as u32;\n+                        // `const` is 5 chars\n+                        let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n+                        err.span_suggestion(\n+                            const_span,\n+                            \"try a static value\",\n+                            \"pub static\".to_owned(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        err.emit();\n+                    });\n                 }\n             }\n             _ => {}\n@@ -984,28 +995,30 @@ impl UnreachablePub {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n                 let def_span = cx.tcx.sess.source_map().def_span(span);\n-                let mut err = cx.struct_span_lint(\n+                cx.struct_span_lint(\n                     UNREACHABLE_PUB,\n                     def_span,\n-                    &format!(\"unreachable `pub` {}\", what),\n-                );\n-                let replacement = if cx.tcx.features().crate_visibility_modifier {\n-                    \"crate\"\n-                } else {\n-                    \"pub(crate)\"\n-                }\n-                .to_owned();\n+                    |lint| {\n+                        let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n+                        let replacement = if cx.tcx.features().crate_visibility_modifier {\n+                            \"crate\"\n+                        } else {\n+                            \"pub(crate)\"\n+                        }\n+                        .to_owned();\n \n-                err.span_suggestion(\n-                    vis.span,\n-                    \"consider restricting its visibility\",\n-                    replacement,\n-                    applicability,\n+                        err.span_suggestion(\n+                            vis.span,\n+                            \"consider restricting its visibility\",\n+                            replacement,\n+                            applicability,\n+                        );\n+                        if exportable {\n+                            err.help(\"or consider exporting it for use by other crates\");\n+                        }\n+                        err.emit();\n+                    }\n                 );\n-                if exportable {\n-                    err.help(\"or consider exporting it for use by other crates\");\n-                }\n-                err.emit();\n             }\n             _ => {}\n         }\n@@ -1120,22 +1133,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n                 .iter()\n                 .map(|pred| pred.span())\n                 .collect();\n-            let mut err = cx.struct_span_lint(\n+            cx.struct_span_lint(\n                 TYPE_ALIAS_BOUNDS,\n                 spans,\n-                \"where clauses are not enforced in type aliases\",\n-            );\n-            err.span_suggestion(\n-                type_alias_generics.where_clause.span_for_predicates_or_empty_place(),\n-                \"the clause will not be checked when the type alias is used, and should be removed\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n+                |lint| {\n+                    let mut err = lint.build(\"where clauses are not enforced in type aliases\");\n+                    err.span_suggestion(\n+                        type_alias_generics.where_clause.span_for_predicates_or_empty_place(),\n+                        \"the clause will not be checked when the type alias is used, and should be removed\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    if !suggested_changing_assoc_types {\n+                        TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                        suggested_changing_assoc_types = true;\n+                    }\n+                    err.emit();\n+                },\n             );\n-            if !suggested_changing_assoc_types {\n-                TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n-                suggested_changing_assoc_types = true;\n-            }\n-            err.emit();\n         }\n         // The parameters must not have bounds\n         for param in type_alias_generics.params.iter() {\n@@ -1148,19 +1163,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n                 })\n                 .collect();\n             if !spans.is_empty() {\n-                let mut err = cx.struct_span_lint(\n+                cx.struct_span_lint(\n                     TYPE_ALIAS_BOUNDS,\n                     spans,\n-                    \"bounds on generic parameters are not enforced in type aliases\",\n+                    |lint| {\n+                        let mut err = lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n+                        let msg = \"the bound will not be checked when the type alias is used, \\\n+                                   and should be removed\";\n+                        err.multipart_suggestion(&msg, suggestion, Applicability::MachineApplicable);\n+                        if !suggested_changing_assoc_types {\n+                            TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                            suggested_changing_assoc_types = true;\n+                        }\n+                        err.emit();\n+                    },\n                 );\n-                let msg = \"the bound will not be checked when the type alias is used, \\\n-                           and should be removed\";\n-                err.multipart_suggestion(&msg, suggestion, Applicability::MachineApplicable);\n-                if !suggested_changing_assoc_types {\n-                    TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n-                    suggested_changing_assoc_types = true;\n-                }\n-                err.emit();\n             }\n         }\n     }\n@@ -1322,23 +1339,27 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                     Some(start) => format!(\"&({}..={})\", expr_to_string(&start), end),\n                     None => format!(\"&(..={})\", end),\n                 };\n-                let mut err = cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, msg);\n-                err.span_suggestion(\n-                    pat.span,\n-                    suggestion,\n-                    replace,\n-                    Applicability::MachineApplicable,\n-                );\n-                err.emit();\n+                cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, |lint| {\n+                    lint.build(msg)\n+                        .span_suggestion(\n+                            pat.span,\n+                            suggestion,\n+                            replace,\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+                });\n             } else {\n-                let mut err = cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, msg);\n-                err.span_suggestion_short(\n-                    join,\n-                    suggestion,\n-                    \"..=\".to_owned(),\n-                    Applicability::MachineApplicable,\n-                );\n-                err.emit();\n+                cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, |lint| {\n+                    lint.build(msg)\n+                        .span_suggestion_short(\n+                            join,\n+                            suggestion,\n+                            \"..=\".to_owned(),\n+                            Applicability::MachineApplicable\n+                        )\n+                        .emit();\n+                });\n             };\n         }\n     }\n@@ -1384,7 +1405,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n         }\n \n         if let Some(attr) = attr::find_by_name(&it.attrs, sym::rustc_test_marker) {\n-            cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, \"cannot test inner items\").emit();\n+            cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, |lint| lint.build(\"cannot test inner items\").emit());\n         }\n     }\n \n@@ -1465,18 +1486,20 @@ impl KeywordIdents {\n             return;\n         }\n \n-        let mut lint = cx.struct_span_lint(\n+        cx.struct_span_lint(\n             KEYWORD_IDENTS,\n             ident.span,\n-            &format!(\"`{}` is a keyword in the {} edition\", ident, next_edition),\n-        );\n-        lint.span_suggestion(\n-            ident.span,\n-            \"you can use a raw identifier to stay compatible\",\n-            format!(\"r#{}\", ident),\n-            Applicability::MachineApplicable,\n+            |lint| {\n+                lint.build(&format!(\"`{}` is a keyword in the {} edition\", ident, next_edition))\n+                    .span_suggestion(\n+                        ident.span,\n+                        \"you can use a raw identifier to stay compatible\",\n+                        format!(\"r#{}\", ident),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit()\n+            },\n         );\n-        lint.emit()\n     }\n }\n \n@@ -1780,17 +1803,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n             }\n \n             if !lint_spans.is_empty() {\n-                let mut err = cx.struct_span_lint(\n+                cx.struct_span_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n-                    \"outlives requirements can be inferred\",\n-                );\n-                err.multipart_suggestion(\n-                    if bound_count == 1 { \"remove this bound\" } else { \"remove these bounds\" },\n-                    lint_spans.into_iter().map(|span| (span, \"\".to_owned())).collect::<Vec<_>>(),\n-                    Applicability::MachineApplicable,\n+                    |lint| {\n+                        lint.build(\"outlives requirements can be inferred\")\n+                            .multipart_suggestion(\n+                                if bound_count == 1 { \"remove this bound\" } else { \"remove these bounds\" },\n+                                lint_spans.into_iter().map(|span| (span, \"\".to_owned())).collect::<Vec<_>>(),\n+                                Applicability::MachineApplicable,\n+                            )\n+                            .emit();\n+                    },\n                 );\n-                err.emit();\n             }\n         }\n     }\n@@ -1820,12 +1845,11 @@ impl EarlyLintPass for IncompleteFeatures {\n                 cx.struct_span_lint(\n                     INCOMPLETE_FEATURES,\n                     span,\n-                    &format!(\n+                    |lint| lint.build(&format!(\n                         \"the feature `{}` is incomplete and may cause the compiler to crash\",\n                         name,\n-                    ),\n+                    )).emit(),\n                 )\n-                .emit();\n             });\n     }\n }\n@@ -2015,30 +2039,32 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.tables.expr_ty(expr);\n             if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty, init) {\n-                let mut err = cx.struct_span_lint(\n+                cx.struct_span_lint(\n                     INVALID_VALUE,\n                     expr.span,\n-                    &format!(\n-                        \"the type `{}` does not permit {}\",\n-                        conjured_ty,\n-                        match init {\n-                            InitKind::Zeroed => \"zero-initialization\",\n-                            InitKind::Uninit => \"being left uninitialized\",\n-                        },\n-                    ),\n-                );\n-                err.span_label(expr.span, \"this code causes undefined behavior when executed\");\n-                err.span_label(\n-                    expr.span,\n-                    \"help: use `MaybeUninit<T>` instead, \\\n-                    and only call `assume_init` after initialization is done\",\n+                    |lint| {\n+                        let mut err = lint.build(&format!(\n+                            \"the type `{}` does not permit {}\",\n+                            conjured_ty,\n+                            match init {\n+                                InitKind::Zeroed => \"zero-initialization\",\n+                                InitKind::Uninit => \"being left uninitialized\",\n+                            },\n+                        ));\n+                        err.span_label(expr.span, \"this code causes undefined behavior when executed\");\n+                        err.span_label(\n+                            expr.span,\n+                            \"help: use `MaybeUninit<T>` instead, \\\n+                            and only call `assume_init` after initialization is done\",\n+                        );\n+                        if let Some(span) = span {\n+                            err.span_note(span, &msg);\n+                        } else {\n+                            err.note(&msg);\n+                        }\n+                        err.emit();\n+                    },\n                 );\n-                if let Some(span) = span {\n-                    err.span_note(span, &msg);\n-                } else {\n-                    err.note(&msg);\n-                }\n-                err.emit();\n             }\n         }\n     }"}, {"sha": "7b085f6c2b3d4777cf919c7238a0bc236c1295fa", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 102, "deletions": 96, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -26,7 +26,8 @@ use rustc::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use rustc::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability};\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -474,7 +475,7 @@ pub trait LintContext: Sized {\n     fn lints(&self) -> &LintStore;\n \n     fn lookup_and_emit<S: Into<MultiSpan>>(&self, lint: &'static Lint, span: Option<S>, msg: &str) {\n-        self.lookup(lint, span, msg).emit();\n+        self.lookup(lint, span, |lint| lint.build(msg).emit());\n     }\n \n     fn lookup_and_emit_with_diagnostics<S: Into<MultiSpan>>(\n@@ -484,95 +485,96 @@ pub trait LintContext: Sized {\n         msg: &str,\n         diagnostic: BuiltinLintDiagnostics,\n     ) {\n-        let mut db = self.lookup(lint, span, msg);\n-\n-        let sess = self.sess();\n-        match diagnostic {\n-            BuiltinLintDiagnostics::Normal => (),\n-            BuiltinLintDiagnostics::BareTraitObject(span, is_global) => {\n-                let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n-                    Ok(s) if is_global => {\n-                        (format!(\"dyn ({})\", s), Applicability::MachineApplicable)\n-                    }\n-                    Ok(s) => (format!(\"dyn {}\", s), Applicability::MachineApplicable),\n-                    Err(_) => (\"dyn <type>\".to_string(), Applicability::HasPlaceholders),\n-                };\n-                db.span_suggestion(span, \"use `dyn`\", sugg, app);\n-            }\n-            BuiltinLintDiagnostics::AbsPathWithModule(span) => {\n-                let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n-                    Ok(ref s) => {\n-                        // FIXME(Manishearth) ideally the emitting code\n-                        // can tell us whether or not this is global\n-                        let opt_colon = if s.trim_start().starts_with(\"::\") { \"\" } else { \"::\" };\n-\n-                        (format!(\"crate{}{}\", opt_colon, s), Applicability::MachineApplicable)\n-                    }\n-                    Err(_) => (\"crate::<path>\".to_string(), Applicability::HasPlaceholders),\n-                };\n-                db.span_suggestion(span, \"use `crate`\", sugg, app);\n-            }\n-            BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(span) => {\n-                db.span_label(\n-                    span,\n-                    \"names from parent modules are not accessible without an explicit import\",\n-                );\n-            }\n-            BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(span_def) => {\n-                db.span_note(span_def, \"the macro is defined here\");\n-            }\n-            BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n-                n,\n-                path_span,\n-                incl_angl_brckt,\n-                insertion_span,\n-                anon_lts,\n-            ) => {\n-                add_elided_lifetime_in_path_suggestion(\n-                    sess,\n-                    &mut db,\n+        self.lookup(lint, span, |lint| {\n+            let mut db = lint.build(msg);\n+            let sess = self.sess();\n+            match diagnostic {\n+                BuiltinLintDiagnostics::Normal => (),\n+                BuiltinLintDiagnostics::BareTraitObject(span, is_global) => {\n+                    let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n+                        Ok(s) if is_global => {\n+                            (format!(\"dyn ({})\", s), Applicability::MachineApplicable)\n+                        }\n+                        Ok(s) => (format!(\"dyn {}\", s), Applicability::MachineApplicable),\n+                        Err(_) => (\"dyn <type>\".to_string(), Applicability::HasPlaceholders),\n+                    };\n+                    db.span_suggestion(span, \"use `dyn`\", sugg, app);\n+                }\n+                BuiltinLintDiagnostics::AbsPathWithModule(span) => {\n+                    let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n+                        Ok(ref s) => {\n+                            // FIXME(Manishearth) ideally the emitting code\n+                            // can tell us whether or not this is global\n+                            let opt_colon = if s.trim_start().starts_with(\"::\") { \"\" } else { \"::\" };\n+\n+                            (format!(\"crate{}{}\", opt_colon, s), Applicability::MachineApplicable)\n+                        }\n+                        Err(_) => (\"crate::<path>\".to_string(), Applicability::HasPlaceholders),\n+                    };\n+                    db.span_suggestion(span, \"use `crate`\", sugg, app);\n+                }\n+                BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(span) => {\n+                    db.span_label(\n+                        span,\n+                        \"names from parent modules are not accessible without an explicit import\",\n+                    );\n+                }\n+                BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(span_def) => {\n+                    db.span_note(span_def, \"the macro is defined here\");\n+                }\n+                BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n                     n,\n                     path_span,\n                     incl_angl_brckt,\n                     insertion_span,\n                     anon_lts,\n-                );\n-            }\n-            BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n-                db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n-            }\n-            BuiltinLintDiagnostics::UnusedImports(message, replaces) => {\n-                if !replaces.is_empty() {\n-                    db.tool_only_multipart_suggestion(\n-                        &message,\n-                        replaces,\n-                        Applicability::MachineApplicable,\n+                ) => {\n+                    add_elided_lifetime_in_path_suggestion(\n+                        sess,\n+                        &mut db,\n+                        n,\n+                        path_span,\n+                        incl_angl_brckt,\n+                        insertion_span,\n+                        anon_lts,\n                     );\n                 }\n-            }\n-            BuiltinLintDiagnostics::RedundantImport(spans, ident) => {\n-                for (span, is_imported) in spans {\n-                    let introduced = if is_imported { \"imported\" } else { \"defined\" };\n-                    db.span_label(\n-                        span,\n-                        format!(\"the item `{}` is already {} here\", ident, introduced),\n-                    );\n+                BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n+                    db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n+                }\n+                BuiltinLintDiagnostics::UnusedImports(message, replaces) => {\n+                    if !replaces.is_empty() {\n+                        db.tool_only_multipart_suggestion(\n+                            &message,\n+                            replaces,\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                BuiltinLintDiagnostics::RedundantImport(spans, ident) => {\n+                    for (span, is_imported) in spans {\n+                        let introduced = if is_imported { \"imported\" } else { \"defined\" };\n+                        db.span_label(\n+                            span,\n+                            format!(\"the item `{}` is already {} here\", ident, introduced),\n+                        );\n+                    }\n+                }\n+                BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span) => {\n+                    stability::deprecation_suggestion(&mut db, suggestion, span)\n                 }\n             }\n-            BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span) => {\n-                stability::deprecation_suggestion(&mut db, suggestion, span)\n-            }\n-        }\n \n-        db.emit();\n+            db.emit();\n+        });\n     }\n \n     fn lookup<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n         span: Option<S>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'_>;\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    );\n \n     /// Emit a lint at the appropriate level, for a particular span.\n     fn span_lint<S: Into<MultiSpan>>(&self, lint: &'static Lint, span: S, msg: &str) {\n@@ -583,9 +585,9 @@ pub trait LintContext: Sized {\n         &self,\n         lint: &'static Lint,\n         span: S,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'_> {\n-        self.lookup(lint, Some(span), msg)\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>)\n+    ) {\n+        self.lookup(lint, Some(span), decorate);\n     }\n \n     /// Emit a lint and note at the appropriate level, for a particular span.\n@@ -597,21 +599,25 @@ pub trait LintContext: Sized {\n         note_span: Span,\n         note: &str,\n     ) {\n-        let mut err = self.lookup(lint, Some(span), msg);\n-        if note_span == span {\n-            err.note(note);\n-        } else {\n-            err.span_note(note_span, note);\n-        }\n-        err.emit();\n+        self.lookup(lint, Some(span), |lint| {\n+            let mut err = lint.build(msg);\n+            if note_span == span {\n+                err.note(note);\n+            } else {\n+                err.span_note(note_span, note);\n+            }\n+            err.emit();\n+        });\n     }\n \n     /// Emit a lint and help at the appropriate level, for a particular span.\n     fn span_lint_help(&self, lint: &'static Lint, span: Span, msg: &str, help: &str) {\n-        let mut err = self.lookup(lint, Some(span), msg);\n-        self.span_lint(lint, span, msg);\n-        err.span_help(span, help);\n-        err.emit();\n+        self.lookup(lint, Some(span), |err| {\n+            let mut err = err.build(msg);\n+            self.span_lint(lint, span, msg);\n+            err.span_help(span, help);\n+            err.emit();\n+        });\n     }\n \n     /// Emit a lint at the appropriate level, with no associated span.\n@@ -654,13 +660,13 @@ impl LintContext for LateContext<'_, '_> {\n         &self,\n         lint: &'static Lint,\n         span: Option<S>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'_> {\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         let hir_id = self.last_node_with_lint_attrs;\n \n         match span {\n-            Some(s) => self.tcx.struct_span_lint_hir(lint, hir_id, s, msg),\n-            None => self.tcx.struct_lint_node(lint, hir_id, msg),\n+            Some(s) => self.tcx.struct_span_lint_hir(lint, hir_id, s, decorate),\n+            None => self.tcx.struct_lint_node(lint, hir_id, decorate),\n         }\n     }\n }\n@@ -681,9 +687,9 @@ impl LintContext for EarlyContext<'_> {\n         &self,\n         lint: &'static Lint,\n         span: Option<S>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'_> {\n-        self.builder.struct_lint(lint, span.map(|s| s.into()), msg)\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n+        self.builder.struct_lint(lint, span.map(|s| s.into()), decorate)\n     }\n }\n "}, {"sha": "19778a044a4986c9822681139b14ef60d76b71f5", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -37,16 +37,19 @@ impl_lint_pass!(DefaultHashTypes => [DEFAULT_HASH_TYPES]);\n impl EarlyLintPass for DefaultHashTypes {\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         if let Some(replace) = self.map.get(&ident.name) {\n+            // FIXME: We can avoid a copy here. Would require us to take String instead of &str.\n             let msg = format!(\"Prefer {} over {}, it has better performance\", replace, ident);\n-            let mut db = cx.struct_span_lint(DEFAULT_HASH_TYPES, ident.span, &msg);\n-            db.span_suggestion(\n-                ident.span,\n-                \"use\",\n-                replace.to_string(),\n-                Applicability::MaybeIncorrect, // FxHashMap, ... needs another import\n-            );\n-            db.note(&format!(\"a `use rustc_data_structures::fx::{}` may be necessary\", replace))\n-                .emit();\n+            cx.struct_span_lint(DEFAULT_HASH_TYPES, ident.span, |lint| {\n+                lint.build(&msg)\n+                    .span_suggestion(\n+                        ident.span,\n+                        \"use\",\n+                        replace.to_string(),\n+                        Applicability::MaybeIncorrect, // FxHashMap, ... needs another import\n+                    )\n+                    .note(&format!(\"a `use rustc_data_structures::fx::{}` may be necessary\", replace))\n+                    .emit();\n+            });\n         }\n     }\n }\n@@ -85,14 +88,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n         if let Some(last) = segments.last() {\n             let span = path.span.with_hi(last.ident.span.hi());\n             if lint_ty_kind_usage(cx, last) {\n-                cx.struct_span_lint(USAGE_OF_TY_TYKIND, span, \"usage of `ty::TyKind::<kind>`\")\n+                cx.struct_span_lint(USAGE_OF_TY_TYKIND, span, |lint| {\n+                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n                     .span_suggestion(\n                         span,\n                         \"try using ty::<kind> directly\",\n                         \"ty\".to_string(),\n                         Applicability::MaybeIncorrect, // ty maybe needs an import\n                     )\n                     .emit();\n+                })\n             }\n         }\n     }\n@@ -106,10 +111,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                             cx.struct_span_lint(\n                                 USAGE_OF_TY_TYKIND,\n                                 path.span,\n-                                \"usage of `ty::TyKind`\",\n+                                |lint| {\n+                                    lint.build(\"usage of `ty::TyKind`\")\n+                                        .help(\"try using `Ty` instead\")\n+                                        .emit();\n+                                },\n                             )\n-                            .help(\"try using `Ty` instead\")\n-                            .emit();\n                         } else {\n                             if ty.span.from_expansion() {\n                                 return;\n@@ -119,16 +126,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                                     cx.struct_span_lint(\n                                         USAGE_OF_QUALIFIED_TY,\n                                         path.span,\n-                                        &format!(\"usage of qualified `ty::{}`\", t),\n+                                        |lint| {\n+                                            lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n+                                                .span_suggestion(\n+                                                    path.span,\n+                                                    \"try using it unqualified\",\n+                                                    t,\n+                                                    // The import probably needs to be changed\n+                                                    Applicability::MaybeIncorrect,\n+                                                )\n+                                                .emit();\n+                                        },\n                                     )\n-                                    .span_suggestion(\n-                                        path.span,\n-                                        \"try using it unqualified\",\n-                                        t,\n-                                        // The import probably needs to be changed\n-                                        Applicability::MaybeIncorrect,\n-                                    )\n-                                    .emit();\n                                 }\n                             }\n                         }\n@@ -145,16 +154,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                     cx.struct_span_lint(\n                         TY_PASS_BY_REFERENCE,\n                         ty.span,\n-                        &format!(\"passing `{}` by reference\", t),\n-                    )\n-                    .span_suggestion(\n-                        ty.span,\n-                        \"try passing by value\",\n-                        t,\n-                        // Changing type of function argument\n-                        Applicability::MaybeIncorrect,\n+                        |lint| {\n+                            lint.build(&format!(\"passing `{}` by reference\", t))\n+                            .span_suggestion(\n+                                ty.span,\n+                                \"try passing by value\",\n+                                t,\n+                                // Changing type of function argument\n+                                Applicability::MaybeIncorrect,\n+                            )\n+                            .emit();\n+                        },\n                     )\n-                    .emit();\n                 }\n             }\n             _ => {}\n@@ -234,10 +245,12 @@ impl EarlyLintPass for LintPassImpl {\n                         cx.struct_span_lint(\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,\n-                            \"implementing `LintPass` by hand\",\n+                            |lint| {\n+                                lint.build(\"implementing `LintPass` by hand\")\n+                                    .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n+                                    .emit();\n+                            },\n                         )\n-                        .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n-                        .emit();\n                     }\n                 }\n             }"}, {"sha": "6dd899d146182794c988a8d530470bff2a12675e", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 46, "deletions": 40, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -6,7 +6,8 @@ use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability};\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::{intravisit, HirId};\n@@ -39,8 +40,8 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     tcx.arena.alloc(builder.levels.build_map())\n }\n \n-pub struct LintLevelsBuilder<'a> {\n-    sess: &'a Session,\n+pub struct LintLevelsBuilder<'s> {\n+    sess: &'s Session,\n     sets: LintLevelSets,\n     id_to_set: FxHashMap<HirId, u32>,\n     cur: u32,\n@@ -52,8 +53,8 @@ pub struct BuilderPush {\n     pub changed: bool,\n }\n \n-impl<'a> LintLevelsBuilder<'a> {\n-    pub fn new(sess: &'a Session, warn_about_weird_lints: bool, store: &LintStore) -> Self {\n+impl<'s> LintLevelsBuilder<'s> {\n+    pub fn new(sess: &'s Session, warn_about_weird_lints: bool, store: &LintStore) -> Self {\n         let mut builder = LintLevelsBuilder {\n             sess,\n             sets: LintLevelSets::new(),\n@@ -245,15 +246,17 @@ impl<'a> LintLevelsBuilder<'a> {\n                                     lvl,\n                                     src,\n                                     Some(li.span().into()),\n-                                    &msg,\n-                                )\n-                                .span_suggestion(\n-                                    li.span(),\n-                                    \"change it to\",\n-                                    new_lint_name.to_string(),\n-                                    Applicability::MachineApplicable,\n-                                )\n-                                .emit();\n+                                    |lint| {\n+                                        lint.build(&msg)\n+                                        .span_suggestion(\n+                                            li.span(),\n+                                            \"change it to\",\n+                                            new_lint_name.to_string(),\n+                                            Applicability::MachineApplicable,\n+                                        )\n+                                        .emit();\n+                                    },\n+                                );\n \n                                 let src = LintSource::Node(\n                                     Symbol::intern(&new_lint_name),\n@@ -279,48 +282,51 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n                         let (level, src) =\n                             self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n-                        let mut err = struct_lint_level(\n+                        struct_lint_level(\n                             self.sess,\n                             lint,\n                             level,\n                             src,\n                             Some(li.span().into()),\n-                            &msg,\n+                            |lint| {\n+                                let mut err = lint.build(&msg);\n+                                if let Some(new_name) = renamed {\n+                                    err.span_suggestion(\n+                                        li.span(),\n+                                        \"use the new name\",\n+                                        new_name,\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                }\n+                                err.emit();\n+                            },\n                         );\n-                        if let Some(new_name) = renamed {\n-                            err.span_suggestion(\n-                                li.span(),\n-                                \"use the new name\",\n-                                new_name,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        err.emit();\n                     }\n                     CheckLintNameResult::NoLint(suggestion) => {\n                         let lint = builtin::UNKNOWN_LINTS;\n                         let (level, src) =\n                             self.sets.get_lint_level(lint, self.cur, Some(&specs), self.sess);\n                         let msg = format!(\"unknown lint: `{}`\", name);\n-                        let mut db = struct_lint_level(\n+                        struct_lint_level(\n                             self.sess,\n                             lint,\n                             level,\n                             src,\n                             Some(li.span().into()),\n-                            &msg,\n+                            |lint| {\n+                                let mut db = lint.build(&msg);\n+                                if let Some(suggestion) = suggestion {\n+                                    db.span_suggestion(\n+                                        li.span(),\n+                                        \"did you mean\",\n+                                        suggestion.to_string(),\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                }\n+                                db.emit();\n+                            },\n                         );\n \n-                        if let Some(suggestion) = suggestion {\n-                            db.span_suggestion(\n-                                li.span(),\n-                                \"did you mean\",\n-                                suggestion.to_string(),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-\n-                        db.emit();\n                     }\n                 }\n             }\n@@ -390,10 +396,10 @@ impl<'a> LintLevelsBuilder<'a> {\n         &self,\n         lint: &'static Lint,\n         span: Option<MultiSpan>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'a> {\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         let (level, src) = self.sets.get_lint_level(lint, self.cur, None, self.sess);\n-        struct_lint_level(self.sess, lint, level, src, span, msg)\n+        struct_lint_level(self.sess, lint, level, src, span, decorate)\n     }\n \n     /// Registers the ID provided with the current set of lints stored in"}, {"sha": "df91df8f8b594b01c9053cb4457aa9ffa2ae82d6", "filename": "src/librustc_lint/non_ascii_idents.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnon_ascii_idents.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -25,16 +25,14 @@ impl EarlyLintPass for NonAsciiIdents {\n         cx.struct_span_lint(\n             NON_ASCII_IDENTS,\n             ident.span,\n-            \"identifier contains non-ASCII characters\",\n-        )\n-        .emit();\n+            |lint| lint.build(\"identifier contains non-ASCII characters\").emit(),\n+        );\n         if !name_str.chars().all(GeneralSecurityProfile::identifier_allowed) {\n             cx.struct_span_lint(\n                 UNCOMMON_CODEPOINTS,\n                 ident.span,\n-                \"identifier contains uncommon Unicode codepoints\",\n+                |lint| lint.build(\"identifier contains uncommon Unicode codepoints\").emit(),\n             )\n-            .emit();\n         }\n     }\n }"}, {"sha": "9e291d2cb74e743487618fc7166420d3df7dfc39", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -108,14 +108,14 @@ impl NonCamelCaseTypes {\n \n         if !is_camel_case(name) {\n             let msg = format!(\"{} `{}` should have an upper camel case name\", sort, name);\n-            cx.struct_span_lint(NON_CAMEL_CASE_TYPES, ident.span, &msg)\n-                .span_suggestion(\n+            cx.struct_span_lint(NON_CAMEL_CASE_TYPES, ident.span, |lint| {\n+                lint.build(&msg).span_suggestion(\n                     ident.span,\n                     \"convert the identifier to upper camel case\",\n                     to_camel_case(name),\n                     Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+                ).emit()\n+            })\n         }\n     }\n }\n@@ -226,22 +226,24 @@ impl NonSnakeCase {\n             let sc = NonSnakeCase::to_snake_case(name);\n \n             let msg = format!(\"{} `{}` should have a snake case name\", sort, name);\n-            let mut err = cx.struct_span_lint(NON_SNAKE_CASE, ident.span, &msg);\n+            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, |lint| {\n+                let mut err = lint.build(&msg);\n+                // We have a valid span in almost all cases, but we don't have one when linting a crate\n+                // name provided via the command line.\n+                if !ident.span.is_dummy() {\n+                    err.span_suggestion(\n+                        ident.span,\n+                        \"convert the identifier to snake case\",\n+                        sc,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    err.help(&format!(\"convert the identifier to snake case: `{}`\", sc));\n+                }\n \n-            // We have a valid span in almost all cases, but we don't have one when linting a crate\n-            // name provided via the command line.\n-            if !ident.span.is_dummy() {\n-                err.span_suggestion(\n-                    ident.span,\n-                    \"convert the identifier to snake case\",\n-                    sc,\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.help(&format!(\"convert the identifier to snake case: `{}`\", sc));\n-            }\n+                err.emit();\n+            });\n \n-            err.emit();\n         }\n     }\n }\n@@ -390,15 +392,16 @@ impl NonUpperCaseGlobals {\n         if name.chars().any(|c| c.is_lowercase()) {\n             let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n \n-            let msg = format!(\"{} `{}` should have an upper case name\", sort, name);\n-            cx.struct_span_lint(NON_UPPER_CASE_GLOBALS, ident.span, &msg)\n+            cx.struct_span_lint(NON_UPPER_CASE_GLOBALS, ident.span, |lint| {\n+                lint.build(&format!(\"{} `{}` should have an upper case name\", sort, name))\n                 .span_suggestion(\n                     ident.span,\n                     \"convert the identifier to upper case\",\n                     uc,\n                     Applicability::MaybeIncorrect,\n                 )\n                 .emit();\n+            })\n         }\n     }\n }"}, {"sha": "68cb0b54f56c55439d34e2e79877921e48a93913", "filename": "src/librustc_lint/redundant_semicolon.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fredundant_semicolon.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -26,19 +26,21 @@ impl EarlyLintPass for RedundantSemicolon {\n                             } else {\n                                 \"unnecessary trailing semicolon\"\n                             };\n-                            let mut err = cx.struct_span_lint(REDUNDANT_SEMICOLON, stmt.span, &msg);\n-                            let suggest_msg = if multiple {\n-                                \"remove these semicolons\"\n-                            } else {\n-                                \"remove this semicolon\"\n-                            };\n-                            err.span_suggestion(\n-                                stmt.span,\n-                                &suggest_msg,\n-                                String::new(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            err.emit();\n+                            cx.struct_span_lint(REDUNDANT_SEMICOLON, stmt.span, |lint| {\n+                                let mut err = lint.build(&msg);\n+                                let suggest_msg = if multiple {\n+                                    \"remove these semicolons\"\n+                                } else {\n+                                    \"remove this semicolon\"\n+                                };\n+                                err.span_suggestion(\n+                                    stmt.span,\n+                                    &suggest_msg,\n+                                    String::new(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                err.emit();\n+                            });\n                         }\n                     }\n                 }"}, {"sha": "30a903a2a30d207737d1b298ad114d774f02001d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -67,6 +67,7 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n     // which are represented as `ExprKind::Struct`.\n+    let mut overwritten = false;\n     if let ExprKind::Struct(_, eps, _) = &parent_expr.kind {\n         if eps.len() != 2 {\n             return false;\n@@ -75,35 +76,36 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n         // (`..=`) instead only if it is the `end` that is\n         // overflowing and only by 1.\n         if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n-            let mut err = cx.struct_span_lint(\n+            cx.struct_span_lint(\n                 OVERFLOWING_LITERALS,\n                 parent_expr.span,\n-                &format!(\"range endpoint is out of range for `{}`\", ty),\n+                |lint| {\n+                    let mut err = lint.build(&format!(\"range endpoint is out of range for `{}`\", ty));\n+                    if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n+                        use ast::{LitIntType, LitKind};\n+                        // We need to preserve the literal's suffix,\n+                        // as it may determine typing information.\n+                        let suffix = match lit.node {\n+                            LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s.name_str()),\n+                            LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s.name_str()),\n+                            LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n+                            _ => bug!(),\n+                        };\n+                        let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n+                        err.span_suggestion(\n+                            parent_expr.span,\n+                            &\"use an inclusive range instead\",\n+                            suggestion,\n+                            Applicability::MachineApplicable,\n+                        );\n+                        err.emit();\n+                        overwritten = true;\n+                    }\n+                },\n             );\n-            if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n-                use ast::{LitIntType, LitKind};\n-                // We need to preserve the literal's suffix,\n-                // as it may determine typing information.\n-                let suffix = match lit.node {\n-                    LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s.name_str()),\n-                    LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s.name_str()),\n-                    LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n-                    _ => bug!(),\n-                };\n-                let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-                err.span_suggestion(\n-                    parent_expr.span,\n-                    &\"use an inclusive range instead\",\n-                    suggestion,\n-                    Applicability::MachineApplicable,\n-                );\n-                err.emit();\n-                return true;\n-            }\n         }\n     }\n-\n-    false\n+    overwritten\n }\n \n // For `isize` & `usize`, be conservative with the warnings, so that the\n@@ -163,31 +165,32 @@ fn report_bin_hex_error(\n             (t.name_str(), actually.to_string())\n         }\n     };\n-    let mut err = cx.struct_span_lint(\n+    cx.struct_span_lint(\n         OVERFLOWING_LITERALS,\n         expr.span,\n-        &format!(\"literal out of range for {}\", t),\n+        |lint| {\n+            let mut err = lint.build(&format!(\"literal out of range for {}\", t));\n+            err.note(&format!(\n+                \"the literal `{}` (decimal `{}`) does not fit into \\\n+                    an `{}` and will become `{}{}`\",\n+                repr_str, val, t, actually, t\n+            ));\n+            if let Some(sugg_ty) = get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative) {\n+                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+                    let (sans_suffix, _) = repr_str.split_at(pos);\n+                    err.span_suggestion(\n+                        expr.span,\n+                        &format!(\"consider using `{}` instead\", sugg_ty),\n+                        format!(\"{}{}\", sans_suffix, sugg_ty),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n+                }\n+            }\n+            err.emit();\n+        },\n     );\n-    err.note(&format!(\n-        \"the literal `{}` (decimal `{}`) does not fit into \\\n-            an `{}` and will become `{}{}`\",\n-        repr_str, val, t, actually, t\n-    ));\n-    if let Some(sugg_ty) = get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative) {\n-        if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n-            let (sans_suffix, _) = repr_str.split_at(pos);\n-            err.span_suggestion(\n-                expr.span,\n-                &format!(\"consider using `{}` instead\", sugg_ty),\n-                format!(\"{}{}\", sans_suffix, sugg_ty),\n-                Applicability::MachineApplicable,\n-            );\n-        } else {\n-            err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n-        }\n-    }\n-\n-    err.emit();\n }\n \n // This function finds the next fitting type and generates a suggestion string.\n@@ -298,18 +301,16 @@ fn lint_uint_literal<'a, 'tcx>(\n             match par_e.kind {\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.tables.expr_ty(par_e).kind {\n-                        let mut err = cx.struct_span_lint(\n-                            OVERFLOWING_LITERALS,\n-                            par_e.span,\n-                            \"only `u8` can be cast into `char`\",\n-                        );\n-                        err.span_suggestion(\n-                            par_e.span,\n-                            &\"use a `char` literal instead\",\n-                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n-                            Applicability::MachineApplicable,\n-                        );\n-                        err.emit();\n+                        cx.struct_span_lint(OVERFLOWING_LITERALS, par_e.span, |lint| {\n+                            lint.build(\"only `u8` can be cast into `char`\")\n+                                .span_suggestion(\n+                                    par_e.span,\n+                                    &\"use a `char` literal instead\",\n+                                    format!(\"'\\\\u{{{:X}}}'\", lit_val),\n+                                    Applicability::MachineApplicable,\n+                                )\n+                                .emit();\n+                        });\n                         return;\n                     }\n                 }\n@@ -883,22 +884,21 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         note: &str,\n         help: Option<&str>,\n     ) {\n-        let mut diag = self.cx.struct_span_lint(\n-            IMPROPER_CTYPES,\n-            sp,\n-            &format!(\"`extern` block uses type `{}`, which is not FFI-safe\", ty),\n-        );\n-        diag.span_label(sp, \"not FFI-safe\");\n-        if let Some(help) = help {\n-            diag.help(help);\n-        }\n-        diag.note(note);\n-        if let ty::Adt(def, _) = ty.kind {\n-            if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did) {\n-                diag.span_note(sp, \"the type is defined here\");\n+        self.cx.struct_span_lint(IMPROPER_CTYPES, sp, |lint| {\n+            let mut diag =\n+                lint.build(&format!(\"`extern` block uses type `{}`, which is not FFI-safe\", ty));\n+            diag.span_label(sp, \"not FFI-safe\");\n+            if let Some(help) = help {\n+                diag.help(help);\n             }\n-        }\n-        diag.emit();\n+            diag.note(note);\n+            if let ty::Adt(def, _) = ty.kind {\n+                if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did) {\n+                    diag.span_note(sp, \"the type is defined here\");\n+                }\n+            }\n+            diag.emit();\n+        });\n     }\n \n     fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {"}, {"sha": "2f4a9572a8349263da18c4e4b4d9f61566d351ce", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 57, "deletions": 53, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -213,18 +213,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         ) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n                 if attr.check_name(sym::must_use) {\n-                    let msg = format!(\n-                        \"unused {}`{}`{} that must be used\",\n-                        descr_pre_path,\n-                        cx.tcx.def_path_str(def_id),\n-                        descr_post_path\n-                    );\n-                    let mut err = cx.struct_span_lint(UNUSED_MUST_USE, span, &msg);\n-                    // check for #[must_use = \"...\"]\n-                    if let Some(note) = attr.value_str() {\n-                        err.note(&note.as_str());\n-                    }\n-                    err.emit();\n+                    cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n+                        let msg = format!(\n+                            \"unused {}`{}`{} that must be used\",\n+                            descr_pre_path,\n+                            cx.tcx.def_path_str(def_id),\n+                            descr_post_path\n+                        );\n+                        let mut err = lint.build(&msg);\n+                        // check for #[must_use = \"...\"]\n+                        if let Some(note) = attr.value_str() {\n+                            err.note(&note.as_str());\n+                        }\n+                        err.emit();\n+                    });\n                     return true;\n                 }\n             }\n@@ -406,52 +408,54 @@ impl UnusedParens {\n         msg: &str,\n         keep_space: (bool, bool),\n     ) {\n-        let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n-        let mut err = cx.struct_span_lint(UNUSED_PARENS, span, &span_msg);\n-        let mut ate_left_paren = false;\n-        let mut ate_right_paren = false;\n-        let parens_removed = pattern.trim_matches(|c| match c {\n-            '(' => {\n-                if ate_left_paren {\n-                    false\n-                } else {\n-                    ate_left_paren = true;\n-                    true\n+        cx.struct_span_lint(UNUSED_PARENS, span, |lint| {\n+            let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n+            let mut err = lint.build(&span_msg);\n+            let mut ate_left_paren = false;\n+            let mut ate_right_paren = false;\n+            let parens_removed = pattern.trim_matches(|c| match c {\n+                '(' => {\n+                    if ate_left_paren {\n+                        false\n+                    } else {\n+                        ate_left_paren = true;\n+                        true\n+                    }\n                 }\n-            }\n-            ')' => {\n-                if ate_right_paren {\n-                    false\n-                } else {\n-                    ate_right_paren = true;\n-                    true\n+                ')' => {\n+                    if ate_right_paren {\n+                        false\n+                    } else {\n+                        ate_right_paren = true;\n+                        true\n+                    }\n                 }\n-            }\n-            _ => false,\n-        });\n+                _ => false,\n+            });\n \n-        let replace = {\n-            let mut replace = if keep_space.0 {\n-                let mut s = String::from(\" \");\n-                s.push_str(parens_removed);\n-                s\n-            } else {\n-                String::from(parens_removed)\n-            };\n+            let replace = {\n+                let mut replace = if keep_space.0 {\n+                    let mut s = String::from(\" \");\n+                    s.push_str(parens_removed);\n+                    s\n+                } else {\n+                    String::from(parens_removed)\n+                };\n \n-            if keep_space.1 {\n-                replace.push(' ');\n-            }\n-            replace\n-        };\n+                if keep_space.1 {\n+                    replace.push(' ');\n+                }\n+                replace\n+            };\n \n-        err.span_suggestion_short(\n-            span,\n-            \"remove these parentheses\",\n-            replace,\n-            Applicability::MachineApplicable,\n-        );\n-        err.emit();\n+            err.span_suggestion_short(\n+                span,\n+                \"remove these parentheses\",\n+                replace,\n+                Applicability::MachineApplicable,\n+            );\n+            err.emit();\n+        });\n     }\n }\n "}, {"sha": "25f1a495ad3e4c3738215efbf8d12c99df63cbe9", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -319,18 +319,20 @@ fn do_mir_borrowck<'a, 'tcx>(\n         };\n \n         // Span and message don't matter; we overwrite them below anyway\n-        let mut diag = mbcx.infcx.tcx.struct_span_lint_hir(\n+        mbcx.infcx.tcx.struct_span_lint_hir(\n             MUTABLE_BORROW_RESERVATION_CONFLICT,\n             lint_root,\n             DUMMY_SP,\n-            \"\",\n-        );\n+            |lint| {\n+                let mut diag = lint.build(\"\");\n \n-        diag.message = initial_diag.styled_message().clone();\n-        diag.span = initial_diag.span.clone();\n+                diag.message = initial_diag.styled_message().clone();\n+                diag.span = initial_diag.span.clone();\n \n+                diag.buffer(&mut mbcx.errors_buffer);\n+            },\n+        );\n         initial_diag.cancel();\n-        diag.buffer(&mut mbcx.errors_buffer);\n     }\n \n     // For each non-user used mutable variable, check if it's been assigned from\n@@ -381,15 +383,17 @@ fn do_mir_borrowck<'a, 'tcx>(\n             UNUSED_MUT,\n             lint_root,\n             span,\n-            \"variable does not need to be mutable\",\n-        )\n-        .span_suggestion_short(\n-            mut_span,\n-            \"remove this `mut`\",\n-            String::new(),\n-            Applicability::MachineApplicable,\n+            |lint| {\n+                lint.build(\"variable does not need to be mutable\")\n+                .span_suggestion_short(\n+                    mut_span,\n+                    \"remove this `mut`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+            },\n         )\n-        .emit();\n     }\n \n     // Buffer any move errors that we collected and de-duplicated."}, {"sha": "99d3b281945ebda72bab160772cf521c58459a89", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -209,10 +209,11 @@ fn validate_and_turn_into_const<'tcx>(\n \n     val.map_err(|error| {\n         let err = error_to_const_error(&ecx, error);\n-        match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n-            Ok(mut diag) => {\n-                diag.note(note_on_undefined_behavior_error());\n-                diag.emit();\n+        match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n+            diag.note(note_on_undefined_behavior_error());\n+            diag.emit();\n+        }) {\n+            Ok(_) => {\n                 ErrorHandled::Reported\n             }\n             Err(err) => err,"}, {"sha": "9fea82d78c94f91cddf3acc32471bd1da365c62e", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -326,12 +326,15 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             // to read enum discriminants in order to find references in enum variant fields.\n             if let err_unsup!(ValidationFailure(_)) = error.kind {\n                 let err = crate::const_eval::error_to_const_error(&ecx, error);\n-                match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n-                    Ok(mut diag) => {\n+                match err.struct_error(\n+                    ecx.tcx,\n+                    \"it is undefined behavior to use this value\",\n+                    |mut diag| {\n                         diag.note(crate::const_eval::note_on_undefined_behavior_error());\n                         diag.emit();\n-                    }\n-                    Err(ErrorHandled::TooGeneric) | Err(ErrorHandled::Reported) => {}\n+                    },\n+                ) {\n+                    Ok(()) | Err(ErrorHandled::TooGeneric) | Err(ErrorHandled::Reported) => {}\n                 }\n             }\n         }"}, {"sha": "c019fa57fb7832dac7936945e6fe80092a019c42", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -527,7 +527,9 @@ fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: DefId) {\n          does not derive Copy (error E0133)\"\n             .to_string()\n     };\n-    tcx.lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), &message);\n+    tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n+        lint.build(&message).emit()\n+    });\n }\n \n /// Returns the `HirId` for an enclosing scope that is also `unsafe`.\n@@ -559,15 +561,17 @@ fn is_enclosed(\n fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n     let span = tcx.sess.source_map().def_span(tcx.hir().span(id));\n     let msg = \"unnecessary `unsafe` block\";\n-    let mut db = tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg);\n-    db.span_label(span, msg);\n-    if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n-        db.span_label(\n-            tcx.sess.source_map().def_span(tcx.hir().span(id)),\n-            format!(\"because it's nested under this `unsafe` {}\", kind),\n-        );\n-    }\n-    db.emit();\n+    tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, |lint| {\n+        let mut db = lint.build(msg);\n+        db.span_label(span, msg);\n+        if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n+            db.span_label(\n+                tcx.sess.source_map().def_span(tcx.hir().span(id)),\n+                format!(\"because it's nested under this `unsafe` {}\", kind),\n+            );\n+        }\n+        db.emit();\n+    });\n }\n \n fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n@@ -619,13 +623,17 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n                         SAFE_PACKED_BORROWS,\n                         lint_hir_id,\n                         source_info.span,\n-                        &format!(\n-                            \"{} is unsafe and requires unsafe function or block (error E0133)\",\n-                            description\n-                        ),\n+                        |lint| {\n+                            lint.build(\n+                                &format!(\n+                                    \"{} is unsafe and requires unsafe function or block (error E0133)\",\n+                                    description\n+                                )\n+                            )\n+                            .note(&details.as_str())\n+                            .emit()\n+                        }\n                     )\n-                    .note(&details.as_str())\n-                    .emit();\n                 }\n             }\n         }"}, {"sha": "aeeca52ba3ba27ac7c7de405ff23744659d136ed", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -557,11 +557,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             if r_bits.map_or(false, |b| b >= left_bits as u128) {\n                 let lint_root = self.lint_root(source_info)?;\n                 let dir = if op == BinOp::Shr { \"right\" } else { \"left\" };\n-                self.tcx.lint_hir(\n+                self.tcx.struct_span_lint_hir(\n                     ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n                     lint_root,\n                     source_info.span,\n-                    &format!(\"attempt to shift {} with overflow\", dir),\n+                    |lint| lint.build(&format!(\"attempt to shift {} with overflow\", dir)).emit(),\n                 );\n                 return None;\n             }\n@@ -912,35 +912,42 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                             .hir()\n                             .as_local_hir_id(self.source.def_id())\n                             .expect(\"some part of a failing const eval must be local\");\n-                        let msg = match msg {\n-                            PanicInfo::Overflow(_)\n-                            | PanicInfo::OverflowNeg\n-                            | PanicInfo::DivisionByZero\n-                            | PanicInfo::RemainderByZero => msg.description().to_owned(),\n-                            PanicInfo::BoundsCheck { ref len, ref index } => {\n-                                let len =\n-                                    self.eval_operand(len, source_info).expect(\"len must be const\");\n-                                let len = match self.ecx.read_scalar(len) {\n-                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Raw { data, .. })) => data,\n-                                    other => bug!(\"const len not primitive: {:?}\", other),\n-                                };\n-                                let index = self\n-                                    .eval_operand(index, source_info)\n-                                    .expect(\"index must be const\");\n-                                let index = match self.ecx.read_scalar(index) {\n-                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Raw { data, .. })) => data,\n-                                    other => bug!(\"const index not primitive: {:?}\", other),\n+                        self.tcx.struct_span_lint_hir(\n+                            ::rustc::lint::builtin::CONST_ERR,\n+                            hir_id,\n+                            span,\n+                            |lint| {\n+                                let msg = match msg {\n+                                    PanicInfo::Overflow(_)\n+                                    | PanicInfo::OverflowNeg\n+                                    | PanicInfo::DivisionByZero\n+                                    | PanicInfo::RemainderByZero => msg.description().to_owned(),\n+                                    PanicInfo::BoundsCheck { ref len, ref index } => {\n+                                        let len =\n+                                            self.eval_operand(len, source_info).expect(\"len must be const\");\n+                                        let len = match self.ecx.read_scalar(len) {\n+                                            Ok(ScalarMaybeUndef::Scalar(Scalar::Raw { data, .. })) => data,\n+                                            other => bug!(\"const len not primitive: {:?}\", other),\n+                                        };\n+                                        let index = self\n+                                            .eval_operand(index, source_info)\n+                                            .expect(\"index must be const\");\n+                                        let index = match self.ecx.read_scalar(index) {\n+                                            Ok(ScalarMaybeUndef::Scalar(Scalar::Raw { data, .. })) => data,\n+                                            other => bug!(\"const index not primitive: {:?}\", other),\n+                                        };\n+                                        format!(\n+                                            \"index out of bounds: \\\n+                                            the len is {} but the index is {}\",\n+                                            len, index,\n+                                        )\n+                                    }\n+                                    // Need proper const propagator for these\n+                                    _ => return,\n                                 };\n-                                format!(\n-                                    \"index out of bounds: \\\n-                                    the len is {} but the index is {}\",\n-                                    len, index,\n-                                )\n-                            }\n-                            // Need proper const propagator for these\n-                            _ => return,\n-                        };\n-                        self.tcx.lint_hir(::rustc::lint::builtin::CONST_ERR, hir_id, span, &msg);\n+                                lint.build(&msg).emit()\n+                            },\n+                        );\n                     } else {\n                         if self.should_const_prop(value) {\n                             if let ScalarMaybeUndef::Scalar(scalar) = value_const {"}, {"sha": "7ed6c81eb63bd6671927249adb02a9c9fb6872cc", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -2235,24 +2235,26 @@ fn lint_overlapping_patterns<'tcx>(\n     overlaps: Vec<IntRange<'tcx>>,\n ) {\n     if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n-        let mut err = tcx.struct_span_lint_hir(\n+        tcx.struct_span_lint_hir(\n             lint::builtin::OVERLAPPING_PATTERNS,\n             hir_id,\n             ctor_range.span,\n-            \"multiple patterns covering the same range\",\n+            |lint| {\n+                let mut err = lint.build(\"multiple patterns covering the same range\");\n+                err.span_label(ctor_range.span, \"overlapping patterns\");\n+                for int_range in overlaps {\n+                    // Use the real type for user display of the ranges:\n+                    err.span_label(\n+                        int_range.span,\n+                        &format!(\n+                            \"this range overlaps on `{}`\",\n+                            IntRange { range: int_range.range, ty, span: DUMMY_SP }.to_pat(tcx),\n+                        ),\n+                    );\n+                }\n+                err.emit();\n+            },\n         );\n-        err.span_label(ctor_range.span, \"overlapping patterns\");\n-        for int_range in overlaps {\n-            // Use the real type for user display of the ranges:\n-            err.span_label(\n-                int_range.span,\n-                &format!(\n-                    \"this range overlaps on `{}`\",\n-                    IntRange { range: int_range.range, ty, span: DUMMY_SP }.to_pat(tcx),\n-                ),\n-            );\n-        }\n-        err.emit();\n     }\n }\n "}, {"sha": "421f7958e5f4973fd8897a52c6398a988a78f113", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -292,20 +292,25 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                                 BINDINGS_WITH_VARIANT_NAME,\n                                 p.hir_id,\n                                 p.span,\n-                                &format!(\n-                                    \"pattern binding `{}` is named the same as one \\\n-                                    of the variants of the type `{}`\",\n-                                    ident, ty_path\n-                                ),\n+                                |lint| {\n+                                    lint\n+                                        .build(\n+                                            &format!(\n+                                                \"pattern binding `{}` is named the same as one \\\n+                                                of the variants of the type `{}`\",\n+                                                ident, ty_path\n+                                            )\n+                                        )\n+                                        .code(error_code!(E0170))\n+                                        .span_suggestion(\n+                                            p.span,\n+                                            \"to match on the variant, qualify the path\",\n+                                            format!(\"{}::{}\", ty_path, ident),\n+                                            Applicability::MachineApplicable,\n+                                        )\n+                                        .emit();\n+                                },\n                             )\n-                            .code(error_code!(E0170))\n-                            .span_suggestion(\n-                                p.span,\n-                                \"to match on the variant, qualify the path\",\n-                                format!(\"{}::{}\", ty_path, ident),\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n                     }\n                 }\n             }\n@@ -325,13 +330,15 @@ fn pat_is_catchall(pat: &super::Pat<'_>) -> bool {\n }\n \n fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<Span>) {\n-    let mut err = tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, \"unreachable pattern\");\n-    if let Some(catchall) = catchall {\n-        // We had a catchall pattern, hint at that.\n-        err.span_label(span, \"unreachable pattern\");\n-        err.span_label(catchall, \"matches any value\");\n-    }\n-    err.emit();\n+    tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, |lint| {\n+        let mut err = lint.build(\"unreachable pattern\");\n+        if let Some(catchall) = catchall {\n+            // We had a catchall pattern, hint at that.\n+            err.span_label(span, \"unreachable pattern\");\n+            err.span_label(catchall, \"matches any value\");\n+        }\n+        err.emit();\n+    });\n }\n \n fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::MatchSource) {\n@@ -340,7 +347,7 @@ fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::\n         hir::MatchSource::WhileLetDesugar => \"irrefutable while-let pattern\",\n         _ => bug!(),\n     };\n-    tcx.lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, msg);\n+    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| lint.build(msg).emit());\n }\n \n /// Check for unreachable patterns."}, {"sha": "5fbe764430c54ad097eb2f8545b1223b09027b8e", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -109,11 +109,14 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     }\n                 };\n                 let path = self.tcx().def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path, path,\n-                );\n+\n+                let make_msg = || -> String {\n+                    format!(\n+                        \"to use a constant of type `{}` in a pattern, \\\n+                         `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                        path, path,\n+                    )\n+                };\n \n                 // double-check there even *is* a semantic `PartialEq` to dispatch to.\n                 //\n@@ -143,13 +146,13 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n \n                 if !ty_is_partial_eq {\n                     // span_fatal avoids ICE from resolution of non-existent method (rare case).\n-                    self.tcx().sess.span_fatal(self.span, &msg);\n+                    self.tcx().sess.span_fatal(self.span, &make_msg());\n                 } else {\n-                    self.tcx().lint_hir(\n+                    self.tcx().struct_span_lint_hir(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         self.id,\n                         self.span,\n-                        &msg,\n+                        |lint| lint.build(&make_msg()).emit(),\n                     );\n                 }\n             }\n@@ -177,11 +180,11 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n \n         let kind = match cv.ty.kind {\n             ty::Float(_) => {\n-                tcx.lint_hir(\n+                tcx.struct_span_lint_hir(\n                     ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                     id,\n                     span,\n-                    \"floating-point types cannot be used in patterns\",\n+                    |lint| lint.build(\"floating-point types cannot be used in patterns\").emit(),\n                 );\n                 PatKind::Constant { value: cv }\n             }"}, {"sha": "4704f8d034dca733ebbc5dd6c5ec7d2816e42665", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -124,18 +124,20 @@ fn check_fn_for_unconditional_recursion<'tcx>(\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let sp = tcx.sess.source_map().def_span(tcx.hir().span(hir_id));\n-        let mut db = tcx.struct_span_lint_hir(\n+        tcx.struct_span_lint_hir(\n             UNCONDITIONAL_RECURSION,\n             hir_id,\n             sp,\n-            \"function cannot return without recursing\",\n+            |lint| {\n+                let mut db = lint.build(\"function cannot return without recursing\");\n+                db.span_label(sp, \"cannot return without recursing\");\n+                // offer some help to the programmer.\n+                for location in &self_call_locations {\n+                    db.span_label(location.span, \"recursive call site\");\n+                }\n+                db.help(\"a `loop` may express intention better if this is on purpose\");\n+                db.emit();\n+            },\n         );\n-        db.span_label(sp, \"cannot return without recursing\");\n-        // offer some help to the programmer.\n-        for location in &self_call_locations {\n-            db.span_label(location.span, \"recursive call site\");\n-        }\n-        db.help(\"a `loop` may express intention better if this is on purpose\");\n-        db.emit();\n     }\n }"}, {"sha": "cd935a37f7ddac3fcefc22c4435ba4fe77bb51ea", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -315,10 +315,11 @@ impl<'a> StripUnconfigured<'a> {\n                 validate_attr::check_meta_bad_delim(self.sess, dspan, delim, msg);\n                 match parse_in(self.sess, tts.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n                     Ok(r) => return Some(r),\n-                    Err(mut e) => e\n-                        .help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n+                    Err(mut e) => {\n+                        e.help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n                         .note(CFG_ATTR_NOTE_REF)\n-                        .emit(),\n+                        .emit();\n+                    },\n                 }\n             }\n             _ => self.error_malformed_cfg_attr_missing(attr.span),"}, {"sha": "d41775a143ad6c467e6e69d00d7e481cc137d2bc", "filename": "src/librustc_parse/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Funescape_error_reporting.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -69,7 +69,7 @@ pub(crate) fn emit_unescape_error(\n                     format!(\"\\\"{}\\\"\", lit),\n                     Applicability::MachineApplicable,\n                 )\n-                .emit()\n+                .emit();\n         }\n         EscapeError::EscapeOnlyChar => {\n             let (c, _span) = last_char();"}, {"sha": "905f6bef58e85c155f97215e40ce746cd38fb765", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -149,7 +149,7 @@ impl<'a> Parser<'a> {\n                                    source files. Outer attributes, like `#[test]`, annotate the \\\n                                    item following them.\",\n                             )\n-                            .emit()\n+                            .emit();\n                     }\n                 }\n \n@@ -239,7 +239,7 @@ impl<'a> Parser<'a> {\n                                     (`1u8`, `1.0f32`, etc.), use an unsuffixed version \\\n                                     (`1`, `1.0`, etc.)\",\n                 )\n-                .emit()\n+                .emit();\n         }\n \n         Ok(lit)"}, {"sha": "018aef3c13cee88c87440c87654244c046463ccc", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -1014,7 +1014,7 @@ impl<'a> Parser<'a> {\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 )\n-                .emit()\n+                .emit();\n         }\n     }\n "}, {"sha": "ba97f3feb8021cd6224ad3320801ebfe3f7c0794", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -1407,6 +1407,6 @@ pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &Pa\n     *sess.reached_eof.borrow_mut() |=\n         unclosed_delims.iter().any(|unmatched_delim| unmatched_delim.found_delim.is_none());\n     for unmatched in unclosed_delims.drain(..) {\n-        make_unclosed_delims_error(unmatched, sess).map(|mut e| e.emit());\n+        make_unclosed_delims_error(unmatched, sess).map(|mut e| { e.emit(); });\n     }\n }"}, {"sha": "ec6d4db610285539e59541c45625fb6be30f8848", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -572,7 +572,7 @@ impl<'a> Parser<'a> {\n         self.struct_span_err(span, problem)\n             .span_suggestion(span, suggestion, fix, Applicability::MachineApplicable)\n             .note(\"`mut` may be followed by `variable` and `variable @ pattern`\")\n-            .emit()\n+            .emit();\n     }\n \n     /// Eat any extraneous `mut`s and error + recover if we ate any."}, {"sha": "f6d5da68be3b62c7de758dfcf6abb126c6340092", "filename": "src/librustc_parse/validate_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_parse%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fvalidate_attr.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -27,7 +27,7 @@ pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n         _ => {\n             if let MacArgs::Eq(..) = attr.get_normal_item().args {\n                 // All key-value attributes are restricted to meta-item syntax.\n-                parse_meta(sess, attr).map_err(|mut err| err.emit()).ok();\n+                parse_meta(sess, attr).map_err(|mut err| { err.emit(); }).ok();\n             }\n         }\n     }\n@@ -152,6 +152,6 @@ pub fn check_builtin_attribute(\n                 }\n             }\n         }\n-        Err(mut err) => err.emit(),\n+        Err(mut err) => { err.emit(); },\n     }\n }"}, {"sha": "6bae61d787b9b2b3e8d0402a9db4824a6a6259ad", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -97,9 +97,8 @@ impl CheckAttrVisitor<'tcx> {\n                         UNUSED_ATTRIBUTES,\n                         hir_id,\n                         attr.span,\n-                        \"`#[inline]` is ignored on function prototypes\",\n-                    )\n-                    .emit();\n+                        |lint| lint.build(\"`#[inline]` is ignored on function prototypes\").emit(),\n+                    );\n                 true\n             }\n             // FIXME(#65833): We permit associated consts to have an `#[inline]` attribute with\n@@ -112,18 +111,19 @@ impl CheckAttrVisitor<'tcx> {\n                         UNUSED_ATTRIBUTES,\n                         hir_id,\n                         attr.span,\n-                        \"`#[inline]` is ignored on constants\",\n-                    )\n-                    .warn(\n-                        \"this was previously accepted by the compiler but is \\\n-                       being phased out; it will become a hard error in \\\n-                       a future release!\",\n-                    )\n-                    .note(\n-                        \"see issue #65833 <https://github.com/rust-lang/rust/issues/65833> \\\n-                         for more information\",\n-                    )\n-                    .emit();\n+                        |lint| {\n+                            lint.build(\"`#[inline]` is ignored on constants\")\n+                            .warn(\n+                                \"this was previously accepted by the compiler but is \\\n+                               being phased out; it will become a hard error in \\\n+                               a future release!\",\n+                            )\n+                            .note(\n+                                \"see issue #65833 <https://github.com/rust-lang/rust/issues/65833> \\\n+                                 for more information\",\n+                            )\n+                            .emit();\n+                        });\n                 true\n             }\n             _ => {\n@@ -336,10 +336,12 @@ impl CheckAttrVisitor<'tcx> {\n                     CONFLICTING_REPR_HINTS,\n                     hir_id,\n                     hint_spans.collect::<Vec<Span>>(),\n-                    \"conflicting representation hints\",\n-                )\n-                .code(rustc_errors::error_code!(E0566))\n-                .emit();\n+                    |lint| {\n+                        lint.build(\"conflicting representation hints\")\n+                            .code(rustc_errors::error_code!(E0566))\n+                            .emit();\n+                    }\n+                );\n         }\n     }\n "}, {"sha": "25b8b8fcd444bc0c469dcc79943364771eba1abb", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -554,12 +554,9 @@ impl DeadVisitor<'tcx> {\n         participle: &str,\n     ) {\n         if !name.as_str().starts_with(\"_\") {\n-            self.tcx.lint_hir(\n-                lint::builtin::DEAD_CODE,\n-                id,\n-                span,\n-                &format!(\"{} is never {}: `{}`\", node_type, participle, name),\n-            );\n+            self.tcx.struct_span_lint_hir(lint::builtin::DEAD_CODE, id, span, |lint| {\n+                lint.build(&format!(\"{} is never {}: `{}`\", node_type, participle, name)).emit()\n+            });\n         }\n     }\n }"}, {"sha": "27ad953e4fa6b484e2b3d7f0b9e87927953d24f9", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -1527,39 +1527,41 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                         lint::builtin::UNUSED_VARIABLES,\n                         hir_id,\n                         spans,\n-                        &format!(\"variable `{}` is assigned to, but never used\", name),\n+                        |lint| {\n+                            lint.build(&format!(\"variable `{}` is assigned to, but never used\", name))\n+                                .note(&format!(\"consider using `_{}` instead\", name))\n+                                .emit();\n+                        },\n                     )\n-                    .note(&format!(\"consider using `_{}` instead\", name))\n-                    .emit();\n             } else {\n-                let mut err = self.ir.tcx.struct_span_lint_hir(\n+                self.ir.tcx.struct_span_lint_hir(\n                     lint::builtin::UNUSED_VARIABLES,\n                     hir_id,\n                     spans.clone(),\n-                    &format!(\"unused variable: `{}`\", name),\n+                    |lint| {\n+                        let mut err = lint.build(&format!(\"unused variable: `{}`\", name));\n+                        if self.ir.variable_is_shorthand(var) {\n+                            if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n+                                // Handle `ref` and `ref mut`.\n+                                let spans =\n+                                    spans.iter().map(|_span| (pat.span, format!(\"{}: _\", name))).collect();\n+\n+                                err.multipart_suggestion(\n+                                    \"try ignoring the field\",\n+                                    spans,\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                        } else {\n+                            err.multipart_suggestion(\n+                                \"consider prefixing with an underscore\",\n+                                spans.iter().map(|span| (*span, format!(\"_{}\", name))).collect(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                        err.emit()\n+                    },\n                 );\n-\n-                if self.ir.variable_is_shorthand(var) {\n-                    if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n-                        // Handle `ref` and `ref mut`.\n-                        let spans =\n-                            spans.iter().map(|_span| (pat.span, format!(\"{}: _\", name))).collect();\n-\n-                        err.multipart_suggestion(\n-                            \"try ignoring the field\",\n-                            spans,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                } else {\n-                    err.multipart_suggestion(\n-                        \"consider prefixing with an underscore\",\n-                        spans.iter().map(|span| (*span, format!(\"_{}\", name))).collect(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-\n-                err.emit()\n             }\n         }\n     }\n@@ -1579,21 +1581,25 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                         lint::builtin::UNUSED_ASSIGNMENTS,\n                         hir_id,\n                         spans,\n-                        &format!(\"value passed to `{}` is never read\", name),\n+                        |lint| {\n+                            lint.build(&format!(\"value passed to `{}` is never read\", name))\n+                                .help(\"maybe it is overwritten before being read?\")\n+                                .emit();\n+                        },\n                     )\n-                    .help(\"maybe it is overwritten before being read?\")\n-                    .emit();\n             } else {\n                 self.ir\n                     .tcx\n                     .struct_span_lint_hir(\n                         lint::builtin::UNUSED_ASSIGNMENTS,\n                         hir_id,\n                         spans,\n-                        &format!(\"value assigned to `{}` is never read\", name),\n+                        |lint| {\n+                            lint.build(&format!(\"value assigned to `{}` is never read\", name))\n+                                .help(\"maybe it is overwritten before being read?\")\n+                                .emit();\n+                        },\n                     )\n-                    .help(\"maybe it is overwritten before being read?\")\n-                    .emit();\n             }\n         }\n     }"}, {"sha": "374b7d1cf7a1507c412d613b615f1a74caeb484a", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -604,15 +604,13 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n }\n \n fn unnecessary_stable_feature_lint(tcx: TyCtxt<'_>, span: Span, feature: Symbol, since: Symbol) {\n-    tcx.lint_hir(\n-        lint::builtin::STABLE_FEATURES,\n-        hir::CRATE_HIR_ID,\n-        span,\n-        &format!(\n+    tcx.struct_span_lint_hir(lint::builtin::STABLE_FEATURES, hir::CRATE_HIR_ID, span, |lint| {\n+        lint.build(&format!(\n             \"the feature `{}` has been stable since {} and no longer requires \\\n-                  an attribute to enable\",\n-            feature, since\n-        ),\n+                      an attribute to enable\",\n+                feature, since\n+            )).emit();\n+        }\n     );\n }\n "}, {"sha": "43f92ae69c46b962a688009f009448a9d429f3fd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -1781,17 +1781,21 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n \n     fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         if self.leaks_private_dep(def_id) {\n-            self.tcx.lint_hir(\n+            self.tcx.struct_span_lint_hir(\n                 lint::builtin::EXPORTED_PRIVATE_DEPENDENCIES,\n                 self.item_id,\n                 self.span,\n-                &format!(\n-                    \"{} `{}` from private dependency '{}' in public \\\n-                                        interface\",\n-                    kind,\n-                    descr,\n-                    self.tcx.crate_name(def_id.krate)\n-                ),\n+                |lint| {\n+                    lint.build(\n+                            &format!(\n+                            \"{} `{}` from private dependency '{}' in public \\\n+                                                interface\",\n+                            kind,\n+                            descr,\n+                            self.tcx.crate_name(def_id.krate)\n+                            )\n+                    ).emit()\n+                },\n             );\n         }\n \n@@ -1814,12 +1818,9 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n                 err.emit();\n             } else {\n                 let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n-                self.tcx.lint_hir(\n-                    lint::builtin::PRIVATE_IN_PUBLIC,\n-                    hir_id,\n-                    self.span,\n-                    &format!(\"{} (error {})\", msg, err_code),\n-                );\n+                self.tcx.struct_span_lint_hir(lint::builtin::PRIVATE_IN_PUBLIC, hir_id, self.span, |lint| {\n+                    lint.build(&format!(\"{} (error {})\", msg, err_code)).emit()\n+                });\n             }\n         }\n "}, {"sha": "cef5e025741d78849a935dbef15b4f234eb864ee", "filename": "src/librustc_resolve/lifetimes.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_resolve%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_resolve%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flifetimes.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -1575,22 +1575,23 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             }\n                         }\n \n-                        let mut err = self.tcx.struct_span_lint_hir(\n+                        self.tcx.struct_span_lint_hir(\n                             lint::builtin::SINGLE_USE_LIFETIMES,\n                             id,\n                             span,\n-                            &format!(\"lifetime parameter `{}` only used once\", name),\n+                            |lint| {\n+                                let mut err = lint.build(&format!(\"lifetime parameter `{}` only used once\", name));\n+                                if span == lifetime.span {\n+                                    // spans are the same for in-band lifetime declarations\n+                                    err.span_label(span, \"this lifetime is only used here\");\n+                                } else {\n+                                    err.span_label(span, \"this lifetime...\");\n+                                    err.span_label(lifetime.span, \"...is used only here\");\n+                                }\n+                                self.suggest_eliding_single_use_lifetime(&mut err, def_id, lifetime);\n+                                err.emit();\n+                            },\n                         );\n-\n-                        if span == lifetime.span {\n-                            // spans are the same for in-band lifetime declarations\n-                            err.span_label(span, \"this lifetime is only used here\");\n-                        } else {\n-                            err.span_label(span, \"this lifetime...\");\n-                            err.span_label(lifetime.span, \"...is used only here\");\n-                        }\n-                        self.suggest_eliding_single_use_lifetime(&mut err, def_id, lifetime);\n-                        err.emit();\n                     }\n                 }\n                 Some(LifetimeUseSet::Many) => {\n@@ -1610,26 +1611,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         _ => None,\n                     } {\n                         debug!(\"id ={:?} span = {:?} name = {:?}\", id, span, name);\n-                        let mut err = self.tcx.struct_span_lint_hir(\n+                        self.tcx.struct_span_lint_hir(\n                             lint::builtin::UNUSED_LIFETIMES,\n                             id,\n                             span,\n-                            &format!(\"lifetime parameter `{}` never used\", name),\n-                        );\n-                        if let Some(parent_def_id) = self.tcx.parent(def_id) {\n-                            if let Some(generics) = self.tcx.hir().get_generics(parent_def_id) {\n-                                let unused_lt_span = self.lifetime_deletion_span(name, generics);\n-                                if let Some(span) = unused_lt_span {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"elide the unused lifetime\",\n-                                        String::new(),\n-                                        Applicability::MachineApplicable,\n-                                    );\n+                            |lint| {\n+                                let mut err = lint.build(&format!(\"lifetime parameter `{}` never used\", name));\n+                                if let Some(parent_def_id) = self.tcx.parent(def_id) {\n+                                    if let Some(generics) = self.tcx.hir().get_generics(parent_def_id) {\n+                                        let unused_lt_span = self.lifetime_deletion_span(name, generics);\n+                                        if let Some(span) = unused_lt_span {\n+                                            err.span_suggestion(\n+                                                span,\n+                                                \"elide the unused lifetime\",\n+                                                String::new(),\n+                                                Applicability::MachineApplicable,\n+                                            );\n+                                        }\n+                                    }\n                                 }\n-                            }\n-                        }\n-                        err.emit();\n+                                err.emit();\n+                            },\n+                        );\n                     }\n                 }\n             }"}, {"sha": "c26b47c313023ee38ba41bfc1ce6db26a2279bb1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -331,11 +331,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 } else {\n                     let mut multispan = MultiSpan::from_span(span);\n                     multispan.push_span_label(span_late, note.to_string());\n-                    tcx.lint_hir(\n+                    tcx.struct_span_lint_hir(\n                         lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n                         args.args[0].id(),\n                         multispan,\n-                        msg,\n+                        |lint| lint.build(msg).emit(),\n                     );\n                     reported_late_bound_region_err = Some(false);\n                 }\n@@ -2216,34 +2216,31 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx.check_stability(item.def_id, Some(hir_ref_id), span);\n \n         if let Some(variant_def_id) = variant_resolution {\n-            let mut err = tcx.struct_span_lint_hir(\n-                AMBIGUOUS_ASSOCIATED_ITEMS,\n-                hir_ref_id,\n-                span,\n-                \"ambiguous associated item\",\n-            );\n+            tcx.struct_span_lint_hir(AMBIGUOUS_ASSOCIATED_ITEMS, hir_ref_id, span, |lint| {\n+                let mut err = lint.build(\"ambiguous associated item\");\n+                let mut could_refer_to = |kind: DefKind, def_id, also| {\n+                    let note_msg = format!(\n+                        \"`{}` could{} refer to the {} defined here\",\n+                        assoc_ident,\n+                        also,\n+                        kind.descr(def_id)\n+                    );\n+                    err.span_note(tcx.def_span(def_id), &note_msg);\n+                };\n \n-            let mut could_refer_to = |kind: DefKind, def_id, also| {\n-                let note_msg = format!(\n-                    \"`{}` could{} refer to the {} defined here\",\n-                    assoc_ident,\n-                    also,\n-                    kind.descr(def_id)\n+                could_refer_to(DefKind::Variant, variant_def_id, \"\");\n+                could_refer_to(kind, item.def_id, \" also\");\n+\n+                err.span_suggestion(\n+                    span,\n+                    \"use fully-qualified syntax\",\n+                    format!(\"<{} as {}>::{}\", qself_ty, tcx.item_name(trait_did), assoc_ident),\n+                    Applicability::MachineApplicable,\n                 );\n-                err.span_note(tcx.def_span(def_id), &note_msg);\n-            };\n-            could_refer_to(DefKind::Variant, variant_def_id, \"\");\n-            could_refer_to(kind, item.def_id, \" also\");\n \n-            err.span_suggestion(\n-                span,\n-                \"use fully-qualified syntax\",\n-                format!(\"<{} as {}>::{}\", qself_ty, tcx.item_name(trait_did), assoc_ident),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+                err.emit();\n+            });\n         }\n-\n         Ok((ty, kind, item.def_id))\n     }\n "}, {"sha": "02da2766ec661fb88df7412e1d8e57c7f8520ba1", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -468,23 +468,27 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         } else {\n             (\"\", lint::builtin::TRIVIAL_CASTS)\n         };\n-        let mut err = fcx.tcx.struct_span_lint_hir(\n+        fcx.tcx.struct_span_lint_hir(\n             lint,\n             self.expr.hir_id,\n             self.span,\n-            &format!(\n-                \"trivial {}cast: `{}` as `{}`\",\n-                adjective,\n-                fcx.ty_to_string(t_expr),\n-                fcx.ty_to_string(t_cast)\n-            ),\n+            |err| {\n+                err.build(\n+                    &format!(\n+                        \"trivial {}cast: `{}` as `{}`\",\n+                        adjective,\n+                        fcx.ty_to_string(t_expr),\n+                        fcx.ty_to_string(t_cast)\n+                    )\n+                )\n+                .help(&format!(\n+                    \"cast can be replaced by coercion; this might \\\n+                                   require {}a temporary variable\",\n+                    type_asc_or\n+                ))\n+                .emit();\n+            },\n         );\n-        err.help(&format!(\n-            \"cast can be replaced by coercion; this might \\\n-                           require {}a temporary variable\",\n-            type_asc_or\n-        ));\n-        err.emit();\n     }\n \n     pub fn check(mut self, fcx: &FnCtxt<'a, 'tcx>) {"}, {"sha": "599f7dfe2d41c7d23aa4f28b39798c685eff74ac", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -382,11 +382,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     )\n                     .emit();\n                 } else {\n-                    self.tcx.lint_hir(\n+                    self.tcx.struct_span_lint_hir(\n                         lint::builtin::TYVAR_BEHIND_RAW_POINTER,\n                         scope_expr_id,\n                         span,\n-                        \"type annotations needed\",\n+                        |lint| lint.build(\"type annotations needed\").emit(),\n                     );\n                 }\n             } else {\n@@ -1280,33 +1280,34 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         stable_pick: &Pick<'_>,\n         unstable_candidates: &[(&Candidate<'tcx>, Symbol)],\n     ) {\n-        let mut diag = self.tcx.struct_span_lint_hir(\n+        self.tcx.struct_span_lint_hir(\n             lint::builtin::UNSTABLE_NAME_COLLISIONS,\n             self.fcx.body_id,\n             self.span,\n-            \"a method with this name may be added to the standard library in the future\",\n-        );\n-\n-        // FIXME: This should be a `span_suggestion` instead of `help`\n-        // However `self.span` only\n-        // highlights the method name, so we can't use it. Also consider reusing the code from\n-        // `report_method_error()`.\n-        diag.help(&format!(\n-            \"call with fully qualified syntax `{}(...)` to keep using the current method\",\n-            self.tcx.def_path_str(stable_pick.item.def_id),\n-        ));\n-\n-        if nightly_options::is_nightly_build() {\n-            for (candidate, feature) in unstable_candidates {\n+            |lint| {\n+                let mut diag = lint.build(\"a method with this name may be added to the standard library in the future\");\n+                // FIXME: This should be a `span_suggestion` instead of `help`\n+                // However `self.span` only\n+                // highlights the method name, so we can't use it. Also consider reusing the code from\n+                // `report_method_error()`.\n                 diag.help(&format!(\n-                    \"add `#![feature({})]` to the crate attributes to enable `{}`\",\n-                    feature,\n-                    self.tcx.def_path_str(candidate.item.def_id),\n+                    \"call with fully qualified syntax `{}(...)` to keep using the current method\",\n+                    self.tcx.def_path_str(stable_pick.item.def_id),\n                 ));\n-            }\n-        }\n \n-        diag.emit();\n+                if nightly_options::is_nightly_build() {\n+                    for (candidate, feature) in unstable_candidates {\n+                        diag.help(&format!(\n+                            \"add `#![feature({})]` to the crate attributes to enable `{}`\",\n+                            feature,\n+                            self.tcx.def_path_str(candidate.item.def_id),\n+                        ));\n+                    }\n+                }\n+\n+                diag.emit();\n+            },\n+        );\n     }\n \n     fn select_trait_candidate("}, {"sha": "2fff5106dd1d26f58ac4871fc02ab49aa2d41876", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -2895,15 +2895,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n \n-                let msg = format!(\"unreachable {}\", kind);\n                 self.tcx()\n-                    .struct_span_lint_hir(lint::builtin::UNREACHABLE_CODE, id, span, &msg)\n-                    .span_label(span, &msg)\n-                    .span_label(\n-                        orig_span,\n-                        custom_note.unwrap_or(\"any code following this expression is unreachable\"),\n-                    )\n-                    .emit();\n+                    .struct_span_lint_hir(lint::builtin::UNREACHABLE_CODE, id, span, |lint| {\n+                        let msg = format!(\"unreachable {}\", kind);\n+                        lint.build(&msg)\n+                            .span_label(span, &msg)\n+                            .span_label(\n+                                orig_span,\n+                                custom_note.unwrap_or(\"any code following this expression is unreachable\"),\n+                            )\n+                            .emit();\n+                    })\n             }\n         }\n     }"}, {"sha": "71ce5ce0f02cee8ee7fbd3342e9bc5a828c161c9", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -55,12 +55,14 @@ impl CheckVisitor<'tcx> {\n             return;\n         }\n \n-        let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-            format!(\"unused import: `{}`\", snippet)\n-        } else {\n-            \"unused import\".to_owned()\n-        };\n-        self.tcx.lint_hir(lint::builtin::UNUSED_IMPORTS, id, span, &msg);\n+        self.tcx.struct_span_lint_hir(lint::builtin::UNUSED_IMPORTS, id, span, |lint| {\n+            let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                format!(\"unused import: `{}`\", snippet)\n+            } else {\n+                \"unused import\".to_owned()\n+            };\n+            lint.build(&msg).emit();\n+        });\n     }\n }\n \n@@ -130,14 +132,16 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n                     .map(|attr| attr.span)\n                     .fold(span, |acc, attr_span| acc.to(attr_span));\n \n-                tcx.struct_span_lint_hir(lint, id, span, msg)\n-                    .span_suggestion_short(\n-                        span_with_attrs,\n-                        \"remove it\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                tcx.struct_span_lint_hir(lint, id, span, |lint| {\n+                    lint.build(msg)\n+                        .span_suggestion_short(\n+                            span_with_attrs,\n+                            \"remove it\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+                });\n                 continue;\n             }\n         }\n@@ -170,21 +174,25 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         }\n \n         // Otherwise, we can convert it into a `use` of some kind.\n-        let msg = \"`extern crate` is not idiomatic in the new edition\";\n-        let help = format!(\"convert it to a `{}`\", visibility_qualified(&item.vis, \"use\"));\n         let base_replacement = match extern_crate.orig_name {\n             Some(orig_name) => format!(\"use {} as {};\", orig_name, item.ident.name),\n             None => format!(\"use {};\", item.ident.name),\n         };\n         let replacement = visibility_qualified(&item.vis, base_replacement);\n-        tcx.struct_span_lint_hir(lint, id, extern_crate.span, msg)\n-            .span_suggestion_short(\n-                extern_crate.span,\n-                &help,\n-                replacement,\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        tcx.struct_span_lint_hir(lint, id, extern_crate.span, |lint| {\n+\n+            let msg = \"`extern crate` is not idiomatic in the new edition\";\n+            let help = format!(\"convert it to a `{}`\", visibility_qualified(&item.vis, \"use\"));\n+\n+            lint.build(msg)\n+                .span_suggestion_short(\n+                    extern_crate.span,\n+                    &help,\n+                    replacement,\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        })\n     }\n }\n "}, {"sha": "d26a4cdc5ca77d10e049a9264a366614ce802b22", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -1151,14 +1151,16 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             GenericParamKind::Type { ref default, synthetic, .. } => {\n                 if !allow_defaults && default.is_some() {\n                     if !tcx.features().default_type_parameter_fallback {\n-                        tcx.lint_hir(\n+                        tcx.struct_span_lint_hir(\n                             lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n                             param.hir_id,\n                             param.span,\n-                            &format!(\n+                            |lint| {\n+                                lint.build(&format!(\n                                 \"defaults for type parameters are only allowed in \\\n                                         `struct`, `enum`, `type`, or `trait` definitions.\"\n-                            ),\n+                                )).emit();\n+                            },\n                         );\n                     }\n                 }"}, {"sha": "dfb75c5a98e73e3bb63234551c73c062a33cb607", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 121, "deletions": 117, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -669,39 +669,41 @@ fn build_diagnostic(\n     let attrs = &item.attrs;\n     let sp = span_of_attrs(attrs).unwrap_or(item.source.span());\n \n-    let mut diag = cx.tcx.struct_span_lint_hir(\n+    cx.tcx.struct_span_lint_hir(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n         hir_id,\n         sp,\n-        &format!(\"`[{}]` {}\", path_str, err_msg),\n+        |lint| {\n+            let mut diag = lint.build(&format!(\"`[{}]` {}\", path_str, err_msg));\n+            if let Some(link_range) = link_range {\n+                if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n+                    diag.set_span(sp);\n+                    diag.span_label(sp, short_err_msg);\n+                } else {\n+                    // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+                    //                       ^     ~~~~\n+                    //                       |     link_range\n+                    //                       last_new_line_offset\n+                    let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+                    let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+                    // Print the line containing the `link_range` and manually mark it with '^'s.\n+                    diag.note(&format!(\n+                        \"the link appears in this line:\\n\\n{line}\\n\\\n+                         {indicator: <before$}{indicator:^<found$}\",\n+                        line = line,\n+                        indicator = \"\",\n+                        before = link_range.start - last_new_line_offset,\n+                        found = link_range.len(),\n+                    ));\n+                }\n+            };\n+            if let Some(help_msg) = help_msg {\n+                diag.help(help_msg);\n+            }\n+            diag.emit();\n+        },\n     );\n-    if let Some(link_range) = link_range {\n-        if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n-            diag.set_span(sp);\n-            diag.span_label(sp, short_err_msg);\n-        } else {\n-            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-            //                       ^     ~~~~\n-            //                       |     link_range\n-            //                       last_new_line_offset\n-            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-            // Print the line containing the `link_range` and manually mark it with '^'s.\n-            diag.note(&format!(\n-                \"the link appears in this line:\\n\\n{line}\\n\\\n-                 {indicator: <before$}{indicator:^<found$}\",\n-                line = line,\n-                indicator = \"\",\n-                before = link_range.start - last_new_line_offset,\n-                found = link_range.len(),\n-            ));\n-        }\n-    };\n-    if let Some(help_msg) = help_msg {\n-        diag.help(help_msg);\n-    }\n-    diag.emit();\n }\n \n /// Reports a resolution failure diagnostic.\n@@ -766,105 +768,107 @@ fn ambiguity_error(\n     let attrs = &item.attrs;\n     let sp = span_of_attrs(attrs).unwrap_or(item.source.span());\n \n-    let mut msg = format!(\"`{}` is \", path_str);\n-\n-    let candidates = [TypeNS, ValueNS, MacroNS]\n-        .iter()\n-        .filter_map(|&ns| candidates[ns].map(|res| (res, ns)))\n-        .collect::<Vec<_>>();\n-    match candidates.as_slice() {\n-        [(first_def, _), (second_def, _)] => {\n-            msg += &format!(\n-                \"both {} {} and {} {}\",\n-                first_def.article(),\n-                first_def.descr(),\n-                second_def.article(),\n-                second_def.descr(),\n-            );\n-        }\n-        _ => {\n-            let mut candidates = candidates.iter().peekable();\n-            while let Some((res, _)) = candidates.next() {\n-                if candidates.peek().is_some() {\n-                    msg += &format!(\"{} {}, \", res.article(), res.descr());\n-                } else {\n-                    msg += &format!(\"and {} {}\", res.article(), res.descr());\n-                }\n-            }\n-        }\n-    }\n-\n-    let mut diag = cx.tcx.struct_span_lint_hir(\n+    cx.tcx.struct_span_lint_hir(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n         hir_id,\n         sp,\n-        &msg,\n-    );\n+        |lint| {\n+            let mut msg = format!(\"`{}` is \", path_str);\n \n-    if let Some(link_range) = link_range {\n-        if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n-            diag.set_span(sp);\n-            diag.span_label(sp, \"ambiguous link\");\n-\n-            for (res, ns) in candidates {\n-                let (action, mut suggestion) = match res {\n-                    Res::Def(DefKind::Method, _) | Res::Def(DefKind::Fn, _) => {\n-                        (\"add parentheses\", format!(\"{}()\", path_str))\n-                    }\n-                    Res::Def(DefKind::Macro(..), _) => {\n-                        (\"add an exclamation mark\", format!(\"{}!\", path_str))\n+            let candidates = [TypeNS, ValueNS, MacroNS]\n+                .iter()\n+                .filter_map(|&ns| candidates[ns].map(|res| (res, ns)))\n+                .collect::<Vec<_>>();\n+            match candidates.as_slice() {\n+                [(first_def, _), (second_def, _)] => {\n+                    msg += &format!(\n+                        \"both {} {} and {} {}\",\n+                        first_def.article(),\n+                        first_def.descr(),\n+                        second_def.article(),\n+                        second_def.descr(),\n+                    );\n+                }\n+                _ => {\n+                    let mut candidates = candidates.iter().peekable();\n+                    while let Some((res, _)) = candidates.next() {\n+                        if candidates.peek().is_some() {\n+                            msg += &format!(\"{} {}, \", res.article(), res.descr());\n+                        } else {\n+                            msg += &format!(\"and {} {}\", res.article(), res.descr());\n+                        }\n                     }\n-                    _ => {\n-                        let type_ = match (res, ns) {\n-                            (Res::Def(DefKind::Const, _), _) => \"const\",\n-                            (Res::Def(DefKind::Static, _), _) => \"static\",\n-                            (Res::Def(DefKind::Struct, _), _) => \"struct\",\n-                            (Res::Def(DefKind::Enum, _), _) => \"enum\",\n-                            (Res::Def(DefKind::Union, _), _) => \"union\",\n-                            (Res::Def(DefKind::Trait, _), _) => \"trait\",\n-                            (Res::Def(DefKind::Mod, _), _) => \"module\",\n-                            (_, TypeNS) => \"type\",\n-                            (_, ValueNS) => \"value\",\n-                            (_, MacroNS) => \"macro\",\n+                }\n+            }\n+\n+            let mut diag = lint.build(&msg);\n+\n+            if let Some(link_range) = link_range {\n+                if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n+                    diag.set_span(sp);\n+                    diag.span_label(sp, \"ambiguous link\");\n+\n+                    for (res, ns) in candidates {\n+                        let (action, mut suggestion) = match res {\n+                            Res::Def(DefKind::Method, _) | Res::Def(DefKind::Fn, _) => {\n+                                (\"add parentheses\", format!(\"{}()\", path_str))\n+                            }\n+                            Res::Def(DefKind::Macro(..), _) => {\n+                                (\"add an exclamation mark\", format!(\"{}!\", path_str))\n+                            }\n+                            _ => {\n+                                let type_ = match (res, ns) {\n+                                    (Res::Def(DefKind::Const, _), _) => \"const\",\n+                                    (Res::Def(DefKind::Static, _), _) => \"static\",\n+                                    (Res::Def(DefKind::Struct, _), _) => \"struct\",\n+                                    (Res::Def(DefKind::Enum, _), _) => \"enum\",\n+                                    (Res::Def(DefKind::Union, _), _) => \"union\",\n+                                    (Res::Def(DefKind::Trait, _), _) => \"trait\",\n+                                    (Res::Def(DefKind::Mod, _), _) => \"module\",\n+                                    (_, TypeNS) => \"type\",\n+                                    (_, ValueNS) => \"value\",\n+                                    (_, MacroNS) => \"macro\",\n+                                };\n+\n+                                // FIXME: if this is an implied shortcut link, it's bad style to suggest `@`\n+                                (\"prefix with the item type\", format!(\"{}@{}\", type_, path_str))\n+                            }\n                         };\n \n-                        // FIXME: if this is an implied shortcut link, it's bad style to suggest `@`\n-                        (\"prefix with the item type\", format!(\"{}@{}\", type_, path_str))\n-                    }\n-                };\n+                        if dox.bytes().nth(link_range.start) == Some(b'`') {\n+                            suggestion = format!(\"`{}`\", suggestion);\n+                        }\n \n-                if dox.bytes().nth(link_range.start) == Some(b'`') {\n-                    suggestion = format!(\"`{}`\", suggestion);\n+                        diag.span_suggestion(\n+                            sp,\n+                            &format!(\"to link to the {}, {}\", res.descr(), action),\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                } else {\n+                    // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+                    //                       ^     ~~~~\n+                    //                       |     link_range\n+                    //                       last_new_line_offset\n+                    let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+                    let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+                    // Print the line containing the `link_range` and manually mark it with '^'s.\n+                    diag.note(&format!(\n+                        \"the link appears in this line:\\n\\n{line}\\n\\\n+                         {indicator: <before$}{indicator:^<found$}\",\n+                        line = line,\n+                        indicator = \"\",\n+                        before = link_range.start - last_new_line_offset,\n+                        found = link_range.len(),\n+                    ));\n                 }\n-\n-                diag.span_suggestion(\n-                    sp,\n-                    &format!(\"to link to the {}, {}\", res.descr(), action),\n-                    suggestion,\n-                    Applicability::MaybeIncorrect,\n-                );\n             }\n-        } else {\n-            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-            //                       ^     ~~~~\n-            //                       |     link_range\n-            //                       last_new_line_offset\n-            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-            // Print the line containing the `link_range` and manually mark it with '^'s.\n-            diag.note(&format!(\n-                \"the link appears in this line:\\n\\n{line}\\n\\\n-                 {indicator: <before$}{indicator:^<found$}\",\n-                line = line,\n-                indicator = \"\",\n-                before = link_range.start - last_new_line_offset,\n-                found = link_range.len(),\n-            ));\n-        }\n-    }\n+            diag.emit();\n+        },\n+    );\n \n-    diag.emit();\n }\n \n /// Given an enum variant's res, return the res of its enum and the associated fragment."}, {"sha": "a5213fe8635fd0eed9f4b057d39517ab07262651", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c58ffe874142e1943e2674d7e75989938a7d21b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=7c58ffe874142e1943e2674d7e75989938a7d21b", "patch": "@@ -342,24 +342,22 @@ pub fn look_for_tests<'tcx>(\n \n     if check_missing_code == true && tests.found_tests == 0 {\n         let sp = span_of_attrs(&item.attrs).unwrap_or(item.source.span());\n-        let mut diag = cx.tcx.struct_span_lint_hir(\n+        cx.tcx.struct_span_lint_hir(\n             lint::builtin::MISSING_DOC_CODE_EXAMPLES,\n             hir_id,\n             sp,\n-            \"missing code example in this documentation\",\n+            |lint| lint.build(\"missing code example in this documentation\").emit(),\n         );\n-        diag.emit();\n     } else if check_missing_code == false\n         && tests.found_tests > 0\n         && !cx.renderinfo.borrow().access_levels.is_public(item.def_id)\n     {\n-        let mut diag = cx.tcx.struct_span_lint_hir(\n+        cx.tcx.struct_span_lint_hir(\n             lint::builtin::PRIVATE_DOC_TESTS,\n             hir_id,\n             span_of_attrs(&item.attrs).unwrap_or(item.source.span()),\n-            \"documentation test in private item\",\n+            |lint| lint.build(\"documentation test in private item\").emit(),\n         );\n-        diag.emit();\n     }\n }\n "}]}