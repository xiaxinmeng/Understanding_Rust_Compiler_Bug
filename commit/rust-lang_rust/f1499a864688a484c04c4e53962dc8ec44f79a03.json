{"sha": "f1499a864688a484c04c4e53962dc8ec44f79a03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNDk5YTg2NDY4OGE0ODRjMDRjNGU1Mzk2MmRjOGVjNDRmNzlhMDM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-01T22:51:50Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-03T18:55:19Z"}, "message": "review comments", "tree": {"sha": "fcea78e3550987f7b1bad156ff03661f07e25f98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcea78e3550987f7b1bad156ff03661f07e25f98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1499a864688a484c04c4e53962dc8ec44f79a03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1499a864688a484c04c4e53962dc8ec44f79a03", "html_url": "https://github.com/rust-lang/rust/commit/f1499a864688a484c04c4e53962dc8ec44f79a03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1499a864688a484c04c4e53962dc8ec44f79a03/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfdc369b40da72eb9ff466fab89584c7815d7a80", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfdc369b40da72eb9ff466fab89584c7815d7a80", "html_url": "https://github.com/rust-lang/rust/commit/dfdc369b40da72eb9ff466fab89584c7815d7a80"}], "stats": {"total": 37, "additions": 17, "deletions": 20}, "files": [{"sha": "72206ffb28df028392df22c8ec9d31b8de7bc3e2", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f1499a864688a484c04c4e53962dc8ec44f79a03/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1499a864688a484c04c4e53962dc8ec44f79a03/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=f1499a864688a484c04c4e53962dc8ec44f79a03", "patch": "@@ -570,6 +570,11 @@ impl<'a> Parser<'a> {\n             \"check_no_chained_comparison: {:?} is not comparison\",\n             outer_op,\n         );\n+\n+        let mk_err_expr = |this: &Self, span| {\n+            Ok(Some(this.mk_expr(span, ExprKind::Err, ThinVec::new())))\n+        };\n+\n         match lhs.kind {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // Respan to include both operators.\n@@ -601,7 +606,7 @@ impl<'a> Parser<'a> {\n                             (token::Gt, -1),\n                             (token::BinOp(token::Shr), -2),\n                         ];\n-                        self.consume_tts(1, &modifiers[..], &[]);\n+                        self.consume_tts(1, &modifiers[..]);\n \n                         if !&[\n                             token::OpenDelim(token::Paren),\n@@ -612,7 +617,7 @@ impl<'a> Parser<'a> {\n                             mem::replace(self, snapshot.clone());\n                         }\n                     }\n-                    if token::ModSep == self.token.kind {\n+                    return if token::ModSep == self.token.kind {\n                         // We have some certainty that this was a bad turbofish at this point.\n                         // `foo< bar >::`\n                         suggest(&mut err);\n@@ -628,18 +633,14 @@ impl<'a> Parser<'a> {\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n-                                return Ok(Some(self.mk_expr(\n-                                    lhs.span.to(self.prev_span),\n-                                    ExprKind::Err,\n-                                    ThinVec::new(),\n-                                )));\n+                                mk_err_expr(self, lhs.span.to(self.prev_span))\n                             }\n                             Err(mut expr_err) => {\n                                 expr_err.cancel();\n                                 // Not entirely sure now, but we bubble the error up with the\n                                 // suggestion.\n                                 mem::replace(self, snapshot);\n-                                return Err(err);\n+                                Err(err)\n                             }\n                         }\n                     } else if token::OpenDelim(token::Paren) == self.token.kind {\n@@ -655,9 +656,9 @@ impl<'a> Parser<'a> {\n                             (token::OpenDelim(token::Paren), 1),\n                             (token::CloseDelim(token::Paren), -1),\n                         ];\n-                        self.consume_tts(1, &modifiers[..], &[]);\n+                        self.consume_tts(1, &modifiers[..]);\n \n-                        return if self.token.kind == token::Eof {\n+                        if self.token.kind == token::Eof {\n                             // Not entirely sure now, but we bubble the error up with the\n                             // suggestion.\n                             mem::replace(self, snapshot);\n@@ -668,20 +669,16 @@ impl<'a> Parser<'a> {\n                             // FIXME: actually check that the two expressions in the binop are\n                             // paths and resynthesize new fn call expression instead of using\n                             // `ExprKind::Err` placeholder.\n-                            Ok(Some(self.mk_expr(\n-                                lhs.span.to(self.prev_span),\n-                                ExprKind::Err,\n-                                ThinVec::new(),\n-                            )))\n+                            mk_err_expr(self, lhs.span.to(self.prev_span))\n                         }\n                     } else {\n                         // All we know is that this is `foo < bar >` and *nothing* else. Try to\n                         // be helpful, but don't attempt to recover.\n                         err.help(TURBOFISH);\n                         err.help(\"or use `(...)` if you meant to specify fn arguments\");\n                         // These cases cause too many knock-down errors, bail out (#61329).\n-                    }\n-                    return Err(err);\n+                        Err(err)\n+                    };\n                 }\n                 err.emit();\n             }\n@@ -1467,14 +1464,14 @@ impl<'a> Parser<'a> {\n     fn consume_tts(\n         &mut self,\n         mut acc: i64, // `i64` because malformed code can have more closing delims than opening.\n-        modifier: &[(token::TokenKind, i64)], // Not using `FxHashMap` and `FxHashSet` due to\n-        early_return: &[token::TokenKind],    // `token::TokenKind: !Eq + !Hash`.\n+        // Not using `FxHashMap` due to `token::TokenKind: !Eq + !Hash`.\n+        modifier: &[(token::TokenKind, i64)],\n     ) {\n         while acc > 0 {\n             if let Some((_, val)) = modifier.iter().find(|(t, _)| *t == self.token.kind) {\n                 acc += *val;\n             }\n-            if self.token.kind == token::Eof || early_return.contains(&self.token.kind) {\n+            if self.token.kind == token::Eof {\n                 break;\n             }\n             self.bump();"}]}