{"sha": "4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNTI1OTUwM2NkOGFhYzk5MDVjN2FjNmQ2OGQwYzRjYWFiMWQyOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-23T20:26:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-23T20:26:58Z"}, "message": "auto merge of #19242 : jakub-/rust/roll-up, r=jakub-", "tree": {"sha": "9d93d055fa5aa82480c4b5771aba4cca5efdfc9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d93d055fa5aa82480c4b5771aba4cca5efdfc9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "html_url": "https://github.com/rust-lang/rust/commit/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "220b99b148559e8996a1dbd279e8ca190bf94b2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/220b99b148559e8996a1dbd279e8ca190bf94b2e", "html_url": "https://github.com/rust-lang/rust/commit/220b99b148559e8996a1dbd279e8ca190bf94b2e"}, {"sha": "d6b023a46750d6c2df919908bd0f1460d3d9c8a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b023a46750d6c2df919908bd0f1460d3d9c8a6", "html_url": "https://github.com/rust-lang/rust/commit/d6b023a46750d6c2df919908bd0f1460d3d9c8a6"}], "stats": {"total": 1128, "additions": 578, "deletions": 550}, "files": [{"sha": "5ac398220592da8b58937692a171da9d1390ba3c", "filename": "configure", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/configure", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -546,22 +546,26 @@ CFG_TARGET=$(to_llvm_triple $CFG_TARGET)\n # there's no rpath. This is where the build system itself puts libraries;\n # --libdir is used to configure the installation directory.\n # FIXME: This needs to parameterized over target triples. Do it in platform.mk\n-CFG_LIBDIR_RELATIVE=lib\n if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ]\n then\n     CFG_LIBDIR_RELATIVE=bin\n-    CFG_LIBDIR=\"${CFG_PREFIX}/${CFG_LIBDIR_RELATIVE}\"\n else\n-    valopt libdir \"${CFG_PREFIX}/${CFG_LIBDIR_RELATIVE}\" \"install libraries (ignored on windows platform)\"\n+    CFG_LIBDIR_RELATIVE=lib\n+fi\n \n-    case \"$CFG_LIBDIR\" in\n-\t\"$CFG_PREFIX\"/*) CAT_INC=2;;\n-\t\"$CFG_PREFIX\"*)  CAT_INC=1;;\n-\t*)\n-            err \"libdir must begin with the prefix. Use --prefix to set it accordingly.\";;\n-    esac\n+valopt libdir \"${CFG_PREFIX}/${CFG_LIBDIR_RELATIVE}\" \"install libraries (do not set it on windows platform)\"\n+\n+case \"$CFG_LIBDIR\" in\n+    \"$CFG_PREFIX\"/*) CAT_INC=2;;\n+    \"$CFG_PREFIX\"*)  CAT_INC=1;;\n+    *)\n+        err \"libdir must begin with the prefix. Use --prefix to set it accordingly.\";;\n+esac\n \n-    CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`\n+CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`\n+\n+if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] && [ \"$CFG_LIBDIR_RELATIVE\" != \"bin\" ]; then\n+    err \"libdir on windows should be set to 'bin'\"\n fi\n \n if [ $HELP -eq 1 ]\n@@ -711,11 +715,6 @@ then\n     fi\n     step_msg \"using rustc at: ${CFG_LOCAL_RUST_ROOT} with version: $LRV\"\n     putvar CFG_LOCAL_RUST_ROOT\n-else\n-    if [ ! -z \"$CFG_LOCAL_RUST_ROOT\" ]\n-    then\n-       warn \"Use of --local-rust-root without --enable-local-rust\"\n-    fi\n fi\n \n # Force freebsd to build with clang; gcc doesn't like us there"}, {"sha": "a9a99f132fba4ade0391aeeeb12f2e749da62058", "filename": "mk/main.mk", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -190,11 +190,14 @@ endif\n # Target-and-rule \"utility variables\"\n ######################################################################\n \n-define DEF_X\n+define DEF_FOR_TARGET\n X_$(1) := $(CFG_EXE_SUFFIX_$(1))\n+ifndef CFG_LLVM_TARGET_$(1)\n+CFG_LLVM_TARGET_$(1) := $(1)\n+endif\n endef\n $(foreach target,$(CFG_TARGET), \\\n-  $(eval $(call DEF_X,$(target))))\n+  $(eval $(call DEF_FOR_TARGET,$(target))))\n \n # \"Source\" files we generate in builddir along the way.\n GENERATED :="}, {"sha": "38aec83631605f188374861e871c3c5789119816", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -75,7 +75,7 @@ $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.ll $$(MKFILE_DEPS) \\\n \t@mkdir -p $$(@D)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(LLC_$$(CFG_BUILD)) $$(CFG_LLC_FLAGS_$(1)) \\\n-\t    -filetype=obj -mtriple=$(1) -relocation-model=pic -o $$@ $$<\n+\t    -filetype=obj -mtriple=$$(CFG_LLVM_TARGET_$(1)) -relocation-model=pic -o $$@ $$<\n \n $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.c $$(MKFILE_DEPS)\n \t@mkdir -p $$(@D)"}, {"sha": "460a4a7f445e36419bed34826710950850e9a0a1", "filename": "mk/stage0.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/mk%2Fstage0.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/mk%2Fstage0.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage0.mk?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -22,7 +22,7 @@ ifdef CFG_ENABLE_LOCAL_RUST\n else\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/get-snapshot.py $(CFG_BUILD) $(SNAPSHOT_FILE)\n endif\n-\t$(Q)touch $@\n+\t$(Q)if [ -e \"$@\" ]; then touch \"$@\"; else echo \"ERROR: snapshot $@ not found\"; exit 1; fi\n \n # For other targets, let the host build the target:\n "}, {"sha": "acdf780f105454cf9d77830b61f18dce344b3b75", "filename": "mk/target.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -116,7 +116,7 @@ $$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n \t\t$$(foreach dep,$$(TOOL_DEPS_$(4)), \\\n \t\t    $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep)) \\\n \t\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n-\t\t| $$(TBIN$(1)_T_$(4)_H_$(3))/\n+\t\t| $$(TBIN$(1)_T_$(2)_H_$(3))/\n \t@$$(call E, rustc: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --cfg $(4)\n "}, {"sha": "c795e69a44deabe93ea19e6217008fae18723f11", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::ascii::AsciiExt;\n use std::io::{BufferedReader, File};\n use regex::Regex;\n \n@@ -31,7 +32,7 @@ pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n fn parse_expected(line_num: uint, line: &str, re: &Regex) -> Option<ExpectedError> {\n     re.captures(line).and_then(|caps| {\n         let adjusts = caps.name(\"adjusts\").len();\n-        let kind = caps.name(\"kind\").to_ascii().to_lowercase().into_string();\n+        let kind = caps.name(\"kind\").to_ascii_lower();\n         let msg = caps.name(\"msg\").trim().to_string();\n \n         debug!(\"line={} kind={} msg={}\", line_num, kind, msg);"}, {"sha": "5c3e5e12adbcbc325db0c88f490b67b56e4bdb16", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#[cfg(not(stage0))]\n+\n use self::TargetLocation::*;\n \n use common::Config;\n@@ -990,7 +990,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         let i = s.chars();\n         let c : Vec<char> = i.map( |c| {\n             if c.is_ascii() {\n-                c.to_ascii().to_lowercase().to_char()\n+                c.to_ascii().to_lowercase().as_char()\n             } else {\n                 c\n             }\n@@ -1161,7 +1161,7 @@ fn compile_test_(config: &Config, props: &TestProps,\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args,\n-                                 |a, b| ThisFile(make_exe_name(a, b)), testfile);\n+                                 |a, b| TargetLocation::ThisFile(make_exe_name(a, b)), testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }\n \n@@ -1219,7 +1219,7 @@ fn compose_and_run_compiler(\n                               crate_type,\n                               |a,b| {\n                                   let f = make_lib_name(a, b, testfile);\n-                                  ThisDirectory(f.dir_path())\n+                                  TargetLocation::ThisDirectory(f.dir_path())\n                               },\n                               &abs_ab);\n         let auxres = compose_and_run(config,\n@@ -1296,11 +1296,11 @@ fn make_compile_args(config: &Config,\n         args.push(\"prefer-dynamic\".to_string());\n     }\n     let path = match xform_file {\n-        ThisFile(path) => {\n+        TargetLocation::ThisFile(path) => {\n             args.push(\"-o\".to_string());\n             path\n         }\n-        ThisDirectory(path) => {\n+        TargetLocation::ThisDirectory(path) => {\n             args.push(\"--out-dir\".to_string());\n             path\n         }\n@@ -1672,7 +1672,8 @@ fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args,\n-                                 |a, b| ThisDirectory(output_base_name(a, b).dir_path()),\n+                                 |a, b| TargetLocation::ThisDirectory(\n+                                     output_base_name(a, b).dir_path()),\n                                  testfile);\n     compose_and_run_compiler(config, props, testfile, args, None)\n }"}, {"sha": "632d21d7b9c05deea379d824054e8b81516fa14e", "filename": "src/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![no_start]\n-\n #[cfg(rustdoc)]\n extern crate \"rustdoc\" as this;\n "}, {"sha": "642235ed4e3804eb5d4f81b2b6ee0de98e002cc7", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -43,8 +43,6 @@ def print_struct_val(val, internal_dict):\n     return print_struct_val_starting_from(0, val, internal_dict)\n \n def print_vec_slice_val(val, internal_dict):\n-  output = \"&[\"\n-\n   length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n \n   data_ptr_val = val.GetChildAtIndex(0)\n@@ -56,16 +54,12 @@ def print_vec_slice_val(val, internal_dict):\n \n   start_address = data_ptr_val.GetValueAsUnsigned()\n \n-  for i in range(length):\n+  def render_element(i):\n     address = start_address + i * element_type_size\n-    element_val = val.CreateValueFromAddress( val.GetName() + (\"[%s]\" % i), address, element_type )\n-    output += print_val(element_val, internal_dict)\n-\n-    if i != length - 1:\n-      output += \", \"\n+    element_val = val.CreateValueFromAddress( val.GetName() + (\"[%s]\" % i), address, element_type)\n+    return print_val(element_val, internal_dict)\n \n-  output += \"]\"\n-  return output\n+  return \"&[%s]\" % (', '.join([render_element(i) for i in range(length)]))\n \n def print_struct_val_starting_from(field_start_index, val, internal_dict):\n   '''\n@@ -77,39 +71,33 @@ def print_struct_val_starting_from(field_start_index, val, internal_dict):\n   t = val.GetType()\n   has_field_names = type_has_field_names(t)\n   type_name = extract_type_name(t.GetName())\n-  output = \"\"\n-\n-  if not type_name.startswith(\"(\"):\n-    # this is a tuple, so don't print the type name\n-    output += type_name\n \n   if has_field_names:\n-    output += \" { \\n\"\n+      template = \"%(type_name)s {\\n%(body)s\\n}\"\n+      separator = \", \\n\"\n   else:\n-    output += \"(\"\n+      template = \"%(type_name)s(%(body)s)\"\n+      separator = \", \"\n+\n+  if type_name.startswith(\"(\"):\n+    # this is a tuple, so don't print the type name\n+    type_name = \"\"\n \n   num_children = val.num_children\n \n-  for child_index in range(field_start_index, num_children):\n+  def render_child(child_index):\n+    this = \"\"\n     if has_field_names:\n       field_name = t.GetFieldAtIndex(child_index).GetName()\n-      output += field_name + \": \"\n+      this += field_name + \": \"\n \n     field_val = val.GetChildAtIndex(child_index)\n-    output += print_val(field_val, internal_dict)\n+    return this + print_val(field_val, internal_dict)\n \n-    if child_index != num_children - 1:\n-      output += \", \"\n-\n-    if has_field_names:\n-      output += \"\\n\"\n-\n-  if has_field_names:\n-    output += \"}\"\n-  else:\n-    output += \")\"\n+  body = separator.join([render_child(idx) for idx in range(field_start_index, num_children)])\n \n-  return output\n+  return template % {\"type_name\": type_name,\n+                     \"body\": body}\n \n \n def print_enum_val(val, internal_dict):\n@@ -243,3 +231,5 @@ def is_vec_slice(val):\n \n   type_name = extract_type_name(ty.GetName()).replace(\"&'static\", \"&\").replace(\" \", \"\")\n   return type_name.startswith(\"&[\") and type_name.endswith(\"]\")\n+\n+# vi: sw=2:ts=2"}, {"sha": "4f744b0b2dee1b271a2e99e646871dd65cd92920", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -119,6 +119,16 @@ impl<T> Arc<T> {\n     }\n }\n \n+/// Get the number of weak references to this value.\n+#[inline]\n+#[experimental]\n+pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(atomic::SeqCst) - 1 }\n+\n+/// Get the number of strong references to this value.\n+#[inline]\n+#[experimental]\n+pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(atomic::SeqCst) }\n+\n #[unstable = \"waiting on stability of Clone\"]\n impl<T> Clone for Arc<T> {\n     /// Duplicate an atomically reference counted wrapper.\n@@ -321,7 +331,7 @@ mod tests {\n     use std::sync::atomic;\n     use std::task;\n     use std::vec::Vec;\n-    use super::{Arc, Weak};\n+    use super::{Arc, Weak, weak_count, strong_count};\n     use std::sync::Mutex;\n \n     struct Canary(*mut atomic::AtomicUint);\n@@ -465,6 +475,49 @@ mod tests {\n         drop(arc_weak);\n     }\n \n+    #[test]\n+    fn test_strong_count() {\n+        let a = Arc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        let b = w.upgrade().expect(\"\");\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&a) == 2);\n+        drop(w);\n+        drop(a);\n+        assert!(strong_count(&b) == 1);\n+        let c = b.clone();\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&c) == 2);\n+    }\n+\n+    #[test]\n+    fn test_weak_count() {\n+        let a = Arc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 1);\n+        let x = w.clone();\n+        assert!(weak_count(&a) == 2);\n+        drop(w);\n+        drop(x);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let c = a.clone();\n+        assert!(strong_count(&a) == 2);\n+        assert!(weak_count(&a) == 0);\n+        let d = c.downgrade();\n+        assert!(weak_count(&c) == 1);\n+        assert!(strong_count(&c) == 2);\n+\n+        drop(a);\n+        drop(c);\n+        drop(d);\n+    }\n+\n     #[test]\n     fn show_arc() {\n         let a = Arc::new(5u32);"}, {"sha": "000dda59e3ddaeb3e3e38d095abdda7c8b9794e3", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -15,7 +15,6 @@ use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n-use core::intrinsics;\n use core::kinds::Sized;\n use core::mem;\n use core::option::Option;\n@@ -104,17 +103,14 @@ pub trait BoxAny {\n }\n \n #[stable]\n-impl BoxAny for Box<Any+'static> {\n+impl BoxAny for Box<Any> {\n     #[inline]\n-    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any+'static>> {\n+    fn downcast<T: 'static>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n                 let to: TraitObject =\n-                    *mem::transmute::<&Box<Any>, &TraitObject>(&self);\n-\n-                // Prevent destructor on self being run\n-                intrinsics::forget(self);\n+                    mem::transmute::<Box<Any>, TraitObject>(self);\n \n                 // Extract the data pointer\n                 Ok(mem::transmute(to.data))"}, {"sha": "df84ac9aec93550a467539c36bb312880a5f0de9", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -213,15 +213,24 @@ impl<T> Rc<T> {\n     }\n }\n \n+/// Get the number of weak references to this value.\n+#[inline]\n+#[experimental]\n+pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n+\n+/// Get the number of strong references to this value.\n+#[inline]\n+#[experimental]\n+pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n+\n /// Returns true if the `Rc` currently has unique ownership.\n ///\n /// Unique ownership means that there are no other `Rc` or `Weak` values\n /// that share the same contents.\n #[inline]\n #[experimental]\n pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n-    // note that we hold both a strong and a weak reference\n-    rc.strong() == 1 && rc.weak() == 1\n+    weak_count(rc) == 0 && strong_count(rc) == 1\n }\n \n /// Unwraps the contained value if the `Rc` has unique ownership.\n@@ -489,7 +498,7 @@ impl<T> RcBoxPtr<T> for Weak<T> {\n #[cfg(test)]\n #[allow(experimental)]\n mod tests {\n-    use super::{Rc, Weak};\n+    use super::{Rc, Weak, weak_count, strong_count};\n     use std::cell::RefCell;\n     use std::option::{Option, Some, None};\n     use std::result::{Err, Ok};\n@@ -566,6 +575,40 @@ mod tests {\n         assert!(super::is_unique(&x));\n     }\n \n+    #[test]\n+    fn test_strong_count() {\n+        let a = Rc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        let b = w.upgrade().expect(\"upgrade of live rc failed\");\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&a) == 2);\n+        drop(w);\n+        drop(a);\n+        assert!(strong_count(&b) == 1);\n+        let c = b.clone();\n+        assert!(strong_count(&b) == 2);\n+        assert!(strong_count(&c) == 2);\n+    }\n+\n+    #[test]\n+    fn test_weak_count() {\n+        let a = Rc::new(0u32);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let w = a.downgrade();\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 1);\n+        drop(w);\n+        assert!(strong_count(&a) == 1);\n+        assert!(weak_count(&a) == 0);\n+        let c = a.clone();\n+        assert!(strong_count(&a) == 2);\n+        assert!(weak_count(&a) == 0);\n+        drop(c);\n+    }\n+\n     #[test]\n     fn try_unwrap() {\n         let x = Rc::new(3u);"}, {"sha": "963b88eda560986a9f2116b6568e838c688154e5", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -68,15 +68,15 @@\n //!     // dist[node] = current shortest distance from `start` to `node`\n //!     let mut dist = Vec::from_elem(adj_list.len(), uint::MAX);\n //!\n-//!     let mut pq = BinaryHeap::new();\n+//!     let mut heap = BinaryHeap::new();\n //!\n //!     // We're at `start`, with a zero cost\n //!     dist[start] = 0u;\n-//!     pq.push(State { cost: 0u, position: start });\n+//!     heap.push(State { cost: 0u, position: start });\n //!\n //!     // Examine the frontier with lower cost nodes first (min-heap)\n //!     loop {\n-//!         let State { cost, position } = match pq.pop() {\n+//!         let State { cost, position } = match heap.pop() {\n //!             None => break, // empty\n //!             Some(s) => s\n //!         };\n@@ -94,7 +94,7 @@\n //!\n //!             // If so, add it to the frontier and continue\n //!             if next.cost < dist[next.position] {\n-//!                 pq.push(next);\n+//!                 heap.push(next);\n //!                 // Relaxation, we have now found a better way\n //!                 dist[next.position] = next.cost;\n //!             }\n@@ -184,7 +184,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::new();\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::new();\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap{data: vec!(),} }\n@@ -198,7 +198,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n@@ -212,7 +212,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n+    /// let heap = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n     /// ```\n     pub fn from_vec(xs: Vec<T>) -> BinaryHeap<T> {\n         let mut q = BinaryHeap{data: xs,};\n@@ -231,10 +231,10 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n+    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n-    /// for x in pq.iter() {\n+    /// for x in heap.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n@@ -250,13 +250,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// assert_eq!(pq.top(), None);\n+    /// let mut heap = BinaryHeap::new();\n+    /// assert_eq!(heap.top(), None);\n     ///\n-    /// pq.push(1i);\n-    /// pq.push(5i);\n-    /// pq.push(2i);\n-    /// assert_eq!(pq.top(), Some(&5i));\n+    /// heap.push(1i);\n+    /// heap.push(5i);\n+    /// heap.push(2i);\n+    /// assert_eq!(heap.top(), Some(&5i));\n     ///\n     /// ```\n     pub fn top<'a>(&'a self) -> Option<&'a T> {\n@@ -270,8 +270,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let heap: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n@@ -292,9 +292,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n-    /// pq.reserve_exact(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let mut heap: BinaryHeap<uint> = BinaryHeap::new();\n+    /// heap.reserve_exact(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve_exact(&mut self, additional: uint) { self.data.reserve_exact(additional) }\n@@ -311,9 +311,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n-    /// pq.reserve(100u);\n-    /// assert!(pq.capacity() >= 100u);\n+    /// let mut heap: BinaryHeap<uint> = BinaryHeap::new();\n+    /// heap.reserve(100u);\n+    /// assert!(heap.capacity() >= 100u);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve(&mut self, additional: uint) {\n@@ -334,11 +334,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::from_vec(vec![1i, 3]);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1i, 3]);\n     ///\n-    /// assert_eq!(pq.pop(), Some(3i));\n-    /// assert_eq!(pq.pop(), Some(1i));\n-    /// assert_eq!(pq.pop(), None);\n+    /// assert_eq!(heap.pop(), Some(3i));\n+    /// assert_eq!(heap.pop(), Some(1i));\n+    /// assert_eq!(heap.pop(), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop(&mut self) -> Option<T> {\n@@ -361,13 +361,13 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// pq.push(3i);\n-    /// pq.push(5i);\n-    /// pq.push(1i);\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.push(3i);\n+    /// heap.push(5i);\n+    /// heap.push(1i);\n     ///\n-    /// assert_eq!(pq.len(), 3);\n-    /// assert_eq!(pq.top(), Some(&5i));\n+    /// assert_eq!(heap.len(), 3);\n+    /// assert_eq!(heap.top(), Some(&5i));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, item: T) {\n@@ -384,14 +384,14 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n-    /// pq.push(1i);\n-    /// pq.push(5i);\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.push(1i);\n+    /// heap.push(5i);\n     ///\n-    /// assert_eq!(pq.push_pop(3i), 5);\n-    /// assert_eq!(pq.push_pop(9i), 9);\n-    /// assert_eq!(pq.len(), 2);\n-    /// assert_eq!(pq.top(), Some(&3i));\n+    /// assert_eq!(heap.push_pop(3i), 5);\n+    /// assert_eq!(heap.push_pop(9i), 9);\n+    /// assert_eq!(heap.len(), 2);\n+    /// assert_eq!(heap.top(), Some(&3i));\n     /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         if !self.is_empty() && *self.top().unwrap() > item {\n@@ -410,12 +410,12 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::new();\n+    /// let mut heap = BinaryHeap::new();\n     ///\n-    /// assert_eq!(pq.replace(1i), None);\n-    /// assert_eq!(pq.replace(3i), Some(1i));\n-    /// assert_eq!(pq.len(), 1);\n-    /// assert_eq!(pq.top(), Some(&3i));\n+    /// assert_eq!(heap.replace(1i), None);\n+    /// assert_eq!(heap.replace(3i), Some(1i));\n+    /// assert_eq!(heap.len(), 1);\n+    /// assert_eq!(heap.top(), Some(&3i));\n     /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n@@ -436,8 +436,8 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let pq = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n-    /// let vec = pq.into_vec();\n+    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// let vec = heap.into_vec();\n     ///\n     /// // Will print in some order\n     /// for x in vec.iter() {\n@@ -454,11 +454,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut pq = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n-    /// pq.push(6);\n-    /// pq.push(3);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n+    /// heap.push(6);\n+    /// heap.push(3);\n     ///\n-    /// let vec = pq.into_sorted_vec();\n+    /// let vec = heap.into_sorted_vec();\n     /// assert_eq!(vec, vec![1i, 2, 3, 4, 5, 6, 7]);\n     /// ```\n     pub fn into_sorted_vec(self) -> Vec<T> {\n@@ -578,9 +578,9 @@ mod tests {\n     fn test_iterator() {\n         let data = vec!(5i, 9, 3);\n         let iterout = [9i, 5, 3];\n-        let pq = BinaryHeap::from_vec(data);\n+        let heap = BinaryHeap::from_vec(data);\n         let mut i = 0;\n-        for el in pq.iter() {\n+        for el in heap.iter() {\n             assert_eq!(*el, iterout[i]);\n             i += 1;\n         }"}, {"sha": "ab69a3ad8b883c0dde0a744c16030c3a8e6592fb", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -251,15 +251,15 @@ impl Default for SipHasher {\n \n /// Hashes a value using the SipHash algorithm.\n #[inline]\n-pub fn hash<T: Hash<SipState>>(value: &T) -> u64 {\n+pub fn hash<Sized? T: Hash<SipState>>(value: &T) -> u64 {\n     let mut state = SipState::new();\n     value.hash(&mut state);\n     state.result()\n }\n \n /// Hashes a value with the SipHash algorithm with the provided keys.\n #[inline]\n-pub fn hash_with_keys<T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n+pub fn hash_with_keys<Sized? T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n     let mut state = SipState::new_with_keys(k0, k1);\n     value.hash(&mut state);\n     state.result()"}, {"sha": "ebd6fab34e9b519e1a1799e311c9c53a17ca1b81", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -71,7 +71,7 @@\n \n #![stable]\n \n-use mem::{transmute, transmute_copy};\n+use mem::{transmute};\n use option::{Option, Some, None};\n use raw::TraitObject;\n use intrinsics::TypeId;\n@@ -134,7 +134,7 @@ impl<'a> AnyRefExt<'a> for &'a Any {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n-                let to: TraitObject = transmute_copy(&self);\n+                let to: TraitObject = transmute(self);\n \n                 // Extract the data pointer\n                 Some(transmute(to.data))\n@@ -162,7 +162,7 @@ impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n         if self.is::<T>() {\n             unsafe {\n                 // Get the raw representation of the trait object\n-                let to: TraitObject = transmute_copy(&self);\n+                let to: TraitObject = transmute(self);\n \n                 // Extract the data pointer\n                 Some(transmute(to.data))"}, {"sha": "6e77b0a7c7936489ba13ad3e4ed999d00448c8cc", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -179,7 +179,7 @@ pub trait Octal for Sized? {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `t` character\n+/// Format trait for the `b` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n pub trait Binary for Sized? {\n     /// Formats the value using the given formatter."}, {"sha": "3240b4207a1c59d19ccc66edff5f02ae95245638", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -57,7 +57,7 @@\n //!\n //! Pattern matching on `Result`s is clear and straightforward for\n //! simple cases, but `Result` comes with some convenience methods\n-//! that make working it more succinct.\n+//! that make working with it more succinct.\n //!\n //! ```\n //! let good_result: Result<int, int> = Ok(10);"}, {"sha": "9fe7a21243f186a8819045cc806353bbe5da856e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -37,22 +37,18 @@ use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n use lint::{Context, LintPass, LintArray};\n \n-use std::cmp;\n+use std::{cmp, slice};\n use std::collections::hash_map::{Occupied, Vacant};\n use std::num::SignedInt;\n-use std::slice;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n-use syntax::abi;\n-use syntax::ast_map;\n-use syntax::ast_util::is_shift_binop;\n-use syntax::attr::AttrMetaMethods;\n-use syntax::attr;\n+use syntax::{abi, ast, ast_map};\n+use syntax::ast_util::{mod, is_shift_binop};\n+use syntax::attr::{mod, AttrMetaMethods};\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token;\n-use syntax::{ast, ast_util, visit};\n use syntax::ast::{TyI, TyU, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n use syntax::ptr::P;\n-use syntax::visit::Visitor;\n+use syntax::visit::{mod, Visitor};\n \n declare_lint!(WHILE_TRUE, Warn,\n               \"suggest using `loop { }` instead of `while true { }`\")\n@@ -1112,8 +1108,8 @@ impl UnusedParens {\n                 }\n                 ast::ExprUnary(_, ref x) |\n                 ast::ExprCast(ref x, _) |\n-                ast::ExprField(ref x, _, _) |\n-                ast::ExprTupField(ref x, _, _) |\n+                ast::ExprField(ref x, _) |\n+                ast::ExprTupField(ref x, _) |\n                 ast::ExprIndex(ref x, _) => {\n                     // &X { y: 1 }, X { y: 1 }.y\n                     contains_exterior_struct_lit(&**x)"}, {"sha": "61c56cf9ecc51f69af58dd58890367995a42c6c2", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -475,8 +475,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             ast::ExprCast(ref e, _) |\n             ast::ExprUnary(_, ref e) |\n             ast::ExprParen(ref e) |\n-            ast::ExprField(ref e, _, _) |\n-            ast::ExprTupField(ref e, _, _) => {\n+            ast::ExprField(ref e, _) |\n+            ast::ExprTupField(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }\n "}, {"sha": "98ac7e413ca7c63213e2a1c9aae7c7f035a03ad3", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -15,19 +15,16 @@ pub use self::const_val::*;\n pub use self::constness::*;\n \n use metadata::csearch;\n-use middle::astencode;\n-use middle::def;\n+use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n use middle::ty::{mod, Ty};\n-use middle::typeck::astconv;\n-use middle::typeck::check;\n-use util::nodemap::{DefIdMap};\n+use middle::typeck::{astconv, check};\n+use util::nodemap::DefIdMap;\n \n use syntax::ast::{mod, Expr};\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n+use syntax::visit::{mod, Visitor};\n use syntax::{ast_map, ast_util, codemap};\n \n use std::rc::Rc;\n@@ -234,9 +231,9 @@ impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ast::ExprField(ref base, _, _) => self.classify(&**base),\n+            ast::ExprField(ref base, _) => self.classify(&**base),\n \n-            ast::ExprTupField(ref base, _, _) => self.classify(&**base),\n+            ast::ExprTupField(ref base, _) => self.classify(&**base),\n \n             ast::ExprIndex(ref base, ref idx) =>\n                 join(self.classify(&**base), self.classify(&**idx)),"}, {"sha": "cf2e9a65859cd93a2c3839516c0b0f692c7c5554", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -12,20 +12,14 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n-use middle::def;\n-use middle::pat_util;\n-use middle::privacy;\n-use middle::ty;\n-use middle::typeck;\n+use middle::{def, pat_util, privacy, ty, typeck};\n use lint;\n use util::nodemap::NodeSet;\n \n use std::collections::HashSet;\n-use syntax::ast;\n-use syntax::ast_map;\n+use syntax::{ast, ast_map, codemap};\n use syntax::ast_util::{local_def, is_local, PostExpansionMethod};\n use syntax::attr::{mod, AttrMetaMethods};\n-use syntax::codemap;\n use syntax::visit::{mod, Visitor};\n \n // Any local node that may call something in its body block should be\n@@ -277,10 +271,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             ast::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id, expr.span);\n             }\n-            ast::ExprField(ref lhs, ref ident, _) => {\n+            ast::ExprField(ref lhs, ref ident) => {\n                 self.handle_field_access(&**lhs, &ident.node);\n             }\n-            ast::ExprTupField(ref lhs, idx, _) => {\n+            ast::ExprTupField(ref lhs, idx) => {\n                 self.handle_tup_field_access(&**lhs, idx.node);\n             }\n             _ => ()"}, {"sha": "fa0f59f68604918db8bcec542bebc63e4cb40792", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -20,11 +20,9 @@ pub use self::ConsumeMode::*;\n pub use self::MoveReason::*;\n use self::OverloadedCallType::*;\n \n+use middle::{def, region, pat_util};\n use middle::mem_categorization as mc;\n-use middle::def;\n use middle::mem_categorization::Typer;\n-use middle::region;\n-use middle::pat_util;\n use middle::ty::{mod, Ty};\n use middle::typeck::{MethodCall, MethodObject, MethodTraitObject};\n use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n@@ -331,11 +329,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 }\n             }\n \n-            ast::ExprField(ref base, _, _) => {         // base.f\n+            ast::ExprField(ref base, _) => {         // base.f\n                 self.select_from_expr(&**base);\n             }\n \n-            ast::ExprTupField(ref base, _, _) => {         // base.<n>\n+            ast::ExprTupField(ref base, _) => {         // base.<n>\n                 self.select_from_expr(&**base);\n             }\n "}, {"sha": "15d9e87a9d5a34678475a3ef7dd5c4de7ee78aeb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -113,24 +113,19 @@ use self::VarKind::*;\n \n use middle::def::*;\n use middle::mem_categorization::Typer;\n-use middle::pat_util;\n-use middle::typeck;\n-use middle::ty;\n+use middle::{pat_util, typeck, ty};\n use lint;\n use util::nodemap::NodeMap;\n \n-use std::fmt;\n-use std::io;\n+use std::{fmt, io, uint};\n use std::rc::Rc;\n-use std::uint;\n use syntax::ast::{mod, NodeId, Expr};\n use syntax::codemap::{BytePos, original_sp, Span};\n-use syntax::parse::token::special_idents;\n-use syntax::parse::token;\n+use syntax::parse::token::{mod, special_idents};\n use syntax::print::pprust::{expr_to_string, block_to_string};\n use syntax::ptr::P;\n-use syntax::{visit, ast_util};\n-use syntax::visit::{Visitor, FnKind};\n+use syntax::ast_util;\n+use syntax::visit::{mod, Visitor, FnKind};\n \n /// For use with `propagate_through_loop`.\n enum LoopKind<'a> {\n@@ -967,11 +962,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n-          ast::ExprField(ref e, _, _) => {\n+          ast::ExprField(ref e, _) => {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ast::ExprTupField(ref e, _, _) => {\n+          ast::ExprTupField(ref e, _) => {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n@@ -1295,8 +1290,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         match expr.node {\n             ast::ExprPath(_) => succ,\n-            ast::ExprField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n-            ast::ExprTupField(ref e, _, _) => self.propagate_through_expr(&**e, succ),\n+            ast::ExprField(ref e, _) => self.propagate_through_expr(&**e, succ),\n+            ast::ExprTupField(ref e, _) => self.propagate_through_expr(&**e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }"}, {"sha": "e9986e47e4a211d9494f5e57e35647a916ee0581", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -477,7 +477,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             Ok(self.cat_deref(expr, base_cmt, 0, false))\n           }\n \n-          ast::ExprField(ref base, f_name, _) => {\n+          ast::ExprField(ref base, f_name) => {\n             let base_cmt = if_ok!(self.cat_expr(&**base));\n             debug!(\"cat_expr(cat_field): id={} expr={} base={}\",\n                    expr.id,\n@@ -486,7 +486,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n           }\n \n-          ast::ExprTupField(ref base, idx, _) => {\n+          ast::ExprTupField(ref base, idx) => {\n             let base_cmt = if_ok!(self.cat_expr(&**base));\n             Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n           }"}, {"sha": "66c782877f9cac248b4a81b6049a84030d21d94e", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -17,20 +17,17 @@ use self::FieldName::*;\n use std::mem::replace;\n \n use metadata::csearch;\n-use middle::def;\n-use middle::resolve;\n+use middle::{def, resolve};\n use middle::ty::{mod, Ty};\n use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use util::nodemap::{NodeMap, NodeSet};\n \n-use syntax::ast;\n-use syntax::ast_map;\n+use syntax::{ast, ast_map};\n use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::parse::token;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n+use syntax::visit::{mod, Visitor};\n \n type Context<'a, 'tcx> = (&'a MethodMap<'tcx>, &'a resolve::ExportMap2);\n \n@@ -836,20 +833,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n-            ast::ExprField(ref base, ident, _) => {\n-                match ty::expr_ty_adjusted(self.tcx, &**base).sty {\n-                    ty::ty_struct(id, _) => {\n-                        self.check_field(expr.span, id, NamedField(ident.node));\n-                    }\n-                    _ => {}\n+            ast::ExprField(ref base, ident) => {\n+                if let ty::ty_struct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n+                    self.check_field(expr.span, id, NamedField(ident.node));\n                 }\n             }\n-            ast::ExprTupField(ref base, idx, _) => {\n-                match ty::expr_ty_adjusted(self.tcx, &**base).sty {\n-                    ty::ty_struct(id, _) => {\n-                        self.check_field(expr.span, id, UnnamedField(idx.node));\n-                    }\n-                    _ => {}\n+            ast::ExprTupField(ref base, idx) => {\n+                if let ty::ty_struct(id, _) = ty::expr_ty_adjusted(self.tcx, &**base).sty {\n+                    self.check_field(expr.span, id, UnnamedField(idx.node));\n                 }\n             }\n             ast::ExprMethodCall(ident, _, _) => {"}, {"sha": "c5511f995bc689397e7d5e5c74e51f02e0ae58de", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -22,8 +22,7 @@ Most of the documentation on regions can be found in\n \n \n use session::Session;\n-use middle::ty::{FreeRegion};\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, FreeRegion};\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n use util::common::can_reach;\n \n@@ -33,7 +32,6 @@ use syntax::codemap::Span;\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::{stmt_id};\n-use syntax::ptr::P;\n use syntax::visit::{Visitor, FnKind};\n \n /// CodeExtent represents a statically-describable extent that can be\n@@ -824,11 +822,10 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n             match expr.node {\n                 ast::ExprAddrOf(_, ref subexpr) |\n                 ast::ExprUnary(ast::UnDeref, ref subexpr) |\n-                ast::ExprField(ref subexpr, _, _) |\n-                ast::ExprTupField(ref subexpr, _, _) |\n+                ast::ExprField(ref subexpr, _) |\n+                ast::ExprTupField(ref subexpr, _) |\n                 ast::ExprIndex(ref subexpr, _) |\n                 ast::ExprParen(ref subexpr) => {\n-                    let subexpr: &'a P<Expr> = subexpr; // FIXME(#11586)\n                     expr = &**subexpr;\n                 }\n                 _ => {"}, {"sha": "68a31c83ea4842dd3d65cbf760bdf9a1677df519", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -71,17 +71,13 @@ use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast;\n-use syntax::ast_util::{PostExpansionMethod, local_def, walk_pat};\n-use syntax::ast_util;\n+use syntax::ast_util::{mod, PostExpansionMethod, local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n-use syntax::parse::token::special_names;\n-use syntax::parse::token::special_idents;\n-use syntax::parse::token;\n+use syntax::parse::token::{mod, special_names, special_idents};\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n use syntax::owned_slice::OwnedSlice;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n+use syntax::visit::{mod, Visitor};\n \n use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::{Occupied, Vacant};\n@@ -5959,7 +5955,7 @@ impl<'a> Resolver<'a> {\n \n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n         match expr.node {\n-            ExprField(_, ident, _) => {\n+            ExprField(_, ident) => {\n                 // FIXME(#6890): Even though you can't treat a method like a\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting"}, {"sha": "47b296e46cd301b1baf65c21d363ef6574d2714d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -2638,11 +2638,6 @@ impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n }\n \n impl fmt::Show for TypeContents {\n-    #[cfg(stage0)]\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeContents({:t})\", self.bits)\n-    }\n-    #[cfg(not(stage0))]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"TypeContents({:b})\", self.bits)\n     }"}, {"sha": "5bcd96e66efc2da544ba00a13ba8f09b09c858d9", "filename": "src/librustc/middle/typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -10,16 +10,13 @@\n \n use super::probe;\n \n-use middle::subst;\n-use middle::subst::Subst;\n+use middle::subst::{mod, Subst};\n use middle::traits;\n use middle::ty::{mod, Ty};\n-use middle::typeck::check;\n-use middle::typeck::check::{FnCtxt, NoPreference, PreferMutLvalue};\n+use middle::typeck::check::{mod, FnCtxt, NoPreference, PreferMutLvalue};\n use middle::typeck::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n                      MethodParam, MethodStatic, MethodTraitObject, MethodTypeParam};\n-use middle::typeck::infer;\n-use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::{mod, InferCtxt};\n use middle::ty_fold::HigherRankedFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -510,8 +507,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             let last = exprs[exprs.len() - 1];\n             match last.node {\n                 ast::ExprParen(ref expr) |\n-                ast::ExprField(ref expr, _, _) |\n-                ast::ExprTupField(ref expr, _, _) |\n+                ast::ExprField(ref expr, _) |\n+                ast::ExprTupField(ref expr, _) |\n                 ast::ExprSlice(ref expr, _, _, _) |\n                 ast::ExprIndex(ref expr, _) |\n                 ast::ExprUnary(ast::UnDeref, ref expr) => exprs.push(&**expr),"}, {"sha": "d38c5bc0ca9cf0c737f9619fad63f411feff7e6e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 37, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -83,62 +83,41 @@ use self::IsBinopAssignment::*;\n use self::TupleArgumentsFlag::*;\n \n use session::Session;\n-use middle::const_eval;\n-use middle::def;\n+use middle::{const_eval, def, traits};\n use middle::lang_items::IteratorItem;\n-use middle::mem_categorization::McResult;\n-use middle::mem_categorization;\n-use middle::pat_util::pat_id_map;\n-use middle::pat_util;\n+use middle::mem_categorization::{mod, McResult};\n+use middle::pat_util::{mod, pat_id_map};\n use middle::region::CodeExtent;\n-use middle::subst;\n-use middle::subst::{Subst, Substs, VecPerParamSpace, ParamSpace};\n-use middle::traits;\n-use middle::ty::{FnSig, VariantInfo};\n-use middle::ty::{Polytype};\n+use middle::subst::{mod, Subst, Substs, VecPerParamSpace, ParamSpace};\n+use middle::ty::{FnSig, VariantInfo, Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{mod, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::TypeFolder;\n-use middle::typeck::astconv::AstConv;\n-use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n-use middle::typeck::astconv;\n+use middle::typeck::astconv::{mod, ast_region_to_region, ast_ty_to_ty, AstConv};\n use middle::typeck::check::_match::pat_ctxt;\n-use middle::typeck::CrateCtxt;\n-use middle::typeck::infer;\n use middle::typeck::rscope::RegionScope;\n-use middle::typeck::{lookup_def_ccx};\n-use middle::typeck::no_params;\n-use middle::typeck::{require_same_types};\n-use middle::typeck::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n-use middle::typeck::{TypeAndSubsts};\n-use middle::typeck;\n+use middle::typeck::{mod, CrateCtxt, infer, lookup_def_ccx, no_params, require_same_types};\n+use middle::typeck::{MethodCall, MethodCallee, MethodMap, ObjectCastMap, TypeAndSubsts};\n use middle::lang_items::TypeIdLangItem;\n use lint;\n use util::common::{block_query, indenter, loop_query};\n-use util::ppaux;\n-use util::ppaux::{UserString, Repr};\n+use util::ppaux::{mod, UserString, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n use std::collections::hash_map::{Occupied, Vacant};\n use std::mem::replace;\n use std::rc::Rc;\n-use syntax::abi;\n-use syntax::ast::{ProvidedMethod, RequiredMethod, TypeTraitItem};\n-use syntax::ast;\n-use syntax::ast_util::{local_def, PostExpansionMethod};\n-use syntax::ast_util;\n-use syntax::attr;\n-use syntax::codemap::Span;\n-use syntax::codemap;\n+use syntax::{mod, abi, attr};\n+use syntax::ast::{mod, ProvidedMethod, RequiredMethod, TypeTraitItem};\n+use syntax::ast_util::{mod, local_def, PostExpansionMethod};\n+use syntax::codemap::{mod, Span};\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n-use syntax;\n+use syntax::visit::{mod, Visitor};\n \n pub mod _match;\n pub mod vtable;\n@@ -4405,10 +4384,10 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         fcx.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n       }\n-      ast::ExprField(ref base, ref field, _) => {\n+      ast::ExprField(ref base, ref field) => {\n         check_field(fcx, expr, lvalue_pref, &**base, field);\n       }\n-      ast::ExprTupField(ref base, idx, _) => {\n+      ast::ExprTupField(ref base, idx) => {\n         check_tup_field(fcx, expr, lvalue_pref, &**base, idx);\n       }\n       ast::ExprIndex(ref base, ref idx) => {"}, {"sha": "549d636e8cb564ac0ee977841f368e38faf2e7b9", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -278,8 +278,8 @@ mod svh_visitor {\n             ExprBlock(..)            => SawExprBlock,\n             ExprAssign(..)           => SawExprAssign,\n             ExprAssignOp(op, _, _)   => SawExprAssignOp(op),\n-            ExprField(_, id, _)      => SawExprField(content(id.node)),\n-            ExprTupField(_, id, _)   => SawExprTupField(id.node),\n+            ExprField(_, id)         => SawExprField(content(id.node)),\n+            ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n             ExprSlice(..)            => SawExprSlice,\n             ExprPath(..)             => SawExprPath,"}, {"sha": "ba6292f8975da45f487bfffee3870c37d8f528fd", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -30,34 +30,26 @@\n use driver::driver::CrateAnalysis;\n use session::Session;\n \n-use middle::def;\n+use middle::{def, typeck};\n use middle::ty::{mod, Ty};\n-use middle::typeck;\n \n use std::cell::Cell;\n-use std::io;\n-use std::io::File;\n-use std::io::fs;\n+use std::io::{mod, File, fs};\n use std::os;\n \n-use syntax::ast;\n-use syntax::ast_util;\n-use syntax::ast_util::PostExpansionMethod;\n-use syntax::ast::{NodeId,DefId};\n+use syntax::ast_util::{mod, PostExpansionMethod};\n+use syntax::ast::{mod, NodeId, DefId};\n use syntax::ast_map::NodeItem;\n use syntax::attr;\n use syntax::codemap::*;\n-use syntax::parse::token;\n-use syntax::parse::token::{get_ident,keywords};\n+use syntax::parse::token::{mod, get_ident, keywords};\n use syntax::owned_slice::OwnedSlice;\n-use syntax::visit;\n-use syntax::visit::Visitor;\n+use syntax::visit::{mod, Visitor};\n use syntax::print::pprust::{path_to_string,ty_to_string};\n use syntax::ptr::P;\n \n use self::span_utils::SpanUtils;\n-use self::recorder::Recorder;\n-use self::recorder::FmtStrs;\n+use self::recorder::{Recorder, FmtStrs};\n \n use util::ppaux;\n \n@@ -568,13 +560,15 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             Some(node_id) => node_id,\n             None => -1,\n         };\n+        let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n         self.fmt.struct_str(item.span,\n                             sub_span,\n                             item.id,\n                             ctor_id,\n                             qualname.as_slice(),\n-                            self.cur_scope);\n+                            self.cur_scope,\n+                            val.as_slice());\n \n         // fields\n         for field in def.fields.iter() {\n@@ -589,21 +583,23 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     item: &ast::Item,\n                     enum_definition: &ast::EnumDef,\n                     ty_params: &ast::Generics) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let enum_name = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let val = self.span.snippet(item.span);\n         match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n                                                 Some(sub_span),\n                                                 item.id,\n-                                                qualname.as_slice(),\n-                                                self.cur_scope),\n+                                                enum_name.as_slice(),\n+                                                self.cur_scope,\n+                                                val.as_slice()),\n             None => self.sess.span_bug(item.span,\n                                        format!(\"Could not find subspan for enum {}\",\n-                                               qualname).as_slice()),\n+                                               enum_name).as_slice()),\n         }\n         for variant in enum_definition.variants.iter() {\n             let name = get_ident(variant.node.name);\n             let name = name.get();\n-            let mut qualname = qualname.clone();\n+            let mut qualname = enum_name.clone();\n             qualname.push_str(\"::\");\n             qualname.push_str(name);\n             let val = self.span.snippet(variant.span);\n@@ -615,6 +611,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                variant.node.id,\n                                                name,\n                                                qualname.as_slice(),\n+                                               enum_name.as_slice(),\n                                                val.as_slice(),\n                                                item.id);\n                     for arg in args.iter() {\n@@ -632,18 +629,19 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         variant.node.id,\n                         ctor_id,\n                         qualname.as_slice(),\n+                        enum_name.as_slice(),\n                         val.as_slice(),\n                         item.id);\n \n                     for field in struct_def.fields.iter() {\n-                        self.process_struct_field_def(field, qualname.as_slice(), variant.node.id);\n+                        self.process_struct_field_def(field, enum_name.as_slice(), variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n                 }\n             }\n         }\n \n-        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n+        self.process_generic_params(ty_params, item.span, enum_name.as_slice(), item.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -698,13 +696,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                      trait_refs: &OwnedSlice<ast::TyParamBound>,\n                      methods: &Vec<ast::TraitItem>) {\n         let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n-\n+        let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         self.fmt.trait_str(item.span,\n                            sub_span,\n                            item.id,\n                            qualname.as_slice(),\n-                           self.cur_scope);\n+                           self.cur_scope,\n+                           val.as_slice());\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n@@ -1293,7 +1292,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n-            ast::ExprField(ref sub_ex, ident, _) => {\n+            ast::ExprField(ref sub_ex, ident) => {\n                 if generated_code(sub_ex.span) {\n                     return\n                 }\n@@ -1319,7 +1318,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                             \"Expected struct type, but not ty_struct\"),\n                 }\n             },\n-            ast::ExprTupField(ref sub_ex, idx, _) => {\n+            ast::ExprTupField(ref sub_ex, idx) => {\n                 if generated_code(sub_ex.span) {\n                     return\n                 }"}, {"sha": "8eda199af3bb59f355ebed0a7a761c81a70b0284", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -106,15 +106,19 @@ impl<'a> FmtStrs<'a> {\n             Variable => (\"variable\",\n                          vec!(\"id\",\"name\",\"qualname\",\"value\",\"type\",\"scopeid\"),\n                          true, true),\n-            Enum => (\"enum\", vec!(\"id\",\"qualname\",\"scopeid\"), true, true),\n-            Variant => (\"variant\", vec!(\"id\",\"name\",\"qualname\",\"value\",\"scopeid\"), true, true),\n+            Enum => (\"enum\", vec!(\"id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n+            Variant => (\"variant\",\n+                        vec!(\"id\",\"name\",\"qualname\",\"type\",\"value\",\"scopeid\"),\n+                        true, true),\n             VariantStruct => (\"variant_struct\",\n-                              vec!(\"id\",\"ctor_id\",\"qualname\",\"value\",\"scopeid\"), true, true),\n-            Function => (\"function\", vec!(\"id\",\"qualname\",\"declid\",\"declidcrate\",\"scopeid\"),\n+                              vec!(\"id\",\"ctor_id\",\"qualname\",\"type\",\"value\",\"scopeid\"),\n+                              true, true),\n+            Function => (\"function\",\n+                         vec!(\"id\",\"qualname\",\"declid\",\"declidcrate\",\"scopeid\"),\n                          true, true),\n             MethodDecl => (\"method_decl\", vec!(\"id\",\"qualname\",\"scopeid\"), true, true),\n-            Struct => (\"struct\", vec!(\"id\",\"ctor_id\",\"qualname\",\"scopeid\"), true, true),\n-            Trait => (\"trait\", vec!(\"id\",\"qualname\",\"scopeid\"), true, true),\n+            Struct => (\"struct\", vec!(\"id\",\"ctor_id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n+            Trait => (\"trait\", vec!(\"id\",\"qualname\",\"scopeid\",\"value\"), true, true),\n             Impl => (\"impl\", vec!(\"id\",\"refid\",\"refidcrate\",\"scopeid\"), true, true),\n             Module => (\"module\", vec!(\"id\",\"qualname\",\"scopeid\",\"def_file\"), true, false),\n             UseAlias => (\"use_alias\",\n@@ -128,7 +132,7 @@ impl<'a> FmtStrs<'a> {\n                             true, false),\n             MethodCall => (\"method_call\",\n                            vec!(\"refid\",\"refidcrate\",\"declid\",\"declidcrate\",\"scopeid\"),\n-                            true, true),\n+                           true, true),\n             Typedef => (\"typedef\", vec!(\"id\",\"qualname\",\"value\"), true, true),\n             ExternalCrate => (\"external_crate\", vec!(\"name\",\"crate\",\"file_name\"), false, false),\n             Crate => (\"crate\", vec!(\"name\"), true, false),\n@@ -140,7 +144,7 @@ impl<'a> FmtStrs<'a> {\n                         true, true),\n             StructRef => (\"struct_ref\",\n                           vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"),\n-                           true, true),\n+                          true, true),\n             FnRef => (\"fn_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true)\n         }\n     }\n@@ -157,6 +161,7 @@ impl<'a> FmtStrs<'a> {\n         }\n \n         let values = values.iter().map(|s| {\n+            // Never take more than 1020 chars\n             if s.len() > 1020 {\n                 s.as_slice().slice_to(1020)\n             } else {\n@@ -323,11 +328,12 @@ impl<'a> FmtStrs<'a> {\n                     sub_span: Option<Span>,\n                     id: NodeId,\n                     name: &str,\n-                    scope_id: NodeId) {\n+                    scope_id: NodeId,\n+                    value: &str) {\n         self.check_and_record(Enum,\n                               span,\n                               sub_span,\n-                              svec!(id, name, scope_id));\n+                              svec!(id, name, scope_id, value));\n     }\n \n     pub fn tuple_variant_str(&mut self,\n@@ -336,12 +342,13 @@ impl<'a> FmtStrs<'a> {\n                              id: NodeId,\n                              name: &str,\n                              qualname: &str,\n+                             typ: &str,\n                              val: &str,\n                              scope_id: NodeId) {\n         self.check_and_record(Variant,\n                               span,\n                               sub_span,\n-                              svec!(id, name, qualname, val, scope_id));\n+                              svec!(id, name, qualname, typ, val, scope_id));\n     }\n \n     pub fn struct_variant_str(&mut self,\n@@ -350,12 +357,13 @@ impl<'a> FmtStrs<'a> {\n                               id: NodeId,\n                               ctor_id: NodeId,\n                               name: &str,\n+                              typ: &str,\n                               val: &str,\n                               scope_id: NodeId) {\n         self.check_and_record(VariantStruct,\n                               span,\n                               sub_span,\n-                              svec!(id, ctor_id, name, val, scope_id));\n+                              svec!(id, ctor_id, name, typ, val, scope_id));\n     }\n \n     pub fn fn_str(&mut self,\n@@ -405,23 +413,25 @@ impl<'a> FmtStrs<'a> {\n                       id: NodeId,\n                       ctor_id: NodeId,\n                       name: &str,\n-                      scope_id: NodeId) {\n+                      scope_id: NodeId,\n+                      value: &str) {\n         self.check_and_record(Struct,\n                               span,\n                               sub_span,\n-                              svec!(id, ctor_id, name, scope_id));\n+                              svec!(id, ctor_id, name, scope_id, value));\n     }\n \n     pub fn trait_str(&mut self,\n                      span: Span,\n                      sub_span: Option<Span>,\n                      id: NodeId,\n                      name: &str,\n-                     scope_id: NodeId) {\n+                     scope_id: NodeId,\n+                     value: &str) {\n         self.check_and_record(Trait,\n                               span,\n                               sub_span,\n-                              svec!(id, name, scope_id));\n+                              svec!(id, name, scope_id, value));\n     }\n \n     pub fn impl_str(&mut self,"}, {"sha": "aa549c99d025c31ea2f6a47293d25f1208f90fc1", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -13,22 +13,14 @@ use back::abi;\n use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True, False};\n use llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n-    RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n+           RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n use metadata::csearch;\n-use middle::const_eval;\n-use middle::def;\n-use trans::adt;\n-use trans::base;\n-use trans::base::push_ctxt;\n-use trans::closure;\n+use middle::{const_eval, def};\n+use trans::{adt, closure, consts, debuginfo, expr, inline, machine};\n+use trans::base::{mod, push_ctxt};\n use trans::common::*;\n-use trans::consts;\n-use trans::expr;\n-use trans::inline;\n-use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n-use trans::debuginfo;\n use middle::ty::{mod, Ty};\n use util::ppaux::{Repr, ty_to_string};\n \n@@ -418,15 +410,15 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               }\n             }\n           }\n-          ast::ExprField(ref base, field, _) => {\n+          ast::ExprField(ref base, field) => {\n               let (bv, bt) = const_expr(cx, &**base);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n                   adt::const_get_field(cx, &*brepr, bv, discr, ix)\n               })\n           }\n-          ast::ExprTupField(ref base, idx, _) => {\n+          ast::ExprTupField(ref base, idx) => {\n               let (bv, bt) = const_expr(cx, &**base);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {"}, {"sha": "a3472e194cf588ee0c524b944f8a3c5f3e56d035", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -197,13 +197,10 @@ use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::*;\n use metadata::csearch;\n use middle::subst::{mod, Subst, Substs};\n-use trans::adt;\n+use trans::{mod, adt, machine, type_of};\n use trans::common::*;\n-use trans::machine;\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n-use trans::type_of;\n use trans::type_::Type;\n-use trans;\n use middle::ty::{mod, Ty};\n use middle::pat_util;\n use session::config::{mod, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n@@ -219,8 +216,7 @@ use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap, ast_util, ast_map};\n use syntax::ast_util::PostExpansionMethod;\n-use syntax::parse::token;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{mod, special_idents};\n \n static DW_LANG_RUST: c_uint = 0x9000;\n \n@@ -3456,8 +3452,8 @@ fn populate_scope_map(cx: &CrateContext,\n \n             ast::ExprCast(ref sub_exp, _)     |\n             ast::ExprAddrOf(_, ref sub_exp)  |\n-            ast::ExprField(ref sub_exp, _, _) |\n-            ast::ExprTupField(ref sub_exp, _, _) |\n+            ast::ExprField(ref sub_exp, _) |\n+            ast::ExprTupField(ref sub_exp, _) |\n             ast::ExprParen(ref sub_exp) =>\n                 walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n "}, {"sha": "482b318e37202605d0b657560791be663bd803fa", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 32, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -38,47 +38,26 @@ pub use self::Dest::*;\n use self::lazy_binop_ty::*;\n \n use back::abi;\n-use llvm;\n-use llvm::{ValueRef};\n+use llvm::{mod, ValueRef};\n use middle::def;\n use middle::mem_categorization::Typer;\n-use middle::subst;\n-use middle::subst::Subst;\n-use trans::_match;\n-use trans::adt;\n-use trans::asm;\n+use middle::subst::{mod, Subst};\n+use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n+use trans::{debuginfo, glue, machine, meth, inline, tvec, type_of};\n use trans::base::*;\n-use trans::base;\n use trans::build::*;\n-use trans::callee;\n-use trans::cleanup;\n-use trans::cleanup::CleanupMethods;\n-use trans::closure;\n+use trans::cleanup::{mod, CleanupMethods};\n use trans::common::*;\n-use trans::consts;\n-use trans::controlflow;\n use trans::datum::*;\n-use trans::debuginfo;\n-use trans::glue;\n-use trans::machine;\n-use trans::meth;\n-use trans::inline;\n-use trans::tvec;\n-use trans::type_of;\n-use middle::ty::{struct_fields, tup_fields};\n-use middle::ty::{AdjustDerefRef, AdjustAddEnv, AutoUnsafe};\n-use middle::ty::{AutoPtr};\n-use middle::ty::{mod, Ty};\n-use middle::typeck;\n-use middle::typeck::MethodCall;\n+use middle::ty::{mod, struct_fields, tup_fields};\n+use middle::ty::{AdjustDerefRef, AdjustAddEnv, AutoUnsafe, AutoPtr, Ty};\n+use middle::typeck::{mod, MethodCall};\n use util::common::indenter;\n use util::ppaux::Repr;\n use trans::machine::{llsize_of, llsize_of_alloc};\n use trans::type_::Type;\n \n-use syntax::ast;\n-use syntax::ast_util;\n-use syntax::codemap;\n+use syntax::{ast, ast_util, codemap};\n use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n use std::rc::Rc;\n@@ -599,10 +578,10 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprPath(_) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n-        ast::ExprField(ref base, ident, _) => {\n+        ast::ExprField(ref base, ident) => {\n             trans_rec_field(bcx, &**base, ident.node)\n         }\n-        ast::ExprTupField(ref base, idx, _) => {\n+        ast::ExprTupField(ref base, idx) => {\n             trans_rec_tup_field(bcx, &**base, idx.node)\n         }\n         ast::ExprIndex(ref base, ref idx) => {"}, {"sha": "f9c509cce1461179afdb232231f1a8824cf1bfcb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -1923,7 +1923,7 @@ impl Clean<ViewItemInner> for ast::ViewItem_ {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub enum ViewPath {\n-    // use str = source;\n+    // use source as str;\n     SimpleImport(String, ImportSource),\n     // use source::*;\n     GlobImport(ImportSource),"}, {"sha": "b040a4bfd2a09f4076562c4e96e179c48711f5a7", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -18,7 +18,6 @@ use rustc_trans::back::link;\n use syntax::{ast, ast_map, codemap, diagnostic};\n \n use std::cell::RefCell;\n-use std::os;\n use std::collections::{HashMap, HashSet};\n use arena::TypedArena;\n \n@@ -89,7 +88,7 @@ pub fn run_core(libs: Vec<Path>, cfgs: Vec<String>, externs: Externs,\n     let warning_lint = lint::builtin::WARNINGS.name_lower();\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n+        maybe_sysroot: None,\n         addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(config::CrateTypeRlib),\n         lint_opts: vec!((warning_lint, lint::Allow)),"}, {"sha": "07b58e1b66c2aa22275a3606116921327c14f43e", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -28,6 +28,7 @@\n #![allow(non_camel_case_types)]\n \n use libc;\n+use std::ascii::AsciiExt;\n use std::cell::{RefCell, Cell};\n use std::fmt;\n use std::slice;\n@@ -223,12 +224,8 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         // Transform the contents of the header into a hyphenated string\n-        let id = s.as_slice().words().map(|s| {\n-            match s.to_ascii_opt() {\n-                Some(s) => s.to_lowercase().into_string(),\n-                None => s.to_string()\n-            }\n-        }).collect::<Vec<String>>().connect(\"-\");\n+        let id = s.as_slice().words().map(|s| s.to_ascii_lower())\n+            .collect::<Vec<String>>().connect(\"-\");\n \n         // This is a terrible hack working around how hoedown gives us rendered\n         // html for text rather than the raw text."}, {"sha": "9e3c336a7a06cc3f5c4619fb22c3efaf0bbf4f64", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 42, "deletions": 62, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -1428,6 +1428,8 @@ impl<'a> fmt::Show for Item<'a> {\n             clean::TypedefItem(ref t) => item_typedef(fmt, self.item, t),\n             clean::MacroItem(ref m) => item_macro(fmt, self.item, m),\n             clean::PrimitiveItem(ref p) => item_primitive(fmt, self.item, p),\n+            clean::StaticItem(ref i) => item_static(fmt, self.item, i),\n+            clean::ConstantItem(ref c) => item_constant(fmt, self.item, c),\n             _ => Ok(())\n         }\n     }\n@@ -1453,13 +1455,6 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n     return s\n }\n \n-fn blank<'a>(s: Option<&'a str>) -> &'a str {\n-    match s {\n-        Some(s) => s,\n-        None => \"\"\n-    }\n-}\n-\n fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     match s {\n         Some(s) => match s.find_str(\"\\n\\n\") {\n@@ -1570,66 +1565,18 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                         id = short, name = name));\n         }\n \n-        struct Initializer<'a>(&'a str, Item<'a>);\n-        impl<'a> fmt::Show for Initializer<'a> {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                let Initializer(s, item) = *self;\n-                if s.len() == 0 { return Ok(()); }\n-                try!(write!(f, \"<code> = </code>\"));\n-                if s.contains(\"\\n\") {\n-                    match item.href() {\n-                        Some(url) => {\n-                            write!(f, \"<a href='{}'>[definition]</a>\",\n-                                   url)\n-                        }\n-                        None => Ok(()),\n-                    }\n-                } else {\n-                    write!(f, \"<code>{}</code>\", s.as_slice())\n-                }\n-            }\n-        }\n-\n         match myitem.inner {\n-            clean::StaticItem(ref s) | clean::ForeignStaticItem(ref s) => {\n-                try!(write!(w, \"\n-                    <tr>\n-                        <td>{}<code>{}static {}{}: {}</code>{}</td>\n-                        <td class='docblock'>{}&nbsp;</td>\n-                    </tr>\n-                \",\n-                ConciseStability(&myitem.stability),\n-                VisSpace(myitem.visibility),\n-                MutableSpace(s.mutability),\n-                *myitem.name.as_ref().unwrap(),\n-                s.type_,\n-                Initializer(s.expr.as_slice(), Item { cx: cx, item: myitem }),\n-                Markdown(blank(myitem.doc_value()))));\n-            }\n-            clean::ConstantItem(ref s) => {\n-                try!(write!(w, \"\n-                    <tr>\n-                        <td>{}<code>{}const {}: {}</code>{}</td>\n-                        <td class='docblock'>{}&nbsp;</td>\n-                    </tr>\n-                \",\n-                ConciseStability(&myitem.stability),\n-                VisSpace(myitem.visibility),\n-                *myitem.name.as_ref().unwrap(),\n-                s.type_,\n-                Initializer(s.expr.as_slice(), Item { cx: cx, item: myitem }),\n-                Markdown(blank(myitem.doc_value()))));\n-            }\n-\n             clean::ViewItemItem(ref item) => {\n                 match item.inner {\n                     clean::ExternCrate(ref name, ref src, _) => {\n-                        try!(write!(w, \"<tr><td><code>extern crate {}\",\n-                                      name.as_slice()));\n                         match *src {\n-                            Some(ref src) => try!(write!(w, \" = \\\"{}\\\"\",\n-                                                           src.as_slice())),\n-                            None => {}\n+                            Some(ref src) =>\n+                                try!(write!(w, \"<tr><td><code>extern crate \\\"{}\\\" as {}\",\n+                                            src.as_slice(),\n+                                            name.as_slice())),\n+                            None =>\n+                                try!(write!(w, \"<tr><td><code>extern crate {}\",\n+                                            name.as_slice())),\n                         }\n                         try!(write!(w, \";</code></td></tr>\"));\n                     }\n@@ -1665,6 +1612,39 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     write!(w, \"</table>\")\n }\n \n+struct Initializer<'a>(&'a str);\n+impl<'a> fmt::Show for Initializer<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let Initializer(s) = *self;\n+        if s.len() == 0 { return Ok(()); }\n+        try!(write!(f, \"<code> = </code>\"));\n+        write!(f, \"<code>{}</code>\", s.as_slice())\n+    }\n+}\n+\n+fn item_constant(w: &mut fmt::Formatter, it: &clean::Item,\n+                 c: &clean::Constant) -> fmt::Result {\n+    try!(write!(w, \"<pre class='rust const'>{vis}const \\\n+                    {name}: {typ}{init}</pre>\",\n+           vis = VisSpace(it.visibility),\n+           name = it.name.as_ref().unwrap().as_slice(),\n+           typ = c.type_,\n+           init = Initializer(c.expr.as_slice())));\n+    document(w, it)\n+}\n+\n+fn item_static(w: &mut fmt::Formatter, it: &clean::Item,\n+               s: &clean::Static) -> fmt::Result {\n+    try!(write!(w, \"<pre class='rust static'>{vis}static {mutability}\\\n+                    {name}: {typ}{init}</pre>\",\n+           vis = VisSpace(it.visibility),\n+           mutability = MutableSpace(s.mutability),\n+           name = it.name.as_ref().unwrap().as_slice(),\n+           typ = s.type_,\n+           init = Initializer(s.expr.as_slice())));\n+    document(w, it)\n+}\n+\n fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust fn'>{vis}{fn_style}fn \\"}, {"sha": "4c019550395474c2ff6fa0d8066c4869655a6166", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -234,6 +234,7 @@ nav.sub {\n .content .highlighted.struct { background-color: #e7b1a0; }\n .content .highlighted.fn { background-color: #c6afb3; }\n .content .highlighted.method { background-color: #c6afb3; }\n+.content .highlighted.tymethod { background-color: #c6afb3; }\n .content .highlighted.ffi { background-color: #c6afb3; }\n \n .docblock.short.nowrap {\n@@ -348,6 +349,7 @@ p a:hover { text-decoration: underline; }\n .content span.struct, .content a.struct, .block a.current.struct { color: #e53700; }\n .content span.fn, .content a.fn, .block a.current.fn { color: #8c6067; }\n .content span.method, .content a.method, .block a.current.method { color: #8c6067; }\n+.content span.tymethod, .content a.tymethod, .block a.current.tymethod { color: #8c6067; }\n .content span.ffi, .content a.ffi, .block a.current.ffi { color: #8c6067; }\n .content .fnname { color: #8c6067; }\n "}, {"sha": "9754e673d3849787eca7e815e2bdcccff2979a63", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -12,7 +12,8 @@\n \n //! Operations on ASCII strings and characters\n \n-#![experimental]\n+#![unstable = \"unsure about placement and naming\"]\n+#![allow(deprecated)]\n \n use core::kinds::Sized;\n use fmt;\n@@ -31,30 +32,47 @@ pub struct Ascii { chr: u8 }\n impl Ascii {\n     /// Converts an ascii character into a `u8`.\n     #[inline]\n-    pub fn to_byte(self) -> u8 {\n+    #[unstable = \"recently renamed\"]\n+    pub fn as_byte(&self) -> u8 {\n         self.chr\n     }\n \n+    /// Deprecated: use `as_byte` isntead.\n+    #[deprecated = \"use as_byte\"]\n+    pub fn to_byte(self) -> u8 {\n+        self.as_byte()\n+    }\n+\n     /// Converts an ascii character into a `char`.\n     #[inline]\n-    pub fn to_char(self) -> char {\n+    #[unstable = \"recently renamed\"]\n+    pub fn as_char(&self) -> char {\n         self.chr as char\n     }\n \n+    /// Deprecated: use `as_char` isntead.\n+    #[deprecated = \"use as_char\"]\n+    pub fn to_char(self) -> char {\n+        self.as_char()\n+    }\n+\n     /// Convert to lowercase.\n     #[inline]\n-    pub fn to_lowercase(self) -> Ascii {\n+    #[stable]\n+    pub fn to_lowercase(&self) -> Ascii {\n         Ascii{chr: ASCII_LOWER_MAP[self.chr as uint]}\n     }\n \n     /// Convert to uppercase.\n     #[inline]\n-    pub fn to_uppercase(self) -> Ascii {\n+    #[stable]\n+    pub fn to_uppercase(&self) -> Ascii {\n         Ascii{chr: ASCII_UPPER_MAP[self.chr as uint]}\n     }\n \n     /// Compares two ascii characters of equality, ignoring case.\n     #[inline]\n+    #[deprecated = \"normalize with to_lowercase\"]\n     pub fn eq_ignore_case(self, other: Ascii) -> bool {\n         ASCII_LOWER_MAP[self.chr as uint] == ASCII_LOWER_MAP[other.chr as uint]\n     }\n@@ -63,66 +81,77 @@ impl Ascii {\n \n     /// Check if the character is a letter (a-z, A-Z)\n     #[inline]\n+    #[stable]\n     pub fn is_alphabetic(&self) -> bool {\n         (self.chr >= 0x41 && self.chr <= 0x5A) || (self.chr >= 0x61 && self.chr <= 0x7A)\n     }\n \n     /// Check if the character is a number (0-9)\n     #[inline]\n+    #[unstable = \"may be renamed\"]\n     pub fn is_digit(&self) -> bool {\n         self.chr >= 0x30 && self.chr <= 0x39\n     }\n \n     /// Check if the character is a letter or number\n     #[inline]\n+    #[stable]\n     pub fn is_alphanumeric(&self) -> bool {\n         self.is_alphabetic() || self.is_digit()\n     }\n \n     /// Check if the character is a space or horizontal tab\n     #[inline]\n+    #[experimental = \"likely to be removed\"]\n     pub fn is_blank(&self) -> bool {\n         self.chr == b' ' || self.chr == b'\\t'\n     }\n \n     /// Check if the character is a control character\n     #[inline]\n+    #[stable]\n     pub fn is_control(&self) -> bool {\n         self.chr < 0x20 || self.chr == 0x7F\n     }\n \n     /// Checks if the character is printable (except space)\n     #[inline]\n+    #[experimental = \"unsure about naming, or whether this is needed\"]\n     pub fn is_graph(&self) -> bool {\n         (self.chr - 0x21) < 0x5E\n     }\n \n     /// Checks if the character is printable (including space)\n     #[inline]\n+    #[unstable = \"unsure about naming\"]\n     pub fn is_print(&self) -> bool {\n         (self.chr - 0x20) < 0x5F\n     }\n \n-    /// Checks if the character is lowercase\n+    /// Checks if the character is alphabetic and lowercase\n     #[inline]\n+    #[stable]\n     pub fn is_lowercase(&self) -> bool {\n         (self.chr - b'a') < 26\n     }\n \n-    /// Checks if the character is uppercase\n+    /// Checks if the character is alphabetic and uppercase\n     #[inline]\n+    #[stable]\n     pub fn is_uppercase(&self) -> bool {\n         (self.chr - b'A') < 26\n     }\n \n     /// Checks if the character is punctuation\n     #[inline]\n+    #[stable]\n     pub fn is_punctuation(&self) -> bool {\n         self.is_graph() && !self.is_alphanumeric()\n     }\n \n     /// Checks if the character is a valid hex digit\n     #[inline]\n+    #[stable]\n     pub fn is_hex(&self) -> bool {\n         self.is_digit() || ((self.chr | 32u8) - b'a') < 6\n     }\n@@ -135,6 +164,7 @@ impl<'a> fmt::Show for Ascii {\n }\n \n /// Trait for converting into an ascii type.\n+#[experimental = \"may be replaced by generic conversion traits\"]\n pub trait AsciiCast<T> {\n     /// Convert to an ascii type, panic on non-ASCII input.\n     #[inline]\n@@ -160,6 +190,7 @@ pub trait AsciiCast<T> {\n     fn is_ascii(&self) -> bool;\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl<'a> AsciiCast<&'a[Ascii]> for &'a [u8] {\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> &'a[Ascii] {\n@@ -175,6 +206,7 @@ impl<'a> AsciiCast<&'a[Ascii]> for &'a [u8] {\n     }\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl<'a> AsciiCast<&'a [Ascii]> for &'a str {\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> &'a [Ascii] {\n@@ -187,6 +219,7 @@ impl<'a> AsciiCast<&'a [Ascii]> for &'a str {\n     }\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl AsciiCast<Ascii> for u8 {\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> Ascii {\n@@ -199,6 +232,7 @@ impl AsciiCast<Ascii> for u8 {\n     }\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl AsciiCast<Ascii> for char {\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> Ascii {\n@@ -212,6 +246,7 @@ impl AsciiCast<Ascii> for char {\n }\n \n /// Trait for copyless casting to an ascii vector.\n+#[experimental = \"may be replaced by generic conversion traits\"]\n pub trait OwnedAsciiCast {\n     /// Check if convertible to ascii\n     fn is_ascii(&self) -> bool;\n@@ -241,6 +276,7 @@ pub trait OwnedAsciiCast {\n     unsafe fn into_ascii_nocheck(self) -> Vec<Ascii>;\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl OwnedAsciiCast for String {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -253,6 +289,7 @@ impl OwnedAsciiCast for String {\n     }\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl OwnedAsciiCast for Vec<u8> {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -274,6 +311,7 @@ impl OwnedAsciiCast for Vec<u8> {\n \n /// Trait for converting an ascii type to a string. Needed to convert\n /// `&[Ascii]` to `&str`.\n+#[experimental = \"may be replaced by generic conversion traits\"]\n pub trait AsciiStr for Sized? {\n     /// Convert to a string.\n     fn as_str_ascii<'a>(&'a self) -> &'a str;\n@@ -283,19 +321,23 @@ pub trait AsciiStr for Sized? {\n     fn to_lower(&self) -> Vec<Ascii>;\n \n     /// Convert to vector representing a lower cased ascii string.\n+    #[deprecated = \"use iterators instead\"]\n     fn to_lowercase(&self) -> Vec<Ascii>;\n \n     /// Deprecated: use `to_uppercase`\n     #[deprecated=\"renamed `to_uppercase`\"]\n     fn to_upper(&self) -> Vec<Ascii>;\n \n     /// Convert to vector representing a upper cased ascii string.\n+    #[deprecated = \"use iterators instead\"]\n     fn to_uppercase(&self) -> Vec<Ascii>;\n \n     /// Compares two Ascii strings ignoring case.\n+    #[deprecated = \"use iterators instead\"]\n     fn eq_ignore_case(&self, other: &[Ascii]) -> bool;\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl AsciiStr for [Ascii] {\n     #[inline]\n     fn as_str_ascii<'a>(&'a self) -> &'a str {\n@@ -336,11 +378,13 @@ impl IntoString for Vec<Ascii> {\n }\n \n /// Trait to convert to an owned byte vector by consuming self\n+#[experimental = \"may be replaced by generic conversion traits\"]\n pub trait IntoBytes {\n     /// Converts to an owned byte vector by consuming self\n     fn into_bytes(self) -> Vec<u8>;\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl IntoBytes for Vec<Ascii> {\n     fn into_bytes(self) -> Vec<u8> {\n         unsafe {\n@@ -358,6 +402,7 @@ impl IntoBytes for Vec<Ascii> {\n \n \n /// Extension methods for ASCII-subset only operations on owned strings\n+#[experimental = \"would prefer to do this in a more general way\"]\n pub trait OwnedAsciiExt {\n     /// Convert the string to ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n@@ -371,6 +416,7 @@ pub trait OwnedAsciiExt {\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n+#[experimental = \"would prefer to do this in a more general way\"]\n pub trait AsciiExt<T> for Sized? {\n     /// Makes a copy of the string in ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n@@ -388,6 +434,7 @@ pub trait AsciiExt<T> for Sized? {\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n }\n \n+#[experimental = \"would prefer to do this in a more general way\"]\n impl AsciiExt<String> for str {\n     #[inline]\n     fn to_ascii_upper(&self) -> String {\n@@ -407,6 +454,7 @@ impl AsciiExt<String> for str {\n     }\n }\n \n+#[experimental = \"would prefer to do this in a more general way\"]\n impl OwnedAsciiExt for String {\n     #[inline]\n     fn into_ascii_upper(self) -> String {\n@@ -421,6 +469,7 @@ impl OwnedAsciiExt for String {\n     }\n }\n \n+#[experimental = \"would prefer to do this in a more general way\"]\n impl AsciiExt<Vec<u8>> for [u8] {\n     #[inline]\n     fn to_ascii_upper(&self) -> Vec<u8> {\n@@ -443,6 +492,7 @@ impl AsciiExt<Vec<u8>> for [u8] {\n     }\n }\n \n+#[experimental = \"would prefer to do this in a more general way\"]\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_upper(mut self) -> Vec<u8> {\n@@ -472,6 +522,7 @@ impl OwnedAsciiExt for Vec<u8> {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex escapes.\n /// - Unicode escapes are never generated by this function.\n+#[unstable = \"needs to be updated to use an iterator\"]\n pub fn escape_default(c: u8, f: |u8|) {\n     match c {\n         b'\\t' => { f(b'\\\\'); f(b't'); }\n@@ -494,7 +545,7 @@ pub fn escape_default(c: u8, f: |u8|) {\n     }\n }\n \n-pub static ASCII_LOWER_MAP: [u8, ..256] = [\n+static ASCII_LOWER_MAP: [u8, ..256] = [\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n@@ -533,7 +584,7 @@ pub static ASCII_LOWER_MAP: [u8, ..256] = [\n     0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n ];\n \n-pub static ASCII_UPPER_MAP: [u8, ..256] = [\n+static ASCII_UPPER_MAP: [u8, ..256] = [\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,"}, {"sha": "9b50361ec1f0d2668da1ff4ca47b7c96435ebb18", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -1110,7 +1110,7 @@ extern \"system\" {\n ///\n /// The first element is traditionally the path to the executable, but it can be\n /// set to arbitrary text, and it may not even exist, so this property should not\n-//  be relied upon for security purposes.\n+/// be relied upon for security purposes.\n ///\n /// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n /// See `String::from_utf8_lossy` for details."}, {"sha": "9f81de72980ce0f3c549fff1eb947a18d515d996", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -235,10 +235,10 @@ impl GenericPathUnsafe for Path {\n             let repr = me.repr.as_slice();\n             match me.prefix {\n                 Some(DiskPrefix) => {\n-                    repr.as_bytes()[0] == path.as_bytes()[0].to_ascii().to_uppercase().to_byte()\n+                    repr.as_bytes()[0] == path.as_bytes()[0].to_ascii().to_uppercase().as_byte()\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    repr.as_bytes()[4] == path.as_bytes()[0].to_ascii().to_uppercase().to_byte()\n+                    repr.as_bytes()[4] == path.as_bytes()[0].to_ascii().to_uppercase().as_byte()\n                 }\n                 _ => false\n             }\n@@ -673,14 +673,17 @@ impl Path {\n         match (self.prefix, other.prefix) {\n             (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n                 self.is_absolute() &&\n-                    s_repr.as_bytes()[0].to_ascii().eq_ignore_case(o_repr.as_bytes()[4].to_ascii())\n+                    s_repr.as_bytes()[0].to_ascii().to_lowercase() ==\n+                        o_repr.as_bytes()[4].to_ascii().to_lowercase()\n             }\n             (Some(VerbatimDiskPrefix), Some(DiskPrefix)) => {\n                 other.is_absolute() &&\n-                    s_repr.as_bytes()[4].to_ascii().eq_ignore_case(o_repr.as_bytes()[0].to_ascii())\n+                    s_repr.as_bytes()[4].to_ascii().to_lowercase() ==\n+                        o_repr.as_bytes()[0].to_ascii().to_lowercase()\n             }\n             (Some(VerbatimDiskPrefix), Some(VerbatimDiskPrefix)) => {\n-                s_repr.as_bytes()[4].to_ascii().eq_ignore_case(o_repr.as_bytes()[4].to_ascii())\n+                s_repr.as_bytes()[4].to_ascii().to_lowercase() ==\n+                    o_repr.as_bytes()[4].to_ascii().to_lowercase()\n             }\n             (Some(UNCPrefix(_,_)), Some(VerbatimUNCPrefix(_,_))) => {\n                 s_repr.slice(2, self.prefix_len()) == o_repr.slice(8, other.prefix_len())\n@@ -747,10 +750,7 @@ impl Path {\n                                 let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    v[0] = (*v)[0]\n-                                                     .to_ascii()\n-                                                     .to_uppercase()\n-                                                     .to_byte();\n+                                    v[0] = (*v)[0].to_ascii().to_uppercase().as_byte();\n                                 }\n                                 if is_abs {\n                                     // normalize C:/ to C:\\\n@@ -765,7 +765,7 @@ impl Path {\n                                 let mut s = String::from_str(s.slice_to(len));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    v[4] = (*v)[4].to_ascii().to_uppercase().to_byte();\n+                                    v[4] = (*v)[4].to_ascii().to_uppercase().as_byte();\n                                 }\n                                 Some(s)\n                             }\n@@ -787,13 +787,13 @@ impl Path {\n                         match prefix {\n                             Some(DiskPrefix) => {\n                                 s.push(prefix_.as_bytes()[0].to_ascii()\n-                                                   .to_uppercase().to_char());\n+                                                   .to_uppercase().as_char());\n                                 s.push(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n                                 s.push_str(prefix_.slice_to(4));\n                                 s.push(prefix_.as_bytes()[4].to_ascii()\n-                                                   .to_uppercase().to_char());\n+                                                   .to_uppercase().as_char());\n                                 s.push_str(prefix_.slice_from(5));\n                             }\n                             Some(UNCPrefix(a,b)) => {"}, {"sha": "3d33774aa55e1d922f5dde98082affd89dc9ef3a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -673,8 +673,8 @@ pub enum Expr_ {\n \n     ExprAssign(P<Expr>, P<Expr>),\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n-    ExprField(P<Expr>, SpannedIdent, Vec<P<Ty>>),\n-    ExprTupField(P<Expr>, Spanned<uint>, Vec<P<Ty>>),\n+    ExprField(P<Expr>, SpannedIdent),\n+    ExprTupField(P<Expr>, Spanned<uint>),\n     ExprIndex(P<Expr>, P<Expr>),\n     ExprSlice(P<Expr>, Option<P<Expr>>, Option<P<Expr>>, Mutability),\n "}, {"sha": "2c7f9e889f8b2d4f4aaaeab233ea6a5409bc441e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -577,7 +577,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         };\n \n         let id = Spanned { node: ident, span: field_span };\n-        self.expr(sp, ast::ExprField(expr, id, Vec::new()))\n+        self.expr(sp, ast::ExprField(expr, id))\n     }\n     fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: uint) -> P<ast::Expr> {\n         let field_span = Span {\n@@ -587,7 +587,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         };\n \n         let id = Spanned { node: idx, span: field_span };\n-        self.expr(sp, ast::ExprTupField(expr, id, Vec::new()))\n+        self.expr(sp, ast::ExprTupField(expr, id))\n     }\n     fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprAddrOf(ast::MutImmutable, e))"}, {"sha": "6941c0e9c180053c4bc845603bcfc1c3d6b9c359", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -1345,15 +1345,13 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                             folder.fold_expr(el),\n                             folder.fold_expr(er))\n             }\n-            ExprField(el, ident, tys) => {\n+            ExprField(el, ident) => {\n                 ExprField(folder.fold_expr(el),\n-                          respan(ident.span, folder.fold_ident(ident.node)),\n-                          tys.move_map(|x| folder.fold_ty(x)))\n+                          respan(ident.span, folder.fold_ident(ident.node)))\n             }\n-            ExprTupField(el, ident, tys) => {\n+            ExprTupField(el, ident) => {\n                 ExprTupField(folder.fold_expr(el),\n-                             respan(ident.span, folder.fold_uint(ident.node)),\n-                             tys.move_map(|x| folder.fold_ty(x)))\n+                             respan(ident.span, folder.fold_uint(ident.node)))\n             }\n             ExprIndex(el, er) => {\n                 ExprIndex(folder.fold_expr(el), folder.fold_expr(er))"}, {"sha": "a9306c71240ef14eaa972318f9ec7e9579eabcac", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -49,8 +49,7 @@ use ast::{PolyTraitRef};\n use ast::{QPath, RequiredMethod};\n use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n-use ast::{StructVariantKind, BiSub};\n-use ast::StrStyle;\n+use ast::{StructVariantKind, BiSub, StrStyle};\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n@@ -65,31 +64,25 @@ use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause, WherePredicate};\n use ast;\n-use ast_util::{as_prec, ident_to_path, operator_prec};\n-use ast_util;\n-use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n-use codemap;\n+use ast_util::{mod, as_prec, ident_to_path, operator_prec};\n+use codemap::{mod, Span, BytePos, Spanned, spanned, mk_sp};\n use diagnostic;\n use ext::tt::macro_parser;\n use parse;\n use parse::attr::ParserAttr;\n use parse::classify;\n-use parse::common::{SeqSep, seq_sep_none};\n-use parse::common::{seq_sep_trailing_allowed};\n-use parse::lexer::Reader;\n-use parse::lexer::TokenAndSpan;\n+use parse::common::{SeqSep, seq_sep_none, seq_sep_trailing_allowed};\n+use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::*;\n-use parse::token::{MatchNt, SubstNt, InternedString};\n+use parse::token::{mod, MatchNt, SubstNt, InternedString};\n use parse::token::{keywords, special_idents};\n-use parse::token;\n use parse::{new_sub_parser_from_file, ParseSess};\n use print::pprust;\n use ptr::P;\n use owned_slice::OwnedSlice;\n \n use std::collections::HashSet;\n use std::io::fs::PathExtensions;\n-use std::mem::replace;\n use std::mem;\n use std::num::Float;\n use std::rc::Rc;\n@@ -915,7 +908,7 @@ impl<'a> Parser<'a> {\n                 tok: token::Underscore,\n                 sp: self.span,\n             };\n-            replace(&mut self.buffer[buffer_start], placeholder)\n+            mem::replace(&mut self.buffer[buffer_start], placeholder)\n         };\n         self.span = next.sp;\n         self.token = next.tok;\n@@ -924,7 +917,7 @@ impl<'a> Parser<'a> {\n \n     /// Advance the parser by one token and return the bumped token.\n     pub fn bump_and_get(&mut self) -> token::Token {\n-        let old_token = replace(&mut self.token, token::Underscore);\n+        let old_token = mem::replace(&mut self.token, token::Underscore);\n         self.bump();\n         old_token\n     }\n@@ -2103,14 +2096,12 @@ impl<'a> Parser<'a> {\n         ExprSlice(expr, start, end, mutbl)\n     }\n \n-    pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent,\n-                    tys: Vec<P<Ty>>) -> ast::Expr_ {\n-        ExprField(expr, ident, tys)\n+    pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::Expr_ {\n+        ExprField(expr, ident)\n     }\n \n-    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<uint>,\n-                    tys: Vec<P<Ty>>) -> ast::Expr_ {\n-        ExprTupField(expr, idx, tys)\n+    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<uint>) -> ast::Expr_ {\n+        ExprTupField(expr, idx)\n     }\n \n     pub fn mk_assign_op(&mut self, binop: ast::BinOp,\n@@ -2465,31 +2456,26 @@ impl<'a> Parser<'a> {\n                             }\n \n                             let id = spanned(dot, hi, i);\n-                            let field = self.mk_field(e, id, tys);\n+                            let field = self.mk_field(e, id);\n                             e = self.mk_expr(lo, hi, field);\n                         }\n                     }\n                   }\n                   token::Literal(token::Integer(n), suf) => {\n                     let sp = self.span;\n+\n+                    // A tuple index may not have a suffix\n                     self.expect_no_suffix(sp, \"tuple index\", suf);\n \n-                    let index = n.as_str();\n                     let dot = self.last_span.hi;\n                     hi = self.span.hi;\n                     self.bump();\n-                    let (_, tys) = if self.eat(&token::ModSep) {\n-                        self.expect_lt();\n-                        self.parse_generic_values_after_lt()\n-                    } else {\n-                        (Vec::new(), Vec::new())\n-                    };\n \n-                    let num = from_str::<uint>(index);\n-                    match num {\n+                    let index = from_str::<uint>(n.as_str());\n+                    match index {\n                         Some(n) => {\n                             let id = spanned(dot, hi, n);\n-                            let field = self.mk_tup_field(e, id, tys);\n+                            let field = self.mk_tup_field(e, id);\n                             e = self.mk_expr(lo, hi, field);\n                         }\n                         None => {"}, {"sha": "6960337c3e2c9dc5f53958f09b2cf748817992a6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -11,31 +11,25 @@\n pub use self::AnnNode::*;\n \n use abi;\n-use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n+use ast::{mod, FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound};\n use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n use ast::{UnboxedClosureKind};\n-use ast;\n use ast_util;\n use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n-use codemap::{CodeMap, BytePos};\n-use codemap;\n+use codemap::{mod, CodeMap, BytePos};\n use diagnostic;\n-use parse::token::{BinOpToken, Token};\n-use parse::token;\n+use parse::token::{mod, BinOpToken, Token};\n use parse::lexer::comments;\n use parse;\n-use print::pp::{break_offset, word, space, zerobreak, hardbreak};\n+use print::pp::{mod, break_offset, word, space, zerobreak, hardbreak};\n use print::pp::{Breaks, Consistent, Inconsistent, eof};\n-use print::pp;\n use ptr::P;\n \n-use std::ascii;\n-use std::io::IoResult;\n-use std::io;\n-use std::mem;\n+use std::{ascii, mem};\n+use std::io::{mod, IoResult};\n \n pub enum AnnNode<'a> {\n     NodeIdent(&'a ast::Ident),\n@@ -1734,29 +1728,15 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }\n-            ast::ExprField(ref expr, id, ref tys) => {\n+            ast::ExprField(ref expr, id) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(id.node));\n-                if tys.len() > 0u {\n-                    try!(word(&mut self.s, \"::<\"));\n-                    try!(self.commasep(\n-                        Inconsistent, tys.as_slice(),\n-                        |s, ty| s.print_type(&**ty)));\n-                    try!(word(&mut self.s, \">\"));\n-                }\n             }\n-            ast::ExprTupField(ref expr, id, ref tys) => {\n+            ast::ExprTupField(ref expr, id) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_uint(id.node));\n-                if tys.len() > 0u {\n-                    try!(word(&mut self.s, \"::<\"));\n-                    try!(self.commasep(\n-                        Inconsistent, tys.as_slice(),\n-                        |s, ty| s.print_type(&**ty)));\n-                    try!(word(&mut self.s, \">\"));\n-                }\n             }\n             ast::ExprIndex(ref expr, ref index) => {\n                 try!(self.print_expr(&**expr));\n@@ -2164,21 +2144,22 @@ impl<'a> State<'a> {\n             try!(self.print_pat(&**p));\n         }\n         try!(space(&mut self.s));\n-        match arm.guard {\n-            Some(ref e) => {\n-                try!(self.word_space(\"if\"));\n-                try!(self.print_expr(&**e));\n-                try!(space(&mut self.s));\n-            }\n-            None => ()\n+        if let Some(ref e) = arm.guard {\n+            try!(self.word_space(\"if\"));\n+            try!(self.print_expr(&**e));\n+            try!(space(&mut self.s));\n         }\n         try!(self.word_space(\"=>\"));\n \n         match arm.body.node {\n             ast::ExprBlock(ref blk) => {\n                 // the block will close the pattern's ibox\n-                try!(self.print_block_unclosed_indent(&**blk,\n-                                                      indent_unit));\n+                try!(self.print_block_unclosed_indent(&**blk, indent_unit));\n+\n+                // If it is a user-provided unsafe block, print a comma after it\n+                if let ast::UnsafeBlock(ast::UserProvided) = blk.rules {\n+                    try!(word(&mut self.s, \",\"));\n+                }\n             }\n             _ => {\n                 try!(self.end()); // close the ibox for the pattern"}, {"sha": "3f87dbc0740ec6b648b31786c43a43a46c229725", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -838,17 +838,11 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(&**right_expression);\n             visitor.visit_expr(&**left_expression)\n         }\n-        ExprField(ref subexpression, _, ref types) => {\n+        ExprField(ref subexpression, _) => {\n             visitor.visit_expr(&**subexpression);\n-            for typ in types.iter() {\n-                visitor.visit_ty(&**typ)\n-            }\n         }\n-        ExprTupField(ref subexpression, _, ref types) => {\n+        ExprTupField(ref subexpression, _) => {\n             visitor.visit_expr(&**subexpression);\n-            for typ in types.iter() {\n-                visitor.visit_ty(&**typ)\n-            }\n         }\n         ExprIndex(ref main_expression, ref index_expression) => {\n             visitor.visit_expr(&**main_expression);"}, {"sha": "cfb4c3bc40322b79d28c387b33d62700feaef2f3", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -533,9 +533,8 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                 FormatHEX => {\n                     s = s.as_slice()\n                          .to_ascii()\n-                         .to_uppercase()\n-                         .into_bytes()\n-                         .into_iter()\n+                         .iter()\n+                         .map(|b| b.to_uppercase().as_byte())\n                          .collect();\n                     if flags.alternate {\n                         let s_ = replace(&mut s, vec!(b'0', b'X'));"}, {"sha": "0faf6840f0610f095d68c1b2ac6e393ffbcac82d", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -1,3 +1,12 @@\n+S 2014-11-21 c9f6d69\n+  freebsd-x86_64 0ef316e7c369177de043e69e964418bd637cbfc0\n+  linux-i386 c8342e762a1720be939ed7c6a39bdaa27892f66f\n+  linux-x86_64 7a7fe6f5ed47b9cc66261f880e166c7c8738b73e\n+  macos-i386 63e8644512bd5665c14389a83d5af564c7c0b103\n+  macos-x86_64 7933ae0e974d1b897806138b7052cb2b4514585f\n+  winnt-i386 94f5e2974e6120945c909753010d73b53cd6ff90\n+  winnt-x86_64 905ffbdd94580854b01dc4e27fdad7e7c8ae18fe\n+\n S 2014-11-18 9c96a79\n   freebsd-x86_64 22c93a289bdbc886af882b5bb76bfa673d46aa4f\n   linux-i386 999ba4a0dfb70adca628138a7d5f491023621140"}, {"sha": "7f42abb3acca4d9b272f0a4dfe82d53b793d70e7", "filename": "src/test/compile-fail/issue-19096.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Fcompile-fail%2Fissue-19096.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Fcompile-fail%2Fissue-19096.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19096.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(tuple_indexing)]\n+\n+fn main() {\n+    let t = (42i, 42i);\n+    t.0::<int>; //~ ERROR expected one of `;`, `}`, found `::`\n+}"}, {"sha": "f68eb6400fa8d3e159afc1cb07e84cac49881724", "filename": "src/test/compile-fail/stage0-cmp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Fcompile-fail%2Fstage0-cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Fcompile-fail%2Fstage0-cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstage0-cmp.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -30,7 +30,6 @@ pub trait PartialEq for Sized? {\n     fn eq(&self, other: &Self) -> bool;\n }\n \n-#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[unstable = \"Trait is unstable.\"]\n impl<'a, Sized? T: PartialEq> PartialEq for &'a T {\n     #[inline]"}, {"sha": "61274385857fe5f09aafb85426b393935bb7fe74", "filename": "src/test/pretty/issue-19077.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Fpretty%2Fissue-19077.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Fpretty%2Fissue-19077.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-19077.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Testing that unsafe blocks in match arms are followed by a comma\n+// pp-exact\n+fn main() {\n+    match true {\n+        true if true => (),\n+        false if false => unsafe { },\n+        true => { }\n+        false => (),\n+    }\n+}"}, {"sha": "f00ba36a00450e1c8fa2646b51bb8115e75c413a", "filename": "src/test/run-pass/super-fast-paren-parsing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty\n+//\n // exec-env:RUST_MIN_STACK=16000000\n //\n // Big stack is needed for pretty printing, a little sad..."}]}