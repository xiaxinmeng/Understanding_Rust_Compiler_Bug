{"sha": "d868da7796bfb96e87e09afc4e8338911b5f99b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NjhkYTc3OTZiZmI5NmU4N2UwOWFmYzRlODMzODkxMWI1Zjk5YjM=", "commit": {"author": {"name": "Kornel", "email": "kornel@geekhood.net", "date": "2021-05-30T16:01:02Z"}, "committer": {"name": "Kornel", "email": "kornel@cloudflare.com", "date": "2021-07-09T13:09:48Z"}, "message": "Unescaped command-line arguments for Windows\n\nFixes #29494", "tree": {"sha": "0d3c864b3127ed8f8a5c4a6cc42401064b915b4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d3c864b3127ed8f8a5c4a6cc42401064b915b4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d868da7796bfb96e87e09afc4e8338911b5f99b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d868da7796bfb96e87e09afc4e8338911b5f99b3", "html_url": "https://github.com/rust-lang/rust/commit/d868da7796bfb96e87e09afc4e8338911b5f99b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d868da7796bfb96e87e09afc4e8338911b5f99b3/comments", "author": {"login": "kornelski", "id": 72159, "node_id": "MDQ6VXNlcjcyMTU5", "avatar_url": "https://avatars.githubusercontent.com/u/72159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kornelski", "html_url": "https://github.com/kornelski", "followers_url": "https://api.github.com/users/kornelski/followers", "following_url": "https://api.github.com/users/kornelski/following{/other_user}", "gists_url": "https://api.github.com/users/kornelski/gists{/gist_id}", "starred_url": "https://api.github.com/users/kornelski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kornelski/subscriptions", "organizations_url": "https://api.github.com/users/kornelski/orgs", "repos_url": "https://api.github.com/users/kornelski/repos", "events_url": "https://api.github.com/users/kornelski/events{/privacy}", "received_events_url": "https://api.github.com/users/kornelski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kornelski", "id": 72159, "node_id": "MDQ6VXNlcjcyMTU5", "avatar_url": "https://avatars.githubusercontent.com/u/72159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kornelski", "html_url": "https://github.com/kornelski", "followers_url": "https://api.github.com/users/kornelski/followers", "following_url": "https://api.github.com/users/kornelski/following{/other_user}", "gists_url": "https://api.github.com/users/kornelski/gists{/gist_id}", "starred_url": "https://api.github.com/users/kornelski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kornelski/subscriptions", "organizations_url": "https://api.github.com/users/kornelski/orgs", "repos_url": "https://api.github.com/users/kornelski/repos", "events_url": "https://api.github.com/users/kornelski/events{/privacy}", "received_events_url": "https://api.github.com/users/kornelski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcd5cecdcf50865df7838d734dfa5aeaa1f9c81e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcd5cecdcf50865df7838d734dfa5aeaa1f9c81e", "html_url": "https://github.com/rust-lang/rust/commit/fcd5cecdcf50865df7838d734dfa5aeaa1f9c81e"}], "stats": {"total": 105, "additions": 86, "deletions": 19}, "files": [{"sha": "48c3d7bbd1789b0713ac30e075b78fe148c2b7d7", "filename": "library/std/src/os/windows/process.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d868da7796bfb96e87e09afc4e8338911b5f99b3/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d868da7796bfb96e87e09afc4e8338911b5f99b3/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs?ref=d868da7796bfb96e87e09afc4e8338911b5f99b3", "patch": "@@ -2,6 +2,7 @@\n \n #![stable(feature = \"process_extensions\", since = \"1.2.0\")]\n \n+use crate::ffi::OsStr;\n use crate::os::windows::io::{AsRawHandle, FromRawHandle, IntoRawHandle, RawHandle};\n use crate::process;\n use crate::sealed::Sealed;\n@@ -125,6 +126,13 @@ pub trait CommandExt: Sealed {\n     /// [2]: <https://msdn.microsoft.com/en-us/library/17w5ykft.aspx>\n     #[unstable(feature = \"windows_process_extensions_force_quotes\", issue = \"82227\")]\n     fn force_quotes(&mut self, enabled: bool) -> &mut process::Command;\n+\n+    /// Append literal text to the command line without any quoting or escaping.\n+    ///\n+    /// This is useful for passing arguments to `cmd.exe /c`, which doesn't follow\n+    /// `CommandLineToArgvW` escaping rules.\n+    #[unstable(feature = \"windows_process_extensions_raw_arg\", issue = \"29494\")]\n+    fn raw_arg(&mut self, text_to_append_as_is: &OsStr) -> &mut process::Command;\n }\n \n #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n@@ -138,4 +146,9 @@ impl CommandExt for process::Command {\n         self.as_inner_mut().force_quotes(enabled);\n         self\n     }\n+\n+    fn raw_arg(&mut self, raw_text: &OsStr) -> &mut process::Command {\n+        self.as_inner_mut().raw_arg(raw_text);\n+        self\n+    }\n }"}, {"sha": "1b685fcccb16ff58dda75fa226000865befafc10", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d868da7796bfb96e87e09afc4e8338911b5f99b3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d868da7796bfb96e87e09afc4e8338911b5f99b3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=d868da7796bfb96e87e09afc4e8338911b5f99b3", "patch": "@@ -137,7 +137,7 @@ fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n \n pub struct Command {\n     program: OsString,\n-    args: Vec<OsString>,\n+    args: Vec<Arg>,\n     env: CommandEnv,\n     cwd: Option<OsString>,\n     flags: u32,\n@@ -161,6 +161,14 @@ pub struct StdioPipes {\n     pub stderr: Option<AnonPipe>,\n }\n \n+#[derive(Debug)]\n+enum Arg {\n+    /// Add quotes (if needed)\n+    Regular(OsString),\n+    /// Append raw string without quoting\n+    Raw(OsString),\n+}\n+\n impl Command {\n     pub fn new(program: &OsStr) -> Command {\n         Command {\n@@ -178,7 +186,7 @@ impl Command {\n     }\n \n     pub fn arg(&mut self, arg: &OsStr) {\n-        self.args.push(arg.to_os_string())\n+        self.args.push(Arg::Regular(arg.to_os_string()))\n     }\n     pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n@@ -203,6 +211,10 @@ impl Command {\n         self.force_quotes_enabled = enabled;\n     }\n \n+    pub fn raw_arg(&mut self, command_str_to_append: &OsStr) {\n+        self.args.push(Arg::Raw(command_str_to_append.to_os_string()))\n+    }\n+\n     pub fn get_program(&self) -> &OsStr {\n         &self.program\n     }\n@@ -536,44 +548,63 @@ fn zeroed_process_information() -> c::PROCESS_INFORMATION {\n     }\n }\n \n+enum Quote {\n+    // Every arg is quoted\n+    Always,\n+    // Whitespace and empty args are quoted\n+    Auto,\n+    // Arg appended without any changes (#29494)\n+    Never,\n+}\n+\n // Produces a wide string *without terminating null*; returns an error if\n // `prog` or any of the `args` contain a nul.\n-fn make_command_line(prog: &OsStr, args: &[OsString], force_quotes: bool) -> io::Result<Vec<u16>> {\n+fn make_command_line(prog: &OsStr, args: &[Arg], force_quotes: bool) -> io::Result<Vec<u16>> {\n     // Encode the command and arguments in a command line string such\n     // that the spawned process may recover them using CommandLineToArgvW.\n     let mut cmd: Vec<u16> = Vec::new();\n     // Always quote the program name so CreateProcess doesn't interpret args as\n     // part of the name if the binary wasn't found first time.\n-    append_arg(&mut cmd, prog, true)?;\n+    append_arg(&mut cmd, prog, Quote::Always)?;\n     for arg in args {\n         cmd.push(' ' as u16);\n-        append_arg(&mut cmd, arg, force_quotes)?;\n+        let (arg, quote) = match arg {\n+            Arg::Regular(arg) => (arg, if force_quotes { Quote::Always } else { Quote::Auto }),\n+            Arg::Raw(arg) => (arg, Quote::Never),\n+        };\n+        append_arg(&mut cmd, arg, quote)?;\n     }\n     return Ok(cmd);\n \n-    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr, force_quotes: bool) -> io::Result<()> {\n+    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr, quote: Quote) -> io::Result<()> {\n         // If an argument has 0 characters then we need to quote it to ensure\n         // that it actually gets passed through on the command line or otherwise\n         // it will be dropped entirely when parsed on the other end.\n         ensure_no_nuls(arg)?;\n         let arg_bytes = &arg.as_inner().inner.as_inner();\n-        let quote = force_quotes\n-            || arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t')\n-            || arg_bytes.is_empty();\n+        let (quote, escape) = match quote {\n+            Quote::Always => (true, true),\n+            Quote::Auto => {\n+                (arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t') || arg_bytes.is_empty(), true)\n+            }\n+            Quote::Never => (false, false),\n+        };\n         if quote {\n             cmd.push('\"' as u16);\n         }\n \n         let mut backslashes: usize = 0;\n         for x in arg.encode_wide() {\n-            if x == '\\\\' as u16 {\n-                backslashes += 1;\n-            } else {\n-                if x == '\"' as u16 {\n-                    // Add n+1 backslashes to total 2n+1 before internal '\"'.\n-                    cmd.extend((0..=backslashes).map(|_| '\\\\' as u16));\n+            if escape {\n+                if x == '\\\\' as u16 {\n+                    backslashes += 1;\n+                } else {\n+                    if x == '\"' as u16 {\n+                        // Add n+1 backslashes to total 2n+1 before internal '\"'.\n+                        cmd.extend((0..=backslashes).map(|_| '\\\\' as u16));\n+                    }\n+                    backslashes = 0;\n                 }\n-                backslashes = 0;\n             }\n             cmd.push(x);\n         }\n@@ -626,13 +657,15 @@ fn make_dirp(d: Option<&OsString>) -> io::Result<(*const u16, Vec<u16>)> {\n }\n \n pub struct CommandArgs<'a> {\n-    iter: crate::slice::Iter<'a, OsString>,\n+    iter: crate::slice::Iter<'a, Arg>,\n }\n \n impl<'a> Iterator for CommandArgs<'a> {\n     type Item = &'a OsStr;\n     fn next(&mut self) -> Option<&'a OsStr> {\n-        self.iter.next().map(|s| s.as_ref())\n+        self.iter.next().map(|arg| match arg {\n+            Arg::Regular(s) | Arg::Raw(s) => s.as_ref(),\n+        })\n     }\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()"}, {"sha": "3b65856dcaca6d4f3e017a2ba97fccf2cf8f339c", "filename": "library/std/src/sys/windows/process/tests.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d868da7796bfb96e87e09afc4e8338911b5f99b3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d868da7796bfb96e87e09afc4e8338911b5f99b3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs?ref=d868da7796bfb96e87e09afc4e8338911b5f99b3", "patch": "@@ -1,14 +1,35 @@\n use super::make_command_line;\n+use super::Arg;\n use crate::env;\n use crate::ffi::{OsStr, OsString};\n use crate::process::Command;\n \n+#[test]\n+fn test_raw_args() {\n+    let command_line = &make_command_line(\n+        OsStr::new(\"quoted exe\"),\n+        &[\n+            Arg::Regular(OsString::from(\"quote me\")),\n+            Arg::Raw(OsString::from(\"quote me *not*\")),\n+            Arg::Raw(OsString::from(\"\\t\\\\\")),\n+            Arg::Raw(OsString::from(\"internal \\\\\\\"backslash-\\\"quote\")),\n+            Arg::Regular(OsString::from(\"optional-quotes\")),\n+        ],\n+        false,\n+    )\n+    .unwrap();\n+    assert_eq!(\n+        String::from_utf16(command_line).unwrap(),\n+        \"\\\"quoted exe\\\" \\\"quote me\\\" quote me *not* \\t\\\\ internal \\\\\\\"backslash-\\\"quote optional-quotes\"\n+    );\n+}\n+\n #[test]\n fn test_make_command_line() {\n     fn test_wrapper(prog: &str, args: &[&str], force_quotes: bool) -> String {\n         let command_line = &make_command_line(\n             OsStr::new(prog),\n-            &args.iter().map(|a| OsString::from(a)).collect::<Vec<OsString>>(),\n+            &args.iter().map(|a| Arg::Regular(OsString::from(a))).collect::<Vec<_>>(),\n             force_quotes,\n         )\n         .unwrap();"}]}