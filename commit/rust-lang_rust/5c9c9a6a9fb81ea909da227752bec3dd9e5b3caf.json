{"sha": "5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjOWM5YTZhOWZiODFlYTkwOWRhMjI3NzUyYmVjM2RkOWU1YjNjYWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-09T02:51:19Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-09T02:51:48Z"}, "message": "libsyntax: Parse common enum fields", "tree": {"sha": "d06b7ab718d3476516196f6be7c1bd89c4a67385", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d06b7ab718d3476516196f6be7c1bd89c4a67385"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "html_url": "https://github.com/rust-lang/rust/commit/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "780b3853d13280ae67d1e196b54e80c47d63e88c", "url": "https://api.github.com/repos/rust-lang/rust/commits/780b3853d13280ae67d1e196b54e80c47d63e88c", "html_url": "https://github.com/rust-lang/rust/commit/780b3853d13280ae67d1e196b54e80c47d63e88c"}], "stats": {"total": 215, "additions": 129, "deletions": 86}, "files": [{"sha": "8f4eb98fa7b67d9deac29048fd4c5353b82f558f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "patch": "@@ -641,7 +641,7 @@ enum variant_kind {\n }\n \n #[auto_serialize]\n-enum enum_def = { variants: ~[variant] };\n+enum enum_def = { variants: ~[variant], common: option<@struct_def> };\n \n #[auto_serialize]\n type variant_ = {name: ident, attrs: ~[attribute], kind: variant_kind,"}, {"sha": "f1f8eb4f452abe96672a7f4917c66b6c387ddefc", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "patch": "@@ -231,7 +231,9 @@ impl state: to_type_decls {\n             vec::push(items_msg, v);\n         }\n \n-        ~[cx.item_enum_poly(name, ast::enum_def({ variants: items_msg }),\n+        ~[cx.item_enum_poly(name,\n+                            ast::enum_def({ variants: items_msg,\n+                                            common: none }),\n                             self.ty_params)]\n     }\n "}, {"sha": "5cce86fd458e176441378cc98fc4a8152816c9fd", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "patch": "@@ -242,40 +242,13 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n             item_enum(ast::enum_def({\n                 variants: vec::map(enum_definition.variants,\n                                    |x| fld.fold_variant(x)),\n+                common: option::map(enum_definition.common,\n+                                    |x| fold_struct_def(x, fld))\n             }), fold_ty_params(typms, fld))\n           }\n           item_class(struct_def, typms) => {\n-            let resulting_optional_constructor;\n-            match struct_def.ctor {\n-                none => {\n-                    resulting_optional_constructor = none;\n-                }\n-                some(constructor) => {\n-                    resulting_optional_constructor = some({\n-                        node: {\n-                            body: fld.fold_block(constructor.node.body),\n-                            dec: fold_fn_decl(constructor.node.dec, fld),\n-                            id: fld.new_id(constructor.node.id)\n-                            with constructor.node\n-                        }\n-                        with constructor\n-                    });\n-                }\n-            }\n-            let dtor = do option::map(struct_def.dtor) |dtor| {\n-                let dtor_body = fld.fold_block(dtor.node.body);\n-                let dtor_id   = fld.new_id(dtor.node.id);\n-                {node: {body: dtor_body,\n-                        id: dtor_id with dtor.node}\n-                    with dtor}};\n-              item_class(@{\n-                  traits: vec::map(struct_def.traits,\n-                                   |p| fold_trait_ref(p, fld)),\n-                  members: vec::map(struct_def.members,\n-                                    |x| fld.fold_class_item(x)),\n-                  ctor: resulting_optional_constructor,\n-                  dtor: dtor},\n-                  /* FIXME (#2543) */ copy typms)\n+            let struct_def = fold_struct_def(struct_def, fld);\n+              item_class(struct_def, /* FIXME (#2543) */ copy typms)\n           }\n           item_impl(tps, ifce, ty, methods) => {\n               item_impl(fold_ty_params(tps, fld),\n@@ -295,6 +268,39 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n         };\n }\n \n+fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n+                -> @ast::struct_def {\n+    let resulting_optional_constructor;\n+    match struct_def.ctor {\n+        none => {\n+            resulting_optional_constructor = none;\n+        }\n+        some(constructor) => {\n+            resulting_optional_constructor = some({\n+                node: {\n+                    body: fld.fold_block(constructor.node.body),\n+                    dec: fold_fn_decl(constructor.node.dec, fld),\n+                    id: fld.new_id(constructor.node.id)\n+                    with constructor.node\n+                }\n+                with constructor\n+            });\n+        }\n+    }\n+    let dtor = do option::map(struct_def.dtor) |dtor| {\n+        let dtor_body = fld.fold_block(dtor.node.body);\n+        let dtor_id   = fld.new_id(dtor.node.id);\n+        {node: {body: dtor_body,\n+                id: dtor_id with dtor.node}\n+            with dtor}};\n+    return @{\n+        traits: vec::map(struct_def.traits, |p| fold_trait_ref(p, fld)),\n+        members: vec::map(struct_def.members, |x| fld.fold_class_item(x)),\n+        ctor: resulting_optional_constructor,\n+        dtor: dtor\n+    };\n+}\n+\n fn fold_trait_ref(&&p: @trait_ref, fld: ast_fold) -> @trait_ref {\n     @{path: fld.fold_path(p.path), ref_id: fld.new_id(p.ref_id),\n      impl_id: fld.new_id(p.impl_id)}\n@@ -570,7 +576,10 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n         enum_variant_kind(enum_definition) => {\n             let variants = vec::map(enum_definition.variants,\n                                     |x| fld.fold_variant(x));\n-            kind = enum_variant_kind(ast::enum_def({ variants: variants }));\n+            let common = option::map(enum_definition.common,\n+                                     |x| fold_struct_def(x, fld));\n+            kind = enum_variant_kind(ast::enum_def({ variants: variants,\n+                                                     common: common }));\n         }\n     }\n "}, {"sha": "287687651929b7b20374876b5149c1ae02ea2c49", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 70, "deletions": 52, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "patch": "@@ -46,9 +46,9 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              proto_block, proto_box, proto_uniq, provided, public, pure_fn,\n              purity, re_anon, re_named, region, rem, required, ret_style,\n              return_val, self_ty, shl, shr, stmt, stmt_decl, stmt_expr,\n-             stmt_semi, struct_variant_kind, subtract, sty_box, sty_by_ref,\n-             sty_region, sty_static, sty_uniq, sty_value, token_tree,\n-             trait_method, trait_ref, tt_delim, tt_seq, tt_tok,\n+             stmt_semi, struct_def, struct_variant_kind, subtract, sty_box,\n+             sty_by_ref, sty_region, sty_static, sty_uniq, sty_value,\n+             token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok,\n              tt_nonterminal, ty, ty_, ty_bot, ty_box, ty_field, ty_fn,\n              ty_infer, ty_mac, ty_method, ty_nil, ty_param, ty_param_bound,\n              ty_path, ty_ptr, ty_rec, ty_rptr, ty_tup, ty_u32, ty_uniq,\n@@ -2792,13 +2792,74 @@ class parser {\n         }\n     }\n \n-    fn parse_enum_def(ty_params: ~[ast::ty_param]) -> enum_def {\n+    fn parse_struct_def(path: @path) -> @struct_def {\n+        let mut the_dtor: option<(blk, ~[attribute], codemap::span)> = none;\n+        let mut ms: ~[@class_member] = ~[];\n+        while self.token != token::RBRACE {\n+            match self.parse_class_item(path) {\n+                ctor_decl(*) => {\n+                    self.span_fatal(copy self.span,\n+                                    ~\"deprecated explicit \\\n+                                      constructors are not allowed \\\n+                                      here\");\n+                }\n+                dtor_decl(blk, attrs, s) => {\n+                    match the_dtor {\n+                        some((_, _, s_first)) => {\n+                            self.span_note(s, ~\"duplicate destructor \\\n+                                                declaration\");\n+                            self.span_fatal(copy s_first,\n+                                            ~\"first destructor \\\n+                                              declared here\");\n+                        }\n+                        none => {\n+                            the_dtor = some((blk, attrs, s));\n+                        }\n+                    }\n+                }\n+                members(mms) =>\n+                    ms = vec::append(ms, mms)\n+            }\n+        }\n+        self.bump();\n+        let mut actual_dtor = do option::map(the_dtor) |dtor| {\n+            let (d_body, d_attrs, d_s) = dtor;\n+            {node: {id: self.get_id(),\n+                    attrs: d_attrs,\n+                    self_id: self.get_id(),\n+                    body: d_body},\n+             span: d_s}\n+        };\n+\n+        return @{\n+            traits: ~[],\n+            members: ms,\n+            ctor: none,\n+            dtor: actual_dtor\n+        };\n+    }\n+\n+    fn parse_enum_def(ident: ast::ident, ty_params: ~[ast::ty_param])\n+                   -> enum_def {\n         let mut variants: ~[variant] = ~[];\n         let mut all_nullary = true, have_disr = false;\n+        let mut common_fields = none;\n \n         while self.token != token::RBRACE {\n             let variant_attrs = self.parse_outer_attributes();\n             let vlo = self.span.lo;\n+\n+            // Is this a common field declaration?\n+            if self.eat_keyword(~\"struct\") {\n+                if common_fields.is_some() {\n+                    self.fatal(~\"duplicate declaration of shared fields\");\n+                }\n+                self.expect(token::LBRACE);\n+                let path = self.ident_to_path_tys(ident, ty_params);\n+                common_fields = some(self.parse_struct_def(path));\n+                again;\n+            }\n+\n             let vis = self.parse_visibility();\n             let ident = self.parse_value_ident();\n             let mut args = ~[], disr_expr = none;\n@@ -2807,51 +2868,7 @@ class parser {\n                 // Parse a struct variant.\n                 all_nullary = false;\n                 let path = self.ident_to_path_tys(ident, ty_params);\n-                let mut the_dtor: option<(blk, ~[attribute], codemap::span)> =\n-                    none;\n-                let mut ms: ~[@class_member] = ~[];\n-                while self.token != token::RBRACE {\n-                    match self.parse_class_item(path) {\n-                        ctor_decl(*) => {\n-                            self.span_fatal(copy self.span,\n-                                            ~\"deprecated explicit \\\n-                                              constructors are not allowed \\\n-                                              here\");\n-                        }\n-                        dtor_decl(blk, attrs, s) => {\n-                            match the_dtor {\n-                                some((_, _, s_first)) => {\n-                                    self.span_note(s, ~\"duplicate destructor \\\n-                                                        declaration\");\n-                                    self.span_fatal(copy s_first,\n-                                                    ~\"first destructor \\\n-                                                      declared here\");\n-                                }\n-                                none => {\n-                                    the_dtor = some((blk, attrs, s));\n-                                }\n-                            }\n-                        }\n-                        members(mms) =>\n-                            ms = vec::append(ms, mms)\n-                    }\n-                }\n-                self.bump();\n-                let mut actual_dtor = do option::map(the_dtor) |dtor| {\n-                    let (d_body, d_attrs, d_s) = dtor;\n-                    {node: {id: self.get_id(),\n-                            attrs: d_attrs,\n-                            self_id: self.get_id(),\n-                            body: d_body},\n-                     span: d_s}\n-                };\n-\n-                kind = struct_variant_kind(@{\n-                    traits: ~[],\n-                    members: ms,\n-                    ctor: none,\n-                    dtor: actual_dtor\n-                });\n+                kind = struct_variant_kind(self.parse_struct_def(path));\n             } else if self.token == token::LPAREN {\n                 all_nullary = false;\n                 let arg_tys = self.parse_unspanned_seq(\n@@ -2883,7 +2900,7 @@ class parser {\n                         enum\");\n         }\n \n-        return enum_def({ variants: variants });\n+        return enum_def({ variants: variants, common: common_fields });\n     }\n \n     fn parse_item_enum() -> item_info {\n@@ -2905,12 +2922,13 @@ class parser {\n                          id: self.get_id(),\n                          disr_expr: none,\n                          vis: public});\n-            return (id, item_enum(enum_def({ variants: ~[variant] }),\n+            return (id, item_enum(enum_def({ variants: ~[variant],\n+                                             common: none }),\n                                   ty_params), none);\n         }\n         self.expect(token::LBRACE);\n \n-        let enum_definition = self.parse_enum_def(ty_params);\n+        let enum_definition = self.parse_enum_def(id, ty_params);\n         (id, item_enum(enum_definition, ty_params), none)\n     }\n "}, {"sha": "c4feb893c10f993537c6a0f9fa19d097f096a7a0", "filename": "src/test/run-pass/common-fields-trivial.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/src%2Ftest%2Frun-pass%2Fcommon-fields-trivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf/src%2Ftest%2Frun-pass%2Fcommon-fields-trivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommon-fields-trivial.rs?ref=5c9c9a6a9fb81ea909da227752bec3dd9e5b3caf", "patch": "@@ -0,0 +1,14 @@\n+enum Foo {\n+    struct {\n+        x: int;\n+        y: int;\n+    }\n+\n+    Bar(int),\n+    Baz(int)\n+}\n+\n+fn main() {\n+    let x = Bar(3);\n+}\n+"}]}