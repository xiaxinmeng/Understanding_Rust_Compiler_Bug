{"sha": "54831f128fac3ad92bd7244aafaf52763452e51b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ODMxZjEyOGZhYzNhZDkyYmQ3MjQ0YWFmYWY1Mjc2MzQ1MmU1MWI=", "commit": {"author": {"name": "Tom Jakubowski", "email": "tom@crystae.net", "date": "2014-09-25T09:01:42Z"}, "committer": {"name": "Tom Jakubowski", "email": "tom@crystae.net", "date": "2014-09-29T13:38:47Z"}, "message": "rustdoc: Render where clauses as appropriate\n\nFix #16546", "tree": {"sha": "878de5d05e462280d83b52f548e6ed3ce483dd5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/878de5d05e462280d83b52f548e6ed3ce483dd5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54831f128fac3ad92bd7244aafaf52763452e51b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54831f128fac3ad92bd7244aafaf52763452e51b", "html_url": "https://github.com/rust-lang/rust/commit/54831f128fac3ad92bd7244aafaf52763452e51b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54831f128fac3ad92bd7244aafaf52763452e51b/comments", "author": {"login": "tomjakubowski", "id": 667901, "node_id": "MDQ6VXNlcjY2NzkwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/667901?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomjakubowski", "html_url": "https://github.com/tomjakubowski", "followers_url": "https://api.github.com/users/tomjakubowski/followers", "following_url": "https://api.github.com/users/tomjakubowski/following{/other_user}", "gists_url": "https://api.github.com/users/tomjakubowski/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomjakubowski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomjakubowski/subscriptions", "organizations_url": "https://api.github.com/users/tomjakubowski/orgs", "repos_url": "https://api.github.com/users/tomjakubowski/repos", "events_url": "https://api.github.com/users/tomjakubowski/events{/privacy}", "received_events_url": "https://api.github.com/users/tomjakubowski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tomjakubowski", "id": 667901, "node_id": "MDQ6VXNlcjY2NzkwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/667901?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tomjakubowski", "html_url": "https://github.com/tomjakubowski", "followers_url": "https://api.github.com/users/tomjakubowski/followers", "following_url": "https://api.github.com/users/tomjakubowski/following{/other_user}", "gists_url": "https://api.github.com/users/tomjakubowski/gists{/gist_id}", "starred_url": "https://api.github.com/users/tomjakubowski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tomjakubowski/subscriptions", "organizations_url": "https://api.github.com/users/tomjakubowski/orgs", "repos_url": "https://api.github.com/users/tomjakubowski/repos", "events_url": "https://api.github.com/users/tomjakubowski/events{/privacy}", "received_events_url": "https://api.github.com/users/tomjakubowski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e13d3aa00e8cfdf1a64f58f6c649460400231c0", "html_url": "https://github.com/rust-lang/rust/commit/5e13d3aa00e8cfdf1a64f58f6c649460400231c0"}], "stats": {"total": 152, "additions": 131, "deletions": 21}, "files": [{"sha": "666be2debdaabd8fbac8e4d5759220f2ed7c06fc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=54831f128fac3ad92bd7244aafaf52763452e51b", "patch": "@@ -641,18 +641,35 @@ impl Clean<Option<Lifetime>> for ty::Region {\n     }\n }\n \n+#[deriving(Clone, Encodable, Decodable, PartialEq)]\n+pub struct WherePredicate {\n+    pub name: String,\n+    pub bounds: Vec<TyParamBound>\n+}\n+\n+impl Clean<WherePredicate> for ast::WherePredicate {\n+    fn clean(&self, cx: &DocContext) -> WherePredicate {\n+        WherePredicate {\n+            name: self.ident.clean(cx),\n+            bounds: self.bounds.clean(cx)\n+        }\n+    }\n+}\n+\n // maybe use a Generic enum and use ~[Generic]?\n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,\n     pub type_params: Vec<TyParam>,\n+    pub where_predicates: Vec<WherePredicate>\n }\n \n impl Clean<Generics> for ast::Generics {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         Generics {\n             lifetimes: self.lifetimes.clean(cx),\n             type_params: self.ty_params.clean(cx),\n+            where_predicates: self.where_clause.predicates.clean(cx)\n         }\n     }\n }\n@@ -663,6 +680,7 @@ impl<'a> Clean<Generics> for (&'a ty::Generics, subst::ParamSpace) {\n         Generics {\n             type_params: me.types.get_slice(space).to_vec().clean(cx),\n             lifetimes: me.regions.get_slice(space).to_vec().clean(cx),\n+            where_predicates: vec![]\n         }\n     }\n }\n@@ -1260,7 +1278,9 @@ impl Clean<Type> for ty::t {\n             ty::ty_bare_fn(ref fty) => BareFunction(box BareFunctionDecl {\n                 fn_style: fty.fn_style,\n                 generics: Generics {\n-                    lifetimes: Vec::new(), type_params: Vec::new()\n+                    lifetimes: Vec::new(),\n+                    type_params: Vec::new(),\n+                    where_predicates: Vec::new()\n                 },\n                 decl: (ast_util::local_def(0), &fty.sig).clean(cx),\n                 abi: fty.abi.to_string(),\n@@ -1670,6 +1690,7 @@ impl Clean<BareFunctionDecl> for ast::BareFnTy {\n             generics: Generics {\n                 lifetimes: self.lifetimes.clean(cx),\n                 type_params: Vec::new(),\n+                where_predicates: Vec::new()\n             },\n             decl: self.decl.clean(cx),\n             abi: self.abi.to_string(),\n@@ -2172,6 +2193,7 @@ impl Clean<Item> for ast::Typedef {\n                 generics: Generics {\n                     lifetimes: Vec::new(),\n                     type_params: Vec::new(),\n+                    where_predicates: Vec::new()\n                 },\n             }),\n             visibility: None,"}, {"sha": "947d9f05ae2bba0cdc0915b0547ffd36cf809488", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=54831f128fac3ad92bd7244aafaf52763452e51b", "patch": "@@ -44,6 +44,11 @@ pub struct RawMutableSpace(pub clean::Mutability);\n pub struct Stability<'a>(pub &'a Option<clean::Stability>);\n /// Wrapper struct for emitting the stability level concisely.\n pub struct ConciseStability<'a>(pub &'a Option<clean::Stability>);\n+/// Wrapper struct for emitting a where clause from Generics.\n+pub struct WhereClause<'a>(pub &'a clean::Generics);\n+\n+/// Wrapper struct for emitting type parameter bounds.\n+struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n \n impl VisSpace {\n     pub fn get(&self) -> Option<ast::Visibility> {\n@@ -57,6 +62,19 @@ impl FnStyleSpace {\n     }\n }\n \n+impl<'a> fmt::Show for TyParamBounds<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let &TyParamBounds(bounds) = self;\n+        for (i, bound) in bounds.iter().enumerate() {\n+            if i > 0 {\n+                try!(f.write(\" + \".as_bytes()));\n+            }\n+            try!(write!(f, \"{}\", *bound));\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl fmt::Show for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n@@ -73,21 +91,14 @@ impl fmt::Show for clean::Generics {\n             if self.lifetimes.len() > 0 {\n                 try!(f.write(\", \".as_bytes()));\n             }\n-\n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n                     try!(f.write(\", \".as_bytes()))\n                 }\n                 try!(f.write(tp.name.as_bytes()));\n \n                 if tp.bounds.len() > 0 {\n-                    try!(f.write(\": \".as_bytes()));\n-                    for (i, bound) in tp.bounds.iter().enumerate() {\n-                        if i > 0 {\n-                            try!(f.write(\" + \".as_bytes()));\n-                        }\n-                        try!(write!(f, \"{}\", *bound));\n-                    }\n+                    try!(write!(f, \": {}\", TyParamBounds(tp.bounds.as_slice())));\n                 }\n \n                 match tp.default {\n@@ -101,6 +112,24 @@ impl fmt::Show for clean::Generics {\n     }\n }\n \n+impl<'a> fmt::Show for WhereClause<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let &WhereClause(gens) = self;\n+        if gens.where_predicates.len() == 0 {\n+            return Ok(());\n+        }\n+        try!(f.write(\" where \".as_bytes()));\n+        for (i, pred) in gens.where_predicates.iter().enumerate() {\n+            if i > 0 {\n+                try!(f.write(\", \".as_bytes()));\n+            }\n+            let bounds = pred.bounds.as_slice();\n+            try!(write!(f, \"{}: {}\", pred.name, TyParamBounds(bounds)));\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl fmt::Show for clean::Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(f.write(self.get_ref().as_bytes()));"}, {"sha": "3bd92db54e29d57d99e0c02126224a05e9c0702d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=54831f128fac3ad92bd7244aafaf52763452e51b", "patch": "@@ -56,7 +56,7 @@ use clean;\n use doctree;\n use fold::DocFolder;\n use html::format::{VisSpace, Method, FnStyleSpace, MutableSpace, Stability};\n-use html::format::{ConciseStability};\n+use html::format::{ConciseStability, WhereClause};\n use html::highlight;\n use html::item_type::{ItemType, shortty};\n use html::item_type;\n@@ -1609,11 +1609,12 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust fn'>{vis}{fn_style}fn \\\n-                    {name}{generics}{decl}</pre>\",\n+                    {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(it.visibility),\n            fn_style = FnStyleSpace(f.fn_style),\n            name = it.name.get_ref().as_slice(),\n            generics = f.generics,\n+           where_clause = WhereClause(&f.generics),\n            decl = f.decl));\n     document(w, it)\n }\n@@ -1630,11 +1631,12 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }\n \n     // Output the trait definition\n-    try!(write!(w, \"<pre class='rust trait'>{}trait {}{}{} \",\n+    try!(write!(w, \"<pre class='rust trait'>{}trait {}{}{}{} \",\n                   VisSpace(it.visibility),\n                   it.name.get_ref().as_slice(),\n                   t.generics,\n-                  bounds));\n+                  bounds,\n+                  WhereClause(&t.generics)));\n     let required = t.items.iter()\n                           .filter(|m| {\n                               match **m {\n@@ -1718,9 +1720,9 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     match cache.implementors.find(&it.def_id) {\n         Some(implementors) => {\n             for i in implementors.iter() {\n-                try!(writeln!(w, \"<li>{}<code>impl{} {} for {}</code></li>\",\n+                try!(writeln!(w, \"<li>{}<code>impl{} {} for {}{}</code></li>\",\n                               ConciseStability(&i.stability),\n-                              i.generics, i.trait_, i.for_));\n+                              i.generics, i.trait_, i.for_, WhereClause(&i.generics)));\n             }\n         }\n         None => {}\n@@ -1746,15 +1748,16 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n            g: &clean::Generics, selfty: &clean::SelfTy,\n            d: &clean::FnDecl) -> fmt::Result {\n         write!(w, \"{}fn <a href='#{ty}.{name}' class='fnname'>{name}</a>\\\n-                   {generics}{decl}\",\n+                   {generics}{decl}{where_clause}\",\n                match fn_style {\n                    ast::UnsafeFn => \"unsafe \",\n                    _ => \"\",\n                },\n                ty = shortty(it),\n                name = it.name.get_ref().as_slice(),\n                generics = *g,\n-               decl = Method(selfty, d))\n+               decl = Method(selfty, d),\n+               where_clause = WhereClause(g))\n     }\n     match meth.inner {\n         clean::TyMethodItem(ref m) => {\n@@ -1809,10 +1812,11 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n \n fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n-    try!(write!(w, \"<pre class='rust enum'>{}enum {}{}\",\n+    try!(write!(w, \"<pre class='rust enum'>{}enum {}{}{}\",\n                   VisSpace(it.visibility),\n                   it.name.get_ref().as_slice(),\n-                  e.generics));\n+                  e.generics,\n+                  WhereClause(&e.generics)));\n     if e.variants.len() == 0 && !e.variants_stripped {\n         try!(write!(w, \" {{}}\"));\n     } else {\n@@ -1916,7 +1920,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                   if structhead {\"struct \"} else {\"\"},\n                   it.name.get_ref().as_slice()));\n     match g {\n-        Some(g) => try!(write!(w, \"{}\", *g)),\n+        Some(g) => try!(write!(w, \"{}{}\", *g, WhereClause(g))),\n         None => {}\n     }\n     match ty {\n@@ -2008,7 +2012,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n         Some(ref ty) => try!(write!(w, \"{} for \", *ty)),\n         None => {}\n     }\n-    try!(write!(w, \"{}</code></h3>\", i.impl_.for_));\n+    try!(write!(w, \"{}{}</code></h3>\", i.impl_.for_, WhereClause(&i.impl_.generics)));\n     match i.dox {\n         Some(ref dox) => {\n             try!(write!(w, \"<div class='docblock'>{}</div>\","}, {"sha": "864d594cf99637fb0ad01be0c173ecae29b445e7", "filename": "src/test/run-make/rustdoc-where/Makefile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Ftest%2Frun-make%2Frustdoc-where%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Ftest%2Frun-make%2Frustdoc-where%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-where%2FMakefile?ref=54831f128fac3ad92bd7244aafaf52763452e51b", "patch": "@@ -0,0 +1,6 @@\n+-include ../tools.mk\n+\n+all: verify.sh foo.rs\n+\t$(HOST_RPATH_ENV) $(RUSTDOC) -w html -o $(TMPDIR)/doc foo.rs\n+\tcp verify.sh $(TMPDIR)\n+\t$(call RUN,verify.sh) $(TMPDIR)"}, {"sha": "7e6df7f011ab771c5b0fa09d2900dc8ee60d0111", "filename": "src/test/run-make/rustdoc-where/foo.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Ftest%2Frun-make%2Frustdoc-where%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Ftest%2Frun-make%2Frustdoc-where%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-where%2Ffoo.rs?ref=54831f128fac3ad92bd7244aafaf52763452e51b", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait MyTrait {}\n+\n+pub struct Alpha<A> where A: MyTrait;\n+pub trait Bravo<B> where B: MyTrait {}\n+pub fn charlie<C>() where C: MyTrait {}\n+\n+pub struct Delta<D>;\n+impl<D> Delta<D> where D: MyTrait {\n+    pub fn delta() {}\n+}\n+\n+pub struct Echo<E>;\n+impl<E> MyTrait for Echo<E> where E: MyTrait {}\n+\n+pub enum Foxtrot<F> {}\n+impl<F> MyTrait for Foxtrot<F> where F: MyTrait {}"}, {"sha": "5d424da02adb96eef0f579d9db2ea4dd1d9b6baf", "filename": "src/test/run-make/rustdoc-where/verify.sh", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Ftest%2Frun-make%2Frustdoc-where%2Fverify.sh", "raw_url": "https://github.com/rust-lang/rust/raw/54831f128fac3ad92bd7244aafaf52763452e51b/src%2Ftest%2Frun-make%2Frustdoc-where%2Fverify.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-where%2Fverify.sh?ref=54831f128fac3ad92bd7244aafaf52763452e51b", "patch": "@@ -0,0 +1,23 @@\n+#!/bin/bash\n+set -e\n+\n+# $1 is the TMPDIR\n+DOC=$1/doc/foo\n+\n+grep \"Alpha.*where.*A:.*MyTrait\" $DOC/struct.Alpha.html > /dev/null\n+echo \"Alpha\"\n+grep \"Bravo.*where.*B:.*MyTrait\" $DOC/trait.Bravo.html > /dev/null\n+echo \"Bravo\"\n+grep \"charlie.*where.*C:.*MyTrait\" $DOC/fn.charlie.html > /dev/null\n+echo \"Charlie\"\n+grep \"impl.*Delta.*where.*D:.*MyTrait\" $DOC/struct.Delta.html > /dev/null\n+echo \"Delta\"\n+grep \"impl.*MyTrait.*for.*Echo.*where.*E:.*MyTrait\" $DOC/struct.Echo.html > /dev/null\n+echo \"Echo\"\n+grep \"impl.*MyTrait.*for.*Foxtrot.*where.*F:.*MyTrait\" $DOC/enum.Foxtrot.html > /dev/null\n+echo \"Foxtrot\"\n+\n+# check \"Implementors\" section of MyTrait\n+grep \"impl.*MyTrait.*for.*Echo.*where.*E:.*MyTrait\" $DOC/trait.MyTrait.html > /dev/null\n+grep \"impl.*MyTrait.*for.*Foxtrot.*where.*F:.*MyTrait\" $DOC/trait.MyTrait.html > /dev/null\n+echo \"Implementors OK\""}]}