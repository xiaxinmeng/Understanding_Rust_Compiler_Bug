{"sha": "cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMTllMzM4MGI0YjdjNjNiNmYxZjc5ZDFkZmMyMTNlYTAwZTE2Y2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-20T20:00:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-20T20:00:36Z"}, "message": "auto merge of #19903 : cgaebel/rust/ringbuf-as-slice, r=Gankro\n\nSee: https://github.com/rust-lang/rfcs/pull/509\n\nNot sure if this is allowed to land before the RFC. Either way,\nit's here for review.\n\nr? @Gankro\ncc: @bfops", "tree": {"sha": "ee49930dbe4843c652894dd46c877ba69f857353", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee49930dbe4843c652894dd46c877ba69f857353"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf", "html_url": "https://github.com/rust-lang/rust/commit/cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "html_url": "https://github.com/rust-lang/rust/commit/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0"}, {"sha": "525f65ebbf67283c13e3cd25c44e95f64fbc57c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/525f65ebbf67283c13e3cd25c44e95f64fbc57c9", "html_url": "https://github.com/rust-lang/rust/commit/525f65ebbf67283c13e3cd25c44e95f64fbc57c9"}], "stats": {"total": 113, "additions": 111, "deletions": 2}, "files": [{"sha": "c807ef611e2ca07d0f56d5e56b81394d40004382", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 111, "deletions": 2, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=cc19e3380b4b7c63b6f1f79d1dfc213ea00e16cf", "patch": "@@ -78,7 +78,13 @@ impl<T> Default for RingBuf<T> {\n impl<T> RingBuf<T> {\n     /// Turn ptr into a slice\n     #[inline]\n-    unsafe fn buffer_as_slice(&self) -> &[T] {\n+    unsafe fn buffer_as_slice<'a>(&'a self) -> &'a [T] {\n+        mem::transmute(RawSlice { data: self.ptr as *const T, len: self.cap })\n+    }\n+\n+    /// Turn ptr into a mut slice\n+    #[inline]\n+    unsafe fn buffer_as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         mem::transmute(RawSlice { data: self.ptr as *const T, len: self.cap })\n     }\n \n@@ -413,6 +419,48 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n+    /// Returns a pair of slices which contain, in order, the contents of the\n+    /// `RingBuf`.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn as_slices<'a>(&'a self) -> (&'a [T], &'a [T]) {\n+        unsafe {\n+            let contiguous = self.is_contiguous();\n+            let buf = self.buffer_as_slice();\n+            if contiguous {\n+                let (empty, buf) = buf.split_at(0);\n+                (buf[self.tail..self.head], empty)\n+            } else {\n+                let (mid, right) = buf.split_at(self.tail);\n+                let (left, _) = mid.split_at(self.head);\n+                (right, left)\n+            }\n+        }\n+    }\n+\n+    /// Returns a pair of slices which contain, in order, the contents of the\n+    /// `RingBuf`.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n+        unsafe {\n+            let contiguous = self.is_contiguous();\n+            let head = self.head;\n+            let tail = self.tail;\n+            let buf = self.buffer_as_mut_slice();\n+\n+            if contiguous {\n+                let (empty, buf) = buf.split_at_mut(0);\n+                (buf[mut tail..head], empty)\n+            } else {\n+                let (mid, right) = buf.split_at_mut(tail);\n+                let (left, _) = mid.split_at_mut(head);\n+\n+                (right, left)\n+            }\n+        }\n+    }\n+\n     /// Returns the number of elements in the `RingBuf`.\n     ///\n     /// # Examples\n@@ -663,6 +711,11 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n+    #[inline]\n+    fn is_contiguous(&self) -> bool {\n+        self.tail <= self.head\n+    }\n+\n     /// Inserts an element at position `i` within the ringbuf. Whichever\n     /// end is closer to the insertion point will be moved to make room,\n     /// and all the affected elements will be moved to new positions.\n@@ -715,7 +768,7 @@ impl<T> RingBuf<T> {\n         let distance_to_tail = i;\n         let distance_to_head = self.len() - i;\n \n-        let contiguous = self.tail <= self.head;\n+        let contiguous = self.is_contiguous();\n \n         match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n             (true, true, _) if i == 0 => {\n@@ -2131,4 +2184,60 @@ mod tests {\n         ring.pop_front();\n         assert_eq!(ring.front(), None);\n     }\n+\n+    #[test]\n+    fn test_as_slices() {\n+        let mut ring: RingBuf<int> = RingBuf::with_capacity(127);\n+        let cap = ring.capacity() as int;\n+        let first = cap/2;\n+        let last  = cap - first;\n+        for i in range(0, first) {\n+            ring.push_back(i);\n+\n+            let (left, right) = ring.as_slices();\n+            let expected: Vec<_> = range(0, i+1).collect();\n+            assert_eq!(left, expected);\n+            assert_eq!(right, []);\n+        }\n+\n+        for j in range(-last, 0) {\n+            ring.push_front(j);\n+            let (left, right) = ring.as_slices();\n+            let expected_left: Vec<_> = range(-last, j+1).rev().collect();\n+            let expected_right: Vec<_> = range(0, first).collect();\n+            assert_eq!(left, expected_left);\n+            assert_eq!(right, expected_right);\n+        }\n+\n+        assert_eq!(ring.len() as int, cap);\n+        assert_eq!(ring.capacity() as int, cap);\n+    }\n+\n+    #[test]\n+    fn test_as_mut_slices() {\n+        let mut ring: RingBuf<int> = RingBuf::with_capacity(127);\n+        let cap = ring.capacity() as int;\n+        let first = cap/2;\n+        let last  = cap - first;\n+        for i in range(0, first) {\n+            ring.push_back(i);\n+\n+            let (left, right) = ring.as_mut_slices();\n+            let expected: Vec<_> = range(0, i+1).collect();\n+            assert_eq!(left, expected);\n+            assert_eq!(right, []);\n+        }\n+\n+        for j in range(-last, 0) {\n+            ring.push_front(j);\n+            let (left, right) = ring.as_mut_slices();\n+            let expected_left: Vec<_> = range(-last, j+1).rev().collect();\n+            let expected_right: Vec<_> = range(0, first).collect();\n+            assert_eq!(left, expected_left);\n+            assert_eq!(right, expected_right);\n+        }\n+\n+        assert_eq!(ring.len() as int, cap);\n+        assert_eq!(ring.capacity() as int, cap);\n+    }\n }"}]}