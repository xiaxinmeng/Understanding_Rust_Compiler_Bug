{"sha": "3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiY2Y2N2MyY2I0NmM4Y2JkYzM0ZTdlYmU4ZDhhYjRlMWFiN2EyYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-05T08:29:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-05T08:29:25Z"}, "message": "Auto merge of #3610 - phansch:method_rs_cleanup, r=flip1995\n\nUI test cleanup: Extract lint from methods.rs test\n\nExtracts the `result_map_unwrap_or_else` lint into a separate test file.\n\nThis also extracts the `IteratorFalsePositives` struct and impl into\n`auxiliary/option_helpers.rs`.\n\ncc #2038", "tree": {"sha": "e546de64936e89a0a845f9f7f32572bc304378f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e546de64936e89a0a845f9f7f32572bc304378f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "html_url": "https://github.com/rust-lang/rust/commit/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "488b8c5f6ff18d493bbd9ab95967ac38c3db3c6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/488b8c5f6ff18d493bbd9ab95967ac38c3db3c6d", "html_url": "https://github.com/rust-lang/rust/commit/488b8c5f6ff18d493bbd9ab95967ac38c3db3c6d"}, {"sha": "a5d3f37c5aaaaa9bc7b327ec240adf3d421ad610", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5d3f37c5aaaaa9bc7b327ec240adf3d421ad610", "html_url": "https://github.com/rust-lang/rust/commit/a5d3f37c5aaaaa9bc7b327ec240adf3d421ad610"}], "stats": {"total": 323, "additions": 154, "deletions": 169}, "files": [{"sha": "33195211968997b0794ee583e7f8f430aafbb1c6", "filename": "tests/ui/auxiliary/option_helpers.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fauxiliary%2Foption_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fauxiliary%2Foption_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Foption_helpers.rs?ref=3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "patch": "@@ -0,0 +1,47 @@\n+#![allow(dead_code, unused_variables)]\n+\n+/// Utility macro to test linting behavior in `option_methods()`\n+/// The lints included in `option_methods()` should not lint if the call to map is partially\n+/// within a macro\n+#[macro_export]\n+macro_rules! opt_map {\n+    ($opt:expr, $map:expr) => {\n+        ($opt).map($map)\n+    };\n+}\n+\n+/// Struct to generate false positive for Iterator-based lints\n+#[derive(Copy, Clone)]\n+pub struct IteratorFalsePositives {\n+    pub foo: u32,\n+}\n+\n+impl IteratorFalsePositives {\n+    pub fn filter(self) -> IteratorFalsePositives {\n+        self\n+    }\n+\n+    pub fn next(self) -> IteratorFalsePositives {\n+        self\n+    }\n+\n+    pub fn find(self) -> Option<u32> {\n+        Some(self.foo)\n+    }\n+\n+    pub fn position(self) -> Option<u32> {\n+        Some(self.foo)\n+    }\n+\n+    pub fn rposition(self) -> Option<u32> {\n+        Some(self.foo)\n+    }\n+\n+    pub fn nth(self, n: usize) -> Option<u32> {\n+        Some(self.foo)\n+    }\n+\n+    pub fn skip(self, _: usize) -> IteratorFalsePositives {\n+        self\n+    }\n+}"}, {"sha": "0b9d2c368277187c2e0a9a6d69fa30d5fed92695", "filename": "tests/ui/iter_skip_next.rs", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fiter_skip_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fiter_skip_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_skip_next.rs?ref=3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "patch": "@@ -7,44 +7,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// aux-build:option_helpers.rs\n+\n #![warn(clippy::iter_skip_next)]\n #![allow(clippy::blacklisted_name)]\n \n-/// Struct to generate false positive for Iterator-based lints\n-#[derive(Copy, Clone)]\n-struct IteratorFalsePositives {\n-    foo: u32,\n-}\n-\n-impl IteratorFalsePositives {\n-    fn filter(self) -> IteratorFalsePositives {\n-        self\n-    }\n-\n-    fn next(self) -> IteratorFalsePositives {\n-        self\n-    }\n-\n-    fn find(self) -> Option<u32> {\n-        Some(self.foo)\n-    }\n+extern crate option_helpers;\n \n-    fn position(self) -> Option<u32> {\n-        Some(self.foo)\n-    }\n-\n-    fn rposition(self) -> Option<u32> {\n-        Some(self.foo)\n-    }\n-\n-    fn nth(self, n: usize) -> Option<u32> {\n-        Some(self.foo)\n-    }\n-\n-    fn skip(self, _: usize) -> IteratorFalsePositives {\n-        self\n-    }\n-}\n+use option_helpers::IteratorFalsePositives;\n \n /// Checks implementation of `ITER_SKIP_NEXT` lint\n fn iter_skip_next() {"}, {"sha": "037c33fbc3df491c8f3928a65a784baabc1b5717", "filename": "tests/ui/iter_skip_next.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fiter_skip_next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fiter_skip_next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_skip_next.stderr?ref=3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "patch": "@@ -1,25 +1,25 @@\n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-  --> $DIR/iter_skip_next.rs:52:13\n+  --> $DIR/iter_skip_next.rs:22:13\n    |\n LL |     let _ = some_vec.iter().skip(42).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::iter-skip-next` implied by `-D warnings`\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-  --> $DIR/iter_skip_next.rs:53:13\n+  --> $DIR/iter_skip_next.rs:23:13\n    |\n LL |     let _ = some_vec.iter().cycle().skip(42).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-  --> $DIR/iter_skip_next.rs:54:13\n+  --> $DIR/iter_skip_next.rs:24:13\n    |\n LL |     let _ = (1..10).skip(10).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-  --> $DIR/iter_skip_next.rs:55:14\n+  --> $DIR/iter_skip_next.rs:25:14\n    |\n LL |     let _ = &some_vec[..].iter().skip(3).next();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "fa99205d69a6824b5439c343e1718c46e1a62d6e", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 7, "deletions": 66, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "patch": "@@ -7,6 +7,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// aux-build:option_helpers.rs\n+\n #![warn(clippy::all, clippy::pedantic, clippy::option_unwrap_used)]\n #![allow(\n     clippy::blacklisted_name,\n@@ -22,6 +24,9 @@\n     clippy::useless_format\n )]\n \n+#[macro_use]\n+extern crate option_helpers;\n+\n use std::collections::BTreeMap;\n use std::collections::HashMap;\n use std::collections::HashSet;\n@@ -31,6 +36,8 @@ use std::iter::FromIterator;\n use std::rc::{self, Rc};\n use std::sync::{self, Arc};\n \n+use option_helpers::IteratorFalsePositives;\n+\n pub struct T;\n \n impl T {\n@@ -101,13 +108,6 @@ impl Mul<T> for T {\n     fn mul(self, other: T) -> T { self } // no error, obviously\n }\n \n-/// Utility macro to test linting behavior in `option_methods()`\n-/// The lints included in `option_methods()` should not lint if the call to map is partially\n-/// within a macro\n-macro_rules! opt_map {\n-    ($opt:expr, $map:expr) => {($opt).map($map)};\n-}\n-\n /// Checks implementation of the following lints:\n /// * `OPTION_MAP_UNWRAP_OR`\n /// * `OPTION_MAP_UNWRAP_OR_ELSE`\n@@ -169,29 +169,6 @@ fn option_methods() {\n                 );\n }\n \n-/// Checks implementation of the following lints:\n-/// * `RESULT_MAP_UNWRAP_OR_ELSE`\n-fn result_methods() {\n-    let res: Result<i32, ()> = Ok(1);\n-\n-    // Check RESULT_MAP_UNWRAP_OR_ELSE\n-    // single line case\n-    let _ = res.map(|x| x + 1)\n-\n-               .unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-    // multi line cases\n-    let _ = res.map(|x| {\n-                        x + 1\n-                    }\n-              ).unwrap_or_else(|e| 0);\n-    let _ = res.map(|x| x + 1)\n-               .unwrap_or_else(|e|\n-                    0\n-                );\n-    // macro case\n-    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|e| 0); // should not lint\n-}\n-\n /// Struct to generate false positives for things with .iter()\n #[derive(Copy, Clone)]\n struct HasIter;\n@@ -206,42 +183,6 @@ impl HasIter {\n     }\n }\n \n-/// Struct to generate false positive for Iterator-based lints\n-#[derive(Copy, Clone)]\n-struct IteratorFalsePositives {\n-    foo: u32,\n-}\n-\n-impl IteratorFalsePositives {\n-    fn filter(self) -> IteratorFalsePositives {\n-        self\n-    }\n-\n-    fn next(self) -> IteratorFalsePositives {\n-        self\n-    }\n-\n-    fn find(self) -> Option<u32> {\n-        Some(self.foo)\n-    }\n-\n-    fn position(self) -> Option<u32> {\n-        Some(self.foo)\n-    }\n-\n-    fn rposition(self) -> Option<u32> {\n-        Some(self.foo)\n-    }\n-\n-    fn nth(self, n: usize) -> Option<u32> {\n-        Some(self.foo)\n-    }\n-\n-    fn skip(self, _: usize) -> IteratorFalsePositives {\n-        self\n-    }\n-}\n-\n /// Checks implementation of `FILTER_NEXT` lint\n fn filter_next() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];"}, {"sha": "ef3a4e2a423b1253b3b129ef07fb52bdb9114844", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 33, "deletions": 65, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "patch": "@@ -1,27 +1,27 @@\n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:37:5\n+  --> $DIR/methods.rs:44:5\n    |\n LL |     pub fn add(self, other: T) -> T { self }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:48:17\n+  --> $DIR/methods.rs:55:17\n    |\n LL |     fn into_u16(&self) -> u16 { 0 }\n    |                 ^^^^^\n    |\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:50:21\n+  --> $DIR/methods.rs:57:21\n    |\n LL |     fn to_something(self) -> u32 { 0 }\n    |                     ^^^^\n \n error: methods called `new` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:52:12\n+  --> $DIR/methods.rs:59:12\n    |\n LL |     fn new(self) -> Self { unimplemented!(); }\n    |            ^^^^\n@@ -143,40 +143,8 @@ LL |                         Some(x + 1)\n LL |                        });\n    |\n \n-error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:179:13\n-   |\n-LL |       let _ = res.map(|x| x + 1)\n-   |  _____________^\n-LL | |\n-LL | |                .unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n-   | |_____________________________________^\n-   |\n-   = note: `-D clippy::result-map-unwrap-or-else` implied by `-D warnings`\n-   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `ok().map_or_else(|e| 0, |x| x + 1)`\n-\n-error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:183:13\n-   |\n-LL |       let _ = res.map(|x| {\n-   |  _____________^\n-LL | |                         x + 1\n-LL | |                     }\n-LL | |               ).unwrap_or_else(|e| 0);\n-   | |_____________________________________^\n-\n-error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:187:13\n-   |\n-LL |       let _ = res.map(|x| x + 1)\n-   |  _____________^\n-LL | |                .unwrap_or_else(|e|\n-LL | |                     0\n-LL | |                 );\n-   | |_________________^\n-\n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:250:13\n+  --> $DIR/methods.rs:191:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -185,7 +153,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:253:13\n+  --> $DIR/methods.rs:194:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -195,7 +163,7 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:268:13\n+  --> $DIR/methods.rs:209:13\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -204,7 +172,7 @@ LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    = note: replace `find(|&x| *x < 0).is_some()` with `any(|&x| *x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:271:13\n+  --> $DIR/methods.rs:212:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -214,15 +182,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:277:13\n+  --> $DIR/methods.rs:218:13\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `position(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:280:13\n+  --> $DIR/methods.rs:221:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -232,15 +200,15 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:286:13\n+  --> $DIR/methods.rs:227:13\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `rposition(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:289:13\n+  --> $DIR/methods.rs:230:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -250,130 +218,130 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:324:22\n+  --> $DIR/methods.rs:265:22\n    |\n LL |     with_constructor.unwrap_or(make());\n    |                      ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(make)`\n    |\n    = note: `-D clippy::or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a call to `new`\n-  --> $DIR/methods.rs:327:5\n+  --> $DIR/methods.rs:268:5\n    |\n LL |     with_new.unwrap_or(Vec::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_new.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:330:21\n+  --> $DIR/methods.rs:271:21\n    |\n LL |     with_const_args.unwrap_or(Vec::with_capacity(12));\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:333:14\n+  --> $DIR/methods.rs:274:14\n    |\n LL |     with_err.unwrap_or(make());\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| make())`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:336:19\n+  --> $DIR/methods.rs:277:19\n    |\n LL |     with_err_args.unwrap_or(Vec::with_capacity(12));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/methods.rs:339:5\n+  --> $DIR/methods.rs:280:5\n    |\n LL |     with_default_trait.unwrap_or(Default::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_trait.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/methods.rs:342:5\n+  --> $DIR/methods.rs:283:5\n    |\n LL |     with_default_type.unwrap_or(u64::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_type.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:345:14\n+  --> $DIR/methods.rs:286:14\n    |\n LL |     with_vec.unwrap_or(vec![]);\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| vec![])`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:350:21\n+  --> $DIR/methods.rs:291:21\n    |\n LL |     without_default.unwrap_or(Foo::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(Foo::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/methods.rs:353:19\n+  --> $DIR/methods.rs:294:19\n    |\n LL |     map.entry(42).or_insert(String::new());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/methods.rs:356:21\n+  --> $DIR/methods.rs:297:21\n    |\n LL |     btree.entry(42).or_insert(String::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/methods.rs:359:21\n+  --> $DIR/methods.rs:300:21\n    |\n LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n error: called `.iter().nth()` on a Vec. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:370:23\n+  --> $DIR/methods.rs:311:23\n    |\n LL |         let bad_vec = some_vec.iter().nth(3);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::iter-nth` implied by `-D warnings`\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:371:26\n+  --> $DIR/methods.rs:312:26\n    |\n LL |         let bad_slice = &some_vec[..].iter().nth(3);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:372:31\n+  --> $DIR/methods.rs:313:31\n    |\n LL |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a VecDeque. Calling `.get()` is both faster and more readable\n-  --> $DIR/methods.rs:373:29\n+  --> $DIR/methods.rs:314:29\n    |\n LL |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a Vec. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:378:23\n+  --> $DIR/methods.rs:319:23\n    |\n LL |         let bad_vec = some_vec.iter_mut().nth(3);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a slice. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:381:26\n+  --> $DIR/methods.rs:322:26\n    |\n LL |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a VecDeque. Calling `.get_mut()` is both faster and more readable\n-  --> $DIR/methods.rs:384:29\n+  --> $DIR/methods.rs:325:29\n    |\n LL |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-  --> $DIR/methods.rs:396:13\n+  --> $DIR/methods.rs:337:13\n    |\n LL |     let _ = opt.unwrap();\n    |             ^^^^^^^^^^^^\n    |\n    = note: `-D clippy::option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 46 previous errors\n+error: aborting due to 43 previous errors\n "}, {"sha": "0481e4ec1b075bc45c62147d6a503fd86312bb20", "filename": "tests/ui/result_map_unwrap_or_else.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fresult_map_unwrap_or_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fresult_map_unwrap_or_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unwrap_or_else.rs?ref=3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014-2019 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:option_helpers.rs\n+\n+//! Checks implementation of `RESULT_MAP_UNWRAP_OR_ELSE`\n+\n+#![warn(clippy::result_map_unwrap_or_else)]\n+\n+#[macro_use]\n+extern crate option_helpers;\n+\n+fn result_methods() {\n+    let res: Result<i32, ()> = Ok(1);\n+\n+    // Check RESULT_MAP_UNWRAP_OR_ELSE\n+    // single line case\n+    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n+                                                      // multi line cases\n+    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n+    let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n+    // macro case\n+    let _ = opt_map!(res, |x| x + 1).unwrap_or_else(|e| 0); // should not lint\n+}\n+\n+fn main() {}"}, {"sha": "9f03de669e4c48003e4330664ee648b2e6d7ecdc", "filename": "tests/ui/result_map_unwrap_or_else.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fresult_map_unwrap_or_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3/tests%2Fui%2Fresult_map_unwrap_or_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unwrap_or_else.stderr?ref=3bcf67c2cb46c8cbdc34e7ebe8d8ab4e1ab7a2b3", "patch": "@@ -0,0 +1,27 @@\n+error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n+  --> $DIR/result_map_unwrap_or_else.rs:24:13\n+   |\n+LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0); // should lint even though this call is on a separate line\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::result-map-unwrap-or-else` implied by `-D warnings`\n+   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `ok().map_or_else(|e| 0, |x| x + 1)`\n+\n+error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n+  --> $DIR/result_map_unwrap_or_else.rs:26:13\n+   |\n+LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `ok().map_or_else(|e| 0, |x| x + 1)`\n+\n+error: called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling `ok().map_or_else(g, f)` instead\n+  --> $DIR/result_map_unwrap_or_else.rs:27:13\n+   |\n+LL |     let _ = res.map(|x| x + 1).unwrap_or_else(|e| 0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: replace `map(|x| x + 1).unwrap_or_else(|e| 0)` with `ok().map_or_else(|e| 0, |x| x + 1)`\n+\n+error: aborting due to 3 previous errors\n+"}]}