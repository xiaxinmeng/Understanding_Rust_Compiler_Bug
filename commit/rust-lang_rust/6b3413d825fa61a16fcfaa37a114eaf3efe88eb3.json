{"sha": "6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMzQxM2Q4MjVmYTYxYTE2ZmNmYWEzN2ExMTRlYWYzZWZlODhlYjM=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-05T12:41:27Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T17:23:57Z"}, "message": "Change code to work with the new system", "tree": {"sha": "ea7f6b3c83ef846e8fa3746864e7c6e724141680", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea7f6b3c83ef846e8fa3746864e7c6e724141680"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "html_url": "https://github.com/rust-lang/rust/commit/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "001e9f349087124165ed6deea6a87e0b158bba21", "url": "https://api.github.com/repos/rust-lang/rust/commits/001e9f349087124165ed6deea6a87e0b158bba21", "html_url": "https://github.com/rust-lang/rust/commit/001e9f349087124165ed6deea6a87e0b158bba21"}], "stats": {"total": 1640, "additions": 1394, "deletions": 246}, "files": [{"sha": "2fd02d3d7c48f6d2ab18ee233923a7a99eb46766", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 342, "deletions": 47, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "patch": "@@ -100,6 +100,8 @@ pub struct Linkcheck<'a> {\n \n impl<'a> Step<'a> for Linkcheck<'a> {\n     type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n \n     /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n     ///\n@@ -110,12 +112,27 @@ impl<'a> Step<'a> for Linkcheck<'a> {\n         let host = self.host;\n \n         println!(\"Linkcheck ({})\", host);\n-        let compiler = Compiler::new(0, host);\n+\n+        builder.default_doc(None);\n \n         let _time = util::timeit();\n-        try_run(build, build.tool_cmd(&compiler, \"linkchecker\")\n+        try_run(build, builder.tool_cmd(Tool::Linkchecker)\n                             .arg(build.out.join(host).join(\"doc\")));\n     }\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/tools/linkchecker\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, _target: &str) {\n+        if path.is_some() {\n+            builder.ensure(Linkcheck { host });\n+        } else {\n+            if builder.build.config.docs {\n+                builder.ensure(Linkcheck { host });\n+            }\n+        }\n+    }\n }\n \n // rules.test(\"check-cargotest\", \"src/tools/cargotest\")\n@@ -132,16 +149,16 @@ pub struct Cargotest<'a> {\n \n impl<'a> Step<'a> for Cargotest<'a> {\n     type Output = ();\n+    const ONLY_HOSTS: bool = true;\n \n     /// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n     ///\n     /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n     /// test` to ensure that we don't regress the test suites there.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = Compiler::new(stage, host);\n+        let compiler = builder.compiler(self.stage, host);\n+        builder.ensure(compile::Rustc { compiler, target: compiler.host });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n         // is currently to minimize the length of path on Windows where we otherwise\n@@ -150,8 +167,7 @@ impl<'a> Step<'a> for Cargotest<'a> {\n         t!(fs::create_dir_all(&out_dir));\n \n         let _time = util::timeit();\n-        let mut cmd = Command::new(build.tool(&Compiler::new(0, host), \"cargotest\"));\n-        build.prepare_tool_cmd(&compiler, &mut cmd);\n+        let mut cmd = builder.tool_cmd(Tool::CargoTest);\n         try_run(build, cmd.arg(&build.initial_cargo)\n                           .arg(&out_dir)\n                           .env(\"RUSTC\", build.compiler_path(&compiler))\n@@ -172,21 +188,34 @@ pub struct Cargo<'a> {\n \n impl<'a> Step<'a> for Cargo<'a> {\n     type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"cargo\") // FIXME: Why is this not src/tools/cargo?\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+        builder.ensure(TestCargo {\n+            compiler: builder.compiler(builder.top_stage, host),\n+            target,\n+        });\n+    }\n \n     /// Runs `cargo test` for `cargo` packaged with Rust.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let stage = self.stage;\n-        let ref compiler = Compiler::new(stage, host);\n+        let compiler = builder.compiler(self.stage, self.host);\n \n         // Configure PATH to find the right rustc. NB. we have to use PATH\n         // and not RUSTC because the Cargo test suite has tests that will\n         // fail if rustc is not spelled `rustc`.\n         let path = build.sysroot(compiler).join(\"bin\");\n         let old_path = env::var_os(\"PATH\").unwrap_or_default();\n-        let newpath = env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\");\n+        let newpath = env::join_paths(\n+            iter::once(path).chain(env::split_paths(&old_path))\n+        ).expect(\"\");\n \n-        let mut cargo = build.cargo(compiler, Mode::Tool, host, \"test\");\n+        let mut cargo = build.cargo(compiler, Mode::Tool, self.host, \"test\");\n         cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n         if !build.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n@@ -250,7 +279,6 @@ fn path_for_cargo(build: &Build, compiler: &Compiler) -> OsString {\n     try_run(build, cargo.env(\"PATH\", newpath));\n =======\n         try_run(build, cargo.env(\"PATH\", newpath));\n-        let host = self.host;\n     }\n >>>>>>> adabe3889e... Move code into Step trait implementations.\n }\n@@ -269,6 +297,9 @@ pub struct Tidy<'a> {\n \n impl<'a> Step<'a> for Tidy<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+    const ONLY_BUILD: bool = true;\n \n     /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n     ///\n@@ -281,8 +312,7 @@ impl<'a> Step<'a> for Tidy<'a> {\n \n         let _folder = build.fold_output(|| \"tidy\");\n         println!(\"tidy check ({})\", host);\n-        let compiler = Compiler::new(0, host);\n-        let mut cmd = build.tool_cmd(&compiler, \"tidy\");\n+        let mut cmd = build.tool_cmd(Tool::Tidy);\n         cmd.arg(build.src.join(\"src\"));\n         if !build.config.vendor {\n             cmd.arg(\"--no-vendor\");\n@@ -292,6 +322,16 @@ impl<'a> Step<'a> for Tidy<'a> {\n         }\n         try_run(build, &mut cmd);\n     }\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/tools/tidy\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, _target: &str) {\n+        builder.ensure(Tidy {\n+            host: &builder.build.build,\n+        });\n+    }\n }\n \n fn testdir(build: &Build, host: &str) -> PathBuf {\n@@ -404,8 +444,78 @@ pub struct Compiletest<'a> {\n     suite: &'a str,\n }\n \n+static COMPILETESTS: &[(bool, &str, &str, &str)] = &[\n+    // default, path, mode, suite\n+    (true, \"src/test/codegen\", \"codegen\", \"codegen\"),\n+    (true, \"src/test/codegen-units\", \"codegen-units\", \"codegen-units\"),\n+    (true, \"src/test/compile-fail\", \"compile-fail\", \"compile-fail\"),\n+    (true, \"src/test/incremental\", \"incremental\", \"incremental\"),\n+    (true, \"src/test/mir-opt\", \"mir-opt\", \"mir-opt\"),\n+    (true, \"src/test/parse-fail\", \"parse-fail\", \"parse-fail\"),\n+    (true, \"src/test/run-fail\", \"run-fail\", \"run-fail\"),\n+    (true, \"src/test/run-pass\", \"run-pass\", \"run-pass\"),\n+    (true, \"src/test/run-pass-valgrind\", \"run-pass-valgrind\", \"run-pass-valgrind\"),\n+    (true, \"src/test/ui\", \"ui\", \"ui\"),\n+    (false, \"src/test/debuginfo-lldb\", \"debuginfo-lldb\", \"debuginfo\"),\n+    (false, \"src/test/debuginfo-gdb\", \"debuginfo-gdb\", \"debuginfo\"),\n+\n+    // FIXME: What this runs varies depending on the native platform being apple\n+    (true, \"src/test/debuginfo\", \"debuginfo-XXX\", \"debuginfo\"),\n+\n+    (true, \"src/test/ui-fulldeps\", \"ui\", \"ui-fulldeps\"),\n+    (true, \"src/test/run-pass-fulldeps\", \"run-pass\", \"run-pass-fulldeps\"),\n+    (true, \"src/test/run-fail-fulldeps\", \"run-fail\", \"run-fail-fulldeps\"),\n+    (true, \"src/test/compile-fail-fulldeps\", \"compile-fail\", \"compile-fail-fulldeps\"),\n+    (true, \"src/test/run-make\", \"run-make\", \"run-make\"),\n+    (true, \"src/test/rustdoc\", \"rustdoc\", \"rustdoc\"),\n+\n+    (false, \"src/test/pretty\", \"pretty\", \"pretty\"),\n+    (false, \"src/test/run-pass/pretty\", \"pretty\", \"run-pass\"),\n+    (false, \"src/test/run-fail/pretty\", \"pretty\", \"run-fail\"),\n+    (false, \"src/test/run-pass-valgrind/pretty\", \"pretty\", \"run-pass-valgrind\"),\n+    (false, \"src/test/run-pass-fulldeps/pretty\", \"pretty\", \"run-pass-fulldeps\"),\n+    (false, \"src/test/run-fail-fulldeps/pretty\", \"pretty\", \"run-fail-fulldeps\"),\n+];\n+\n+\n impl<'a> Step<'a> for Compiletest<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        // Note that this is general, while a few more cases are skipped inside\n+        // run() itself. This is to avoid duplication across should_run and\n+        // make_run.\n+        COMPILETESTS.iter().any(|&(_, test_path, _, _)| {\n+            path.ends_with(test_path)\n+        })\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+        let compiler = builder.compiler(builder.top_stage, host);\n+\n+        let test = path.map(|path| {\n+            COMPILETESTS.iter().find(|&&(_, test_path, _, _)| {\n+                path.ends_with(test_path)\n+            }).unwrap_or_else(|| {\n+                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n+            })\n+        });\n+\n+        if let Some(test) = test { // specific test\n+            builder.ensure(Compiletest {\n+                compiler, target, mode: test.2, suite: test.3\n+            });\n+        } else { // default tests\n+            for &(default, _, mode, suite) in COMPILETESTS {\n+                if default {\n+                    builder.ensure(Compiletest {\n+                        compiler, target, mode, suite\n+                    });\n+                }\n+            }\n+        }\n+    }\n \n     /// Executes the `compiletest` tool to run a suite of tests.\n     ///\n@@ -418,12 +528,58 @@ impl<'a> Step<'a> for Compiletest<'a> {\n         let target = self.target;\n         let mode = self.mode;\n         let suite = self.suite;\n+\n+        // Skip codegen tests if they aren't enabled in configuration.\n+        if !build.config.codegen_tests && suite == \"codegen\" {\n+            return;\n+        }\n+\n+        if suite == \"debuginfo\" {\n+            if mode == \"debuginfo-XXX\" {\n+                return if build.build.contains(\"apple\") {\n+                    builder.ensure(Compiletest {\n+                        mode: \"debuginfo-lldb\",\n+                        ..self\n+                    })\n+                } else {\n+                    builder.ensure(Compiletest {\n+                        mode: \"debuginfo-gdb\",\n+                        ..self\n+                    })\n+                };\n+            }\n+\n+            // Skip debuginfo tests on MSVC\n+            if build.build.contains(\"msvc\") {\n+                return;\n+            }\n+\n+            builder.ensure(dist::DebuggerScripts {\n+                sysroot: &builder.sysroot(compiler),\n+                host: compiler.host\n+            });\n+        }\n+\n+        if suite.ends_with(\"fulldeps\") ||\n+            // FIXME: Does pretty need librustc compiled? Note that there are\n+            // fulldeps test suites with mode = pretty as well.\n+            mode == \"pretty\" ||\n+            mode == \"rustdoc\" ||\n+            mode == \"run-make\" {\n+            builder.ensure(compile::Rustc { compiler, target });\n+        }\n+\n+        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(native::TestHelpers { target });\n+\n+        if mode == \"debuginfo-gdb\" {\n+            builder.ensure(RemoteCopyLibs { compiler, target });\n+        }\n+\n         let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n         println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n                  suite, mode, compiler.host, target);\n-        let mut cmd = Command::new(build.tool(&Compiler::new(0, compiler.host),\n-                                              \"compiletest\"));\n-        build.prepare_tool_cmd(compiler, &mut cmd);\n+        let mut cmd = builder.tool_cmd(Tool::Compiletest);\n \n         // compiletest currently has... a lot of arguments, so let's just pass all\n         // of them!\n@@ -518,9 +674,7 @@ impl<'a> Step<'a> for Compiletest<'a> {\n         }\n \n         if build.remote_tested(target) {\n-            cmd.arg(\"--remote-test-client\")\n-               .arg(build.tool(&Compiler::new(0, &build.build),\n-                               \"remote-test-client\"));\n+            cmd.arg(\"--remote-test-client\").arg(builder.tool_exe(Tool::RemoteTestClient));\n         }\n \n         // Running a C compiler on MSVC requires a few env vars to be set, to be\n@@ -614,6 +768,18 @@ pub struct ErrorIndex<'a> {\n \n impl<'a> Step<'a> for ErrorIndex<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/tools/error_index_generator\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n+        builder.ensure(ErrorIndex {\n+            compiler: builder.compiler(builder.top_stage, host),\n+        });\n+    }\n \n     /// Run the error index generator tool to execute the tests located in the error\n     /// index.\n@@ -625,6 +791,8 @@ impl<'a> Step<'a> for ErrorIndex<'a> {\n         let build = builder.build;\n         let compiler = self.compiler;\n \n+        builder.ensure(compile::Std { compiler, target: compiler.host });\n+\n         let _folder = build.fold_output(|| \"test_error_index\");\n         println!(\"Testing error-index stage{}\", compiler.stage);\n \n@@ -633,8 +801,7 @@ impl<'a> Step<'a> for ErrorIndex<'a> {\n         let output = dir.join(\"error-index.md\");\n \n         let _time = util::timeit();\n-        build.run(build.tool_cmd(&Compiler::new(0, compiler.host),\n-                                \"error_index_generator\")\n+        build.run(build.tool_cmd(Tool::ErrorIndex)\n                     .arg(\"markdown\")\n                     .arg(&output)\n                     .env(\"CFG_BUILD\", &build.build));\n@@ -669,6 +836,86 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n     }\n }\n \n+//    for (krate, path, _default) in krates(\"rustc-main\") {\n+//        rules.test(&krate.test_step, path)\n+//             .dep(|s| s.name(\"librustc\"))\n+//             .dep(|s| s.name(\"remote-copy-libs\"))\n+//             .host(true)\n+//             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+//                                        Mode::Librustc, TestKind::Test,\n+//                                        Some(&krate.name)));\n+//    }\n+//    rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n+//         .dep(|s| s.name(\"librustc\"))\n+//         .dep(|s| s.name(\"remote-copy-libs\"))\n+//         .default(true)\n+//         .host(true)\n+//         .run(move |s| check::krate(build, &s.compiler(), s.target,\n+//                                    Mode::Librustc, TestKind::Test, None));\n+#[derive(Serialize)]\n+pub struct KrateLibrustc<'a> {\n+    compiler: Compiler<'a>,\n+    target: &'a str,\n+    test_kind: TestKind,\n+    krate: Option<&'a str>,\n+}\n+\n+impl<'a> Step<'a> for KrateLibrustc<'a> {\n+    type Output = ();\n+    const NAME: &'static str = \"check librustc\";\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(builder: &Builder, path: &Path) -> bool {\n+        builder.crates(\"rustc-main\").into_iter().any(|(_, krate_path)| {\n+            path.ends_with(krate_path)\n+        })\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+        let compiler = builder.compiler(builder.top_stage, host);\n+\n+        let run = |name: Option<&str>| {\n+            let test_kind = if builder.kind == Kind::Test {\n+                TestKind::Test\n+            } else if builder.kind == Kind::Bench {\n+                TestKind::Bench\n+            } else {\n+                panic!(\"unexpected builder.kind in Krate: {:?}\", builder.kind);\n+            };\n+\n+            builder.ensure(KrateLibrustc {\n+                compiler,\n+                target,\n+                test_kind: test_kind,\n+                krate: name,\n+            });\n+        };\n+\n+        if let Some(path) = path {\n+            for (name, krate_path) in builder.crates(\"rustc-main\") {\n+                if path.ends_with(krate_path) {\n+                    run(Some(name));\n+                }\n+            }\n+        } else {\n+            run(None);\n+        }\n+    }\n+\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Krate {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: Mode::Librustc,\n+            test_kind: self.test_kind,\n+            krate: self.krate,\n+        });\n+    }\n+}\n+\n+\n //    for (krate, path, _default) in krates(\"std\") {\n //        rules.test(&krate.test_step, path)\n //             .dep(|s| s.name(\"libtest\"))\n@@ -714,22 +961,6 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n //         .default(true)\n //         .run(move |s| check::krate(build, &s.compiler(), s.target,\n //                                    Mode::Libtest, TestKind::Test, None));\n-//    for (krate, path, _default) in krates(\"rustc-main\") {\n-//        rules.test(&krate.test_step, path)\n-//             .dep(|s| s.name(\"librustc\"))\n-//             .dep(|s| s.name(\"remote-copy-libs\"))\n-//             .host(true)\n-//             .run(move |s| check::krate(build, &s.compiler(), s.target,\n-//                                        Mode::Librustc, TestKind::Test,\n-//                                        Some(&krate.name)));\n-//    }\n-//    rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n-//         .dep(|s| s.name(\"librustc\"))\n-//         .dep(|s| s.name(\"remote-copy-libs\"))\n-//         .default(true)\n-//         .host(true)\n-//         .run(move |s| check::krate(build, &s.compiler(), s.target,\n-//                                    Mode::Librustc, TestKind::Test, None));\n \n #[derive(Serialize)]\n pub struct Krate<'a> {\n@@ -742,6 +973,53 @@ pub struct Krate<'a> {\n \n impl<'a> Step<'a> for Krate<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(builder: &Builder, path: &Path) -> bool {\n+        builder.crates(\"std\").into_iter().any(|(_, krate_path)| {\n+            path.ends_with(krate_path)\n+        }) ||\n+        builder.crates(\"test\").into_iter().any(|(_, krate_path)| {\n+            path.ends_with(krate_path)\n+        })\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+        let compiler = builder.compiler(builder.top_stage, host);\n+\n+        let run = |mode: Mode, name: Option<&str>| {\n+            let test_kind = if builder.kind == Kind::Test {\n+                TestKind::Test\n+            } else if builder.kind == Kind::Bench {\n+                TestKind::Bench\n+            } else {\n+                panic!(\"unexpected builder.kind in Krate: {:?}\", builder.kind);\n+            };\n+\n+            builder.ensure(Krate {\n+                compiler, target,\n+                mode: mode,\n+                test_kind: test_kind,\n+                krate: name,\n+            });\n+        };\n+\n+        if let Some(path) = path {\n+            for (name, krate_path) in builder.crates(\"std\") {\n+                if path.ends_with(krate_path) {\n+                    run(Mode::Libstd, Some(name));\n+                }\n+            }\n+            for (name, krate_path) in builder.crates(\"test\") {\n+                if path.ends_with(krate_path) {\n+                    run(Mode::Libtest, Some(name));\n+                }\n+            }\n+        } else {\n+            run(Mode::Libstd, None);\n+            run(Mode::Libtest, None);\n+        }\n+    }\n \n     /// Run all unit tests plus documentation tests for an entire crate DAG defined\n     /// by a `Cargo.toml`\n@@ -759,6 +1037,8 @@ impl<'a> Step<'a> for Krate<'a> {\n         let test_kind = self.test_kind;\n         let krate = self.krate;\n \n+        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(RemoteCopyLibs { compiler, target });\n         let (name, path, features, root) = match mode {\n             Mode::Libstd => {\n                 (\"libstd\", \"src/libstd\", build.std_features(), \"std\")\n@@ -782,7 +1062,7 @@ impl<'a> Step<'a> for Krate<'a> {\n         // stage1. Reflect that here by updating the compiler that we're working\n         // with automatically.\n         let compiler = if build.force_use_stage1(compiler, target) {\n-            Compiler::new(1, compiler.host)\n+            builder.compiler(1, compiler.host)\n         } else {\n             compiler.clone()\n         };\n@@ -855,7 +1135,7 @@ impl<'a> Step<'a> for Krate<'a> {\n             krate_emscripten(build, &compiler, target, mode);\n         } else if build.remote_tested(target) {\n             build.run(&mut cargo);\n-            krate_remote(build, &compiler, target, mode);\n+            krate_remote(builder, &compiler, target, mode);\n         } else {\n             cargo.args(&build.flags.cmd.test_args());\n             try_run(build, &mut cargo);\n@@ -882,15 +1162,14 @@ fn krate_emscripten(build: &Build,\n     }\n }\n \n-fn krate_remote(build: &Build,\n+fn krate_remote(build: &Builder,\n                 compiler: &Compiler,\n                 target: &str,\n                 mode: Mode) {\n     let out_dir = build.cargo_out(compiler, mode, target);\n     let tests = find_tests(&out_dir.join(\"deps\"), target);\n \n-    let tool = build.tool(&Compiler::new(0, &build.build),\n-                          \"remote-test-client\");\n+    let tool = builder.tool_exe(Tool::RemoteTestClient);\n     for test in tests {\n         let mut cmd = Command::new(&tool);\n         cmd.arg(\"run\")\n@@ -968,15 +1247,17 @@ impl<'a> Step<'a> for RemoteCopyLibs<'a> {\n             return\n         }\n \n+        builder.ensure(compile::Test { compiler, target });\n+\n         println!(\"REMOTE copy libs to emulator ({})\", target);\n         t!(fs::create_dir_all(build.out.join(\"tmp\")));\n \n-        let server = build.cargo_out(compiler, Mode::Tool, target)\n-                          .join(exe(\"remote-test-server\", target));\n+        // FIXME: This builds the tool for the native build triple\n+        // (build.build); that is probably wrong. Should build for target.\n+        let server = builder.tool_exe(Tool::RemoteTestServer);\n \n         // Spawn the emulator and wait for it to come online\n-        let tool = build.tool(&Compiler::new(0, &build.build),\n-                              \"remote-test-client\");\n+        let tool = builder.tool_exe(Tool::RemoteTestClient);\n         let mut cmd = Command::new(&tool);\n         cmd.arg(\"spawn-emulator\")\n            .arg(target)\n@@ -1025,6 +1306,9 @@ impl<'a> Step<'a> for Distcheck {\n             return\n         }\n \n+        builder.ensure(dist::PlainSourceTarball);\n+        builder.ensure(dist::Src);\n+\n         println!(\"Distcheck\");\n         let dir = build.out.join(\"tmp\").join(\"distcheck\");\n         let _ = fs::remove_dir_all(&dir);\n@@ -1077,6 +1361,9 @@ pub struct Bootstrap;\n \n impl<'a> for Step<'a> Bootstrap {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+    const ONLY_BUILD: bool = true;\n \n     /// Test the build system itself\n     fn run(self, builder: &Builder) {\n@@ -1093,4 +1380,12 @@ impl<'a> for Step<'a> Bootstrap {\n         cmd.arg(\"--\").args(&build.flags.cmd.test_args());\n         try_run(build, &mut cmd);\n     }\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/bootstrap\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, _target: &str) {\n+        builder.ensure(Bootstrap);\n+    }\n }"}, {"sha": "07a0f63e6cb9230b3891b99b0da70f7558169cb6", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 197, "deletions": 23, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "patch": "@@ -129,6 +129,9 @@ fn crate_rule<'a, 'b>(build: &'a Build,\n         rule\n }\n \n+//        rules.build(\"libstd\", \"src/libstd\")\n+//             .dep(|s| s.name(\"rustc\").target(s.host))\n+//             .dep(|s| s.name(\"libstd-link\"));\n //    for (krate, path, _default) in krates(\"std\") {\n //        rules.build(&krate.build_step, path)\n //             .dep(|s| s.name(\"startup-objects\"))\n@@ -143,6 +146,21 @@ pub struct Std<'a> {\n \n impl<'a> Step<'a> for Std<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/libstd\") ||\n+        builder.crates(\"std\").into_iter().any(|(_, krate_path)| {\n+            path.ends_with(krate_path)\n+        })\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+        builder.ensure(Std {\n+            compiler: builder.compiler(builder.top_stage, host),\n+            target,\n+        })\n+    }\n \n     /// Build the standard library.\n     ///\n@@ -153,16 +171,31 @@ impl<'a> Step<'a> for Std<'a> {\n         let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n-        let libdir = build.sysroot_libdir(compiler, target);\n-        t!(fs::create_dir_all(&libdir));\n+\n+        builder.ensure(StartupObjects { compiler, target });\n+\n+        if build.force_use_stage1(compiler, target) {\n+            let from = builder.compiler(1, &build.build);\n+            builder.ensure(Std {\n+                compiler: from,\n+                target: target,\n+            });\n+            println!(\"Uplifting stage1 std ({} -> {})\", from.host, target);\n+            builder.ensure(StdLink {\n+                compiler: from,\n+                target_compiler: compiler,\n+                target: target,\n+            });\n+            return;\n+        }\n \n         let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n         println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n                 compiler.host, target);\n \n         let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n         build.clear_if_dirty(&out_dir, &build.compiler_path(compiler));\n-        let mut cargo = build.cargo(compiler, Mode::Libstd, target, \"build\");\n+        let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n         let mut features = build.std_features();\n \n         if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n@@ -188,6 +221,7 @@ impl<'a> Step<'a> for Std<'a> {\n             // config.toml equivalent) is used\n             cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n         }\n+\n         cargo.arg(\"--features\").arg(features)\n             .arg(\"--manifest-path\")\n             .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n@@ -206,6 +240,12 @@ impl<'a> Step<'a> for Std<'a> {\n         run_cargo(build,\n                 &mut cargo,\n                 &libstd_stamp(build, &compiler, target));\n+\n+        builder.ensure(StdLink {\n+            compiler: builder.compiler(compiler.stage, &build.build),\n+            target_compiler: compiler,\n+            target: target,\n+        });\n     }\n }\n \n@@ -219,7 +259,7 @@ impl<'a> Step<'a> for Std<'a> {\n //     .dep(|s| s.name(\"create-sysroot\").target(s.host));\n \n #[derive(Serialize)]\n-pub struct StdLink<'a> {\n+struct StdLink<'a> {\n     pub compiler: Compiler<'a>,\n     pub target_compiler: Compiler<'a>,\n     pub target: &'a str,\n@@ -297,6 +337,17 @@ pub struct StartupObjects<'a> {\n impl<'a> Step<'a> for StartupObjects<'a> {\n     type Output = ();\n \n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/rtstartup\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+        builder.ensure(StartupObjects {\n+            compiler: builder.compiler(builder.top_stage, host),\n+            target,\n+        })\n+    }\n+\n     /// Build and prepare startup objects like rsbegin.o and rsend.o\n     ///\n     /// These are primarily used on Windows right now for linking executables/dlls.\n@@ -354,6 +405,21 @@ pub struct Test<'a> {\n \n impl<'a> Step<'a> for Test<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/libtest\") ||\n+        builder.crates(\"test\").into_iter().any(|(_, krate_path)| {\n+            path.ends_with(krate_path)\n+        })\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+        builder.ensure(Test {\n+            compiler: builder.compiler(builder.top_stage, host),\n+            target,\n+        })\n+    }\n \n     /// Build libtest.\n     ///\n@@ -364,6 +430,23 @@ impl<'a> Step<'a> for Test<'a> {\n         let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n+\n+        builder.ensure(Std { compiler, target });\n+\n+        if build.force_use_stage1(compiler, target) {\n+            builder.ensure(Test {\n+                compiler: builder.compiler(1, &build.build),\n+                target: target,\n+            });\n+            println!(\"Uplifting stage1 test ({} -> {})\", &build.build, target);\n+            builder.ensure(TestLink {\n+                compiler: builder.compiler(1, &build.build),\n+                target_compiler: compiler,\n+                target: target,\n+            });\n+            return;\n+        }\n+\n         let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n                 compiler.host, target);\n@@ -378,6 +461,12 @@ impl<'a> Step<'a> for Test<'a> {\n         run_cargo(build,\n                 &mut cargo,\n                 &libtest_stamp(build, compiler, target));\n+\n+        builder.ensure(TestLink {\n+            compiler: builder.compiler(1, &build.build),\n+            target_compiler: compiler,\n+            target: target,\n+        });\n     }\n }\n \n@@ -432,6 +521,22 @@ pub struct Rustc<'a> {\n \n impl<'a> Step<'a> for Rustc<'a> {\n     type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/librustc\") ||\n+        builder.crates(\"rustc-main\").into_iter().any(|(_, krate_path)| {\n+            path.ends_with(krate_path)\n+        })\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+        builder.ensure(Rustc {\n+            compiler: builder.compiler(builder.top_stage, host),\n+            target,\n+        })\n+    }\n \n     /// Build the compiler.\n     ///\n@@ -442,6 +547,33 @@ impl<'a> Step<'a> for Rustc<'a> {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n+\n+        builder.ensure(Test { compiler, target });\n+\n+        // Build LLVM for our target. This will implicitly build the host LLVM\n+        // if necessary.\n+        builder.ensure(native::Llvm { target });\n+\n+        if build.force_use_stage1(compiler, target) {\n+            builder.ensure(Rustc {\n+                compiler: builder.compiler(1, &build.build),\n+                target: target,\n+            });\n+            println!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target);\n+            builder.ensure(RustcLink {\n+                compiler: builder.compiler(1, &build.build),\n+                target_compiler: compiler,\n+                target,\n+            });\n+            return;\n+        }\n+\n+        // Ensure that build scripts have a std to link against.\n+        builder.ensure(Std {\n+            compiler: builder.compiler(self.compiler.stage, &build.build),\n+            target: &build.build,\n+        });\n+\n         let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n         println!(\"Building stage{} compiler artifacts ({} -> {})\",\n                  compiler.stage, compiler.host, target);\n@@ -513,6 +645,12 @@ impl<'a> Step<'a> for Rustc<'a> {\n         run_cargo(build,\n                   &mut cargo,\n                   &librustc_stamp(build, compiler, target));\n+\n+        builder.ensure(RustcLink {\n+            compiler: builder.compiler(compiler.stage, &build.build),\n+            target_compiler: compiler,\n+            target,\n+        });\n     }\n }\n \n@@ -523,7 +661,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n //            compile::rustc_link)\n //     .dep(|s| s.name(\"libtest-link\"));\n #[derive(Serialize)]\n-pub struct RustcLink<'a> {\n+struct RustcLink<'a> {\n     pub compiler: Compiler<'a>,\n     pub target_compiler: Compiler<'a>,\n     pub target: &'a str,\n@@ -551,19 +689,19 @@ impl<'a> Step<'a> for RustcLink<'a> {\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-fn libstd_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+pub fn libstd_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n     build.cargo_out(compiler, Mode::Libstd, target).join(\".libstd.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-fn libtest_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+pub fn libtest_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n     build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-fn librustc_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n+pub fn librustc_stamp(build: &Build, compiler: &Compiler, target: &str) -> PathBuf {\n     build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n }\n \n@@ -582,20 +720,25 @@ pub struct Sysroot<'a> {\n }\n \n impl<'a> Step<'a> for Sysroot<'a> {\n-    type Output = ();\n+    type Output = PathBuf;\n \n     /// Returns the sysroot for the `compiler` specified that *this build system\n     /// generates*.\n     ///\n     /// That is, the sysroot for the stage0 compiler is not what the compiler\n     /// thinks it is by default, but it's the same as the default for stages\n     /// 1-3.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n         let compiler = self.compiler;\n-        let sysroot = build.sysroot(compiler);\n+        let sysroot = if compiler.stage == 0 {\n+            build.out.join(compiler.host).join(\"stage0-sysroot\")\n+        } else {\n+            build.out.join(compiler.host).join(format!(\"stage{}\", compiler.stage))\n+        };\n         let _ = fs::remove_dir_all(&sysroot);\n         t!(fs::create_dir_all(&sysroot));\n+        sysroot\n     }\n }\n \n@@ -615,8 +758,11 @@ impl<'a> Step<'a> for Sysroot<'a> {\n \n #[derive(Serialize)]\n pub struct Assemble<'a> {\n-    pub stage: u32,\n-    pub host: &'a str,\n+    /// The compiler which we will produce in this step. Assemble itself will\n+    /// take care of ensuring that the necessary prerequisites to do so exist,\n+    /// that is, this target can be a stage2 compiler and Assemble will build\n+    /// previous stages for you.\n+    pub target_compiler: Compiler<'a>,\n }\n \n impl<'a> Step<'a> for Assemble<'a> {\n@@ -629,20 +775,48 @@ impl<'a> Step<'a> for Assemble<'a> {\n     /// compiler.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        // nothing to do in stage0\n-        if stage == 0 {\n-            return\n+        let target_compiler = self.target_compiler;\n+\n+        if target_compiler.stage == 0 {\n+            assert_eq!(build.build, target_compiler.host,\n+                \"Cannot obtain compiler for non-native build triple at stage 0\");\n+            // The stage 0 compiler for the build triple is always pre-built.\n+            return target_compiler;\n         }\n \n-        println!(\"Copying stage{} compiler ({})\", stage, host);\n+        // Get the compiler that we'll use to bootstrap ourselves.\n+        let build_compiler = if target_compiler.host != build.build {\n+            // Build a compiler for the host platform. We cannot use the stage0\n+            // compiler for the host platform for this because it doesn't have\n+            // the libraries we need.  FIXME: Perhaps we should download those\n+            // libraries? It would make builds faster...\n+            builder.ensure(Assemble {\n+                target_compiler: Compiler {\n+                    // FIXME: It may be faster if we build just a stage 1\n+                    // compiler and then use that to bootstrap this compiler\n+                    // forward.\n+                    stage: target_compiler.stage - 1,\n+                    host: &build.build\n+                },\n+            })\n+        } else {\n+            // Build the compiler we'll use to build the stage requested. This\n+            // may build more than one compiler (going down to stage 0).\n+            builder.ensure(Assemble {\n+                target_compiler: target_compiler.with_stage(target_compiler.stage - 1),\n+            })\n+        };\n \n-        // The compiler that we're assembling\n-        let target_compiler = Compiler::new(stage, host);\n+        // Build the libraries for this compiler to link to (i.e., the libraries\n+        // it uses at runtime). NOTE: Crates the target compiler compiles don't\n+        // link to these. (FIXME: Is that correct? It seems to be correct most\n+        // of the time but I think we do link to these for stage2/bin compilers\n+        // when not performing a full bootstrap).\n+        builder.ensure(Rustc { compiler: build_compiler, target: target_compiler.host });\n \n-        // The compiler that compiled the compiler we're assembling\n-        let build_compiler = Compiler::new(stage - 1, &build.build);\n+        let stage = target_compiler.stage;\n+        let host = target_compiler.host;\n+        println!(\"Assembling stage{} compiler ({})\", stage, host);\n \n         // Link in all dylibs to the libdir\n         let sysroot = build.sysroot(&target_compiler);"}, {"sha": "da513b1f2f66929d812599df6afc74188f9c99a5", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 185, "deletions": 12, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "patch": "@@ -76,6 +76,19 @@ pub struct Docs<'a> {\n \n impl<'a> Step<'a> for Docs<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_BUILD_TARGETS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/doc\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+        builder.ensure(Docs {\n+            stage: builder.top_stage,\n+            host: target,\n+        });\n+    }\n \n     /// Builds the `rust-docs` installer component.\n     ///\n@@ -85,6 +98,8 @@ impl<'a> Step<'a> for Docs<'a> {\n         let stage = self.stage;\n         let host = self.host;\n \n+        builder.default_doc(None);\n+\n         println!(\"Dist docs stage{} ({})\", stage, host);\n         if !build.config.docs {\n             println!(\"\\tskipping - docs disabled\");\n@@ -268,6 +283,18 @@ pub struct Mingw<'a> {\n \n impl<'a> Step<'a> for Mingw<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_BUILD_TARGETS: bool = true;\n+\n+    fn should_run(_builder: &Builder, _path: &Path) -> bool {\n+        false\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n+        builder.ensure(Mingw {\n+            host: host,\n+        });\n+    }\n \n     /// Build the `rust-mingw` installer component.\n     ///\n@@ -276,6 +303,11 @@ impl<'a> Step<'a> for Mingw<'a> {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let host = self.host;\n+\n+        if !host.contains(\"pc-windows-gnu\") {\n+            return;\n+        }\n+\n         println!(\"Dist mingw ({})\", host);\n         let name = pkgname(build, \"rust-mingw\");\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n@@ -320,6 +352,20 @@ pub struct Rustc<'a> {\n \n impl<'a> Step<'a> for Rustc<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+    const ONLY_BUILD_TARGETS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/librustc\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n+        builder.ensure(Rustc {\n+            stage: builder.top_stage,\n+            host: host,\n+        });\n+    }\n \n     /// Creates the `rustc` installer component.\n     fn run(self, builder: &builder) {\n@@ -334,7 +380,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n         let _ = fs::remove_dir_all(&overlay);\n \n         // Prepare the rustc \"image\", what will actually end up getting installed\n-        prepare_image(build, stage, host, &image);\n+        prepare_image(builder, stage, host, &image);\n \n         // Prepare the overlay which is part of the tarball but won't actually be\n         // installed\n@@ -384,8 +430,9 @@ impl<'a> Step<'a> for Rustc<'a> {\n         t!(fs::remove_dir_all(&image));\n         t!(fs::remove_dir_all(&overlay));\n \n-        fn prepare_image(build: &Build, stage: u32, host: &str, image: &Path) {\n-            let src = build.sysroot(&Compiler::new(stage, host));\n+        fn prepare_image(builder: &Builder, stage: u32, host: &str, image: &Path) {\n+            let build = builder.build;\n+            let src = build.sysroot(builder.compiler(stage, host));\n             let libdir = libdir(host);\n \n             // Copy rustc/rustdoc binaries\n@@ -409,7 +456,10 @@ impl<'a> Step<'a> for Rustc<'a> {\n             cp_r(&build.src.join(\"man\"), &image.join(\"share/man/man1\"));\n \n             // Debugger scripts\n-            debugger_scripts(build, &image, host);\n+            builder.ensure(DebuggerScripts {\n+                sysroot: &image,\n+                host: host,\n+            });\n \n             // Misc license info\n             let cp = |file: &str| {\n@@ -423,8 +473,6 @@ impl<'a> Step<'a> for Rustc<'a> {\n     }\n }\n \n-\n-\n //rules.test(\"debugger-scripts\", \"src/etc/lldb_batchmode.py\")\n //     .run(move |s| dist::debugger_scripts(build, &build.sysroot(&s.compiler()),\n //                                     s.target));\n@@ -438,6 +486,18 @@ pub struct DebuggerScripts<'a> {\n impl<'a> Step<'a> for DebuggerScripts<'a> {\n     type Output = ();\n \n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/etc/lldb_batchmode.py\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n+        builder.ensure(DebuggerScripts {\n+            // FIXME: builder.top_stage is likely wrong in some cases.\n+            sysroot: &builder.sysroot(builder.compiler(builder.top_stage, host)),\n+            host: host,\n+        });\n+    }\n+\n     /// Copies debugger scripts for `host` into the `sysroot` specified.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n@@ -542,6 +602,22 @@ pub struct Analysis<'a> {\n \n impl<'a> Step<'a> for Analysis<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_BUILD_TARGETS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"analysis\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+        if path.is_none() && !builder.build.config.extended {\n+            return;\n+        }\n+        builder.ensure(Analysis {\n+            compiler: builder.compiler(builder.top_stage, host),\n+            target: target,\n+        });\n+    }\n \n     /// Creates a tarball of save-analysis metadata, if available.\n     fn run(self, builder: &Builder) {\n@@ -559,15 +635,16 @@ impl<'a> Step<'a> for Analysis<'a> {\n         // Package save-analysis from stage1 if not doing a full bootstrap, as the\n         // stage2 artifacts is simply copied from stage1 in that case.\n         let compiler = if build.force_use_stage1(compiler, target) {\n-            Compiler::new(1, compiler.host)\n+            builder.compiler(1, compiler.host)\n         } else {\n             compiler.clone()\n         };\n \n         let name = pkgname(build, \"rust-analysis\");\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n \n-        let src = build.stage_out(&compiler, Mode::Libstd).join(target).join(\"release\").join(\"deps\");\n+        let src = build.stage_out(compiler, Mode::Libstd)\n+            .join(target).join(\"release\").join(\"deps\");\n \n         let image_src = src.join(\"save-analysis\");\n         let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n@@ -644,6 +721,18 @@ pub struct Src;\n \n impl<'a> Step<'a> for Src {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+    const ONLY_BUILD_TARGETS: bool = true;\n+    const ONLY_BUILD: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, _target: &str) {\n+        builder.ensure(Src);\n+    }\n \n     /// Creates the `rust-src` installer component\n     fn run(self, builder: &Builder) {\n@@ -727,6 +816,22 @@ pub struct PlainSourceTarball;\n \n impl<'a> Step<'a> for PlainSourceTarball {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+    const ONLY_BUILD_TARGETS: bool = true;\n+    const ONLY_BUILD: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, _target: &str) {\n+        if path.is_none() && !builder.build.config.rust_dist_src {\n+            return;\n+        }\n+\n+        builder.ensure(PlainSourceTarball);\n+    }\n \n     /// Creates the plain source tarball\n     fn run(self, builder: &Builder) {\n@@ -862,13 +967,29 @@ pub struct Cargo<'a> {\n \n impl<'a> Step<'a> for Cargo<'a> {\n     type Output = ();\n+    const ONLY_BUILD_TARGETS: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"cargo\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+        builder.ensure(Cargo {\n+            stage: builder.top_stage,\n+            target: target,\n+        });\n+    }\n \n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n+\n+        builder.ensure(tool::Cargo { stage, target });\n+\n         println!(\"Dist cargo stage{} ({})\", stage, target);\n-        let compiler = Compiler::new(stage, &build.build);\n+        let compiler = builder.compiler(stage, &build.build);\n \n         let src = build.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n@@ -941,14 +1062,30 @@ pub struct Rls<'a> {\n \n impl<'a> Step<'a> for Rls<'a> {\n     type Output = ();\n+    const ONLY_BUILD_TARGETS: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"rls\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+        builder.ensure(Rls {\n+            stage: builder.top_stage,\n+            target: target,\n+        });\n+    }\n \n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n         assert!(build.config.extended);\n+\n+        builder.ensure(tool::Rls { stage, target });\n+\n         println!(\"Dist RLS stage{} ({})\", stage, target);\n-        let compiler = Compiler::new(stage, &build.build);\n+        let compiler = builder.compiler(stage, &build.build);\n \n         let src = build.src.join(\"src/tools/rls\");\n         let release_num = build.release_num(\"rls\");\n@@ -1017,12 +1154,38 @@ pub struct Extended<'a> {\n \n impl<'a> Step<'a> for Extended<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_BUILD_TARGETS: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"cargo\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+        if path.is_none() && !builder.build.config.extended {\n+            return;\n+        }\n+        builder.ensure(Extended {\n+            compiler: builder.compiler(builder.top_stage, host),\n+            target: target,\n+        });\n+    }\n \n     /// Creates a combined installer for the specified target in the provided stage.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n+        let compiler = builder.compiler(stage, &build.build);\n+\n+        builder.ensure(Std { compiler, target });\n+        builder.ensure(Rustc { stage, host });\n+        builder.ensure(Mingw { host });\n+        builder.ensure(Docs { stage, host });\n+        builder.ensure(Cargo { stage, target });\n+        builder.ensure(Rls { stage, target });\n+        builder.ensure(Analysis { compiler, target });\n \n         println!(\"Dist extended stage{} ({})\", stage, target);\n \n@@ -1420,11 +1583,21 @@ pub struct HashSign;\n \n impl<'a> Step<'a> for HashSign {\n     type Output = ();\n+    const ONLY_BUILD_TARGETS: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+    const ONLY_BUILD: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"hash-and-sign\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, _target: &str) {\n+        builder.ensure(HashSign);\n+    }\n \n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let compiler = Compiler::new(0, &build.build);\n-        let mut cmd = build.tool_cmd(&compiler, \"build-manifest\");\n+        let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n         let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n         });"}, {"sha": "11edee6234459342262fa54d1955c269691f4e85", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 284, "deletions": 40, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "patch": "@@ -27,27 +27,70 @@ use {Build, Compiler, Mode};\n use util::{cp_r, symlink_dir};\n use build_helper::up_to_date;\n \n-// rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n-//      .dep(move |s| {\n-//          s.name(\"tool-rustbook\")\n-//           .host(&build.build)\n-//           .target(&build.build)\n-//           .stage(0)\n-//      })\n-//      .default(build.config.docs)\n-//      .run(move |s| doc::rustbook(build, s.target, \"nomicon\"));\n-// rules.doc(\"doc-reference\", \"src/doc/reference\")\n-//      .dep(move |s| {\n-//          s.name(\"tool-rustbook\")\n-//           .host(&build.build)\n-//           .target(&build.build)\n-//           .stage(0)\n-//      })\n-//      .default(build.config.docs)\n-//      .run(move |s| doc::rustbook(build, s.target, \"reference\"));\n+macro_rules! book {\n+    ($($name:ident, $path:expr, $book_name:expr;)+) => {\n+        $(\n+        #[derive(Serialize)]\n+        pub struct $name<'a> {\n+            target: &'a str,\n+        }\n+\n+        impl<'a> Step<'a> for $name<'a> {\n+            type Output = ();\n+            const NAME: &'static str = concat!(stringify!($book_name), \" - book\");\n+            const DEFAULT: bool = true;\n+\n+            fn should_run(_builder: &Builder, path: &Path) -> bool {\n+                path.ends_with($path)\n+            }\n+\n+            fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+                if path.is_none() && !builder.build.config.docs {\n+                    // Not a default rule if docs are disabled.\n+                    return;\n+                }\n+\n+                builder.ensure($name {\n+                    target,\n+                });\n+            }\n+\n+            fn run(self, builder: &Builder) {\n+                builder.ensure(Rustbook {\n+                    target: self.target,\n+                    name: $book_name,\n+                })\n+            }\n+        }\n+        )+\n+    }\n+}\n+\n+book!(\n+    // rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n+    //      .dep(move |s| {\n+    //          s.name(\"tool-rustbook\")\n+    //           .host(&build.build)\n+    //           .target(&build.build)\n+    //           .stage(0)\n+    //      })\n+    //      .default(build.config.docs)\n+    //      .run(move |s| doc::rustbook(build, s.target, \"nomicon\"));\n+    Nomicon, \"src/doc/book\", \"nomicon\";\n+    // rules.doc(\"doc-reference\", \"src/doc/reference\")\n+    //      .dep(move |s| {\n+    //          s.name(\"tool-rustbook\")\n+    //           .host(&build.build)\n+    //           .target(&build.build)\n+    //           .stage(0)\n+    //      })\n+    //      .default(build.config.docs)\n+    //      .run(move |s| doc::rustbook(build, s.target, \"reference\"));\n+    Reference, \"src/doc/reference\", \"reference\";\n+);\n \n #[derive(Serialize)]\n-pub struct Rustbook<'a> {\n+struct Rustbook<'a> {\n     target: &'a str,\n     name: &'a str,\n }\n@@ -60,11 +103,12 @@ impl<'a> Step<'a> for Rustbook<'a> {\n     /// This will not actually generate any documentation if the documentation has\n     /// already been generated.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let target = self.target;\n-        let name = self.name;\n-        let src = build.src.join(\"src/doc\");\n-        rustbook_src(build, target, name, &src);\n+        let src = builder.build.src.join(\"src/doc\");\n+        builder.ensure(RustbookSrc {\n+            target: self.target,\n+            name: self.name,\n+            src: &src,\n+        });\n     }\n }\n \n@@ -81,6 +125,42 @@ impl<'a> Step<'a> for Rustbook<'a> {\n //                                     s.target,\n //                                     \"unstable-book\",\n //                                     &build.md_doc_out(s.target)));\n+#[derive(Serialize)]\n+pub struct UnstableBook<'a> {\n+    target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for UnstableBook<'a> {\n+    type Output = ();\n+    const NAME: &'static str = \"unstable book documentation\";\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/doc/unstable-book\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+        if path.is_none() && !builder.build.config.docs {\n+            // Not a default rule if docs are disabled.\n+            return;\n+        }\n+\n+        builder.ensure(UnstableBook {\n+            target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(UnstableBookGen {\n+            target: self.target,\n+        });\n+        builder.ensure(RustbookSrc {\n+            target: self.target,\n+            name: \"unstable-book\",\n+            src: &builder.build.md_doc_out(self.target),\n+        })\n+    }\n+}\n \n #[derive(Serialize)]\n pub struct RustbookSrc<'a> {\n@@ -105,16 +185,15 @@ impl<'a> Step<'a> for RustbookSrc<'a> {\n         t!(fs::create_dir_all(&out));\n \n         let out = out.join(name);\n-        let compiler = Compiler::new(0, &build.build);\n         let src = src.join(name);\n         let index = out.join(\"index.html\");\n-        let rustbook = build.tool(&compiler, \"rustbook\");\n+        let rustbook = builder.tool_exe(Tool::Rustbook);\n         if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n             return\n         }\n         println!(\"Rustbook ({}) - {}\", target, name);\n         let _ = fs::remove_dir_all(&out);\n-        build.run(build.tool_cmd(&compiler, \"rustbook\")\n+        build.run(builder.tool_cmd(Tool::Rustbook)\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n@@ -154,10 +233,16 @@ impl<'a> Step<'a> for TheBook<'a> {\n         let target = self.target;\n         let name = self.name;\n         // build book first edition\n-        rustbook(build, target, &format!(\"{}/first-edition\", name));\n+        builder.ensure(Rustbook {\n+            target: target,\n+            name: &format!(\"{}/first-edition\", name),\n+        });\n \n         // build book second edition\n-        rustbook(build, target, &format!(\"{}/second-edition\", name));\n+        builder.ensure(Rustbook {\n+            target: target,\n+            name: &format!(\"{}/second-edition\", name),\n+        });\n \n         // build the index page\n         let index = format!(\"{}/index.md\", name);\n@@ -238,6 +323,22 @@ pub struct Standalone<'a> {\n \n impl<'a> Step<'a> for Standalone<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/doc\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+        if path.is_none() && !builder.build.config.docs {\n+            // Not a default rule if docs are disabled.\n+            return;\n+        }\n+\n+        builder.ensure(Standalone {\n+            target,\n+        });\n+    }\n \n     /// Generates all standalone documentation as compiled by the rustdoc in `stage`\n     /// for the `target` into `out`.\n@@ -254,7 +355,7 @@ impl<'a> Step<'a> for Standalone<'a> {\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n-        let compiler = Compiler::new(0, &build.build);\n+        let compiler = builder.compiler(0, &build.build);\n \n         let favicon = build.src.join(\"src/doc/favicon.inc\");\n         let footer = build.src.join(\"src/doc/footer.inc\");\n@@ -329,6 +430,34 @@ pub struct Std<'a> {\n \n impl<'a> Step<'a> for Std<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(builder: &Builder, path: &Path) -> bool {\n+        builder.crates(\"std\").into_iter().any(|(_, krate_path)| {\n+            path.ends_with(krate_path)\n+        })\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+        let run = || {\n+            builder.ensure(Std {\n+                stage: builder.top_stage,\n+                target\n+            });\n+        };\n+\n+        if let Some(path) = path {\n+            for (_, krate_path) in builder.crates(\"std\") {\n+                if path.ends_with(krate_path) {\n+                    run();\n+                }\n+            }\n+        } else {\n+            if builder.build.config.docs {\n+                run();\n+            }\n+        }\n+    }\n \n     /// Compile all standard library documentation.\n     ///\n@@ -341,12 +470,14 @@ impl<'a> Step<'a> for Std<'a> {\n         println!(\"Documenting stage{} std ({})\", stage, target);\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = Compiler::new(stage, &build.build);\n-        let compiler = if build.force_use_stage1(&compiler, target) {\n-            Compiler::new(1, compiler.host)\n+        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = if build.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n         } else {\n             compiler\n         };\n+\n+        builder.ensure(compile::Std { compiler, target });\n         let out_dir = build.stage_out(&compiler, Mode::Libstd)\n                            .join(target).join(\"doc\");\n         let rustdoc = build.rustdoc(&compiler);\n@@ -410,6 +541,34 @@ pub struct Test<'a> {\n \n impl<'a> Step<'a> for Test<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(builder: &Builder, path: &Path) -> bool {\n+        builder.crates(\"test\").into_iter().any(|(_, krate_path)| {\n+            path.ends_with(krate_path)\n+        })\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+        let run = || {\n+            builder.ensure(Test {\n+                stage: builder.top_stage,\n+                target\n+            });\n+        };\n+\n+        if let Some(path) = path {\n+            for (_, krate_path) in builder.crates(\"test\") {\n+                if path.ends_with(krate_path) {\n+                    run();\n+                }\n+            }\n+        } else {\n+            if builder.build.config.docs {\n+                run();\n+            }\n+        }\n+    }\n \n     /// Compile all libtest documentation.\n     ///\n@@ -422,12 +581,17 @@ impl<'a> Step<'a> for Test<'a> {\n         println!(\"Documenting stage{} test ({})\", stage, target);\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = Compiler::new(stage, &build.build);\n-        let compiler = if build.force_use_stage1(&compiler, target) {\n-            Compiler::new(1, compiler.host)\n+        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = if build.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n         } else {\n             compiler\n         };\n+\n+        // Build libstd docs so that we generate relative links\n+        builder.ensure(Std { stage, target });\n+\n+        builder.ensure(compile::Test { compiler, target });\n         let out_dir = build.stage_out(&compiler, Mode::Libtest)\n                            .join(target).join(\"doc\");\n         let rustdoc = build.rustdoc(&compiler);\n@@ -464,6 +628,35 @@ pub struct Rustc<'a> {\n \n impl<'a> Step<'a> for Rustc<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(builder: &Builder, path: &Path) -> bool {\n+        builder.crates(\"rustc-main\").into_iter().any(|(_, krate_path)| {\n+            path.ends_with(krate_path)\n+        })\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+        let run = || {\n+            builder.ensure(Rustc {\n+                stage: builder.top_stage,\n+                target\n+            });\n+        };\n+\n+        if let Some(path) = path {\n+            for (_, krate_path) in builder.crates(\"rustc-main\") {\n+                if path.ends_with(krate_path) {\n+                    run();\n+                }\n+            }\n+        } else {\n+            if builder.build.config.compiler_docs {\n+                run();\n+            }\n+        }\n+    }\n \n     /// Generate all compiler documentation.\n     ///\n@@ -476,12 +669,17 @@ impl<'a> Step<'a> for Rustc<'a> {\n         println!(\"Documenting stage{} compiler ({})\", stage, target);\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = Compiler::new(stage, &build.build);\n-        let compiler = if build.force_use_stage1(&compiler, target) {\n-            Compiler::new(1, compiler.host)\n+        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = if build.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n         } else {\n             compiler\n         };\n+\n+        // Build libstd docs so that we generate relative links\n+        builder.ensure(Std { stage, target });\n+\n+        builder.ensure(compile::Rustc { compiler, target });\n         let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                            .join(target).join(\"doc\");\n         let rustdoc = build.rustdoc(&compiler);\n@@ -530,17 +728,40 @@ pub struct ErrorIndex<'a> {\n \n impl<'a> Step<'a> for ErrorIndex<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/tools/error_index_generator\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+        if path.is_none() && !builder.build.config.docs {\n+            // Not a default rule if docs are disabled.\n+            return;\n+        }\n+\n+        builder.ensure(ErrorIndex {\n+            target,\n+        });\n+    }\n \n     /// Generates the HTML rendered error-index by running the\n     /// `error_index_generator` tool.\n     fn run(self, builder: &Builder) {\n         let builder = builder.build;\n         let target = self.target;\n+\n+        builder.ensure(compile::Rustc {\n+            compiler: builder.compiler(0, &build.build),\n+            target,\n+        });\n+\n         println!(\"Documenting error index ({})\", target);\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = Compiler::new(0, &build.build);\n-        let mut index = build.tool_cmd(&compiler, \"error_index_generator\");\n+        let mut index = builder.tool_cmd(Tool::ErrorIndex);\n         index.arg(\"html\");\n         index.arg(out.join(\"error-index.html\"));\n \n@@ -570,10 +791,33 @@ pub struct UnstableBookGen<'a> {\n \n impl<'a> Step<'a> for UnstableBookGen<'a> {\n     type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/doc/unstable-book\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+        if path.is_none() && !builder.build.config.docs {\n+            // Not a default rule if docs are disabled.\n+            return;\n+        }\n+\n+        builder.ensure(UnstableBookGen {\n+            target,\n+        });\n+    }\n \n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let target = self.target;\n+\n+        builder.ensure(compile::Std {\n+            compiler: builder.compiler(builder.top_stage, &build.build),\n+            target,\n+        });\n+\n         println!(\"Generating unstable book md files ({})\", target);\n         let out = build.md_doc_out(target).join(\"unstable-book\");\n         t!(fs::create_dir_all(&out));"}, {"sha": "3e895bbe90017f587bd291616155a2058b35e541", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 121, "deletions": 42, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "patch": "@@ -148,45 +148,124 @@ fn add_destdir(path: &Path, destdir: &Option<PathBuf>) -> PathBuf {\n     }\n     ret\n }\n-/*\n-rules.install(\"install-docs\", \"src/doc\")\n-     .default(build.config.docs)\n-     .only_host_build(true)\n-     .dep(|s| s.name(\"dist-docs\"))\n-     .run(move |s| install::Installer::new(build).install_docs(s.stage, s.target));\n-rules.install(\"install-std\", \"src/libstd\")\n-     .default(true)\n-     .only_host_build(true)\n-     .dep(|s| s.name(\"dist-std\"))\n-     .run(move |s| install::Installer::new(build).install_std(s.stage));\n-rules.install(\"install-cargo\", \"cargo\")\n-     .default(build.config.extended)\n-     .host(true)\n-     .only_host_build(true)\n-     .dep(|s| s.name(\"dist-cargo\"))\n-     .run(move |s| install::Installer::new(build).install_cargo(s.stage, s.target));\n-rules.install(\"install-rls\", \"rls\")\n-     .default(build.config.extended)\n-     .host(true)\n-     .only_host_build(true)\n-     .dep(|s| s.name(\"dist-rls\"))\n-     .run(move |s| install::Installer::new(build).install_rls(s.stage, s.target));\n-rules.install(\"install-analysis\", \"analysis\")\n-     .default(build.config.extended)\n-     .only_host_build(true)\n-     .dep(|s| s.name(\"dist-analysis\"))\n-     .run(move |s| install::Installer::new(build).install_analysis(s.stage, s.target));\n-rules.install(\"install-src\", \"src\")\n-     .default(build.config.extended)\n-     .host(true)\n-     .only_build(true)\n-     .only_host_build(true)\n-     .dep(|s| s.name(\"dist-src\"))\n-     .run(move |s| install::Installer::new(build).install_src(s.stage));\n-rules.install(\"install-rustc\", \"src/librustc\")\n-     .default(true)\n-     .host(true)\n-     .only_host_build(true)\n-     .dep(|s| s.name(\"dist-rustc\"))\n-     .run(move |s| install::Installer::new(build).install_rustc(s.stage, s.target));\n-*/\n+\n+macro_rules! install {\n+    ($($name:ident,\n+       $path:expr,\n+       $default_cond:expr,\n+       only_hosts: $only_hosts:expr,\n+       ($sel:ident, $builder:ident),\n+       $run_item:block $(, $c:ident)*;)+) => {\n+        $(#[derive(Serialize)]\n+        pub struct $name<'a> {\n+            pub stage: u32,\n+            pub target: &'a str,\n+            pub host: &'a str,\n+        }\n+\n+        impl<'a> Step<'a> for $name<'a> {\n+            type Output = ();\n+            const NAME: &'static str = concat!(\"install \", stringify!($name));\n+            const DEFAULT: bool = true;\n+            const ONLY_BUILD_TARGETS: bool = true;\n+            const ONLY_HOSTS: bool = $only_hosts;\n+            $(const $c: bool = true;)*\n+\n+            fn should_run(_builder: &Builder, path: &Path) -> bool {\n+                path.ends_with($path)\n+            }\n+\n+            fn make_run($builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+                if path.is_none() && !($default_cond) {\n+                    return;\n+                }\n+                $builder.ensure($name {\n+                    stage: $builder.top_stage,\n+                    target,\n+                    host,\n+                });\n+            }\n+\n+            fn run($sel, $builder: &Builder) {\n+                $run_item\n+            }\n+        })+\n+    }\n+}\n+\n+install!(\n+    // rules.install(\"install-docs\", \"src/doc\")\n+    //      .default(build.config.docs)\n+    //      .only_host_build(true)\n+    //      .dep(|s| s.name(\"dist-docs\"))\n+    //      .run(move |s| install::Installer::new(build).install_docs(s.stage, s.target));\n+    Docs, \"src/doc\", builder.build.config.docs, only_hosts: false, (self, builder), {\n+        builder.ensure(dist::Docs { stage: self.stage, host: self.host });\n+        Installer::new(builder.build).install_docs(self.stage, self.target);\n+    };\n+    // rules.install(\"install-std\", \"src/libstd\")\n+    //      .default(true)\n+    //      .only_host_build(true)\n+    //      .dep(|s| s.name(\"dist-std\"))\n+    //      .run(move |s| install::Installer::new(build).install_std(s.stage));\n+    Std, \"src/libstd\", true, only_hosts: true, (self, builder), {\n+        builder.ensure(dist::Std {\n+            compiler: builder.compiler(self.stage, self.host),\n+            target: self.target\n+        });\n+        Installer::new(builder.build).install_std(self.stage);\n+    };\n+    // rules.install(\"install-cargo\", \"cargo\")\n+    //      .default(build.config.extended)\n+    //      .host(true)\n+    //      .only_host_build(true)\n+    //      .dep(|s| s.name(\"dist-cargo\"))\n+    //      .run(move |s| install::Installer::new(build).install_cargo(s.stage, s.target));\n+    Cargo, \"cargo\", builder.build.config.extended, only_hosts: true, (self, builder), {\n+        builder.ensure(dist::Cargo { stage: self.stage, target: self.target });\n+        Installer::new(builder.build).install_cargo(self.stage, self.target);\n+    };\n+    // rules.install(\"install-rls\", \"rls\")\n+    //      .default(build.config.extended)\n+    //      .host(true)\n+    //      .only_host_build(true)\n+    //      .dep(|s| s.name(\"dist-rls\"))\n+    //      .run(move |s| install::Installer::new(build).install_rls(s.stage, s.target));\n+    Rls, \"rls\", builder.build.config.extended, only_hosts: true, (self, builder), {\n+        builder.ensure(dist::Rls { stage: self.stage, target: self.target });\n+        Installer::new(builder.build).install_rls(self.stage, self.target);\n+    };\n+    // rules.install(\"install-analysis\", \"analysis\")\n+    //      .default(build.config.extended)\n+    //      .only_host_build(true)\n+    //      .dep(|s| s.name(\"dist-analysis\"))\n+    //      .run(move |s| install::Installer::new(build).install_analysis(s.stage, s.target));\n+    Analysis, \"analysis\", builder.build.config.extended, only_hosts: false, (self, builder), {\n+        builder.ensure(dist::Analysis {\n+            compiler: builder.compiler(self.stage, self.host),\n+            target: self.target\n+        });\n+        Installer::new(builder.build).install_analysis(self.stage, self.target);\n+    };\n+    // rules.install(\"install-src\", \"src\")\n+    //      .default(build.config.extended)\n+    //      .host(true)\n+    //      .only_build(true)\n+    //      .only_host_build(true)\n+    //      .dep(|s| s.name(\"dist-src\"))\n+    //      .run(move |s| install::Installer::new(build).install_src(s.stage));\n+    Src, \"src\", builder.build.config.extended, only_hosts: true, (self, builder), {\n+        builder.ensure(dist::Src);\n+        Installer::new(builder.build).install_src(self.stage);\n+    }, ONLY_BUILD;\n+    // rules.install(\"install-rustc\", \"src/librustc\")\n+    //      .default(true)\n+    //      .host(true)\n+    //      .only_host_build(true)\n+    //      .dep(|s| s.name(\"dist-rustc\"))\n+    //      .run(move |s| install::Installer::new(build).install_rustc(s.stage, s.target));\n+    Rustc, \"src/librustc\", builder.build.config.extended, only_hosts: true, (self, builder), {\n+        builder.ensure(dist::Rustc { stage: self.stage, host: self.host });\n+        Installer::new(builder.build).install_rustc(self.stage, self.target);\n+    };\n+);"}, {"sha": "2b44f33db8e182c3f821617f51eada8b6a935564", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "patch": "@@ -33,7 +33,7 @@ use Build;\n use util;\n use build_helper::up_to_date;\n \n-/j/ rules.build(\"llvm\", \"src/llvm\")\n+// rules.build(\"llvm\", \"src/llvm\")\n //      .host(true)\n //      .dep(move |s| {\n //          if s.target == build.build {\n@@ -51,6 +51,7 @@ pub struct Llvm<'a> {\n \n impl<'a> Step<'a> for Llvm<'a> {\n     type Output = ();\n+    const ONLY_HOSTS: bool = true;\n \n     /// Compile LLVM for `target`.\n     fn run(self, builder: &Builder) {\n@@ -151,6 +152,7 @@ impl<'a> Step<'a> for Llvm<'a> {\n \n         // http://llvm.org/docs/HowToCrossCompileLLVM.html\n         if target != build.build {\n+            builder.ensure(Llvm { target: &build.build });\n             // FIXME: if the llvm root for the build triple is overridden then we\n             //        should use llvm-tblgen from there, also should verify that it\n             //        actually exists most of the time in normal installs of LLVM.\n@@ -249,6 +251,14 @@ pub struct TestHelpers<'a> {\n impl<'a> Step<'a> for TestHelpers<'a> {\n     type Output = ();\n \n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/rt/rust_test_helpers.c\")\n+    }\n+\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+        builder.ensure(TestHelpers { target })\n+    }\n+\n     /// Compiles the `rust_test_helpers.c` library which we used in various\n     /// `run-pass` test suites for ABI testing.\n     fn run(self, builder: &Builder) {\n@@ -295,12 +305,16 @@ const OPENSSL_SHA256: &'static str =\n \n #[derive(Serialize)]\n pub struct Openssl<'a> {\n-    target: &'a str,\n+    pub target: &'a str,\n }\n \n impl<'a> Step<'a> for Openssl<'a> {\n     type Output = ();\n \n+    fn should_run(_builder: &Builder, _path: &Path) -> bool {\n+        false\n+    }\n+\n     fn run(self, builder: &Builder) {\n         let build = bulder.build;\n         let target = self.target;"}, {"sha": "442ca7aadbc0583476ef90b1eda7b60d191d5ad7", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 249, "deletions": 80, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3413d825fa61a16fcfaa37a114eaf3efe88eb3/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=6b3413d825fa61a16fcfaa37a114eaf3efe88eb3", "patch": "@@ -15,7 +15,7 @@ use std::process::Command;\n use Mode;\n use builder::{Step, Builder};\n use util::{exe, add_lib_path};\n-use compile::{self, stamp, Rustc};\n+use compile::{self, libtest_stamp, libstd_stamp, librustc_stamp, Rustc};\n use native;\n use channel::GitInfo;\n \n@@ -63,7 +63,7 @@ impl<'a> Step<'a> for CleanTools<'a> {\n         let target = self.target;\n         let mode = self.mode;\n \n-        let compiler = Compiler::new(stage, &build.build);\n+        let compiler = builder.compiler(stage, &build.build);\n \n         let stamp = match mode {\n             Mode::Libstd => libstd_stamp(build, &compiler, target),\n@@ -76,103 +76,39 @@ impl<'a> Step<'a> for CleanTools<'a> {\n     }\n }\n \n-// rules.build(\"tool-rustbook\", \"src/tools/rustbook\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"librustc-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"rustbook\"));\n-// rules.build(\"tool-error-index\", \"src/tools/error_index_generator\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"librustc-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n-// rules.build(\"tool-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"unstable-book-gen\"));\n-// rules.build(\"tool-tidy\", \"src/tools/tidy\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"tidy\"));\n-// rules.build(\"tool-linkchecker\", \"src/tools/linkchecker\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"linkchecker\"));\n-// rules.build(\"tool-cargotest\", \"src/tools/cargotest\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"cargotest\"));\n-// rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libtest-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n-// rules.build(\"tool-build-manifest\", \"src/tools/build-manifest\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n-// rules.build(\"tool-remote-test-server\", \"src/tools/remote-test-server\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-server\"));\n-// rules.build(\"tool-remote-test-client\", \"src/tools/remote-test-client\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-client\"));\n-// rules.build(\"tool-rust-installer\", \"src/tools/rust-installer\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"rust-installer\"));\n-// rules.build(\"tool-cargo\", \"src/tools/cargo\")\n-//      .host(true)\n-//      .default(build.config.extended)\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n-//      .dep(move |s| {\n-//          // Cargo depends on procedural macros, which requires a full host\n-//          // compiler to be available, so we need to depend on that.\n-//          s.name(\"librustc-link\")\n-//           .target(&build.build)\n-//           .host(&build.build)\n-//      })\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"cargo\"));\n-// rules.build(\"tool-rls\", \"src/tools/rls\")\n-//      .host(true)\n-//      .default(build.config.extended)\n-//      .dep(|s| s.name(\"librustc-tool\"))\n-//      .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n-//      .dep(move |s| {\n-//          // rls, like cargo, uses procedural macros\n-//          s.name(\"librustc-link\")\n-//           .target(&build.build)\n-//           .host(&build.build)\n-//      })\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"rls\"));\n-//\n-\n #[derive(Serialize)]\n-pub struct Tool<'a> {\n+pub struct ToolBuild<'a> {\n     pub stage: u32,\n     pub target: &'a str,\n     pub tool: &'a str,\n+    pub mode: Mode,\n }\n \n-impl<'a> Step<'a> for Tool<'a> {\n-    type Output = ();\n+impl<'a> Step<'a> for ToolBuild<'a> {\n+    type Output = PathBuf;\n \n     /// Build a tool in `src/tools`\n     ///\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n         let tool = self.tool;\n \n+        let compiler = builder.compiler(stage, &build.build);\n+        builder.ensure(CleanTools { stage, target, mode: self.mode });\n+        match self.mode {\n+            Mode::Libstd => builder.ensure(compile::Std { compiler, target }),\n+            Mode::Libtest => builder.ensure(compile::Test { compiler, target }),\n+            Mode::Librustc => builder.ensure(compile::Rustc { compiler, target }),\n+            Mode::Tool => panic!(\"unexpected Mode::Tool for tool build\")\n+        }\n+\n         let _folder = build.fold_output(|| format!(\"stage{}-{}\", stage, tool));\n         println!(\"Building stage{} tool {} ({})\", stage, tool, target);\n \n-        let compiler = Compiler::new(stage, &build.build);\n-\n         let mut cargo = build.cargo(&compiler, Mode::Tool, target, \"build\");\n         let dir = build.src.join(\"src/tools\").join(tool);\n         cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n@@ -201,5 +137,238 @@ impl<'a> Step<'a> for Tool<'a> {\n         }\n \n         build.run(&mut cargo);\n+        build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, compiler.host))\n+    }\n+}\n+\n+macro_rules! tool {\n+    ($($name:ident, $path:expr, $tool_name:expr, $mode:expr;)+) => {\n+        #[derive(Copy, Clone)]\n+        pub enum Tool {\n+            $(\n+                $name,\n+            )+\n+        }\n+\n+        impl<'a> Builder<'a> {\n+            pub fn tool_exe(&self, tool: Tool) -> PathBuf {\n+                match tool {\n+                    $(Tool::$name =>\n+                        self.ensure($name {\n+                            stage: 0,\n+                            target: &self.build.build,\n+                        }),\n+                    )+\n+                }\n+            }\n+        }\n+\n+        $(\n+        #[derive(Serialize)]\n+        pub struct $name<'a> {\n+            pub stage: u32,\n+            pub target: &'a str,\n+        }\n+\n+        impl<'a> Step<'a> for $name<'a> {\n+            type Output = PathBuf;\n+            const NAME: &'static str = concat!(stringify!($name), \" tool\");\n+\n+            fn should_run(_builder: &Builder, path: &Path) -> bool {\n+                path.ends_with($path)\n+            }\n+\n+            fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+                builder.ensure($name {\n+                    stage: builder.top_stage,\n+                    target,\n+                });\n+            }\n+\n+            fn run(self, builder: &Builder) -> PathBuf {\n+                builder.ensure(ToolBuild {\n+                    stage: self.stage,\n+                    target: self.target,\n+                    tool: $tool_name,\n+                    mode: $mode,\n+                })\n+            }\n+        }\n+        )+\n+    }\n+}\n+\n+tool!(\n+    // rules.build(\"tool-rustbook\", \"src/tools/rustbook\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"librustc-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"rustbook\"));\n+    Rustbook, \"src/tools/rustbook\", \"rustbook\", Mode::Librustc;\n+    // rules.build(\"tool-error-index\", \"src/tools/error_index_generator\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"librustc-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n+    ErrorIndex, \"src/tools/error_index_generator\", \"error_index_generator\", Mode::Librustc;\n+    // rules.build(\"tool-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"libstd-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"unstable-book-gen\"));\n+    UnstableBook, \"src/tools/unstable-book-gen\", \"unstable-book-gen\", Mode::Libstd;\n+    // rules.build(\"tool-tidy\", \"src/tools/tidy\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"libstd-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"tidy\"));\n+    Tidy, \"src/tools/tidy\", \"tidy\", Mode::Libstd;\n+    // rules.build(\"tool-linkchecker\", \"src/tools/linkchecker\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"libstd-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"linkchecker\"));\n+    Linkchecker, \"src/tools/linkchecker\", \"linkchecker\", Mode::Libstd;\n+    // rules.build(\"tool-cargotest\", \"src/tools/cargotest\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"libstd-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"cargotest\"));\n+    CargoTest, \"src/tools/cargotest\", \"cargotest\", Mode::Libstd;\n+    // rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"libtest-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n+    Compiletest, \"src/tools/compiletest\", \"compiletest\", Mode::Libtest;\n+    // rules.build(\"tool-build-manifest\", \"src/tools/build-manifest\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"libstd-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n+    BuildManifest, \"src/tools/build-manifest\", \"build-manifest\", Mode::Libstd;\n+    // rules.build(\"tool-remote-test-server\", \"src/tools/remote-test-server\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"libstd-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-server\"));\n+    RemoteTestServer, \"src/tools/remote-test-server\", \"remote-test-server\", Mode::Libstd;\n+    // rules.build(\"tool-remote-test-client\", \"src/tools/remote-test-client\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"libstd-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-client\"));\n+    RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\", Mode::Libstd;\n+    // rules.build(\"tool-rust-installer\", \"src/tools/rust-installer\")\n+    //      .dep(|s| s.name(\"maybe-clean-tools\"))\n+    //      .dep(|s| s.name(\"libstd-tool\"))\n+    //      .run(move |s| compile::tool(build, s.stage, s.target, \"rust-installer\"));\n+    RustInstaller, \"src/tools/rust-installer\", \"rust-installer\", Mode::Libstd;\n+);\n+\n+// rules.build(\"tool-cargo\", \"src/tools/cargo\")\n+//      .host(true)\n+//      .default(build.config.extended)\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n+//      .dep(move |s| {\n+//          // Cargo depends on procedural macros, which requires a full host\n+//          // compiler to be available, so we need to depend on that.\n+//          s.name(\"librustc-link\")\n+//           .target(&build.build)\n+//           .host(&build.build)\n+//      })\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"cargo\"));\n+#[derive(Serialize)]\n+pub struct Cargo<'a> {\n+    pub stage: u32,\n+    pub target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Cargo<'a> {\n+    type Output = PathBuf;\n+    const NAME: &'static str = \"cargo tool\";\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/tools/cargo\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+        if path.is_none() && !builder.build.config.extended {\n+            return;\n+        }\n+        builder.ensure(Cargo {\n+            stage: builder.top_stage,\n+            target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) -> PathBuf {\n+        builder.ensure(native::Openssl {\n+            target: self.target,\n+        });\n+        // Cargo depends on procedural macros, which requires a full host\n+        // compiler to be available, so we need to depend on that.\n+        builder.ensure(Rustc {\n+            compiler: builder.compiler(builder.top_stage, &builder.build.build),\n+            target: &builder.build.build,\n+        });\n+        builder.ensure(ToolBuild {\n+            stage: self.stage,\n+            target: self.target,\n+            tool: \"cargo\",\n+            mode: Mode::Libstd,\n+        })\n+    }\n+}\n+\n+// rules.build(\"tool-rls\", \"src/tools/rls\")\n+//      .host(true)\n+//      .default(build.config.extended)\n+//      .dep(|s| s.name(\"librustc-tool\"))\n+//      .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n+//      .dep(move |s| {\n+//          // rls, like cargo, uses procedural macros\n+//          s.name(\"librustc-link\")\n+//           .target(&build.build)\n+//           .host(&build.build)\n+//      })\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"rls\"));\n+//\n+#[derive(Serialize)]\n+pub struct Rls<'a> {\n+    pub stage: u32,\n+    pub target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Rls<'a> {\n+    type Output = PathBuf;\n+    const NAME: &'static str = \"RLS tool\";\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/tools/rls\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+        if path.is_none() && !builder.build.config.extended {\n+            return;\n+        }\n+        builder.ensure(Cargo {\n+            stage: builder.top_stage,\n+            target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) -> PathBuf {\n+        builder.ensure(native::Openssl {\n+            target: self.target,\n+        });\n+        // RLS depends on procedural macros, which requires a full host\n+        // compiler to be available, so we need to depend on that.\n+        builder.ensure(Rustc {\n+            compiler: builder.compiler(builder.top_stage, &builder.build.build),\n+            target: &builder.build.build,\n+        });\n+        builder.ensure(ToolBuild {\n+            stage: self.stage,\n+            target: self.target,\n+            tool: \"rls\",\n+            mode: Mode::Librustc,\n+        })\n     }\n }"}]}