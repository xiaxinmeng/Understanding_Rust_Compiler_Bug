{"sha": "f23b782101c03331413870a11a787d4b605b84df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyM2I3ODIxMDFjMDMzMzE0MTM4NzBhMTFhNzg3ZDRiNjA1Yjg0ZGY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-02T07:03:45Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-05T21:48:48Z"}, "message": "align small malloc-allocations even less, and test that we do", "tree": {"sha": "b0b566c24e46a54f36df06f65aec1d271f6c22bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0b566c24e46a54f36df06f65aec1d271f6c22bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f23b782101c03331413870a11a787d4b605b84df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f23b782101c03331413870a11a787d4b605b84df", "html_url": "https://github.com/rust-lang/rust/commit/f23b782101c03331413870a11a787d4b605b84df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f23b782101c03331413870a11a787d4b605b84df/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "285fc0d70e33e91016d288f0afd0971a85095f3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/285fc0d70e33e91016d288f0afd0971a85095f3c", "html_url": "https://github.com/rust-lang/rust/commit/285fc0d70e33e91016d288f0afd0971a85095f3c"}], "stats": {"total": 85, "additions": 58, "deletions": 27}, "files": [{"sha": "a58903f6d5160470f820c7eec88028e7c6bb8610", "filename": "src/machine.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f23b782101c03331413870a11a787d4b605b84df/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23b782101c03331413870a11a787d4b605b84df/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=f23b782101c03331413870a11a787d4b605b84df", "patch": "@@ -25,6 +25,8 @@ pub enum MiriMemoryKind {\n     Rust,\n     /// `malloc` memory.\n     C,\n+    /// Windows `HeapAlloc` memory.\n+    WinHeap,\n     /// Part of env var emulation.\n     Env,\n     /// Statics.\n@@ -407,7 +409,7 @@ impl MayLeak for MiriMemoryKind {\n     fn may_leak(self) -> bool {\n         use self::MiriMemoryKind::*;\n         match self {\n-            Rust | C => false,\n+            Rust | C | WinHeap => false,\n             Env | Static => true,\n         }\n     }"}, {"sha": "38fc36609e698b1dce89000bebf33f90e3078117", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f23b782101c03331413870a11a787d4b605b84df/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23b782101c03331413870a11a787d4b605b84df/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=f23b782101c03331413870a11a787d4b605b84df", "patch": "@@ -10,30 +10,48 @@ use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    /// Returns the minimum alignment for the target architecture.\n-    fn min_align(&self) -> Align {\n+    /// Returns the minimum alignment for the target architecture for allocations of the given size.\n+    fn min_align(&self, size: u64, kind: MiriMemoryKind) -> Align {\n         let this = self.eval_context_ref();\n         // List taken from `libstd/sys_common/alloc.rs`.\n         let min_align = match this.tcx.tcx.sess.target.target.arch.as_str() {\n             \"x86\" | \"arm\" | \"mips\" | \"powerpc\" | \"powerpc64\" | \"asmjs\" | \"wasm32\" => 8,\n             \"x86_64\" | \"aarch64\" | \"mips64\" | \"s390x\" | \"sparc64\" => 16,\n             arch => bug!(\"Unsupported target architecture: {}\", arch),\n         };\n-        Align::from_bytes(min_align).unwrap()\n+        // Windows always aligns, even small allocations.\n+        // Source: <https://support.microsoft.com/en-us/help/286470/how-to-use-pageheap-exe-in-windows-xp-windows-2000-and-windows-server>\n+        // But jemalloc does not, so for the C heap we only align if the allocation is sufficiently big.\n+        if kind == MiriMemoryKind::WinHeap || size >= min_align {\n+            return Align::from_bytes(min_align).unwrap();\n+        }\n+        // We have `size < min_align`. Round `size` *down* to the next power of two and use that.\n+        fn prev_power_of_two(x: u64) -> u64 {\n+            let next_pow2 = x.next_power_of_two();\n+            if next_pow2 == x {\n+                // x *is* a power of two, just use that.\n+                x\n+            } else {\n+                // x is between two powers, so next = 2*prev.\n+                next_pow2 / 2\n+            }\n+        }\n+        Align::from_bytes(prev_power_of_two(size)).unwrap()\n     }\n \n     fn malloc(\n         &mut self,\n         size: u64,\n         zero_init: bool,\n+        kind: MiriMemoryKind,\n     ) -> Scalar<Tag> {\n         let this = self.eval_context_mut();\n         let tcx = &{this.tcx.tcx};\n         if size == 0 {\n             Scalar::from_int(0, this.pointer_size())\n         } else {\n-            let align = this.min_align();\n-            let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n+            let align = this.min_align(size, kind);\n+            let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, kind.into());\n             if zero_init {\n                 // We just allocated this, the access cannot fail\n                 this.memory_mut()\n@@ -47,14 +65,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn free(\n         &mut self,\n         ptr: Scalar<Tag>,\n+        kind: MiriMemoryKind,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if !this.is_null(ptr)? {\n             let ptr = this.force_ptr(ptr)?;\n             this.memory_mut().deallocate(\n                 ptr,\n                 None,\n-                MiriMemoryKind::C.into(),\n+                kind.into(),\n             )?;\n         }\n         Ok(())\n@@ -64,39 +83,38 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         old_ptr: Scalar<Tag>,\n         new_size: u64,\n+        kind: MiriMemoryKind,\n     ) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n-        let align = this.min_align();\n+        let new_align = this.min_align(new_size, kind);\n         if this.is_null(old_ptr)? {\n             if new_size == 0 {\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n             } else {\n                 let new_ptr = this.memory_mut().allocate(\n                     Size::from_bytes(new_size),\n-                    align,\n-                    MiriMemoryKind::C.into()\n+                    new_align,\n+                    kind.into()\n                 );\n                 Ok(Scalar::Ptr(new_ptr))\n             }\n         } else {\n             let old_ptr = this.force_ptr(old_ptr)?;\n             let memory = this.memory_mut();\n-            let old_size = Size::from_bytes(memory.get(old_ptr.alloc_id)?.bytes.len() as u64);\n             if new_size == 0 {\n                 memory.deallocate(\n                     old_ptr,\n-                    Some((old_size, align)),\n-                    MiriMemoryKind::C.into(),\n+                    None,\n+                    kind.into(),\n                 )?;\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n             } else {\n                 let new_ptr = memory.reallocate(\n                     old_ptr,\n-                    old_size,\n-                    align,\n+                    None,\n                     Size::from_bytes(new_size),\n-                    align,\n-                    MiriMemoryKind::C.into(),\n+                    new_align,\n+                    kind.into(),\n                 )?;\n                 Ok(Scalar::Ptr(new_ptr))\n             }\n@@ -145,14 +163,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             \"malloc\" => {\n                 let size = this.read_scalar(args[0])?.to_usize(this)?;\n-                let res = this.malloc(size, /*zero_init:*/ false);\n+                let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n                 let items = this.read_scalar(args[0])?.to_usize(this)?;\n                 let len = this.read_scalar(args[1])?.to_usize(this)?;\n                 let size = items.checked_mul(len).ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n-                let res = this.malloc(size, /*zero_init:*/ true);\n+                let res = this.malloc(size, /*zero_init:*/ true, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"posix_memalign\" => {\n@@ -187,12 +205,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"free\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                this.free(ptr)?;\n+                this.free(ptr, MiriMemoryKind::C)?;\n             }\n             \"realloc\" => {\n                 let old_ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let new_size = this.read_scalar(args[1])?.to_usize(this)?;\n-                let res = this.realloc(old_ptr, new_size)?;\n+                let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n                 this.write_scalar(res, dest)?;\n             }\n \n@@ -262,12 +280,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n+                let align = Align::from_bytes(align).unwrap();\n                 let new_ptr = this.memory_mut().reallocate(\n                     ptr,\n-                    Size::from_bytes(old_size),\n-                    Align::from_bytes(align).unwrap(),\n+                    Some((Size::from_bytes(old_size), align)),\n                     Size::from_bytes(new_size),\n-                    Align::from_bytes(align).unwrap(),\n+                    align,\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n                 this.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n@@ -765,22 +783,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let flags = this.read_scalar(args[1])?.to_u32()?;\n                 let size = this.read_scalar(args[2])?.to_usize(this)?;\n                 let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n-                let res = this.malloc(size, zero_init);\n+                let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap);\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n                 let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n                 let _flags = this.read_scalar(args[1])?.to_u32()?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n-                this.free(ptr)?;\n+                this.free(ptr, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(Scalar::from_int(1, Size::from_bytes(4)), dest)?;\n             }\n             \"HeapReAlloc\" => {\n                 let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n                 let _flags = this.read_scalar(args[1])?.to_u32()?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n                 let size = this.read_scalar(args[3])?.to_usize(this)?;\n-                let res = this.realloc(ptr, size)?;\n+                let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(res, dest)?;\n             }\n "}, {"sha": "a50b3f3606de35a5757c6c587d5847c9245797ee", "filename": "tests/run-pass/malloc.rs", "status": "renamed", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f23b782101c03331413870a11a787d4b605b84df/tests%2Frun-pass%2Fmalloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23b782101c03331413870a11a787d4b605b84df/tests%2Frun-pass%2Fmalloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmalloc.rs?ref=f23b782101c03331413870a11a787d4b605b84df", "patch": "@@ -1,4 +1,5 @@\n //ignore-windows: Uses POSIX APIs\n+//compile-flags: -Zmiri-seed=\n \n #![feature(rustc_private)]\n \n@@ -7,6 +8,16 @@ use core::{slice, ptr};\n extern crate libc;\n \n fn main() {\n+    // Test that small allocations sometimes *are* not very aligned.\n+    let saw_unaligned = (0..64).any(|_| unsafe {\n+        let p = libc::malloc(3);\n+        let addr = p as usize;\n+        let unaligned = addr % 4 != 0; // test that this is not 4-aligned\n+        libc::free(p); // FIXME have to free *after* test; should allow ptr-to-int of dangling ptr.\n+        unaligned\n+    });\n+    assert!(saw_unaligned);\n+\n     unsafe {\n         // Use calloc for initialized memory\n         let p1 = libc::calloc(20, 1);", "previous_filename": "tests/run-pass/realloc.rs"}]}