{"sha": "b924ec1484bfca00c42a8aff68d77c41d4cd1ea6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MjRlYzE0ODRiZmNhMDBjNDJhOGFmZjY4ZDc3YzQxZDRjZDFlYTY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-07-26T10:35:23Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T13:15:09Z"}, "message": "async-llvm(13): Submit LLVM work packages from base::trans_crate().", "tree": {"sha": "635841dfc973e88449b73e2c9683b59dd62df909", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/635841dfc973e88449b73e2c9683b59dd62df909"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b924ec1484bfca00c42a8aff68d77c41d4cd1ea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b924ec1484bfca00c42a8aff68d77c41d4cd1ea6", "html_url": "https://github.com/rust-lang/rust/commit/b924ec1484bfca00c42a8aff68d77c41d4cd1ea6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b924ec1484bfca00c42a8aff68d77c41d4cd1ea6/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "397b2a800f7a25e81c2aaab2ac0291adbfdce3ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/397b2a800f7a25e81c2aaab2ac0291adbfdce3ce", "html_url": "https://github.com/rust-lang/rust/commit/397b2a800f7a25e81c2aaab2ac0291adbfdce3ce"}], "stats": {"total": 177, "additions": 90, "deletions": 87}, "files": [{"sha": "ba4a6c0d67dd8296cb0a4cf7a855ad13a6f99bbd", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b924ec1484bfca00c42a8aff68d77c41d4cd1ea6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b924ec1484bfca00c42a8aff68d77c41d4cd1ea6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b924ec1484bfca00c42a8aff68d77c41d4cd1ea6", "patch": "@@ -229,7 +229,7 @@ pub fn compile_input(sess: &Session,\n         sess.code_stats.borrow().print_type_sizes();\n     }\n \n-    let (phase5_result, trans) = phase_5_run_llvm_passes(sess, trans, &outputs);\n+    let (phase5_result, trans) = phase_5_run_llvm_passes(sess, trans);\n \n     controller_entry_point!(after_llvm,\n                             sess,\n@@ -1071,10 +1071,9 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n pub fn phase_5_run_llvm_passes(sess: &Session,\n-                               trans: write::OngoingCrateTranslation,\n-                               outputs: &OutputFilenames)\n+                               trans: write::OngoingCrateTranslation)\n                                -> (CompileResult, trans::CrateTranslation) {\n-    let trans = trans.join(sess, outputs);\n+    let trans = trans.join(sess);\n \n     if sess.opts.debugging_opts.incremental_info {\n         write::dump_incremental_data(&trans);"}, {"sha": "c1c85394698c906afd7e576a815345175d159e70", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b924ec1484bfca00c42a8aff68d77c41d4cd1ea6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b924ec1484bfca00c42a8aff68d77c41d4cd1ea6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=b924ec1484bfca00c42a8aff68d77c41d4cd1ea6", "patch": "@@ -662,11 +662,8 @@ fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n }\n \n pub fn run_passes(sess: &Session,\n-                  modules: Vec<ModuleTranslation>,\n-                  metadata_module: ModuleTranslation,\n-                  allocator_module: Option<ModuleTranslation>,\n                   crate_output: &OutputFilenames,\n-\n+                  total_work_item_count: usize,\n                   crate_name: Symbol,\n                   link: LinkMeta,\n                   metadata: EncodedMetadata,\n@@ -695,12 +692,6 @@ pub fn run_passes(sess: &Session,\n         sess.opts.output_types.clone()\n     };\n \n-    // Sanity check\n-    assert!(modules.len() == sess.opts.cg.codegen_units ||\n-            sess.opts.debugging_opts.incremental.is_some() ||\n-            !sess.opts.output_types.should_trans() ||\n-            sess.opts.debugging_opts.no_trans);\n-\n     // Figure out what we actually need to build.\n \n     let mut modules_config = ModuleConfig::new(sess, sess.opts.cg.passes.clone());\n@@ -776,38 +767,11 @@ pub fn run_passes(sess: &Session,\n     metadata_config.set_flags(sess, no_builtins);\n     allocator_config.set_flags(sess, no_builtins);\n \n-\n-    // Populate a buffer with a list of codegen threads.  Items are processed in\n-    // LIFO order, just because it's a tiny bit simpler that way.  (The order\n-    // doesn't actually matter.)\n-    let mut work_items = Vec::with_capacity(1 + modules.len());\n-\n-    {\n-        let work = build_work_item(metadata_module,\n-                                   metadata_config.clone(sess),\n-                                   crate_output.clone());\n-        work_items.push(work);\n-    }\n-\n-    if let Some(allocator) = allocator_module {\n-        let work = build_work_item(allocator,\n-                                   allocator_config.clone(sess),\n-                                   crate_output.clone());\n-        work_items.push(work);\n-    }\n-\n-    for mtrans in modules {\n-        let work = build_work_item(mtrans,\n-                                   modules_config.clone(sess),\n-                                   crate_output.clone());\n-        work_items.push(work);\n-    }\n-\n     let client = sess.jobserver_from_env.clone().unwrap_or_else(|| {\n         // Pick a \"reasonable maximum\" if we don't otherwise have a jobserver in\n         // our environment, capping out at 32 so we don't take everything down\n         // by hogging the process run queue.\n-        let num_workers = cmp::min(work_items.len() - 1, 32);\n+        let num_workers = cmp::min(total_work_item_count - 1, 32);\n         Client::new(num_workers).expect(\"failed to create jobserver\")\n     });\n \n@@ -816,16 +780,13 @@ pub fn run_passes(sess: &Session,\n     let (coordinator_send, coordinator_receive) = channel();\n \n     let coordinator_thread = start_executing_work(sess,\n-                                                  work_items.len(),\n+                                                  total_work_item_count,\n                                                   shared_emitter,\n                                                   trans_worker_send,\n                                                   coordinator_send.clone(),\n                                                   coordinator_receive,\n                                                   client,\n                                                   exported_symbols.clone());\n-    for work_item in work_items {\n-        coordinator_send.send(Message::WorkItem(work_item)).unwrap();\n-    }\n \n     OngoingCrateTranslation {\n         crate_name,\n@@ -837,6 +798,12 @@ pub fn run_passes(sess: &Session,\n         linker_info,\n         no_integrated_as,\n \n+        regular_module_config: modules_config,\n+        metadata_module_config: metadata_config,\n+        allocator_module_config: allocator_config,\n+\n+        output_filenames: crate_output.clone(),\n+        coordinator_send,\n         shared_emitter_main,\n         future: coordinator_thread\n     }\n@@ -1583,22 +1550,29 @@ pub struct OngoingCrateTranslation {\n     pub linker_info: LinkerInfo,\n     pub no_integrated_as: bool,\n \n+    output_filenames: OutputFilenames,\n+    regular_module_config: ModuleConfig,\n+    metadata_module_config: ModuleConfig,\n+    allocator_module_config: ModuleConfig,\n+\n+    coordinator_send: Sender<Message>,\n     shared_emitter_main: SharedEmitterMain,\n     future: thread::JoinHandle<CompiledModules>,\n }\n \n impl OngoingCrateTranslation {\n-    pub fn join(self,\n-                sess: &Session,\n-                outputs: &OutputFilenames)\n-                -> CrateTranslation {\n+    pub fn join(self, sess: &Session) -> CrateTranslation {\n         self.shared_emitter_main.check(sess, true);\n         let compiled_modules = self.future.join().unwrap();\n \n         sess.abort_if_errors();\n \n-        copy_module_artifacts_into_incr_comp_cache(sess, &compiled_modules, outputs);\n-        produce_final_output_artifacts(sess, &compiled_modules, outputs);\n+        copy_module_artifacts_into_incr_comp_cache(sess,\n+                                                   &compiled_modules,\n+                                                   &self.output_filenames);\n+        produce_final_output_artifacts(sess,\n+                                       &compiled_modules,\n+                                       &self.output_filenames);\n \n         // FIXME: time_llvm_passes support - does this use a global context or\n         // something?\n@@ -1621,24 +1595,41 @@ impl OngoingCrateTranslation {\n         };\n \n         if self.no_integrated_as {\n-            run_assembler(sess, outputs);\n+            run_assembler(sess,  &self.output_filenames);\n \n             // HACK the linker expects the object file to be named foo.0.o but\n             // `run_assembler` produces an object named just foo.o. Rename it if we\n             // are going to build an executable\n             if sess.opts.output_types.contains_key(&OutputType::Exe) {\n-                let f = outputs.path(OutputType::Object);\n+                let f =  self.output_filenames.path(OutputType::Object);\n                 rename_or_copy_remove(&f,\n-                         f.with_file_name(format!(\"{}.0.o\",\n-                                                  f.file_stem().unwrap().to_string_lossy()))).unwrap();\n+                    f.with_file_name(format!(\"{}.0.o\",\n+                                             f.file_stem().unwrap().to_string_lossy()))).unwrap();\n             }\n \n             // Remove assembly source, unless --save-temps was specified\n             if !sess.opts.cg.save_temps {\n-                fs::remove_file(&outputs.temp_path(OutputType::Assembly, None)).unwrap();\n+                fs::remove_file(&self.output_filenames\n+                                     .temp_path(OutputType::Assembly, None)).unwrap();\n             }\n         }\n \n         trans\n     }\n+\n+    pub fn submit_translated_module_to_llvm(&self,\n+                                            sess: &Session,\n+                                            mtrans: ModuleTranslation) {\n+        let module_config = match mtrans.kind {\n+            ModuleKind::Regular => self.regular_module_config.clone(sess),\n+            ModuleKind::Metadata => self.metadata_module_config.clone(sess),\n+            ModuleKind::Allocator => self.allocator_module_config.clone(sess),\n+        };\n+\n+        let work_item = build_work_item(mtrans,\n+                                        module_config,\n+                                        self.output_filenames.clone());\n+\n+        drop(self.coordinator_send.send(Message::WorkItem(work_item)));\n+    }\n }"}, {"sha": "144c1efd23b7d2d4ff916c679f99a216a82b4087", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 43, "deletions": 30, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b924ec1484bfca00c42a8aff68d77c41d4cd1ea6/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b924ec1484bfca00c42a8aff68d77c41d4cd1ea6/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b924ec1484bfca00c42a8aff68d77c41d4cd1ea6", "patch": "@@ -963,20 +963,22 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n        !tcx.sess.opts.output_types.should_trans() {\n         let empty_exported_symbols = ExportedSymbols::empty();\n         let linker_info = LinkerInfo::new(&shared_ccx, &empty_exported_symbols);\n-        return write::run_passes(tcx.sess,\n-                                 vec![],\n-                                 metadata_module,\n-                                 None,\n-                                 output_filenames,\n-\n-                                 tcx.crate_name(LOCAL_CRATE),\n-                                 link_meta,\n-                                 metadata,\n-                                 Arc::new(empty_exported_symbols),\n-                                 no_builtins,\n-                                 None,\n-                                 linker_info,\n-                                 false);\n+        let ongoing_translation = write::run_passes(\n+            tcx.sess,\n+            output_filenames,\n+            1,\n+            tcx.crate_name(LOCAL_CRATE),\n+            link_meta,\n+            metadata,\n+            Arc::new(empty_exported_symbols),\n+            no_builtins,\n+            None,\n+            linker_info,\n+            false);\n+\n+        ongoing_translation.submit_translated_module_to_llvm(tcx.sess, metadata_module);\n+\n+        return ongoing_translation;\n     }\n \n     let exported_symbols = Arc::new(ExportedSymbols::compute(tcx,\n@@ -1236,22 +1238,33 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               link_meta.crate_hash));\n     // ---\n \n-    time(sess.time_passes(),\n-         \"LLVM passes\",\n-         || write::run_passes(sess,\n-                              modules,\n-                              metadata_module,\n-                              allocator_module,\n-                              outputs,\n-\n-                              tcx.crate_name(LOCAL_CRATE),\n-                              link_meta,\n-                              metadata,\n-                              exported_symbols,\n-                              no_builtins,\n-                              windows_subsystem,\n-                              linker_info,\n-                              no_integrated_as))\n+    let total_module_count = modules.len() + 1 +\n+        if allocator_module.is_some() { 1 } else { 0 };\n+\n+    let ongoing_translation = write::run_passes(\n+        sess,\n+        outputs,\n+        total_module_count,\n+        tcx.crate_name(LOCAL_CRATE),\n+        link_meta,\n+        metadata,\n+        exported_symbols,\n+        no_builtins,\n+        windows_subsystem,\n+        linker_info,\n+        no_integrated_as);\n+\n+    ongoing_translation.submit_translated_module_to_llvm(sess, metadata_module);\n+\n+    for mtrans in modules {\n+        ongoing_translation.submit_translated_module_to_llvm(sess, mtrans);\n+    }\n+\n+    if let Some(allocator_module) = allocator_module {\n+        ongoing_translation.submit_translated_module_to_llvm(sess, allocator_module);\n+    }\n+\n+    ongoing_translation\n }\n \n #[inline(never)] // give this a place in the profiler"}]}