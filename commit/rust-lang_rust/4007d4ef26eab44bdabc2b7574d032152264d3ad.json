{"sha": "4007d4ef26eab44bdabc2b7574d032152264d3ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMDdkNGVmMjZlYWI0NGJkYWJjMmI3NTc0ZDAzMjE1MjI2NGQzYWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-01T06:00:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-01T06:00:33Z"}, "message": "Auto merge of #66917 - Centril:rollup-xj2enik, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #66503 (More useful test error messages on should_panic(expected=...) mismatch)\n - #66662 (Miri: run panic-catching tests in liballoc)\n - #66679 (Improve lifetime errors with implicit trait object lifetimes)\n - #66726 (Use recursion_limit for const eval stack limit)\n - #66790 (Do `min_const_fn` checks for `SetDiscriminant`s target)\n - #66832 (const_prop: detect and avoid catching Miri errors that require allocation)\n - #66880 (Add long error code explanation message for E0203)\n - #66890 (Format liballoc with rustfmt)\n - #66896 (pass Queries to compiler callbacks)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "feada823fc5b16040da2f7aba36cda434f0b2fa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/feada823fc5b16040da2f7aba36cda434f0b2fa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4007d4ef26eab44bdabc2b7574d032152264d3ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4007d4ef26eab44bdabc2b7574d032152264d3ad", "html_url": "https://github.com/rust-lang/rust/commit/4007d4ef26eab44bdabc2b7574d032152264d3ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4007d4ef26eab44bdabc2b7574d032152264d3ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "135ccbaca86ed4b9c0efaf0cd31442eae57ffad7", "url": "https://api.github.com/repos/rust-lang/rust/commits/135ccbaca86ed4b9c0efaf0cd31442eae57ffad7", "html_url": "https://github.com/rust-lang/rust/commit/135ccbaca86ed4b9c0efaf0cd31442eae57ffad7"}, {"sha": "bed4c09d21aceb440ee61091b68dd653da32b45b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bed4c09d21aceb440ee61091b68dd653da32b45b", "html_url": "https://github.com/rust-lang/rust/commit/bed4c09d21aceb440ee61091b68dd653da32b45b"}], "stats": {"total": 1288, "additions": 657, "deletions": 631}, "files": [{"sha": "956298d7836b854a2be3d10535c8d84630588ec2", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,15 +1,15 @@\n use super::*;\n \n extern crate test;\n-use test::Bencher;\n use crate::boxed::Box;\n+use test::Bencher;\n \n #[test]\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let ptr = Global.alloc_zeroed(layout.clone())\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr =\n+            Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         let mut i = ptr.cast::<u8>().as_ptr();\n         let end = i.add(layout.size());"}, {"sha": "eb5f51d9adc584b39efbc6760685828e6723ecb6", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,12 +1,12 @@\n+use std::collections::BTreeMap;\n use std::iter::Iterator;\n use std::vec::Vec;\n-use std::collections::BTreeMap;\n \n-use rand::{Rng, seq::SliceRandom, thread_rng};\n-use test::{Bencher, black_box};\n+use rand::{seq::SliceRandom, thread_rng, Rng};\n+use test::{black_box, Bencher};\n \n macro_rules! map_insert_rand_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let n: usize = $n;\n@@ -27,11 +27,11 @@ macro_rules! map_insert_rand_bench {\n             });\n             black_box(map);\n         }\n-    )\n+    };\n }\n \n macro_rules! map_insert_seq_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -50,11 +50,11 @@ macro_rules! map_insert_seq_bench {\n             });\n             black_box(map);\n         }\n-    )\n+    };\n }\n \n macro_rules! map_find_rand_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -78,11 +78,11 @@ macro_rules! map_find_rand_bench {\n                 black_box(t);\n             })\n         }\n-    )\n+    };\n }\n \n macro_rules! map_find_seq_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -101,20 +101,20 @@ macro_rules! map_find_seq_bench {\n                 black_box(x);\n             })\n         }\n-    )\n+    };\n }\n \n-map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n-map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n+map_insert_rand_bench! {insert_rand_100,    100,    BTreeMap}\n+map_insert_rand_bench! {insert_rand_10_000, 10_000, BTreeMap}\n \n-map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n-map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n+map_insert_seq_bench! {insert_seq_100,    100,    BTreeMap}\n+map_insert_seq_bench! {insert_seq_10_000, 10_000, BTreeMap}\n \n-map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n-map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n+map_find_rand_bench! {find_rand_100,    100,    BTreeMap}\n+map_find_rand_bench! {find_rand_10_000, 10_000, BTreeMap}\n \n-map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n-map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n+map_find_seq_bench! {find_seq_100,    100,    BTreeMap}\n+map_find_seq_bench! {find_seq_10_000, 10_000, BTreeMap}\n \n fn bench_iter(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();"}, {"sha": "e20c043286e6fedd50cc43a87c616c3bda9e58b0", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,9 +1,9 @@\n use std::{mem, ptr};\n \n+use rand::distributions::{Alphanumeric, Standard};\n use rand::{thread_rng, Rng, SeedableRng};\n-use rand::distributions::{Standard, Alphanumeric};\n use rand_xorshift::XorShiftRng;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn iterator(b: &mut Bencher) {\n@@ -239,7 +239,7 @@ macro_rules! sort {\n             b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_strings {\n@@ -251,7 +251,7 @@ macro_rules! sort_strings {\n             b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of::<&str>() as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_expensive {\n@@ -273,7 +273,7 @@ macro_rules! sort_expensive {\n             });\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_lexicographic {\n@@ -284,7 +284,7 @@ macro_rules! sort_lexicographic {\n             b.iter(|| v.clone().$f(|x| x.to_string()));\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n sort!(sort, sort_small_ascending, gen_ascending, 10);\n@@ -325,57 +325,58 @@ macro_rules! reverse {\n         fn $name(b: &mut Bencher) {\n             // odd length and offset by 1 to be as unaligned as possible\n             let n = 0xFFFFF;\n-            let mut v: Vec<_> =\n-                (0..1+(n / mem::size_of::<$ty>() as u64))\n-                .map($f)\n-                .collect();\n+            let mut v: Vec<_> = (0..1 + (n / mem::size_of::<$ty>() as u64)).map($f).collect();\n             b.iter(|| black_box(&mut v[1..]).reverse());\n             b.bytes = n;\n         }\n-    }\n+    };\n }\n \n reverse!(reverse_u8, u8, |x| x as u8);\n reverse!(reverse_u16, u16, |x| x as u16);\n-reverse!(reverse_u8x3, [u8;3], |x| [x as u8, (x>>8) as u8, (x>>16) as u8]);\n+reverse!(reverse_u8x3, [u8; 3], |x| [x as u8, (x >> 8) as u8, (x >> 16) as u8]);\n reverse!(reverse_u32, u32, |x| x as u32);\n reverse!(reverse_u64, u64, |x| x as u64);\n reverse!(reverse_u128, u128, |x| x as u128);\n-#[repr(simd)] struct F64x4(f64, f64, f64, f64);\n-reverse!(reverse_simd_f64x4, F64x4, |x| { let x = x as f64; F64x4(x,x,x,x) });\n+#[repr(simd)]\n+struct F64x4(f64, f64, f64, f64);\n+reverse!(reverse_simd_f64x4, F64x4, |x| {\n+    let x = x as f64;\n+    F64x4(x, x, x, x)\n+});\n \n macro_rules! rotate {\n     ($name:ident, $gen:expr, $len:expr, $mid:expr) => {\n         #[bench]\n         fn $name(b: &mut Bencher) {\n             let size = mem::size_of_val(&$gen(1)[0]);\n             let mut v = $gen($len * 8 / size);\n-            b.iter(|| black_box(&mut v).rotate_left(($mid*8+size-1)/size));\n+            b.iter(|| black_box(&mut v).rotate_left(($mid * 8 + size - 1) / size));\n             b.bytes = (v.len() * size) as u64;\n         }\n-    }\n+    };\n }\n \n rotate!(rotate_tiny_by1, gen_random, 16, 1);\n-rotate!(rotate_tiny_half, gen_random, 16, 16/2);\n-rotate!(rotate_tiny_half_plus_one, gen_random, 16, 16/2+1);\n+rotate!(rotate_tiny_half, gen_random, 16, 16 / 2);\n+rotate!(rotate_tiny_half_plus_one, gen_random, 16, 16 / 2 + 1);\n \n rotate!(rotate_medium_by1, gen_random, 9158, 1);\n rotate!(rotate_medium_by727_u64, gen_random, 9158, 727);\n rotate!(rotate_medium_by727_bytes, gen_random_bytes, 9158, 727);\n rotate!(rotate_medium_by727_strings, gen_strings, 9158, 727);\n-rotate!(rotate_medium_half, gen_random, 9158, 9158/2);\n-rotate!(rotate_medium_half_plus_one, gen_random, 9158, 9158/2+1);\n+rotate!(rotate_medium_half, gen_random, 9158, 9158 / 2);\n+rotate!(rotate_medium_half_plus_one, gen_random, 9158, 9158 / 2 + 1);\n \n // Intended to use more RAM than the machine has cache\n-rotate!(rotate_huge_by1, gen_random, 5*1024*1024, 1);\n-rotate!(rotate_huge_by9199_u64, gen_random, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_bytes, gen_random_bytes, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_strings, gen_strings, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_big, gen_big_random, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by1234577_u64, gen_random, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_bytes, gen_random_bytes, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_strings, gen_strings, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_big, gen_big_random, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_half, gen_random, 5*1024*1024, 5*1024*1024/2);\n-rotate!(rotate_huge_half_plus_one, gen_random, 5*1024*1024, 5*1024*1024/2+1);\n+rotate!(rotate_huge_by1, gen_random, 5 * 1024 * 1024, 1);\n+rotate!(rotate_huge_by9199_u64, gen_random, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_bytes, gen_random_bytes, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_strings, gen_strings, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_big, gen_big_random, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by1234577_u64, gen_random, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_bytes, gen_random_bytes, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_strings, gen_strings, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_big, gen_big_random, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_half, gen_random, 5 * 1024 * 1024, 5 * 1024 * 1024 / 2);\n+rotate!(rotate_huge_half_plus_one, gen_random, 5 * 1024 * 1024, 5 * 1024 * 1024 / 2 + 1);"}, {"sha": "391475bc0c75deda0ca0e47e15f8e7ad9cb2f8f3", "filename": "src/liballoc/benches/str.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstr.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,4 +1,4 @@\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn char_iterator(b: &mut Bencher) {\n@@ -12,7 +12,9 @@ fn char_iterator_for(b: &mut Bencher) {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n \n     b.iter(|| {\n-        for ch in s.chars() { black_box(ch); }\n+        for ch in s.chars() {\n+            black_box(ch);\n+        }\n     });\n }\n \n@@ -40,7 +42,9 @@ fn char_iterator_rev_for(b: &mut Bencher) {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n \n     b.iter(|| {\n-        for ch in s.chars().rev() { black_box(ch); }\n+        for ch in s.chars().rev() {\n+            black_box(ch);\n+        }\n     });\n }\n \n@@ -79,7 +83,9 @@ fn split_ascii(b: &mut Bencher) {\n fn split_extern_fn(b: &mut Bencher) {\n     let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n     let len = s.split(' ').count();\n-    fn pred(c: char) -> bool { c == ' ' }\n+    fn pred(c: char) -> bool {\n+        c == ' '\n+    }\n \n     b.iter(|| assert_eq!(s.split(pred).count(), len));\n }\n@@ -185,16 +191,19 @@ fn bench_contains_equal(b: &mut Bencher) {\n     })\n }\n \n-\n macro_rules! make_test_inner {\n     ($s:ident, $code:expr, $name:ident, $str:expr, $iters:expr) => {\n         #[bench]\n         fn $name(bencher: &mut Bencher) {\n             let mut $s = $str;\n             black_box(&mut $s);\n-            bencher.iter(|| for _ in 0..$iters { black_box($code); });\n+            bencher.iter(|| {\n+                for _ in 0..$iters {\n+                    black_box($code);\n+                }\n+            });\n         }\n-    }\n+    };\n }\n \n macro_rules! make_test {\n@@ -261,15 +270,9 @@ make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n \n make_test!(split_a_str, s, s.split(\"a\").count());\n \n-make_test!(trim_ascii_char, s, {\n-    s.trim_matches(|c: char| c.is_ascii())\n-});\n-make_test!(trim_start_ascii_char, s, {\n-    s.trim_start_matches(|c: char| c.is_ascii())\n-});\n-make_test!(trim_end_ascii_char, s, {\n-    s.trim_end_matches(|c: char| c.is_ascii())\n-});\n+make_test!(trim_ascii_char, s, { s.trim_matches(|c: char| c.is_ascii()) });\n+make_test!(trim_start_ascii_char, s, { s.trim_start_matches(|c: char| c.is_ascii()) });\n+make_test!(trim_end_ascii_char, s, { s.trim_end_matches(|c: char| c.is_ascii()) });\n \n make_test!(find_underscore_char, s, s.find('_'));\n make_test!(rfind_underscore_char, s, s.rfind('_'));"}, {"sha": "bf2dffd1e931eecfbc52c1b48c5811e196085958", "filename": "src/liballoc/benches/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,5 +1,5 @@\n use std::collections::VecDeque;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_new(b: &mut Bencher) {"}, {"sha": "5825bdc355f2d173d4ab3aff19bd9e509aa8eb9e", "filename": "src/liballoc/benches/vec_deque_append.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -30,8 +30,5 @@ fn main() {\n \n     assert!(BENCH_N % 2 == 0);\n     let median = (durations[(l / 2) - 1] + durations[l / 2]) / 2;\n-    println!(\n-        \"\\ncustom-bench vec_deque_append {:?} ns/iter\\n\",\n-        median.as_nanos()\n-    );\n+    println!(\"\\ncustom-bench vec_deque_append {:?} ns/iter\\n\", median.as_nanos());\n }"}, {"sha": "f73a24d09916bb1cbd448fb83868a541c4db84af", "filename": "src/liballoc/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,6 +1,6 @@\n+pub mod map;\n mod node;\n mod search;\n-pub mod map;\n pub mod set;\n \n #[doc(hidden)]"}, {"sha": "3f3c49a2ef875246600f87cf976b1b4ea538d370", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,21 +1,23 @@\n use core::borrow::Borrow;\n use core::cmp::Ordering;\n \n-use super::node::{Handle, NodeRef, marker, ForceResult::*};\n+use super::node::{marker, ForceResult::*, Handle, NodeRef};\n \n use SearchResult::*;\n \n pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     Found(Handle<NodeRef<BorrowType, K, V, FoundType>, marker::KV>),\n-    GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>)\n+    GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n }\n \n pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n     mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    key: &Q\n+    key: &Q,\n ) -> SearchResult<BorrowType, K, V, marker::LeafOrInternal, marker::Leaf>\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     loop {\n         match search_node(node, key) {\n             Found(handle) => return Found(handle),\n@@ -25,38 +27,38 @@ pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n                     node = internal.descend();\n                     continue;\n                 }\n-            }\n+            },\n         }\n     }\n }\n \n pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     node: NodeRef<BorrowType, K, V, Type>,\n-    key: &Q\n+    key: &Q,\n ) -> SearchResult<BorrowType, K, V, Type, Type>\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     match search_linear(&node, key) {\n-        (idx, true) => Found(\n-            Handle::new_kv(node, idx)\n-        ),\n-        (idx, false) => SearchResult::GoDown(\n-            Handle::new_edge(node, idx)\n-        )\n+        (idx, true) => Found(Handle::new_kv(node, idx)),\n+        (idx, false) => SearchResult::GoDown(Handle::new_edge(node, idx)),\n     }\n }\n \n pub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n-    key: &Q\n+    key: &Q,\n ) -> (usize, bool)\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     for (i, k) in node.keys().iter().enumerate() {\n         match key.cmp(k.borrow()) {\n-            Ordering::Greater => {},\n+            Ordering::Greater => {}\n             Ordering::Equal => return (i, true),\n-            Ordering::Less => return (i, false)\n+            Ordering::Less => return (i, false),\n         }\n     }\n     (node.keys().len(), false)"}, {"sha": "94b92df12940098e5d68b888970e57fa553bfe1b", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -177,8 +177,7 @@ fn test_insert_prev() {\n     }\n     check_links(&m);\n     assert_eq!(m.len(), 3 + len * 2);\n-    assert_eq!(m.into_iter().collect::<Vec<_>>(),\n-                [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n }\n \n #[test]\n@@ -187,13 +186,13 @@ fn test_insert_prev() {\n fn test_send() {\n     let n = list_from(&[1, 2, 3]);\n     thread::spawn(move || {\n-            check_links(&n);\n-            let a: &[_] = &[&1, &2, &3];\n-            assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n-        })\n-        .join()\n-        .ok()\n-        .unwrap();\n+        check_links(&n);\n+        let a: &[_] = &[&1, &2, &3];\n+        assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n+    })\n+    .join()\n+    .ok()\n+    .unwrap();\n }\n \n #[test]"}, {"sha": "8dc097cc088051a4fdb5d8472fa52c00840314ce", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -66,11 +66,8 @@ fn test_swap_front_back_remove() {\n         let final_len = usable_cap / 2;\n \n         for len in 0..final_len {\n-            let expected: VecDeque<_> = if back {\n-                (0..len).collect()\n-            } else {\n-                (0..len).rev().collect()\n-            };\n+            let expected: VecDeque<_> =\n+                if back { (0..len).collect() } else { (0..len).rev().collect() };\n             for tail_pos in 0..usable_cap {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n@@ -111,7 +108,6 @@ fn test_insert() {\n     // this test isn't covering what it wants to\n     let cap = tester.capacity();\n \n-\n     // len is the length *after* insertion\n     for len in 1..cap {\n         // 0, 1, 2, .., len - 1\n@@ -198,9 +194,7 @@ fn test_drain() {\n                     assert!(tester.head < tester.cap());\n \n                     // We should see the correct values in the VecDeque\n-                    let expected: VecDeque<_> = (0..drain_start)\n-                        .chain(drain_end..len)\n-                        .collect();\n+                    let expected: VecDeque<_> = (0..drain_start).chain(drain_end..len).collect();\n                     assert_eq!(expected, tester);\n                 }\n             }"}, {"sha": "18ebae333098f9f42ea80c1ceb982825b5eae924", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -516,24 +516,24 @@\n \n #[unstable(feature = \"fmt_internals\", issue = \"0\")]\n pub use core::fmt::rt;\n+#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n+pub use core::fmt::Alignment;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{Formatter, Result, Write};\n+pub use core::fmt::Error;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::fmt::{write, ArgumentV1, Arguments};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{Binary, Octal};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{Debug, Display};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{LowerHex, Pointer, UpperHex};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{LowerExp, UpperExp};\n+pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::Error;\n+pub use core::fmt::{Formatter, Result, Write};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{write, ArgumentV1, Arguments};\n+pub use core::fmt::{LowerExp, UpperExp};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n-#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n-pub use core::fmt::{Alignment};\n+pub use core::fmt::{LowerHex, Pointer, UpperHex};\n \n use crate::string;\n \n@@ -568,8 +568,6 @@ use crate::string;\n pub fn format(args: Arguments<'_>) -> string::String {\n     let capacity = args.estimated_capacity();\n     let mut output = string::String::with_capacity(capacity);\n-    output\n-        .write_fmt(args)\n-        .expect(\"a formatting trait implementation returned an error\");\n+    output.write_fmt(args).expect(\"a formatting trait implementation returned an error\");\n     output\n }"}, {"sha": "6a53b4ca1f6ca961f1c53703c3a56c5e4ca21f72", "filename": "src/liballoc/prelude/v1.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fv1.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -4,7 +4,11 @@\n \n #![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n \n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::borrow::ToOwned;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::boxed::Box;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::string::{String, ToString};\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::vec::Vec;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::borrow::ToOwned;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::boxed::Box;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::string::{String, ToString};\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::vec::Vec;"}, {"sha": "b214cef30111516146e2ea14488dba664118f180", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -16,15 +16,20 @@ fn allocator_param() {\n \n     // A dumb allocator that consumes a fixed amount of fuel\n     // before allocation attempts start failing.\n-    struct BoundedAlloc { fuel: usize }\n+    struct BoundedAlloc {\n+        fuel: usize,\n+    }\n     unsafe impl Alloc for BoundedAlloc {\n         unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);\n             }\n             match Global.alloc(layout) {\n-                ok @ Ok(_) => { self.fuel -= size; ok }\n+                ok @ Ok(_) => {\n+                    self.fuel -= size;\n+                    ok\n+                }\n                 err @ Err(_) => err,\n             }\n         }"}, {"sha": "2f6d10c027be38bcd742a8a525d158ebada6b62b", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 92, "deletions": 81, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -82,7 +82,6 @@\n //! [`.chunks`]: ../../std/primitive.slice.html#method.chunks\n //! [`.windows`]: ../../std/primitive.slice.html#method.windows\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n // Many of the usings in this module are only used in the test configuration.\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n@@ -91,32 +90,32 @@ use core::borrow::{Borrow, BorrowMut};\n use core::cmp::Ordering::{self, Less};\n use core::mem::{self, size_of};\n use core::ptr;\n-use core::{u8, u16, u32};\n+use core::{u16, u32, u8};\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+pub use core::slice::SliceIndex;\n+#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n+pub use core::slice::{from_mut, from_ref};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{Chunks, Windows};\n+pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{Iter, IterMut};\n+pub use core::slice::{Chunks, Windows};\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+pub use core::slice::{ChunksExact, ChunksExactMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{SplitMut, ChunksMut, Split};\n+pub use core::slice::{ChunksMut, Split, SplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n+pub use core::slice::{Iter, IterMut};\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+pub use core::slice::{RChunks, RChunksExact, RChunksExactMut, RChunksMut};\n #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n pub use core::slice::{RSplit, RSplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n-#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n-pub use core::slice::{from_ref, from_mut};\n-#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-pub use core::slice::SliceIndex;\n-#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n-pub use core::slice::{ChunksExact, ChunksExactMut};\n-#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n-pub use core::slice::{RChunks, RChunksMut, RChunksExact, RChunksExactMut};\n+pub use core::slice::{RSplitN, RSplitNMut, SplitN, SplitNMut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -138,9 +137,9 @@ pub use hack::to_vec;\n // `test_permutations` test\n mod hack {\n     use crate::boxed::Box;\n-    use crate::vec::Vec;\n     #[cfg(test)]\n     use crate::string::ToString;\n+    use crate::vec::Vec;\n \n     pub fn into_vec<T>(b: Box<[T]>) -> Vec<T> {\n         unsafe {\n@@ -153,7 +152,8 @@ mod hack {\n \n     #[inline]\n     pub fn to_vec<T>(s: &[T]) -> Vec<T>\n-        where T: Clone\n+    where\n+        T: Clone,\n     {\n         let mut vector = Vec::with_capacity(s.len());\n         vector.extend_from_slice(s);\n@@ -193,7 +193,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort(&mut self)\n-        where T: Ord\n+    where\n+        T: Ord,\n     {\n         merge_sort(self, |a, b| a.lt(b));\n     }\n@@ -246,7 +247,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort_by<F>(&mut self, mut compare: F)\n-        where F: FnMut(&T, &T) -> Ordering\n+    where\n+        F: FnMut(&T, &T) -> Ordering,\n     {\n         merge_sort(self, |a, b| compare(a, b) == Less);\n     }\n@@ -285,7 +287,9 @@ impl<T> [T] {\n     #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n     pub fn sort_by_key<K, F>(&mut self, mut f: F)\n-        where F: FnMut(&T) -> K, K: Ord\n+    where\n+        F: FnMut(&T) -> K,\n+        K: Ord,\n     {\n         merge_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n@@ -325,11 +329,13 @@ impl<T> [T] {\n     #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n     #[inline]\n     pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n-        where F: FnMut(&T) -> K, K: Ord\n+    where\n+        F: FnMut(&T) -> K,\n+        K: Ord,\n     {\n         // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n         macro_rules! sort_by_key {\n-            ($t:ty, $slice:ident, $f:ident) => ({\n+            ($t:ty, $slice:ident, $f:ident) => {{\n                 let mut indices: Vec<_> =\n                     $slice.iter().map($f).enumerate().map(|(i, k)| (k, i as $t)).collect();\n                 // The elements of `indices` are unique, as they are indexed, so any sort will be\n@@ -344,19 +350,27 @@ impl<T> [T] {\n                     indices[i].1 = index;\n                     $slice.swap(i, index as usize);\n                 }\n-            })\n+            }};\n         }\n \n-        let sz_u8    = mem::size_of::<(K, u8)>();\n-        let sz_u16   = mem::size_of::<(K, u16)>();\n-        let sz_u32   = mem::size_of::<(K, u32)>();\n+        let sz_u8 = mem::size_of::<(K, u8)>();\n+        let sz_u16 = mem::size_of::<(K, u16)>();\n+        let sz_u32 = mem::size_of::<(K, u32)>();\n         let sz_usize = mem::size_of::<(K, usize)>();\n \n         let len = self.len();\n-        if len < 2 { return }\n-        if sz_u8  < sz_u16   && len <= ( u8::MAX as usize) { return sort_by_key!( u8, self, f) }\n-        if sz_u16 < sz_u32   && len <= (u16::MAX as usize) { return sort_by_key!(u16, self, f) }\n-        if sz_u32 < sz_usize && len <= (u32::MAX as usize) { return sort_by_key!(u32, self, f) }\n+        if len < 2 {\n+            return;\n+        }\n+        if sz_u8 < sz_u16 && len <= (u8::MAX as usize) {\n+            return sort_by_key!(u8, self, f);\n+        }\n+        if sz_u16 < sz_u32 && len <= (u16::MAX as usize) {\n+            return sort_by_key!(u16, self, f);\n+        }\n+        if sz_u32 < sz_usize && len <= (u32::MAX as usize) {\n+            return sort_by_key!(u32, self, f);\n+        }\n         sort_by_key!(usize, self, f)\n     }\n \n@@ -373,7 +387,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_vec(&self) -> Vec<T>\n-        where T: Clone\n+    where\n+        T: Clone,\n     {\n         // N.B., see the `hack` module in this file for more details.\n         hack::to_vec(self)\n@@ -421,7 +436,10 @@ impl<T> [T] {\n     /// b\"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n     #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n-    pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {\n+    pub fn repeat(&self, n: usize) -> Vec<T>\n+    where\n+        T: Copy,\n+    {\n         if n == 0 {\n             return Vec::new();\n         }\n@@ -486,7 +504,8 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n-        where Self: Concat<Item>\n+    where\n+        Self: Concat<Item>,\n     {\n         Concat::concat(self)\n     }\n@@ -503,7 +522,8 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n     pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n-        where Self: Join<Separator>\n+    where\n+        Self: Join<Separator>,\n     {\n         Join::join(self, sep)\n     }\n@@ -521,11 +541,11 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n     pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n-        where Self: Join<Separator>\n+    where\n+        Self: Join<Separator>,\n     {\n         Join::join(self, sep)\n     }\n-\n }\n \n #[lang = \"slice_u8_alloc\"]\n@@ -668,8 +688,8 @@ impl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() +\n-            sep.len() * (slice.len() - 1);\n+        let size =\n+            slice.iter().map(|v| v.borrow().len()).sum::<usize>() + sep.len() * (slice.len() - 1);\n         let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n \n@@ -734,7 +754,8 @@ impl<T: Clone> ToOwned for [T] {\n ///\n /// This is the integral subroutine of insertion sort.\n fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     if v.len() >= 2 && is_less(&v[1], &v[0]) {\n         unsafe {\n@@ -767,10 +788,7 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n             // If `is_less` panics at any point during the process, `hole` will get dropped and\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n-            let mut hole = InsertionHole {\n-                src: &mut *tmp,\n-                dest: &mut v[1],\n-            };\n+            let mut hole = InsertionHole { src: &mut *tmp, dest: &mut v[1] };\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n@@ -792,7 +810,9 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n \n     impl<T> Drop for InsertionHole<T> {\n         fn drop(&mut self) {\n-            unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n+            }\n         }\n     }\n }\n@@ -805,7 +825,8 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n /// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n /// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n@@ -834,11 +855,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n     if mid <= len - mid {\n         // The left run is shorter.\n         ptr::copy_nonoverlapping(v, buf, mid);\n-        hole = MergeHole {\n-            start: buf,\n-            end: buf.add(mid),\n-            dest: v,\n-        };\n+        hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n \n         // Initially, these pointers point to the beginnings of their arrays.\n         let left = &mut hole.start;\n@@ -858,11 +875,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n     } else {\n         // The right run is shorter.\n         ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n-        hole = MergeHole {\n-            start: buf,\n-            end: buf.add(len - mid),\n-            dest: v_mid,\n-        };\n+        hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n \n         // Initially, these pointers point past the ends of their arrays.\n         let left = &mut hole.dest;\n@@ -905,7 +918,9 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n         fn drop(&mut self) {\n             // `T` is not a zero-sized type, so it's okay to divide by its size.\n             let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n-            unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.start, self.dest, len);\n+            }\n         }\n     }\n }\n@@ -923,7 +938,8 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n ///\n /// The invariants ensure that the total running time is `O(n log n)` worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Slices of up to this length get sorted using insertion sort.\n     const MAX_INSERTION: usize = 20;\n@@ -940,7 +956,7 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     // Short arrays get sorted in-place via insertion sort to avoid allocations.\n     if len <= MAX_INSERTION {\n         if len >= 2 {\n-            for i in (0..len-1).rev() {\n+            for i in (0..len - 1).rev() {\n                 insert_head(&mut v[i..], &mut is_less);\n             }\n         }\n@@ -966,14 +982,13 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n             start -= 1;\n             unsafe {\n                 if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n-                    while start > 0 && is_less(v.get_unchecked(start),\n-                                               v.get_unchecked(start - 1)) {\n+                    while start > 0 && is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {\n                         start -= 1;\n                     }\n                     v[start..end].reverse();\n                 } else {\n-                    while start > 0 && !is_less(v.get_unchecked(start),\n-                                                v.get_unchecked(start - 1)) {\n+                    while start > 0 && !is_less(v.get_unchecked(start), v.get_unchecked(start - 1))\n+                    {\n                         start -= 1;\n                     }\n                 }\n@@ -988,24 +1003,22 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n         }\n \n         // Push this run onto the stack.\n-        runs.push(Run {\n-            start,\n-            len: end - start,\n-        });\n+        runs.push(Run { start, len: end - start });\n         end = start;\n \n         // Merge some pairs of adjacent runs to satisfy the invariants.\n         while let Some(r) = collapse(&runs) {\n             let left = runs[r + 1];\n             let right = runs[r];\n             unsafe {\n-                merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n-                      &mut is_less);\n+                merge(\n+                    &mut v[left.start..right.start + right.len],\n+                    left.len,\n+                    buf.as_mut_ptr(),\n+                    &mut is_less,\n+                );\n             }\n-            runs[r] = Run {\n-                start: left.start,\n-                len: left.len + right.len,\n-            };\n+            runs[r] = Run { start: left.start, len: left.len + right.len };\n             runs.remove(r + 1);\n         }\n     }\n@@ -1030,15 +1043,13 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     #[inline]\n     fn collapse(runs: &[Run]) -> Option<usize> {\n         let n = runs.len();\n-        if n >= 2 && (runs[n - 1].start == 0 ||\n-                      runs[n - 2].len <= runs[n - 1].len ||\n-                      (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len) ||\n-                      (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len)) {\n-            if n >= 3 && runs[n - 3].len < runs[n - 1].len {\n-                Some(n - 3)\n-            } else {\n-                Some(n - 2)\n-            }\n+        if n >= 2\n+            && (runs[n - 1].start == 0\n+                || runs[n - 2].len <= runs[n - 1].len\n+                || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)\n+                || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))\n+        {\n+            if n >= 3 && runs[n - 3].len < runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }\n         } else {\n             None\n         }"}, {"sha": "1b6e0bb291c35c17aba17233df5f574a68b8f091", "filename": "src/liballoc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,12 +1,12 @@\n //! Test for `boxed` mod.\n \n use core::any::Any;\n-use core::convert::TryInto;\n-use core::ops::Deref;\n-use core::result::Result::{Err, Ok};\n use core::clone::Clone;\n+use core::convert::TryInto;\n use core::f64;\n use core::i64;\n+use core::ops::Deref;\n+use core::result::Result::{Err, Ok};\n \n use std::boxed::Box;\n "}, {"sha": "2fbb59b0419e020422fd77aa20ec45b3d52d48ac", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,9 +1,9 @@\n use std::any::Any;\n-use std::sync::{Arc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n use std::iter::TrustedLen;\n use std::mem;\n+use std::sync::{Arc, Weak};\n \n #[test]\n fn uninhabited() {\n@@ -12,16 +12,16 @@ fn uninhabited() {\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n \n-    let mut a: Weak<dyn Any> = a;  // Unsizing\n+    let mut a: Weak<dyn Any> = a; // Unsizing\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n }\n \n #[test]\n fn slice() {\n     let a: Arc<[u32; 3]> = Arc::new([3, 2, 1]);\n-    let a: Arc<[u32]> = a;  // Unsizing\n-    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]);  // Conversion\n+    let a: Arc<[u32]> = a; // Unsizing\n+    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]); // Conversion\n     assert_eq!(a, b);\n \n     // Exercise is_dangling() with a DST\n@@ -33,7 +33,7 @@ fn slice() {\n #[test]\n fn trait_object() {\n     let a: Arc<u32> = Arc::new(4);\n-    let a: Arc<dyn Any> = a;  // Unsizing\n+    let a: Arc<dyn Any> = a; // Unsizing\n \n     // Exercise is_dangling() with a DST\n     let mut a = Arc::downgrade(&a);\n@@ -43,7 +43,7 @@ fn trait_object() {\n     let mut b = Weak::<u32>::new();\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n-    let mut b: Weak<dyn Any> = b;  // Unsizing\n+    let mut b: Weak<dyn Any> = b; // Unsizing\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n }\n@@ -57,7 +57,7 @@ fn float_nan_ne() {\n \n #[test]\n fn partial_eq() {\n-    struct TestPEq (RefCell<usize>);\n+    struct TestPEq(RefCell<usize>);\n     impl PartialEq for TestPEq {\n         fn eq(&self, other: &TestPEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -74,7 +74,7 @@ fn partial_eq() {\n #[test]\n fn eq() {\n     #[derive(Eq)]\n-    struct TestEq (RefCell<usize>);\n+    struct TestEq(RefCell<usize>);\n     impl PartialEq for TestEq {\n         fn eq(&self, other: &TestEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -160,13 +160,10 @@ fn shared_from_iter_trustedlen_normal() {\n fn shared_from_iter_trustedlen_panic() {\n     // Exercise the `TrustedLen` implementation when `size_hint()` matches\n     // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n-    let iter = (0..SHARED_ITER_MAX)\n-        .map(|val| {\n-            match val {\n-                98 => panic!(\"I've almost got 99 problems.\"),\n-                _ => Box::new(val),\n-            }\n-        });\n+    let iter = (0..SHARED_ITER_MAX).map(|val| match val {\n+        98 => panic!(\"I've almost got 99 problems.\"),\n+        _ => Box::new(val),\n+    });\n     assert_trusted_len(&iter);\n     let _ = iter.collect::<Rc<[_]>>();\n \n@@ -193,16 +190,8 @@ fn shared_from_iter_trustedlen_no_fuse() {\n         }\n     }\n \n-    let vec = vec![\n-        Some(Box::new(42)),\n-        Some(Box::new(24)),\n-        None,\n-        Some(Box::new(12)),\n-    ];\n+    let vec = vec![Some(Box::new(42)), Some(Box::new(24)), None, Some(Box::new(12))];\n     let iter = Iter(vec.into_iter());\n     assert_trusted_len(&iter);\n-    assert_eq!(\n-        &[Box::new(42), Box::new(24)],\n-        &*iter.collect::<Rc<[_]>>()\n-    );\n+    assert_eq!(&[Box::new(42), Box::new(24)], &*iter.collect::<Rc<[_]>>());\n }"}, {"sha": "a896a1064d9e17070bdef52f43e9cd0cc48dce1b", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -347,7 +347,7 @@ fn assert_covariance() {\n // Destructors must be called exactly once per element.\n // FIXME: re-enable emscripten once it can unwind again\n #[test]\n-#[cfg(not(any(miri, target_os = \"emscripten\")))] // Miri does not support catching panics\n+#[cfg(not(target_os = \"emscripten\"))]\n fn panic_safe() {\n     use std::cmp;\n     use std::panic::{self, AssertUnwindSafe};\n@@ -376,7 +376,10 @@ fn panic_safe() {\n     }\n     let mut rng = thread_rng();\n     const DATASZ: usize = 32;\n+    #[cfg(not(miri))] // Miri is too slow\n     const NTEST: usize = 10;\n+    #[cfg(miri)]\n+    const NTEST: usize = 1;\n \n     // don't use 0 in the data -- we want to catch the zeroed-out case.\n     let data = (1..=DATASZ).collect::<Vec<_>>();"}, {"sha": "66782ecbeb7f6deaa686e98206be3758f03fdd28", "filename": "src/liballoc/tests/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fboxed.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,5 +1,5 @@\n-use std::ptr::NonNull;\n use std::mem::MaybeUninit;\n+use std::ptr::NonNull;\n \n #[test]\n fn unitialized_zero_size_box() {"}, {"sha": "1d08ae13e054011cd3e9f9285539fb15dfc34675", "filename": "src/liballoc/tests/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -11,12 +11,7 @@ struct DeterministicRng {\n \n impl DeterministicRng {\n     fn new() -> Self {\n-        DeterministicRng {\n-            x: 0x193a6754,\n-            y: 0xa8a7d469,\n-            z: 0x97830e05,\n-            w: 0x113ba7bb,\n-        }\n+        DeterministicRng { x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n     }\n \n     fn next(&mut self) -> u32 {"}, {"sha": "daa49c48c6a92461532c3dfe97ca08b8f0536976", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 30, "deletions": 45, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -102,7 +102,6 @@ fn test_split_off() {\n         assert_eq!(m.back(), Some(&1));\n         assert_eq!(m.front(), Some(&1));\n     }\n-\n }\n \n #[test]\n@@ -305,8 +304,7 @@ fn test_show() {\n     assert_eq!(format!(\"{:?}\", list), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n     let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n-    assert_eq!(format!(\"{:?}\", list),\n-               \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+    assert_eq!(format!(\"{:?}\", list), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]\n@@ -446,19 +444,14 @@ fn drain_filter_true() {\n \n #[test]\n fn drain_filter_complex() {\n-\n-    {   //                [+xxx++++++xxxxx++++x+x++]\n+    {\n+        //                [+xxx++++++xxxxx++++x+x++]\n         let mut list = vec![\n-            1,\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36,\n-            37, 39\n-        ].into_iter().collect::<LinkedList<_>>();\n+            1, 2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37,\n+            39,\n+        ]\n+        .into_iter()\n+        .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -471,17 +464,13 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxx++++++xxxxx++++x+x++]\n+    {\n+        // [xxx++++++xxxxx++++x+x++]\n         let mut list = vec![\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36,\n-            37, 39\n-        ].into_iter().collect::<LinkedList<_>>();\n+            2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37, 39,\n+        ]\n+        .into_iter()\n+        .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -494,16 +483,12 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxx++++++xxxxx++++x+x]\n-        let mut list = vec![\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [xxx++++++xxxxx++++x+x]\n+        let mut list =\n+            vec![2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36]\n+                .into_iter()\n+                .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -516,11 +501,11 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxxxxxxxxx+++++++++++]\n-        let mut list = vec![\n-            2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n-            1, 3, 5, 7, 9, 11, 13, 15, 17, 19\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [xxxxxxxxxx+++++++++++]\n+        let mut list = vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -530,11 +515,11 @@ fn drain_filter_complex() {\n         assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n \n-    {   // [+++++++++++xxxxxxxxxx]\n-        let mut list = vec![\n-            1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n-            2, 4, 6, 8, 10, 12, 14, 16, 18, 20\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [+++++++++++xxxxxxxxxx]\n+        let mut list = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);"}, {"sha": "e77c57d9a5a09ef38b6721587799b0191b51d71f", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,9 +1,9 @@\n use std::any::Any;\n-use std::rc::{Rc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n-use std::mem;\n use std::iter::TrustedLen;\n+use std::mem;\n+use std::rc::{Rc, Weak};\n \n #[test]\n fn uninhabited() {\n@@ -12,16 +12,16 @@ fn uninhabited() {\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n \n-    let mut a: Weak<dyn Any> = a;  // Unsizing\n+    let mut a: Weak<dyn Any> = a; // Unsizing\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n }\n \n #[test]\n fn slice() {\n     let a: Rc<[u32; 3]> = Rc::new([3, 2, 1]);\n-    let a: Rc<[u32]> = a;  // Unsizing\n-    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]);  // Conversion\n+    let a: Rc<[u32]> = a; // Unsizing\n+    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]); // Conversion\n     assert_eq!(a, b);\n \n     // Exercise is_dangling() with a DST\n@@ -33,7 +33,7 @@ fn slice() {\n #[test]\n fn trait_object() {\n     let a: Rc<u32> = Rc::new(4);\n-    let a: Rc<dyn Any> = a;  // Unsizing\n+    let a: Rc<dyn Any> = a; // Unsizing\n \n     // Exercise is_dangling() with a DST\n     let mut a = Rc::downgrade(&a);\n@@ -43,7 +43,7 @@ fn trait_object() {\n     let mut b = Weak::<u32>::new();\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n-    let mut b: Weak<dyn Any> = b;  // Unsizing\n+    let mut b: Weak<dyn Any> = b; // Unsizing\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n }\n@@ -57,7 +57,7 @@ fn float_nan_ne() {\n \n #[test]\n fn partial_eq() {\n-    struct TestPEq (RefCell<usize>);\n+    struct TestPEq(RefCell<usize>);\n     impl PartialEq for TestPEq {\n         fn eq(&self, other: &TestPEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -74,7 +74,7 @@ fn partial_eq() {\n #[test]\n fn eq() {\n     #[derive(Eq)]\n-    struct TestEq (RefCell<usize>);\n+    struct TestEq(RefCell<usize>);\n     impl PartialEq for TestEq {\n         fn eq(&self, other: &TestEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -156,13 +156,10 @@ fn shared_from_iter_trustedlen_normal() {\n fn shared_from_iter_trustedlen_panic() {\n     // Exercise the `TrustedLen` implementation when `size_hint()` matches\n     // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n-    let iter = (0..SHARED_ITER_MAX)\n-        .map(|val| {\n-            match val {\n-                98 => panic!(\"I've almost got 99 problems.\"),\n-                _ => Box::new(val),\n-            }\n-        });\n+    let iter = (0..SHARED_ITER_MAX).map(|val| match val {\n+        98 => panic!(\"I've almost got 99 problems.\"),\n+        _ => Box::new(val),\n+    });\n     assert_trusted_len(&iter);\n     let _ = iter.collect::<Rc<[_]>>();\n \n@@ -189,16 +186,8 @@ fn shared_from_iter_trustedlen_no_fuse() {\n         }\n     }\n \n-    let vec = vec![\n-        Some(Box::new(42)),\n-        Some(Box::new(24)),\n-        None,\n-        Some(Box::new(12)),\n-    ];\n+    let vec = vec![Some(Box::new(42)), Some(Box::new(24)), None, Some(Box::new(12))];\n     let iter = Iter(vec.into_iter());\n     assert_trusted_len(&iter);\n-    assert_eq!(\n-        &[Box::new(42), Box::new(24)],\n-        &*iter.collect::<Rc<[_]>>()\n-    );\n+    assert_eq!(&[Box::new(42), Box::new(24)], &*iter.collect::<Rc<[_]>>());\n }"}, {"sha": "d9707b95740785bc4600d0973da1c2f6b5f093a9", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -4,7 +4,6 @@ use std::mem;\n use std::panic;\n use std::rc::Rc;\n use std::sync::atomic::{Ordering::Relaxed, AtomicUsize};\n-use std::thread;\n \n use rand::{Rng, RngCore, thread_rng};\n use rand::seq::SliceRandom;\n@@ -1406,11 +1405,9 @@ fn test_box_slice_clone() {\n #[test]\n #[allow(unused_must_use)] // here, we care about the side effects of `.clone()`\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg(not(miri))] // Miri does not support threads\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n-    use std::thread::spawn;\n \n     struct Canary {\n         count: Arc<AtomicUsize>,\n@@ -1446,15 +1443,14 @@ fn test_box_slice_clone_panics() {\n         panics: true,\n     };\n \n-    spawn(move || {\n+    std::panic::catch_unwind(move || {\n             // When xs is dropped, +5.\n             let xs = vec![canary.clone(), canary.clone(), canary.clone(), panic, canary]\n                 .into_boxed_slice();\n \n             // When panic is cloned, +3.\n             xs.clone();\n         })\n-        .join()\n         .unwrap_err();\n \n     // Total = 8\n@@ -1566,7 +1562,7 @@ macro_rules! test {\n             }\n \n             let v = $input.to_owned();\n-            let _ = thread::spawn(move || {\n+            let _ = std::panic::catch_unwind(move || {\n                 let mut v = v;\n                 let mut panic_countdown = panic_countdown;\n                 v.$func(|a, b| {\n@@ -1577,7 +1573,7 @@ macro_rules! test {\n                     panic_countdown -= 1;\n                     a.cmp(b)\n                 })\n-            }).join();\n+            });\n \n             // Check that the number of things dropped is exactly\n             // what we expect (i.e., the contents of `v`).\n@@ -1598,7 +1594,6 @@ thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n-#[cfg(not(miri))] // Miri does not support threads\n fn panic_safe() {\n     let prev = panic::take_hook();\n     panic::set_hook(Box::new(move |info| {\n@@ -1609,8 +1604,18 @@ fn panic_safe() {\n \n     let mut rng = thread_rng();\n \n-    for len in (1..20).chain(70..MAX_LEN) {\n-        for &modulus in &[5, 20, 50] {\n+    #[cfg(not(miri))] // Miri is too slow\n+    let lens = (1..20).chain(70..MAX_LEN);\n+    #[cfg(not(miri))] // Miri is too slow\n+    let moduli = &[5, 20, 50];\n+\n+    #[cfg(miri)]\n+    let lens = (1..13);\n+    #[cfg(miri)]\n+    let moduli = &[10];\n+\n+    for len in lens {\n+        for &modulus in moduli {\n             for &has_runs in &[false, true] {\n                 let mut input = (0..len)\n                     .map(|id| {\n@@ -1643,6 +1648,9 @@ fn panic_safe() {\n             }\n         }\n     }\n+\n+    // Set default panic hook again.\n+    drop(panic::take_hook());\n }\n \n #[test]"}, {"sha": "9ee254f99acdfa34611443c5fee088580fa79f66", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -944,10 +944,9 @@ fn drain_filter_complex() {\n     }\n }\n \n-// Miri does not support catching panics\n // FIXME: re-enable emscripten once it can unwind again\n #[test]\n-#[cfg(not(any(miri, target_os = \"emscripten\")))]\n+#[cfg(not(target_os = \"emscripten\"))]\n fn drain_filter_consumed_panic() {\n     use std::rc::Rc;\n     use std::sync::Mutex;\n@@ -999,7 +998,7 @@ fn drain_filter_consumed_panic() {\n \n // FIXME: Re-enable emscripten once it can catch panics\n #[test]\n-#[cfg(not(any(miri, target_os = \"emscripten\")))] // Miri does not support catching panics\n+#[cfg(not(target_os = \"emscripten\"))]\n fn drain_filter_unconsumed_panic() {\n     use std::rc::Rc;\n     use std::sync::Mutex;"}, {"sha": "5a0162a536175295cb89b0e9897afc6efe88395e", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -1,8 +1,8 @@\n-use std::fmt::Debug;\n-use std::collections::{VecDeque, vec_deque::Drain};\n use std::collections::TryReserveError::*;\n+use std::collections::{vec_deque::Drain, VecDeque};\n+use std::fmt::Debug;\n use std::mem::size_of;\n-use std::{usize, isize};\n+use std::{isize, usize};\n \n use crate::hash;\n \n@@ -148,34 +148,20 @@ fn test_param_taggy() {\n \n #[test]\n fn test_param_taggypar() {\n-    test_parameterized::<Taggypar<i32>>(Onepar::<i32>(1),\n-                                        Twopar::<i32>(1, 2),\n-                                        Threepar::<i32>(1, 2, 3),\n-                                        Twopar::<i32>(17, 42));\n+    test_parameterized::<Taggypar<i32>>(\n+        Onepar::<i32>(1),\n+        Twopar::<i32>(1, 2),\n+        Threepar::<i32>(1, 2, 3),\n+        Twopar::<i32>(17, 42),\n+    );\n }\n \n #[test]\n fn test_param_reccy() {\n-    let reccy1 = RecCy {\n-        x: 1,\n-        y: 2,\n-        t: One(1),\n-    };\n-    let reccy2 = RecCy {\n-        x: 345,\n-        y: 2,\n-        t: Two(1, 2),\n-    };\n-    let reccy3 = RecCy {\n-        x: 1,\n-        y: 777,\n-        t: Three(1, 2, 3),\n-    };\n-    let reccy4 = RecCy {\n-        x: 19,\n-        y: 252,\n-        t: Two(17, 42),\n-    };\n+    let reccy1 = RecCy { x: 1, y: 2, t: One(1) };\n+    let reccy2 = RecCy { x: 345, y: 2, t: Two(1, 2) };\n+    let reccy3 = RecCy { x: 1, y: 777, t: Three(1, 2, 3) };\n+    let reccy4 = RecCy { x: 19, y: 252, t: Two(17, 42) };\n     test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n }\n \n@@ -320,8 +306,7 @@ fn test_mut_rev_iter_wrap() {\n     assert_eq!(d.pop_front(), Some(1));\n     d.push_back(4);\n \n-    assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<_>>(),\n-               vec![4, 3, 2]);\n+    assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<_>>(), vec![4, 3, 2]);\n }\n \n #[test]\n@@ -372,7 +357,6 @@ fn test_mut_rev_iter() {\n \n #[test]\n fn test_into_iter() {\n-\n     // Empty iter\n     {\n         let d: VecDeque<i32> = VecDeque::new();\n@@ -431,7 +415,6 @@ fn test_into_iter() {\n \n #[test]\n fn test_drain() {\n-\n     // Empty iter\n     {\n         let mut d: VecDeque<i32> = VecDeque::new();\n@@ -650,12 +633,8 @@ fn test_show() {\n     let ringbuf: VecDeque<_> = (0..10).collect();\n     assert_eq!(format!(\"{:?}\", ringbuf), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"]\n-        .iter()\n-        .cloned()\n-        .collect();\n-    assert_eq!(format!(\"{:?}\", ringbuf),\n-               \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n+    assert_eq!(format!(\"{:?}\", ringbuf), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]\n@@ -955,7 +934,6 @@ fn test_append_permutations() {\n             // doesn't pop more values than are pushed\n             for src_pop_back in 0..(src_push_back + src_push_front) {\n                 for src_pop_front in 0..(src_push_back + src_push_front - src_pop_back) {\n-\n                     let src = construct_vec_deque(\n                         src_push_back,\n                         src_pop_back,\n@@ -966,8 +944,8 @@ fn test_append_permutations() {\n                     for dst_push_back in 0..MAX {\n                         for dst_push_front in 0..MAX {\n                             for dst_pop_back in 0..(dst_push_back + dst_push_front) {\n-                                for dst_pop_front\n-                                    in 0..(dst_push_back + dst_push_front - dst_pop_back)\n+                                for dst_pop_front in\n+                                    0..(dst_push_back + dst_push_front - dst_pop_back)\n                                 {\n                                     let mut dst = construct_vec_deque(\n                                         dst_push_back,\n@@ -1124,7 +1102,6 @@ fn test_reserve_exact_2() {\n #[test]\n #[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve() {\n-\n     // These are the interesting cases:\n     // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n     // * > isize::MAX should always fail\n@@ -1158,22 +1135,27 @@ fn test_try_reserve() {\n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             // Check usize::MAX does count as overflow\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n@@ -1186,47 +1168,54 @@ fn test_try_reserve() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should always overflow in the add-to-len\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n \n-\n     {\n         // Same basic idea, but with interesting type size\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should fail in the mul-by-size\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n     }\n-\n }\n \n #[test]\n #[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n-\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments.\n \n@@ -1247,21 +1236,26 @@ fn test_try_reserve_exact() {\n \n         if guards_against_isize {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n@@ -1273,36 +1267,46 @@ fn test_try_reserve_exact() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n \n-\n     {\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n-\n }\n \n #[test]\n@@ -1404,9 +1408,8 @@ fn test_rotate_right_parts() {\n #[test]\n fn test_rotate_left_random() {\n     let shifts = [\n-        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1,\n-        4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11,\n-        9, 4, 12, 3, 12, 9, 11, 1, 7, 9, 7, 2,\n+        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1, 4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11, 9, 4, 12, 3,\n+        12, 9, 11, 1, 7, 9, 7, 2,\n     ];\n     let n = 12;\n     let mut v: VecDeque<_> = (0..n).collect();\n@@ -1423,9 +1426,8 @@ fn test_rotate_left_random() {\n #[test]\n fn test_rotate_right_random() {\n     let shifts = [\n-        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1,\n-        4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11,\n-        9, 4, 12, 3, 12, 9, 11, 1, 7, 9, 7, 2,\n+        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1, 4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11, 9, 4, 12, 3,\n+        12, 9, 11, 1, 7, 9, 7, 2,\n     ];\n     let n = 12;\n     let mut v: VecDeque<_> = (0..n).collect();\n@@ -1447,8 +1449,7 @@ fn test_try_fold_empty() {\n #[test]\n fn test_try_fold_none() {\n     let v: VecDeque<u32> = (0..12).collect();\n-    assert_eq!(None, v.into_iter().try_fold(0, |a, b|\n-        if b < 11 { Some(a + b) } else { None }));\n+    assert_eq!(None, v.into_iter().try_fold(0, |a, b| if b < 11 { Some(a + b) } else { None }));\n }\n \n #[test]\n@@ -1463,7 +1464,6 @@ fn test_try_fold_unit() {\n     assert_eq!(Some(()), v.into_iter().try_fold((), |(), ()| Some(())));\n }\n \n-\n #[test]\n fn test_try_fold_unit_none() {\n     let v: std::collections::VecDeque<()> = [(); 10].iter().cloned().collect();\n@@ -1534,7 +1534,7 @@ fn test_try_rfold_rotated() {\n \n #[test]\n fn test_try_rfold_moves_iter() {\n-    let v : VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n+    let v: VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n     let mut iter = v.into_iter();\n     assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n     assert_eq!(iter.next_back(), Some(&70));"}, {"sha": "9f133597ab4203fb7743942eeda11eb9c1fa0eb5", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -44,14 +44,14 @@ CloneTypeFoldableImpls! {\n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug)]\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n     pub error: crate::mir::interpret::InterpError<'tcx>,\n     pub stacktrace: Vec<FrameInfo<'tcx>>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug)]\n pub struct FrameInfo<'tcx> {\n     /// This span is in the caller.\n     pub call_site: Span,\n@@ -331,7 +331,7 @@ impl<O: fmt::Debug> fmt::Debug for PanicInfo<O> {\n /// Error information for when the program we executed turned out not to actually be a valid\n /// program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp\n /// where we work on generic code or execution does not have all information available.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, HashStable)]\n pub enum InvalidProgramInfo<'tcx> {\n     /// Resolution can fail if we are in a too generic context.\n     TooGeneric,\n@@ -361,7 +361,7 @@ impl fmt::Debug for InvalidProgramInfo<'tcx> {\n }\n \n /// Error information for when the program caused Undefined Behavior.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, HashStable)]\n pub enum UndefinedBehaviorInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Ub(String),\n@@ -394,11 +394,15 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n ///\n /// Currently, we also use this as fall-back error kind for errors that have not been\n /// categorized yet.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, HashStable)]\n pub enum UnsupportedOpInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n \n+    /// When const-prop encounters a situation it does not support, it raises this error.\n+    /// This must not allocate for performance reasons.\n+    ConstPropUnsupported(&'tcx str),\n+\n     // -- Everything below is not categorized yet --\n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n@@ -559,13 +563,15 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n                     not a power of two\"),\n             Unsupported(ref msg) =>\n                 write!(f, \"{}\", msg),\n+            ConstPropUnsupported(ref msg) =>\n+                write!(f, \"Constant propagation encountered an unsupported situation: {}\", msg),\n         }\n     }\n }\n \n /// Error information for when the program exhausted the resources granted to it\n /// by the interpreter.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, HashStable)]\n pub enum ResourceExhaustionInfo {\n     /// The stack grew too big.\n     StackFrameLimitReached,\n@@ -586,7 +592,7 @@ impl fmt::Debug for ResourceExhaustionInfo {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, HashStable)]\n pub enum InterpError<'tcx> {\n     /// The program panicked.\n     Panic(PanicInfo<u64>),"}, {"sha": "74ba83d0ee4d41f18e4ca350f54256d1c6dfad82", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -94,9 +94,6 @@ pub struct Session {\n     /// The maximum length of types during monomorphization.\n     pub type_length_limit: Once<usize>,\n \n-    /// The maximum number of stackframes allowed in const eval.\n-    pub const_eval_stack_frame_limit: usize,\n-\n     /// Map from imported macro spans (which consist of\n     /// the localized span for the macro body) to the\n     /// macro name and definition span in the source crate.\n@@ -1158,7 +1155,6 @@ fn build_session_(\n         features: Once::new(),\n         recursion_limit: Once::new(),\n         type_length_limit: Once::new(),\n-        const_eval_stack_frame_limit: 100,\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,"}, {"sha": "6cb0d1e9946b597ce41724b53c6ca9d3f5fe96b6", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -69,7 +69,7 @@ pub enum BoundRegion {\n impl BoundRegion {\n     pub fn is_named(&self) -> bool {\n         match *self {\n-            BoundRegion::BrNamed(..) => true,\n+            BoundRegion::BrNamed(_, name) => name != kw::UnderscoreLifetime,\n             _ => false,\n         }\n     }"}, {"sha": "93f4e73ccc311aac793f060eafb36f2e0676d709", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -41,7 +41,7 @@ use rustc::util::common::{set_time_depth, time, print_time_passes_entry, ErrorRe\n use rustc_metadata::locator;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use errors::{PResult, registry::Registry};\n-use rustc_interface::interface;\n+use rustc_interface::{interface, Queries};\n use rustc_interface::util::get_codegen_sysroot;\n use rustc_data_structures::sync::SeqCst;\n use rustc_feature::{find_gated_cfg, UnstableFeatures};\n@@ -98,17 +98,29 @@ pub trait Callbacks {\n     fn config(&mut self, _config: &mut interface::Config) {}\n     /// Called after parsing. Return value instructs the compiler whether to\n     /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n-    fn after_parsing(&mut self, _compiler: &interface::Compiler) -> Compilation {\n+    fn after_parsing<'tcx>(\n+        &mut self,\n+        _compiler: &interface::Compiler,\n+        _queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n         Compilation::Continue\n     }\n     /// Called after expansion. Return value instructs the compiler whether to\n     /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n-    fn after_expansion(&mut self, _compiler: &interface::Compiler) -> Compilation {\n+    fn after_expansion<'tcx>(\n+        &mut self,\n+        _compiler: &interface::Compiler,\n+        _queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n         Compilation::Continue\n     }\n     /// Called after analysis. Return value instructs the compiler whether to\n     /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n-    fn after_analysis(&mut self, _compiler: &interface::Compiler) -> Compilation {\n+    fn after_analysis<'tcx>(\n+        &mut self,\n+        _compiler: &interface::Compiler,\n+        _queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n         Compilation::Continue\n     }\n }\n@@ -312,7 +324,7 @@ pub fn run_compiler(\n                 return early_exit();\n             }\n \n-            if callbacks.after_parsing(compiler) == Compilation::Stop {\n+            if callbacks.after_parsing(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n             }\n \n@@ -333,7 +345,7 @@ pub fn run_compiler(\n             }\n \n             queries.expansion()?;\n-            if callbacks.after_expansion(compiler) == Compilation::Stop {\n+            if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n             }\n \n@@ -382,7 +394,7 @@ pub fn run_compiler(\n \n             queries.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n \n-            if callbacks.after_analysis(compiler) == Compilation::Stop {\n+            if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n             }\n "}, {"sha": "7f111b42403b574e0e049fbbd9ffc8877cb0bfa2", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -107,6 +107,7 @@ E0199: include_str!(\"./error_codes/E0199.md\"),\n E0200: include_str!(\"./error_codes/E0200.md\"),\n E0201: include_str!(\"./error_codes/E0201.md\"),\n E0202: include_str!(\"./error_codes/E0202.md\"),\n+E0203: include_str!(\"./error_codes/E0203.md\"),\n E0204: include_str!(\"./error_codes/E0204.md\"),\n E0205: include_str!(\"./error_codes/E0205.md\"),\n E0206: include_str!(\"./error_codes/E0206.md\"),\n@@ -446,8 +447,6 @@ E0745: include_str!(\"./error_codes/E0745.md\"),\n //  E0190, // deprecated: can only cast a &-pointer to an &-object\n //  E0194, // merged into E0403\n //  E0196, // cannot determine a type for this closure\n-    E0203, // type parameter has more than one relaxed default bound,\n-           // and only one is supported\n     E0208,\n //  E0209, // builtin traits can only be implemented on structs or enums\n     E0212, // cannot extract an associated type from a higher-ranked trait bound"}, {"sha": "1edb519275f79108d538bbc3a90c87c0e80cd2f8", "filename": "src/librustc_error_codes/error_codes/E0203.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_error_codes%2Ferror_codes%2FE0203.md", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_error_codes%2Ferror_codes%2FE0203.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0203.md?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -0,0 +1,18 @@\n+Having multiple relaxed default bounds is unsupported.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0203\n+struct Bad<T: ?Sized + ?Send>{\n+    inner: T\n+}\n+```\n+\n+Here the type `T` cannot have a relaxed bound for multiple default traits\n+(`Sized` and `Send`). This can be fixed by only using one relaxed bound.\n+\n+```\n+struct Good<T: ?Sized>{\n+    inner: T\n+}\n+```"}, {"sha": "76af4342f5c9ef0c59877cdb020394bd6287b98f", "filename": "src/librustc_interface/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -18,6 +18,7 @@ pub mod util;\n mod proc_macro_decls;\n \n pub use interface::{run_compiler, Config};\n+pub use queries::Queries;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "938059c2a923b84199ad5dd87ebc0ba5876a5f5d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/outlives_suggestion.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Foutlives_suggestion.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -78,17 +78,7 @@ impl OutlivesSuggestionBuilder<'a> {\n         match name.source {\n             RegionNameSource::NamedEarlyBoundRegion(..)\n             | RegionNameSource::NamedFreeRegion(..)\n-            | RegionNameSource::Static => {\n-                // FIXME: This is a bit hacky. We should ideally have a semantic way for checking\n-                // if the name is `'_`...\n-                if name.name().with(|name| name != \"'_\") {\n-                    debug!(\"Region {:?} is suggestable\", name);\n-                    true\n-                } else {\n-                    debug!(\"Region {:?} is NOT suggestable\", name);\n-                    false\n-                }\n-            }\n+            | RegionNameSource::Static => true,\n \n             // Don't give suggestions for upvars, closure return types, or other unnamable\n             // regions.\n@@ -98,7 +88,8 @@ impl OutlivesSuggestionBuilder<'a> {\n             | RegionNameSource::MatchedAdtAndSegment(..)\n             | RegionNameSource::AnonRegionFromUpvar(..)\n             | RegionNameSource::AnonRegionFromOutput(..)\n-            | RegionNameSource::AnonRegionFromYieldTy(..) => {\n+            | RegionNameSource::AnonRegionFromYieldTy(..)\n+            | RegionNameSource::AnonRegionFromAsyncFn(..) => {\n                 debug!(\"Region {:?} is NOT suggestable\", name);\n                 false\n             }"}, {"sha": "0f5d1c5edc49858bd970b37bd7d508ad1bf3316e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 34, "deletions": 49, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -13,13 +13,13 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::{Local, Body};\n use rustc::ty::subst::{SubstsRef, GenericArgKind};\n-use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc::ty::print::RegionHighlightMode;\n use rustc_index::vec::IndexVec;\n use rustc_errors::DiagnosticBuilder;\n use syntax::symbol::kw;\n use rustc_data_structures::fx::FxHashMap;\n-use syntax_pos::{Span, symbol::Symbol};\n+use syntax_pos::{Span, symbol::Symbol, DUMMY_SP};\n \n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n@@ -55,7 +55,10 @@ crate enum RegionNameSource {\n     AnonRegionFromUpvar(Span, String),\n     /// The region corresponding to the return type of a closure.\n     AnonRegionFromOutput(Span, String, String),\n+    /// The region from a type yielded by a generator.\n     AnonRegionFromYieldTy(Span, String),\n+    /// An anonymous region from an async fn.\n+    AnonRegionFromAsyncFn(Span),\n }\n \n /// Records region names that have been assigned before so that we can use the same ones in later\n@@ -113,14 +116,11 @@ impl RegionName {\n             RegionNameSource::MatchedAdtAndSegment(..) |\n             RegionNameSource::AnonRegionFromUpvar(..) |\n             RegionNameSource::AnonRegionFromOutput(..) |\n-            RegionNameSource::AnonRegionFromYieldTy(..) => false,\n+            RegionNameSource::AnonRegionFromYieldTy(..) |\n+            RegionNameSource::AnonRegionFromAsyncFn(..) => false,\n         }\n     }\n \n-    crate fn name(&self) -> Symbol {\n-        self.name\n-    }\n-\n     crate fn highlight_region_name(&self, diag: &mut DiagnosticBuilder<'_>) {\n         match &self.source {\n             RegionNameSource::NamedFreeRegion(span)\n@@ -137,7 +137,8 @@ impl RegionName {\n             RegionNameSource::CannotMatchHirTy(span, type_name) => {\n                 diag.span_label(*span, format!(\"has type `{}`\", type_name));\n             }\n-            RegionNameSource::MatchedHirTy(span) => {\n+            RegionNameSource::MatchedHirTy(span) |\n+            RegionNameSource::AnonRegionFromAsyncFn(span) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"let's call the lifetime of this reference `{}`\", self),\n@@ -270,7 +271,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         match error_region {\n             ty::ReEarlyBound(ebr) => {\n                 if ebr.has_name() {\n-                    let span = self.get_named_span(tcx, error_region, ebr.name);\n+                    let span = tcx.hir().span_if_local(ebr.def_id).unwrap_or(DUMMY_SP);\n                     Some(RegionName {\n                         name: ebr.name,\n                         source: RegionNameSource::NamedEarlyBoundRegion(span),\n@@ -286,12 +287,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }),\n \n             ty::ReFree(free_region) => match free_region.bound_region {\n-                ty::BoundRegion::BrNamed(_, name) => {\n-                    let span = self.get_named_span(tcx, error_region, name);\n-                    Some(RegionName {\n-                        name,\n-                        source: RegionNameSource::NamedFreeRegion(span),\n-                    })\n+                ty::BoundRegion::BrNamed(region_def_id, name) => {\n+                    // Get the span to point to, even if we don't use the name.\n+                    let span = tcx.hir().span_if_local(region_def_id).unwrap_or(DUMMY_SP);\n+                    debug!(\"bound region named: {:?}, is_named: {:?}\",\n+                        name, free_region.bound_region.is_named());\n+\n+                    if free_region.bound_region.is_named() {\n+                        // A named region that is actually named.\n+                        Some(RegionName {\n+                            name,\n+                            source: RegionNameSource::NamedFreeRegion(span),\n+                        })\n+                    } else {\n+                        // If we spuriously thought that the region is named, we should let the\n+                        // system generate a true name for error messages. Currently this can\n+                        // happen if we have an elided name in an async fn for example: the\n+                        // compiler will generate a region named `'_`, but reporting such a name is\n+                        // not actually useful, so we synthesize a name for it instead.\n+                        let name = renctx.synthesize_region_name();\n+                        Some(RegionName {\n+                            name,\n+                            source: RegionNameSource::AnonRegionFromAsyncFn(span),\n+                        })\n+                    }\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n@@ -350,40 +369,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Gets a span of a named region to provide context for error messages that\n-    /// mention that span, for example:\n-    ///\n-    /// ```\n-    ///  |\n-    ///  | fn two_regions<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n-    ///  |                --  -- lifetime `'b` defined here\n-    ///  |                |\n-    ///  |                lifetime `'a` defined here\n-    ///  |\n-    ///  |     with_signature(cell, t, |cell, t| require(cell, t));\n-    ///  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must\n-    ///  |                                                         outlive `'a`\n-    /// ```\n-    fn get_named_span(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        error_region: &RegionKind,\n-        name: Symbol,\n-    ) -> Span {\n-        let scope = error_region.free_region_binding_scope(tcx);\n-        let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n-\n-        let span = tcx.sess.source_map().def_span(tcx.hir().span(node));\n-        if let Some(param) = tcx.hir()\n-            .get_generics(scope)\n-            .and_then(|generics| generics.get_named(name))\n-        {\n-            param.span\n-        } else {\n-            span\n-        }\n-    }\n-\n     /// Finds an argument that contains `fr` and label it with a fully\n     /// elaborated type, returning something like `'1`. Result looks\n     /// like:"}, {"sha": "228e5cad4e367091f1ec8f6026762fbfb36bf158", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -548,7 +548,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n-        if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n+        if self.stack.len() > *self.tcx.sess.recursion_limit.get() {\n             throw_exhaust!(StackFrameLimitReached)\n         } else {\n             Ok(())"}, {"sha": "829d9ee6fafd7387542dfeee27a46ab1728775b5", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -560,15 +560,14 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         trace!(\"visit_statement: statement={:?} location={:?}\", statement, location);\n \n         match statement.kind {\n-            StatementKind::Assign(..) => {\n+            StatementKind::Assign(..) | StatementKind::SetDiscriminant { .. } => {\n                 self.super_statement(statement, location);\n             }\n             StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n                 self.check_op(ops::IfOrMatch);\n             }\n             // FIXME(eddyb) should these really do nothing?\n             StatementKind::FakeRead(..) |\n-            StatementKind::SetDiscriminant { .. } |\n             StatementKind::StorageLive(_) |\n             StatementKind::StorageDead(_) |\n             StatementKind::InlineAsm {..} |"}, {"sha": "0fe75301fc1a001fa0d435750ceb76bb6df49a88", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -168,14 +168,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>\n     ) -> InterpResult<'tcx> {\n-        throw_unsup_format!(\"calling intrinsics isn't supported in ConstProp\");\n+        throw_unsup!(ConstPropUnsupported(\"calling intrinsics isn't supported in ConstProp\"));\n     }\n \n     fn ptr_to_int(\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer,\n     ) -> InterpResult<'tcx, u64> {\n-        throw_unsup_format!(\"ptr-to-int casts aren't supported in ConstProp\");\n+        throw_unsup!(ConstPropUnsupported(\"ptr-to-int casts aren't supported in ConstProp\"));\n     }\n \n     fn binary_ptr_op(\n@@ -185,7 +185,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _right: ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n         // We can't do this because aliasing of memory can differ between const eval and llvm\n-        throw_unsup_format!(\"pointer arithmetic or comparisons aren't supported in ConstProp\");\n+        throw_unsup!(ConstPropUnsupported(\"pointer arithmetic or comparisons aren't supported \\\n+            in ConstProp\"));\n     }\n \n     fn find_foreign_static(\n@@ -218,7 +219,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        throw_unsup_format!(\"can't const prop `box` keyword\");\n+        throw_unsup!(ConstPropUnsupported(\"can't const prop `box` keyword\"));\n     }\n \n     fn access_local(\n@@ -229,7 +230,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         let l = &frame.locals[local];\n \n         if l.value == LocalValue::Uninitialized {\n-            throw_unsup_format!(\"tried to access an uninitialized local\");\n+            throw_unsup!(ConstPropUnsupported(\"tried to access an uninitialized local\"));\n         }\n \n         l.access()\n@@ -241,7 +242,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         // if the static allocation is mutable or if it has relocations (it may be legal to mutate\n         // the memory behind that in the future), then we can't const prop it\n         if allocation.mutability == Mutability::Mutable || allocation.relocations().len() > 0 {\n-            throw_unsup_format!(\"can't eval mutable statics in ConstProp\");\n+            throw_unsup!(ConstPropUnsupported(\"can't eval mutable statics in ConstProp\"));\n         }\n \n         Ok(())\n@@ -389,9 +390,26 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n-                use rustc::mir::interpret::InterpError::*;\n+                use rustc::mir::interpret::{\n+                    UnsupportedOpInfo,\n+                    UndefinedBehaviorInfo,\n+                    InterpError::*\n+                };\n                 match error.kind {\n                     Exit(_) => bug!(\"the CTFE program cannot exit\"),\n+\n+                    // Some error shouldn't come up because creating them causes\n+                    // an allocation, which we should avoid. When that happens,\n+                    // dedicated error variants should be introduced instead.\n+                    // Only test this in debug builds though to avoid disruptions.\n+                    Unsupported(UnsupportedOpInfo::Unsupported(_))\n+                    | Unsupported(UnsupportedOpInfo::ValidationFailure(_))\n+                    | UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n+                    | UndefinedBehavior(UndefinedBehaviorInfo::UbExperimental(_))\n+                      if cfg!(debug_assertions) => {\n+                        bug!(\"const-prop encountered allocating error: {:?}\", error.kind);\n+                    }\n+\n                     Unsupported(_)\n                     | UndefinedBehavior(_)\n                     | InvalidProgram(_)"}, {"sha": "e40d6a5952edb2aebd16c68bd6d70ef2c607a710", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -225,7 +225,7 @@ fn check_statement(\n         StatementKind::FakeRead(_, place) => check_place(tcx, place, span, def_id, body),\n \n         // just an assignment\n-        StatementKind::SetDiscriminant { .. } => Ok(()),\n+        StatementKind::SetDiscriminant { place, .. } => check_place(tcx, place, span, def_id, body),\n \n         | StatementKind::InlineAsm { .. } => {\n             Err((span, \"cannot use inline assembly in const fn\".into()))"}, {"sha": "bfabe1722dbedc53d2c693a8a06da24a06d3faa3", "filename": "src/libtest/test_result.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibtest%2Ftest_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibtest%2Ftest_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftest_result.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -37,22 +37,30 @@ pub fn calc_result<'a>(\n     let result = match (&desc.should_panic, task_result) {\n         (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TestResult::TrOk,\n         (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n-            if err\n+            let maybe_panic_str = err\n                 .downcast_ref::<String>()\n                 .map(|e| &**e)\n-                .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n-                .map(|e| e.contains(msg))\n-                .unwrap_or(false)\n-            {\n+                .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e));\n+\n+            if maybe_panic_str.map(|e| e.contains(msg)).unwrap_or(false) {\n                 TestResult::TrOk\n+            } else if desc.allow_fail {\n+                TestResult::TrAllowedFail\n+            } else if let Some(panic_str) = maybe_panic_str {\n+                TestResult::TrFailedMsg(format!(\n+                    r#\"panic did not contain expected string\n+      panic message: `{:?}`,\n+ expected substring: `{:?}`\"#,\n+                    panic_str, msg\n+                ))\n             } else {\n-                if desc.allow_fail {\n-                    TestResult::TrAllowedFail\n-                } else {\n-                    TestResult::TrFailedMsg(\n-                        format!(\"panic did not include expected string '{}'\", msg)\n-                    )\n-                }\n+                TestResult::TrFailedMsg(format!(\n+                    r#\"expected panic with string value,\n+ found non-string value: `{:?}`\n+     expected substring: `{:?}`\"#,\n+                    (**err).type_id(),\n+                    msg\n+                ))\n             }\n         }\n         (&ShouldPanic::Yes, Ok(())) => {"}, {"sha": "0bea2b80ecf5e185e2ce40f7c82cb0af14346e98", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -15,6 +15,7 @@ use crate::{\n         // TestType, TrFailedMsg, TrIgnored, TrOk,\n     },\n };\n+use std::any::TypeId;\n use std::sync::mpsc::channel;\n use std::time::Duration;\n \n@@ -84,7 +85,7 @@ pub fn do_not_run_ignored_tests() {\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n-    assert!(result != TrOk);\n+    assert_ne!(result, TrOk);\n }\n \n #[test]\n@@ -103,7 +104,7 @@ pub fn ignored_tests_result_in_ignored() {\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n-    assert!(result == TrIgnored);\n+    assert_eq!(result, TrIgnored);\n }\n \n // FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n@@ -126,7 +127,7 @@ fn test_should_panic() {\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n-    assert!(result == TrOk);\n+    assert_eq!(result, TrOk);\n }\n \n // FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n@@ -149,7 +150,7 @@ fn test_should_panic_good_message() {\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n-    assert!(result == TrOk);\n+    assert_eq!(result, TrOk);\n }\n \n // FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n@@ -161,7 +162,9 @@ fn test_should_panic_bad_message() {\n         panic!(\"an error message\");\n     }\n     let expected = \"foobar\";\n-    let failed_msg = \"panic did not include expected string\";\n+    let failed_msg = r#\"panic did not contain expected string\n+      panic message: `\"an error message\"`,\n+ expected substring: `\"foobar\"`\"#;\n     let desc = TestDescAndFn {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n@@ -175,7 +178,35 @@ fn test_should_panic_bad_message() {\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n-    assert!(result == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n+    assert_eq!(result, TrFailedMsg(failed_msg.to_string()));\n+}\n+\n+// FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n+#[test]\n+#[cfg(not(target_os = \"emscripten\"))]\n+fn test_should_panic_non_string_message_type() {\n+    use crate::tests::TrFailedMsg;\n+    fn f() {\n+        panic!(1i32);\n+    }\n+    let expected = \"foobar\";\n+    let failed_msg = format!(r#\"expected panic with string value,\n+ found non-string value: `{:?}`\n+     expected substring: `\"foobar\"`\"#, TypeId::of::<i32>());\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::YesWithMessage(expected),\n+            allow_fail: false,\n+            test_type: TestType::Unknown,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    let result = rx.recv().unwrap().result;\n+    assert_eq!(result, TrFailedMsg(failed_msg));\n }\n \n // FIXME: Re-enable emscripten once it can catch panics again (introduced by #65251)\n@@ -196,7 +227,7 @@ fn test_should_panic_but_succeeds() {\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let result = rx.recv().unwrap().result;\n-    assert!(result == TrFailedMsg(\"test did not panic as expected\".to_string()));\n+    assert_eq!(result, TrFailedMsg(\"test did not panic as expected\".to_string()));\n }\n \n fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n@@ -570,7 +601,7 @@ pub fn sort_tests() {\n     ];\n \n     for (a, b) in expected.iter().zip(filtered) {\n-        assert!(*a == b.desc.name.to_string());\n+        assert_eq!(*a, b.desc.name.to_string());\n     }\n }\n "}, {"sha": "4ae3971e90eae7265f6637c290c25e4ecbd3db5e", "filename": "src/test/ui/async-await/issues/issue-63388-1.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -12,12 +12,12 @@ error: lifetime may not live long enough\n LL |       async fn do_sth<'a>(\n    |                       -- lifetime `'a` defined here\n LL |           &'a self, foo: &dyn Foo\n-   |                          - lifetime `'_` defined here\n+   |                          - let's call the lifetime of this reference `'1`\n LL |       ) -> &dyn Foo\n LL | /     {\n LL | |         foo\n LL | |     }\n-   | |_____^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'_`\n+   | |_____^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'1`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "19f9cd28a9a01251dce1c394cedb8f0badd1c692", "filename": "src/test/ui/maybe-bounds-where.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -42,3 +42,4 @@ LL | struct S5<T>(*const T) where T: ?Trait<'static> + ?Sized;\n \n error: aborting due to 6 previous errors\n \n+For more information about this error, try `rustc --explain E0203`."}, {"sha": "5a63553adc5c8f5262477a42cb3d425bf6ab0995", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.nll.stderr?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -2,11 +2,11 @@ error: lifetime may not live long enough\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:48\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                          -                     ^^^^^^^^ returning this value requires that `'_` must outlive `'static`\n+   |                          -                     ^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n    |                          |\n-   |                          lifetime `'_` defined here\n+   |                          let's call the lifetime of this reference `'1`\n    |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'_`, add `'_` as a constraint\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a constraint\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n    |                                     ^^^^^^^^^^^^^^^"}, {"sha": "b05940fd273a146ebda42d28d66c4b7631c8f528", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -10,19 +10,19 @@ error: lifetime may not live long enough\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:8:52\n    |\n LL |     async fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n-   |                          -                         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n-   |                          |\n-   |                          lifetime `'_` defined here\n-   |                          lifetime `'_` defined here\n+   |                          -         -               ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |                          |         |\n+   |                          |         let's call the lifetime of this reference `'1`\n+   |                          let's call the lifetime of this reference `'2`\n \n error: lifetime may not live long enough\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:11:75\n    |\n LL |     async fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) }\n-   |                          -                                                ^^^^^^^^^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n-   |                          |\n-   |                          lifetime `'_` defined here\n-   |                          lifetime `'_` defined here\n+   |                          -          -                                     ^^^^^^^^^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |                          |          |\n+   |                          |          let's call the lifetime of this reference `'1`\n+   |                          let's call the lifetime of this reference `'2`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:17:58\n@@ -36,8 +36,9 @@ error: lifetime may not live long enough\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:17:64\n    |\n LL |     async fn bar<'a>(self: Alias<&Self>, arg: &'a ()) -> &() { arg }\n-   |                  --              - lifetime `'_` defined here  ^^^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'a`\n-   |                  |\n+   |                  --              -                             ^^^ function was supposed to return data with lifetime `'1` but it is returning data with lifetime `'a`\n+   |                  |               |\n+   |                  |               let's call the lifetime of this reference `'1`\n    |                  lifetime `'a` defined here\n \n error: aborting due to 5 previous errors"}, {"sha": "8dd823a2204971b127bc76106a9f44ff7303a726", "filename": "src/test/ui/self/elision/lt-ref-self-async.nll.stderr", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -10,12 +10,11 @@ error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:13:9\n    |\n LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n-   |                       -\n+   |                       -         - let's call the lifetime of this reference `'1`\n    |                       |\n-   |                       lifetime `'_` defined here\n-   |                       lifetime `'_` defined here\n+   |                       let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/lt-ref-self-async.rs:18:48\n@@ -29,12 +28,11 @@ error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:19:9\n    |\n LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n-   |                             -\n+   |                             -         - let's call the lifetime of this reference `'1`\n    |                             |\n-   |                             lifetime `'_` defined here\n-   |                             lifetime `'_` defined here\n+   |                             let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/lt-ref-self-async.rs:22:57\n@@ -48,12 +46,11 @@ error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:23:9\n    |\n LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n-   |                                     -\n+   |                                     -          - let's call the lifetime of this reference `'1`\n    |                                     |\n-   |                                     lifetime `'_` defined here\n-   |                                     lifetime `'_` defined here\n+   |                                     let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/lt-ref-self-async.rs:26:57\n@@ -67,12 +64,11 @@ error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:27:9\n    |\n LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n-   |                                     -\n+   |                                     -          - let's call the lifetime of this reference `'1`\n    |                                     |\n-   |                                     lifetime `'_` defined here\n-   |                                     lifetime `'_` defined here\n+   |                                     let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/lt-ref-self-async.rs:30:66\n@@ -86,12 +82,11 @@ error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:31:9\n    |\n LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n-   |                                             -\n+   |                                             -           - let's call the lifetime of this reference `'1`\n    |                                             |\n-   |                                             lifetime `'_` defined here\n-   |                                             lifetime `'_` defined here\n+   |                                             let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/lt-ref-self-async.rs:34:62\n@@ -105,12 +100,11 @@ error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:35:9\n    |\n LL |     async fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n-   |                                         -\n+   |                                         -           - let's call the lifetime of this reference `'1`\n    |                                         |\n-   |                                         lifetime `'_` defined here\n-   |                                         lifetime `'_` defined here\n+   |                                         let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error: aborting due to 12 previous errors\n "}, {"sha": "768f532c18317ca4f7512e3ca5b1315d8219a19c", "filename": "src/test/ui/self/elision/ref-mut-self-async.nll.stderr", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -10,12 +10,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:13:9\n    |\n LL |     async fn ref_self(&mut self, f: &u32) -> &u32 {\n-   |                       -\n+   |                       -             - let's call the lifetime of this reference `'1`\n    |                       |\n-   |                       lifetime `'_` defined here\n-   |                       lifetime `'_` defined here\n+   |                       let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-mut-self-async.rs:18:52\n@@ -29,12 +28,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:19:9\n    |\n LL |     async fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n-   |                             -\n+   |                             -             - let's call the lifetime of this reference `'1`\n    |                             |\n-   |                             lifetime `'_` defined here\n-   |                             lifetime `'_` defined here\n+   |                             let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-mut-self-async.rs:22:61\n@@ -48,12 +46,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:23:9\n    |\n LL |     async fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n-   |                                     -\n+   |                                     -              - let's call the lifetime of this reference `'1`\n    |                                     |\n-   |                                     lifetime `'_` defined here\n-   |                                     lifetime `'_` defined here\n+   |                                     let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-mut-self-async.rs:26:61\n@@ -67,12 +64,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:27:9\n    |\n LL |     async fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n-   |                                     -\n+   |                                     -              - let's call the lifetime of this reference `'1`\n    |                                     |\n-   |                                     lifetime `'_` defined here\n-   |                                     lifetime `'_` defined here\n+   |                                     let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-mut-self-async.rs:30:70\n@@ -86,12 +82,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:31:9\n    |\n LL |     async fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n-   |                                             -\n+   |                                             -               - let's call the lifetime of this reference `'1`\n    |                                             |\n-   |                                             lifetime `'_` defined here\n-   |                                             lifetime `'_` defined here\n+   |                                             let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-mut-self-async.rs:34:70\n@@ -105,12 +100,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:35:9\n    |\n LL |     async fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n-   |                                             -\n+   |                                             -               - let's call the lifetime of this reference `'1`\n    |                                             |\n-   |                                             lifetime `'_` defined here\n-   |                                             lifetime `'_` defined here\n+   |                                             let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error: aborting due to 12 previous errors\n "}, {"sha": "9e26e411d30bd832183f4479d449a47b8e36eac8", "filename": "src/test/ui/self/elision/ref-mut-struct-async.nll.stderr", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -10,12 +10,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:13:9\n    |\n LL |     async fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n-   |                               -\n+   |                               -               - let's call the lifetime of this reference `'1`\n    |                               |\n-   |                               lifetime `'_` defined here\n-   |                               lifetime `'_` defined here\n+   |                               let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-mut-struct-async.rs:16:65\n@@ -29,12 +28,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:17:9\n    |\n LL |     async fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n-   |                                       -\n+   |                                       -                - let's call the lifetime of this reference `'1`\n    |                                       |\n-   |                                       lifetime `'_` defined here\n-   |                                       lifetime `'_` defined here\n+   |                                       let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-mut-struct-async.rs:20:65\n@@ -48,12 +46,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:21:9\n    |\n LL |     async fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n-   |                                       -\n+   |                                       -                - let's call the lifetime of this reference `'1`\n    |                                       |\n-   |                                       lifetime `'_` defined here\n-   |                                       lifetime `'_` defined here\n+   |                                       let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-mut-struct-async.rs:24:74\n@@ -67,12 +64,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:25:9\n    |\n LL |     async fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u32 {\n-   |                                               -\n+   |                                               -                 - let's call the lifetime of this reference `'1`\n    |                                               |\n-   |                                               lifetime `'_` defined here\n-   |                                               lifetime `'_` defined here\n+   |                                               let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-mut-struct-async.rs:28:74\n@@ -86,12 +82,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:29:9\n    |\n LL |     async fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u32 {\n-   |                                               -\n+   |                                               -                 - let's call the lifetime of this reference `'1`\n    |                                               |\n-   |                                               lifetime `'_` defined here\n-   |                                               lifetime `'_` defined here\n+   |                                               let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error: aborting due to 10 previous errors\n "}, {"sha": "cbf051205ed969cfd9f836ca3bc030d8ccd6885b", "filename": "src/test/ui/self/elision/ref-struct-async.nll.stderr", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4007d4ef26eab44bdabc2b7574d032152264d3ad/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr?ref=4007d4ef26eab44bdabc2b7574d032152264d3ad", "patch": "@@ -10,12 +10,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:13:9\n    |\n LL |     async fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n-   |                               -\n+   |                               -           - let's call the lifetime of this reference `'1`\n    |                               |\n-   |                               lifetime `'_` defined here\n-   |                               lifetime `'_` defined here\n+   |                               let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-struct-async.rs:16:61\n@@ -29,12 +28,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:17:9\n    |\n LL |     async fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n-   |                                       -\n+   |                                       -            - let's call the lifetime of this reference `'1`\n    |                                       |\n-   |                                       lifetime `'_` defined here\n-   |                                       lifetime `'_` defined here\n+   |                                       let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-struct-async.rs:20:61\n@@ -48,12 +46,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:21:9\n    |\n LL |     async fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n-   |                                       -\n+   |                                       -            - let's call the lifetime of this reference `'1`\n    |                                       |\n-   |                                       lifetime `'_` defined here\n-   |                                       lifetime `'_` defined here\n+   |                                       let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-struct-async.rs:24:70\n@@ -67,12 +64,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:25:9\n    |\n LL |     async fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n-   |                                               -\n+   |                                               -             - let's call the lifetime of this reference `'1`\n    |                                               |\n-   |                                               lifetime `'_` defined here\n-   |                                               lifetime `'_` defined here\n+   |                                               let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ref-struct-async.rs:28:66\n@@ -86,12 +82,11 @@ error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:29:9\n    |\n LL |     async fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n-   |                                           -\n+   |                                           -             - let's call the lifetime of this reference `'1`\n    |                                           |\n-   |                                           lifetime `'_` defined here\n-   |                                           lifetime `'_` defined here\n+   |                                           let's call the lifetime of this reference `'2`\n LL |         f\n-   |         ^ function was supposed to return data with lifetime `'_` but it is returning data with lifetime `'_`\n+   |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n error: aborting due to 10 previous errors\n "}]}