{"sha": "d476147629970b86657d46465a20982343a9280d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NzYxNDc2Mjk5NzBiODY2NTdkNDY0NjVhMjA5ODIzNDNhOTI4MGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-01T19:32:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-09T15:02:14Z"}, "message": "cache the `dropck_outlives` computation per variable", "tree": {"sha": "7c0763b0b0c90b6640de0dede88da64d81eaadf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c0763b0b0c90b6640de0dede88da64d81eaadf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d476147629970b86657d46465a20982343a9280d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d476147629970b86657d46465a20982343a9280d", "html_url": "https://github.com/rust-lang/rust/commit/d476147629970b86657d46465a20982343a9280d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d476147629970b86657d46465a20982343a9280d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "780f6c52cc23ccb04d95d0857a6c48362a67a702", "url": "https://api.github.com/repos/rust-lang/rust/commits/780f6c52cc23ccb04d95d0857a6c48362a67a702", "html_url": "https://github.com/rust-lang/rust/commit/780f6c52cc23ccb04d95d0857a6c48362a67a702"}], "stats": {"total": 108, "additions": 57, "deletions": 51}, "files": [{"sha": "80b9dde98c230683282984f457665fb061ff6683", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/d476147629970b86657d46465a20982343a9280d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d476147629970b86657d46465a20982343a9280d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=d476147629970b86657d46465a20982343a9280d", "patch": "@@ -13,10 +13,14 @@ use borrow_check::nll::type_check::AtLocation;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n-use rustc::infer::InferOk;\n+use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::mir::Local;\n use rustc::mir::{BasicBlock, Location, Mir};\n-use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::subst::Kind;\n+use rustc::ty::{Ty, TypeFoldable};\n+use rustc_data_structures::fx::FxHashMap;\n+use std::rc::Rc;\n+use syntax::codemap::DUMMY_SP;\n use util::liveness::LivenessResults;\n \n use super::TypeChecker;\n@@ -36,14 +40,13 @@ pub(super) fn generate<'gcx, 'tcx>(\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n-    let tcx = cx.tcx();\n     let mut generator = TypeLivenessGenerator {\n         cx,\n-        tcx,\n         mir,\n         liveness,\n         flow_inits,\n         move_data,\n+        drop_data: FxHashMap(),\n     };\n \n     for bb in mir.basic_blocks().indices() {\n@@ -59,11 +62,16 @@ where\n     'gcx: 'tcx,\n {\n     cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n-    tcx: TyCtxt<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n     liveness: &'gen LivenessResults,\n     flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n+    drop_data: FxHashMap<Local, DropData<'tcx>>,\n+}\n+\n+struct DropData<'tcx> {\n+    dropped_kinds: Vec<Kind<'tcx>>,\n+    region_constraint_data: Option<Rc<RegionConstraintData<'tcx>>>,\n }\n \n impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n@@ -80,7 +88,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                 for live_local in live_locals.iter() {\n                     let live_local_ty = self.mir.local_decls[live_local].ty;\n                     let cause = Cause::LiveVar(live_local, location);\n-                    self.push_type_live_constraint(live_local_ty, location, cause);\n+                    Self::push_type_live_constraint(&mut self.cx, live_local_ty, location, cause);\n                 }\n             });\n \n@@ -148,17 +156,21 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at\n     /// `location`.\n-    fn push_type_live_constraint<T>(&mut self, value: T, location: Location, cause: Cause)\n-    where\n+    fn push_type_live_constraint<T>(\n+        cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+        value: T,\n+        location: Location,\n+        cause: Cause,\n+    ) where\n         T: TypeFoldable<'tcx>,\n     {\n         debug!(\n             \"push_type_live_constraint(live_ty={:?}, location={:?})\",\n             value, location\n         );\n \n-        self.tcx.for_each_free_region(&value, |live_region| {\n-            self.cx\n+        cx.tcx().for_each_free_region(&value, |live_region| {\n+            cx\n                 .constraints\n                 .liveness_set\n                 .push((live_region, location, cause.clone()));\n@@ -182,53 +194,47 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             dropped_local, dropped_ty, location\n         );\n \n-        // If we end visiting the same type twice (usually due to a cycle involving\n-        // associated types), we need to ensure that its region types match up with the type\n-        // we added to the 'known' map the first time around. For this reason, we need\n-        // our infcx to hold onto its calculated region constraints after each call\n-        // to dtorck_constraint_for_ty. Otherwise, normalizing the corresponding associated\n-        // type will end up instantiating the type with a new set of inference variables\n-        // Since this new type will never be in 'known', we end up looping forever.\n-        //\n-        // For this reason, we avoid calling TypeChecker.normalize, instead doing all normalization\n-        // ourselves in one large 'fully_perform_op' callback.\n-        let kind_constraints = self\n-            .cx\n-            .fully_perform_op(\n-                location.at_self(),\n-                || format!(\"add_drop_live_constraint(dropped_ty={:?})\", dropped_ty),\n-                |cx| {\n-                    let span = cx.last_span;\n+        let drop_data = self.drop_data.entry(dropped_local).or_insert_with({\n+            let cx = &mut self.cx;\n+            move || Self::compute_drop_data(cx, dropped_ty)\n+        });\n \n-                    let mut final_obligations = Vec::new();\n-                    let mut kind_constraints = Vec::new();\n+        if let Some(data) = &drop_data.region_constraint_data {\n+            self.cx\n+                .push_region_constraints(location.at_self(), data.clone());\n+        }\n \n-                    let InferOk {\n-                        value: kinds,\n-                        obligations,\n-                    } = cx\n+        // All things in the `outlives` array may be touched by\n+        // the destructor and must be live at this point.\n+        let cause = Cause::DropVar(dropped_local, location);\n+        for &kind in &drop_data.dropped_kinds {\n+            Self::push_type_live_constraint(&mut self.cx, kind, location, cause);\n+        }\n+    }\n+\n+    #[inline(never)]\n+    fn compute_drop_data(\n+        cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+        dropped_ty: Ty<'tcx>,\n+    ) -> DropData<'tcx> {\n+        debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n+\n+        let (dropped_kinds, region_constraint_data) =\n+            cx.fully_perform_op_and_get_region_constraint_data(\n+                || format!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty),\n+                |cx| {\n+                    // crappy span, but I don't think it really matters\n+                    let span = DUMMY_SP;\n+                    Ok(cx\n                         .infcx\n                         .at(&cx.misc(span), cx.param_env)\n-                        .dropck_outlives(dropped_ty);\n-                    for kind in kinds {\n-                        // All things in the `outlives` array may be touched by\n-                        // the destructor and must be live at this point.\n-                        let cause = Cause::DropVar(dropped_local, location);\n-                        kind_constraints.push((kind, location, cause));\n-                    }\n-\n-                    final_obligations.extend(obligations);\n-\n-                    Ok(InferOk {\n-                        value: kind_constraints,\n-                        obligations: final_obligations,\n-                    })\n+                        .dropck_outlives(dropped_ty))\n                 },\n-            )\n-            .unwrap();\n+            ).unwrap();\n \n-        for (kind, location, cause) in kind_constraints {\n-            self.push_type_live_constraint(kind, location, cause);\n+        DropData {\n+            dropped_kinds,\n+            region_constraint_data,\n         }\n     }\n }"}]}