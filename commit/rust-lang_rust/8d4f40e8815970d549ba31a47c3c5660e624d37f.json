{"sha": "8d4f40e8815970d549ba31a47c3c5660e624d37f", "node_id": "C_kwDOAAsO6NoAKDhkNGY0MGU4ODE1OTcwZDU0OWJhMzFhNDdjM2M1NjYwZTYyNGQzN2Y", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-08T10:04:16Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-08T10:04:16Z"}, "message": "Do less allocs in `trait_data` and `impl_data` queries", "tree": {"sha": "3c2de7b2d41f7eff2c2c77c6e9efaebdb118373f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c2de7b2d41f7eff2c2c77c6e9efaebdb118373f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d4f40e8815970d549ba31a47c3c5660e624d37f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d4f40e8815970d549ba31a47c3c5660e624d37f", "html_url": "https://github.com/rust-lang/rust/commit/8d4f40e8815970d549ba31a47c3c5660e624d37f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d4f40e8815970d549ba31a47c3c5660e624d37f/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6746ba58398cb17f45c8bfdc403f78d8bdaad5fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6746ba58398cb17f45c8bfdc403f78d8bdaad5fc", "html_url": "https://github.com/rust-lang/rust/commit/6746ba58398cb17f45c8bfdc403f78d8bdaad5fc"}], "stats": {"total": 87, "additions": 49, "deletions": 38}, "files": [{"sha": "471c7330d73d7807712caed066e8da37fcf32436", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8d4f40e8815970d549ba31a47c3c5660e624d37f/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d4f40e8815970d549ba31a47c3c5660e624d37f/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=8d4f40e8815970d549ba31a47c3c5660e624d37f", "patch": "@@ -184,6 +184,7 @@ pub struct TraitData {\n     /// method calls to this trait's methods when the receiver is an array and the crate edition is\n     /// 2015 or 2018.\n     pub skip_array_during_method_dispatch: bool,\n+    // box it as the vec is usually empty anyways\n     pub attribute_calls: Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n }\n \n@@ -208,17 +209,8 @@ impl TraitData {\n             .by_key(\"rustc_skip_array_during_method_dispatch\")\n             .exists();\n \n-        let (attribute_calls, items) = collect_items(\n-            db,\n-            module_id,\n-            &mut expander,\n-            tr_def.items.iter().copied(),\n-            tr_loc.id.tree_id(),\n-            container,\n-            100,\n-        );\n-        let attribute_calls =\n-            if attribute_calls.is_empty() { None } else { Some(Box::new(attribute_calls)) };\n+        let (items, attribute_calls) =\n+            do_collect(db, module_id, &mut expander, &tr_def.items, tr_loc.id.tree_id(), container);\n \n         Arc::new(TraitData {\n             name,\n@@ -263,6 +255,7 @@ pub struct ImplData {\n     pub self_ty: Interned<TypeRef>,\n     pub items: Vec<AssocItemId>,\n     pub is_negative: bool,\n+    // box it as the vec is usually empty anyways\n     pub attribute_calls: Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n }\n \n@@ -280,18 +273,15 @@ impl ImplData {\n         let container = ItemContainerId::ImplId(id);\n         let mut expander = Expander::new(db, impl_loc.id.file_id(), module_id);\n \n-        let (attribute_calls, items) = collect_items(\n+        let (items, attribute_calls) = do_collect(\n             db,\n             module_id,\n             &mut expander,\n-            impl_def.items.iter().copied(),\n+            &impl_def.items,\n             impl_loc.id.tree_id(),\n             container,\n-            100,\n         );\n         let items = items.into_iter().map(|(_, item)| item).collect();\n-        let attribute_calls =\n-            if attribute_calls.is_empty() { None } else { Some(Box::new(attribute_calls)) };\n \n         Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls })\n     }\n@@ -348,44 +338,70 @@ impl StaticData {\n     }\n }\n \n+fn do_collect(\n+    db: &dyn DefDatabase,\n+    module_id: ModuleId,\n+    expander: &mut Expander,\n+    assoc_items: &[AssocItem],\n+    tree_id: item_tree::TreeId,\n+    container: ItemContainerId,\n+) -> (Vec<(Name, AssocItemId)>, Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>) {\n+    let mut items = Vec::new();\n+    let mut attribute_calls = Vec::new();\n+\n+    collect_items(\n+        db,\n+        &mut items,\n+        &mut attribute_calls,\n+        module_id,\n+        expander,\n+        assoc_items.iter().copied(),\n+        tree_id,\n+        container,\n+        100,\n+    );\n+\n+    let attribute_calls =\n+        if attribute_calls.is_empty() { None } else { Some(Box::new(attribute_calls)) };\n+    (items, attribute_calls)\n+}\n+\n fn collect_items(\n     db: &dyn DefDatabase,\n+    items: &mut Vec<(Name, AssocItemId)>,\n+    attr_calls: &mut Vec<(AstId<ast::Item>, MacroCallId)>,\n     module: ModuleId,\n     expander: &mut Expander,\n     assoc_items: impl Iterator<Item = AssocItem>,\n     tree_id: item_tree::TreeId,\n     container: ItemContainerId,\n     limit: usize,\n-) -> (Vec<(AstId<ast::Item>, MacroCallId)>, Vec<(Name, AssocItemId)>) {\n+) {\n     if limit == 0 {\n-        return Default::default();\n+        return;\n     }\n \n     let item_tree = tree_id.item_tree(db);\n     let crate_graph = db.crate_graph();\n     let cfg_options = &crate_graph[module.krate].cfg_options;\n     let def_map = module.def_map(db);\n \n-    let mut items = Vec::new();\n-    let mut attribute_calls = Vec::new();\n-\n     'items: for item in assoc_items {\n         let attrs = item_tree.attrs(db, module.krate, ModItem::from(item).into());\n         if !attrs.is_cfg_enabled(cfg_options) {\n             continue;\n         }\n+\n         for attr in &*attrs {\n             let ast_id = AstId::new(expander.current_file_id(), item.ast_id(&item_tree).upcast());\n             let ast_id_with_path = AstIdWithPath { path: (*attr.path).clone(), ast_id };\n+\n             if let Ok(ResolvedAttr::Macro(call_id)) =\n                 def_map.resolve_attr_macro(db, module.local_id, ast_id_with_path, attr)\n             {\n-                attribute_calls.push((ast_id, call_id));\n+                attr_calls.push((ast_id, call_id));\n                 let res = expander.enter_expand_id(db, call_id);\n-                let (mac_attrs, mac_items) =\n-                    collect_macro_items(db, module, expander, container, limit, res);\n-                items.extend(mac_items);\n-                attribute_calls.extend(mac_attrs);\n+                collect_macro_items(db, items, attr_calls, module, expander, container, limit, res);\n                 continue 'items;\n             }\n         }\n@@ -419,37 +435,32 @@ fn collect_items(\n                 let res = expander.enter_expand(db, call);\n \n                 if let Ok(res) = res {\n-                    let (mac_attrs, mac_items) =\n-                        collect_macro_items(db, module, expander, container, limit, res);\n-                    items.extend(mac_items);\n-                    attribute_calls.extend(mac_attrs);\n+                    collect_macro_items(\n+                        db, items, attr_calls, module, expander, container, limit, res,\n+                    );\n                 }\n             }\n         }\n     }\n-\n-    (attribute_calls, items)\n }\n \n fn collect_macro_items(\n     db: &dyn DefDatabase,\n+    items: &mut Vec<(Name, AssocItemId)>,\n+    attr_calls: &mut Vec<(AstId<ast::Item>, MacroCallId)>,\n     module: ModuleId,\n     expander: &mut Expander,\n     container: ItemContainerId,\n     limit: usize,\n     res: ExpandResult<Option<(Mark, ast::MacroItems)>>,\n-) -> (Vec<(AstId<ast::Item>, MacroCallId)>, Vec<(Name, AssocItemId)>) {\n+) {\n     if let Some((mark, mac)) = res.value {\n         let src: InFile<ast::MacroItems> = expander.to_source(mac);\n         let tree_id = item_tree::TreeId::new(src.file_id, None);\n         let item_tree = tree_id.item_tree(db);\n         let iter = item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item);\n-        let items = collect_items(db, module, expander, iter, tree_id, container, limit - 1);\n+        collect_items(db, items, attr_calls, module, expander, iter, tree_id, container, limit - 1);\n \n         expander.exit(db, mark);\n-\n-        return items;\n     }\n-\n-    Default::default()\n }"}]}