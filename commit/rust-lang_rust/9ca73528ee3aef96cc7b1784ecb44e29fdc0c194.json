{"sha": "9ca73528ee3aef96cc7b1784ecb44e29fdc0c194", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYTczNTI4ZWUzYWVmOTZjYzdiMTc4NGVjYjQ0ZTI5ZmRjMGMxOTQ=", "commit": {"author": {"name": "mahdi-frms", "email": "mahdif1380@outlook.com", "date": "2021-08-05T09:30:08Z"}, "committer": {"name": "mahdi-frms", "email": "mahdif1380@outlook.com", "date": "2021-08-09T16:36:24Z"}, "message": "generate method assist", "tree": {"sha": "bedc0bd8992433e7159741c0b23ffd3c0c567be6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bedc0bd8992433e7159741c0b23ffd3c0c567be6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ca73528ee3aef96cc7b1784ecb44e29fdc0c194", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ca73528ee3aef96cc7b1784ecb44e29fdc0c194", "html_url": "https://github.com/rust-lang/rust/commit/9ca73528ee3aef96cc7b1784ecb44e29fdc0c194", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ca73528ee3aef96cc7b1784ecb44e29fdc0c194/comments", "author": {"login": "mahdifrmz", "id": 62165556, "node_id": "MDQ6VXNlcjYyMTY1NTU2", "avatar_url": "https://avatars.githubusercontent.com/u/62165556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahdifrmz", "html_url": "https://github.com/mahdifrmz", "followers_url": "https://api.github.com/users/mahdifrmz/followers", "following_url": "https://api.github.com/users/mahdifrmz/following{/other_user}", "gists_url": "https://api.github.com/users/mahdifrmz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahdifrmz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahdifrmz/subscriptions", "organizations_url": "https://api.github.com/users/mahdifrmz/orgs", "repos_url": "https://api.github.com/users/mahdifrmz/repos", "events_url": "https://api.github.com/users/mahdifrmz/events{/privacy}", "received_events_url": "https://api.github.com/users/mahdifrmz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mahdifrmz", "id": 62165556, "node_id": "MDQ6VXNlcjYyMTY1NTU2", "avatar_url": "https://avatars.githubusercontent.com/u/62165556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahdifrmz", "html_url": "https://github.com/mahdifrmz", "followers_url": "https://api.github.com/users/mahdifrmz/followers", "following_url": "https://api.github.com/users/mahdifrmz/following{/other_user}", "gists_url": "https://api.github.com/users/mahdifrmz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahdifrmz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahdifrmz/subscriptions", "organizations_url": "https://api.github.com/users/mahdifrmz/orgs", "repos_url": "https://api.github.com/users/mahdifrmz/repos", "events_url": "https://api.github.com/users/mahdifrmz/events{/privacy}", "received_events_url": "https://api.github.com/users/mahdifrmz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2b24255c870afc1b4d7e19aa1be022d4366b760", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b24255c870afc1b4d7e19aa1be022d4366b760", "html_url": "https://github.com/rust-lang/rust/commit/b2b24255c870afc1b4d7e19aa1be022d4366b760"}], "stats": {"total": 154, "additions": 154, "deletions": 0}, "files": [{"sha": "3012ccf2ba5c011cc88c2fabc3017cb26e170709", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/9ca73528ee3aef96cc7b1784ecb44e29fdc0c194/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca73528ee3aef96cc7b1784ecb44e29fdc0c194/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=9ca73528ee3aef96cc7b1784ecb44e29fdc0c194", "patch": "@@ -79,6 +79,35 @@ pub(crate) fn generate_function(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     )\n }\n \n+pub(crate) fn generate_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let fn_name: ast::NameRef = ctx.find_node_at_offset()?;\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+    let module = ctx.sema.scope(call.syntax()).module();\n+    let ty = ctx.sema.type_of_expr(&call.receiver()?)?.as_adt()?;\n+\n+    let function_builder = FunctionBuilder::from_method_call(ctx, &call, &fn_name, module)?;\n+    let target = call.syntax().text_range();\n+\n+    acc.add(\n+        AssistId(\"generate_method\", AssistKind::Generate),\n+        format!(\"Generate `{}` method\", function_builder.fn_name),\n+        target,\n+        |builder| {\n+            let function_template = function_builder.render();\n+            builder.edit_file(function_template.file);\n+            let new_fn = format!(\n+                \"impl {} {{{}}}\",\n+                ty.name(ctx.sema.db),\n+                function_template.to_string(ctx.config.snippet_cap)\n+            );\n+            match ctx.config.snippet_cap {\n+                Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n+                None => builder.insert(function_template.insert_offset, new_fn),\n+            }\n+        },\n+    )\n+}\n+\n struct FunctionTemplate {\n     insert_offset: TextSize,\n     leading_ws: String,\n@@ -181,6 +210,70 @@ impl FunctionBuilder {\n         })\n     }\n \n+    fn from_method_call(\n+        ctx: &AssistContext,\n+        call: &ast::MethodCallExpr,\n+        name: &ast::NameRef,\n+        target_module: Option<hir::Module>,\n+    ) -> Option<Self> {\n+        let mut file = ctx.frange.file_id;\n+        let target = match &target_module {\n+            Some(target_module) => {\n+                let module_source = target_module.definition_source(ctx.db());\n+                let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n+                file = in_file;\n+                target\n+            }\n+            None => next_space_for_fn_after_method_call_site(call)?,\n+        };\n+        let needs_pub = false;\n+        let target_module = target_module.or_else(|| ctx.sema.scope(target.syntax()).module())?;\n+        let fn_name = make::name(&name.text());\n+        let (type_params, params) = method_args(ctx, target_module, call)?;\n+\n+        let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n+        let is_async = await_expr.is_some();\n+\n+        // should_render_snippet intends to express a rough level of confidence about\n+        // the correctness of the return type.\n+        //\n+        // If we are able to infer some return type, and that return type is not unit, we\n+        // don't want to render the snippet. The assumption here is in this situation the\n+        // return type is just as likely to be correct as any other part of the generated\n+        // function.\n+        //\n+        // In the case where the return type is inferred as unit it is likely that the\n+        // user does in fact intend for this generated function to return some non unit\n+        // type, but that the current state of their code doesn't allow that return type\n+        // to be accurately inferred.\n+        let (ret_ty, should_render_snippet) = {\n+            match ctx.sema.type_of_expr(&ast::Expr::MethodCallExpr(call.clone())) {\n+                Some(ty) if ty.is_unknown() || ty.is_unit() => (make::ty_unit(), true),\n+                Some(ty) => {\n+                    let rendered = ty.display_source_code(ctx.db(), target_module.into());\n+                    match rendered {\n+                        Ok(rendered) => (make::ty(&rendered), false),\n+                        Err(_) => (make::ty_unit(), true),\n+                    }\n+                }\n+                None => (make::ty_unit(), true),\n+            }\n+        };\n+        let ret_type = make::ret_type(ret_ty);\n+\n+        Some(Self {\n+            target,\n+            fn_name,\n+            type_params,\n+            params,\n+            ret_type,\n+            should_render_snippet,\n+            file,\n+            needs_pub,\n+            is_async,\n+        })\n+    }\n+\n     fn render(self) -> FunctionTemplate {\n         let placeholder_expr = make::ext::expr_todo();\n         let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n@@ -280,6 +373,40 @@ fn fn_args(\n     Some((None, make::param_list(None, params)))\n }\n \n+fn method_args(\n+    ctx: &AssistContext,\n+    target_module: hir::Module,\n+    call: &ast::MethodCallExpr,\n+) -> Option<(Option<ast::GenericParamList>, ast::ParamList)> {\n+    let mut arg_names = Vec::new();\n+    let mut arg_types = Vec::new();\n+    for arg in call.arg_list()?.args() {\n+        arg_names.push(match fn_arg_name(&arg) {\n+            Some(name) => name,\n+            None => String::from(\"arg\"),\n+        });\n+        arg_types.push(match fn_arg_type(ctx, target_module, &arg) {\n+            Some(ty) => {\n+                if ty.len() > 0 && ty.starts_with('&') {\n+                    if let Some((new_ty, _)) = useless_type_special_case(\"\", &ty[1..].to_owned()) {\n+                        new_ty\n+                    } else {\n+                        ty\n+                    }\n+                } else {\n+                    ty\n+                }\n+            }\n+            None => String::from(\"()\"),\n+        });\n+    }\n+    deduplicate_arg_names(&mut arg_names);\n+    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| {\n+        make::param(make::ext::simple_ident_pat(make::name(&name)).into(), make::ty(&ty))\n+    });\n+    Some((None, make::param_list(Some(make::self_param()), params)))\n+}\n+\n /// Makes duplicate argument names unique by appending incrementing numbers.\n ///\n /// ```\n@@ -368,6 +495,28 @@ fn next_space_for_fn_after_call_site(expr: &ast::CallExpr) -> Option<GeneratedFu\n     last_ancestor.map(GeneratedFunctionTarget::BehindItem)\n }\n \n+fn next_space_for_fn_after_method_call_site(\n+    expr: &ast::MethodCallExpr,\n+) -> Option<GeneratedFunctionTarget> {\n+    let mut ancestors = expr.syntax().ancestors().peekable();\n+    let mut last_ancestor: Option<SyntaxNode> = None;\n+    while let Some(next_ancestor) = ancestors.next() {\n+        match next_ancestor.kind() {\n+            SyntaxKind::SOURCE_FILE => {\n+                break;\n+            }\n+            SyntaxKind::ITEM_LIST => {\n+                if ancestors.peek().map(|a| a.kind()) == Some(SyntaxKind::MODULE) {\n+                    break;\n+                }\n+            }\n+            _ => {}\n+        }\n+        last_ancestor = Some(next_ancestor);\n+    }\n+    last_ancestor.map(GeneratedFunctionTarget::BehindItem)\n+}\n+\n fn next_space_for_fn_in_module(\n     db: &dyn hir::db::AstDatabase,\n     module_source: &hir::InFile<hir::ModuleSource>,"}, {"sha": "30b57ade14dcc2a58de2d54470732ea0a39bae79", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ca73528ee3aef96cc7b1784ecb44e29fdc0c194/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca73528ee3aef96cc7b1784ecb44e29fdc0c194/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=9ca73528ee3aef96cc7b1784ecb44e29fdc0c194", "patch": "@@ -151,6 +151,7 @@ mod handlers {\n             generate_enum_projection_method::generate_enum_try_into_method,\n             generate_from_impl_for_enum::generate_from_impl_for_enum,\n             generate_function::generate_function,\n+            generate_function::generate_method,\n             generate_getter::generate_getter,\n             generate_getter::generate_getter_mut,\n             generate_impl::generate_impl,"}, {"sha": "ec90be35a6ee92b78f0b91db60ccb1a104b4531e", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca73528ee3aef96cc7b1784ecb44e29fdc0c194/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca73528ee3aef96cc7b1784ecb44e29fdc0c194/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=9ca73528ee3aef96cc7b1784ecb44e29fdc0c194", "patch": "@@ -531,6 +531,10 @@ pub fn param(pat: ast::Pat, ty: ast::Type) -> ast::Param {\n     ast_from_text(&format!(\"fn f({}: {}) {{ }}\", pat, ty))\n }\n \n+pub fn self_param() -> ast::SelfParam {\n+    ast_from_text(&format!(\"fn f(&self) {{ }}\"))\n+}\n+\n pub fn ret_type(ty: ast::Type) -> ast::RetType {\n     ast_from_text(&format!(\"fn f() -> {} {{ }}\", ty))\n }"}]}