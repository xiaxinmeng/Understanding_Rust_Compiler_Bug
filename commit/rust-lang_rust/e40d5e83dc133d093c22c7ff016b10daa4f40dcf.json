{"sha": "e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "node_id": "C_kwDOAAsO6NoAKGU0MGQ1ZTgzZGMxMzNkMDkzYzIyYzdmZjAxNmIxMGRhYTRmNDBkY2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-03T12:37:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-03T12:37:16Z"}, "message": "Auto merge of #89862 - lcnr:path-generics-diagnostics, r=estebank\n\nrewrite error handling for unresolved inference vars\n\nPretty much completely rewrites `fn emit_inference_failure_err`.\n\nThis new setup should hopefully be easier to extend and is already a lot better when looking for generic arguments.\nBecause this is a rewrite there are still some parts which are lacking, these are tracked in #94483 and will be fixed in later PRs.\n\nr? `@estebank` `@petrochenkov`", "tree": {"sha": "dc2a28093b19836d6f14e25763b33904e9d12186", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc2a28093b19836d6f14e25763b33904e9d12186"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "html_url": "https://github.com/rust-lang/rust/commit/e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72f7e3144a386c820c188350092d2d93a74889b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/72f7e3144a386c820c188350092d2d93a74889b8", "html_url": "https://github.com/rust-lang/rust/commit/72f7e3144a386c820c188350092d2d93a74889b8"}, {"sha": "b343a466c650cd43d81b7fc98d3571eda64fe35b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b343a466c650cd43d81b7fc98d3571eda64fe35b", "html_url": "https://github.com/rust-lang/rust/commit/b343a466c650cd43d81b7fc98d3571eda64fe35b"}], "stats": {"total": 3613, "additions": 2132, "deletions": 1481}, "files": [{"sha": "7b5c377f7b4caa25ffd21921d538c5e877f23806", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 829, "deletions": 886, "changes": 1715, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,263 +1,22 @@\n use crate::infer::type_variable::TypeVariableOriginKind;\n-use crate::infer::{InferCtxt, Symbol};\n-use rustc_errors::{\n-    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-};\n+use crate::infer::InferCtxt;\n+use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Namespace};\n+use rustc_hir::def::{CtorOf, DefKind, Namespace};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, MatchSource, Pat};\n+use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, LocalSource};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::infer::unify_key::ConstVariableOriginKind;\n-use rustc_middle::ty::print::Print;\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, Const, DefIdTree, InferConst, Ty, TyCtxt, TypeFoldable, TypeFolder};\n-use rustc_span::symbol::kw;\n-use rustc_span::{sym, Span};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n+use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, InferConst};\n+use rustc_middle::ty::{Ty, TyCtxt, TypeckResults};\n+use rustc_span::symbol::{kw, Ident};\n+use rustc_span::{BytePos, Span};\n use std::borrow::Cow;\n-\n-struct FindHirNodeVisitor<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    target: GenericArg<'tcx>,\n-    target_span: Span,\n-    found_node_ty: Option<Ty<'tcx>>,\n-    found_local_pattern: Option<&'tcx Pat<'tcx>>,\n-    found_arg_pattern: Option<&'tcx Pat<'tcx>>,\n-    found_closure: Option<&'tcx Expr<'tcx>>,\n-    found_method_call: Option<&'tcx Expr<'tcx>>,\n-    found_exact_method_call: Option<&'tcx Expr<'tcx>>,\n-    found_for_loop_iter: Option<&'tcx Expr<'tcx>>,\n-    found_use_diagnostic: Option<UseDiagnostic<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>, target_span: Span) -> Self {\n-        Self {\n-            infcx,\n-            target,\n-            target_span,\n-            found_node_ty: None,\n-            found_local_pattern: None,\n-            found_arg_pattern: None,\n-            found_closure: None,\n-            found_method_call: None,\n-            found_exact_method_call: None,\n-            found_for_loop_iter: None,\n-            found_use_diagnostic: None,\n-        }\n-    }\n-\n-    fn node_type_opt(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n-        self.infcx.in_progress_typeck_results?.borrow().node_type_opt(hir_id)\n-    }\n-\n-    fn node_ty_contains_target(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n-        self.node_type_opt(hir_id).map(|ty| self.infcx.resolve_vars_if_possible(ty)).filter(|ty| {\n-            ty.walk().any(|inner| {\n-                inner == self.target\n-                    || match (inner.unpack(), self.target.unpack()) {\n-                        (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {\n-                            use ty::{Infer, TyVar};\n-                            match (inner_ty.kind(), target_ty.kind()) {\n-                                (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n-                                    .infcx\n-                                    .inner\n-                                    .borrow_mut()\n-                                    .type_variables()\n-                                    .sub_unified(a_vid, b_vid),\n-                                _ => false,\n-                            }\n-                        }\n-                        _ => false,\n-                    }\n-            })\n-        })\n-    }\n-\n-    /// Determine whether the expression, assumed to be the callee within a `Call`,\n-    /// corresponds to the `From::from` emitted in desugaring of the `?` operator.\n-    fn is_try_conversion(&self, callee: &Expr<'tcx>) -> bool {\n-        self.infcx\n-            .trait_def_from_hir_fn(callee.hir_id)\n-            .map_or(false, |def_id| self.infcx.is_try_conversion(callee.span, def_id))\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n-    type NestedFilter = nested_filter::OnlyBodies;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.infcx.tcx.hir()\n-    }\n-\n-    fn visit_local(&mut self, local: &'tcx Local<'tcx>) {\n-        if let (None, Some(ty)) =\n-            (self.found_local_pattern, self.node_ty_contains_target(local.hir_id))\n-        {\n-            self.found_local_pattern = Some(&*local.pat);\n-            self.found_node_ty = Some(ty);\n-        }\n-        intravisit::walk_local(self, local);\n-    }\n-\n-    fn visit_body(&mut self, body: &'tcx Body<'tcx>) {\n-        for param in body.params {\n-            if let (None, Some(ty)) =\n-                (self.found_arg_pattern, self.node_ty_contains_target(param.hir_id))\n-            {\n-                self.found_arg_pattern = Some(&*param.pat);\n-                self.found_node_ty = Some(ty);\n-            }\n-        }\n-        intravisit::walk_body(self, body);\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::Match(scrutinee, [_, arm], MatchSource::ForLoopDesugar) = expr.kind\n-            && let Some(pat) = arm.pat.for_loop_some()\n-            && let Some(ty) = self.node_ty_contains_target(pat.hir_id)\n-        {\n-            self.found_for_loop_iter = Some(scrutinee);\n-            self.found_node_ty = Some(ty);\n-            return;\n-        }\n-        if let ExprKind::MethodCall(segment, exprs, _) = expr.kind\n-            && segment.ident.span == self.target_span\n-            && Some(self.target) == self.infcx.in_progress_typeck_results.and_then(|typeck_results| {\n-                typeck_results\n-                    .borrow()\n-                    .node_type_opt(exprs.first().unwrap().hir_id)\n-                    .map(Into::into)\n-            })\n-        {\n-            self.found_exact_method_call = Some(&expr);\n-            return;\n-        }\n-\n-        // FIXME(const_generics): Currently, any uninferred `const` generics arguments\n-        // are handled specially, but instead they should be handled in `annotate_method_call`,\n-        // which currently doesn't work because this evaluates to `false` for const arguments.\n-        // See https://github.com/rust-lang/rust/pull/77758 for more details.\n-        if let Some(ty) = self.node_ty_contains_target(expr.hir_id) {\n-            match expr.kind {\n-                ExprKind::Closure(..) => self.found_closure = Some(&expr),\n-                ExprKind::MethodCall(..) => self.found_method_call = Some(&expr),\n-\n-                // If the given expression falls within the target span and is a\n-                // `From::from(e)` call emitted during desugaring of the `?` operator,\n-                // extract the types inferred before and after the call\n-                ExprKind::Call(callee, [arg])\n-                    if self.target_span.contains(expr.span)\n-                        && self.found_use_diagnostic.is_none()\n-                        && self.is_try_conversion(callee) =>\n-                {\n-                    self.found_use_diagnostic = self.node_type_opt(arg.hir_id).map(|pre_ty| {\n-                        UseDiagnostic::TryConversion { pre_ty, post_ty: ty, span: callee.span }\n-                    });\n-                }\n-                _ => {}\n-            }\n-        }\n-        intravisit::walk_expr(self, expr);\n-    }\n-}\n-\n-/// An observation about the use site of a type to be emitted as an additional\n-/// note in an inference failure error.\n-enum UseDiagnostic<'tcx> {\n-    /// Records the types inferred before and after `From::from` is called on the\n-    /// error value within the desugaring of the `?` operator.\n-    TryConversion { pre_ty: Ty<'tcx>, post_ty: Ty<'tcx>, span: Span },\n-}\n-\n-impl UseDiagnostic<'_> {\n-    /// Return a descriptor of the value at the use site\n-    fn descr(&self) -> &'static str {\n-        match self {\n-            Self::TryConversion { .. } => \"error for `?` operator\",\n-        }\n-    }\n-\n-    /// Return a descriptor of the type at the use site\n-    fn type_descr(&self) -> &'static str {\n-        match self {\n-            Self::TryConversion { .. } => \"error type for `?` operator\",\n-        }\n-    }\n-\n-    fn applies_to(&self, span: Span) -> bool {\n-        match *self {\n-            // In some cases the span for an inference failure due to try\n-            // conversion contains the antecedent expression as well as the `?`\n-            Self::TryConversion { span: s, .. } => span.contains(s) && span.hi() == s.hi(),\n-        }\n-    }\n-\n-    fn attach_note(&self, err: &mut Diagnostic) {\n-        match *self {\n-            Self::TryConversion { pre_ty, post_ty, .. } => {\n-                let intro = \"`?` implicitly converts the error value\";\n-\n-                let msg = match (pre_ty.is_ty_infer(), post_ty.is_ty_infer()) {\n-                    (true, true) => format!(\"{} using the `From` trait\", intro),\n-                    (false, true) => {\n-                        format!(\"{} into a type implementing `From<{}>`\", intro, pre_ty)\n-                    }\n-                    (true, false) => {\n-                        format!(\"{} into `{}` using the `From` trait\", intro, post_ty)\n-                    }\n-                    (false, false) => {\n-                        format!(\n-                            \"{} into `{}` using its implementation of `From<{}>`\",\n-                            intro, post_ty, pre_ty\n-                        )\n-                    }\n-                };\n-\n-                err.note(&msg);\n-            }\n-        }\n-    }\n-}\n-\n-/// Suggest giving an appropriate return type to a closure expression.\n-fn closure_return_type_suggestion(\n-    err: &mut Diagnostic,\n-    output: &FnRetTy<'_>,\n-    body: &Body<'_>,\n-    ret: &str,\n-) {\n-    let (arrow, post) = match output {\n-        FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n-        _ => (\"\", \"\"),\n-    };\n-    let suggestion = match body.value.kind {\n-        ExprKind::Block(..) => vec![(output.span(), format!(\"{}{}{}\", arrow, ret, post))],\n-        _ => vec![\n-            (output.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n-            (body.value.span.shrink_to_hi(), \" }\".to_string()),\n-        ],\n-    };\n-    err.multipart_suggestion(\n-        \"give this closure an explicit return type without `_` placeholders\",\n-        suggestion,\n-        Applicability::HasPlaceholders,\n-    );\n-}\n-\n-/// Given a closure signature, return a `String` containing a list of all its argument types.\n-fn closure_args(fn_sig: &ty::PolyFnSig<'_>) -> String {\n-    fn_sig\n-        .inputs()\n-        .skip_binder()\n-        .iter()\n-        .next()\n-        .map(|args| {\n-            args.tuple_fields().iter().map(|arg| arg.to_string()).collect::<Vec<_>>().join(\", \")\n-        })\n-        .unwrap_or_default()\n-}\n+use std::iter;\n \n pub enum TypeAnnotationNeeded {\n     /// ```compile_fail,E0282\n@@ -296,62 +55,67 @@ pub struct InferenceDiagnosticsData {\n \n /// Data on the parent definition where a generic argument was declared.\n pub struct InferenceDiagnosticsParentData {\n-    pub prefix: &'static str,\n-    pub name: String,\n-    pub def_id: DefId,\n+    prefix: &'static str,\n+    name: String,\n }\n \n pub enum UnderspecifiedArgKind {\n     Type { prefix: Cow<'static, str> },\n     Const { is_parameter: bool },\n }\n \n-impl UnderspecifiedArgKind {\n-    fn descr(&self) -> &'static str {\n-        match self {\n-            Self::Type { .. } => \"type\",\n-            Self::Const { .. } => \"const\",\n-        }\n-    }\n-}\n-\n impl InferenceDiagnosticsData {\n     /// Generate a label for a generic argument which can't be inferred. When not\n     /// much is known about the argument, `use_diag` may be used to describe the\n     /// labeled value.\n-    fn cannot_infer_msg(&self, use_diag: Option<&UseDiagnostic<'_>>) -> String {\n+    fn cannot_infer_msg(&self) -> String {\n         if self.name == \"_\" && matches!(self.kind, UnderspecifiedArgKind::Type { .. }) {\n-            if let Some(use_diag) = use_diag {\n-                return format!(\"cannot infer type of {}\", use_diag.descr());\n-            }\n-\n             return \"cannot infer type\".to_string();\n         }\n \n-        let suffix = match (&self.parent, use_diag) {\n-            (Some(parent), _) => format!(\" declared on the {} `{}`\", parent.prefix, parent.name),\n-            (None, Some(use_diag)) => format!(\" in {}\", use_diag.type_descr()),\n-            (None, None) => String::new(),\n+        let suffix = match &self.parent {\n+            Some(parent) => parent.suffix_string(),\n+            None => String::new(),\n         };\n \n         // For example: \"cannot infer type for type parameter `T`\"\n         format!(\"cannot infer {} `{}`{}\", self.kind.prefix_string(), self.name, suffix)\n     }\n+\n+    fn where_x_is_specified(&self, in_type: Ty<'_>) -> String {\n+        if in_type.is_ty_infer() {\n+            String::new()\n+        } else if self.name == \"_\" {\n+            // FIXME: Consider specializing this message if there is a single `_`\n+            // in the type.\n+            \", where the placeholders `_` are specified\".to_string()\n+        } else {\n+            format!(\", where the {} `{}` is specified\", self.kind.prefix_string(), self.name)\n+        }\n+    }\n }\n \n impl InferenceDiagnosticsParentData {\n-    fn for_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<InferenceDiagnosticsParentData> {\n-        let parent_def_id = tcx.parent(def_id);\n-\n+    fn for_parent_def_id(\n+        tcx: TyCtxt<'_>,\n+        parent_def_id: DefId,\n+    ) -> Option<InferenceDiagnosticsParentData> {\n         let parent_name =\n             tcx.def_key(parent_def_id).disambiguated_data.data.get_opt_name()?.to_string();\n \n         Some(InferenceDiagnosticsParentData {\n             prefix: tcx.def_kind(parent_def_id).descr(parent_def_id),\n             name: parent_name,\n-            def_id: parent_def_id,\n         })\n     }\n+\n+    fn for_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<InferenceDiagnosticsParentData> {\n+        Self::for_parent_def_id(tcx, tcx.parent(def_id))\n+    }\n+\n+    fn suffix_string(&self) -> String {\n+        format!(\" declared on the {} `{}`\", self.prefix, self.name)\n+    }\n }\n \n impl UnderspecifiedArgKind {\n@@ -364,6 +128,80 @@ impl UnderspecifiedArgKind {\n     }\n }\n \n+fn fmt_printer<'a, 'tcx>(infcx: &'a InferCtxt<'_, 'tcx>, ns: Namespace) -> FmtPrinter<'a, 'tcx> {\n+    let mut printer = FmtPrinter::new(infcx.tcx, ns);\n+    let ty_getter = move |ty_vid| {\n+        if infcx.probe_ty_var(ty_vid).is_ok() {\n+            warn!(\"resolved ty var in error message\");\n+        }\n+        if let TypeVariableOriginKind::TypeParameterDefinition(name, _) =\n+            infcx.inner.borrow_mut().type_variables().var_origin(ty_vid).kind\n+        {\n+            Some(name.to_string())\n+        } else {\n+            None\n+        }\n+    };\n+    printer.ty_infer_name_resolver = Some(Box::new(ty_getter));\n+    let const_getter = move |ct_vid| {\n+        if infcx.probe_const_var(ct_vid).is_ok() {\n+            warn!(\"resolved const var in error message\");\n+        }\n+        if let ConstVariableOriginKind::ConstParameterDefinition(name, _) =\n+            infcx.inner.borrow_mut().const_unification_table().probe_value(ct_vid).origin.kind\n+        {\n+            return Some(name.to_string());\n+        } else {\n+            None\n+        }\n+    };\n+    printer.const_infer_name_resolver = Some(Box::new(const_getter));\n+    printer\n+}\n+\n+fn ty_to_string<'tcx>(infcx: &InferCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> String {\n+    let printer = fmt_printer(infcx, Namespace::TypeNS);\n+    let ty = infcx.resolve_vars_if_possible(ty);\n+    match ty.kind() {\n+        // We don't want the regular output for `fn`s because it includes its path in\n+        // invalid pseudo-syntax, we want the `fn`-pointer output instead.\n+        ty::FnDef(..) => ty.fn_sig(infcx.tcx).print(printer).unwrap().into_buffer(),\n+        // FIXME: The same thing for closures, but this only works when the closure\n+        // does not capture anything.\n+        //\n+        // We do have to hide the `extern \"rust-call\"` ABI in that case though,\n+        // which is too much of a bother for now.\n+        _ => ty.print(printer).unwrap().into_buffer(),\n+    }\n+}\n+\n+/// We don't want to directly use `ty_to_string` for closures as their type isn't really\n+/// something users are familar with. Directly printing the `fn_sig` of closures also\n+/// doesn't work as they actually use the \"rust-call\" API.\n+fn closure_as_fn_str<'tcx>(infcx: &InferCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> String {\n+    let ty::Closure(_, substs) = ty.kind() else { unreachable!() };\n+    let fn_sig = substs.as_closure().sig();\n+    let args = fn_sig\n+        .inputs()\n+        .skip_binder()\n+        .iter()\n+        .next()\n+        .map(|args| {\n+            args.tuple_fields()\n+                .iter()\n+                .map(|arg| ty_to_string(infcx, arg))\n+                .collect::<Vec<_>>()\n+                .join(\", \")\n+        })\n+        .unwrap_or_default();\n+    let ret = if fn_sig.output().skip_binder().is_unit() {\n+        String::new()\n+    } else {\n+        format!(\" -> {}\", ty_to_string(infcx, fn_sig.output().skip_binder()))\n+    };\n+    format!(\"fn({}){}\", args, ret)\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Extracts data used by diagnostic for either types or constants\n     /// which were stuck during inference.\n@@ -400,562 +238,239 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if let Some(highlight) = highlight {\n                     printer.region_highlight_mode = highlight;\n                 }\n-                let name = ty.print(printer).unwrap().into_buffer();\n                 InferenceDiagnosticsData {\n-                    name,\n+                    name: ty.print(printer).unwrap().into_buffer(),\n                     span: None,\n                     kind: UnderspecifiedArgKind::Type { prefix: ty.prefix_string(self.tcx) },\n                     parent: None,\n                 }\n             }\n             GenericArgKind::Const(ct) => {\n-                match ct.val() {\n-                    ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                        let origin = self\n-                            .inner\n-                            .borrow_mut()\n-                            .const_unification_table()\n-                            .probe_value(vid)\n-                            .origin;\n-                        if let ConstVariableOriginKind::ConstParameterDefinition(name, def_id) =\n-                            origin.kind\n-                        {\n-                            return InferenceDiagnosticsData {\n-                                name: name.to_string(),\n-                                span: Some(origin.span),\n-                                kind: UnderspecifiedArgKind::Const { is_parameter: true },\n-                                parent: InferenceDiagnosticsParentData::for_def_id(\n-                                    self.tcx, def_id,\n-                                ),\n-                            };\n-                        }\n-\n-                        debug_assert!(!origin.span.is_dummy());\n-                        let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::ValueNS);\n-                        if let Some(highlight) = highlight {\n-                            printer.region_highlight_mode = highlight;\n-                        }\n-                        let name = ct.print(printer).unwrap().into_buffer();\n-                        InferenceDiagnosticsData {\n-                            name,\n+                if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val() {\n+                    let origin =\n+                        self.inner.borrow_mut().const_unification_table().probe_value(vid).origin;\n+                    if let ConstVariableOriginKind::ConstParameterDefinition(name, def_id) =\n+                        origin.kind\n+                    {\n+                        return InferenceDiagnosticsData {\n+                            name: name.to_string(),\n                             span: Some(origin.span),\n-                            kind: UnderspecifiedArgKind::Const { is_parameter: false },\n-                            parent: None,\n-                        }\n+                            kind: UnderspecifiedArgKind::Const { is_parameter: true },\n+                            parent: InferenceDiagnosticsParentData::for_def_id(self.tcx, def_id),\n+                        };\n                     }\n-                    ty::ConstKind::Unevaluated(ty::Unevaluated { substs, .. }) => {\n-                        assert!(substs.has_infer_types_or_consts());\n-\n-                        // FIXME: We only use the first inference variable we encounter in\n-                        // `substs` here, this gives insufficiently informative diagnostics\n-                        // in case there are multiple inference variables\n-                        for s in substs.iter() {\n-                            match s.unpack() {\n-                                GenericArgKind::Type(t) => match t.kind() {\n-                                    ty::Infer(_) => {\n-                                        return self.extract_inference_diagnostics_data(s, None);\n-                                    }\n-                                    _ => {}\n-                                },\n-                                GenericArgKind::Const(c) => match c.val() {\n-                                    ty::ConstKind::Infer(InferConst::Var(_)) => {\n-                                        return self.extract_inference_diagnostics_data(s, None);\n-                                    }\n-                                    _ => {}\n-                                },\n-                                _ => {}\n-                            }\n-                        }\n-                        bug!(\n-                            \"expected an inference variable in substs of unevaluated const {:?}\",\n-                            ct\n-                        );\n+\n+                    debug_assert!(!origin.span.is_dummy());\n+                    let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::ValueNS);\n+                    if let Some(highlight) = highlight {\n+                        printer.region_highlight_mode = highlight;\n+                    }\n+                    InferenceDiagnosticsData {\n+                        name: ct.print(printer).unwrap().into_buffer(),\n+                        span: Some(origin.span),\n+                        kind: UnderspecifiedArgKind::Const { is_parameter: false },\n+                        parent: None,\n+                    }\n+                } else {\n+                    // If we end up here the `FindInferSourceVisitor`\n+                    // won't work, as its expected argument isn't an inference variable.\n+                    //\n+                    // FIXME: Ideally we should look into the generic constant\n+                    // to figure out which inference var is actually unresolved so that\n+                    // this path is unreachable.\n+                    let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::ValueNS);\n+                    if let Some(highlight) = highlight {\n+                        printer.region_highlight_mode = highlight;\n                     }\n-                    _ => {\n-                        bug!(\"unexpect const: {:?}\", ct);\n+                    InferenceDiagnosticsData {\n+                        name: ct.print(printer).unwrap().into_buffer(),\n+                        span: None,\n+                        kind: UnderspecifiedArgKind::Const { is_parameter: false },\n+                        parent: None,\n                     }\n                 }\n             }\n             GenericArgKind::Lifetime(_) => bug!(\"unexpected lifetime\"),\n         }\n     }\n \n+    /// Used as a fallback in [InferCtxt::emit_inference_failure_err]\n+    /// in case we weren't able to get a better error.\n+    fn bad_inference_failure_err(\n+        &self,\n+        span: Span,\n+        arg_data: InferenceDiagnosticsData,\n+        error_code: TypeAnnotationNeeded,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        let error_code = error_code.into();\n+        let mut err = self.tcx.sess.struct_span_err_with_code(\n+            span,\n+            &format!(\"type annotations needed\"),\n+            error_code,\n+        );\n+        err.span_label(span, arg_data.cannot_infer_msg());\n+        err\n+    }\n+\n     pub fn emit_inference_failure_err(\n         &self,\n         body_id: Option<hir::BodyId>,\n         span: Span,\n         arg: GenericArg<'tcx>,\n-        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        // FIXME(#94483): Either use this or remove it.\n+        _impl_candidates: Vec<ty::TraitRef<'tcx>>,\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let arg = self.resolve_vars_if_possible(arg);\n         let arg_data = self.extract_inference_diagnostics_data(arg, None);\n \n-        let mut local_visitor = FindHirNodeVisitor::new(&self, arg, span);\n-        let ty_to_string = |ty: Ty<'tcx>| -> String {\n-            let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS);\n-            let ty_getter = move |ty_vid| {\n-                if let TypeVariableOriginKind::TypeParameterDefinition(name, _) =\n-                    self.inner.borrow_mut().type_variables().var_origin(ty_vid).kind\n-                {\n-                    Some(name.to_string())\n-                } else {\n-                    None\n-                }\n-            };\n-            printer.ty_infer_name_resolver = Some(Box::new(ty_getter));\n-            let const_getter = move |ct_vid| {\n-                if let ConstVariableOriginKind::ConstParameterDefinition(name, _) = self\n-                    .inner\n-                    .borrow_mut()\n-                    .const_unification_table()\n-                    .probe_value(ct_vid)\n-                    .origin\n-                    .kind\n-                {\n-                    return Some(name.to_string());\n-                } else {\n-                    None\n-                }\n-            };\n-            printer.const_infer_name_resolver = Some(Box::new(const_getter));\n-\n-            if let ty::FnDef(..) = ty.kind() {\n-                // We don't want the regular output for `fn`s because it includes its path in\n-                // invalid pseudo-syntax, we want the `fn`-pointer output instead.\n-                ty.fn_sig(self.tcx).print(printer).unwrap().into_buffer()\n-            } else {\n-                ty.print(printer).unwrap().into_buffer()\n-            }\n+        let Some(typeck_results) = self.in_progress_typeck_results else {\n+            // If we don't have any typeck results we're outside\n+            // of a body, so we won't be able to get better info\n+            // here.\n+            return self.bad_inference_failure_err(span, arg_data, error_code);\n         };\n+        let typeck_results = typeck_results.borrow();\n+        let typeck_results = &typeck_results;\n \n+        let mut local_visitor = FindInferSourceVisitor::new(&self, typeck_results, arg);\n         if let Some(body_id) = body_id {\n             let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n+            debug!(?expr);\n             local_visitor.visit_expr(expr);\n         }\n-        let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n-            pattern.span\n-        } else if let Some(span) = arg_data.span {\n-            // `span` here lets us point at `sum` instead of the entire right hand side expr:\n-            // error[E0282]: type annotations needed\n-            //  --> file2.rs:3:15\n-            //   |\n-            // 3 |     let _ = x.sum() as f64;\n-            //   |               ^^^ cannot infer type for `S`\n-            span\n-        } else if let Some(ExprKind::MethodCall(segment, ..)) =\n-            local_visitor.found_method_call.map(|e| &e.kind)\n-        {\n-            // Point at the call instead of the whole expression:\n-            // error[E0284]: type annotations needed\n-            //  --> file.rs:2:5\n-            //   |\n-            // 2 |     [Ok(2)].into_iter().collect()?;\n-            //   |                         ^^^^^^^ cannot infer type\n-            //   |\n-            //   = note: cannot resolve `<_ as std::ops::Try>::Ok == _`\n-            if span.contains(segment.ident.span) { segment.ident.span } else { span }\n-        } else {\n-            span\n-        };\n \n-        let is_named_and_not_impl_trait =\n-            |ty: Ty<'_>| &ty.to_string() != \"_\" && !ty.is_impl_trait();\n-\n-        let ty_msg = match (local_visitor.found_node_ty, local_visitor.found_exact_method_call) {\n-            (_, Some(_)) => String::new(),\n-            (Some(ty), _) if ty.is_closure() => {\n-                let ty::Closure(_, substs) = *ty.kind() else { unreachable!() };\n-                let fn_sig = substs.as_closure().sig();\n-                let args = closure_args(&fn_sig);\n-                let ret = fn_sig.output().skip_binder().to_string();\n-                format!(\" for the closure `fn({}) -> {}`\", args, ret)\n-            }\n-            (Some(ty), _) if is_named_and_not_impl_trait(ty) => {\n-                let ty = ty_to_string(ty);\n-                format!(\" for `{}`\", ty)\n-            }\n-            _ => String::new(),\n+        let Some(InferSource { span, kind }) = local_visitor.infer_source else {\n+            return self.bad_inference_failure_err(span, arg_data, error_code)\n         };\n \n-        // When `arg_data.name` corresponds to a type argument, show the path of the full type we're\n-        // trying to infer. In the following example, `ty_msg` contains\n-        // \" for `std::result::Result<i32, E>`\":\n-        // ```\n-        // error[E0282]: type annotations needed for `std::result::Result<i32, E>`\n-        //  --> file.rs:L:CC\n-        //   |\n-        // L |     let b = Ok(4);\n-        //   |         -   ^^ cannot infer type for `E` in `std::result::Result<i32, E>`\n-        //   |         |\n-        //   |         consider giving `b` the explicit type `std::result::Result<i32, E>`, where\n-        //   |         the type parameter `E` is specified\n-        // ```\n         let error_code = error_code.into();\n         let mut err = self.tcx.sess.struct_span_err_with_code(\n-            err_span,\n-            &format!(\"type annotations needed{}\", ty_msg),\n+            span,\n+            &format!(\"type annotations needed{}\", kind.ty_msg(self)),\n             error_code,\n         );\n-\n-        let use_diag = local_visitor.found_use_diagnostic.as_ref();\n-        if let Some(use_diag) = use_diag && use_diag.applies_to(err_span) {\n-            use_diag.attach_note(&mut err);\n-        }\n-\n-        let param_type = arg_data.kind.descr();\n-        let suffix = match local_visitor.found_node_ty {\n-            Some(ty) if ty.is_closure() => {\n-                let ty::Closure(_, substs) = *ty.kind() else { unreachable!() };\n-                let fn_sig = substs.as_closure().sig();\n-                let ret = fn_sig.output().skip_binder().to_string();\n-\n-                let closure_decl_and_body_id =\n-                    local_visitor.found_closure.and_then(|closure| match &closure.kind {\n-                        ExprKind::Closure(_, decl, body_id, ..) => Some((decl, *body_id)),\n-                        _ => None,\n-                    });\n-\n-                if let Some((decl, body_id)) = closure_decl_and_body_id {\n-                    closure_return_type_suggestion(\n-                        &mut err,\n-                        &decl.output,\n-                        self.tcx.hir().body(body_id),\n-                        &ret,\n-                    );\n-                    // We don't want to give the other suggestions when the problem is the\n-                    // closure return type.\n-                    err.span_label(\n-                        span,\n-                        arg_data.cannot_infer_msg(use_diag.filter(|d| d.applies_to(span))),\n-                    );\n-                    return err;\n-                }\n-\n-                // This shouldn't be reachable, but just in case we leave a reasonable fallback.\n-                let args = closure_args(&fn_sig);\n-                // This suggestion is incomplete, as the user will get further type inference\n-                // errors due to the `_` placeholders and the introduction of `Box`, but it does\n-                // nudge them in the right direction.\n-                format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n+        match kind {\n+            InferSourceKind::LetBinding { insert_span, pattern_name, ty } => {\n+                let suggestion_msg = if let Some(name) = pattern_name {\n+                    format!(\n+                        \"consider giving `{}` an explicit type{}\",\n+                        name,\n+                        arg_data.where_x_is_specified(ty)\n+                    )\n+                } else {\n+                    format!(\n+                        \"consider giving this pattern a type{}\",\n+                        arg_data.where_x_is_specified(ty)\n+                    )\n+                };\n+                err.span_suggestion_verbose(\n+                    insert_span,\n+                    &suggestion_msg,\n+                    format!(\": {}\", ty_to_string(self, ty)),\n+                    Applicability::HasPlaceholders,\n+                );\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) && arg_data.name == \"_\" => {\n-                let ty = ty_to_string(ty);\n-                format!(\"the explicit type `{}`, with the {} parameters specified\", ty, param_type)\n+            InferSourceKind::ClosureArg { insert_span, ty } => {\n+                err.span_suggestion_verbose(\n+                    insert_span,\n+                    &format!(\n+                        \"consider giving this closure parameter an explicit type{}\",\n+                        arg_data.where_x_is_specified(ty)\n+                    ),\n+                    format!(\": {}\", ty_to_string(self, ty)),\n+                    Applicability::HasPlaceholders,\n+                );\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != arg_data.name => {\n-                let ty = ResolvedTypeParamEraser::new(self.tcx).fold_ty(ty);\n-                let ty = ErrTypeParamEraser(self.tcx).fold_ty(ty);\n-                let ty = ty_to_string(ty);\n-                format!(\n-                    \"the explicit type `{}`, where the {} parameter `{}` is specified\",\n-                    ty, param_type, arg_data.name,\n-                )\n+            InferSourceKind::GenericArg {\n+                insert_span,\n+                argument_index,\n+                generics_def_id,\n+                def_id: _,\n+                generic_args,\n+            } => {\n+                let generics = self.tcx.generics_of(generics_def_id);\n+                let is_type = matches!(arg.unpack(), GenericArgKind::Type(_));\n+\n+                let cannot_infer_msg = format!(\n+                    \"cannot infer {} of the {} parameter `{}`{}\",\n+                    if is_type { \"type\" } else { \"the value\" },\n+                    if is_type { \"type\" } else { \"const\" },\n+                    generics.params[argument_index].name,\n+                    // We use the `generics_def_id` here, as even when suggesting `None::<T>`,\n+                    // the type parameter `T` was still declared on the enum, not on the\n+                    // variant.\n+                    InferenceDiagnosticsParentData::for_parent_def_id(self.tcx, generics_def_id)\n+                        .map_or(String::new(), |parent| parent.suffix_string()),\n+                );\n+\n+                err.span_label(span, cannot_infer_msg);\n+\n+                let printer = fmt_printer(self, Namespace::TypeNS);\n+                let args = printer.comma_sep(generic_args.iter().copied()).unwrap().into_buffer();\n+                err.span_suggestion_verbose(\n+                    insert_span,\n+                    &format!(\"consider specifying the generic argument{}\", pluralize!(args.len()),),\n+                    format!(\"::<{}>\", args),\n+                    Applicability::HasPlaceholders,\n+                );\n             }\n-            _ => \"a type\".to_string(),\n-        };\n+            InferSourceKind::FullyQualifiedMethodCall { receiver, successor, substs, def_id } => {\n+                let printer = fmt_printer(self, Namespace::ValueNS);\n+                let def_path = printer.print_def_path(def_id, substs).unwrap().into_buffer();\n+\n+                // We only care about whether we have to add `&` or `&mut ` for now.\n+                // This is the case if the last adjustment is a borrow and the\n+                // first adjustment was not a builtin deref.\n+                let adjustment = match typeck_results.expr_adjustments(receiver) {\n+                    [\n+                        Adjustment { kind: Adjust::Deref(None), target: _ },\n+                        ..,\n+                        Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), target: _ },\n+                    ] => \"\",\n+                    [\n+                        ..,\n+                        Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mut_)), target: _ },\n+                    ] => match mut_ {\n+                        AutoBorrowMutability::Mut { .. } => \"&mut \",\n+                        AutoBorrowMutability::Not => \"&\",\n+                    },\n+                    _ => \"\",\n+                };\n \n-        if let Some(e) = local_visitor.found_exact_method_call {\n-            if let ExprKind::MethodCall(segment, ..) = &e.kind {\n-                // Suggest specifying type params or point out the return type of the call:\n-                //\n-                // error[E0282]: type annotations needed\n-                //   --> $DIR/type-annotations-needed-expr.rs:2:39\n-                //    |\n-                // LL |     let _ = x.into_iter().sum() as f64;\n-                //    |                           ^^^\n-                //    |                           |\n-                //    |                           cannot infer type for `S`\n-                //    |                           help: consider specifying the type argument in\n-                //    |                           the method call: `sum::<S>`\n-                //    |\n-                //    = note: type must be known at this point\n-                //\n-                // or\n-                //\n-                // error[E0282]: type annotations needed\n-                //   --> $DIR/issue-65611.rs:59:20\n-                //    |\n-                // LL |     let x = buffer.last().unwrap().0.clone();\n-                //    |             -------^^^^--\n-                //    |             |      |\n-                //    |             |      cannot infer type for `T`\n-                //    |             this method call resolves to `std::option::Option<&T>`\n-                //    |\n-                //    = note: type must be known at this point\n-                self.annotate_method_call(segment, e, &mut err);\n-            }\n-        } else if let Some(pattern) = local_visitor.found_arg_pattern {\n-            // We don't want to show the default label for closures.\n-            //\n-            // So, before clearing, the output would look something like this:\n-            // ```\n-            // let x = |_| {  };\n-            //          -  ^^^^ cannot infer type for `[_; 0]`\n-            //          |\n-            //          consider giving this closure parameter a type\n-            // ```\n-            //\n-            // After clearing, it looks something like this:\n-            // ```\n-            // let x = |_| {  };\n-            //          ^ consider giving this closure parameter the type `[_; 0]`\n-            //            with the type parameter `_` specified\n-            // ```\n-            err.span_label(\n-                pattern.span,\n-                format!(\"consider giving this closure parameter {}\", suffix),\n-            );\n-        } else if let Some(pattern) = local_visitor.found_local_pattern {\n-            let msg = if let Some(simple_ident) = pattern.simple_ident() {\n-                match pattern.span.desugaring_kind() {\n-                    None => format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    Some(_) => format!(\"this needs {}\", suffix),\n-                }\n-            } else {\n-                format!(\"consider giving this pattern {}\", suffix)\n-            };\n-            err.span_label(pattern.span, msg);\n-        } else if let Some(e) = local_visitor.found_method_call {\n-            if let ExprKind::MethodCall(segment, exprs, _) = &e.kind {\n-                // Suggest impl candidates:\n-                //\n-                // error[E0283]: type annotations needed\n-                //   --> $DIR/E0283.rs:35:24\n-                //    |\n-                // LL |     let bar = foo_impl.into() * 1u32;\n-                //    |               ---------^^^^--\n-                //    |               |        |\n-                //    |               |        cannot infer type for type parameter `T` declared on the trait `Into`\n-                //    |               this method call resolves to `T`\n-                //    |               help: specify type like: `<Impl as Into<u32>>::into(foo_impl)`\n-                //    |\n-                //    = note: cannot satisfy `Impl: Into<_>`\n-                debug!(?segment);\n-                if !impl_candidates.is_empty() && e.span.contains(span)\n-                    && let Some(expr) = exprs.first()\n-                    && let ExprKind::Path(hir::QPath::Resolved(_, path)) = expr.kind\n-                    && let [_] = path.segments\n-                {\n-                    let mut eraser = TypeParamEraser(self.tcx);\n-                    let candidate_len = impl_candidates.len();\n-                    let mut suggestions: Vec<_> = impl_candidates.iter().filter_map(|candidate| {\n-                        let trait_item = self.tcx\n-                            .associated_items(candidate.def_id)\n-                            .find_by_name_and_kind(\n-                                self.tcx,\n-                                segment.ident,\n-                                ty::AssocKind::Fn,\n-                                candidate.def_id\n-                            );\n-                        if trait_item.is_none() {\n-                            return None;\n-                        }\n-                        let prefix = if let Some(trait_item) = trait_item\n-                            && let Some(trait_m) = trait_item.def_id.as_local()\n-                            && let hir::TraitItemKind::Fn(fn_, _) = &self.tcx.hir().trait_item(hir::TraitItemId { def_id: trait_m }).kind\n-                        {\n-                            match fn_.decl.implicit_self {\n-                                hir::ImplicitSelfKind::ImmRef => \"&\",\n-                                hir::ImplicitSelfKind::MutRef => \"&mut \",\n-                                _ => \"\",\n-                            }\n-                        } else {\n-                            \"\"\n-                        };\n-                        let candidate = candidate.super_fold_with(&mut eraser);\n-                        Some(vec![\n-                            (expr.span.shrink_to_lo(), format!(\"{}::{}({}\", candidate, segment.ident, prefix)),\n-                            if exprs.len() == 1 {\n-                                (expr.span.shrink_to_hi().with_hi(e.span.hi()), \")\".to_string())\n-                            } else {\n-                                (expr.span.shrink_to_hi().with_hi(exprs[1].span.lo()), \", \".to_string())\n-                            },\n-                        ])\n-                    }).collect();\n-                    suggestions.sort_by(|a, b| a[0].1.cmp(&b[0].1));\n-                    if !suggestions.is_empty() {\n-                        err.multipart_suggestions(\n-                            &format!(\n-                                \"use the fully qualified path for the potential candidate{}\",\n-                                pluralize!(candidate_len),\n-                            ),\n-                            suggestions.into_iter(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-                // Suggest specifying type params or point out the return type of the call:\n-                //\n-                // error[E0282]: type annotations needed\n-                //   --> $DIR/type-annotations-needed-expr.rs:2:39\n-                //    |\n-                // LL |     let _ = x.into_iter().sum() as f64;\n-                //    |                           ^^^\n-                //    |                           |\n-                //    |                           cannot infer type for `S`\n-                //    |                           help: consider specifying the type argument in\n-                //    |                           the method call: `sum::<S>`\n-                //    |\n-                //    = note: type must be known at this point\n-                //\n-                // or\n-                //\n-                // error[E0282]: type annotations needed\n-                //   --> $DIR/issue-65611.rs:59:20\n-                //    |\n-                // LL |     let x = buffer.last().unwrap().0.clone();\n-                //    |             -------^^^^--\n-                //    |             |      |\n-                //    |             |      cannot infer type for `T`\n-                //    |             this method call resolves to `std::option::Option<&T>`\n-                //    |\n-                //    = note: type must be known at this point\n-                self.annotate_method_call(segment, e, &mut err);\n+                let suggestion = vec![\n+                    (receiver.span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n+                    (receiver.span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n+                ];\n+                err.multipart_suggestion_verbose(\n+                    \"try using a fully qualified path to specify the expected types\",\n+                    suggestion,\n+                    Applicability::HasPlaceholders,\n+                );\n             }\n-        } else if let Some(scrutinee) = local_visitor.found_for_loop_iter {\n-            err.span_label(\n-                scrutinee.span,\n-                \"the element type for this iterator is not specified\".to_string(),\n-            );\n-        }\n-        // Instead of the following:\n-        // error[E0282]: type annotations needed\n-        //  --> file2.rs:3:15\n-        //   |\n-        // 3 |     let _ = x.sum() as f64;\n-        //   |             --^^^--------- cannot infer type for `S`\n-        //   |\n-        //   = note: type must be known at this point\n-        // We want:\n-        // error[E0282]: type annotations needed\n-        //  --> file2.rs:3:15\n-        //   |\n-        // 3 |     let _ = x.sum() as f64;\n-        //   |               ^^^ cannot infer type for `S`\n-        //   |\n-        //   = note: type must be known at this point\n-        let span = arg_data.span.unwrap_or(err_span);\n-\n-        // Avoid multiple labels pointing at `span`.\n-        if !err\n-            .span\n-            .span_labels()\n-            .iter()\n-            .any(|span_label| span_label.label.is_some() && span_label.span == span)\n-            && local_visitor.found_arg_pattern.is_none()\n-        {\n-            // FIXME(const_generics): we would like to handle const arguments\n-            // as part of the normal diagnostics flow below, but there appear to\n-            // be subtleties in doing so, so for now we special-case const args\n-            // here.\n-            if let (UnderspecifiedArgKind::Const { .. }, Some(parent_data)) =\n-                (&arg_data.kind, &arg_data.parent)\n-            {\n-                // (#83606): Do not emit a suggestion if the parent has an `impl Trait`\n-                // as an argument otherwise it will cause the E0282 error.\n-                if !self.tcx.generics_of(parent_data.def_id).has_impl_trait()\n-                    || self.tcx.features().explicit_generic_args_with_impl_trait\n-                {\n-                    err.span_suggestion_verbose(\n-                        span,\n-                        \"consider specifying the const argument\",\n-                        format!(\"{}::<{}>\", parent_data.name, arg_data.name),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n+            InferSourceKind::ClosureReturn { ty, data, should_wrap_expr } => {\n+                let ret = ty_to_string(self, ty);\n+                let (arrow, post) = match data {\n+                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+                    _ => (\"\", \"\"),\n+                };\n+                let suggestion = match should_wrap_expr {\n+                    Some(end_span) => vec![\n+                        (data.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n+                        (end_span, \" }\".to_string()),\n+                    ],\n+                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ret, post))],\n+                };\n+                err.multipart_suggestion_verbose(\n+                    \"try giving this closure an explicit return type\",\n+                    suggestion,\n+                    Applicability::HasPlaceholders,\n+                );\n             }\n-\n-            self.report_ambiguous_type_parameter(&mut err, arg);\n-            err.span_label(\n-                span,\n-                arg_data.cannot_infer_msg(use_diag.filter(|d| d.applies_to(span))),\n-            );\n         }\n-\n         err\n     }\n \n-    fn trait_def_from_hir_fn(&self, hir_id: hir::HirId) -> Option<DefId> {\n-        // The DefId will be the method's trait item ID unless this is an inherent impl\n-        if let Some((DefKind::AssocFn, def_id)) =\n-            self.in_progress_typeck_results?.borrow().type_dependent_def(hir_id)\n-        {\n-            let parent_def_id = self.tcx.parent(def_id);\n-            return self.tcx.is_trait(parent_def_id).then_some(parent_def_id);\n-        }\n-\n-        None\n-    }\n-\n-    /// If the `FnSig` for the method call can be found and type arguments are identified as\n-    /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n-    fn annotate_method_call(\n-        &self,\n-        segment: &hir::PathSegment<'_>,\n-        e: &Expr<'_>,\n-        err: &mut Diagnostic,\n-    ) {\n-        if let (Some(typeck_results), None) = (self.in_progress_typeck_results, &segment.args) {\n-            let borrow = typeck_results.borrow();\n-            if let Some((DefKind::AssocFn, did)) = borrow.type_dependent_def(e.hir_id) {\n-                let generics = self.tcx.generics_of(did);\n-                if !generics.params.is_empty() && !generics.has_impl_trait() {\n-                    err.span_suggestion_verbose(\n-                        segment.ident.span.shrink_to_hi(),\n-                        &format!(\n-                            \"consider specifying the type argument{} in the method call\",\n-                            pluralize!(generics.params.len()),\n-                        ),\n-                        format!(\n-                            \"::<{}>\",\n-                            generics\n-                                .params\n-                                .iter()\n-                                .map(|p| p.name.to_string())\n-                                .collect::<Vec<String>>()\n-                                .join(\", \")\n-                        ),\n-                        Applicability::HasPlaceholders,\n-                    );\n-                } else {\n-                    let sig = self.tcx.fn_sig(did);\n-                    let bound_output = sig.output();\n-                    let output = bound_output.skip_binder();\n-                    err.span_label(e.span, &format!(\"this method call resolves to `{}`\", output));\n-                    let kind = output.kind();\n-                    if let ty::Projection(proj) = kind {\n-                        if let Some(span) = self.tcx.hir().span_if_local(proj.item_def_id) {\n-                            err.span_label(span, &format!(\"`{}` defined here\", output));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn report_ambiguous_type_parameter(&self, err: &mut Diagnostic, arg: GenericArg<'tcx>) {\n-        if let GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Infer(ty::TyVar(ty_vid)) = *ty.kind()\n-        {\n-            let mut inner = self.inner.borrow_mut();\n-            let ty_vars = &inner.type_variables();\n-            let var_origin = ty_vars.var_origin(ty_vid);\n-            if let TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id)) =\n-                var_origin.kind\n-                && let Some(parent_def_id) = self.tcx.parent(def_id).as_local()\n-                && let Some(node) = self.tcx.hir().find_by_def_id(parent_def_id)\n-            {\n-                match node {\n-                    hir::Node::Item(item) if matches!(item.kind, hir::ItemKind::Impl(_) | hir::ItemKind::Fn(..)) => (),\n-                    hir::Node::ImplItem(impl_item) if matches!(impl_item.kind, hir::ImplItemKind::Fn(..)) => (),\n-                    _ => return,\n-                }\n-                err.span_help(self.tcx.def_span(def_id), \"type parameter declared here\");\n-            }\n-        }\n-    }\n-\n     pub fn need_type_info_err_in_generator(\n         &self,\n         kind: hir::GeneratorKind,\n@@ -972,136 +487,564 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"type inside {} must be known in this context\",\n             kind,\n         );\n-        err.span_label(span, data.cannot_infer_msg(None));\n+        err.span_label(span, data.cannot_infer_msg());\n         err\n     }\n }\n \n-/// Turn *resolved* type params into `[type error]` to signal we don't want to display them. After\n-/// performing that replacement, we'll turn all remaining infer type params to use their name from\n-/// their definition, and replace all the `[type error]`s back to being infer so they display in\n-/// the output as `_`. If we didn't go through `[type error]`, we would either show all type params\n-/// by their name *or* `_`, neither of which is desirable: we want to show all types that we could\n-/// infer as `_` to reduce verbosity and avoid telling the user about unnecessary type annotations.\n-struct ResolvedTypeParamEraser<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    level: usize,\n+#[derive(Debug)]\n+struct InferSource<'tcx> {\n+    span: Span,\n+    kind: InferSourceKind<'tcx>,\n }\n \n-impl<'tcx> ResolvedTypeParamEraser<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        ResolvedTypeParamEraser { tcx, level: 0 }\n-    }\n+#[derive(Debug)]\n+enum InferSourceKind<'tcx> {\n+    LetBinding {\n+        insert_span: Span,\n+        pattern_name: Option<Ident>,\n+        ty: Ty<'tcx>,\n+    },\n+    ClosureArg {\n+        insert_span: Span,\n+        ty: Ty<'tcx>,\n+    },\n+    GenericArg {\n+        insert_span: Span,\n+        argument_index: usize,\n+        generics_def_id: DefId,\n+        def_id: DefId,\n+        generic_args: &'tcx [GenericArg<'tcx>],\n+    },\n+    FullyQualifiedMethodCall {\n+        receiver: &'tcx Expr<'tcx>,\n+        /// If the method has other arguments, this is \", \" and the start of the first argument,\n+        /// while for methods without arguments this is \")\" and the end of the method call.\n+        successor: (&'static str, BytePos),\n+        substs: SubstsRef<'tcx>,\n+        def_id: DefId,\n+    },\n+    ClosureReturn {\n+        ty: Ty<'tcx>,\n+        data: &'tcx FnRetTy<'tcx>,\n+        should_wrap_expr: Option<Span>,\n+    },\n+}\n \n-    /// Replace not yet inferred const params with their def name.\n-    fn replace_infers(&self, c: Const<'tcx>, index: u32, name: Symbol) -> Const<'tcx> {\n-        match c.val() {\n-            ty::ConstKind::Infer(..) => self.tcx().mk_const_param(index, name, c.ty()),\n-            _ => c,\n+impl<'tcx> InferSourceKind<'tcx> {\n+    fn ty_msg(&self, infcx: &InferCtxt<'_, 'tcx>) -> String {\n+        match *self {\n+            InferSourceKind::LetBinding { ty, .. }\n+            | InferSourceKind::ClosureArg { ty, .. }\n+            | InferSourceKind::ClosureReturn { ty, .. } => {\n+                if ty.is_closure() {\n+                    format!(\" for the closure `{}`\", closure_as_fn_str(infcx, ty))\n+                } else if !ty.is_ty_infer() {\n+                    format!(\" for `{}`\", ty_to_string(infcx, ty))\n+                } else {\n+                    String::new()\n+                }\n+            }\n+            // FIXME: We should be able to add some additional info here.\n+            InferSourceKind::GenericArg { .. }\n+            | InferSourceKind::FullyQualifiedMethodCall { .. } => String::new(),\n         }\n     }\n }\n \n-impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-        self.tcx\n+struct InsertableGenericArgs<'tcx> {\n+    insert_span: Span,\n+    substs: SubstsRef<'tcx>,\n+    generics_def_id: DefId,\n+    def_id: DefId,\n+}\n+\n+/// A visitor which searches for the \"best\" spot to use in the inference error.\n+///\n+/// For this it walks over the hir body and tries to check all places where\n+/// inference variables could be bound.\n+///\n+/// While doing so, the currently best spot is stored in `infer_source`.\n+/// For details on how we rank spots, see [Self::source_cost]\n+struct FindInferSourceVisitor<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    typeck_results: &'a TypeckResults<'tcx>,\n+\n+    target: GenericArg<'tcx>,\n+\n+    attempt: usize,\n+    infer_source_cost: usize,\n+    infer_source: Option<InferSource<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n+    fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        typeck_results: &'a TypeckResults<'tcx>,\n+        target: GenericArg<'tcx>,\n+    ) -> Self {\n+        FindInferSourceVisitor {\n+            infcx,\n+            typeck_results,\n+\n+            target,\n+\n+            attempt: 0,\n+            infer_source_cost: usize::MAX,\n+            infer_source: None,\n+        }\n     }\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        self.level += 1;\n-        let t = match t.kind() {\n-            // We'll hide this type only if all its type params are hidden as well.\n-            ty::Adt(def, substs) => {\n-                let generics = self.tcx().generics_of(def.did());\n-                // Account for params with default values, like `Vec`, where we\n-                // want to show `Vec<T>`, not `Vec<T, _>`. If we replaced that\n-                // subst, then we'd get the incorrect output, so we passthrough.\n-                let substs: Vec<_> = substs\n-                    .iter()\n-                    .zip(generics.params.iter())\n-                    .map(|(subst, param)| match &(subst.unpack(), &param.kind) {\n-                        (_, ty::GenericParamDefKind::Type { has_default: true, .. }) => subst,\n-                        (crate::infer::GenericArgKind::Const(c), _) => {\n-                            self.replace_infers(*c, param.index, param.name).into()\n-                        }\n-                        _ => subst.super_fold_with(self),\n-                    })\n-                    .collect();\n-                let should_keep = |subst: &GenericArg<'_>| match subst.unpack() {\n-                    ty::subst::GenericArgKind::Type(t) => match t.kind() {\n-                        ty::Error(_) => false,\n-                        _ => true,\n-                    },\n-                    // Account for `const` params here, otherwise `doesnt_infer.rs`\n-                    // shows `_` instead of `Foo<{ _: u32 }>`\n-                    ty::subst::GenericArgKind::Const(_) => true,\n-                    _ => false,\n+\n+    /// Computes cost for the given source.\n+    ///\n+    /// Sources with a small cost are prefer and should result\n+    /// in a clearer and idiomatic suggestion.\n+    fn source_cost(&self, source: &InferSource<'tcx>) -> usize {\n+        let tcx = self.infcx.tcx;\n+\n+        fn arg_cost<'tcx>(arg: GenericArg<'tcx>) -> usize {\n+            match arg.unpack() {\n+                GenericArgKind::Lifetime(_) => 0, // erased\n+                GenericArgKind::Type(ty) => ty_cost(ty),\n+                GenericArgKind::Const(_) => 3, // some non-zero value\n+            }\n+        }\n+        fn ty_cost<'tcx>(ty: Ty<'tcx>) -> usize {\n+            match ty.kind() {\n+                ty::Closure(..) => 100,\n+                ty::FnDef(..) => 20,\n+                ty::FnPtr(..) => 10,\n+                ty::Infer(..) => 0,\n+                _ => 1,\n+            }\n+        }\n+\n+        // The sources are listed in order of preference here.\n+        match source.kind {\n+            InferSourceKind::LetBinding { ty, .. } => ty_cost(ty),\n+            InferSourceKind::ClosureArg { ty, .. } => 5 + ty_cost(ty),\n+            InferSourceKind::GenericArg { def_id, generic_args, .. } => {\n+                let variant_cost = match tcx.def_kind(def_id) {\n+                    DefKind::Variant | DefKind::Ctor(CtorOf::Variant, _) => 15, // `None::<u32>` and friends are ugly.\n+                    _ => 12,\n                 };\n-                if self.level == 1 || substs.iter().any(should_keep) {\n-                    let substs = self.tcx().intern_substs(&substs[..]);\n-                    self.tcx().mk_ty(ty::Adt(*def, substs))\n-                } else {\n-                    self.tcx().ty_error()\n+                variant_cost + generic_args.iter().map(|&arg| arg_cost(arg)).sum::<usize>()\n+            }\n+            InferSourceKind::FullyQualifiedMethodCall { substs, .. } => {\n+                20 + substs.iter().map(|arg| arg_cost(arg)).sum::<usize>()\n+            }\n+            InferSourceKind::ClosureReturn { ty, should_wrap_expr, .. } => {\n+                30 + ty_cost(ty) + if should_wrap_expr.is_some() { 10 } else { 0 }\n+            }\n+        }\n+    }\n+\n+    /// Uses `fn source_cost` to determine whether this inference source is preferable to\n+    /// previous sources. We generally prefer earlier sources.\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn update_infer_source(&mut self, new_source: InferSource<'tcx>) {\n+        let cost = self.source_cost(&new_source) + self.attempt;\n+        self.attempt += 1;\n+        if cost < self.infer_source_cost {\n+            self.infer_source_cost = cost;\n+            self.infer_source = Some(new_source);\n+        }\n+    }\n+\n+    fn opt_node_type(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n+        let ty = self.typeck_results.node_type_opt(hir_id);\n+        self.infcx.resolve_vars_if_possible(ty)\n+    }\n+\n+    // Check whether this generic argument is the inference variable we\n+    // are looking for.\n+    fn generic_arg_is_target(&self, arg: GenericArg<'tcx>) -> bool {\n+        if arg == self.target {\n+            return true;\n+        }\n+\n+        match (arg.unpack(), self.target.unpack()) {\n+            (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {\n+                use ty::{Infer, TyVar};\n+                match (inner_ty.kind(), target_ty.kind()) {\n+                    (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => {\n+                        self.infcx.inner.borrow_mut().type_variables().sub_unified(a_vid, b_vid)\n+                    }\n+                    _ => false,\n+                }\n+            }\n+            (GenericArgKind::Const(inner_ct), GenericArgKind::Const(target_ct)) => {\n+                use ty::InferConst::*;\n+                match (inner_ct.val(), target_ct.val()) {\n+                    (ty::ConstKind::Infer(Var(a_vid)), ty::ConstKind::Infer(Var(b_vid))) => self\n+                        .infcx\n+                        .inner\n+                        .borrow_mut()\n+                        .const_unification_table()\n+                        .unioned(a_vid, b_vid),\n+                    _ => false,\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    /// Does this generic argument contain our target inference variable\n+    /// in a way which can be written by the user.\n+    fn generic_arg_contains_target(&self, arg: GenericArg<'tcx>) -> bool {\n+        let mut walker = arg.walk();\n+        while let Some(inner) = walker.next() {\n+            if self.generic_arg_is_target(inner) {\n+                return true;\n+            }\n+            match inner.unpack() {\n+                GenericArgKind::Lifetime(_) => {}\n+                GenericArgKind::Type(ty) => {\n+                    if matches!(ty.kind(), ty::Opaque(..) | ty::Closure(..) | ty::Generator(..)) {\n+                        // Opaque types can't be named by the user right now.\n+                        //\n+                        // Both the generic arguments of closures and generators can\n+                        // also not be named. We may want to only look into the closure\n+                        // signature in case it has no captures, as that can be represented\n+                        // using `fn(T) -> R`.\n+\n+                        // FIXME(type_alias_impl_trait): These opaque types\n+                        // can actually be named, so it would make sense to\n+                        // adjust this case and add a test for it.\n+                        walker.skip_current_subtree();\n+                    }\n+                }\n+                GenericArgKind::Const(ct) => {\n+                    if matches!(ct.val(), ty::ConstKind::Unevaluated(..)) {\n+                        // You can't write the generic arguments for\n+                        // unevaluated constants.\n+                        walker.skip_current_subtree();\n+                    }\n                 }\n             }\n-            ty::Ref(_, ty, _) => {\n-                let ty = self.fold_ty(*ty);\n-                match ty.kind() {\n-                    // Avoid `&_`, these can be safely presented as `_`.\n-                    ty::Error(_) => self.tcx().ty_error(),\n-                    _ => t.super_fold_with(self),\n+        }\n+        false\n+    }\n+\n+    fn expr_inferred_subst_iter(\n+        &self,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Box<dyn Iterator<Item = InsertableGenericArgs<'tcx>> + 'a> {\n+        let tcx = self.infcx.tcx;\n+        match expr.kind {\n+            hir::ExprKind::Path(ref path) => {\n+                if let Some(substs) = self.typeck_results.node_substs_opt(expr.hir_id) {\n+                    return self.path_inferred_subst_iter(expr.hir_id, substs, path);\n                 }\n             }\n-            // We could account for `()` if we wanted to replace it, but it's assured to be short.\n-            ty::Tuple(_)\n-            | ty::Slice(_)\n-            | ty::RawPtr(_)\n-            | ty::FnDef(..)\n-            | ty::FnPtr(_)\n-            | ty::Opaque(..)\n-            | ty::Projection(_)\n-            | ty::Never => t.super_fold_with(self),\n-            ty::Array(ty, c) => {\n-                self.tcx().mk_ty(ty::Array(self.fold_ty(*ty), self.replace_infers(*c, 0, sym::N)))\n+            hir::ExprKind::Struct(path, _, _) => {\n+                if let Some(ty) = self.opt_node_type(expr.hir_id) {\n+                    if let ty::Adt(_, substs) = ty.kind() {\n+                        return self.path_inferred_subst_iter(expr.hir_id, substs, path);\n+                    }\n+                }\n+            }\n+            hir::ExprKind::MethodCall(segment, _, _) => {\n+                if let Some(def_id) = self.typeck_results.type_dependent_def_id(expr.hir_id) {\n+                    let generics = tcx.generics_of(def_id);\n+                    let insertable: Option<_> = try {\n+                        if generics.has_impl_trait() {\n+                            None?\n+                        }\n+                        let substs = self.typeck_results.node_substs_opt(expr.hir_id)?;\n+                        let span = tcx.hir().span(segment.hir_id?);\n+                        let insert_span = segment.ident.span.shrink_to_hi().with_hi(span.hi());\n+                        InsertableGenericArgs {\n+                            insert_span,\n+                            substs,\n+                            generics_def_id: def_id,\n+                            def_id,\n+                        }\n+                    };\n+                    return Box::new(insertable.into_iter());\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        Box::new(iter::empty())\n+    }\n+\n+    fn resolved_path_inferred_subst_iter(\n+        &self,\n+        path: &'tcx hir::Path<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> impl Iterator<Item = InsertableGenericArgs<'tcx>> + 'a {\n+        let tcx = self.infcx.tcx;\n+        // The last segment of a path often has `Res::Err` and the\n+        // correct `Res` is the one of the whole path.\n+        //\n+        // FIXME: We deal with that one separately for now,\n+        // would be good to remove this special case.\n+        let last_segment_using_path_data: Option<_> = try {\n+            let generics_def_id = tcx.res_generics_def_id(path.res)?;\n+            let generics = tcx.generics_of(generics_def_id);\n+            if generics.has_impl_trait() {\n+                None?\n+            }\n+            let insert_span =\n+                path.segments.last().unwrap().ident.span.shrink_to_hi().with_hi(path.span.hi());\n+            InsertableGenericArgs {\n+                insert_span,\n+                substs,\n+                generics_def_id,\n+                def_id: path.res.def_id(),\n             }\n-            // We don't want to hide type params that haven't been resolved yet.\n-            // This would be the type that will be written out with the type param\n-            // name in the output.\n-            ty::Infer(_) => t,\n-            // We don't want to hide the outermost type, only its type params.\n-            _ if self.level == 1 => t.super_fold_with(self),\n-            // Hide this type\n-            _ => self.tcx().ty_error(),\n         };\n-        self.level -= 1;\n-        t\n+\n+        path.segments\n+            .iter()\n+            .filter_map(move |segment| {\n+                let res = segment.res?;\n+                let generics_def_id = tcx.res_generics_def_id(res)?;\n+                let generics = tcx.generics_of(generics_def_id);\n+                if generics.has_impl_trait() {\n+                    return None;\n+                }\n+                let span = tcx.hir().span(segment.hir_id?);\n+                let insert_span = segment.ident.span.shrink_to_hi().with_hi(span.hi());\n+                Some(InsertableGenericArgs {\n+                    insert_span,\n+                    substs,\n+                    generics_def_id,\n+                    def_id: res.def_id(),\n+                })\n+            })\n+            .chain(last_segment_using_path_data)\n+    }\n+\n+    fn path_inferred_subst_iter(\n+        &self,\n+        hir_id: HirId,\n+        substs: SubstsRef<'tcx>,\n+        qpath: &'tcx hir::QPath<'tcx>,\n+    ) -> Box<dyn Iterator<Item = InsertableGenericArgs<'tcx>> + 'a> {\n+        let tcx = self.infcx.tcx;\n+        match qpath {\n+            hir::QPath::Resolved(_self_ty, path) => {\n+                Box::new(self.resolved_path_inferred_subst_iter(path, substs))\n+            }\n+            hir::QPath::TypeRelative(ty, segment) => {\n+                let Some(def_id) = self.typeck_results.type_dependent_def_id(hir_id) else {\n+                    return Box::new(iter::empty());\n+                };\n+\n+                let generics = tcx.generics_of(def_id);\n+                let segment: Option<_> = try {\n+                    if !segment.infer_args || generics.has_impl_trait() {\n+                        None?;\n+                    }\n+                    let span = tcx.hir().span(segment.hir_id?);\n+                    let insert_span = segment.ident.span.shrink_to_hi().with_hi(span.hi());\n+                    InsertableGenericArgs { insert_span, substs, generics_def_id: def_id, def_id }\n+                };\n+\n+                let parent_def_id = generics.parent.unwrap();\n+                if tcx.def_kind(parent_def_id) == DefKind::Impl {\n+                    let parent_ty = tcx.bound_type_of(parent_def_id).subst(tcx, substs);\n+                    match (parent_ty.kind(), &ty.kind) {\n+                        (\n+                            ty::Adt(def, substs),\n+                            hir::TyKind::Path(hir::QPath::Resolved(_self_ty, path)),\n+                        ) => {\n+                            if tcx.res_generics_def_id(path.res) != Some(def.did()) {\n+                                bug!(\n+                                    \"unexpected path: def={:?} substs={:?} path={:?}\",\n+                                    def,\n+                                    substs,\n+                                    path,\n+                                );\n+                            } else {\n+                                return Box::new(\n+                                    self.resolved_path_inferred_subst_iter(path, substs)\n+                                        .chain(segment),\n+                                );\n+                            }\n+                        }\n+                        _ => (),\n+                    }\n+                }\n+\n+                Box::new(segment.into_iter())\n+            }\n+            hir::QPath::LangItem(_, _, _) => Box::new(iter::empty()),\n+        }\n     }\n }\n \n-/// Replace `[type error]` with `ty::Infer(ty::Var)` to display `_`.\n-struct ErrTypeParamEraser<'tcx>(TyCtxt<'tcx>);\n-impl<'tcx> TypeFolder<'tcx> for ErrTypeParamEraser<'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-        self.0\n+impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n+    type NestedFilter = nested_filter::OnlyBodies;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.infcx.tcx.hir()\n     }\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.kind() {\n-            ty::Error(_) => self.tcx().mk_ty_var(ty::TyVid::from_u32(0)),\n-            _ => t.super_fold_with(self),\n+\n+    fn visit_local(&mut self, local: &'tcx Local<'tcx>) {\n+        intravisit::walk_local(self, local);\n+\n+        if let Some(ty) = self.opt_node_type(local.hir_id) {\n+            if self.generic_arg_contains_target(ty.into()) {\n+                match local.source {\n+                    LocalSource::Normal if local.ty.is_none() => {\n+                        self.update_infer_source(InferSource {\n+                            span: local.pat.span,\n+                            kind: InferSourceKind::LetBinding {\n+                                insert_span: local.pat.span.shrink_to_hi(),\n+                                pattern_name: local.pat.simple_ident(),\n+                                ty,\n+                            },\n+                        })\n+                    }\n+                    _ => {}\n+                }\n+            }\n         }\n     }\n-}\n \n-/// Replace type parameters with `ty::Infer(ty::Var)` to display `_`.\n-struct TypeParamEraser<'tcx>(TyCtxt<'tcx>);\n+    /// For closures, we first visit the parameters and then the content,\n+    /// as we prefer those.\n+    fn visit_body(&mut self, body: &'tcx Body<'tcx>) {\n+        for param in body.params {\n+            debug!(\n+                \"param: span {:?}, ty_span {:?}, pat.span {:?}\",\n+                param.span, param.ty_span, param.pat.span\n+            );\n+            if param.ty_span != param.pat.span {\n+                debug!(\"skipping param: has explicit type\");\n+                continue;\n+            }\n+\n+            let Some(param_ty) = self.opt_node_type(param.hir_id) else {\n+                continue\n+            };\n \n-impl<'tcx> TypeFolder<'tcx> for TypeParamEraser<'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-        self.0\n+            if self.generic_arg_contains_target(param_ty.into()) {\n+                self.update_infer_source(InferSource {\n+                    span: param.pat.span,\n+                    kind: InferSourceKind::ClosureArg {\n+                        insert_span: param.pat.span.shrink_to_hi(),\n+                        ty: param_ty,\n+                    },\n+                })\n+            }\n+        }\n+        intravisit::walk_body(self, body);\n     }\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.kind() {\n-            ty::Param(_) | ty::Error(_) => self.tcx().mk_ty_var(ty::TyVid::from_u32(0)),\n-            _ => t.super_fold_with(self),\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        let tcx = self.infcx.tcx;\n+        match expr.kind {\n+            // When encountering `func(arg)` first look into `arg` and then `func`,\n+            // as `arg` is \"more specific\".\n+            ExprKind::Call(func, args) => {\n+                for arg in args {\n+                    self.visit_expr(arg);\n+                }\n+                self.visit_expr(func);\n+            }\n+            _ => intravisit::walk_expr(self, expr),\n+        }\n+\n+        for InsertableGenericArgs { insert_span, substs, generics_def_id, def_id } in\n+            self.expr_inferred_subst_iter(expr)\n+        {\n+            let generics = tcx.generics_of(generics_def_id);\n+            if let Some(argument_index) =\n+                generics.own_substs(substs).iter().position(|&arg| self.generic_arg_is_target(arg))\n+            {\n+                let substs = self.infcx.resolve_vars_if_possible(substs);\n+                let num_args = generics\n+                    .params\n+                    .iter()\n+                    .rev()\n+                    .filter(|&p| !matches!(p.kind, GenericParamDefKind::Lifetime))\n+                    .skip_while(|&param| {\n+                        if let Some(default) = param.default_value(tcx) {\n+                            // FIXME: Using structural comparisions has a bunch of false negatives.\n+                            //\n+                            // We should instead try to replace inference variables with placeholders and\n+                            // then use `infcx.can_eq`. That probably should be a separate method\n+                            // generally used during error reporting.\n+                            default.subst(tcx, substs) == substs[param.index as usize]\n+                        } else {\n+                            false\n+                        }\n+                    })\n+                    .count();\n+                let generic_args =\n+                    &generics.own_substs(substs)[generics.own_counts().lifetimes..][..num_args];\n+                let span = match expr.kind {\n+                    ExprKind::MethodCall(path, _, _) => path.ident.span,\n+                    _ => expr.span,\n+                };\n+\n+                self.update_infer_source(InferSource {\n+                    span,\n+                    kind: InferSourceKind::GenericArg {\n+                        insert_span,\n+                        argument_index,\n+                        generics_def_id,\n+                        def_id,\n+                        generic_args,\n+                    },\n+                });\n+            }\n+        }\n+\n+        if let Some(node_ty) = self.opt_node_type(expr.hir_id) {\n+            if let (&ExprKind::Closure(_, decl, body_id, span, _), ty::Closure(_, substs)) =\n+                (&expr.kind, node_ty.kind())\n+            {\n+                let output = substs.as_closure().sig().output().skip_binder();\n+                if self.generic_arg_contains_target(output.into()) {\n+                    let body = self.infcx.tcx.hir().body(body_id);\n+                    let should_wrap_expr = if matches!(body.value.kind, ExprKind::Block(..)) {\n+                        None\n+                    } else {\n+                        Some(body.value.span.shrink_to_hi())\n+                    };\n+                    self.update_infer_source(InferSource {\n+                        span,\n+                        kind: InferSourceKind::ClosureReturn {\n+                            ty: output,\n+                            data: &decl.output,\n+                            should_wrap_expr,\n+                        },\n+                    })\n+                }\n+            }\n+        }\n+\n+        let has_impl_trait = |def_id| {\n+            iter::successors(Some(tcx.generics_of(def_id)), |generics| {\n+                generics.parent.map(|def_id| tcx.generics_of(def_id))\n+            })\n+            .any(|generics| generics.has_impl_trait())\n+        };\n+        if let ExprKind::MethodCall(path, args, span) = expr.kind\n+            && let Some(substs) = self.typeck_results.node_substs_opt(expr.hir_id)\n+            && substs.iter().any(|arg| self.generic_arg_contains_target(arg))\n+            && let Some(def_id) = self.typeck_results.type_dependent_def_id(expr.hir_id)\n+            && self.infcx.tcx.trait_of_item(def_id).is_some()\n+            && !has_impl_trait(def_id)\n+        {\n+            let successor =\n+                args.get(1).map_or_else(|| (\")\", span.hi()), |arg| (\", \", arg.span.lo()));\n+            let substs = self.infcx.resolve_vars_if_possible(substs);\n+            self.update_infer_source(InferSource {\n+                span: path.ident.span,\n+                kind: InferSourceKind::FullyQualifiedMethodCall {\n+                    receiver: args.first().unwrap(),\n+                    successor,\n+                    substs,\n+                    def_id,\n+                }\n+            })\n         }\n     }\n }"}, {"sha": "7769a68ba2a66086bc269d40c1383c17d5e7ecbf", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -22,6 +22,7 @@\n #![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "7a1bdd6beca189059a53c2cdef589c5d80838970", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -983,7 +983,11 @@ impl<'hir> Map<'hir> {\n             Node::AnonConst(constant) => self.body(constant.body).value.span,\n             Node::Expr(expr) => expr.span,\n             Node::Stmt(stmt) => stmt.span,\n-            Node::PathSegment(seg) => seg.ident.span,\n+            Node::PathSegment(seg) => {\n+                let ident_span = seg.ident.span;\n+                ident_span\n+                    .with_hi(seg.args.map_or_else(|| ident_span.hi(), |args| args.span_ext.hi()))\n+            }\n             Node::Ty(ty) => ty.span,\n             Node::TraitRef(tr) => tr.path.span,\n             Node::Binding(pat) => pat.span,"}, {"sha": "1feabb2d6b122e73e80eefead895c23c67907dd8", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -63,6 +63,29 @@ impl GenericParamDef {\n             bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n         }\n     }\n+\n+    pub fn has_default(&self) -> bool {\n+        match self.kind {\n+            GenericParamDefKind::Type { has_default, .. }\n+            | GenericParamDefKind::Const { has_default } => has_default,\n+            GenericParamDefKind::Lifetime => false,\n+        }\n+    }\n+\n+    pub fn default_value<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<EarlyBinder<ty::GenericArg<'tcx>>> {\n+        match self.kind {\n+            GenericParamDefKind::Type { has_default, .. } if has_default => {\n+                Some(EarlyBinder(tcx.type_of(self.def_id).into()))\n+            }\n+            GenericParamDefKind::Const { has_default } if has_default => {\n+                Some(EarlyBinder(tcx.const_param_default(self.def_id).into()))\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Default)]\n@@ -204,6 +227,12 @@ impl<'tcx> Generics {\n             matches!(param.kind, ty::GenericParamDefKind::Type { synthetic: true, .. })\n         })\n     }\n+\n+    /// Returns the substs corresponding to the generic parameters of this item, excluding `Self`.\n+    pub fn own_substs(&'tcx self, substs: SubstsRef<'tcx>) -> &'tcx [ty::GenericArg<'tcx>] {\n+        let own = &substs[self.parent_count..][..self.params.len()];\n+        if self.has_self && self.parent.is_none() { &own[1..] } else { &own }\n+    }\n }\n \n /// Bounds on generics."}, {"sha": "8da6d97251ba183b83153bb497a4fd308c82bcb5", "filename": "src/test/ui/array-slice-vec/infer_array_len.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Finfer_array_len.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,9 +2,13 @@ error[E0282]: type annotations needed\n   --> $DIR/infer_array_len.rs:19:9\n    |\n LL |     let [_, _] = a.into();\n-   |         ^^^^^^ consider giving this pattern a type\n+   |         ^^^^^^\n    |\n    = note: type must be known at this point\n+help: consider giving this pattern a type\n+   |\n+LL |     let [_, _]: _ = a.into();\n+   |               +++\n \n error: aborting due to previous error\n "}, {"sha": "d2ea08aa47430b60ef72711e5420a58e58896612", "filename": "src/test/ui/array-slice-vec/vector-no-ann.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Farray-slice-vec%2Fvector-no-ann.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Farray-slice-vec%2Fvector-no-ann.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvector-no-ann.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,10 +1,13 @@\n error[E0282]: type annotations needed for `Vec<T>`\n-  --> $DIR/vector-no-ann.rs:2:16\n+  --> $DIR/vector-no-ann.rs:2:9\n    |\n LL |     let _foo = Vec::new();\n-   |         ----   ^^^^^^^^ cannot infer type for type parameter `T`\n-   |         |\n-   |         consider giving `_foo` the explicit type `Vec<T>`, where the type parameter `T` is specified\n+   |         ^^^^\n+   |\n+help: consider giving `_foo` an explicit type, where the type for type parameter `T` is specified\n+   |\n+LL |     let _foo: Vec<T> = Vec::new();\n+   |             ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "db7586bee4953f9310eca084799bd571bd0ac682", "filename": "src/test/ui/closure-expected-type/expect-two-infer-vars-supply-ty-with-bound-region.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/expect-two-infer-vars-supply-ty-with-bound-region.rs:8:27\n    |\n LL |     with_closure(|x: u32, y| {});\n-   |                           ^ consider giving this closure parameter a type\n+   |                           ^\n+   |\n+help: consider giving this closure parameter an explicit type\n+   |\n+LL |     with_closure(|x: u32, y: B| {});\n+   |                            +++\n \n error: aborting due to previous error\n "}, {"sha": "38d9d08ce36ab4c2d6c0bd62cf44dbc7d1bee2e7", "filename": "src/test/ui/closures/issue-52437.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -8,7 +8,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-52437.rs:2:30\n    |\n LL |     [(); &(&'static: loop { |x| {}; }) as *const _ as usize]\n-   |                              ^ consider giving this closure parameter a type\n+   |                              ^\n+   |\n+help: consider giving this closure parameter an explicit type\n+   |\n+LL |     [(); &(&'static: loop { |x: _| {}; }) as *const _ as usize]\n+   |                               +++\n \n error[E0308]: mismatched types\n   --> $DIR/issue-52437.rs:2:5"}, {"sha": "227b2f4022365ae7cab2a676577504e94b181dde", "filename": "src/test/ui/const-generics/defaults/doesnt_infer.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,10 +1,13 @@\n error[E0282]: type annotations needed for `Foo<N>`\n-  --> $DIR/doesnt_infer.rs:11:15\n+  --> $DIR/doesnt_infer.rs:11:9\n    |\n LL |     let foo = Foo::foo();\n-   |         ---   ^^^^^^^^ cannot infer the value of const parameter `N`\n-   |         |\n-   |         consider giving `foo` the explicit type `Foo<N>`, where the const parameter `N` is specified\n+   |         ^^^\n+   |\n+help: consider giving `foo` an explicit type, where the the value of const parameter `N` is specified\n+   |\n+LL |     let foo: Foo<N> = Foo::foo();\n+   |            ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "463605e2431d609bd2ae7dbdd60723ab61b323e4", "filename": "src/test/ui/const-generics/generic_arg_infer/issue-91614.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fissue-91614.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,17 +1,19 @@\n error[E0283]: type annotations needed for `Mask<_, LANES>`\n-  --> $DIR/issue-91614.rs:6:13\n+  --> $DIR/issue-91614.rs:6:9\n    |\n LL |     let y = Mask::<_, _>::splat(false);\n-   |         -   ^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `T`\n-   |         |\n-   |         consider giving `y` the explicit type `Mask<_, LANES>`, where the type parameter `T` is specified\n+   |         ^\n    |\n    = note: cannot satisfy `_: MaskElement`\n note: required by a bound in `Mask::<T, LANES>::splat`\n   --> $SRC_DIR/core/src/../../portable-simd/crates/core_simd/src/masks.rs:LL:COL\n    |\n LL |     T: MaskElement,\n    |        ^^^^^^^^^^^ required by this bound in `Mask::<T, LANES>::splat`\n+help: consider giving `y` an explicit type, where the type for type parameter `T` is specified\n+   |\n+LL |     let y: Mask<_, LANES> = Mask::<_, _>::splat(false);\n+   |          ++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "9e8328d37017ea0ee92fd90ed4de5f2064761ecb", "filename": "src/test/ui/const-generics/generic_const_exprs/const_eval_resolve_canonical.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_eval_resolve_canonical.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_eval_resolve_canonical.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_eval_resolve_canonical.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,13 +2,18 @@ error[E0282]: type annotations needed\n   --> $DIR/const_eval_resolve_canonical.rs:26:9\n    |\n LL |     let mut _q = Default::default();\n-   |         ^^^^^^ consider giving `_q` a type\n+   |         ^^^^^^\n+   |\n+help: consider giving `_q` an explicit type\n+   |\n+LL |     let mut _q: _ = Default::default();\n+   |               +++\n \n error[E0283]: type annotations needed\n   --> $DIR/const_eval_resolve_canonical.rs:29:10\n    |\n LL |     _q = foo::<_, 2>(_q);\n-   |          ^^^^^^^^^^^ cannot infer type\n+   |          ^^^^^^^^^^^ cannot infer the value of the constant `{ N + 1 }`\n    |\n note: multiple `impl`s satisfying `(): Foo<{ N + 1 }>` found\n   --> $DIR/const_eval_resolve_canonical.rs:8:1"}, {"sha": "93e45a88a6c2056604a6dd95564948979ed1bf7c", "filename": "src/test/ui/const-generics/infer/cannot-infer-const-args.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,12 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-const-args.rs:6:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer the value of const parameter `X` declared on the function `foo`\n+   |     ^^^ cannot infer the value of the const parameter `X` declared on the function `foo`\n    |\n-help: consider specifying the const argument\n+help: consider specifying the generic argument\n    |\n LL |     foo::<X>();\n-   |     ~~~~~~~~\n+   |        +++++\n \n error: aborting due to previous error\n "}, {"sha": "1682b26ac8777bb64f527b345a061e890fef7450", "filename": "src/test/ui/const-generics/infer/issue-77092.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fissue-77092.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,12 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-77092.rs:11:26\n    |\n LL |         println!(\"{:?}\", take_array_from_mut(&mut arr, i));\n-   |                          ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `take_array_from_mut`\n+   |                          ^^^^^^^^^^^^^^^^^^^ cannot infer the value of the const parameter `N` declared on the function `take_array_from_mut`\n    |\n-help: consider specifying the const argument\n+help: consider specifying the generic arguments\n    |\n-LL |         println!(\"{:?}\", take_array_from_mut::<N>(&mut arr, i));\n-   |                          ~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |         println!(\"{:?}\", take_array_from_mut::<i32, N>(&mut arr, i));\n+   |                                             ++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "ff6da535bd264eb90a980b264373b6de68e120b9", "filename": "src/test/ui/const-generics/infer/method-chain.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,12 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/method-chain.rs:15:33\n    |\n LL |     Foo.bar().bar().bar().bar().baz();\n-   |                                 ^^^ cannot infer the value of const parameter `N` declared on the associated function `baz`\n+   |                                 ^^^ cannot infer the value of the const parameter `N` declared on the associated function `baz`\n    |\n-help: consider specifying the const argument\n+help: consider specifying the generic argument\n    |\n LL |     Foo.bar().bar().bar().bar().baz::<N>();\n-   |                                 ~~~~~~~~\n+   |                                    +++++\n \n error: aborting due to previous error\n "}, {"sha": "98ea8df825265a4e2f8f7b54e247a8b1df492663", "filename": "src/test/ui/const-generics/infer/one-param-uninferred.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,12 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/one-param-uninferred.rs:9:23\n    |\n LL |     let _: [u8; 17] = foo();\n-   |                       ^^^ cannot infer the value of const parameter `M` declared on the function `foo`\n+   |                       ^^^ cannot infer the value of the const parameter `M` declared on the function `foo`\n    |\n-help: consider specifying the const argument\n+help: consider specifying the generic arguments\n    |\n-LL |     let _: [u8; 17] = foo::<M>();\n-   |                       ~~~~~~~~\n+LL |     let _: [u8; 17] = foo::<17_usize, M>();\n+   |                          +++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "3980ecea86362f9e3323df0c12606de456ce23a4", "filename": "src/test/ui/const-generics/infer/uninferred-consts.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,12 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/uninferred-consts.rs:9:9\n    |\n LL |     Foo.foo();\n-   |         ^^^ cannot infer the value of const parameter `A` declared on the associated function `foo`\n+   |         ^^^ cannot infer the value of the const parameter `A` declared on the associated function `foo`\n    |\n-help: consider specifying the const argument\n+help: consider specifying the generic arguments\n    |\n-LL |     Foo.foo::<A>();\n-   |         ~~~~~~~~\n+LL |     Foo.foo::<A, B>();\n+   |            ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "362b8554b2fcb91617bc1a4c371c44753b4928a2", "filename": "src/test/ui/const-generics/issues/issue-83249.stderr", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83249.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,16 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-83249.rs:19:13\n+  --> $DIR/issue-83249.rs:19:9\n    |\n LL |     let _ = foo([0; 1]);\n-   |         -   ^^^ cannot infer type for type parameter `T` declared on the function `foo`\n-   |         |\n-   |         consider giving this pattern a type\n+   |         ^\n    |\n-help: type parameter declared here\n-  --> $DIR/issue-83249.rs:12:8\n+help: consider giving this pattern a type\n    |\n-LL | fn foo<T: Foo>(_: [u8; T::N]) -> T {\n-   |        ^\n+LL |     let _: _ = foo([0; 1]);\n+   |          +++\n \n error: aborting due to previous error\n "}, {"sha": "21a419711a989c6a60f00dda3ffbe06f8171e34b", "filename": "src/test/ui/consts/issue-64662.stderr", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,25 +2,23 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-64662.rs:2:9\n    |\n LL |     A = foo(),\n-   |         ^^^ cannot infer type for type parameter `T` declared on the function `foo`\n+   |         ^^^ cannot infer type of the type parameter `T` declared on the function `foo`\n    |\n-help: type parameter declared here\n-  --> $DIR/issue-64662.rs:6:14\n+help: consider specifying the generic argument\n    |\n-LL | const fn foo<T>() -> isize {\n-   |              ^\n+LL |     A = foo::<T>(),\n+   |            +++++\n \n error[E0282]: type annotations needed\n   --> $DIR/issue-64662.rs:3:9\n    |\n LL |     B = foo(),\n-   |         ^^^ cannot infer type for type parameter `T` declared on the function `foo`\n+   |         ^^^ cannot infer type of the type parameter `T` declared on the function `foo`\n    |\n-help: type parameter declared here\n-  --> $DIR/issue-64662.rs:6:14\n+help: consider specifying the generic argument\n    |\n-LL | const fn foo<T>() -> isize {\n-   |              ^\n+LL |     B = foo::<T>(),\n+   |            +++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d01aa3617c764c1fe9f0c95b65a69bf689c59dc1", "filename": "src/test/ui/error-codes/E0282.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/E0282.rs:2:9\n    |\n LL |     let x = \"hello\".chars().rev().collect();\n-   |         ^ consider giving `x` a type\n+   |         ^\n+   |\n+help: consider giving `x` an explicit type\n+   |\n+LL |     let x: _ = \"hello\".chars().rev().collect();\n+   |          +++\n \n error: aborting due to previous error\n "}, {"sha": "a107160d11a35bc25ab2adfa9bae60f54950a25e", "filename": "src/test/ui/error-codes/E0283.stderr", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0283.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -10,10 +10,7 @@ error[E0283]: type annotations needed\n   --> $DIR/E0283.rs:35:24\n    |\n LL |     let bar = foo_impl.into() * 1u32;\n-   |               ---------^^^^--\n-   |               |        |\n-   |               |        cannot infer type for type parameter `T` declared on the trait `Into`\n-   |               this method call resolves to `T`\n+   |                        ^^^^\n    |\n note: multiple `impl`s satisfying `Impl: Into<_>` found\n   --> $DIR/E0283.rs:17:1\n@@ -23,10 +20,10 @@ LL | impl Into<u32> for Impl {\n    = note: and another `impl` found in the `core` crate:\n            - impl<T, U> Into<U> for T\n              where U: From<T>;\n-help: use the fully qualified path for the potential candidate\n+help: try using a fully qualified path to specify the expected types\n    |\n-LL |     let bar = <Impl as Into<u32>>::into(foo_impl) * 1u32;\n-   |               ++++++++++++++++++++++++++        ~\n+LL |     let bar = <Impl as Into<T>>::into(foo_impl) * 1u32;\n+   |               ++++++++++++++++++++++++        ~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "81715621dd921d07e061c56cb93b3266732e9ce2", "filename": "src/test/ui/error-codes/E0401.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -36,13 +36,12 @@ error[E0282]: type annotations needed\n   --> $DIR/E0401.rs:11:5\n    |\n LL |     bfnr(x);\n-   |     ^^^^ cannot infer type for type parameter `U` declared on the function `bfnr`\n+   |     ^^^^ cannot infer type of the type parameter `U` declared on the function `bfnr`\n    |\n-help: type parameter declared here\n-  --> $DIR/E0401.rs:4:13\n+help: consider specifying the generic arguments\n    |\n-LL |     fn bfnr<U, V: Baz<U>, W: Fn()>(y: T) {\n-   |             ^\n+LL |     bfnr::<U, V, W>(x);\n+   |         +++++++++++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "b1b38f6b9194b1f12016ae4c3f2bb599e3453b63", "filename": "src/test/ui/for/for-loop-unconstrained-element-type.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,10 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/for-loop-unconstrained-element-type.rs:8:9\n+  --> $DIR/for-loop-unconstrained-element-type.rs:8:14\n    |\n LL |     for i in Vec::new() { }\n-   |         ^    ---------- the element type for this iterator is not specified\n-   |         |\n-   |         cannot infer type\n+   |              ^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `Vec`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     for i in Vec::<T>::new() { }\n+   |                 +++++\n \n error: aborting due to previous error\n "}, {"sha": "c2785fee387fa986d13220a9491f3a37b4af18a2", "filename": "src/test/ui/generic-associated-types/issue-91762.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91762.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91762.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91762.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-91762.rs:25:15\n    |\n LL |         ret = <Self::Base as Functor>::fmap(arg);\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `T` declared on the associated function `fmap`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `fmap`\n+   |\n+help: consider specifying the generic arguments\n+   |\n+LL |         ret = <Self::Base as Functor>::fmap::<T, U>(arg);\n+   |                                            ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "d881af9ed8fe13c655fed5ecff9544c72fbb4bf1", "filename": "src/test/ui/impl-trait/cross-return-site-inference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -29,17 +29,17 @@ fn baa(b: bool) -> impl std::fmt::Debug {\n }\n \n fn muh() -> Result<(), impl std::fmt::Debug> {\n-    Err(\"whoops\")?; //~^ ERROR type annotations needed\n-    Ok(())\n+    Err(\"whoops\")?;\n+    Ok(()) //~ ERROR type annotations needed\n }\n \n fn muh2() -> Result<(), impl std::fmt::Debug> {\n-    return Err(From::from(\"foo\")); //~^ ERROR type annotations needed\n+    return Err(From::from(\"foo\")); //~ ERROR type annotations needed\n     Ok(())\n }\n \n fn muh3() -> Result<(), impl std::fmt::Debug> {\n-    Err(From::from(\"foo\")) //~^ ERROR type annotations needed\n+    Err(From::from(\"foo\")) //~ ERROR type annotations needed\n }\n \n fn main() {}"}, {"sha": "1ff777e65037c11b9872c7ded5cee41a4033637d", "filename": "src/test/ui/impl-trait/cross-return-site-inference.stderr", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,20 +1,35 @@\n error[E0282]: type annotations needed\n-  --> $DIR/cross-return-site-inference.rs:31:24\n+  --> $DIR/cross-return-site-inference.rs:33:5\n    |\n-LL | fn muh() -> Result<(), impl std::fmt::Debug> {\n-   |                        ^^^^^^^^^^^^^^^^^^^^ cannot infer type\n+LL |     Ok(())\n+   |     ^^ cannot infer type of the type parameter `E` declared on the enum `Result`\n+   |\n+help: consider specifying the generic arguments\n+   |\n+LL |     Ok::<(), E>(())\n+   |       +++++++++\n \n error[E0282]: type annotations needed\n-  --> $DIR/cross-return-site-inference.rs:36:25\n+  --> $DIR/cross-return-site-inference.rs:37:12\n+   |\n+LL |     return Err(From::from(\"foo\"));\n+   |            ^^^ cannot infer type of the type parameter `E` declared on the enum `Result`\n    |\n-LL | fn muh2() -> Result<(), impl std::fmt::Debug> {\n-   |                         ^^^^^^^^^^^^^^^^^^^^ cannot infer type\n+help: consider specifying the generic arguments\n+   |\n+LL |     return Err::<(), E>(From::from(\"foo\"));\n+   |               +++++++++\n \n error[E0282]: type annotations needed\n-  --> $DIR/cross-return-site-inference.rs:41:25\n+  --> $DIR/cross-return-site-inference.rs:42:5\n+   |\n+LL |     Err(From::from(\"foo\"))\n+   |     ^^^ cannot infer type of the type parameter `E` declared on the enum `Result`\n+   |\n+help: consider specifying the generic arguments\n    |\n-LL | fn muh3() -> Result<(), impl std::fmt::Debug> {\n-   |                         ^^^^^^^^^^^^^^^^^^^^ cannot infer type\n+LL |     Err::<(), E>(From::from(\"foo\"))\n+   |        +++++++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "3a47710d508b55663f4ba3cc6ab3df9b3595a076", "filename": "src/test/ui/impl-trait/diagnostics/fully-qualified-path-impl-trait.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fdiagnostics%2Ffully-qualified-path-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fdiagnostics%2Ffully-qualified-path-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdiagnostics%2Ffully-qualified-path-impl-trait.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -0,0 +1,15 @@\n+trait Foo<T> {\n+    fn foo(self, f: impl FnOnce());\n+}\n+\n+impl<T> Foo<T> for () {\n+    fn foo(self, f: impl FnOnce()) {\n+        f()\n+    }\n+}\n+\n+fn main() {\n+    // FIXME: This should ideally use a fully qualified path\n+    // without mentioning the generic arguments of `foo`.\n+    ().foo(|| ()) //~ ERROR type annotations needed\n+}"}, {"sha": "a1a629bddbdead8b622378c6febc83d925377117", "filename": "src/test/ui/impl-trait/diagnostics/fully-qualified-path-impl-trait.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fdiagnostics%2Ffully-qualified-path-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fdiagnostics%2Ffully-qualified-path-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdiagnostics%2Ffully-qualified-path-impl-trait.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/fully-qualified-path-impl-trait.rs:14:8\n+   |\n+LL |     ().foo(|| ())\n+   |        ^^^ cannot infer type for type parameter `T` declared on the trait `Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "98f0bd1af2813174a9a2055499adffc91c089249", "filename": "src/test/ui/impl-trait/fallback_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback_inference.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,7 +1,7 @@\n use std::marker::PhantomData;\n \n fn weird() -> PhantomData<impl Sized> {\n-    PhantomData //~^ ERROR type annotations needed\n+    PhantomData //~ ERROR type annotations needed\n }\n \n fn main() {}"}, {"sha": "4ac3c238fe95897e4c30ac43f8f4b242c12b0786", "filename": "src/test/ui/impl-trait/fallback_inference.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback_inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback_inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback_inference.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,8 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/fallback_inference.rs:3:27\n+  --> $DIR/fallback_inference.rs:4:5\n    |\n-LL | fn weird() -> PhantomData<impl Sized> {\n-   |                           ^^^^^^^^^^ cannot infer type\n+LL |     PhantomData\n+   |     ^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `PhantomData`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     PhantomData::<T>\n+   |                +++++\n \n error: aborting due to previous error\n "}, {"sha": "970d84120e07e89187999c4da5769a9c659ee2c8", "filename": "src/test/ui/impl-trait/hidden-type-is-opaque-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -5,17 +5,17 @@\n #![feature(type_alias_impl_trait)]\n \n fn reify_as() -> Thunk<impl FnOnce(Continuation) -> Continuation> {\n-    Thunk::new(|mut cont| { //~ ERROR type annotations needed\n-        cont.reify_as();\n+    Thunk::new(|mut cont| {\n+        cont.reify_as(); //~ ERROR type annotations needed\n         cont\n     })\n }\n \n type Tait = impl FnOnce(Continuation) -> Continuation;\n \n fn reify_as_tait() -> Thunk<Tait> {\n-    Thunk::new(|mut cont| { //~ ERROR type annotations needed\n-        cont.reify_as();\n+    Thunk::new(|mut cont| {\n+        cont.reify_as(); //~ ERROR type annotations needed\n         cont\n     })\n }"}, {"sha": "11ba5aa7867fe0e42fe559f2d186f96677cdc1d4", "filename": "src/test/ui/impl-trait/hidden-type-is-opaque-2.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,16 +1,16 @@\n error[E0282]: type annotations needed\n-  --> $DIR/hidden-type-is-opaque-2.rs:8:17\n+  --> $DIR/hidden-type-is-opaque-2.rs:9:9\n    |\n-LL |     Thunk::new(|mut cont| {\n-   |                 ^^^^^^^^ consider giving this closure parameter a type\n+LL |         cont.reify_as();\n+   |         ^^^^ cannot infer type\n    |\n    = note: type must be known at this point\n \n error[E0282]: type annotations needed\n-  --> $DIR/hidden-type-is-opaque-2.rs:17:17\n+  --> $DIR/hidden-type-is-opaque-2.rs:18:9\n    |\n-LL |     Thunk::new(|mut cont| {\n-   |                 ^^^^^^^^ consider giving this closure parameter a type\n+LL |         cont.reify_as();\n+   |         ^^^^ cannot infer type\n    |\n    = note: type must be known at this point\n "}, {"sha": "3c39aa6ce5bb953c98034b29eb964e69d9d46a6c", "filename": "src/test/ui/impl-trait/issues/issue-84073.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-84073.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-84073.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-84073.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed for `RaceBuilder<T, Never<T>>`\n   --> $DIR/issue-84073.rs:32:16\n    |\n LL |     Race::new(|race| race.when());\n-   |                ^^^^ consider giving this closure parameter the explicit type `RaceBuilder<T, Never<T>>`, where the type parameter `T` is specified\n+   |                ^^^^\n+   |\n+help: consider giving this closure parameter an explicit type, where the type for type parameter `T` is specified\n+   |\n+LL |     Race::new(|race: RaceBuilder<T, Never<T>>| race.when());\n+   |                    ++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "09047cdcbe15ca5f8d0b211bfc0075ed8b51d203", "filename": "src/test/ui/impl-trait/issues/issue-86719.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -16,7 +16,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-86719.rs:9:10\n    |\n LL |         |_| true\n-   |          ^ consider giving this closure parameter a type\n+   |          ^\n+   |\n+help: consider giving this closure parameter an explicit type\n+   |\n+LL |         |_: _| true\n+   |           +++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "e8575b76b0930c3c8499054ad3335d51cf5c43b6", "filename": "src/test/ui/impl-trait/issues/issue-92305.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-92305.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -18,7 +18,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-92305.rs:7:5\n    |\n LL |     iter::empty()\n-   |     ^^^^^^^^^^^ cannot infer type for type parameter `T` declared on the function `empty`\n+   |     ^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `empty`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     iter::empty::<T>()\n+   |                +++++\n \n error[E0282]: type annotations needed\n   --> $DIR/issue-92305.rs:10:35"}, {"sha": "a08342371b3b5ae15e6b2321a2d43cca87d57d3e", "filename": "src/test/ui/inference/ambiguous_type_parameter.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fambiguous_type_parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fambiguous_type_parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fambiguous_type_parameter.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -3,12 +3,6 @@ error[E0282]: type annotations needed\n    |\n LL |     InMemoryStore.get_raw(&String::default());\n    |                   ^^^^^^^ cannot infer type for type parameter `K`\n-   |\n-help: type parameter declared here\n-  --> $DIR/ambiguous_type_parameter.rs:9:6\n-   |\n-LL | impl<K> Store<String, HashMap<K, String>> for InMemoryStore {\n-   |      ^\n \n error: aborting due to previous error\n "}, {"sha": "0579cf238a9da03b4c12fea17c4033ff9582da97", "filename": "src/test/ui/inference/cannot-infer-async.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,11 +1,13 @@\n error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-async.rs:13:9\n    |\n-LL |     let fut = async {\n-   |         --- consider giving `fut` a type\n-...\n LL |         Ok(())\n-   |         ^^ cannot infer type for type parameter `E` declared on the enum `Result`\n+   |         ^^ cannot infer type of the type parameter `E` declared on the enum `Result`\n+   |\n+help: consider specifying the generic arguments\n+   |\n+LL |         Ok::<(), E>(())\n+   |           +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "ae879db68ec1302dc5a62f368ced9f624361cf9c", "filename": "src/test/ui/inference/cannot-infer-closure-circular.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -5,10 +5,9 @@ fn main() {\n     // note about the `?` operator in the closure body, which isn't relevant to\n     // the inference.\n     let x = |r| {\n-        //~^ ERROR type annotations needed\n         let v = r?;\n         Ok(v)\n     };\n \n-    let _ = x(x(Ok(())));\n+    let _ = x(x(Ok(())));  //~ ERROR type annotations needed for `Result<(), E>`\n }"}, {"sha": "3ad8e3cda16e54b8d58ce2d9b1f40c3e4df629eb", "filename": "src/test/ui/inference/cannot-infer-closure-circular.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,8 +1,13 @@\n error[E0282]: type annotations needed for `Result<(), E>`\n-  --> $DIR/cannot-infer-closure-circular.rs:7:14\n+  --> $DIR/cannot-infer-closure-circular.rs:12:9\n    |\n-LL |     let x = |r| {\n-   |              ^ consider giving this closure parameter the explicit type `Result<(), E>`, where the type parameter `E` is specified\n+LL |     let _ = x(x(Ok(())));\n+   |         ^\n+   |\n+help: consider giving this pattern a type, where the type for type parameter `E` is specified\n+   |\n+LL |     let _: Result<(), E> = x(x(Ok(())));\n+   |          +++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "1c350b18f5a6fa0f9ccd457c483e2aa6d5e4fcef", "filename": "src/test/ui/inference/cannot-infer-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let x = |a: (), b: ()| {\n         Err(a)?;\n-        Ok(b) //~ ERROR type annotations needed for the closure\n+        Ok(b) //~ ERROR type annotations needed\n     };\n }"}, {"sha": "a4b818e6e2bb8fb8d3d9886764d80f8a56f22ffd", "filename": "src/test/ui/inference/cannot-infer-closure.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,13 +1,13 @@\n-error[E0282]: type annotations needed for the closure `fn((), ()) -> Result<(), _>`\n+error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-closure.rs:4:9\n    |\n LL |         Ok(b)\n-   |         ^^ cannot infer type for type parameter `E` declared on the enum `Result`\n+   |         ^^ cannot infer type of the type parameter `E` declared on the enum `Result`\n    |\n-help: give this closure an explicit return type without `_` placeholders\n+help: consider specifying the generic arguments\n    |\n-LL |     let x = |a: (), b: ()| -> Result<(), _> {\n-   |                            ++++++++++++++++\n+LL |         Ok::<(), E>(b)\n+   |           +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "976827a4478608504075ca40b8266f867979e7d1", "filename": "src/test/ui/inference/cannot-infer-partial-try-return.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -16,7 +16,8 @@ fn infallible() -> Result<(), std::convert::Infallible> {\n \n fn main() {\n     let x = || -> Result<_, QualifiedError<_>> {\n-        infallible()?; //~ ERROR type annotations needed\n+        //~^ ERROR type annotations needed for `Result<(), QualifiedError<_>>`\n+        infallible()?;\n         Ok(())\n     };\n }"}, {"sha": "220602c124cb15a47f41c261f570008285fa26f4", "filename": "src/test/ui/inference/cannot-infer-partial-try-return.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,10 +1,10 @@\n-error[E0282]: type annotations needed for the closure `fn() -> Result<(), QualifiedError<_>>`\n-  --> $DIR/cannot-infer-partial-try-return.rs:19:9\n+error[E0282]: type annotations needed for `Result<(), QualifiedError<_>>`\n+  --> $DIR/cannot-infer-partial-try-return.rs:18:13\n    |\n-LL |         infallible()?;\n-   |         ^^^^^^^^^^^^^ cannot infer type\n+LL |     let x = || -> Result<_, QualifiedError<_>> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: give this closure an explicit return type without `_` placeholders\n+help: try giving this closure an explicit return type\n    |\n LL |     let x = || -> Result<(), QualifiedError<_>> {\n    |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"}, {"sha": "fd58844c2380a6ec8df46ff44af0595c99674b35", "filename": "src/test/ui/inference/erase-type-params-in-label.stderr", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,46 +1,40 @@\n error[E0283]: type annotations needed for `Foo<i32, &str, W, Z>`\n-  --> $DIR/erase-type-params-in-label.rs:2:15\n+  --> $DIR/erase-type-params-in-label.rs:2:9\n    |\n LL |     let foo = foo(1, \"\");\n-   |         ---   ^^^ cannot infer type for type parameter `W` declared on the function `foo`\n-   |         |\n-   |         consider giving `foo` the explicit type `Foo<_, _, W, Z>`, where the type parameter `W` is specified\n+   |         ^^^\n    |\n-help: type parameter declared here\n-  --> $DIR/erase-type-params-in-label.rs:25:14\n-   |\n-LL | fn foo<T, K, W: Default, Z: Default>(t: T, k: K) -> Foo<T, K, W, Z> {\n-   |              ^\n    = note: cannot satisfy `_: Default`\n note: required by a bound in `foo`\n   --> $DIR/erase-type-params-in-label.rs:25:17\n    |\n LL | fn foo<T, K, W: Default, Z: Default>(t: T, k: K) -> Foo<T, K, W, Z> {\n    |                 ^^^^^^^ required by this bound in `foo`\n+help: consider giving `foo` an explicit type, where the type for type parameter `W` is specified\n+   |\n+LL |     let foo: Foo<i32, &str, W, Z> = foo(1, \"\");\n+   |            ++++++++++++++++++++++\n help: consider specifying the type arguments in the function call\n    |\n LL |     let foo = foo::<T, K, W, Z>(1, \"\");\n    |                  ++++++++++++++\n \n error[E0283]: type annotations needed for `Bar<i32, &str, Z>`\n-  --> $DIR/erase-type-params-in-label.rs:5:15\n+  --> $DIR/erase-type-params-in-label.rs:5:9\n    |\n LL |     let bar = bar(1, \"\");\n-   |         ---   ^^^ cannot infer type for type parameter `Z` declared on the function `bar`\n-   |         |\n-   |         consider giving `bar` the explicit type `Bar<_, _, Z>`, where the type parameter `Z` is specified\n+   |         ^^^\n    |\n-help: type parameter declared here\n-  --> $DIR/erase-type-params-in-label.rs:14:14\n-   |\n-LL | fn bar<T, K, Z: Default>(t: T, k: K) -> Bar<T, K, Z> {\n-   |              ^\n    = note: cannot satisfy `_: Default`\n note: required by a bound in `bar`\n   --> $DIR/erase-type-params-in-label.rs:14:17\n    |\n LL | fn bar<T, K, Z: Default>(t: T, k: K) -> Bar<T, K, Z> {\n    |                 ^^^^^^^ required by this bound in `bar`\n+help: consider giving `bar` an explicit type, where the type for type parameter `Z` is specified\n+   |\n+LL |     let bar: Bar<i32, &str, Z> = bar(1, \"\");\n+   |            +++++++++++++++++++\n help: consider specifying the type arguments in the function call\n    |\n LL |     let bar = bar::<T, K, Z>(1, \"\");"}, {"sha": "db153d38aaa9f160155911cac50ca13b8908964b", "filename": "src/test/ui/inference/issue-71732.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-71732.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,9 +2,7 @@ error[E0283]: type annotations needed\n   --> $DIR/issue-71732.rs:18:10\n    |\n LL |         .get(&\"key\".into())\n-   |          ^^^  ------------ this method call resolves to `T`\n-   |          |\n-   |          cannot infer type for type parameter `Q` declared on the associated function `get`\n+   |          ^^^ cannot infer type of the type parameter `Q` declared on the associated function `get`\n    |\n    = note: multiple `impl`s satisfying `String: Borrow<_>` found in the following crates: `alloc`, `core`:\n            - impl Borrow<str> for String;\n@@ -15,6 +13,10 @@ note: required by a bound in `HashMap::<K, V, S>::get`\n    |\n LL |         K: Borrow<Q>,\n    |            ^^^^^^^^^ required by this bound in `HashMap::<K, V, S>::get`\n+help: consider specifying the generic argument\n+   |\n+LL |         .get::<Q>(&\"key\".into())\n+   |             +++++\n help: consider specifying the type argument in the function call\n    |\n LL |         .get::<Q>(&\"key\".into())"}, {"sha": "3c53d8126e778b370144b20ee89636ad3db563b2", "filename": "src/test/ui/inference/issue-72616.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fissue-72616.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fissue-72616.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-72616.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,16 +1,18 @@\n error[E0283]: type annotations needed\n-  --> $DIR/issue-72616.rs:20:30\n+  --> $DIR/issue-72616.rs:20:37\n    |\n LL |         if String::from(\"a\") == \"a\".try_into().unwrap() {}\n-   |                              ^^ -------------- this method call resolves to `Result<T, <Self as TryInto<T>>::Error>`\n-   |                              |\n-   |                              cannot infer type\n+   |                                     ^^^^^^^^\n    |\n    = note: multiple `impl`s satisfying `String: PartialEq<_>` found in the `alloc` crate:\n            - impl PartialEq for String;\n            - impl<'a, 'b> PartialEq<&'a str> for String;\n            - impl<'a, 'b> PartialEq<Cow<'a, str>> for String;\n            - impl<'a, 'b> PartialEq<str> for String;\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |         if String::from(\"a\") == <&str as TryInto<T>>::try_into(\"a\").unwrap() {}\n+   |                                 +++++++++++++++++++++++++++++++   ~\n \n error: aborting due to previous error\n "}, {"sha": "4ffaf820b826729f7a26a8f3872e680c888c8e91", "filename": "src/test/ui/inference/issue-83606.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,10 +1,13 @@\n error[E0282]: type annotations needed for `[usize; _]`\n-  --> $DIR/issue-83606.rs:8:13\n+  --> $DIR/issue-83606.rs:8:9\n    |\n LL |     let _ = foo(\"foo\"); //<- Do not suggest `foo::<N>(\"foo\");`!\n-   |         -   ^^^ cannot infer the value of const parameter `N` declared on the function `foo`\n-   |         |\n-   |         consider giving this pattern the explicit type `[_; N]`, where the const parameter `N` is specified\n+   |         ^\n+   |\n+help: consider giving this pattern a type, where the the value of const parameter `N` is specified\n+   |\n+LL |     let _: [usize; _] = foo(\"foo\"); //<- Do not suggest `foo::<N>(\"foo\");`!\n+   |          ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "6641b29b30b0be56ecb6f6d07108dbc5ee0c0230", "filename": "src/test/ui/inference/issue-86162-1.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fissue-86162-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fissue-86162-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-86162-1.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,20 +1,19 @@\n error[E0283]: type annotations needed\n-  --> $DIR/issue-86162-1.rs:7:5\n+  --> $DIR/issue-86162-1.rs:7:9\n    |\n LL |     foo(gen()); //<- Do not suggest `foo::<impl Clone>()`!\n-   |     ^^^ cannot infer type for type parameter `impl Clone` declared on the function `foo`\n+   |         ^^^ cannot infer type of the type parameter `T` declared on the function `gen`\n    |\n-help: type parameter declared here\n-  --> $DIR/issue-86162-1.rs:3:11\n-   |\n-LL | fn foo(x: impl Clone) {}\n-   |           ^^^^^^^^^^\n    = note: cannot satisfy `_: Clone`\n note: required by a bound in `foo`\n   --> $DIR/issue-86162-1.rs:3:16\n    |\n LL | fn foo(x: impl Clone) {}\n    |                ^^^^^ required by this bound in `foo`\n+help: consider specifying the generic argument\n+   |\n+LL |     foo(gen::<T>()); //<- Do not suggest `foo::<impl Clone>()`!\n+   |            +++++\n \n error: aborting due to previous error\n "}, {"sha": "d2a026a9269c66b25f63ebf44d7488b849c7d745", "filename": "src/test/ui/inference/issue-86162-2.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fissue-86162-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Finference%2Fissue-86162-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-86162-2.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,20 +1,19 @@\n error[E0283]: type annotations needed\n-  --> $DIR/issue-86162-2.rs:12:5\n+  --> $DIR/issue-86162-2.rs:12:14\n    |\n LL |     Foo::bar(gen()); //<- Do not suggest `Foo::bar::<impl Clone>()`!\n-   |     ^^^^^^^^ cannot infer type for type parameter `impl Clone` declared on the associated function `bar`\n+   |              ^^^ cannot infer type of the type parameter `T` declared on the function `gen`\n    |\n-help: type parameter declared here\n-  --> $DIR/issue-86162-2.rs:8:15\n-   |\n-LL |     fn bar(x: impl Clone) {}\n-   |               ^^^^^^^^^^\n    = note: cannot satisfy `_: Clone`\n note: required by a bound in `Foo::bar`\n   --> $DIR/issue-86162-2.rs:8:20\n    |\n LL |     fn bar(x: impl Clone) {}\n    |                    ^^^^^ required by this bound in `Foo::bar`\n+help: consider specifying the generic argument\n+   |\n+LL |     Foo::bar(gen::<T>()); //<- Do not suggest `Foo::bar::<impl Clone>()`!\n+   |                 +++++\n \n error: aborting due to previous error\n "}, {"sha": "806b7f0ac05e960d3f8fac5c5e7378b39b8e362c", "filename": "src/test/ui/issues/issue-12187-1.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-12187-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-12187-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12187-1.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,11 +1,13 @@\n error[E0282]: type annotations needed for `&T`\n-  --> $DIR/issue-12187-1.rs:6:10\n+  --> $DIR/issue-12187-1.rs:6:9\n    |\n LL |     let &v = new();\n-   |         -^\n-   |         ||\n-   |         |cannot infer type\n-   |         consider giving this pattern the explicit type `&T`, with the type parameters specified\n+   |         ^^\n+   |\n+help: consider giving this pattern a type, where the placeholders `_` are specified\n+   |\n+LL |     let &v: &T = new();\n+   |           ++++\n \n error: aborting due to previous error\n "}, {"sha": "a1fa0a2b00245d03ca17ab1b94973f1bd7862622", "filename": "src/test/ui/issues/issue-12187-2.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-12187-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-12187-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12187-2.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,11 +1,13 @@\n error[E0282]: type annotations needed for `&T`\n-  --> $DIR/issue-12187-2.rs:6:10\n+  --> $DIR/issue-12187-2.rs:6:9\n    |\n LL |     let &v = new();\n-   |         -^\n-   |         ||\n-   |         |cannot infer type\n-   |         consider giving this pattern the explicit type `&T`, with the type parameters specified\n+   |         ^^\n+   |\n+help: consider giving this pattern a type, where the placeholders `_` are specified\n+   |\n+LL |     let &v: &T = new();\n+   |           ++++\n \n error: aborting due to previous error\n "}, {"sha": "6eb56ca5516bfb2e7c371c96411b709d3bd1644b", "filename": "src/test/ui/issues/issue-16966.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,9 +2,14 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-16966.rs:2:5\n    |\n LL |     panic!(std::default::Default::default());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `M` declared on the function `begin_panic`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `M` declared on the function `begin_panic`\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider specifying the generic argument\n+  --> $SRC_DIR/std/src/panic.rs:LL:COL\n+   |\n+LL |         $crate::rt::begin_panic::<M>($msg)\n+   |                                +++++\n \n error: aborting due to previous error\n "}, {"sha": "5f45a2f844321e40873647d4efad028fc5f07023", "filename": "src/test/ui/issues/issue-17551.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-17551.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-17551.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17551.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,10 +1,13 @@\n error[E0282]: type annotations needed for `B<T>`\n-  --> $DIR/issue-17551.rs:6:15\n+  --> $DIR/issue-17551.rs:6:9\n    |\n LL |     let foo = B(marker::PhantomData);\n-   |         ---   ^ cannot infer type for type parameter `T` declared on the struct `B`\n-   |         |\n-   |         consider giving `foo` the explicit type `B<T>`, where the type parameter `T` is specified\n+   |         ^^^\n+   |\n+help: consider giving `foo` an explicit type, where the type for type parameter `T` is specified\n+   |\n+LL |     let foo: B<T> = B(marker::PhantomData);\n+   |            ++++++\n \n error: aborting due to previous error\n "}, {"sha": "605ff3829d19a6a70e88f7f83fa22763a3c6e2e4", "filename": "src/test/ui/issues/issue-18159.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-18159.rs:2:9\n    |\n LL |     let x;\n-   |         ^ consider giving `x` a type\n+   |         ^\n+   |\n+help: consider giving `x` an explicit type\n+   |\n+LL |     let x: _;\n+   |          +++\n \n error: aborting due to previous error\n "}, {"sha": "73468c7ca1687c9f1289a1d32cf87c14eab39cbf", "filename": "src/test/ui/issues/issue-20261.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-20261.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-20261.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20261.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,8 +1,6 @@\n-error[E0282]: type annotations needed for `(_,)`\n+error[E0282]: type annotations needed\n   --> $DIR/issue-20261.rs:4:11\n    |\n-LL |     for (ref i,) in [].iter() {\n-   |                     --------- this method call resolves to `std::slice::Iter<'_, T>`\n LL |         i.clone();\n    |           ^^^^^ cannot infer type\n    |"}, {"sha": "82cf49de8227ef303d8c67b20f86acd7966e747c", "filename": "src/test/ui/issues/issue-2151.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-2151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-2151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2151.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let x = panic!();\n-    x.clone(); //~ ERROR type annotations needed\n+    let x = panic!(); //~ ERROR type annotations needed\n+    x.clone();\n }"}, {"sha": "e0d946205ad0a30e7c5358532c1aa1d479cccdd7", "filename": "src/test/ui/issues/issue-2151.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-2151.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-2151.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2151.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,12 +1,14 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-2151.rs:3:5\n+  --> $DIR/issue-2151.rs:2:9\n    |\n LL |     let x = panic!();\n-   |         - consider giving `x` a type\n-LL |     x.clone();\n-   |     ^ cannot infer type\n+   |         ^\n    |\n    = note: type must be known at this point\n+help: consider giving `x` an explicit type\n+   |\n+LL |     let x: _ = panic!();\n+   |          +++\n \n error: aborting due to previous error\n "}, {"sha": "1403ecbd92d49df96d866d01e532d8a0e3a67567", "filename": "src/test/ui/issues/issue-23046.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-23046.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-23046.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23046.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed for `Expr<'_, VAR>`\n   --> $DIR/issue-23046.rs:17:15\n    |\n LL |     let ex = |x| {\n-   |               ^ consider giving this closure parameter the explicit type `Expr<'_, VAR>`, where the type parameter `VAR` is specified\n+   |               ^\n+   |\n+help: consider giving this closure parameter an explicit type, where the type for type parameter `VAR` is specified\n+   |\n+LL |     let ex = |x: Expr<'_, VAR>| {\n+   |                +++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "4622501f33edae7a823ab372401f1d233f1a7a19", "filename": "src/test/ui/issues/issue-24036.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -15,7 +15,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-24036.rs:9:15\n    |\n LL |         1 => |c| c + 1,\n-   |               ^ consider giving this closure parameter a type\n+   |               ^\n+   |\n+help: consider giving this closure parameter an explicit type\n+   |\n+LL |         1 => |c: _| c + 1,\n+   |                +++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b7f0f613e8091f3f1a2c34fbe2d1694e53e87f23", "filename": "src/test/ui/issues/issue-25368.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -5,9 +5,10 @@ use std::marker::PhantomData;\n struct Foo<T> {foo: PhantomData<T>}\n \n fn main() {\n-    let (tx, rx) = channel();\n-\n+    let (tx, rx) = //~ ERROR type annotations needed\n+        channel();\n+    // FIXME(#89862): Suggest adding a generic argument to `channel` instead\n     spawn(move || {\n-        tx.send(Foo{ foo: PhantomData }); //~ ERROR E0282\n+        tx.send(Foo{ foo: PhantomData });\n     });\n }"}, {"sha": "ffcb73849527fd2d3f0a4555dcdcd0ba2abc03c4", "filename": "src/test/ui/issues/issue-25368.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,11 +1,13 @@\n error[E0282]: type annotations needed for `(Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>)`\n-  --> $DIR/issue-25368.rs:11:17\n+  --> $DIR/issue-25368.rs:8:9\n    |\n-LL |     let (tx, rx) = channel();\n-   |         -------- consider giving this pattern the explicit type `(Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>)`, where the type parameter `T` is specified\n-...\n-LL |         tx.send(Foo{ foo: PhantomData });\n-   |                 ^^^ cannot infer type for type parameter `T` declared on the struct `Foo`\n+LL |     let (tx, rx) =\n+   |         ^^^^^^^^\n+   |\n+help: consider giving this pattern a type, where the type for type parameter `T` is specified\n+   |\n+LL |     let (tx, rx): (Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>) =\n+   |                 +++++++++++++++++++++++++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "ca57b2d7e01d212c76ee02a09bbab791de9e25b7", "filename": "src/test/ui/issues/issue-47486.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47486.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,8 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-47486.rs:3:31\n+  --> $DIR/issue-47486.rs:3:11\n    |\n LL |     [0u8; std::mem::size_of::<_>()];\n-   |                               ^ cannot infer type\n+   |           ^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `size_of`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     [0u8; std::mem::size_of::<_>()];\n+   |                            ~~~~~\n \n error[E0308]: mismatched types\n   --> $DIR/issue-47486.rs:2:10"}, {"sha": "3191bd3de32fef352599ac0102d017cd8215cf91", "filename": "src/test/ui/issues/issue-5062.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-5062.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-5062.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5062.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-5062.rs:1:29\n    |\n LL | fn main() { format!(\"{:?}\", None); }\n-   |                             ^^^^ cannot infer type for type parameter `T` declared on the enum `Option`\n+   |                             ^^^^ cannot infer type of the type parameter `T` declared on the enum `Option`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL | fn main() { format!(\"{:?}\", None::<T>); }\n+   |                                 +++++\n \n error: aborting due to previous error\n "}, {"sha": "c979c7b2cdd7636a64f423be9b1e8c5a6710f8a5", "filename": "src/test/ui/issues/issue-51116.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-51116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-51116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51116.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,6 @@ fn main() {\n     let tiles = Default::default();\n     for row in &mut tiles {\n         for tile in row {\n-            //~^ NOTE the element type for this iterator is not specified\n             *tile = 0;\n             //~^ ERROR type annotations needed\n             //~| NOTE cannot infer type"}, {"sha": "399b421ab163ec9512653d040abf6dd4a6a31dfd", "filename": "src/test/ui/issues/issue-51116.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-51116.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-51116.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51116.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,9 +1,6 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-51116.rs:6:13\n+  --> $DIR/issue-51116.rs:5:13\n    |\n-LL |         for tile in row {\n-   |                     --- the element type for this iterator is not specified\n-LL |\n LL |             *tile = 0;\n    |             ^^^^^ cannot infer type\n    |"}, {"sha": "8dbdd9a2735317cd0a45305989be0548967c3780", "filename": "src/test/ui/issues/issue-6458-2.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-6458-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-6458-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458-2.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-6458-2.rs:3:21\n    |\n LL |     format!(\"{:?}\", None);\n-   |                     ^^^^ cannot infer type for type parameter `T` declared on the enum `Option`\n+   |                     ^^^^ cannot infer type of the type parameter `T` declared on the enum `Option`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     format!(\"{:?}\", None::<T>);\n+   |                         +++++\n \n error: aborting due to previous error\n "}, {"sha": "2c3ec1a331ff83f998f5413ab9391d6c3938235e", "filename": "src/test/ui/issues/issue-6458-3.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-6458-3.rs:4:5\n    |\n LL |     mem::transmute(0);\n-   |     ^^^^^^^^^^^^^^ cannot infer type for type parameter `U` declared on the function `transmute`\n+   |     ^^^^^^^^^^^^^^ cannot infer type of the type parameter `U` declared on the function `transmute`\n+   |\n+help: consider specifying the generic arguments\n+   |\n+LL |     mem::transmute::<i32, U>(0);\n+   |                   ++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "2e93c13855f565ec95fb2b6fd965078e81e4b135", "filename": "src/test/ui/issues/issue-6458.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-6458.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-6458.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,14 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-6458.rs:9:4\n+  --> $DIR/issue-6458.rs:9:22\n    |\n LL |    foo(TypeWithState(marker::PhantomData));\n-   |    ^^^ cannot infer type for type parameter `State` declared on the function `foo`\n+   |                      ^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `PhantomData`\n    |\n-help: type parameter declared here\n-  --> $DIR/issue-6458.rs:6:12\n+help: consider specifying the generic argument\n    |\n-LL | pub fn foo<State>(_: TypeWithState<State>) {}\n-   |            ^^^^^\n+LL |    foo(TypeWithState(marker::PhantomData::<T>));\n+   |                                         +++++\n \n error: aborting due to previous error\n "}, {"sha": "1c55560cb7c723f8e37f0dc6275000d2fa715ec9", "filename": "src/test/ui/issues/issue-66706.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-66706.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-66706.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66706.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -30,7 +30,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-66706.rs:2:11\n    |\n LL |     [0; [|_: _ &_| ()].len()]\n-   |           ^ consider giving this closure parameter a type\n+   |           ^ cannot infer type\n \n error[E0308]: mismatched types\n   --> $DIR/issue-66706.rs:2:5"}, {"sha": "6c4eafbc8b3a1cbf92fbd91dc24504f4b84c61f5", "filename": "src/test/ui/issues/issue-69455.stderr", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,22 +1,20 @@\n error[E0282]: type annotations needed\n   --> $DIR/issue-69455.rs:29:20\n    |\n-LL |     type Output;\n-   |     ------------ `<Self as Test<Rhs>>::Output` defined here\n-...\n LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                    |\n-   |                    this method call resolves to `<Self as Test<Rhs>>::Output`\n-   |                    cannot infer type for type parameter `T` declared on the associated function `new_display`\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `new_display`\n    |\n    = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider specifying the generic argument\n+   |\n+LL |     println!(\"{}\", 23u64.test(xs.iter().sum())::<T>);\n+   |                                               +++++\n \n error[E0283]: type annotations needed\n-  --> $DIR/issue-69455.rs:29:26\n+  --> $DIR/issue-69455.rs:29:41\n    |\n LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n-   |                          ^^^^ cannot infer type for type parameter `Rhs` declared on the trait `Test`\n+   |                                         ^^^ cannot infer type of the type parameter `S` declared on the associated function `sum`\n    |\n note: multiple `impl`s satisfying `u64: Test<_>` found\n   --> $DIR/issue-69455.rs:11:1\n@@ -26,7 +24,7 @@ LL | impl Test<u32> for u64 {\n ...\n LL | impl Test<u64> for u64 {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n-help: consider specifying the type argument in the method call\n+help: consider specifying the generic argument\n    |\n LL |     println!(\"{}\", 23u64.test(xs.iter().sum::<S>()));\n    |                                            +++++"}, {"sha": "9c71ecffa2682ac34e61608aa504cc1669090402", "filename": "src/test/ui/issues/issue-69683.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-69683.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-69683.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69683.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -8,7 +8,7 @@ error[E0283]: type annotations needed\n   --> $DIR/issue-69683.rs:30:10\n    |\n LL |     0u16.foo(b);\n-   |          ^^^ cannot infer type for type parameter `I` declared on the trait `Foo`\n+   |          ^^^\n    |\n note: multiple `impl`s satisfying `u8: Element<_>` found\n   --> $DIR/issue-69683.rs:5:1\n@@ -26,6 +26,10 @@ LL |     u8: Element<I>,\n LL | {\n LL |     fn foo(self, x: <u8 as Element<I>>::Array);\n    |        --- required by a bound in this\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <u16 as Foo<I>>::foo(0u16, b);\n+   |     +++++++++++++++++++++    ~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9edf14ef291f9e5d3484c9af459574bd9356addd", "filename": "src/test/ui/issues/issue-72690.stderr", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-72690.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-72690.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72690.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -12,51 +12,60 @@ error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:7:22\n    |\n LL |     String::from(\"x\".as_ref());\n-   |                  ----^^^^^^--\n-   |                  |   |\n-   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n-   |                  this method call resolves to `&T`\n+   |                      ^^^^^^\n    |\n    = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n            - impl AsRef<OsStr> for str;\n            - impl AsRef<Path> for str;\n            - impl AsRef<[u8]> for str;\n            - impl AsRef<str> for str;\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     String::from(<str as AsRef<T>>::as_ref(\"x\"));\n+   |                  ++++++++++++++++++++++++++   ~\n \n error[E0282]: type annotations needed\n   --> $DIR/issue-72690.rs:12:6\n    |\n LL |     |x| String::from(\"x\".as_ref());\n-   |      ^ consider giving this closure parameter a type\n+   |      ^\n+   |\n+help: consider giving this closure parameter an explicit type\n+   |\n+LL |     |x: _| String::from(\"x\".as_ref());\n+   |       +++\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:12:26\n    |\n LL |     |x| String::from(\"x\".as_ref());\n-   |                      ----^^^^^^--\n-   |                      |   |\n-   |                      |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n-   |                      this method call resolves to `&T`\n+   |                          ^^^^^^\n    |\n    = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n            - impl AsRef<OsStr> for str;\n            - impl AsRef<Path> for str;\n            - impl AsRef<[u8]> for str;\n            - impl AsRef<str> for str;\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     |x| String::from(<str as AsRef<T>>::as_ref(\"x\"));\n+   |                      ++++++++++++++++++++++++++   ~\n \n error[E0283]: type annotations needed for `&T`\n-  --> $DIR/issue-72690.rs:17:17\n+  --> $DIR/issue-72690.rs:17:9\n    |\n LL |     let _ = \"x\".as_ref();\n-   |         -       ^^^^^^ cannot infer type for type parameter `T` declared on the trait `AsRef`\n-   |         |\n-   |         consider giving this pattern the explicit type `&T`, where the type parameter `T` is specified\n+   |         ^\n    |\n    = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n            - impl AsRef<OsStr> for str;\n            - impl AsRef<Path> for str;\n            - impl AsRef<[u8]> for str;\n            - impl AsRef<str> for str;\n+help: consider giving this pattern a type, where the type for type parameter `T` is specified\n+   |\n+LL |     let _: &T = \"x\".as_ref();\n+   |          ++++\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:21:5\n@@ -72,16 +81,17 @@ error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:21:22\n    |\n LL |     String::from(\"x\".as_ref());\n-   |                  ----^^^^^^--\n-   |                  |   |\n-   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n-   |                  this method call resolves to `&T`\n+   |                      ^^^^^^\n    |\n    = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n            - impl AsRef<OsStr> for str;\n            - impl AsRef<Path> for str;\n            - impl AsRef<[u8]> for str;\n            - impl AsRef<str> for str;\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     String::from(<str as AsRef<T>>::as_ref(\"x\"));\n+   |                  ++++++++++++++++++++++++++   ~\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:28:5\n@@ -97,16 +107,17 @@ error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:28:22\n    |\n LL |     String::from(\"x\".as_ref());\n-   |                  ----^^^^^^--\n-   |                  |   |\n-   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n-   |                  this method call resolves to `&T`\n+   |                      ^^^^^^\n    |\n    = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n            - impl AsRef<OsStr> for str;\n            - impl AsRef<Path> for str;\n            - impl AsRef<[u8]> for str;\n            - impl AsRef<str> for str;\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     String::from(<str as AsRef<T>>::as_ref(\"x\"));\n+   |                  ++++++++++++++++++++++++++   ~\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:37:5\n@@ -122,16 +133,17 @@ error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:37:22\n    |\n LL |     String::from(\"x\".as_ref());\n-   |                  ----^^^^^^--\n-   |                  |   |\n-   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n-   |                  this method call resolves to `&T`\n+   |                      ^^^^^^\n    |\n    = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n            - impl AsRef<OsStr> for str;\n            - impl AsRef<Path> for str;\n            - impl AsRef<[u8]> for str;\n            - impl AsRef<str> for str;\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     String::from(<str as AsRef<T>>::as_ref(\"x\"));\n+   |                  ++++++++++++++++++++++++++   ~\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:46:5\n@@ -147,16 +159,17 @@ error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:46:22\n    |\n LL |     String::from(\"x\".as_ref());\n-   |                  ----^^^^^^--\n-   |                  |   |\n-   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n-   |                  this method call resolves to `&T`\n+   |                      ^^^^^^\n    |\n    = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n            - impl AsRef<OsStr> for str;\n            - impl AsRef<Path> for str;\n            - impl AsRef<[u8]> for str;\n            - impl AsRef<str> for str;\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     String::from(<str as AsRef<T>>::as_ref(\"x\"));\n+   |                  ++++++++++++++++++++++++++   ~\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:53:5\n@@ -172,16 +185,17 @@ error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:53:22\n    |\n LL |     String::from(\"x\".as_ref());\n-   |                  ----^^^^^^--\n-   |                  |   |\n-   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n-   |                  this method call resolves to `&T`\n+   |                      ^^^^^^\n    |\n    = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n            - impl AsRef<OsStr> for str;\n            - impl AsRef<Path> for str;\n            - impl AsRef<[u8]> for str;\n            - impl AsRef<str> for str;\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     String::from(<str as AsRef<T>>::as_ref(\"x\"));\n+   |                  ++++++++++++++++++++++++++   ~\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:62:5\n@@ -197,16 +211,17 @@ error[E0283]: type annotations needed\n   --> $DIR/issue-72690.rs:62:22\n    |\n LL |     String::from(\"x\".as_ref());\n-   |                  ----^^^^^^--\n-   |                  |   |\n-   |                  |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n-   |                  this method call resolves to `&T`\n+   |                      ^^^^^^\n    |\n    = note: multiple `impl`s satisfying `str: AsRef<_>` found in the following crates: `core`, `std`:\n            - impl AsRef<OsStr> for str;\n            - impl AsRef<Path> for str;\n            - impl AsRef<[u8]> for str;\n            - impl AsRef<str> for str;\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     String::from(<str as AsRef<T>>::as_ref(\"x\"));\n+   |                  ++++++++++++++++++++++++++   ~\n \n error: aborting due to 17 previous errors\n "}, {"sha": "3aee61bd5a54c047a0afdc6f48380f55a769c1b0", "filename": "src/test/ui/issues/issue-7813.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-7813.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fissues%2Fissue-7813.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7813.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,10 +1,13 @@\n error[E0282]: type annotations needed for `&[_; 0]`\n-  --> $DIR/issue-7813.rs:2:13\n+  --> $DIR/issue-7813.rs:2:9\n    |\n LL |     let v = &[];\n-   |         -   ^^^ cannot infer type\n-   |         |\n-   |         consider giving `v` the explicit type `&[_; 0]`, with the type parameters specified\n+   |         ^\n+   |\n+help: consider giving `v` an explicit type, where the placeholders `_` are specified\n+   |\n+LL |     let v: &[_; 0] = &[];\n+   |          +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "9eadb88a8ba814d6ce7b6fa01365f3f2571c0ac8", "filename": "src/test/ui/match/match-unresolved-one-arm.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/match-unresolved-one-arm.rs:4:9\n    |\n LL |     let x = match () {\n-   |         ^ consider giving `x` a type\n+   |         ^\n+   |\n+help: consider giving `x` an explicit type\n+   |\n+LL |     let x: _ = match () {\n+   |          +++\n \n error: aborting due to previous error\n "}, {"sha": "66e7ada3ac5fd9d43b20f7aba0cd4eb53d5b61fb", "filename": "src/test/ui/methods/method-ambig-one-trait-unknown-int-type.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,10 +1,13 @@\n error[E0282]: type annotations needed for `Vec<T>`\n-  --> $DIR/method-ambig-one-trait-unknown-int-type.rs:24:17\n+  --> $DIR/method-ambig-one-trait-unknown-int-type.rs:24:9\n    |\n LL |     let mut x = Vec::new();\n-   |         -----   ^^^^^^^^ cannot infer type for type parameter `T`\n-   |         |\n-   |         consider giving `x` the explicit type `Vec<T>`, where the type parameter `T` is specified\n+   |         ^^^^^\n+   |\n+help: consider giving `x` an explicit type, where the type for type parameter `T` is specified\n+   |\n+LL |     let mut x: Vec<T> = Vec::new();\n+   |              ++++++++\n \n error[E0283]: type annotations needed\n   --> $DIR/method-ambig-one-trait-unknown-int-type.rs:26:7"}, {"sha": "722539fca6b8e228686ef120c9b798bafe975ef9", "filename": "src/test/ui/missing/missing-items/missing-type-parameter.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fmissing-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fmissing-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fmissing-type-parameter.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,13 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/missing-type-parameter.rs:4:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for type parameter `X` declared on the function `foo`\n+   |     ^^^ cannot infer type of the type parameter `X` declared on the function `foo`\n    |\n-help: type parameter declared here\n-  --> $DIR/missing-type-parameter.rs:1:8\n+help: consider specifying the generic argument\n    |\n-LL | fn foo<X>() { }\n-   |        ^\n+LL |     foo::<X>();\n+   |        +++++\n \n error: aborting due to previous error\n "}, {"sha": "85c9fe409dbe9f68181902acc62d50267c5c24dd", "filename": "src/test/ui/parser/issues/issue-67377-invalid-syntax-in-enum-discriminant.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-67377-invalid-syntax-in-enum-discriminant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-67377-invalid-syntax-in-enum-discriminant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-67377-invalid-syntax-in-enum-discriminant.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -116,7 +116,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-67377-invalid-syntax-in-enum-discriminant.rs:26:14\n    |\n LL |         V = [Vec::new; { [0].len() ].len() as isize,\n-   |              ^^^^^^^^ cannot infer type for type parameter `T`\n+   |              ^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `Vec`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |         V = [Vec::<T>::new; { [0].len() ].len() as isize,\n+   |                 +++++\n \n error: aborting due to 14 previous errors\n "}, {"sha": "bad241634cbe62b94242286000ac42978cff6ef1", "filename": "src/test/ui/parser/missing-closing-angle-bracket-eq-constraint.stderr", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fparser%2Fmissing-closing-angle-bracket-eq-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fparser%2Fmissing-closing-angle-bracket-eq-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmissing-closing-angle-bracket-eq-constraint.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -40,24 +40,26 @@ LL |   let v : Vec<'a> = vec![];\n    |                 +\n \n error[E0282]: type annotations needed for `Vec<T>`\n-  --> $DIR/missing-closing-angle-bracket-eq-constraint.rs:7:25\n+  --> $DIR/missing-closing-angle-bracket-eq-constraint.rs:7:7\n    |\n LL |   let v : Vec<(u32,_) = vec![];\n-   |       -                 ^^^^^^ cannot infer type for type parameter `T`\n-   |       |\n-   |       consider giving `v` the explicit type `Vec<T>`, where the type parameter `T` is specified\n+   |       ^\n+   |\n+help: consider giving `v` an explicit type, where the type for type parameter `T` is specified\n    |\n-   = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL |   let v: Vec<T> : Vec<(u32,_) = vec![];\n+   |        ++++++++\n \n error[E0282]: type annotations needed for `Vec<T>`\n-  --> $DIR/missing-closing-angle-bracket-eq-constraint.rs:18:20\n+  --> $DIR/missing-closing-angle-bracket-eq-constraint.rs:18:7\n    |\n LL |   let v : Vec<'a = vec![];\n-   |       -            ^^^^^^ cannot infer type for type parameter `T`\n-   |       |\n-   |       consider giving `v` the explicit type `Vec<T>`, where the type parameter `T` is specified\n+   |       ^\n+   |\n+help: consider giving `v` an explicit type, where the type for type parameter `T` is specified\n    |\n-   = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL |   let v: Vec<T> : Vec<'a = vec![];\n+   |        ++++++++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "98481167a59d1c87ba7a21d706fdcb43608e946d", "filename": "src/test/ui/pattern/pat-tuple-bad-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,8 +1,8 @@\n fn main() {\n-    let x;\n+    let x; //~ ERROR type annotations needed\n \n     match x {\n-        (..) => {} //~ ERROR type annotations needed\n+        (..) => {}\n         _ => {}\n     }\n "}, {"sha": "11b28987848d6c0458cf830ac1e69ad545bdad80", "filename": "src/test/ui/pattern/pat-tuple-bad-type.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,13 +1,14 @@\n error[E0282]: type annotations needed\n-  --> $DIR/pat-tuple-bad-type.rs:5:9\n+  --> $DIR/pat-tuple-bad-type.rs:2:9\n    |\n LL |     let x;\n-   |         - consider giving `x` a type\n-...\n-LL |         (..) => {}\n-   |         ^^^^ cannot infer type\n+   |         ^\n    |\n    = note: type must be known at this point\n+help: consider giving `x` an explicit type\n+   |\n+LL |     let x: _;\n+   |          +++\n \n error[E0308]: mismatched types\n   --> $DIR/pat-tuple-bad-type.rs:10:9"}, {"sha": "e6a4e5f19b716ecd44949a0fe713ab756944fc41", "filename": "src/test/ui/pattern/rest-pat-semantic-disallowed.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -189,7 +189,12 @@ error[E0282]: type annotations needed\n   --> $DIR/rest-pat-semantic-disallowed.rs:33:9\n    |\n LL |     let x @ ..;\n-   |         ^^^^^^ consider giving this pattern a type\n+   |         ^^^^^^\n+   |\n+help: consider giving this pattern a type\n+   |\n+LL |     let x @ ..: _;\n+   |               +++\n \n error: aborting due to 23 previous errors\n "}, {"sha": "f839dd927db999b883504950badb49cf32a914e8", "filename": "src/test/ui/resolve/issue-85348.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -17,7 +17,12 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-85348.rs:6:13\n    |\n LL |         let mut N;\n-   |             ^^^^^ consider giving `N` a type\n+   |             ^^^^^\n+   |\n+help: consider giving `N` an explicit type\n+   |\n+LL |         let mut N: _;\n+   |                  +++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "cd3ffdc6f9d60c0ea1012c9a04e576c918170782", "filename": "src/test/ui/span/issue-42234-unknown-receiver-type.full.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.full.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,20 +1,26 @@\n-error[E0282]: type annotations needed for `Option<_>`\n-  --> $DIR/issue-42234-unknown-receiver-type.rs:10:7\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-42234-unknown-receiver-type.rs:9:24\n    |\n LL |     let x: Option<_> = None;\n-   |         - consider giving `x` the explicit type `Option<_>`, where the type parameter `T` is specified\n-LL |     x.unwrap().method_that_could_exist_on_some_type();\n-   |       ^^^^^^ cannot infer type for type parameter `T`\n+   |                        ^^^^ cannot infer type of the type parameter `T` declared on the enum `Option`\n    |\n    = note: type must be known at this point\n+help: consider specifying the generic argument\n+   |\n+LL |     let x: Option<_> = None::<T>;\n+   |                            +++++\n \n error[E0282]: type annotations needed\n-  --> $DIR/issue-42234-unknown-receiver-type.rs:16:10\n+  --> $DIR/issue-42234-unknown-receiver-type.rs:15:10\n    |\n LL |         .sum::<_>()\n-   |          ^^^ cannot infer type\n+   |          ^^^ cannot infer type of the type parameter `S` declared on the associated function `sum`\n    |\n    = note: type must be known at this point\n+help: consider specifying the generic argument\n+   |\n+LL |         .sum::<_>()\n+   |             ~~~~~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b6a3f07f5715f0a243beb7d3d2d37d3270039392", "filename": "src/test/ui/span/issue-42234-unknown-receiver-type.generic_arg.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.generic_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.generic_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.generic_arg.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,20 +1,26 @@\n-error[E0282]: type annotations needed for `Option<_>`\n-  --> $DIR/issue-42234-unknown-receiver-type.rs:10:7\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-42234-unknown-receiver-type.rs:9:24\n    |\n LL |     let x: Option<_> = None;\n-   |         - consider giving `x` the explicit type `Option<_>`, where the type parameter `T` is specified\n-LL |     x.unwrap().method_that_could_exist_on_some_type();\n-   |       ^^^^^^ cannot infer type for type parameter `T`\n+   |                        ^^^^ cannot infer type of the type parameter `T` declared on the enum `Option`\n    |\n    = note: type must be known at this point\n+help: consider specifying the generic argument\n+   |\n+LL |     let x: Option<_> = None::<T>;\n+   |                            +++++\n \n error[E0282]: type annotations needed\n-  --> $DIR/issue-42234-unknown-receiver-type.rs:16:16\n+  --> $DIR/issue-42234-unknown-receiver-type.rs:15:10\n    |\n LL |         .sum::<_>()\n-   |                ^ cannot infer type for type parameter `S` declared on the associated function `sum`\n+   |          ^^^ cannot infer type of the type parameter `S` declared on the associated function `sum`\n    |\n    = note: type must be known at this point\n+help: consider specifying the generic argument\n+   |\n+LL |         .sum::<S>()\n+   |             ~~~~~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fd53121204c78733598db7153501766b6456b178", "filename": "src/test/ui/span/issue-42234-unknown-receiver-type.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-42234-unknown-receiver-type.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -6,9 +6,8 @@\n // the fix of which this tests).\n \n fn shines_a_beacon_through_the_darkness() {\n-    let x: Option<_> = None;\n+    let x: Option<_> = None; //~ ERROR type annotations needed\n     x.unwrap().method_that_could_exist_on_some_type();\n-    //~^ ERROR type annotations needed\n }\n \n fn courier_to_des_moines_and_points_west(data: &[u32]) -> String {"}, {"sha": "a0f0d8810e5c7c6242d1d330e2248f8934767507", "filename": "src/test/ui/span/method-and-field-eager-resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Fmethod-and-field-eager-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Fmethod-and-field-eager-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmethod-and-field-eager-resolution.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,14 +2,14 @@\n \n fn main() {\n     let mut x = Default::default();\n-    x.0;\n     //~^ ERROR type annotations needed\n+    x.0;\n     x = 1;\n }\n \n fn foo() {\n     let mut x = Default::default();\n-    x[0];\n     //~^ ERROR type annotations needed\n+    x[0];\n     x = 1;\n }"}, {"sha": "2dd650f38ce394b92827a33dc477b14cc3519d82", "filename": "src/test/ui/span/method-and-field-eager-resolution.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Fmethod-and-field-eager-resolution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Fmethod-and-field-eager-resolution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmethod-and-field-eager-resolution.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,22 +1,26 @@\n error[E0282]: type annotations needed\n-  --> $DIR/method-and-field-eager-resolution.rs:5:5\n+  --> $DIR/method-and-field-eager-resolution.rs:4:9\n    |\n LL |     let mut x = Default::default();\n-   |         ----- consider giving `x` a type\n-LL |     x.0;\n-   |     ^ cannot infer type\n+   |         ^^^^^\n    |\n    = note: type must be known at this point\n+help: consider giving `x` an explicit type\n+   |\n+LL |     let mut x: _ = Default::default();\n+   |              +++\n \n error[E0282]: type annotations needed\n-  --> $DIR/method-and-field-eager-resolution.rs:12:5\n+  --> $DIR/method-and-field-eager-resolution.rs:11:9\n    |\n LL |     let mut x = Default::default();\n-   |         ----- consider giving `x` a type\n-LL |     x[0];\n-   |     ^ cannot infer type\n+   |         ^^^^^\n    |\n    = note: type must be known at this point\n+help: consider giving `x` an explicit type\n+   |\n+LL |     let mut x: _ = Default::default();\n+   |              +++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e4a8f7464626cd0a14fa39a1e5e8de9f2eff9bb6", "filename": "src/test/ui/span/type-annotations-needed-expr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,10 +2,10 @@ error[E0282]: type annotations needed\n   --> $DIR/type-annotations-needed-expr.rs:2:39\n    |\n LL |     let _ = (vec![1,2,3]).into_iter().sum() as f64;\n-   |                                       ^^^ cannot infer type for type parameter `S` declared on the associated function `sum`\n+   |                                       ^^^ cannot infer type of the type parameter `S` declared on the associated function `sum`\n    |\n    = note: type must be known at this point\n-help: consider specifying the type argument in the method call\n+help: consider specifying the generic argument\n    |\n LL |     let _ = (vec![1,2,3]).into_iter().sum::<S>() as f64;\n    |                                          +++++"}, {"sha": "bcc91b5cb4c56cba73b007766acbc7aa4656caca", "filename": "src/test/ui/suggestions/fn-needing-specified-return-type-param.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Ffn-needing-specified-return-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Ffn-needing-specified-return-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-needing-specified-return-type-param.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,5 +1,7 @@\n fn f<A>() -> A { unimplemented!() }\n fn foo() {\n-    let _ = f; //~ ERROR type annotations needed for `fn() -> A`\n+    let _ = f;\n+    //~^ ERROR type annotations needed\n+    //~| HELP consider specifying the generic argument\n }\n fn main() {}"}, {"sha": "9dea667fb961ed4e45304e40016b519e1a7890d8", "filename": "src/test/ui/suggestions/fn-needing-specified-return-type-param.stderr", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Ffn-needing-specified-return-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Ffn-needing-specified-return-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-needing-specified-return-type-param.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,16 +1,13 @@\n-error[E0282]: type annotations needed for `fn() -> A`\n+error[E0282]: type annotations needed\n   --> $DIR/fn-needing-specified-return-type-param.rs:3:13\n    |\n LL |     let _ = f;\n-   |         -   ^ cannot infer type for type parameter `A` declared on the function `f`\n-   |         |\n-   |         consider giving this pattern the explicit type `fn() -> A`, where the type parameter `A` is specified\n+   |             ^ cannot infer type of the type parameter `A` declared on the function `f`\n    |\n-help: type parameter declared here\n-  --> $DIR/fn-needing-specified-return-type-param.rs:1:6\n+help: consider specifying the generic argument\n    |\n-LL | fn f<A>() -> A { unimplemented!() }\n-   |      ^\n+LL |     let _ = f::<A>;\n+   |              +++++\n \n error: aborting due to previous error\n "}, {"sha": "8bb4219039b9392a0da56c9a1a45eff5453d98d1", "filename": "src/test/ui/suggestions/suggest-closure-return-type-1.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,3 +1,7 @@\n+fn unbound_drop(_: impl Sized) {}\n+\n fn main() {\n-    let _v = || -> _ { [] }; //~ ERROR type annotations needed for the closure\n+    unbound_drop(|| -> _ { [] });\n+    //~^ ERROR type annotations needed for `[_; 0]`\n+    //~| HELP try giving this closure an explicit return type\n }"}, {"sha": "3116211b52c9075307bb2478c166684e2fb0a9ff", "filename": "src/test/ui/suggestions/suggest-closure-return-type-1.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,13 +1,13 @@\n-error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n-  --> $DIR/suggest-closure-return-type-1.rs:2:24\n+error[E0282]: type annotations needed for `[_; 0]`\n+  --> $DIR/suggest-closure-return-type-1.rs:4:18\n    |\n-LL |     let _v = || -> _ { [] };\n-   |                        ^^ cannot infer type\n+LL |     unbound_drop(|| -> _ { [] });\n+   |                  ^^^^^^^\n    |\n-help: give this closure an explicit return type without `_` placeholders\n+help: try giving this closure an explicit return type\n    |\n-LL |     let _v = || -> [_; 0] { [] };\n-   |                    ~~~~~~\n+LL |     unbound_drop(|| -> [_; 0] { [] });\n+   |                        ~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "25ed1882e8d2d1742265104a131f92769bc72019", "filename": "src/test/ui/suggestions/suggest-closure-return-type-2.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,3 +1,7 @@\n+fn unbound_drop(_: impl Sized) {}\n+\n fn main() {\n-    let _v = || { [] }; //~ ERROR type annotations needed for the closure\n+    unbound_drop(|| { [] })\n+    //~^ ERROR type annotations needed for `[_; 0]`\n+    //~| HELP try giving this closure an explicit return type\n }"}, {"sha": "f368e7de467ca94847bf76348afb3d36604b783b", "filename": "src/test/ui/suggestions/suggest-closure-return-type-2.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,13 +1,13 @@\n-error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n-  --> $DIR/suggest-closure-return-type-2.rs:2:19\n+error[E0282]: type annotations needed for `[_; 0]`\n+  --> $DIR/suggest-closure-return-type-2.rs:4:18\n    |\n-LL |     let _v = || { [] };\n-   |                   ^^ cannot infer type\n+LL |     unbound_drop(|| { [] })\n+   |                  ^^\n    |\n-help: give this closure an explicit return type without `_` placeholders\n+help: try giving this closure an explicit return type\n    |\n-LL |     let _v = || -> [_; 0] { [] };\n-   |                 +++++++++\n+LL |     unbound_drop(|| -> [_; 0] { [] })\n+   |                     +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "3de6c55cf1696600667748e6277522e0bfa12401", "filename": "src/test/ui/suggestions/suggest-closure-return-type-3.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,3 +1,7 @@\n+fn unbound_drop(_: impl Sized) {}\n+\n fn main() {\n-    let _v = || []; //~ ERROR type annotations needed for the closure\n+    unbound_drop(|| []);\n+    //~^ ERROR type annotations needed for `[_; 0]`\n+    //~| HELP try giving this closure an explicit return type\n }"}, {"sha": "417693215335374404536e7a0bd96a42d39fac13", "filename": "src/test/ui/suggestions/suggest-closure-return-type-3.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,13 +1,13 @@\n-error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n-  --> $DIR/suggest-closure-return-type-3.rs:2:17\n+error[E0282]: type annotations needed for `[_; 0]`\n+  --> $DIR/suggest-closure-return-type-3.rs:4:18\n    |\n-LL |     let _v = || [];\n-   |                 ^^ cannot infer type\n+LL |     unbound_drop(|| []);\n+   |                  ^^\n    |\n-help: give this closure an explicit return type without `_` placeholders\n+help: try giving this closure an explicit return type\n    |\n-LL |     let _v = || -> [_; 0] { [] };\n-   |                 +++++++++++    +\n+LL |     unbound_drop(|| -> [_; 0] { [] });\n+   |                     +++++++++++    +\n \n error: aborting due to previous error\n "}, {"sha": "57b2587ae5ccd02a4b3dd2b1e3f9859b530890ed", "filename": "src/test/ui/traits/do-not-mention-type-params-by-name-in-suggestion-issue-96292.stderr", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fdo-not-mention-type-params-by-name-in-suggestion-issue-96292.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fdo-not-mention-type-params-by-name-in-suggestion-issue-96292.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdo-not-mention-type-params-by-name-in-suggestion-issue-96292.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,19 +2,18 @@ error[E0282]: type annotations needed\n   --> $DIR/do-not-mention-type-params-by-name-in-suggestion-issue-96292.rs:17:11\n    |\n LL |     thing.method(42);\n-   |     ------^^^^^^----\n-   |     |     |\n-   |     |     cannot infer type for type parameter `T` declared on the trait `Method`\n-   |     this method call resolves to `T`\n+   |           ^^^^^^\n+   |\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing<bool> as Method<T>>::method(thing, 42);\n+   |     +++++++++++++++++++++++++++++++++++     ~\n \n error[E0283]: type annotations needed\n   --> $DIR/do-not-mention-type-params-by-name-in-suggestion-issue-96292.rs:17:11\n    |\n LL |     thing.method(42);\n-   |     ------^^^^^^----\n-   |     |     |\n-   |     |     cannot infer type for type parameter `T` declared on the trait `Method`\n-   |     this method call resolves to `T`\n+   |           ^^^^^^\n    |\n note: multiple `impl`s satisfying `Thing<bool>: Method<_>` found\n   --> $DIR/do-not-mention-type-params-by-name-in-suggestion-issue-96292.rs:7:1\n@@ -24,12 +23,10 @@ LL | impl<X> Method<i32> for Thing<X> {\n ...\n LL | impl<X> Method<u32> for Thing<X> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: use the fully qualified path for the potential candidates\n+help: try using a fully qualified path to specify the expected types\n    |\n-LL |     <Thing<_> as Method<i32>>::method(thing, 42);\n-   |     ++++++++++++++++++++++++++++++++++     ~\n-LL |     <Thing<_> as Method<u32>>::method(thing, 42);\n-   |     ++++++++++++++++++++++++++++++++++     ~\n+LL |     <Thing<bool> as Method<T>>::method(thing, 42);\n+   |     +++++++++++++++++++++++++++++++++++     ~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5aa42b5b1d3edeee9eb51ac90d4bee10a7556fa2", "filename": "src/test/ui/traits/issue-77982.stderr", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-77982.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,9 +2,7 @@ error[E0283]: type annotations needed\n   --> $DIR/issue-77982.rs:8:10\n    |\n LL |     opts.get(opt.as_ref());\n-   |          ^^^ ------------ this method call resolves to `&T`\n-   |          |\n-   |          cannot infer type for type parameter `Q` declared on the associated function `get`\n+   |          ^^^ cannot infer type of the type parameter `Q` declared on the associated function `get`\n    |\n    = note: multiple `impl`s satisfying `String: Borrow<_>` found in the following crates: `alloc`, `core`:\n            - impl Borrow<str> for String;\n@@ -15,59 +13,53 @@ note: required by a bound in `HashMap::<K, V, S>::get`\n    |\n LL |         K: Borrow<Q>,\n    |            ^^^^^^^^^ required by this bound in `HashMap::<K, V, S>::get`\n+help: consider specifying the generic argument\n+   |\n+LL |     opts.get::<Q>(opt.as_ref());\n+   |             +++++\n help: consider specifying the type argument in the function call\n    |\n LL |     opts.get::<Q>(opt.as_ref());\n    |             +++++\n \n error[E0283]: type annotations needed\n-  --> $DIR/issue-77982.rs:8:18\n+  --> $DIR/issue-77982.rs:8:10\n    |\n LL |     opts.get(opt.as_ref());\n-   |              ----^^^^^^--\n-   |              |   |\n-   |              |   cannot infer type for type parameter `T` declared on the trait `AsRef`\n-   |              this method call resolves to `&T`\n+   |          ^^^ cannot infer type of the type parameter `Q` declared on the associated function `get`\n    |\n    = note: multiple `impl`s satisfying `String: AsRef<_>` found in the following crates: `alloc`, `std`:\n            - impl AsRef<OsStr> for String;\n            - impl AsRef<Path> for String;\n            - impl AsRef<[u8]> for String;\n            - impl AsRef<str> for String;\n-help: use the fully qualified path for the potential candidates\n-   |\n-LL |     opts.get(<String as AsRef<OsStr>>::as_ref(opt));\n-   |              +++++++++++++++++++++++++++++++++   ~\n-LL |     opts.get(<String as AsRef<Path>>::as_ref(opt));\n-   |              ++++++++++++++++++++++++++++++++   ~\n-LL |     opts.get(<String as AsRef<[u8]>>::as_ref(opt));\n-   |              ++++++++++++++++++++++++++++++++   ~\n-LL |     opts.get(<String as AsRef<str>>::as_ref(opt));\n-   |              +++++++++++++++++++++++++++++++   ~\n-     and 4 other candidates\n+help: consider specifying the generic argument\n+   |\n+LL |     opts.get::<Q>(opt.as_ref());\n+   |             +++++\n \n error[E0283]: type annotations needed\n-  --> $DIR/issue-77982.rs:13:44\n+  --> $DIR/issue-77982.rs:13:59\n    |\n LL |     let ips: Vec<_> = (0..100_000).map(|_| u32::from(0u32.into())).collect();\n-   |                                            ^^^^^^^^^ ----------- this method call resolves to `T`\n-   |                                            |\n-   |                                            cannot infer type for type parameter `T` declared on the trait `From`\n+   |                                                           ^^^^\n    |\n    = note: multiple `impl`s satisfying `u32: From<_>` found in the following crates: `core`, `std`:\n            - impl From<Ipv4Addr> for u32;\n            - impl From<NonZeroU32> for u32;\n            - impl From<bool> for u32;\n            - impl From<char> for u32;\n            and 3 more\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     let ips: Vec<_> = (0..100_000).map(|_| u32::from(<u32 as Into<T>>::into(0u32))).collect();\n+   |                                                      +++++++++++++++++++++++    ~\n \n error[E0283]: type annotations needed for `Box<T>`\n-  --> $DIR/issue-77982.rs:36:16\n+  --> $DIR/issue-77982.rs:36:9\n    |\n LL |     let _ = ().foo();\n-   |         -      ^^^ cannot infer type for type parameter `T` declared on the trait `Foo`\n-   |         |\n-   |         consider giving this pattern the explicit type `Box<T>`, where the type parameter `T` is specified\n+   |         ^\n    |\n note: multiple `impl`s satisfying `(): Foo<'_, _>` found\n   --> $DIR/issue-77982.rs:29:1\n@@ -76,14 +68,16 @@ LL | impl Foo<'static, u32> for () {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL | impl<'a> Foo<'a, i16> for () {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider giving this pattern a type, where the type for type parameter `T` is specified\n+   |\n+LL |     let _: Box<T> = ().foo();\n+   |          ++++++++\n \n error[E0283]: type annotations needed for `Box<T>`\n-  --> $DIR/issue-77982.rs:40:19\n+  --> $DIR/issue-77982.rs:40:9\n    |\n LL |     let _ = (&()).bar();\n-   |         -         ^^^ cannot infer type for type parameter `T` declared on the trait `Bar`\n-   |         |\n-   |         consider giving this pattern the explicit type `Box<T>`, where the type parameter `T` is specified\n+   |         ^\n    |\n note: multiple `impl`s satisfying `&(): Bar<'_, _>` found\n   --> $DIR/issue-77982.rs:32:1\n@@ -92,6 +86,10 @@ LL | impl<'a> Bar<'static, u32> for &'a () {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL | impl<'a> Bar<'a, i16> for &'a () {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider giving this pattern a type, where the type for type parameter `T` is specified\n+   |\n+LL |     let _: Box<T> = (&()).bar();\n+   |          ++++++++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "25f8d5383776de0a9cdfd06ea418b2d0ad683756", "filename": "src/test/ui/traits/multidispatch-convert-ambig-dest.stderr", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fmultidispatch-convert-ambig-dest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fmultidispatch-convert-ambig-dest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fmultidispatch-convert-ambig-dest.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,25 +2,19 @@ error[E0282]: type annotations needed\n   --> $DIR/multidispatch-convert-ambig-dest.rs:26:5\n    |\n LL |     test(22, std::default::Default::default());\n-   |     ^^^^ cannot infer type for type parameter `U` declared on the function `test`\n+   |     ^^^^ cannot infer type of the type parameter `U` declared on the function `test`\n    |\n-help: type parameter declared here\n-  --> $DIR/multidispatch-convert-ambig-dest.rs:20:11\n+help: consider specifying the generic arguments\n    |\n-LL | fn test<T,U>(_: T, _: U)\n-   |           ^\n+LL |     test::<i32, U>(22, std::default::Default::default());\n+   |         ++++++++++\n \n error[E0283]: type annotations needed\n   --> $DIR/multidispatch-convert-ambig-dest.rs:26:5\n    |\n LL |     test(22, std::default::Default::default());\n-   |     ^^^^ cannot infer type for type parameter `U` declared on the function `test`\n-   |\n-help: type parameter declared here\n-  --> $DIR/multidispatch-convert-ambig-dest.rs:20:11\n+   |     ^^^^ cannot infer type of the type parameter `U` declared on the function `test`\n    |\n-LL | fn test<T,U>(_: T, _: U)\n-   |           ^\n note: multiple `impl`s satisfying `i32: Convert<_>` found\n   --> $DIR/multidispatch-convert-ambig-dest.rs:8:1\n    |\n@@ -36,6 +30,10 @@ LL | fn test<T,U>(_: T, _: U)\n    |    ---- required by a bound in this\n LL | where T : Convert<U>\n    |           ^^^^^^^^^^ required by this bound in `test`\n+help: consider specifying the generic arguments\n+   |\n+LL |     test::<i32, U>(22, std::default::Default::default());\n+   |         ++++++++++\n help: consider specifying the type arguments in the function call\n    |\n LL |     test::<T, U>(22, std::default::Default::default());"}, {"sha": "75d45d9052b46359f1ca5b06fe33ec3e5bb990ee", "filename": "src/test/ui/traits/not-suggest-non-existing-fully-qualified-path.stderr", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fnot-suggest-non-existing-fully-qualified-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fnot-suggest-non-existing-fully-qualified-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnot-suggest-non-existing-fully-qualified-path.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,25 +2,19 @@ error[E0282]: type annotations needed\n   --> $DIR/not-suggest-non-existing-fully-qualified-path.rs:21:7\n    |\n LL |     a.method();\n-   |     --^^^^^^--\n-   |     | |\n-   |     | cannot infer type for type parameter `U` declared on the trait `V`\n-   |     this method call resolves to `U`\n+   |       ^^^^^^\n+   |\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <A<B> as V<U>>::method(a);\n+   |     +++++++++++++++++++++++ ~\n \n error[E0283]: type annotations needed\n   --> $DIR/not-suggest-non-existing-fully-qualified-path.rs:21:7\n    |\n LL |     a.method();\n-   |     --^^^^^^--\n-   |     | |\n-   |     | cannot infer type for type parameter `U`\n-   |     this method call resolves to `U`\n-   |\n-help: type parameter declared here\n-  --> $DIR/not-suggest-non-existing-fully-qualified-path.rs:12:9\n+   |       ^^^^^^\n    |\n-LL | impl<T, U> V<U> for A<T>\n-   |         ^\n note: multiple `impl`s satisfying `B: I<_>` found\n   --> $DIR/not-suggest-non-existing-fully-qualified-path.rs:5:1\n    |\n@@ -33,6 +27,10 @@ note: required because of the requirements on the impl of `V<_>` for `A<B>`\n    |\n LL | impl<T, U> V<U> for A<T>\n    |            ^^^^     ^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <A<B> as V<U>>::method(a);\n+   |     +++++++++++++++++++++++ ~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9a2cf469d08e4a83be96b75ee94dad3e29f27b68", "filename": "src/test/ui/traits/suggest-fully-qualified-path-with-adjustment.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-adjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-adjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-adjustment.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -0,0 +1,60 @@\n+use std::ops::{Deref, DerefMut};\n+\n+struct Thing;\n+\n+trait Method<T> {\n+    fn method(&self) -> T;\n+    fn mut_method(&mut self) -> T;\n+}\n+\n+impl Method<i32> for Thing {\n+    fn method(&self) -> i32 { 0 }\n+    fn mut_method(&mut self) -> i32 { 0 }\n+}\n+\n+impl Method<u32> for Thing {\n+    fn method(&self) -> u32 { 0 }\n+    fn mut_method(&mut self) -> u32 { 0 }\n+}\n+trait MethodRef<T> {\n+    fn by_self(self);\n+}\n+impl MethodRef<i32> for &Thing {\n+    fn by_self(self) {}\n+}\n+impl MethodRef<u32> for &Thing {\n+    fn by_self(self) {}\n+}\n+\n+\n+struct DerefsTo<T>(T);\n+impl<T> Deref for DerefsTo<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl<T> DerefMut for DerefsTo<T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+fn main() {\n+    let mut thing = Thing;\n+    thing.method();\n+    //~^ ERROR type annotations needed\n+    //~| ERROR type annotations needed\n+    thing.mut_method(); //~ ERROR type annotations needed\n+    thing.by_self(); //~ ERROR type annotations needed\n+\n+    let mut deref_to = DerefsTo(Thing);\n+    deref_to.method(); //~ ERROR type annotations needed\n+    deref_to.mut_method(); //~ ERROR type annotations needed\n+    deref_to.by_self(); //~ ERROR type annotations needed\n+\n+    let mut deref_deref_to = DerefsTo(DerefsTo(Thing));\n+    deref_deref_to.method(); //~ ERROR type annotations needed\n+    deref_deref_to.mut_method(); //~ ERROR type annotations needed\n+    deref_deref_to.by_self(); //~ ERROR type annotations needed\n+}"}, {"sha": "68b31a1ca34e30d7bd3a11b8e277b4e4c030a760", "filename": "src/test/ui/traits/suggest-fully-qualified-path-with-adjustment.stderr", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-adjustment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-adjustment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-adjustment.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -0,0 +1,186 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:45:11\n+   |\n+LL |     thing.method();\n+   |           ^^^^^^\n+   |\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::method(&thing);\n+   |     ++++++++++++++++++++++++++++++     ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:45:11\n+   |\n+LL |     thing.method();\n+   |           ^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::method(&thing);\n+   |     ++++++++++++++++++++++++++++++     ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:48:11\n+   |\n+LL |     thing.mut_method();\n+   |           ^^^^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::mut_method(&mut thing);\n+   |     +++++++++++++++++++++++++++++++++++++      ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:49:11\n+   |\n+LL |     thing.by_self();\n+   |           ^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&Thing: MethodRef<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:22:1\n+   |\n+LL | impl MethodRef<i32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl MethodRef<u32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <&Thing as MethodRef<T>>::by_self(&thing);\n+   |     +++++++++++++++++++++++++++++++++++     ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:52:14\n+   |\n+LL |     deref_to.method();\n+   |              ^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::method(&deref_to);\n+   |     ++++++++++++++++++++++++++++++        ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:53:14\n+   |\n+LL |     deref_to.mut_method();\n+   |              ^^^^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::mut_method(&mut deref_to);\n+   |     +++++++++++++++++++++++++++++++++++++         ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:54:14\n+   |\n+LL |     deref_to.by_self();\n+   |              ^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&Thing: MethodRef<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:22:1\n+   |\n+LL | impl MethodRef<i32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl MethodRef<u32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <&Thing as MethodRef<T>>::by_self(&deref_to);\n+   |     +++++++++++++++++++++++++++++++++++        ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:57:20\n+   |\n+LL |     deref_deref_to.method();\n+   |                    ^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::method(&deref_deref_to);\n+   |     ++++++++++++++++++++++++++++++              ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:58:20\n+   |\n+LL |     deref_deref_to.mut_method();\n+   |                    ^^^^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::mut_method(&mut deref_deref_to);\n+   |     +++++++++++++++++++++++++++++++++++++               ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:59:20\n+   |\n+LL |     deref_deref_to.by_self();\n+   |                    ^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&Thing: MethodRef<_>` found\n+  --> $DIR/suggest-fully-qualified-path-with-adjustment.rs:22:1\n+   |\n+LL | impl MethodRef<i32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl MethodRef<u32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <&Thing as MethodRef<T>>::by_self(&deref_deref_to);\n+   |     +++++++++++++++++++++++++++++++++++              ~\n+\n+error: aborting due to 10 previous errors\n+\n+Some errors have detailed explanations: E0282, E0283.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "da68b996be999df60ade17d648d78960cd56c9ec", "filename": "src/test/ui/traits/suggest-fully-qualified-path-with-appropriate-params.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/72f7e3144a386c820c188350092d2d93a74889b8/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72f7e3144a386c820c188350092d2d93a74889b8/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.rs?ref=72f7e3144a386c820c188350092d2d93a74889b8", "patch": "@@ -1,24 +0,0 @@\n-struct Thing;\n-\n-trait Method<T> {\n-    fn method(&self) -> T;\n-    fn mut_method(&mut self) -> T;\n-}\n-\n-impl Method<i32> for Thing {\n-    fn method(&self) -> i32 { 0 }\n-    fn mut_method(&mut self) -> i32 { 0 }\n-}\n-\n-impl Method<u32> for Thing {\n-    fn method(&self) -> u32 { 0 }\n-    fn mut_method(&mut self) -> u32 { 0 }\n-}\n-\n-fn main() {\n-    let thing = Thing;\n-    thing.method();\n-    //~^ ERROR type annotations needed\n-    //~| ERROR type annotations needed\n-    thing.mut_method(); //~ ERROR type annotations needed\n-}"}, {"sha": "0c4962417e9bc152e2544744a8089f99de7ea149", "filename": "src/test/ui/traits/suggest-fully-qualified-path-with-appropriate-params.stderr", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/72f7e3144a386c820c188350092d2d93a74889b8/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72f7e3144a386c820c188350092d2d93a74889b8/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-with-appropriate-params.stderr?ref=72f7e3144a386c820c188350092d2d93a74889b8", "patch": "@@ -1,61 +0,0 @@\n-error[E0282]: type annotations needed\n-  --> $DIR/suggest-fully-qualified-path-with-appropriate-params.rs:20:11\n-   |\n-LL |     thing.method();\n-   |     ------^^^^^^--\n-   |     |     |\n-   |     |     cannot infer type for type parameter `T` declared on the trait `Method`\n-   |     this method call resolves to `T`\n-\n-error[E0283]: type annotations needed\n-  --> $DIR/suggest-fully-qualified-path-with-appropriate-params.rs:20:11\n-   |\n-LL |     thing.method();\n-   |     ------^^^^^^--\n-   |     |     |\n-   |     |     cannot infer type for type parameter `T` declared on the trait `Method`\n-   |     this method call resolves to `T`\n-   |\n-note: multiple `impl`s satisfying `Thing: Method<_>` found\n-  --> $DIR/suggest-fully-qualified-path-with-appropriate-params.rs:8:1\n-   |\n-LL | impl Method<i32> for Thing {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-...\n-LL | impl Method<u32> for Thing {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: use the fully qualified path for the potential candidates\n-   |\n-LL |     <Thing as Method<i32>>::method(&thing);\n-   |     ++++++++++++++++++++++++++++++++     ~\n-LL |     <Thing as Method<u32>>::method(&thing);\n-   |     ++++++++++++++++++++++++++++++++     ~\n-\n-error[E0283]: type annotations needed\n-  --> $DIR/suggest-fully-qualified-path-with-appropriate-params.rs:23:11\n-   |\n-LL |     thing.mut_method();\n-   |     ------^^^^^^^^^^--\n-   |     |     |\n-   |     |     cannot infer type for type parameter `T` declared on the trait `Method`\n-   |     this method call resolves to `T`\n-   |\n-note: multiple `impl`s satisfying `Thing: Method<_>` found\n-  --> $DIR/suggest-fully-qualified-path-with-appropriate-params.rs:8:1\n-   |\n-LL | impl Method<i32> for Thing {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-...\n-LL | impl Method<u32> for Thing {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: use the fully qualified path for the potential candidates\n-   |\n-LL |     <Thing as Method<i32>>::mut_method(&mut thing);\n-   |     +++++++++++++++++++++++++++++++++++++++      ~\n-LL |     <Thing as Method<u32>>::mut_method(&mut thing);\n-   |     +++++++++++++++++++++++++++++++++++++++      ~\n-\n-error: aborting due to 3 previous errors\n-\n-Some errors have detailed explanations: E0282, E0283.\n-For more information about an error, try `rustc --explain E0282`."}, {"sha": "da640c8c8c26a883638ee2fe48a58c59fa8e5f04", "filename": "src/test/ui/traits/suggest-fully-qualified-path-without-adjustment.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-without-adjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-without-adjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-without-adjustment.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -0,0 +1,64 @@\n+use std::ops::{Deref, DerefMut};\n+\n+struct Thing;\n+\n+trait Method<T> {\n+    fn method(&self) -> T;\n+    fn mut_method(&mut self) -> T;\n+}\n+\n+impl Method<i32> for Thing {\n+    fn method(&self) -> i32 { 0 }\n+    fn mut_method(&mut self) -> i32 { 0 }\n+}\n+\n+impl Method<u32> for Thing {\n+    fn method(&self) -> u32 { 0 }\n+    fn mut_method(&mut self) -> u32 { 0 }\n+}\n+\n+trait MethodRef<T> {\n+    fn by_self(self);\n+}\n+impl MethodRef<i32> for &Thing {\n+    fn by_self(self) {}\n+}\n+impl MethodRef<u32> for &Thing {\n+    fn by_self(self) {}\n+}\n+\n+struct DerefsTo<T>(T);\n+impl<T> Deref for DerefsTo<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+impl<T> DerefMut for DerefsTo<T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+fn main() {\n+    let mut ref_thing = &Thing;\n+    ref_thing.method();\n+    //~^ ERROR type annotations needed\n+    //~| ERROR type annotations needed\n+    ref_thing.by_self(); //~ ERROR type annotations needed\n+\n+    let mut mut_thing = &mut Thing;\n+    mut_thing.method(); //~ ERROR type annotations needed\n+    mut_thing.mut_method(); //~ ERROR type annotations needed\n+    mut_thing.by_self(); //~ ERROR type annotations needed\n+\n+    let mut deref_to = &DerefsTo(Thing);\n+    deref_to.method(); //~ ERROR type annotations needed\n+    deref_to.mut_method(); //~ ERROR type annotations needed\n+    deref_to.by_self(); //~ ERROR type annotations needed\n+\n+    let mut deref_deref_to = &DerefsTo(DerefsTo(Thing));\n+    deref_deref_to.method(); //~ ERROR type annotations needed\n+    deref_deref_to.mut_method(); //~ ERROR type annotations needed\n+    deref_deref_to.by_self(); //~ ERROR type annotations needed\n+}"}, {"sha": "27518a54e7507d221137b7edd331221f8dc06ff1", "filename": "src/test/ui/traits/suggest-fully-qualified-path-without-adjustment.stderr", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-without-adjustment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-without-adjustment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-fully-qualified-path-without-adjustment.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -0,0 +1,224 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:45:15\n+   |\n+LL |     ref_thing.method();\n+   |               ^^^^^^\n+   |\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::method(ref_thing);\n+   |     +++++++++++++++++++++++++++++         ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:45:15\n+   |\n+LL |     ref_thing.method();\n+   |               ^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::method(ref_thing);\n+   |     +++++++++++++++++++++++++++++         ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:48:15\n+   |\n+LL |     ref_thing.by_self();\n+   |               ^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&Thing: MethodRef<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:23:1\n+   |\n+LL | impl MethodRef<i32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl MethodRef<u32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <&Thing as MethodRef<T>>::by_self(ref_thing);\n+   |     ++++++++++++++++++++++++++++++++++         ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:51:15\n+   |\n+LL |     mut_thing.method();\n+   |               ^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::method(mut_thing);\n+   |     +++++++++++++++++++++++++++++         ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:52:15\n+   |\n+LL |     mut_thing.mut_method();\n+   |               ^^^^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::mut_method(mut_thing);\n+   |     +++++++++++++++++++++++++++++++++         ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:53:15\n+   |\n+LL |     mut_thing.by_self();\n+   |               ^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&Thing: MethodRef<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:23:1\n+   |\n+LL | impl MethodRef<i32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl MethodRef<u32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <&Thing as MethodRef<T>>::by_self(mut_thing);\n+   |     ++++++++++++++++++++++++++++++++++         ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:56:14\n+   |\n+LL |     deref_to.method();\n+   |              ^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::method(deref_to);\n+   |     +++++++++++++++++++++++++++++        ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:57:14\n+   |\n+LL |     deref_to.mut_method();\n+   |              ^^^^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::mut_method(deref_to);\n+   |     +++++++++++++++++++++++++++++++++        ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:58:14\n+   |\n+LL |     deref_to.by_self();\n+   |              ^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&Thing: MethodRef<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:23:1\n+   |\n+LL | impl MethodRef<i32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl MethodRef<u32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <&Thing as MethodRef<T>>::by_self(deref_to);\n+   |     ++++++++++++++++++++++++++++++++++        ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:61:20\n+   |\n+LL |     deref_deref_to.method();\n+   |                    ^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::method(deref_deref_to);\n+   |     +++++++++++++++++++++++++++++              ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:62:20\n+   |\n+LL |     deref_deref_to.mut_method();\n+   |                    ^^^^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `Thing: Method<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:10:1\n+   |\n+LL | impl Method<i32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl Method<u32> for Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Thing as Method<T>>::mut_method(deref_deref_to);\n+   |     +++++++++++++++++++++++++++++++++              ~\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:63:20\n+   |\n+LL |     deref_deref_to.by_self();\n+   |                    ^^^^^^^\n+   |\n+note: multiple `impl`s satisfying `&Thing: MethodRef<_>` found\n+  --> $DIR/suggest-fully-qualified-path-without-adjustment.rs:23:1\n+   |\n+LL | impl MethodRef<i32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | impl MethodRef<u32> for &Thing {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <&Thing as MethodRef<T>>::by_self(deref_deref_to);\n+   |     ++++++++++++++++++++++++++++++++++              ~\n+\n+error: aborting due to 12 previous errors\n+\n+Some errors have detailed explanations: E0282, E0283.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "b3ca260894bc8e14094fac321a0921974c3298d0", "filename": "src/test/ui/type-alias-impl-trait/closures_in_branches.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,9 +2,13 @@ error[E0282]: type annotations needed\n   --> $DIR/closures_in_branches.rs:21:10\n    |\n LL |         |x| x.len()\n-   |          ^ consider giving this closure parameter a type\n+   |          ^\n    |\n    = note: type must be known at this point\n+help: consider giving this closure parameter an explicit type\n+   |\n+LL |         |x: _| x.len()\n+   |           +++\n \n error: aborting due to previous error\n "}, {"sha": "9a0e71b4eed90d8cfd65f7768fe15688bc3606b1", "filename": "src/test/ui/type-alias-impl-trait/incomplete-inference.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincomplete-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincomplete-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincomplete-inference.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/incomplete-inference.rs:6:5\n    |\n LL |     None\n-   |     ^^^^ cannot infer type for type parameter `T` declared on the enum `Option`\n+   |     ^^^^ cannot infer type of the type parameter `T` declared on the enum `Option`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     None::<T>\n+   |         +++++\n \n error: aborting due to previous error\n "}, {"sha": "6ac63a91ee9ac546637a527aa15d071bdcc688fc", "filename": "src/test/ui/type-inference/or_else-multiple-type-params.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,13 +1,13 @@\n-error[E0282]: type annotations needed\n-  --> $DIR/or_else-multiple-type-params.rs:7:10\n+error[E0282]: type annotations needed for `Result<Child, F>`\n+  --> $DIR/or_else-multiple-type-params.rs:7:18\n    |\n LL |         .or_else(|err| {\n-   |          ^^^^^^^ cannot infer type for type parameter `F` declared on the associated function `or_else`\n+   |                  ^^^^^\n    |\n-help: consider specifying the type arguments in the method call\n+help: try giving this closure an explicit return type\n    |\n-LL |         .or_else::<F, O>(|err| {\n-   |                 ++++++++\n+LL |         .or_else(|err| -> Result<Child, F> {\n+   |                        +++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "0a48d5756eb41b8671ad2a604c4ff5d94f019509", "filename": "src/test/ui/type-inference/sort_by_key.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,10 +1,10 @@\n error[E0282]: type annotations needed\n-  --> $DIR/sort_by_key.rs:3:9\n+  --> $DIR/sort_by_key.rs:3:40\n    |\n LL |     lst.sort_by_key(|&(v, _)| v.iter().sum());\n-   |         ^^^^^^^^^^^ cannot infer type for type parameter `K` declared on the associated function `sort_by_key`\n+   |                                        ^^^ cannot infer type of the type parameter `S` declared on the associated function `sum`\n    |\n-help: consider specifying the type argument in the method call\n+help: consider specifying the generic argument\n    |\n LL |     lst.sort_by_key(|&(v, _)| v.iter().sum::<S>());\n    |                                           +++++"}, {"sha": "e0fecc72f30928c68bb0e8f6be80b30836123af3", "filename": "src/test/ui/type-inference/unbounded-associated-type.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,14 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/unbounded-associated-type.rs:15:5\n+  --> $DIR/unbounded-associated-type.rs:15:7\n    |\n-LL |     type A;\n-   |     ------- `<Self as T>::A` defined here\n-...\n LL |     S(std::marker::PhantomData).foo();\n-   |     ^--------------------------------\n-   |     |\n-   |     this method call resolves to `<Self as T>::A`\n-   |     cannot infer type for type parameter `X` declared on the struct `S`\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `PhantomData`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     S(std::marker::PhantomData::<T>).foo();\n+   |                               +++++\n \n error: aborting due to previous error\n "}, {"sha": "209abfe5cba49157750464c42ac736caf7b521c5", "filename": "src/test/ui/type-inference/unbounded-type-param-in-fn-with-assoc-type.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,13 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/unbounded-type-param-in-fn-with-assoc-type.rs:8:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `foo`\n+   |     ^^^ cannot infer type of the type parameter `T` declared on the function `foo`\n    |\n-help: type parameter declared here\n-  --> $DIR/unbounded-type-param-in-fn-with-assoc-type.rs:3:8\n+help: consider specifying the generic arguments\n    |\n-LL | fn foo<T, U = u64>() -> (T, U) {\n-   |        ^\n+LL |     foo::<T, U>();\n+   |        ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "d92892eeb84eda01096f4091e8c825897287c92f", "filename": "src/test/ui/type-inference/unbounded-type-param-in-fn.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,13 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/unbounded-type-param-in-fn.rs:6:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `foo`\n+   |     ^^^ cannot infer type of the type parameter `T` declared on the function `foo`\n    |\n-help: type parameter declared here\n-  --> $DIR/unbounded-type-param-in-fn.rs:1:8\n+help: consider specifying the generic argument\n    |\n-LL | fn foo<T>() -> T {\n-   |        ^\n+LL |     foo::<T>();\n+   |        +++++\n \n error: aborting due to previous error\n "}, {"sha": "7d7890c8b80972fd9924a8ca00ce594dc530cd37", "filename": "src/test/ui/type/type-annotation-needed.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,19 +2,18 @@ error[E0283]: type annotations needed\n   --> $DIR/type-annotation-needed.rs:6:5\n    |\n LL |     foo(42);\n-   |     ^^^ cannot infer type for type parameter `T` declared on the function `foo`\n+   |     ^^^ cannot infer type of the type parameter `T` declared on the function `foo`\n    |\n-help: type parameter declared here\n-  --> $DIR/type-annotation-needed.rs:1:8\n-   |\n-LL | fn foo<T: Into<String>>(x: i32) {}\n-   |        ^\n    = note: cannot satisfy `_: Into<String>`\n note: required by a bound in `foo`\n   --> $DIR/type-annotation-needed.rs:1:11\n    |\n LL | fn foo<T: Into<String>>(x: i32) {}\n    |           ^^^^^^^^^^^^ required by this bound in `foo`\n+help: consider specifying the generic argument\n+   |\n+LL |     foo::<T>(42);\n+   |        +++++\n help: consider specifying the type argument in the function call\n    |\n LL |     foo::<T>(42);"}, {"sha": "d68d5e5d40b9e7a7efd4b19e182378823591b685", "filename": "src/test/ui/type/type-check/cannot_infer_local_or_array.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_array.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,10 +1,13 @@\n error[E0282]: type annotations needed for `[_; 0]`\n-  --> $DIR/cannot_infer_local_or_array.rs:2:13\n+  --> $DIR/cannot_infer_local_or_array.rs:2:9\n    |\n LL |     let x = [];\n-   |         -   ^^ cannot infer type\n-   |         |\n-   |         consider giving `x` the explicit type `[_; 0]`, with the type parameters specified\n+   |         ^\n+   |\n+help: consider giving `x` an explicit type, where the placeholders `_` are specified\n+   |\n+LL |     let x: [_; 0] = [];\n+   |          ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "b63d2a3b61c249db086bace9b1001d83d347573e", "filename": "src/test/ui/type/type-check/cannot_infer_local_or_vec.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,12 +1,13 @@\n error[E0282]: type annotations needed for `Vec<T>`\n-  --> $DIR/cannot_infer_local_or_vec.rs:2:13\n+  --> $DIR/cannot_infer_local_or_vec.rs:2:9\n    |\n LL |     let x = vec![];\n-   |         -   ^^^^^^ cannot infer type for type parameter `T`\n-   |         |\n-   |         consider giving `x` the explicit type `Vec<T>`, where the type parameter `T` is specified\n+   |         ^\n    |\n-   = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider giving `x` an explicit type, where the type for type parameter `T` is specified\n+   |\n+LL |     let x: Vec<T> = vec![];\n+   |          ++++++++\n \n error: aborting due to previous error\n "}, {"sha": "be60cda68b9f0fb0ce1951d6d84934f929f10a1d", "filename": "src/test/ui/type/type-check/cannot_infer_local_or_vec_in_tuples.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,12 +1,13 @@\n error[E0282]: type annotations needed for `(Vec<T>,)`\n-  --> $DIR/cannot_infer_local_or_vec_in_tuples.rs:2:18\n+  --> $DIR/cannot_infer_local_or_vec_in_tuples.rs:2:9\n    |\n LL |     let (x, ) = (vec![], );\n-   |         -----    ^^^^^^ cannot infer type for type parameter `T`\n-   |         |\n-   |         consider giving this pattern the explicit type `(Vec<T>,)`, where the type parameter `T` is specified\n+   |         ^^^^^\n    |\n-   = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider giving this pattern a type, where the type for type parameter `T` is specified\n+   |\n+LL |     let (x, ): (Vec<T>,) = (vec![], );\n+   |              +++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "167687c18712910fbac5c86b1ef9636d05f5ef57", "filename": "src/test/ui/type/type-check/unknown_type_for_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Funknown_type_for_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Funknown_type_for_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Funknown_type_for_closure.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -11,7 +11,7 @@ fn infer_ty() {\n }\n \n fn ambig_return() {\n-    let x = || -> Vec<_> { Vec::new() }; //~ ERROR type annotations needed for the closure `fn() -> Vec<_>`\n+    let x = || -> Vec<_> { Vec::new() }; //~ ERROR type annotations needed\n }\n \n fn main() {}"}, {"sha": "9ae97f390d3e4bcb04fb13431c64092f8fc4051e", "filename": "src/test/ui/type/type-check/unknown_type_for_closure.stderr", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Funknown_type_for_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Funknown_type_for_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Funknown_type_for_closure.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,31 +1,36 @@\n-error[E0282]: type annotations needed for `Vec<_>`\n-  --> $DIR/unknown_type_for_closure.rs:2:14\n+error[E0282]: type annotations needed\n+  --> $DIR/unknown_type_for_closure.rs:2:13\n    |\n LL |     let x = |b: Vec<_>| {};\n-   |              ^ consider giving this closure parameter a type\n+   |             ^^^^^^^^^^^^^^ cannot infer type for struct `Vec<_>`\n \n error[E0282]: type annotations needed\n   --> $DIR/unknown_type_for_closure.rs:6:14\n    |\n LL |     let x = |_| {};\n-   |              ^ consider giving this closure parameter a type\n+   |              ^\n+   |\n+help: consider giving this closure parameter an explicit type\n+   |\n+LL |     let x = |_: _| {};\n+   |               +++\n \n error[E0282]: type annotations needed\n   --> $DIR/unknown_type_for_closure.rs:10:14\n    |\n LL |     let x = |k: _| {};\n-   |              ^ consider giving this closure parameter a type\n+   |              ^ cannot infer type\n \n-error[E0282]: type annotations needed for the closure `fn() -> Vec<_>`\n+error[E0282]: type annotations needed\n   --> $DIR/unknown_type_for_closure.rs:14:28\n    |\n LL |     let x = || -> Vec<_> { Vec::new() };\n-   |                            ^^^^^^^^ cannot infer type for type parameter `T`\n+   |                            ^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `Vec`\n    |\n-help: give this closure an explicit return type without `_` placeholders\n+help: consider specifying the generic argument\n    |\n-LL |     let x = || -> Vec<_> { Vec::new() };\n-   |                   ~~~~~~\n+LL |     let x = || -> Vec<_> { Vec::<T>::new() };\n+   |                               +++++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c1ae10efac4b4e874169caf6729eb77e2e8af666", "filename": "src/test/ui/type/type-path-err-node-types.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-path-err-node-types.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -26,7 +26,12 @@ error[E0282]: type annotations needed\n   --> $DIR/type-path-err-node-types.rs:23:14\n    |\n LL |     let _ = |a, b: _| -> _ { 0 };\n-   |              ^ consider giving this closure parameter a type\n+   |              ^\n+   |\n+help: consider giving this closure parameter an explicit type\n+   |\n+LL |     let _ = |a: _, b: _| -> _ { 0 };\n+   |               +++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "5f831291a3851542982165e39a246c6330461b73", "filename": "src/test/ui/typeck/issue-65611.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftypeck%2Fissue-65611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Ftypeck%2Fissue-65611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-65611.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,11 +1,8 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-65611.rs:59:20\n+  --> $DIR/issue-65611.rs:59:13\n    |\n LL |     let x = buffer.last().unwrap().0.clone();\n-   |             -------^^^^--\n-   |             |      |\n-   |             |      cannot infer type for type parameter `T`\n-   |             this method call resolves to `Option<&T>`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `T`\n    |\n    = note: type must be known at this point\n "}, {"sha": "25c2dbe196fe1105b5c62b2191280d8fddc0ffb7", "filename": "src/test/ui/unboxed-closures/unboxed-closures-failed-recursive-fn-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-2.rs?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -6,6 +6,7 @@\n \n fn a() {\n     let mut closure0 = None;\n+    //~^ ERROR type annotations needed\n     let vec = vec![1, 2, 3];\n \n     loop {\n@@ -14,7 +15,6 @@ fn a() {\n                 match closure0.take() {\n                     Some(c) => {\n                         return c();\n-                        //~^ ERROR type annotations needed\n                     }\n                     None => { }\n                 }"}, {"sha": "666ab79b65c32376af95221df43562207f3e063f", "filename": "src/test/ui/unboxed-closures/unboxed-closures-failed-recursive-fn-2.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-failed-recursive-fn-2.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -1,13 +1,14 @@\n error[E0282]: type annotations needed for `Option<T>`\n-  --> $DIR/unboxed-closures-failed-recursive-fn-2.rs:16:32\n+  --> $DIR/unboxed-closures-failed-recursive-fn-2.rs:8:9\n    |\n LL |     let mut closure0 = None;\n-   |         ------------ consider giving `closure0` the explicit type `Option<T>`, with the type parameters specified\n-...\n-LL |                         return c();\n-   |                                ^^^ cannot infer type\n+   |         ^^^^^^^^^^^^\n    |\n    = note: type must be known at this point\n+help: consider giving `closure0` an explicit type, where the placeholders `_` are specified\n+   |\n+LL |     let mut closure0: Option<T> = None;\n+   |                     +++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "19ac74fdf58319a4ecc022261919e7a69092380f", "filename": "src/test/ui/unconstrained-none.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Funconstrained-none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Funconstrained-none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funconstrained-none.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/unconstrained-none.rs:4:5\n    |\n LL |     None;\n-   |     ^^^^ cannot infer type for type parameter `T` declared on the enum `Option`\n+   |     ^^^^ cannot infer type of the type parameter `T` declared on the enum `Option`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     None::<T>;\n+   |         +++++\n \n error: aborting due to previous error\n "}, {"sha": "1df6d8b446d5c4029d9ecf053c07954129def4b3", "filename": "src/test/ui/unconstrained-ref.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Funconstrained-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e40d5e83dc133d093c22c7ff016b10daa4f40dcf/src%2Ftest%2Fui%2Funconstrained-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funconstrained-ref.stderr?ref=e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/unconstrained-ref.rs:6:5\n    |\n LL |     S { o: &None };\n-   |     ^ cannot infer type for type parameter `T` declared on the struct `S`\n+   |     ^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `S`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     S::<T> { o: &None };\n+   |      +++++\n \n error: aborting due to previous error\n "}]}