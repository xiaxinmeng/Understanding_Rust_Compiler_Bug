{"sha": "949c3545ce6c8662d384d625db7bfeae388f21d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0OWMzNTQ1Y2U2Yzg2NjJkMzg0ZDYyNWRiN2JmZWFlMzg4ZjIxZDY=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2015-10-14T10:06:28Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2015-10-14T10:06:28Z"}, "message": "Merged #366", "tree": {"sha": "2ce7036b61815b2ad405862155cc0bf84617de5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ce7036b61815b2ad405862155cc0bf84617de5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/949c3545ce6c8662d384d625db7bfeae388f21d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/949c3545ce6c8662d384d625db7bfeae388f21d6", "html_url": "https://github.com/rust-lang/rust/commit/949c3545ce6c8662d384d625db7bfeae388f21d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/949c3545ce6c8662d384d625db7bfeae388f21d6/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3d035d252d9e916e35450609919c3dc218119c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d035d252d9e916e35450609919c3dc218119c6", "html_url": "https://github.com/rust-lang/rust/commit/b3d035d252d9e916e35450609919c3dc218119c6"}, {"sha": "b7c6c30c8835254e2cb7c5fada886ffa7685bbd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7c6c30c8835254e2cb7c5fada886ffa7685bbd4", "html_url": "https://github.com/rust-lang/rust/commit/b7c6c30c8835254e2cb7c5fada886ffa7685bbd4"}], "stats": {"total": 172, "additions": 166, "deletions": 6}, "files": [{"sha": "3b231f34a5abe8dfd5b0c1a194d4df3f28e1c53d", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949c3545ce6c8662d384d625db7bfeae388f21d6/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/949c3545ce6c8662d384d625db7bfeae388f21d6/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=949c3545ce6c8662d384d625db7bfeae388f21d6", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 61 lints included in this crate:\n+There are 62 lints included in this crate:\n \n name                                                                                                   | default | meaning\n -------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -43,6 +43,7 @@ name\n [needless_range_loop](https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop)             | warn    | for-looping over a range of indices where an iterator over items would do\n [needless_return](https://github.com/Manishearth/rust-clippy/wiki#needless_return)                     | warn    | using a return statement like `return expr;` where an expression would suffice\n [non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                 | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n+[nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)   | warn    | nonsensical combination of options for opening a file\n [option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)               | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n [precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                               | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught\n [ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                     | allow   | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively"}, {"sha": "ff8d099b3fc72bd76bb359999afe6a9b89b21e5d", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949c3545ce6c8662d384d625db7bfeae388f21d6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949c3545ce6c8662d384d625db7bfeae388f21d6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=949c3545ce6c8662d384d625db7bfeae388f21d6", "patch": "@@ -48,6 +48,7 @@ pub mod ranges;\n pub mod matches;\n pub mod precedence;\n pub mod zero_div_zero;\n+pub mod open_options;\n \n mod reexport {\n     pub use syntax::ast::{Name, Ident, NodeId};\n@@ -89,6 +90,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box matches::MatchPass);\n     reg.register_late_lint_pass(box misc::PatternPass);\n     reg.register_late_lint_pass(box minmax::MinMaxPass);\n+    reg.register_late_lint_pass(box open_options::NonSensicalOpenOptions);\n     reg.register_late_lint_pass(box zero_div_zero::ZeroDivZeroPass);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n@@ -145,6 +147,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         misc::TOPLEVEL_REF_ARG,\n         mut_reference::UNNECESSARY_MUT_PASSED,\n         needless_bool::NEEDLESS_BOOL,\n+        open_options::NONSENSICAL_OPEN_OPTIONS,\n         precedence::PRECEDENCE,\n         ranges::RANGE_STEP_BY_ZERO,\n         returns::LET_AND_RETURN,"}, {"sha": "76a2eeef1ba12627797bb8481b910064154e76f6", "filename": "src/open_options.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/949c3545ce6c8662d384d625db7bfeae388f21d6/src%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949c3545ce6c8662d384d625db7bfeae388f21d6/src%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fopen_options.rs?ref=949c3545ce6c8662d384d625db7bfeae388f21d6", "patch": "@@ -0,0 +1,139 @@\n+use rustc::lint::*;\n+use rustc_front::hir::{Expr, ExprMethodCall, ExprLit};\n+use utils::{walk_ptrs_ty_depth, match_type, span_lint, OPEN_OPTIONS_PATH};\n+use syntax::codemap::{Span, Spanned};\n+use syntax::ast::Lit_::LitBool;\n+\n+declare_lint! {\n+    pub NONSENSICAL_OPEN_OPTIONS,\n+    Warn,\n+    \"nonsensical combination of options for opening a file\"\n+}\n+\n+\n+#[derive(Copy,Clone)]\n+pub struct NonSensicalOpenOptions;\n+\n+impl LintPass for NonSensicalOpenOptions {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NONSENSICAL_OPEN_OPTIONS)\n+    }\n+}\n+\n+impl LateLintPass for NonSensicalOpenOptions {\n+    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+        if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n+            let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));\n+            if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &OPEN_OPTIONS_PATH){\n+                let mut options = Vec::new();\n+                get_open_options(cx, &arguments[0], &mut options);\n+                check_open_options(cx, &options, e.span);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum Argument {\n+    True,\n+    False,\n+    Unknown\n+}\n+\n+#[derive(Debug)]\n+enum OpenOption {\n+    Write,\n+    Read,\n+    Truncate,\n+    Create,\n+    Append\n+}\n+\n+fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n+    if let ExprMethodCall(ref name, _, ref arguments) = argument.node {\n+        let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&arguments[0]));\n+        \n+        // Only proceed if this is a call on some object of type std::fs::OpenOptions\n+        if match_type(cx, obj_ty, &OPEN_OPTIONS_PATH) && arguments.len() >= 2 {\n+            \n+            let argument_option = match arguments[1].node {\n+                ExprLit(ref span) => {\n+                    if let Spanned {node: LitBool(lit), span: _} = **span {\n+                        if lit {Argument::True} else {Argument::False}\n+                    } else {\n+                        return; // The function is called with a literal\n+                                // which is not a boolean literal. This is theoretically\n+                                // possible, but not very likely.\n+                    }\n+                },\n+                _ => {\n+                    Argument::Unknown\n+                }\n+            };\n+            \n+            match &*name.node.as_str() {\n+                \"create\" => {\n+                    options.push((OpenOption::Create, argument_option));\n+                },\n+                \"append\" => {\n+                    options.push((OpenOption::Append, argument_option));\n+                },\n+                \"truncate\" => {\n+                    options.push((OpenOption::Truncate, argument_option));\n+                },\n+                \"read\" => {\n+                    options.push((OpenOption::Read, argument_option));\n+                },\n+                \"write\" => {\n+                    options.push((OpenOption::Write, argument_option));\n+                },\n+                _ => {}\n+            }\n+            \n+            get_open_options(cx, &arguments[0], options);\n+        }\n+    }\n+}\n+\n+fn check_for_duplicates(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n+    // This code is almost duplicated (oh, the irony), but I haven't found a way to unify it.\n+    if options.iter().filter(|o| if let (OpenOption::Create, _) = **o {true} else {false}).count() > 1 {\n+        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"The method \\\"create\\\" \\\n+                                                       is called more than once\");\n+    }\n+    if options.iter().filter(|o| if let (OpenOption::Append, _) = **o {true} else {false}).count() > 1 {\n+        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"The method \\\"append\\\" \\\n+                                                       is called more than once\");\n+    }\n+    if options.iter().filter(|o| if let (OpenOption::Truncate, _) = **o {true} else {false}).count() > 1 {\n+        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"The method \\\"truncate\\\" \\\n+                                                       is called more than once\");\n+    }\n+    if options.iter().filter(|o| if let (OpenOption::Read, _) = **o {true} else {false}).count() > 1 {\n+        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"The method \\\"read\\\" \\\n+                                                       is called more than once\");\n+    }\n+    if options.iter().filter(|o| if let (OpenOption::Write, _) = **o {true} else {false}).count() > 1 {\n+        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"The method \\\"write\\\" \\\n+                                                       is called more than once\");\n+    }\n+}\n+\n+fn check_for_inconsistencies(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n+    // Truncate + read makes no sense.\n+    if options.iter().filter(|o| if let (OpenOption::Read, Argument::True) = **o {true} else {false}).count() > 0 &&\n+       options.iter().filter(|o| if let (OpenOption::Truncate, Argument::True) = **o {true} else {false}).count() > 0 {\n+        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"File opened with \\\"truncate\\\" and \\\"read\\\"\");\n+    }\n+    \n+    // Append + truncate makes no sense.\n+    if options.iter().filter(|o| if let (OpenOption::Append, Argument::True) = **o {true} else {false}).count() > 0 &&\n+       options.iter().filter(|o| if let (OpenOption::Truncate, Argument::True) = **o {true} else {false}).count() > 0 {\n+        span_lint(cx, NONSENSICAL_OPEN_OPTIONS, span, \"File opened with \\\"append\\\" and \\\"truncate\\\"\");\n+    }\n+}\n+\n+fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n+    check_for_duplicates(cx, options, span);\n+    check_for_inconsistencies(cx, options, span);\n+}"}, {"sha": "c84bf3692c4b30f1758d7a8a61167f6022e828ec", "filename": "src/utils.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949c3545ce6c8662d384d625db7bfeae388f21d6/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949c3545ce6c8662d384d625db7bfeae388f21d6/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=949c3545ce6c8662d384d625db7bfeae388f21d6", "patch": "@@ -10,11 +10,12 @@ use syntax::ast::Lit_::*;\n use syntax::ast;\n \n // module DefPaths for certain structs/enums we check for\n-pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n-pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n-pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n-pub const VEC_PATH:    [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n-pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+pub const OPTION_PATH:       [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RESULT_PATH:       [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n+pub const STRING_PATH:       [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const VEC_PATH:          [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub const LL_PATH:           [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///"}, {"sha": "35cc91c9d0fe9bc2c4ee85d4b0e6d7571bcdbc44", "filename": "tests/compile-fail/open_options.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/949c3545ce6c8662d384d625db7bfeae388f21d6/tests%2Fcompile-fail%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949c3545ce6c8662d384d625db7bfeae388f21d6/tests%2Fcompile-fail%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fopen_options.rs?ref=949c3545ce6c8662d384d625db7bfeae388f21d6", "patch": "@@ -0,0 +1,16 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+use std::fs::OpenOptions;\n+\n+#[allow(unused_must_use)]\n+#[deny(nonsensical_open_options)]\n+fn main() {\n+\tOpenOptions::new().read(true).truncate(true).open(\"foo.txt\"); //~ERROR File opened with \"truncate\" and \"read\"\n+\tOpenOptions::new().append(true).truncate(true).open(\"foo.txt\"); //~ERROR File opened with \"append\" and \"truncate\"\n+    \n+\tOpenOptions::new().read(true).read(false).open(\"foo.txt\"); //~ERROR The method \"read\" is called more than once\n+\tOpenOptions::new().create(true).create(false).open(\"foo.txt\"); //~ERROR The method \"create\" is called more than once\n+\tOpenOptions::new().write(true).write(false).open(\"foo.txt\"); //~ERROR The method \"write\" is called more than once\n+\tOpenOptions::new().append(true).append(false).open(\"foo.txt\"); //~ERROR The method \"append\" is called more than once\n+\tOpenOptions::new().truncate(true).truncate(false).open(\"foo.txt\"); //~ERROR The method \"truncate\" is called more than once\n+}"}]}