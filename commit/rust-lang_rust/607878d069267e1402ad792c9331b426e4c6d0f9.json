{"sha": "607878d069267e1402ad792c9331b426e4c6d0f9", "node_id": "C_kwDOAAsO6NoAKDYwNzg3OGQwNjkyNjdlMTQwMmFkNzkyYzkzMzFiNDI2ZTRjNmQwZjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-29T06:20:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-29T06:20:48Z"}, "message": "Auto merge of #102698 - michaelwoerister:unord-collections, r=lncr\n\nIntroduce UnordMap, UnordSet, and UnordBag (MCP 533)\n\nThis is the start of implementing [MCP 533](https://github.com/rust-lang/compiler-team/issues/533).\n\nI followed `@eddyb's` suggestion of naming the collection types `Unord(Map/Set/Bag)` which is a bit easier to type than `Unordered(Map/Set/Bag)`\n\nr? `@eddyb`", "tree": {"sha": "0d0399113a9049f57294494faaa69c7035110383", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d0399113a9049f57294494faaa69c7035110383"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/607878d069267e1402ad792c9331b426e4c6d0f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/607878d069267e1402ad792c9331b426e4c6d0f9", "html_url": "https://github.com/rust-lang/rust/commit/607878d069267e1402ad792c9331b426e4c6d0f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/607878d069267e1402ad792c9331b426e4c6d0f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33b55ac39fa633d0983fad014469e1036669bf28", "url": "https://api.github.com/repos/rust-lang/rust/commits/33b55ac39fa633d0983fad014469e1036669bf28", "html_url": "https://github.com/rust-lang/rust/commit/33b55ac39fa633d0983fad014469e1036669bf28"}, {"sha": "9117ea975834a86dadcb9ebbc40dd9a9fb0f78ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/9117ea975834a86dadcb9ebbc40dd9a9fb0f78ae", "html_url": "https://github.com/rust-lang/rust/commit/9117ea975834a86dadcb9ebbc40dd9a9fb0f78ae"}], "stats": {"total": 412, "additions": 400, "deletions": 12}, "files": [{"sha": "3a2000233c5d10fac7150e1956b2e33f7a9a7042", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=607878d069267e1402ad792c9331b426e4c6d0f9", "patch": "@@ -22,6 +22,7 @@\n #![feature(new_uninit)]\n #![feature(once_cell)]\n #![feature(rustc_attrs)]\n+#![feature(negative_impls)]\n #![feature(test)]\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n@@ -86,6 +87,7 @@ pub mod steal;\n pub mod tagged_ptr;\n pub mod temp_dir;\n pub mod unhash;\n+pub mod unord;\n \n pub use ena::undo_log;\n pub use ena::unify;"}, {"sha": "c015f1232cd927c74ec8c968c1328985940a693a", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=607878d069267e1402ad792c9331b426e4c6d0f9", "patch": "@@ -0,0 +1,382 @@\n+//! This module contains collection types that don't expose their internal\n+//! ordering. This is a useful property for deterministic computations, such\n+//! as required by the query system.\n+\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use smallvec::SmallVec;\n+use std::{\n+    borrow::Borrow,\n+    hash::Hash,\n+    iter::{Product, Sum},\n+};\n+\n+use crate::{\n+    fingerprint::Fingerprint,\n+    stable_hasher::{HashStable, StableHasher, ToStableHashKey},\n+};\n+\n+/// `UnordItems` is the order-less version of `Iterator`. It only contains methods\n+/// that don't (easily) expose an ordering of the underlying items.\n+///\n+/// Most methods take an `Fn` where the `Iterator`-version takes an `FnMut`. This\n+/// is to reduce the risk of accidentally leaking the internal order via the closure\n+/// environment. Otherwise one could easily do something like\n+///\n+/// ```rust,ignore (pseudo code)\n+/// let mut ordered = vec![];\n+/// unordered_items.all(|x| ordered.push(x));\n+/// ```\n+///\n+/// It's still possible to do the same thing with an `Fn` by using interior mutability,\n+/// but the chance of doing it accidentally is reduced.\n+pub struct UnordItems<T, I: Iterator<Item = T>>(I);\n+\n+impl<T, I: Iterator<Item = T>> UnordItems<T, I> {\n+    #[inline]\n+    pub fn map<U, F: Fn(T) -> U>(self, f: F) -> UnordItems<U, impl Iterator<Item = U>> {\n+        UnordItems(self.0.map(f))\n+    }\n+\n+    #[inline]\n+    pub fn all<U, F: Fn(T) -> bool>(mut self, f: F) -> bool {\n+        self.0.all(f)\n+    }\n+\n+    #[inline]\n+    pub fn any<U, F: Fn(T) -> bool>(mut self, f: F) -> bool {\n+        self.0.any(f)\n+    }\n+\n+    #[inline]\n+    pub fn filter<U, F: Fn(&T) -> bool>(self, f: F) -> UnordItems<T, impl Iterator<Item = T>> {\n+        UnordItems(self.0.filter(f))\n+    }\n+\n+    #[inline]\n+    pub fn filter_map<U, F: Fn(T) -> Option<U>>(\n+        self,\n+        f: F,\n+    ) -> UnordItems<U, impl Iterator<Item = U>> {\n+        UnordItems(self.0.filter_map(f))\n+    }\n+\n+    #[inline]\n+    pub fn max(self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n+        self.0.max()\n+    }\n+\n+    #[inline]\n+    pub fn min(self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n+        self.0.min()\n+    }\n+\n+    #[inline]\n+    pub fn sum<S>(self) -> S\n+    where\n+        S: Sum<T>,\n+    {\n+        self.0.sum()\n+    }\n+\n+    #[inline]\n+    pub fn product<S>(self) -> S\n+    where\n+        S: Product<T>,\n+    {\n+        self.0.product()\n+    }\n+\n+    #[inline]\n+    pub fn count(self) -> usize {\n+        self.0.count()\n+    }\n+}\n+\n+impl<'a, T: Clone + 'a, I: Iterator<Item = &'a T>> UnordItems<&'a T, I> {\n+    #[inline]\n+    pub fn cloned(self) -> UnordItems<T, impl Iterator<Item = T>> {\n+        UnordItems(self.0.cloned())\n+    }\n+}\n+\n+impl<'a, T: Copy + 'a, I: Iterator<Item = &'a T>> UnordItems<&'a T, I> {\n+    #[inline]\n+    pub fn copied(self) -> UnordItems<T, impl Iterator<Item = T>> {\n+        UnordItems(self.0.copied())\n+    }\n+}\n+\n+impl<T: Ord, I: Iterator<Item = T>> UnordItems<T, I> {\n+    pub fn into_sorted<HCX>(self, hcx: &HCX) -> Vec<T>\n+    where\n+        T: ToStableHashKey<HCX>,\n+    {\n+        let mut items: Vec<T> = self.0.collect();\n+        items.sort_by_cached_key(|x| x.to_stable_hash_key(hcx));\n+        items\n+    }\n+\n+    pub fn into_sorted_small_vec<HCX, const LEN: usize>(self, hcx: &HCX) -> SmallVec<[T; LEN]>\n+    where\n+        T: ToStableHashKey<HCX>,\n+    {\n+        let mut items: SmallVec<[T; LEN]> = self.0.collect();\n+        items.sort_by_cached_key(|x| x.to_stable_hash_key(hcx));\n+        items\n+    }\n+}\n+\n+/// This is a set collection type that tries very hard to not expose\n+/// any internal iteration. This is a useful property when trying to\n+/// uphold the determinism invariants imposed by the query system.\n+///\n+/// This collection type is a good choice for set-like collections the\n+/// keys of which don't have a semantic ordering.\n+///\n+/// See [MCP 533](https://github.com/rust-lang/compiler-team/issues/533)\n+/// for more information.\n+#[derive(Debug, Eq, PartialEq, Clone, Encodable, Decodable)]\n+pub struct UnordSet<V: Eq + Hash> {\n+    inner: FxHashSet<V>,\n+}\n+\n+impl<V: Eq + Hash> Default for UnordSet<V> {\n+    fn default() -> Self {\n+        Self { inner: FxHashSet::default() }\n+    }\n+}\n+\n+impl<V: Eq + Hash> UnordSet<V> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        Self { inner: Default::default() }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+\n+    #[inline]\n+    pub fn insert(&mut self, v: V) -> bool {\n+        self.inner.insert(v)\n+    }\n+\n+    #[inline]\n+    pub fn contains<Q: ?Sized>(&self, v: &Q) -> bool\n+    where\n+        V: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.contains(v)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n+        UnordItems(self.inner.iter())\n+    }\n+\n+    #[inline]\n+    pub fn into_items(self) -> UnordItems<V, impl Iterator<Item = V>> {\n+        UnordItems(self.inner.into_iter())\n+    }\n+\n+    // We can safely extend this UnordSet from a set of unordered values because that\n+    // won't expose the internal ordering anywhere.\n+    #[inline]\n+    pub fn extend<I: Iterator<Item = V>>(&mut self, items: UnordItems<V, I>) {\n+        self.inner.extend(items.0)\n+    }\n+}\n+\n+impl<V: Hash + Eq> Extend<V> for UnordSet<V> {\n+    fn extend<T: IntoIterator<Item = V>>(&mut self, iter: T) {\n+        self.inner.extend(iter)\n+    }\n+}\n+\n+impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordSet<V> {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n+    }\n+}\n+\n+/// This is a map collection type that tries very hard to not expose\n+/// any internal iteration. This is a useful property when trying to\n+/// uphold the determinism invariants imposed by the query system.\n+///\n+/// This collection type is a good choice for map-like collections the\n+/// keys of which don't have a semantic ordering.\n+///\n+/// See [MCP 533](https://github.com/rust-lang/compiler-team/issues/533)\n+/// for more information.\n+#[derive(Debug, Eq, PartialEq, Clone, Encodable, Decodable)]\n+pub struct UnordMap<K: Eq + Hash, V> {\n+    inner: FxHashMap<K, V>,\n+}\n+\n+impl<K: Eq + Hash, V> Default for UnordMap<K, V> {\n+    fn default() -> Self {\n+        Self { inner: FxHashMap::default() }\n+    }\n+}\n+\n+impl<K: Hash + Eq, V> Extend<(K, V)> for UnordMap<K, V> {\n+    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n+        self.inner.extend(iter)\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> UnordMap<K, V> {\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+\n+    #[inline]\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        self.inner.insert(k, v)\n+    }\n+\n+    #[inline]\n+    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.contains_key(k)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<(&'a K, &'a V), impl Iterator<Item = (&'a K, &'a V)>> {\n+        UnordItems(self.inner.iter())\n+    }\n+\n+    #[inline]\n+    pub fn into_items(self) -> UnordItems<(K, V), impl Iterator<Item = (K, V)>> {\n+        UnordItems(self.inner.into_iter())\n+    }\n+\n+    // We can safely extend this UnordMap from a set of unordered values because that\n+    // won't expose the internal ordering anywhere.\n+    #[inline]\n+    pub fn extend<I: Iterator<Item = (K, V)>>(&mut self, items: UnordItems<(K, V), I>) {\n+        self.inner.extend(items.0)\n+    }\n+}\n+\n+impl<HCX, K: Hash + Eq + HashStable<HCX>, V: HashStable<HCX>> HashStable<HCX> for UnordMap<K, V> {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n+    }\n+}\n+\n+/// This is a collection type that tries very hard to not expose\n+/// any internal iteration. This is a useful property when trying to\n+/// uphold the determinism invariants imposed by the query system.\n+///\n+/// This collection type is a good choice for collections the\n+/// keys of which don't have a semantic ordering and don't implement\n+/// `Hash` or `Eq`.\n+///\n+/// See [MCP 533](https://github.com/rust-lang/compiler-team/issues/533)\n+/// for more information.\n+#[derive(Default, Debug, Eq, PartialEq, Clone, Encodable, Decodable)]\n+pub struct UnordBag<V> {\n+    inner: Vec<V>,\n+}\n+\n+impl<V> UnordBag<V> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        Self { inner: Default::default() }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+\n+    #[inline]\n+    pub fn push(&mut self, v: V) {\n+        self.inner.push(v);\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n+        UnordItems(self.inner.iter())\n+    }\n+\n+    #[inline]\n+    pub fn into_items(self) -> UnordItems<V, impl Iterator<Item = V>> {\n+        UnordItems(self.inner.into_iter())\n+    }\n+\n+    // We can safely extend this UnordSet from a set of unordered values because that\n+    // won't expose the internal ordering anywhere.\n+    #[inline]\n+    pub fn extend<I: Iterator<Item = V>>(&mut self, items: UnordItems<V, I>) {\n+        self.inner.extend(items.0)\n+    }\n+}\n+\n+impl<T> Extend<T> for UnordBag<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        self.inner.extend(iter)\n+    }\n+}\n+\n+impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordBag<V> {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n+    }\n+}\n+\n+fn hash_iter_order_independent<\n+    HCX,\n+    T: HashStable<HCX>,\n+    I: Iterator<Item = T> + ExactSizeIterator,\n+>(\n+    mut it: I,\n+    hcx: &mut HCX,\n+    hasher: &mut StableHasher,\n+) {\n+    let len = it.len();\n+    len.hash_stable(hcx, hasher);\n+\n+    match len {\n+        0 => {\n+            // We're done\n+        }\n+        1 => {\n+            // No need to instantiate a hasher\n+            it.next().unwrap().hash_stable(hcx, hasher);\n+        }\n+        _ => {\n+            let mut accumulator = Fingerprint::ZERO;\n+            for item in it {\n+                let mut item_hasher = StableHasher::new();\n+                item.hash_stable(hcx, &mut item_hasher);\n+                let item_fingerprint: Fingerprint = item_hasher.finish();\n+                accumulator = accumulator.combine_commutative(item_fingerprint);\n+            }\n+            accumulator.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+// Do not implement IntoIterator for the collections in this module.\n+// They only exist to hide iteration order in the first place.\n+impl<T> !IntoIterator for UnordBag<T> {}\n+impl<V> !IntoIterator for UnordSet<V> {}\n+impl<K, V> !IntoIterator for UnordMap<K, V> {}\n+impl<T, I> !IntoIterator for UnordItems<T, I> {}"}, {"sha": "d3df259075274c45232b01eb9d684a17d2ea4cb2", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=607878d069267e1402ad792c9331b426e4c6d0f9", "patch": "@@ -1,5 +1,6 @@\n use crate::errors::{ExternCrateNotIdiomatic, UnusedExternCrate};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -8,12 +9,12 @@ use rustc_session::lint;\n use rustc_span::{Span, Symbol};\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n-    let mut used_trait_imports: FxHashSet<LocalDefId> = FxHashSet::default();\n+    let mut used_trait_imports: UnordSet<LocalDefId> = Default::default();\n \n     for item_def_id in tcx.hir().body_owners() {\n         let imports = tcx.used_trait_imports(item_def_id);\n         debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n-        used_trait_imports.extend(imports.iter());\n+        used_trait_imports.extend(imports.items().copied());\n     }\n \n     for &id in tcx.maybe_unused_trait_imports(()) {"}, {"sha": "959c54866453dd8520f2ef00eaf979ce3886d264", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=607878d069267e1402ad792c9331b426e4c6d0f9", "patch": "@@ -52,7 +52,7 @@ pub use inherited::{Inherited, InheritedBuilder};\n use crate::check::check_fn;\n use crate::coercion::DynamicCoerceMany;\n use crate::gather_locals::GatherLocalsVisitor;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{struct_span_err, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -174,7 +174,7 @@ fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n }\n \n-fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDefId> {\n+fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &UnordSet<LocalDefId> {\n     &*tcx.typeck(def_id).used_trait_imports\n }\n "}, {"sha": "f8aae86fe3dc3691b6484db95f49a0cfffc47c2d", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=607878d069267e1402ad792c9331b426e4c6d0f9", "patch": "@@ -96,7 +96,7 @@ macro_rules! arena_types {\n             // since we need to allocate this type on both the `rustc_hir` arena\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n             [decode] asm_template: rustc_ast::InlineAsmTemplatePiece,\n-            [decode] used_trait_imports: rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>,\n+            [decode] used_trait_imports: rustc_data_structures::unord::UnordSet<rustc_hir::def_id::LocalDefId>,\n             [decode] is_late_bound_map: rustc_data_structures::fx::FxIndexSet<rustc_hir::def_id::LocalDefId>,\n             [decode] impl_source: rustc_middle::traits::ImplSource<'tcx, ()>,\n "}, {"sha": "3d720f09b4ff7ca8d6285d857e65c99491586cb6", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=607878d069267e1402ad792c9331b426e4c6d0f9", "patch": "@@ -912,7 +912,7 @@ rustc_queries! {\n         cache_on_disk_if { true }\n     }\n \n-    query used_trait_imports(key: LocalDefId) -> &'tcx FxHashSet<LocalDefId> {\n+    query used_trait_imports(key: LocalDefId) -> &'tcx UnordSet<LocalDefId> {\n         desc { |tcx| \"finding used_trait_imports `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }"}, {"sha": "3d7e2a0839abc384f8fdf9c01140b4aed3be0f92", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=607878d069267e1402ad792c9331b426e4c6d0f9", "patch": "@@ -34,6 +34,7 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, RwLock, WorkerLocal};\n+use rustc_data_structures::unord::UnordSet;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{\n     DecorateLint, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n@@ -531,7 +532,7 @@ pub struct TypeckResults<'tcx> {\n     /// This is used for warning unused imports. During type\n     /// checking, this `Lrc` should not be cloned: it must have a ref-count\n     /// of 1 so that we can insert things into the set mutably.\n-    pub used_trait_imports: Lrc<FxHashSet<LocalDefId>>,\n+    pub used_trait_imports: Lrc<UnordSet<LocalDefId>>,\n \n     /// If any errors occurred while type-checking this body,\n     /// this field will be set to `Some(ErrorGuaranteed)`."}, {"sha": "ec90590ada2ec15430203b068b2248ca0352b3db", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=607878d069267e1402ad792c9331b426e4c6d0f9", "patch": "@@ -40,6 +40,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;"}, {"sha": "8b14ce210a20512a9247d76cd001d1bc05b4f95f", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607878d069267e1402ad792c9331b426e4c6d0f9/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=607878d069267e1402ad792c9331b426e4c6d0f9", "patch": "@@ -1,8 +1,9 @@\n use crate::QueryCtxt;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, RwLock};\n use rustc_data_structures::unhash::UnhashMap;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -792,7 +793,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n     }\n }\n \n-impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx FxHashSet<LocalDefId> {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx UnordSet<LocalDefId> {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }"}, {"sha": "3e5f42b7a80dc54ee4178682d5558bfa18452647", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/607878d069267e1402ad792c9331b426e4c6d0f9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607878d069267e1402ad792c9331b426e4c6d0f9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=607878d069267e1402ad792c9331b426e4c6d0f9", "patch": "@@ -1,6 +1,7 @@\n use rustc_ast::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n+use rustc_data_structures::unord::UnordSet;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n@@ -288,8 +289,7 @@ pub(crate) fn create_config(\n             providers.typeck_item_bodies = |_, _| {};\n             // hack so that `used_trait_imports` won't try to call typeck\n             providers.used_trait_imports = |_, _| {\n-                static EMPTY_SET: LazyLock<FxHashSet<LocalDefId>> =\n-                    LazyLock::new(FxHashSet::default);\n+                static EMPTY_SET: LazyLock<UnordSet<LocalDefId>> = LazyLock::new(UnordSet::default);\n                 &EMPTY_SET\n             };\n             // In case typeck does end up being called, don't ICE in case there were name resolution errors"}]}