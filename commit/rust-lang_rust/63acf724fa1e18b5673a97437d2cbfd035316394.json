{"sha": "63acf724fa1e18b5673a97437d2cbfd035316394", "node_id": "C_kwDOAAsO6NoAKDYzYWNmNzI0ZmExZTE4YjU2NzNhOTc0MzdkMmNiZmQwMzUzMTYzOTQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-08T18:00:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-08T18:00:41Z"}, "message": "Merge #11938\n\n11938: feat: improve assoc. item completion in trait impls r=jonas-schievink a=jonas-schievink\n\nAccount for macro-generated items, increase the score of these completions since they're very relevant, and allow them to trigger when the cursor is directly in the assoc. item list without requiring further input.\r\n\r\n![screenshot-2022-04-08-18:12:06](https://user-images.githubusercontent.com/1786438/162481277-2a0d2f21-dc20-4452-804d-6370766216b6.png)\r\n\r\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/11860\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "3563dab336e4ff51b0ec5ce6c64cc915b4578165", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3563dab336e4ff51b0ec5ce6c64cc915b4578165"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63acf724fa1e18b5673a97437d2cbfd035316394", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiUHhJCRBK7hj4Ov3rIwAAVVsIADzj527CEyNwjc/5z0fqs8n2\nAdy3J6neR29jHBpZsElMT853RABoXxSWrruV3zvVzaZD7vsw80YmLKqHYB0aeUD0\nUAEjaPaQbgNfSpuSzavxMr5o5+nku70e0DrfoTJV1OsDFZOaCSWnMfKiktQM52HC\nqz8ekFu5cOjV2ELrPfz2r8b0q7jcHT09ymfm67WyZKOivdXZ/3emm/UonHCmW5yM\nkupLleyIjMbnXt+OgAiNVID+K899O0jTTO88r1v7tu0eGV3g2RX6ZF2Wj3g5DcVL\nTK/eELOuWQi9r1peVms4+furDnBiP53zTkQIayNUIhr6ruVYOXmVzENMFUpZNSk=\n=RT2L\n-----END PGP SIGNATURE-----\n", "payload": "tree 3563dab336e4ff51b0ec5ce6c64cc915b4578165\nparent 847c552ab3d257a45fee6ef2c1737de52c081d11\nparent 22b13c8bff1908b40beb4d9f8e4dc99ea8864465\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1649440841 +0000\ncommitter GitHub <noreply@github.com> 1649440841 +0000\n\nMerge #11938\n\n11938: feat: improve assoc. item completion in trait impls r=jonas-schievink a=jonas-schievink\n\nAccount for macro-generated items, increase the score of these completions since they're very relevant, and allow them to trigger when the cursor is directly in the assoc. item list without requiring further input.\r\n\r\n![screenshot-2022-04-08-18:12:06](https://user-images.githubusercontent.com/1786438/162481277-2a0d2f21-dc20-4452-804d-6370766216b6.png)\r\n\r\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/11860\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63acf724fa1e18b5673a97437d2cbfd035316394", "html_url": "https://github.com/rust-lang/rust/commit/63acf724fa1e18b5673a97437d2cbfd035316394", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63acf724fa1e18b5673a97437d2cbfd035316394/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "847c552ab3d257a45fee6ef2c1737de52c081d11", "url": "https://api.github.com/repos/rust-lang/rust/commits/847c552ab3d257a45fee6ef2c1737de52c081d11", "html_url": "https://github.com/rust-lang/rust/commit/847c552ab3d257a45fee6ef2c1737de52c081d11"}, {"sha": "22b13c8bff1908b40beb4d9f8e4dc99ea8864465", "url": "https://api.github.com/repos/rust-lang/rust/commits/22b13c8bff1908b40beb4d9f8e4dc99ea8864465", "html_url": "https://github.com/rust-lang/rust/commit/22b13c8bff1908b40beb4d9f8e4dc99ea8864465"}], "stats": {"total": 264, "additions": 173, "deletions": 91}, "files": [{"sha": "13e05049e2f89e0717e84ba3014613a4aa16b23e", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 126, "deletions": 66, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/63acf724fa1e18b5673a97437d2cbfd035316394/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63acf724fa1e18b5673a97437d2cbfd035316394/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=63acf724fa1e18b5673a97437d2cbfd035316394", "patch": "@@ -36,11 +36,13 @@ use ide_db::{path_transform::PathTransform, traits::get_missing_assoc_items, Sym\n use syntax::{\n     ast::{self, edit_in_place::AttrsOwnerEdit},\n     display::function_declaration,\n-    AstNode, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, T,\n+    AstNode, SyntaxElement, SyntaxKind, SyntaxNode, TextRange, T,\n };\n use text_edit::TextEdit;\n \n-use crate::{CompletionContext, CompletionItem, CompletionItemKind, Completions};\n+use crate::{\n+    CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n+};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum ImplCompletionKind {\n@@ -51,84 +53,102 @@ enum ImplCompletionKind {\n }\n \n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n-    if let Some((kind, trigger, impl_def)) = completion_match(ctx.token.clone()) {\n+    if let Some((kind, replacement_range, impl_def)) = completion_match(ctx) {\n         if let Some(hir_impl) = ctx.sema.to_def(&impl_def) {\n             get_missing_assoc_items(&ctx.sema, &impl_def).into_iter().for_each(|item| {\n                 match (item, kind) {\n                     (\n                         hir::AssocItem::Function(fn_item),\n                         ImplCompletionKind::All | ImplCompletionKind::Fn,\n-                    ) => add_function_impl(acc, ctx, &trigger, fn_item, hir_impl),\n+                    ) => add_function_impl(acc, ctx, replacement_range, fn_item, hir_impl),\n                     (\n                         hir::AssocItem::TypeAlias(type_item),\n                         ImplCompletionKind::All | ImplCompletionKind::TypeAlias,\n-                    ) => add_type_alias_impl(acc, ctx, &trigger, type_item),\n+                    ) => add_type_alias_impl(acc, ctx, replacement_range, type_item),\n                     (\n                         hir::AssocItem::Const(const_item),\n                         ImplCompletionKind::All | ImplCompletionKind::Const,\n-                    ) => add_const_impl(acc, ctx, &trigger, const_item, hir_impl),\n+                    ) => add_const_impl(acc, ctx, replacement_range, const_item, hir_impl),\n                     _ => {}\n                 }\n             });\n         }\n     }\n }\n \n-fn completion_match(mut token: SyntaxToken) -> Option<(ImplCompletionKind, SyntaxNode, ast::Impl)> {\n+fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, TextRange, ast::Impl)> {\n+    let token = ctx.token.clone();\n+\n     // For keyword without name like `impl .. { fn $0 }`, the current position is inside\n     // the whitespace token, which is outside `FN` syntax node.\n     // We need to follow the previous token in this case.\n+    let mut token_before_ws = token.clone();\n     if token.kind() == SyntaxKind::WHITESPACE {\n-        token = token.prev_token()?;\n+        token_before_ws = token.prev_token()?;\n     }\n \n-    let parent_kind = token.parent().map_or(SyntaxKind::EOF, |it| it.kind());\n-    let impl_item_offset = match token.kind() {\n-        // `impl .. { const $0 }`\n-        // ERROR      0\n-        //   CONST_KW <- *\n-        T![const] => 0,\n-        // `impl .. { fn/type $0 }`\n-        // FN/TYPE_ALIAS  0\n-        //   FN_KW        <- *\n-        T![fn] | T![type] => 0,\n-        // `impl .. { fn/type/const foo$0 }`\n-        // FN/TYPE_ALIAS/CONST  1\n-        //  NAME                0\n-        //    IDENT             <- *\n-        SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME => 1,\n-        // `impl .. { foo$0 }`\n-        // MACRO_CALL       3\n-        //  PATH            2\n-        //    PATH_SEGMENT  1\n-        //      NAME_REF    0\n-        //        IDENT     <- *\n-        SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME_REF => 3,\n-        _ => return None,\n-    };\n+    let parent_kind = token_before_ws.parent().map_or(SyntaxKind::EOF, |it| it.kind());\n+    if token.parent().map(|n| n.kind()) == Some(SyntaxKind::ASSOC_ITEM_LIST)\n+        && matches!(\n+            token_before_ws.kind(),\n+            SyntaxKind::SEMICOLON | SyntaxKind::R_CURLY | SyntaxKind::L_CURLY\n+        )\n+    {\n+        let impl_def = ast::Impl::cast(token.parent()?.parent()?)?;\n+        let kind = ImplCompletionKind::All;\n+        let replacement_range = TextRange::empty(ctx.position.offset);\n+        Some((kind, replacement_range, impl_def))\n+    } else {\n+        let impl_item_offset = match token_before_ws.kind() {\n+            // `impl .. { const $0 }`\n+            // ERROR      0\n+            //   CONST_KW <- *\n+            T![const] => 0,\n+            // `impl .. { fn/type $0 }`\n+            // FN/TYPE_ALIAS  0\n+            //   FN_KW        <- *\n+            T![fn] | T![type] => 0,\n+            // `impl .. { fn/type/const foo$0 }`\n+            // FN/TYPE_ALIAS/CONST  1\n+            //  NAME                0\n+            //    IDENT             <- *\n+            SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME => 1,\n+            // `impl .. { foo$0 }`\n+            // MACRO_CALL       3\n+            //  PATH            2\n+            //    PATH_SEGMENT  1\n+            //      NAME_REF    0\n+            //        IDENT     <- *\n+            SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME_REF => 3,\n+            _ => return None,\n+        };\n \n-    let impl_item = token.ancestors().nth(impl_item_offset)?;\n-    // Must directly belong to an impl block.\n-    // IMPL\n-    //   ASSOC_ITEM_LIST\n-    //     <item>\n-    let impl_def = ast::Impl::cast(impl_item.parent()?.parent()?)?;\n-    let kind = match impl_item.kind() {\n-        // `impl ... { const $0 fn/type/const }`\n-        _ if token.kind() == T![const] => ImplCompletionKind::Const,\n-        SyntaxKind::CONST | SyntaxKind::ERROR => ImplCompletionKind::Const,\n-        SyntaxKind::TYPE_ALIAS => ImplCompletionKind::TypeAlias,\n-        SyntaxKind::FN => ImplCompletionKind::Fn,\n-        SyntaxKind::MACRO_CALL => ImplCompletionKind::All,\n-        _ => return None,\n-    };\n-    Some((kind, impl_item, impl_def))\n+        let impl_item = token_before_ws.ancestors().nth(impl_item_offset)?;\n+        // Must directly belong to an impl block.\n+        // IMPL\n+        //   ASSOC_ITEM_LIST\n+        //     <item>\n+        let impl_def = ast::Impl::cast(impl_item.parent()?.parent()?)?;\n+        let kind = match impl_item.kind() {\n+            // `impl ... { const $0 fn/type/const }`\n+            _ if token_before_ws.kind() == T![const] => ImplCompletionKind::Const,\n+            SyntaxKind::CONST | SyntaxKind::ERROR => ImplCompletionKind::Const,\n+            SyntaxKind::TYPE_ALIAS => ImplCompletionKind::TypeAlias,\n+            SyntaxKind::FN => ImplCompletionKind::Fn,\n+            SyntaxKind::MACRO_CALL => ImplCompletionKind::All,\n+            _ => return None,\n+        };\n+\n+        let replacement_range = replacement_range(ctx, &impl_item);\n+\n+        Some((kind, replacement_range, impl_def))\n+    }\n }\n \n fn add_function_impl(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    fn_def_node: &SyntaxNode,\n+    replacement_range: TextRange,\n     func: hir::Function,\n     impl_def: hir::Impl,\n ) {\n@@ -146,9 +166,10 @@ fn add_function_impl(\n         CompletionItemKind::SymbolKind(SymbolKind::Function)\n     };\n \n-    let range = replacement_range(ctx, fn_def_node);\n-    let mut item = CompletionItem::new(completion_kind, range, label);\n-    item.lookup_by(fn_name).set_documentation(func.docs(ctx.db));\n+    let mut item = CompletionItem::new(completion_kind, replacement_range, label);\n+    item.lookup_by(fn_name)\n+        .set_documentation(func.docs(ctx.db))\n+        .set_relevance(CompletionRelevance { is_item_from_trait: true, ..Default::default() });\n \n     if let Some(source) = ctx.sema.source(func) {\n         let assoc_item = ast::AssocItem::Fn(source.value);\n@@ -162,11 +183,11 @@ fn add_function_impl(\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n                     let snippet = format!(\"{} {{\\n    $0\\n}}\", function_decl);\n-                    item.snippet_edit(cap, TextEdit::replace(range, snippet));\n+                    item.snippet_edit(cap, TextEdit::replace(replacement_range, snippet));\n                 }\n                 None => {\n                     let header = format!(\"{} {{\", function_decl);\n-                    item.text_edit(TextEdit::replace(range, header));\n+                    item.text_edit(TextEdit::replace(replacement_range, header));\n                 }\n             };\n             item.add_to(acc);\n@@ -201,25 +222,26 @@ fn get_transformed_assoc_item(\n fn add_type_alias_impl(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    type_def_node: &SyntaxNode,\n+    replacement_range: TextRange,\n     type_alias: hir::TypeAlias,\n ) {\n     let alias_name = type_alias.name(ctx.db).to_smol_str();\n \n+    let label = format!(\"type {} =\", alias_name);\n     let snippet = format!(\"type {} = \", alias_name);\n \n-    let range = replacement_range(ctx, type_def_node);\n-    let mut item = CompletionItem::new(SymbolKind::TypeAlias, range, &snippet);\n-    item.text_edit(TextEdit::replace(range, snippet))\n+    let mut item = CompletionItem::new(SymbolKind::TypeAlias, replacement_range, label);\n+    item.text_edit(TextEdit::replace(replacement_range, snippet))\n         .lookup_by(alias_name)\n-        .set_documentation(type_alias.docs(ctx.db));\n+        .set_documentation(type_alias.docs(ctx.db))\n+        .set_relevance(CompletionRelevance { is_item_from_trait: true, ..Default::default() });\n     item.add_to(acc);\n }\n \n fn add_const_impl(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    const_def_node: &SyntaxNode,\n+    replacement_range: TextRange,\n     const_: hir::Const,\n     impl_def: hir::Impl,\n ) {\n@@ -234,13 +256,17 @@ fn add_const_impl(\n                     _ => unreachable!(),\n                 };\n \n-                let snippet = make_const_compl_syntax(&transformed_const);\n+                let label = make_const_compl_syntax(&transformed_const);\n+                let snippet = format!(\"{} \", label);\n \n-                let range = replacement_range(ctx, const_def_node);\n-                let mut item = CompletionItem::new(SymbolKind::Const, range, &snippet);\n-                item.text_edit(TextEdit::replace(range, snippet))\n+                let mut item = CompletionItem::new(SymbolKind::Const, replacement_range, label);\n+                item.text_edit(TextEdit::replace(replacement_range, snippet))\n                     .lookup_by(const_name)\n-                    .set_documentation(const_.docs(ctx.db));\n+                    .set_documentation(const_.docs(ctx.db))\n+                    .set_relevance(CompletionRelevance {\n+                        is_item_from_trait: true,\n+                        ..Default::default()\n+                    });\n                 item.add_to(acc);\n             }\n         }\n@@ -267,7 +293,7 @@ fn make_const_compl_syntax(const_: &ast::Const) -> String {\n \n     let syntax = const_.syntax().text().slice(range).to_string();\n \n-    format!(\"{} = \", syntax.trim_end())\n+    format!(\"{} =\", syntax.trim_end())\n }\n \n fn replacement_range(ctx: &CompletionContext, item: &SyntaxNode) -> TextRange {\n@@ -987,4 +1013,38 @@ where Self: SomeTrait<u32> {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn works_directly_in_impl() {\n+        check(\n+            r#\"\n+trait Tr {\n+    fn required();\n+}\n+\n+impl Tr for () {\n+    $0\n+}\n+\"#,\n+            expect![[r#\"\n+            fn fn required()\n+        \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Tr {\n+    fn provided() {}\n+    fn required();\n+}\n+\n+impl Tr for () {\n+    fn provided() {}\n+    $0\n+}\n+\"#,\n+            expect![[r#\"\n+            fn fn required()\n+        \"#]],\n+        );\n+    }\n }"}, {"sha": "2fa8f77264231884c57589bc89613529ea40540b", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63acf724fa1e18b5673a97437d2cbfd035316394/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63acf724fa1e18b5673a97437d2cbfd035316394/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=63acf724fa1e18b5673a97437d2cbfd035316394", "patch": "@@ -132,6 +132,8 @@ pub struct CompletionRelevance {\n     /// }\n     /// ```\n     pub is_local: bool,\n+    /// This is set when trait items are completed in an impl of that trait.\n+    pub is_item_from_trait: bool,\n     /// Set for method completions of the `core::ops` and `core::cmp` family.\n     pub is_op_method: bool,\n     /// Set for item completions that are private but in the workspace.\n@@ -197,6 +199,7 @@ impl CompletionRelevance {\n             exact_name_match,\n             type_match,\n             is_local,\n+            is_item_from_trait,\n             is_op_method,\n             is_private_editable,\n             postfix_match,\n@@ -228,6 +231,9 @@ impl CompletionRelevance {\n         if is_local {\n             score += 1;\n         }\n+        if is_item_from_trait {\n+            score += 1;\n+        }\n         if is_definite {\n             score += 10;\n         }"}, {"sha": "5b0257f6b40e682f383430d3be36bea662e9c6c7", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63acf724fa1e18b5673a97437d2cbfd035316394/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63acf724fa1e18b5673a97437d2cbfd035316394/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=63acf724fa1e18b5673a97437d2cbfd035316394", "patch": "@@ -624,6 +624,7 @@ fn main() { let _: m::Spam = S$0 }\n                                 Exact,\n                             ),\n                             is_local: false,\n+                            is_item_from_trait: false,\n                             is_op_method: false,\n                             is_private_editable: false,\n                             postfix_match: None,\n@@ -646,6 +647,7 @@ fn main() { let _: m::Spam = S$0 }\n                                 Exact,\n                             ),\n                             is_local: false,\n+                            is_item_from_trait: false,\n                             is_op_method: false,\n                             is_private_editable: false,\n                             postfix_match: None,\n@@ -734,6 +736,7 @@ fn foo() { A { the$0 } }\n                                 CouldUnify,\n                             ),\n                             is_local: false,\n+                            is_item_from_trait: false,\n                             is_op_method: false,\n                             is_private_editable: false,\n                             postfix_match: None,"}, {"sha": "0e60f748790bf07fcfeca3843255b432e4178ada", "filename": "crates/ide_completion/src/tests/item_list.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63acf724fa1e18b5673a97437d2cbfd035316394/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63acf724fa1e18b5673a97437d2cbfd035316394/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=63acf724fa1e18b5673a97437d2cbfd035316394", "patch": "@@ -241,11 +241,14 @@ impl Test for () {\n             kw fn\n             kw const\n             kw type\n+            ta type Type1 =\n+            ct const CONST1: () =\n+            fn fn function1()\n             kw self\n             kw super\n             kw crate\n             md module\n-            ma makro!(\u2026)  macro_rules! makro\n+            ma makro!(\u2026)          macro_rules! makro\n         \"#]],\n     );\n }"}, {"sha": "0fbfd8699214bd63376f16edace9394e3ef291e8", "filename": "crates/ide_db/src/traits.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/63acf724fa1e18b5673a97437d2cbfd035316394/crates%2Fide_db%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63acf724fa1e18b5673a97437d2cbfd035316394/crates%2Fide_db%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ftraits.rs?ref=63acf724fa1e18b5673a97437d2cbfd035316394", "patch": "@@ -3,10 +3,7 @@\n use crate::RootDatabase;\n use hir::Semantics;\n use rustc_hash::FxHashSet;\n-use syntax::{\n-    ast::{self, HasName},\n-    AstNode,\n-};\n+use syntax::{ast, AstNode};\n \n /// Given the `impl` block, attempts to find the trait this `impl` corresponds to.\n pub fn resolve_target_trait(\n@@ -28,32 +25,28 @@ pub fn get_missing_assoc_items(\n     sema: &Semantics<RootDatabase>,\n     impl_def: &ast::Impl,\n ) -> Vec<hir::AssocItem> {\n+    let imp = match sema.to_def(impl_def) {\n+        Some(it) => it,\n+        None => return vec![],\n+    };\n+\n     // Names must be unique between constants and functions. However, type aliases\n     // may share the same name as a function or constant.\n     let mut impl_fns_consts = FxHashSet::default();\n     let mut impl_type = FxHashSet::default();\n \n-    if let Some(item_list) = impl_def.assoc_item_list() {\n-        for item in item_list.assoc_items() {\n-            match item {\n-                ast::AssocItem::Fn(f) => {\n-                    if let Some(n) = f.name() {\n-                        impl_fns_consts.insert(n.syntax().to_string());\n-                    }\n-                }\n-\n-                ast::AssocItem::TypeAlias(t) => {\n-                    if let Some(n) = t.name() {\n-                        impl_type.insert(n.syntax().to_string());\n-                    }\n-                }\n-\n-                ast::AssocItem::Const(c) => {\n-                    if let Some(n) = c.name() {\n-                        impl_fns_consts.insert(n.syntax().to_string());\n-                    }\n+    for item in imp.items(sema.db) {\n+        match item {\n+            hir::AssocItem::Function(it) => {\n+                impl_fns_consts.insert(it.name(sema.db).to_string());\n+            }\n+            hir::AssocItem::Const(it) => {\n+                if let Some(name) = it.name(sema.db) {\n+                    impl_fns_consts.insert(name.to_string());\n                 }\n-                ast::AssocItem::MacroCall(_) => (),\n+            }\n+            hir::AssocItem::TypeAlias(it) => {\n+                impl_type.insert(it.name(sema.db).to_string());\n             }\n         }\n     }\n@@ -219,5 +212,22 @@ impl Foo {\n }\"#,\n             expect![[r#\"\"#]],\n         );\n+\n+        check_missing_assoc(\n+            r#\"\n+trait Tr {\n+    fn required();\n+}\n+macro_rules! m {\n+    () => { fn required() {} };\n+}\n+impl Tr for () {\n+    m!();\n+    $0\n+}\n+\n+            \"#,\n+            expect![[r#\"\"#]],\n+        );\n     }\n }"}]}