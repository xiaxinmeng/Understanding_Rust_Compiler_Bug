{"sha": "2f2c3e178325dc1837badcd7573c2c0905fab979", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMmMzZTE3ODMyNWRjMTgzN2JhZGNkNzU3M2MyYzA5MDVmYWI5Nzk=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-07-12T19:18:16Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-07-14T11:57:46Z"}, "message": "DCE and fixing some internal tests", "tree": {"sha": "612638d11f7a89f81c5ed7762b478affcb03c209", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/612638d11f7a89f81c5ed7762b478affcb03c209"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f2c3e178325dc1837badcd7573c2c0905fab979", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2c3e178325dc1837badcd7573c2c0905fab979", "html_url": "https://github.com/rust-lang/rust/commit/2f2c3e178325dc1837badcd7573c2c0905fab979", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f2c3e178325dc1837badcd7573c2c0905fab979/comments", "author": null, "committer": null, "parents": [{"sha": "f481879d2ae82a6f6ebe33202d4a1cfa8aece5ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/f481879d2ae82a6f6ebe33202d4a1cfa8aece5ed", "html_url": "https://github.com/rust-lang/rust/commit/f481879d2ae82a6f6ebe33202d4a1cfa8aece5ed"}], "stats": {"total": 1345, "additions": 132, "deletions": 1213}, "files": [{"sha": "901cd3403c1d22cdb5b765e358f2521622a50358", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 32, "deletions": 374, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c3e178325dc1837badcd7573c2c0905fab979/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c3e178325dc1837badcd7573c2c0905fab979/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=2f2c3e178325dc1837badcd7573c2c0905fab979", "patch": "@@ -14,13 +14,12 @@ use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, LineInfo,\n use registry;\n \n use check_old_skool;\n-use {Level, RenderSpan, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n+use {Level, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n use RenderSpan::*;\n-use Level::*;\n-use snippet::{SnippetData, StyledString, Style, FormatMode, Annotation, Line};\n+use snippet::{StyledString, Style, FormatMode, Annotation, Line};\n use styled_buffer::StyledBuffer;\n \n-use std::{cmp, fmt};\n+use std::cmp;\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n@@ -73,10 +72,6 @@ pub struct EmitterWriter {\n     registry: Option<registry::Registry>,\n     cm: Option<Rc<CodeMapper>>,\n \n-    /// Is this the first error emitted thus far? If not, we emit a\n-    /// `\\n` before the top-level errors.\n-    first: bool,\n-\n     // For now, allow an old-school mode while we transition\n     format_mode: FormatMode\n }\n@@ -112,13 +107,11 @@ impl EmitterWriter {\n             EmitterWriter { dst: dst,\n                             registry: registry,\n                             cm: code_map,\n-                            first: true,\n                             format_mode: format_mode.clone() }\n         } else {\n             EmitterWriter { dst: Raw(Box::new(io::stderr())),\n                             registry: registry,\n                             cm: code_map,\n-                            first: true,\n                             format_mode: format_mode.clone() }\n         }\n     }\n@@ -131,23 +124,9 @@ impl EmitterWriter {\n         EmitterWriter { dst: Raw(dst),\n                         registry: registry,\n                         cm: code_map,\n-                        first: true,\n                         format_mode: format_mode.clone() }\n     }\n \n-    fn emit_message(&mut self,\n-                    rsp: &RenderSpan,\n-                    msg: &str,\n-                    code: Option<&str>,\n-                    lvl: Level,\n-                    is_header: bool,\n-                    show_snippet: bool) {\n-        match self.emit_message_(rsp, msg, code, lvl, is_header, show_snippet) {\n-            Ok(()) => { }\n-            Err(e) => panic!(\"failed to emit error: {}\", e)\n-        }\n-    }\n-\n     fn preprocess_annotations(&self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n         fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n                                     file: Rc<FileMap>,\n@@ -187,7 +166,7 @@ impl EmitterWriter {\n \n         if let Some(ref cm) = self.cm {\n             for span_label in msp.span_labels() {\n-                let mut lo = cm.lookup_char_pos(span_label.span.lo);\n+                let lo = cm.lookup_char_pos(span_label.span.lo);\n                 let mut hi = cm.lookup_char_pos(span_label.span.hi);\n                 let mut is_minimized = false;\n \n@@ -478,7 +457,7 @@ impl EmitterWriter {\n \n         if msp.primary_spans().is_empty() && msp.span_labels().is_empty() && is_secondary {\n             // This is a secondary message with no span info\n-            for i in 0..max_line_num_len {\n+            for _ in 0..max_line_num_len {\n                 buffer.prepend(0, \" \", Style::NoStyle);\n             }\n             draw_note_separator(&mut buffer, 0, max_line_num_len + 1);\n@@ -511,7 +490,7 @@ impl EmitterWriter {\n                 cm.lookup_char_pos(primary_span.lo)\n             } else {\n                 // If we don't have span information, emit and exit\n-                emit_to_destination(&buffer.render(), level, &mut self.dst);\n+                emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n                 return Ok(());\n             };\n         if let Ok(pos) =\n@@ -526,19 +505,19 @@ impl EmitterWriter {\n             let is_primary = primary_lo.file.name == annotated_file.file.name;\n             if is_primary {\n                 // remember where we are in the output buffer for easy reference\n-                let mut buffer_msg_line_offset = buffer.num_lines();\n+                let buffer_msg_line_offset = buffer.num_lines();\n \n                 buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n                 let loc = primary_lo.clone();\n                 buffer.append(buffer_msg_line_offset,\n                                 &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0 + 1),\n                                 Style::LineAndColumn);\n-                for i in 0..max_line_num_len {\n+                for _ in 0..max_line_num_len {\n                     buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n                 }\n             } else {\n                 // remember where we are in the output buffer for easy reference\n-                let mut buffer_msg_line_offset = buffer.num_lines();\n+                let buffer_msg_line_offset = buffer.num_lines();\n \n                 // Add spacing line\n                 draw_col_separator(&mut buffer, buffer_msg_line_offset, max_line_num_len + 1);\n@@ -548,13 +527,13 @@ impl EmitterWriter {\n                 buffer.append(buffer_msg_line_offset + 1,\n                                 &annotated_file.file.name,\n                                 Style::LineAndColumn);\n-                for i in 0..max_line_num_len {\n+                for _ in 0..max_line_num_len {\n                     buffer.prepend(buffer_msg_line_offset + 1, \" \", Style::NoStyle);\n                 }\n             }\n \n             // Put in the spacer between the location and annotated source\n-            let mut buffer_msg_line_offset = buffer.num_lines();\n+            let buffer_msg_line_offset = buffer.num_lines();\n             draw_col_separator(&mut buffer, buffer_msg_line_offset, max_line_num_len + 1);\n \n             // Next, output the annotate source for this file\n@@ -599,7 +578,7 @@ impl EmitterWriter {\n         }\n \n         // final step: take our styled buffer, render it, then output it\n-        emit_to_destination(&buffer.render(), level, &mut self.dst);\n+        emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n \n         Ok(())\n     }\n@@ -624,12 +603,6 @@ impl EmitterWriter {\n             assert!(!lines.lines.is_empty());\n \n             let complete = suggestion.splice_lines(cm.borrow());\n-            let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n-            let display_lines = &lines.lines[..line_count];\n-\n-            let fm = &*lines.file;\n-            // Calculate the widest number to format evenly\n-            let max_digits = line_num_max_digits(display_lines.last().unwrap());\n \n             // print the suggestion without any line numbers, but leave\n             // space for them. This helps with lining up with previous\n@@ -646,7 +619,7 @@ impl EmitterWriter {\n             if let Some(_) = lines.next() {\n                 buffer.append(row_num, \"...\", Style::NoStyle);\n             }\n-            emit_to_destination(&buffer.render(), level, &mut self.dst);\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n         }\n         Ok(())\n     }\n@@ -664,7 +637,10 @@ impl EmitterWriter {\n                 if !db.children.is_empty() {\n                     let mut buffer = StyledBuffer::new();\n                     draw_col_separator(&mut buffer, 0, max_line_num_len + 1);\n-                    emit_to_destination(&buffer.render(), &db.level, &mut self.dst);\n+                    match emit_to_destination(&buffer.render(), &db.level, &mut self.dst) {\n+                        Ok(()) => (),\n+                        Err(e) => panic!(\"failed to emit error: {}\", e)\n+                    }\n                 }\n                 for child in &db.children {\n                     match child.render_span {\n@@ -704,7 +680,10 @@ impl EmitterWriter {\n             }\n             Err(e) => panic!(\"failed to emit error: {}\", e)\n         }\n-        write!(&mut self.dst, \"\\n\");\n+        match write!(&mut self.dst, \"\\n\") {\n+            Err(e) => panic!(\"failed to emit error: {}\", e),\n+            _ => ()\n+        }\n     }\n     fn emit_message_old_school(&mut self,\n                                msp: &MultiSpan,\n@@ -744,21 +723,21 @@ impl EmitterWriter {\n         }\n \n         if !show_snippet {\n-            emit_to_destination(&buffer.render(), level, &mut self.dst);\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n             return Ok(());\n         }\n \n         // Watch out for various nasty special spans; don't try to\n         // print any filename or anything for those.\n         match msp.primary_span() {\n             Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => {\n-                emit_to_destination(&buffer.render(), level, &mut self.dst);\n+                emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n                 return Ok(());\n             }\n             _ => { }\n         }\n \n-        let mut annotated_files = self.preprocess_annotations(msp);\n+        let annotated_files = self.preprocess_annotations(msp);\n \n         if let (Some(ref cm), Some(ann_file), Some(ref primary_span)) =\n             (self.cm.as_ref(), annotated_files.first(), msp.primary_span().as_ref()) {\n@@ -781,7 +760,7 @@ impl EmitterWriter {\n             buffer.puts(line_offset, 0, &file_pos, Style::FileNameStyle);\n             buffer.puts(line_offset, file_pos_len, &source_string, Style::Quotation);\n             // Sort the annotations by (start, end col)\n-            let mut annotations = ann_file.lines[0].annotations.clone();\n+            let annotations = ann_file.lines[0].annotations.clone();\n \n             // Next, create the highlight line.\n             for annotation in &annotations {\n@@ -830,7 +809,7 @@ impl EmitterWriter {\n         }\n \n         // final step: take our styled buffer, render it, then output it\n-        emit_to_destination(&buffer.render(), level, &mut self.dst);\n+        emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n         Ok(())\n     }\n     fn emit_suggestion_old_school(&mut self,\n@@ -874,7 +853,7 @@ impl EmitterWriter {\n             let mut row_num = 1;\n             for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n                 buffer.append(row_num, &fm.name, Style::FileNameStyle);\n-                for i in 0..max_digits+2 {\n+                for _ in 0..max_digits+2 {\n                     buffer.append(row_num, &\" \", Style::NoStyle);\n                 }\n                 buffer.append(row_num, line, Style::NoStyle);\n@@ -885,7 +864,7 @@ impl EmitterWriter {\n             if let Some(_) = lines.next() {\n                 buffer.append(row_num, \"...\", Style::NoStyle);\n             }\n-            emit_to_destination(&buffer.render(), level, &mut self.dst);\n+            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n         }\n         Ok(())\n     }\n@@ -905,7 +884,7 @@ impl EmitterWriter {\n                     };\n \n                     match child.render_span {\n-                        Some(FullSpan(ref msp)) => {\n+                        Some(FullSpan(_)) => {\n                             match self.emit_message_old_school(&span,\n                                                                &child.message,\n                                                                &None,\n@@ -940,235 +919,6 @@ impl EmitterWriter {\n         }\n     }\n \n-    fn emit_message_(&mut self,\n-                     rsp: &RenderSpan,\n-                     msg: &str,\n-                     code: Option<&str>,\n-                     lvl: Level,\n-                     is_header: bool,\n-                     show_snippet: bool)\n-                     -> io::Result<()> {\n-        let old_school = match self.format_mode {\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n-\n-        if is_header {\n-            if self.first {\n-                self.first = false;\n-            } else {\n-                if !old_school {\n-                    write!(self.dst, \"\\n\")?;\n-                }\n-            }\n-        }\n-\n-        match code {\n-            Some(code) if self.registry.as_ref()\n-                                       .and_then(|registry| registry.find_description(code))\n-                                       .is_some() => {\n-                let code_with_explain = String::from(\"--explain \") + code;\n-                if old_school {\n-                    let loc = match rsp.span().primary_span() {\n-                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-                        Some(ps) => if let Some(ref cm) = self.cm {\n-                            cm.span_to_string(ps)\n-                        } else {\n-                            \"\".to_string()\n-                        },\n-                        None => \"\".to_string()\n-                    };\n-                    print_diagnostic(&mut self.dst, &loc, lvl, msg, Some(code))?\n-                }\n-                else {\n-                    print_diagnostic(&mut self.dst, \"\", lvl, msg, Some(&code_with_explain))?\n-                }\n-            }\n-            _ => {\n-                if old_school {\n-                    let loc = match rsp.span().primary_span() {\n-                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-                        Some(ps) => if let Some(ref cm) = self.cm {\n-                            cm.span_to_string(ps)\n-                        } else {\n-                            \"\".to_string()\n-                        },\n-                        None => \"\".to_string()\n-                    };\n-                    print_diagnostic(&mut self.dst, &loc, lvl, msg, code)?\n-                }\n-                else {\n-                    print_diagnostic(&mut self.dst, \"\", lvl, msg, code)?\n-                }\n-            }\n-        }\n-\n-        if !show_snippet {\n-            return Ok(());\n-        }\n-\n-        // Watch out for various nasty special spans; don't try to\n-        // print any filename or anything for those.\n-        match rsp.span().primary_span() {\n-            Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => {\n-                return Ok(());\n-            }\n-            _ => { }\n-        }\n-\n-        // Otherwise, print out the snippet etc as needed.\n-        match *rsp {\n-            FullSpan(ref msp) => {\n-                self.highlight_lines(msp, lvl)?;\n-                if let Some(primary_span) = msp.primary_span() {\n-                    self.print_macro_backtrace(primary_span)?;\n-                }\n-            }\n-            Suggestion(ref suggestion) => {\n-                self.highlight_suggestion(suggestion)?;\n-                if let Some(primary_span) = rsp.span().primary_span() {\n-                    self.print_macro_backtrace(primary_span)?;\n-                }\n-            }\n-        }\n-        if old_school {\n-            match code {\n-                Some(code) if self.registry.as_ref()\n-                                        .and_then(|registry| registry.find_description(code))\n-                                        .is_some() => {\n-                    let loc = match rsp.span().primary_span() {\n-                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-                        Some(ps) => if let Some(ref cm) = self.cm {\n-                            cm.span_to_string(ps)\n-                        } else {\n-                            \"\".to_string()\n-                        },\n-                        None => \"\".to_string()\n-                    };\n-                    let msg = \"run `rustc --explain \".to_string() + &code.to_string() +\n-                        \"` to see a detailed explanation\";\n-                    print_diagnostic(&mut self.dst, &loc, Level::Help, &msg,\n-                        None)?\n-                }\n-                _ => ()\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    fn highlight_suggestion(&mut self, suggestion: &CodeSuggestion) -> io::Result<()>\n-    {\n-        use std::borrow::Borrow;\n-\n-        let primary_span = suggestion.msp.primary_span().unwrap();\n-        if let Some(ref cm) = self.cm {\n-            let lines = cm.span_to_lines(primary_span).unwrap();\n-\n-            assert!(!lines.lines.is_empty());\n-\n-            let complete = suggestion.splice_lines(cm.borrow());\n-            let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n-            let display_lines = &lines.lines[..line_count];\n-\n-            let fm = &*lines.file;\n-            // Calculate the widest number to format evenly\n-            let max_digits = line_num_max_digits(display_lines.last().unwrap());\n-\n-            // print the suggestion without any line numbers, but leave\n-            // space for them. This helps with lining up with previous\n-            // snippets from the actual error being reported.\n-            let mut lines = complete.lines();\n-            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-                write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n-                    fm.name, \"\", max_digits, line)?;\n-            }\n-\n-            // if we elided some lines, add an ellipsis\n-            if let Some(_) = lines.next() {\n-                write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n-                    \"\", fm.name.len(), max_digits)?;\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn highlight_lines(&mut self,\n-                       msp: &MultiSpan,\n-                       lvl: Level)\n-                       -> io::Result<()>\n-    {\n-        // Check to see if we have any lines to highlight, exit early if not\n-        match self.cm {\n-            None => return Ok(()),\n-            _ => ()\n-        }\n-\n-        let old_school = match self.format_mode {\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n-\n-        let mut snippet_data = SnippetData::new(self.cm.as_ref().unwrap().clone(),\n-                                                msp.primary_span(),\n-                                                self.format_mode.clone());\n-        if old_school {\n-            let mut output_vec = vec![];\n-\n-            for span_label in msp.span_labels() {\n-                let mut snippet_data = SnippetData::new(self.cm.as_ref().unwrap().clone(),\n-                                                        Some(span_label.span),\n-                                                        self.format_mode.clone());\n-\n-                snippet_data.push(span_label.span,\n-                                  span_label.is_primary,\n-                                  span_label.label);\n-                if span_label.is_primary {\n-                    output_vec.insert(0, snippet_data);\n-                }\n-                else {\n-                    output_vec.push(snippet_data);\n-                }\n-            }\n-\n-            for snippet_data in output_vec.iter() {\n-                /*\n-                let rendered_lines = snippet_data.render_lines();\n-                for rendered_line in &rendered_lines {\n-                    for styled_string in &rendered_line.text {\n-                        self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n-                        write!(&mut self.dst, \"{}\", styled_string.text)?;\n-                        self.dst.reset_attrs()?;\n-                    }\n-                    write!(&mut self.dst, \"\\n\")?;\n-                }\n-                */\n-                emit_to_destination(&snippet_data.render_lines(), &lvl, &mut self.dst);\n-            }\n-        }\n-        else {\n-            for span_label in msp.span_labels() {\n-                snippet_data.push(span_label.span,\n-                                  span_label.is_primary,\n-                                  span_label.label);\n-            }\n-            emit_to_destination(&snippet_data.render_lines(), &lvl, &mut self.dst);\n-            /*\n-            let rendered_lines = snippet_data.render_lines();\n-            for rendered_line in &rendered_lines {\n-                for styled_string in &rendered_line.text {\n-                    self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n-                    write!(&mut self.dst, \"{}\", styled_string.text)?;\n-                    self.dst.reset_attrs()?;\n-                }\n-                write!(&mut self.dst, \"\\n\")?;\n-            }\n-            */\n-        }\n-        Ok(())\n-    }\n-\n     fn render_macro_backtrace_old_school(&mut self,\n                                          sp: &Span,\n                                          buffer: &mut StyledBuffer) -> io::Result<()> {\n@@ -1192,24 +942,6 @@ impl EmitterWriter {\n         }\n         Ok(())\n     }\n-    fn print_macro_backtrace(&mut self,\n-                             sp: Span)\n-                             -> io::Result<()> {\n-        if let Some(ref cm) = self.cm {\n-            for trace in cm.macro_backtrace(sp) {\n-                let mut diag_string =\n-                    format!(\"in this expansion of {}\", trace.macro_decl_name);\n-                if let Some(def_site_span) = trace.def_site_span {\n-                    diag_string.push_str(\n-                        &format!(\" (defined in {})\",\n-                            cm.span_to_filename(def_site_span)));\n-                }\n-                let snippet = cm.span_to_string(trace.call_site);\n-                print_diagnostic(&mut self.dst, &snippet, Note, &diag_string, None)?;\n-            }\n-        }\n-        Ok(())\n-    }\n }\n \n fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n@@ -1230,11 +962,11 @@ fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n         dst: &mut Destination) -> io::Result<()> {\n     for line in rendered_buffer {\n         for part in line {\n-            dst.apply_style(lvl.clone(), part.style);\n-            write!(dst, \"{}\", part.text);\n+            dst.apply_style(lvl.clone(), part.style)?;\n+            write!(dst, \"{}\", part.text)?;\n             dst.reset_attrs()?;\n         }\n-        write!(dst, \"\\n\");\n+        write!(dst, \"\\n\")?;\n     }\n     Ok(())\n }\n@@ -1249,40 +981,6 @@ fn line_num_max_digits(line: &LineInfo) -> usize {\n     digits\n }\n \n-fn print_diagnostic(dst: &mut Destination,\n-                    topic: &str,\n-                    lvl: Level,\n-                    msg: &str,\n-                    code: Option<&str>)\n-                    -> io::Result<()> {\n-    if !topic.is_empty() {\n-        let old_school = check_old_skool();\n-        if !old_school {\n-            write!(dst, \"{}: \", topic)?;\n-        }\n-        else {\n-            write!(dst, \"{} \", topic)?;\n-        }\n-        dst.reset_attrs()?;\n-    }\n-    dst.start_attr(term::Attr::Bold)?;\n-    dst.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n-    write!(dst, \"{}\", lvl.to_string())?;\n-    dst.reset_attrs()?;\n-    write!(dst, \": \")?;\n-    dst.start_attr(term::Attr::Bold)?;\n-    write!(dst, \"{}\", msg)?;\n-\n-    if let Some(code) = code {\n-        let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-        print_maybe_styled!(dst, style, \" [{}]\", code.clone())?;\n-    }\n-\n-    dst.reset_attrs()?;\n-    write!(dst, \"\\n\")?;\n-    Ok(())\n-}\n-\n #[cfg(unix)]\n fn stderr_isatty() -> bool {\n     use libc;\n@@ -1374,46 +1072,6 @@ impl Destination {\n         }\n         Ok(())\n     }\n-\n-    fn print_maybe_styled(&mut self,\n-                          args: fmt::Arguments,\n-                          color: term::Attr,\n-                          print_newline_at_end: bool)\n-                          -> io::Result<()> {\n-        match *self {\n-            Terminal(ref mut t) => {\n-                t.attr(color)?;\n-                // If `msg` ends in a newline, we need to reset the color before\n-                // the newline. We're making the assumption that we end up writing\n-                // to a `LineBufferedWriter`, which means that emitting the reset\n-                // after the newline ends up buffering the reset until we print\n-                // another line or exit. Buffering the reset is a problem if we're\n-                // sharing the terminal with any other programs (e.g. other rustc\n-                // instances via `make -jN`).\n-                //\n-                // Note that if `msg` contains any internal newlines, this will\n-                // result in the `LineBufferedWriter` flushing twice instead of\n-                // once, which still leaves the opportunity for interleaved output\n-                // to be miscolored. We assume this is rare enough that we don't\n-                // have to worry about it.\n-                t.write_fmt(args)?;\n-                t.reset()?;\n-                if print_newline_at_end {\n-                    t.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-            Raw(ref mut w) => {\n-                w.write_fmt(args)?;\n-                if print_newline_at_end {\n-                    w.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-        }\n-    }\n }\n \n impl Write for Destination {"}, {"sha": "d5340e66ff0c46a7a9dd7d9d3d74835a41ca6bc1", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c3e178325dc1837badcd7573c2c0905fab979/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c3e178325dc1837badcd7573c2c0905fab979/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=2f2c3e178325dc1837badcd7573c2c0905fab979", "patch": "@@ -82,16 +82,6 @@ pub trait CodeMapper {\n     fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace>;\n }\n \n-impl RenderSpan {\n-    fn span(&self) -> &MultiSpan {\n-        match *self {\n-            FullSpan(ref msp) |\n-            Suggestion(CodeSuggestion { ref msp, .. }) =>\n-                msp\n-        }\n-    }\n-}\n-\n impl CodeSuggestion {\n     /// Returns the assembled code suggestion.\n     pub fn splice_lines(&self, cm: &CodeMapper) -> String {"}, {"sha": "2f94a7f6832fe34401b3a52b6d54cb7d610023ef", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 2, "deletions": 731, "changes": 733, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c3e178325dc1837badcd7573c2c0905fab979/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c3e178325dc1837badcd7573c2c0905fab979/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=2f2c3e178325dc1837badcd7573c2c0905fab979", "patch": "@@ -10,13 +10,9 @@\n \n // Code for annotating snippets.\n \n-use syntax_pos::{Span, FileMap, CharPos, LineInfo};\n-use check_old_skool;\n+use syntax_pos::{Span, FileMap};\n use CodeMapper;\n-use styled_buffer::StyledBuffer;\n-use std::cmp;\n use std::rc::Rc;\n-use std::mem;\n use {Level};\n \n #[derive(Clone)]\n@@ -78,14 +74,6 @@ pub struct Annotation {\n     pub label: Option<String>,\n }\n \n-/*\n-#[derive(Debug)]\n-pub struct RenderedLine {\n-    pub text: Vec<StyledString>,\n-    pub kind: RenderedLineKind,\n-}\n-*/\n-\n #[derive(Debug)]\n pub struct StyledString {\n     pub text: String,\n@@ -108,721 +96,4 @@ pub enum Style {\n     NoStyle,\n     ErrorCode,\n     Level(Level),\n-}\n-\n-/*\n-#[derive(Debug, Clone)]\n-pub enum RenderedLineKind {\n-    PrimaryFileName,\n-    OtherFileName,\n-    SourceText {\n-        file: Rc<FileMap>,\n-        line_index: usize,\n-    },\n-    Annotations,\n-    Elision,\n-}\n-*/\n-\n-impl SnippetData {\n-    pub fn new(codemap: Rc<CodeMapper>,\n-               primary_span: Option<Span>,\n-               format_mode: FormatMode) // (*)\n-               -> Self {\n-        // (*) The primary span indicates the file that must appear\n-        // first, and which will have a line number etc in its\n-        // name. Outside of tests, this is always `Some`, but for many\n-        // tests it's not relevant to test this portion of the logic,\n-        // and it's tedious to pick a primary span (read: tedious to\n-        // port older tests that predate the existence of a primary\n-        // span).\n-\n-        debug!(\"SnippetData::new(primary_span={:?})\", primary_span);\n-\n-        let mut data = SnippetData {\n-            codemap: codemap.clone(),\n-            files: vec![],\n-            format_mode: format_mode.clone()\n-        };\n-        if let Some(primary_span) = primary_span {\n-            let lo = codemap.lookup_char_pos(primary_span.lo);\n-            data.files.push(\n-                FileInfo {\n-                    file: lo.file,\n-                    primary_span: Some(primary_span),\n-                    lines: vec![],\n-                    format_mode: format_mode.clone(),\n-                });\n-        }\n-        data\n-    }\n-\n-    pub fn push(&mut self, span: Span, is_primary: bool, label: Option<String>) {\n-        debug!(\"SnippetData::push(span={:?}, is_primary={}, label={:?})\",\n-               span, is_primary, label);\n-\n-        let file_lines = match self.codemap.span_to_lines(span) {\n-            Ok(file_lines) => file_lines,\n-            Err(_) => {\n-                // ignore unprintable spans completely.\n-                return;\n-            }\n-        };\n-\n-        self.file(&file_lines.file)\n-            .push_lines(&file_lines.lines, is_primary, label);\n-    }\n-\n-    fn file(&mut self, file_map: &Rc<FileMap>) -> &mut FileInfo {\n-        let index = self.files.iter().position(|f| f.file.name == file_map.name);\n-        if let Some(index) = index {\n-            return &mut self.files[index];\n-        }\n-\n-        self.files.push(\n-            FileInfo {\n-                file: file_map.clone(),\n-                lines: vec![],\n-                primary_span: None,\n-                format_mode: self.format_mode.clone()\n-            });\n-        self.files.last_mut().unwrap()\n-    }\n-\n-    pub fn render_lines(&self) -> Vec<Vec<StyledString>> {\n-        debug!(\"SnippetData::render_lines()\");\n-\n-        let mut rendered_lines: Vec<_> =\n-            self.files.iter()\n-                      .flat_map(|f| f.render_file_lines(&self.codemap))\n-                      .collect();\n-        //prepend_prefixes(&mut rendered_lines, &self.format_mode);\n-        //trim_lines(&mut rendered_lines);\n-        rendered_lines\n-    }\n-}\n-\n-pub trait StringSource {\n-    fn make_string(self) -> String;\n-}\n-\n-impl StringSource for String {\n-    fn make_string(self) -> String {\n-        self\n-    }\n-}\n-\n-impl StringSource for Vec<char> {\n-    fn make_string(self) -> String {\n-        self.into_iter().collect()\n-    }\n-}\n-\n-/*\n-impl<S> From<(S, Style, RenderedLineKind)> for RenderedLine\n-    where S: StringSource\n-{\n-    fn from((text, style, kind): (S, Style, RenderedLineKind)) -> Self {\n-        RenderedLine {\n-            text: vec![StyledString {\n-                text: text.make_string(),\n-                style: style,\n-            }],\n-            kind: kind,\n-        }\n-    }\n-}\n-\n-impl<S1,S2> From<(S1, Style, S2, Style, RenderedLineKind)> for RenderedLine\n-    where S1: StringSource, S2: StringSource\n-{\n-    fn from(tuple: (S1, Style, S2, Style, RenderedLineKind)) -> Self {\n-        let (text1, style1, text2, style2, kind) = tuple;\n-        RenderedLine {\n-            text: vec![\n-                StyledString {\n-                    text: text1.make_string(),\n-                    style: style1,\n-                },\n-                StyledString {\n-                    text: text2.make_string(),\n-                    style: style2,\n-                }\n-            ],\n-            kind: kind,\n-        }\n-    }\n-}\n-\n-impl RenderedLine {\n-    fn trim_last(&mut self) {\n-        if let Some(last_text) = self.text.last_mut() {\n-            let len = last_text.text.trim_right().len();\n-            last_text.text.truncate(len);\n-        }\n-    }\n-}\n-\n-impl RenderedLineKind {\n-    fn prefix(&self) -> StyledString {\n-        match *self {\n-            RenderedLineKind::SourceText { file: _, line_index } =>\n-                StyledString {\n-                    text: format!(\"{}\", line_index + 1),\n-                    style: Style::LineNumber,\n-                },\n-            RenderedLineKind::Elision =>\n-                StyledString {\n-                    text: String::from(\"...\"),\n-                    style: Style::LineNumber,\n-                },\n-            RenderedLineKind::PrimaryFileName |\n-            RenderedLineKind::OtherFileName |\n-            RenderedLineKind::Annotations =>\n-                StyledString {\n-                    text: String::from(\"\"),\n-                    style: Style::LineNumber,\n-                },\n-        }\n-    }\n-}\n-*/\n-\n-impl FileInfo {\n-    fn get_max_line_num(&self) -> usize {\n-        let mut max = 0;\n-\n-        for line in &self.lines {\n-            if line.line_index > max {\n-                max = line.line_index;\n-            }\n-        }\n-        max\n-    }\n-\n-    fn push_lines(&mut self,\n-                  lines: &[LineInfo],\n-                  is_primary: bool,\n-                  label: Option<String>) {\n-        assert!(lines.len() > 0);\n-\n-        // If a span covers multiple lines, we reduce it to a single\n-        // point at the start of the span. This means that instead\n-        // of producing output like this:\n-        //\n-        // ```\n-        // --> foo.rs:2:1\n-        // 2   |> fn conflicting_items<'grammar>(state: &LR0State<'grammar>)\n-        //     |> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-        // 3   |>                               -> Set<LR0Item<'grammar>>\n-        //     |> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-        // (and so on)\n-        // ```\n-        //\n-        // we produce:\n-        //\n-        // ```\n-        // --> foo.rs:2:1\n-        // 2   |> fn conflicting_items<'grammar>(state: &LR0State<'grammar>)\n-        //        ^\n-        // ```\n-        //\n-        // Basically, although this loses information, multi-line spans just\n-        // never look good.\n-\n-        let (line, start_col, mut end_col, is_minimized) = if lines.len() == 1 {\n-            (lines[0].line_index, lines[0].start_col, lines[0].end_col, false)\n-        } else {\n-            (lines[0].line_index, lines[0].start_col, CharPos(lines[0].start_col.0 + 1), true)\n-        };\n-\n-        // Watch out for \"empty spans\". If we get a span like 6..6, we\n-        // want to just display a `^` at 6, so convert that to\n-        // 6..7. This is degenerate input, but it's best to degrade\n-        // gracefully -- and the parser likes to suply a span like\n-        // that for EOF, in particular.\n-        if start_col == end_col {\n-            end_col.0 += 1;\n-        }\n-\n-        let index = self.ensure_source_line(line);\n-        self.lines[index].push_annotation(start_col,\n-                                          end_col,\n-                                          is_primary,\n-                                          is_minimized,\n-                                          label);\n-    }\n-\n-    /// Ensure that we have a `Line` struct corresponding to\n-    /// `line_index` in the file. If we already have some other lines,\n-    /// then this will add the intervening lines to ensure that we\n-    /// have a complete snippet. (Note that when we finally display,\n-    /// some of those lines may be elided.)\n-    fn ensure_source_line(&mut self, line_index: usize) -> usize {\n-        if self.lines.is_empty() {\n-            self.lines.push(Line::new(line_index));\n-            return 0;\n-        }\n-\n-        // Find the range of lines we have thus far.\n-        let first_line_index = self.lines.first().unwrap().line_index;\n-        let last_line_index = self.lines.last().unwrap().line_index;\n-        assert!(first_line_index <= last_line_index);\n-\n-        // If the new line is lower than all the lines we have thus\n-        // far, then insert the new line and any intervening lines at\n-        // the front. In a silly attempt at micro-optimization, we\n-        // don't just call `insert` repeatedly, but instead make a new\n-        // (empty) vector, pushing the new lines onto it, and then\n-        // appending the old vector.\n-        if line_index < first_line_index {\n-            let lines = mem::replace(&mut self.lines, vec![]);\n-            self.lines.extend(\n-                (line_index .. first_line_index)\n-                    .map(|line| Line::new(line))\n-                    .chain(lines));\n-            return 0;\n-        }\n-\n-        // If the new line comes after the ones we have so far, insert\n-        // lines for it.\n-        if line_index > last_line_index {\n-            self.lines.extend(\n-                (last_line_index+1 .. line_index+1)\n-                    .map(|line| Line::new(line)));\n-            return self.lines.len() - 1;\n-        }\n-\n-        // Otherwise it should already exist.\n-        return line_index - first_line_index;\n-    }\n-\n-    fn render_file_lines(&self, codemap: &Rc<CodeMapper>) -> Vec<Vec<StyledString>> {\n-        let old_school = match self.format_mode {\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n-\n-        let mut lines_iter = self.lines.iter();\n-        let mut output = vec![];\n-\n-        // First insert the name of the file.\n-        if !old_school {\n-            match self.primary_span {\n-                Some(span) => {\n-                    let lo = codemap.lookup_char_pos(span.lo);\n-                    output.push(vec![StyledString {\n-                            text: lo.file.name.clone(),\n-                            style: Style::FileNameStyle,\n-                        }, StyledString {\n-                            text: format!(\":{}:{}\", lo.line, lo.col.0 + 1),\n-                            style: Style::LineAndColumn,\n-                        }]);\n-                    output.push(vec![StyledString {\n-                            text: \"\".to_string(),\n-                            style: Style::FileNameStyle,\n-                        }]);\n-                }\n-                None => {\n-                    output.push(vec![StyledString {\n-                            text: self.file.name.clone(),\n-                            style: Style::FileNameStyle,\n-                        }]);\n-                    output.push(vec![StyledString {\n-                            text: \"\".to_string(),\n-                            style: Style::FileNameStyle,\n-                        }]);\n-                }\n-            }\n-        }\n-\n-        let mut next_line = lines_iter.next();\n-        while next_line.is_some() {\n-            // Consume lines with annotations.\n-            while let Some(line) = next_line {\n-                if line.annotations.is_empty() { break; }\n-\n-                let mut rendered_lines = self.render_line(line);\n-                assert!(!rendered_lines.is_empty());\n-                if old_school {\n-                    match self.primary_span {\n-                        Some(span) => {\n-                            let lo = codemap.lookup_char_pos(span.lo);\n-                            let hi = codemap.lookup_char_pos(span.hi);\n-                            //Before each secondary line in old skool-mode, print the label\n-                            //as an old-style note\n-                            if !line.annotations[0].is_primary {\n-                                if let Some(ann) = line.annotations[0].label.clone() {\n-                                    output.push(vec![StyledString {\n-                                            text: lo.file.name.clone(),\n-                                            style: Style::FileNameStyle,\n-                                        }, StyledString {\n-                                            text: format!(\":{}:{}: {}:{} \", lo.line, lo.col.0 + 1,\n-                                                hi.line, hi.col.0+1),\n-                                            style: Style::LineAndColumn,\n-                                        }, StyledString {\n-                                            text: format!(\"note: \"),\n-                                            style: Style::OldSchoolNote,\n-                                        }, StyledString {\n-                                            text: format!(\"{}\", ann),\n-                                            style: Style::OldSchoolNoteText,\n-                                        }]);\n-                                }\n-                            }\n-                            rendered_lines[0].insert(0, StyledString {\n-                                text: format!(\":{} \", lo.line),\n-                                style: Style::LineAndColumn,\n-                            });\n-                            rendered_lines[0].insert(0, StyledString {\n-                                text: lo.file.name.clone(),\n-                                style: Style::FileNameStyle,\n-                            });\n-                            let gap_amount =\n-                                rendered_lines[0][0].text.len() +\n-                                rendered_lines[0][1].text.len();\n-                            assert!(rendered_lines.len() >= 2,\n-                                    \"no annotations resulted from: {:?}\",\n-                                    line);\n-                            for i in 1..rendered_lines.len() {\n-                                rendered_lines[i].insert(0, StyledString {\n-                                    text: vec![\" \"; gap_amount].join(\"\"),\n-                                    style: Style::NoStyle\n-                                });\n-                            }\n-                        }\n-                        _ =>()\n-                    }\n-                }\n-                output.append(&mut rendered_lines);\n-                next_line = lines_iter.next();\n-            }\n-\n-            // Emit lines without annotations, but only if they are\n-            // followed by a line with an annotation.\n-            let unannotated_line = next_line;\n-            let mut unannotated_lines = 0;\n-            while let Some(line) = next_line {\n-                if !line.annotations.is_empty() { break; }\n-                unannotated_lines += 1;\n-                next_line = lines_iter.next();\n-            }\n-            if unannotated_lines > 1 {\n-                output.push(vec![StyledString{ text: String::new(), style: Style::NoStyle}]);\n-            } else if let Some(line) = unannotated_line {\n-                output.append(&mut self.render_line(line));\n-            }\n-        }\n-\n-        output\n-    }\n-\n-    fn render_line(&self, line: &Line) -> Vec<Vec<StyledString>> {\n-        let old_school = match self.format_mode {\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::EnvironmentSelected => check_old_skool()\n-        };\n-\n-        let source_string = self.file.get_line(line.line_index)\n-                                     .unwrap_or(\"\");\n-        /*\n-        let source_kind = RenderedLineKind::SourceText {\n-            file: self.file.clone(),\n-            line_index: line.line_index,\n-        };\n-        */\n-\n-        let mut styled_buffer = StyledBuffer::new();\n-\n-        // First create the source line we will highlight.\n-        styled_buffer.append(0, &source_string, Style::Quotation);\n-\n-        if line.annotations.is_empty() {\n-            return styled_buffer.render();\n-        }\n-\n-        // We want to display like this:\n-        //\n-        //      vec.push(vec.pop().unwrap());\n-        //      ---      ^^^               _ previous borrow ends here\n-        //      |        |\n-        //      |        error occurs here\n-        //      previous borrow of `vec` occurs here\n-        //\n-        // But there are some weird edge cases to be aware of:\n-        //\n-        //      vec.push(vec.pop().unwrap());\n-        //      --------                    - previous borrow ends here\n-        //      ||\n-        //      |this makes no sense\n-        //      previous borrow of `vec` occurs here\n-        //\n-        // For this reason, we group the lines into \"highlight lines\"\n-        // and \"annotations lines\", where the highlight lines have the `~`.\n-\n-        //let mut highlight_line = Self::whitespace(&source_string);\n-\n-        // Sort the annotations by (start, end col)\n-        let mut annotations = line.annotations.clone();\n-        annotations.sort();\n-\n-        // Next, create the highlight line.\n-        for annotation in &annotations {\n-            if old_school {\n-                for p in annotation.start_col .. annotation.end_col {\n-                    if p == annotation.start_col {\n-                        styled_buffer.putc(1, p, '^',\n-                            if annotation.is_primary {\n-                                Style::UnderlinePrimary\n-                            } else {\n-                                Style::OldSchoolNote\n-                            });\n-                    }\n-                    else {\n-                        styled_buffer.putc(1, p, '~',\n-                            if annotation.is_primary {\n-                                Style::UnderlinePrimary\n-                            } else {\n-                                Style::OldSchoolNote\n-                            });\n-                    }\n-                }\n-            }\n-            else {\n-                for p in annotation.start_col .. annotation.end_col {\n-                    if annotation.is_primary {\n-                        styled_buffer.putc(1, p, '^', Style::UnderlinePrimary);\n-                        if !annotation.is_minimized {\n-                            styled_buffer.set_style(0, p, Style::UnderlinePrimary);\n-                        }\n-                    } else {\n-                        styled_buffer.putc(1, p, '-', Style::UnderlineSecondary);\n-                        if !annotation.is_minimized {\n-                            styled_buffer.set_style(0, p, Style::UnderlineSecondary);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Now we are going to write labels in. To start, we'll exclude\n-        // the annotations with no labels.\n-        let (labeled_annotations, unlabeled_annotations): (Vec<_>, _) =\n-            annotations.into_iter()\n-                       .partition(|a| a.label.is_some());\n-\n-        // If there are no annotations that need text, we're done.\n-        if labeled_annotations.is_empty() {\n-            return styled_buffer.render();\n-        }\n-        if old_school {\n-            return styled_buffer.render();\n-        }\n-\n-        // Now add the text labels. We try, when possible, to stick the rightmost\n-        // annotation at the end of the highlight line:\n-        //\n-        //      vec.push(vec.pop().unwrap());\n-        //      ---      ---               - previous borrow ends here\n-        //\n-        // But sometimes that's not possible because one of the other\n-        // annotations overlaps it. For example, from the test\n-        // `span_overlap_label`, we have the following annotations\n-        // (written on distinct lines for clarity):\n-        //\n-        //      fn foo(x: u32) {\n-        //      --------------\n-        //             -\n-        //\n-        // In this case, we can't stick the rightmost-most label on\n-        // the highlight line, or we would get:\n-        //\n-        //      fn foo(x: u32) {\n-        //      -------- x_span\n-        //      |\n-        //      fn_span\n-        //\n-        // which is totally weird. Instead we want:\n-        //\n-        //      fn foo(x: u32) {\n-        //      --------------\n-        //      |      |\n-        //      |      x_span\n-        //      fn_span\n-        //\n-        // which is...less weird, at least. In fact, in general, if\n-        // the rightmost span overlaps with any other span, we should\n-        // use the \"hang below\" version, so we can at least make it\n-        // clear where the span *starts*.\n-        let mut labeled_annotations = &labeled_annotations[..];\n-        match labeled_annotations.split_last().unwrap() {\n-            (last, previous) => {\n-                if previous.iter()\n-                           .chain(&unlabeled_annotations)\n-                           .all(|a| !overlaps(a, last))\n-                {\n-                    // append the label afterwards; we keep it in a separate\n-                    // string\n-                    let highlight_label: String = format!(\" {}\", last.label.as_ref().unwrap());\n-                    if last.is_primary {\n-                        styled_buffer.append(1, &highlight_label, Style::LabelPrimary);\n-                    } else {\n-                        styled_buffer.append(1, &highlight_label, Style::LabelSecondary);\n-                    }\n-                    labeled_annotations = previous;\n-                }\n-            }\n-        }\n-\n-        // If that's the last annotation, we're done\n-        if labeled_annotations.is_empty() {\n-            return styled_buffer.render();\n-        }\n-\n-        for (index, annotation) in labeled_annotations.iter().enumerate() {\n-            // Leave:\n-            // - 1 extra line\n-            // - One line for each thing that comes after\n-            let comes_after = labeled_annotations.len() - index - 1;\n-            let blank_lines = 3 + comes_after;\n-\n-            // For each blank line, draw a `|` at our column. The\n-            // text ought to be long enough for this.\n-            for index in 2..blank_lines {\n-                if annotation.is_primary {\n-                    styled_buffer.putc(index, annotation.start_col, '|', Style::UnderlinePrimary);\n-                } else {\n-                    styled_buffer.putc(index, annotation.start_col, '|', Style::UnderlineSecondary);\n-                }\n-            }\n-\n-            if annotation.is_primary {\n-                styled_buffer.puts(blank_lines, annotation.start_col,\n-                    annotation.label.as_ref().unwrap(), Style::LabelPrimary);\n-            } else {\n-                styled_buffer.puts(blank_lines, annotation.start_col,\n-                    annotation.label.as_ref().unwrap(), Style::LabelSecondary);\n-            }\n-        }\n-\n-        styled_buffer.render()\n-    }\n-}\n-\n-/*\n-fn prepend_prefixes(rendered_lines: &mut [RenderedLine], format_mode: &FormatMode) {\n-    let old_school = match *format_mode {\n-        FormatMode::OriginalErrorFormat => true,\n-        FormatMode::NewErrorFormat => false,\n-        FormatMode::EnvironmentSelected => check_old_skool()\n-    };\n-    if old_school {\n-        return;\n-    }\n-\n-    let prefixes: Vec<_> =\n-        rendered_lines.iter()\n-                      .map(|rl| rl.kind.prefix())\n-                      .collect();\n-\n-    // find the max amount of spacing we need; add 1 to\n-    // p.text.len() to leave space between the prefix and the\n-    // source text\n-    let padding_len =\n-        prefixes.iter()\n-                .map(|p| if p.text.len() == 0 { 0 } else { p.text.len() + 1 })\n-                .max()\n-                .unwrap_or(0);\n-\n-    // Ensure we insert at least one character of padding, so that the\n-    // `-->` arrows can fit etc.\n-    let padding_len = cmp::max(padding_len, 1);\n-\n-    for (mut prefix, line) in prefixes.into_iter().zip(rendered_lines) {\n-        let extra_spaces = (prefix.text.len() .. padding_len).map(|_| ' ');\n-        prefix.text.extend(extra_spaces);\n-        match line.kind {\n-            RenderedLineKind::Elision => {\n-                line.text.insert(0, prefix);\n-            }\n-            RenderedLineKind::PrimaryFileName => {\n-                //   --> filename\n-                // 22 |>\n-                //   ^\n-                //   padding_len\n-                let dashes = (0..padding_len - 1).map(|_| ' ')\n-                                                 .chain(Some('-'))\n-                                                 .chain(Some('-'))\n-                                                 .chain(Some('>'))\n-                                                 .chain(Some(' '));\n-                line.text.insert(0, StyledString {text: dashes.collect(),\n-                                                  style: Style::LineNumber})\n-            }\n-            RenderedLineKind::OtherFileName => {\n-                //   ::: filename\n-                // 22 |>\n-                //   ^\n-                //   padding_len\n-                let dashes = (0..padding_len - 1).map(|_| ' ')\n-                                                 .chain(Some(':'))\n-                                                 .chain(Some(':'))\n-                                                 .chain(Some(':'))\n-                                                 .chain(Some(' '));\n-                line.text.insert(0, StyledString {text: dashes.collect(),\n-                                                  style: Style::LineNumber})\n-            }\n-            _ => {\n-                line.text.insert(0, prefix);\n-                line.text.insert(1, StyledString {text: String::from(\"|> \"),\n-                                                  style: Style::LineNumber})\n-            }\n-        }\n-    }\n-}\n-\n-fn trim_lines(rendered_lines: &mut [RenderedLine]) {\n-    for line in rendered_lines {\n-        while !line.text.is_empty() {\n-            line.trim_last();\n-            if line.text.last().unwrap().text.is_empty() {\n-                line.text.pop();\n-            } else {\n-                break;\n-            }\n-        }\n-    }\n-}\n-*/\n-\n-impl Line {\n-    fn new(line_index: usize) -> Line {\n-        Line {\n-            line_index: line_index,\n-            annotations: vec![]\n-        }\n-    }\n-\n-    fn push_annotation(&mut self,\n-                       start: CharPos,\n-                       end: CharPos,\n-                       is_primary: bool,\n-                       is_minimized: bool,\n-                       label: Option<String>) {\n-        self.annotations.push(Annotation {\n-            start_col: start.0,\n-            end_col: end.0,\n-            is_primary: is_primary,\n-            is_minimized: is_minimized,\n-            label: label,\n-        });\n-    }\n-}\n-\n-fn overlaps(a1: &Annotation,\n-            a2: &Annotation)\n-            -> bool\n-{\n-    (a2.start_col .. a2.end_col).contains(a1.start_col) ||\n-        (a1.start_col .. a1.end_col).contains(a2.start_col)\n-}\n+}\n\\ No newline at end of file"}, {"sha": "80b38a8e48ef98149bfbc4321c2b5f3b5395409d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c3e178325dc1837badcd7573c2c0905fab979/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c3e178325dc1837badcd7573c2c0905fab979/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2f2c3e178325dc1837badcd7573c2c0905fab979", "patch": "@@ -1265,9 +1265,9 @@ r\"blork2.rs:2:1: 2:12\n         println!(\"r#\\\"\\n{}\\\"#\", str);\n         assert_eq!(str, &r#\"\n   --> dummy.txt:11:1\n-   |>\n-11 |>         e-l\u00e4-v\u00e4n\n-   |> ^\n+   | \n+11 |          e-l\u00e4-v\u00e4n\n+   |  ^\n \"#[1..]);\n     }\n \n@@ -1333,9 +1333,9 @@ r\"blork2.rs:2:1: 2:12\n \n         let expect_start = &r#\"\n  --> dummy.txt:1:6\n-  |>\n-1 |> _____aaaaaa____bbbbbb__cccccdd_\n-  |>      ^^^^^^    ^^^^^^  ^^^^^^^\n+  | \n+1 |  _____aaaaaa____bbbbbb__cccccdd_\n+  |       ^^^^^^    ^^^^^^  ^^^^^^^\n \"#[1..];\n \n         let span = |sp, expected| {\n@@ -1409,28 +1409,28 @@ r\"blork2.rs:2:1: 2:12\n \n         let expect0 = &r#\"\n    --> dummy.txt:5:1\n-    |>\n-5   |> ccccc\n-    |> ^\n+    | \n+5   |  ccccc\n+    |  ^\n ...\n-9   |> ddd__eee_\n-    |> ^^^  ^^^\n-10  |> elided\n-11  |> __f_gg\n-    |>   ^ ^^\n+9   |  ddd__eee_\n+    |  ^^^  ^^^\n+10  |  elided\n+11  |  __f_gg\n+    |    ^ ^^\n \"#[1..];\n \n         let expect = &r#\"\n    --> dummy.txt:1:1\n-    |>\n-1   |> aaaaa\n-    |> ^\n+    | \n+1   |  aaaaa\n+    |  ^\n ...\n-9   |> ddd__eee_\n-    |> ^^^  ^^^\n-10  |> elided\n-11  |> __f_gg\n-    |>   ^ ^^\n+9   |  ddd__eee_\n+    |  ^^^  ^^^\n+10  |  elided\n+11  |  __f_gg\n+    |    ^ ^^\n \"#[1..];\n \n         macro_rules! test {\n@@ -1477,9 +1477,9 @@ fn foo() {\n         let text = make_string(&lines);\n         assert_eq!(&text[..], &\"\n  --> foo.rs:3:2\n-  |>\n-3 |> \\tbar;\n-  |> \\t^^^\n+  | \n+3 |  \\tbar;\n+  |  \\t^^^\n \"[1..]);\n     }\n \n@@ -1510,12 +1510,12 @@ fn foo() {\n         println!(\"text=\\n{}\", text);\n         assert_eq!(&text[..], &r#\"\n  ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n+  | \n+3 |      vec.push(vec.pop().unwrap());\n+  |      ---      ---                - previous borrow ends here\n+  |      |        |\n+  |      |        error occurs here\n+  |      previous borrow of `vec` occurs here\n \"#[1..]);\n     }\n \n@@ -1577,24 +1577,24 @@ fn bar() {\n \n         println!(\"text=\\n{}\", text);\n \n-        // Note that the `|>` remain aligned across both files:\n+        // Note that the `|` remain aligned across both files:\n         assert_eq!(&text[..], &r#\"\n    --> foo.rs:3:14\n-    |>\n-3   |>     vec.push(vec.pop().unwrap());\n-    |>     ---      ^^^                - c\n-    |>     |        |\n-    |>     |        b\n-    |>     a\n+    | \n+3   |      vec.push(vec.pop().unwrap());\n+    |      ---      ^^^                - c\n+    |      |        |\n+    |      |        b\n+    |      a\n    ::: bar.rs\n-    |>\n-17  |>     vec.push();\n-    |>     ---       - f\n-    |>     |\n-    |>     d\n+    | \n+17  |      vec.push();\n+    |      ---       - f\n+    |      |\n+    |      d\n ...\n-21  |>     vec.pop().unwrap());\n-    |>     --- e\n+21  |      vec.pop().unwrap());\n+    |      --- e\n \"#[1..]);\n     }\n \n@@ -1632,15 +1632,15 @@ fn foo() {\n         println!(\"text=\\n{}\", text);\n         assert_eq!(&text[..], &r#\"\n    ::: foo.rs\n-    |>\n-3   |>     let name = find_id(&data, 22).unwrap();\n-    |>                         ---- immutable borrow begins here\n+    | \n+3   |      let name = find_id(&data, 22).unwrap();\n+    |                          ---- immutable borrow begins here\n ...\n-6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n-    |>     ---- mutable borrow occurs here\n+6   |      data.push(Data { name: format!(\"Hera\"), id: 66 });\n+    |      ---- mutable borrow occurs here\n ...\n-11  |> }\n-    |> - immutable borrow ends here\n+11  |  }\n+    |  - immutable borrow ends here\n \"#[1..]);\n     }\n \n@@ -1672,13 +1672,13 @@ fn foo() {\n         println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n         assert_eq!(&text[..], &r#\"\n  ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     --------           ------ D\n-  |>     ||\n-  |>     |C\n-  |>     A\n-  |>     B\n+  | \n+3 |      vec.push(vec.pop().unwrap());\n+  |      --------           ------ D\n+  |      ||\n+  |      |C\n+  |      A\n+  |      B\n \"#[1..]);\n     }\n \n@@ -1709,12 +1709,12 @@ fn foo() {\n         println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n         assert_eq!(&text[..], &r#\"\n  ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n+  | \n+3 |      vec.push(vec.pop().unwrap());\n+  |      ---      ---                - previous borrow ends here\n+  |      |        |\n+  |      |        error occurs here\n+  |      previous borrow of `vec` occurs here\n \"#[1..]);\n     }\n \n@@ -1748,12 +1748,12 @@ fn foo() {\n         println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n         assert_eq!(&text[..], &r#\"\n    ::: foo.rs\n-    |>\n-4   |>     let mut vec2 = vec;\n-    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n+    | \n+4   |      let mut vec2 = vec;\n+    |                     --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n ...\n-9   |>     vec.push(7);\n-    |>     --- use of moved value: `vec`\n+9   |      vec.push(7);\n+    |      --- use of moved value: `vec`\n \"#[1..]);\n     }\n \n@@ -1785,11 +1785,11 @@ fn foo() {\n         println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n         assert_eq!(text, &r#\"\n  ::: foo.rs\n-  |>\n-3 |>     let mut vec = vec![0, 1, 2];\n-  |>             ---   ---\n-4 |>     let mut vec2 = vec;\n-  |>             ---    ---\n+  | \n+3 |      let mut vec = vec![0, 1, 2];\n+  |              ---   ---\n+4 |      let mut vec2 = vec;\n+  |              ---    ---\n \"#[1..]);\n     }\n \n@@ -1817,9 +1817,9 @@ impl SomeTrait for () {\n         println!(\"r#\\\"\\n{}\\\"\", text);\n         assert_eq!(text, &r#\"\n  ::: foo.rs\n-  |>\n-3 |>     fn foo(x: u32) {\n-  |>     -\n+  | \n+3 |      fn foo(x: u32) {\n+  |      -\n \"#[1..]);\n     }\n \n@@ -1847,12 +1847,12 @@ impl SomeTrait for () {\n         println!(\"r#\\\"\\n{}\\\"\", text);\n         assert_eq!(text, &r#\"\n  ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n+  | \n+2 |      fn foo(x: u32) {\n+  |      --------------\n+  |      |      |\n+  |      |      x_span\n+  |      fn_span\n \"#[1..]);\n     }\n \n@@ -1882,12 +1882,12 @@ impl SomeTrait for () {\n         println!(\"r#\\\"\\n{}\\\"\", text);\n         assert_eq!(text, &r#\"\n  ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n+  | \n+2 |      fn foo(x: u32) {\n+  |      --------------\n+  |      |      |\n+  |      |      x_span\n+  |      fn_span\n \"#[1..]);\n     }\n \n@@ -1928,11 +1928,11 @@ impl SomeTrait for () {\n         println!(\"r#\\\"\\n{}\\\"\", text);\n         assert_eq!(text, &r#\"\n  ::: foo.rs\n-  |>\n-3 |>        let closure = || {\n-  |>                      - foo\n-4 |>            inner\n-  |>            ----- bar\n+  | \n+3 |         let closure = || {\n+  |                       - foo\n+4 |             inner\n+  |             ----- bar\n \"#[1..]);\n     }\n \n@@ -1971,9 +1971,9 @@ fn main() {\n         println!(\"r#\\\"\\n{}\\\"\", text);\n         assert_eq!(text, &r#\"\n   --> foo.rs:11:2\n-   |>\n-11 |> }\n-   |>  -\n+   | \n+11 |  }\n+   |   -\n \"#[1..]);\n     }\n }"}]}