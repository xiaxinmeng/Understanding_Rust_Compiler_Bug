{"sha": "5bc15866d752d4ba4a02e9ab130b08cb8186d8f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViYzE1ODY2ZDc1MmQ0YmE0YTAyZTlhYjEzMGIwOGNiODE4NmQ4Zjk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-09T10:38:06Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-27T19:47:12Z"}, "message": "Move ExprUseVisitor and mem_categorization to rustc_typeck\n\n`MemCategorizationContext` is now private, the remaining types and\ntraits remain public for Clippy.", "tree": {"sha": "9633f41a221a566cab95967e2ef2850d8c5caf13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9633f41a221a566cab95967e2ef2850d8c5caf13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9", "html_url": "https://github.com/rust-lang/rust/commit/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c87de41f99f0523490e826222edb21d6cc361415", "url": "https://api.github.com/repos/rust-lang/rust/commits/c87de41f99f0523490e826222edb21d6cc361415", "html_url": "https://github.com/rust-lang/rust/commit/c87de41f99f0523490e826222edb21d6cc361415"}], "stats": {"total": 83, "additions": 44, "deletions": 39}, "files": [{"sha": "481ae3b93291e207ab93e605ee645fea81b819c1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5bc15866d752d4ba4a02e9ab130b08cb8186d8f9", "patch": "@@ -96,15 +96,13 @@ pub mod infer;\n pub mod lint;\n \n pub mod middle {\n-    pub mod expr_use_visitor;\n     pub mod cstore;\n     pub mod dependency_format;\n     pub mod diagnostic_items;\n     pub mod exported_symbols;\n     pub mod free_region;\n     pub mod lib_features;\n     pub mod lang_items;\n-    pub mod mem_categorization;\n     pub mod privacy;\n     pub mod reachable;\n     pub mod region;"}, {"sha": "8ceb21748520ebbe80f3025cdd6072d6e5438957", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5bc15866d752d4ba4a02e9ab130b08cb8186d8f9", "patch": "@@ -74,7 +74,7 @@\n \n use crate::check::dropck;\n use crate::check::FnCtxt;\n-use crate::middle::mem_categorization as mc;\n+use crate::mem_categorization as mc;\n use crate::middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::infer::outlives::env::OutlivesEnvironment;"}, {"sha": "3002459d56f3c392cb7f81fcada250b8f7563cf1", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=5bc15866d752d4ba4a02e9ab130b08cb8186d8f9", "patch": "@@ -32,9 +32,9 @@\n \n use super::FnCtxt;\n \n-use crate::middle::expr_use_visitor as euv;\n-use crate::middle::mem_categorization as mc;\n-use crate::middle::mem_categorization::PlaceBase;\n+use crate::expr_use_visitor as euv;\n+use crate::mem_categorization as mc;\n+use crate::mem_categorization::PlaceBase;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def_id::LocalDefId;"}, {"sha": "03d7ab2d6337717cdc1be365a6c50f2f6417fe5b", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "renamed", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=5bc15866d752d4ba4a02e9ab130b08cb8186d8f9", "patch": "@@ -5,14 +5,17 @@\n pub use self::ConsumeMode::*;\n use self::OverloadedCallType::*;\n \n-use crate::hir::def::Res;\n-use crate::hir::def_id::DefId;\n-use crate::hir::ptr::P;\n-use crate::infer::InferCtxt;\n-use crate::middle::mem_categorization as mc;\n-use crate::ty::{self, TyCtxt, adjustment};\n-\n-use crate::hir::{self, PatKind};\n+// Export these here so that Clippy can use them.\n+pub use mc::{PlaceBase, Place, Projection};\n+\n+use rustc::hir::{self, PatKind};\n+use rustc::hir::def::Res;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::ptr::P;\n+use rustc::infer::InferCtxt;\n+use rustc::ty::{self, TyCtxt, adjustment};\n+\n+use crate::mem_categorization as mc;\n use syntax_pos::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -147,7 +150,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.mc.tcx()\n     }\n \n-    fn delegate_consume(&mut self, place: &mc::Place<'tcx>) {\n+    fn delegate_consume(&mut self, place: &Place<'tcx>) {\n         debug!(\"delegate_consume(place={:?})\", place);\n \n         let mode = copy_or_move(&self.mc, place);\n@@ -516,7 +519,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_arm(&mut self, discr_place: &mc::Place<'tcx>, arm: &hir::Arm) {\n+    fn walk_arm(&mut self, discr_place: &Place<'tcx>, arm: &hir::Arm) {\n         self.walk_pat(discr_place, &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n@@ -528,13 +531,13 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n-    fn walk_irrefutable_pat(&mut self, discr_place: &mc::Place<'tcx>, pat: &hir::Pat) {\n+    fn walk_irrefutable_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat) {\n         self.walk_pat(discr_place, pat);\n     }\n \n \n     /// The core driver for walking a pattern\n-    fn walk_pat(&mut self, discr_place: &mc::Place<'tcx>, pat: &hir::Pat) {\n+    fn walk_pat(&mut self, discr_place: &Place<'tcx>, pat: &hir::Pat) {\n         debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n \n         let tcx = self.tcx();\n@@ -622,7 +625,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n fn copy_or_move<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n-    place: &mc::Place<'tcx>,\n+    place: &Place<'tcx>,\n ) -> ConsumeMode {\n     if !mc.type_is_copy_modulo_regions(place.ty, place.span) {\n         Move", "previous_filename": "src/librustc/middle/expr_use_visitor.rs"}, {"sha": "c606feab087279ca5f7bc1c04a6cfa13ebac9e17", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5bc15866d752d4ba4a02e9ab130b08cb8186d8f9", "patch": "@@ -75,6 +75,9 @@ This API is completely unstable and subject to change.\n \n #[macro_use] extern crate rustc;\n \n+// This is used by Clippy.\n+pub mod expr_use_visitor;\n+\n mod astconv;\n mod check;\n mod check_unused;\n@@ -83,6 +86,7 @@ mod collect;\n mod constrained_generic_params;\n mod structured_errors;\n mod impl_wf_check;\n+mod mem_categorization;\n mod namespace;\n mod outlives;\n mod variance;"}, {"sha": "84e5d234da9d7d01b62b78c8fa20e29d13418f75", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "renamed", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc15866d752d4ba4a02e9ab130b08cb8186d8f9/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=5bc15866d752d4ba4a02e9ab130b08cb8186d8f9", "patch": "@@ -48,15 +48,15 @@\n //! result of `*x'`, effectively, where `x'` is a `Categorization::Upvar` reference\n //! tied to `x`. The type of `x'` will be a borrowed pointer.\n \n-use crate::hir::def_id::DefId;\n-use crate::infer::InferCtxt;\n-use crate::hir::def::{Res, DefKind};\n-use crate::ty::adjustment;\n-use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::fold::TypeFoldable;\n-\n-use crate::hir::PatKind;\n-use crate::hir;\n+use rustc::hir;\n+use rustc::hir::PatKind;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::def::{Res, DefKind};\n+use rustc::infer::InferCtxt;\n+use rustc::ty::adjustment;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n+\n use syntax_pos::Span;\n \n use rustc_data_structures::fx::FxIndexMap;\n@@ -105,7 +105,7 @@ impl<'tcx> Place<'tcx> {\n     /// The types are in the reverse order that they are applied. So if\n     /// `x: &*const u32` and the `Place` is `**x`, then the types returned are\n     ///`*const u32` then `&*const u32`.\n-    pub fn deref_tys(&self) -> impl Iterator<Item=Ty<'tcx>> + '_ {\n+    crate fn deref_tys(&self) -> impl Iterator<Item=Ty<'tcx>> + '_ {\n         self.projections.iter().rev().filter_map(|proj| if let Projection::Deref(deref_ty) = *proj {\n             Some(deref_ty)\n         } else {\n@@ -114,7 +114,7 @@ impl<'tcx> Place<'tcx> {\n     }\n }\n \n-pub trait HirNode {\n+crate trait HirNode {\n     fn hir_id(&self) -> hir::HirId;\n     fn span(&self) -> Span;\n }\n@@ -130,19 +130,19 @@ impl HirNode for hir::Pat {\n }\n \n #[derive(Clone)]\n-pub struct MemCategorizationContext<'a, 'tcx> {\n-    pub tables: &'a ty::TypeckTables<'tcx>,\n+crate struct MemCategorizationContext<'a, 'tcx> {\n+    crate tables: &'a ty::TypeckTables<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_owner: DefId,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n }\n \n-pub type McResult<T> = Result<T, ()>;\n+crate type McResult<T> = Result<T, ()>;\n \n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     /// Creates a `MemCategorizationContext`.\n-    pub fn new(\n+    crate fn new(\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body_owner: DefId,\n@@ -276,7 +276,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<Place<'tcx>> {\n+    crate fn cat_expr(&self, expr: &hir::Expr) -> McResult<Place<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n         fn helper<'a, 'tcx>(\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         helper(self, expr, self.tables.expr_adjustments(expr))\n     }\n \n-    pub fn cat_expr_adjusted(&self, expr: &hir::Expr,\n+    crate fn cat_expr_adjusted(&self, expr: &hir::Expr,\n                              previous: Place<'tcx>,\n                              adjustment: &adjustment::Adjustment<'tcx>)\n                              -> McResult<Place<'tcx>> {\n@@ -334,7 +334,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<Place<'tcx>> {\n+    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<Place<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n@@ -475,7 +475,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret)\n     }\n \n-    pub fn cat_rvalue(&self, hir_id: hir::HirId, span: Span, expr_ty: Ty<'tcx>) -> Place<'tcx> {\n+    crate fn cat_rvalue(&self, hir_id: hir::HirId, span: Span, expr_ty: Ty<'tcx>) -> Place<'tcx> {\n         debug!(\"cat_rvalue hir_id={:?}, expr_ty={:?}, span={:?}\", hir_id, expr_ty, span);\n         let ret = Place {\n             hir_id,\n@@ -562,7 +562,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret)\n     }\n \n-    pub fn cat_pattern<F>(&self, place: Place<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n+    crate fn cat_pattern<F>(&self, place: Place<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n         where F: FnMut(&Place<'tcx>, &hir::Pat),\n     {\n         self.cat_pattern_(place, pat, &mut op)", "previous_filename": "src/librustc/middle/mem_categorization.rs"}]}