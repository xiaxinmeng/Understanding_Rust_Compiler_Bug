{"sha": "729715779a904860fb75898b0f6df89d0c675ab1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOTcxNTc3OWE5MDQ4NjBmYjc1ODk4YjBmNmRmODlkMGM2NzVhYjE=", "commit": {"author": {"name": "OGINO Masanori", "email": "masanori.ogino@gmail.com", "date": "2014-01-13T03:18:17Z"}, "committer": {"name": "OGINO Masanori", "email": "masanori.ogino@gmail.com", "date": "2014-01-14T12:19:16Z"}, "message": "Update .po and strip down untranslated entries.\n\nThis work is done by execute these commands manually:\n\n$ po4a --copyright-holder=\"The Rust Project Developers\" \\\n    --package-name=\"Rust\" \\\n    --package-version=\"0.10-pre\" \\\n    -M UTF-8 -L UTF-8 \\\n    doc/po4a.conf\n$ for f in doc/po/**/*.po; do\n>   msgattrib --translated $f -o $f.strip\n>   if [ -e $f.strip ]; then\n>       mv $f.strip $f\n>   else\n>       rm $f\n>   fi\n> done\n\nIt should be managed by the build system automatically to use in our\ntranslation workflow, but I've not yet done that.\n\nSigned-off-by: OGINO Masanori <masanori.ogino@gmail.com>", "tree": {"sha": "78d7de969cb0098d7b30cb225738337af1e8d711", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78d7de969cb0098d7b30cb225738337af1e8d711"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/729715779a904860fb75898b0f6df89d0c675ab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/729715779a904860fb75898b0f6df89d0c675ab1", "html_url": "https://github.com/rust-lang/rust/commit/729715779a904860fb75898b0f6df89d0c675ab1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/729715779a904860fb75898b0f6df89d0c675ab1/comments", "author": {"login": "omasanori", "id": 167209, "node_id": "MDQ6VXNlcjE2NzIwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/167209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/omasanori", "html_url": "https://github.com/omasanori", "followers_url": "https://api.github.com/users/omasanori/followers", "following_url": "https://api.github.com/users/omasanori/following{/other_user}", "gists_url": "https://api.github.com/users/omasanori/gists{/gist_id}", "starred_url": "https://api.github.com/users/omasanori/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/omasanori/subscriptions", "organizations_url": "https://api.github.com/users/omasanori/orgs", "repos_url": "https://api.github.com/users/omasanori/repos", "events_url": "https://api.github.com/users/omasanori/events{/privacy}", "received_events_url": "https://api.github.com/users/omasanori/received_events", "type": "User", "site_admin": false}, "committer": {"login": "omasanori", "id": 167209, "node_id": "MDQ6VXNlcjE2NzIwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/167209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/omasanori", "html_url": "https://github.com/omasanori", "followers_url": "https://api.github.com/users/omasanori/followers", "following_url": "https://api.github.com/users/omasanori/following{/other_user}", "gists_url": "https://api.github.com/users/omasanori/gists{/gist_id}", "starred_url": "https://api.github.com/users/omasanori/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/omasanori/subscriptions", "organizations_url": "https://api.github.com/users/omasanori/orgs", "repos_url": "https://api.github.com/users/omasanori/repos", "events_url": "https://api.github.com/users/omasanori/events{/privacy}", "received_events_url": "https://api.github.com/users/omasanori/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "html_url": "https://github.com/rust-lang/rust/commit/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1"}], "stats": {"total": 16938, "additions": 3801, "deletions": 13137}, "files": [{"sha": "5c13cd20c3d48ff3c539ff6bb138d423edfc9db2", "filename": "doc/po/ja/complement-cheatsheet.md.po", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,152 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:13\n+#, fuzzy\n+#| msgid \"\"\n+#| \"~~~~ let x: f64 = 4.0; let y: uint = x as uint; assert!(y == 4u); ~~~~\"\n+msgid \"~~~ let x: int = 42; let y: ~str = x.to_str(); ~~~\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"let x: f64 = 4.0;\\n\"\n+\"let y: uint = x as uint;\\n\"\n+\"assert!(y == 4u);\\n\"\n+\"~~~~\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:17\n+#, fuzzy\n+#| msgid \"\"\n+#| \"[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz [win-exe]: \"\n+#| \"http://static.rust-lang.org/dist/rust-0.7-install.exe\"\n+msgid \"\"\n+\"Use [`FromStr`](http://static.rust-lang.org/doc/master/std/from_str/trait.\"\n+\"FromStr.html), and its helper function, [`from_str`](http://static.rust-lang.\"\n+\"org/doc/master/std/from_str/fn.from_str.html).\"\n+msgstr \"\"\n+\"[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz\\n\"\n+\"[win-exe]: http://static.rust-lang.org/dist/rust-0.7-install.exe\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:22\n+#, fuzzy\n+#| msgid \"\"\n+#| \"~~~~ let x: f64 = 4.0; let y: uint = x as uint; assert!(y == 4u); ~~~~\"\n+msgid \"~~~ let x: Option<int> = from_str(\\\"42\\\"); let y: int = x.unwrap(); ~~~\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"let x: f64 = 4.0;\\n\"\n+\"let y: uint = x as uint;\\n\"\n+\"assert!(y == 4u);\\n\"\n+\"~~~~\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:29\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~ use std::num::ToStrRadix;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:33\n+#, fuzzy\n+#| msgid \"\"\n+#| \"~~~~ let x: f64 = 4.0; let y: uint = x as uint; assert!(y == 4u); ~~~~\"\n+msgid \"let x: int = 42; let y: ~str = x.to_str_radix(16); ~~~\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"let x: f64 = 4.0;\\n\"\n+\"let y: uint = x as uint;\\n\"\n+\"assert!(y == 4u);\\n\"\n+\"~~~~\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:37\n+#, fuzzy\n+#| msgid \"\"\n+#| \"[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz [win-exe]: \"\n+#| \"http://static.rust-lang.org/dist/rust-0.7-install.exe\"\n+msgid \"\"\n+\"Use [`FromStrRadix`](http://static.rust-lang.org/doc/master/std/num/trait.\"\n+\"FromStrRadix.html), and its helper function, [`from_str_radix`](http://\"\n+\"static.rust-lang.org/doc/master/std/num/fn.from_str_radix.html).\"\n+msgstr \"\"\n+\"[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz\\n\"\n+\"[win-exe]: http://static.rust-lang.org/dist/rust-0.7-install.exe\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:40\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~ use std::num::from_str_radix;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:46\n+#, fuzzy\n+#| msgid \"## Operators\"\n+msgid \"# File operations\"\n+msgstr \"## \u6f14\u7b97\u5b50\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:54\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~ {.xfail-test} use std::path::Path; use std::io::fs::File;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:63\n+#, fuzzy\n+#| msgid \"\"\n+#| \"[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz [win-exe]: \"\n+#| \"http://static.rust-lang.org/dist/rust-0.7-install.exe\"\n+msgid \"\"\n+\"Use the [`lines`](http://static.rust-lang.org/doc/master/std/io/trait.Buffer.\"\n+\"html#method.lines) method on a [`BufferedReader`](http://static.rust-lang.\"\n+\"org/doc/master/std/io/buffered/struct.BufferedReader.html).\"\n+msgstr \"\"\n+\"[tarball]: http://static.rust-lang.org/dist/rust-0.7.tar.gz\\n\"\n+\"[win-exe]: http://static.rust-lang.org/dist/rust-0.7-install.exe\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:77\n+#, fuzzy\n+#| msgid \"## Using other crates\"\n+msgid \"# String operations\"\n+msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:88 doc/guide-container.md:4\n+#, fuzzy\n+msgid \"# Containers\"\n+msgstr \"## \u672c\u66f8\u306e\u8868\u8a18\u306b\u3064\u3044\u3066\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:176\n+#, fuzzy\n+#| msgid \"[The foreign function interface][ffi]\"\n+msgid \"# FFI (Foreign Function Interface)\"\n+msgstr \"[\u4ed6\u8a00\u8a9e\u9593\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9 (foreign function inferface)][ffi]\""}, {"sha": "a4d16a82c44a16bd4cd059e1c8cbf023f0f381c0", "filename": "doc/po/ja/complement-lang-faq.md.po", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fcomplement-lang-faq.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fcomplement-lang-faq.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fcomplement-lang-faq.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,47 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/complement-lang-faq.md:83\n+#, fuzzy\n+#| msgid \"\"\n+#| \"[bug-3319]: https://github.com/mozilla/rust/issues/3319 [wiki-start]: \"\n+#| \"https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\"\n+msgid \"\"\n+\"[rustc]: https://github.com/mozilla/rust/tree/master/src/librustc [resolve]: \"\n+\"https://github.com/mozilla/rust/blob/master/src/librustc/middle/resolve.rs \"\n+\"[borrowck]: https://github.com/mozilla/rust/blob/master/src/librustc/middle/\"\n+\"borrowck/\"\n+msgstr \"\"\n+\"[bug-3319]: https://github.com/mozilla/rust/issues/3319\\n\"\n+\"[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-\"\n+\"developing-Rust\"\n+\n+#. type: Plain text\n+#: doc/complement-lang-faq.md:110\n+#, fuzzy\n+#| msgid \"\"\n+#| \"[bug-3319]: https://github.com/mozilla/rust/issues/3319 [wiki-start]: \"\n+#| \"https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\"\n+msgid \"\"\n+\"[unwind]: https://github.com/mozilla/rust/issues/908 [libgcc]: https://\"\n+\"github.com/mozilla/rust/issues/1603\"\n+msgstr \"\"\n+\"[bug-3319]: https://github.com/mozilla/rust/issues/3319\\n\"\n+\"[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-\"\n+\"developing-Rust\""}, {"sha": "100e1d5653c2847f721f13cef43552024dc7081a", "filename": "doc/po/ja/complement-project-faq.md.po", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fcomplement-project-faq.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fcomplement-project-faq.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fcomplement-project-faq.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,24 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Bullet: '* '\n+#: doc/complement-project-faq.md:36\n+#, fuzzy\n+#| msgid \"## The standard library\"\n+msgid \"An evolving standard library.\"\n+msgstr \"## \u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\""}, {"sha": "505d55a512c5c85f6581125989a497d3a17a18cf", "filename": "doc/po/ja/guide-conditions.md.po", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-conditions.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-conditions.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-conditions.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,73 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:2\n+#, fuzzy\n+#| msgid \"% The Rust Language Tutorial\"\n+msgid \"% The Rust Condition and Error-handling Guide\"\n+msgstr \"% Rust \u8a00\u8a9e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4\n+#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4\n+#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n+msgid \"# Introduction\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Bullet: '  - '\n+#: doc/guide-conditions.md:14\n+#, fuzzy\n+#| msgid \"# Functions\"\n+msgid \"Options\"\n+msgstr \"# \u95a2\u6570\"\n+\n+#. type: Bullet: '  - '\n+#: doc/guide-conditions.md:14\n+#, fuzzy\n+#| msgid \"## Conditionals\"\n+msgid \"Conditions\"\n+msgstr \"## \u6761\u4ef6\u5f0f\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:19\n+#, fuzzy\n+#| msgid \"## Tuples\"\n+msgid \"# Example program\"\n+msgstr \"## \u30bf\u30d7\u30eb\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:112\n+#, fuzzy\n+#| msgid \"# Functions\"\n+msgid \"# Options\"\n+msgstr \"# \u95a2\u6570\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:318\n+#, fuzzy\n+#| msgid \"## Conditionals\"\n+msgid \"# Conditions\"\n+msgstr \"## \u6761\u4ef6\u5f0f\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:415\n+#, fuzzy\n+#| msgid \"## Traits\"\n+msgid \"# Trapping a condition\"\n+msgstr \"## \u30c8\u30ec\u30a4\u30c8\""}, {"sha": "6113f1f554ee7653ab24aabbf22405d5739125a5", "filename": "doc/po/ja/guide-container.md.po", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-container.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-container.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-container.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,114 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/complement-cheatsheet.md:88 doc/guide-container.md:4\n+#, fuzzy\n+msgid \"# Containers\"\n+msgstr \"## \u672c\u66f8\u306e\u8868\u8a18\u306b\u3064\u3044\u3066\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:2\n+#, fuzzy\n+#| msgid \"% The Rust Language Tutorial\"\n+msgid \"% The Rust Containers and Iterators Guide\"\n+msgstr \"% Rust \u8a00\u8a9e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:8\n+#, fuzzy\n+#| msgid \"# Control structures\"\n+msgid \"## Unique vectors\"\n+msgstr \"# \u5236\u5fa1\u69cb\u9020\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:18\n+#, fuzzy\n+#| msgid \"## Managed closures\"\n+msgid \"## Maps and sets\"\n+msgstr \"## \u30de\u30cd\u30fc\u30b8\u30c9\u30af\u30ed\u30fc\u30b8\u30e3\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:24\n+#, fuzzy\n+#| msgid \"## The standard library\"\n+msgid \"The standard library provides three owned map/set types:\"\n+msgstr \"## \u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:68\n+#, fuzzy\n+#| msgid \"## Operators\"\n+msgid \"# Iterators\"\n+msgstr \"## \u6f14\u7b97\u5b50\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:70\n+#, fuzzy\n+#| msgid \"# Introduction\"\n+msgid \"## Iteration protocol\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:119\n+#, fuzzy\n+#| msgid \"# Control structures\"\n+msgid \"## Container iterators\"\n+msgstr \"# \u5236\u5fa1\u69cb\u9020\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:131\n+#, fuzzy\n+#| msgid \"## Freezing\"\n+msgid \"### Freezing\"\n+msgstr \"## \u51cd\u7d50\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:151\n+#, fuzzy\n+#| msgid \"## Operators\"\n+msgid \"## Iterator adaptors\"\n+msgstr \"## \u6f14\u7b97\u5b50\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:201\n+#, fuzzy\n+#| msgid \"## Loops\"\n+msgid \"## For loops\"\n+msgstr \"## \u30eb\u30fc\u30d7\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:257\n+#, fuzzy\n+#| msgid \"## Conventions\"\n+msgid \"## Conversion\"\n+msgstr \"## \u672c\u66f8\u306e\u8868\u8a18\u306b\u3064\u3044\u3066\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:334\n+#, fuzzy\n+#| msgid \"# Control structures\"\n+msgid \"## Double-ended iterators\"\n+msgstr \"# \u5236\u5fa1\u69cb\u9020\"\n+\n+#. type: Plain text\n+#: doc/guide-container.md:385\n+#, fuzzy\n+#| msgid \"# Control structures\"\n+msgid \"## Random-access iterators\"\n+msgstr \"# \u5236\u5fa1\u69cb\u9020\""}, {"sha": "b61c8efece1fecac74f2de272bb83ab5f078043a", "filename": "doc/po/ja/guide-ffi.md.po", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-ffi.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-ffi.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-ffi.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,82 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4\n+#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4\n+#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n+msgid \"# Introduction\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Plain text\n+#: doc/guide-ffi.md:2\n+#, fuzzy\n+#| msgid \"[The foreign function interface][ffi]\"\n+msgid \"% The Rust Foreign Function Interface Guide\"\n+msgstr \"[\u4ed6\u8a00\u8a9e\u9593\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9 (foreign function inferface)][ffi]\"\n+\n+#. type: Plain text\n+#: doc/guide-ffi.md:16\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~~ {.xfail-test} use std::libc::size_t;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/guide-ffi.md:48\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~~ {.xfail-test} use std::libc::{c_int, size_t};\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/guide-ffi.md:168 doc/tutorial.md:875\n+msgid \"# Destructors\"\n+msgstr \"# \u30c7\u30b9\u30c8\u30e9\u30af\u30bf\"\n+\n+#. type: Plain text\n+#: doc/guide-ffi.md:333\n+#, fuzzy\n+#| msgid \"~~~~ let square = |x: int| -> uint { (x * x) as uint }; ~~~~\"\n+msgid \"~~~~ unsafe fn kaboom(ptr: *int) -> int { *ptr } ~~~~\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"let square = |x: int| -> uint { (x * x) as uint };\\n\"\n+\"~~~~~~~~\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-ffi.md:344\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~{.xfail-test} use std::libc;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/guide-ffi.md:363\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~{.xfail-test} use std::libc; use std::ptr;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\""}, {"sha": "e491afcfee766030da0ed97b75696c49d40f8c42", "filename": "doc/po/ja/guide-lifetimes.md.po", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-lifetimes.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-lifetimes.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-lifetimes.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,315 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4\n+#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4\n+#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n+msgid \"# Introduction\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:2\n+#, fuzzy\n+#| msgid \"% The Rust Language Tutorial\"\n+msgid \"% The Rust References and Lifetimes Guide\"\n+msgstr \"% Rust \u8a00\u8a9e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:26\n+#, fuzzy\n+#| msgid \"## A minimal example\"\n+msgid \"# By example\"\n+msgstr \"## \u6700\u5c0f\u9650\u306e\u4f8b\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:33\n+#, fuzzy\n+#| msgid \"As an example, consider a simple struct type, `Point`:\"\n+msgid \"As an example, consider a simple struct type `Point`:\"\n+msgstr \"\u4f8b\u3068\u3057\u3066\u3001\u30b7\u30f3\u30d7\u30eb\u306a\u69cb\u9020\u4f53\u578b\u306e `Point` \u306b\u3064\u3044\u3066\u8003\u3048\u307e\u3059\u3002\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:41\n+#, fuzzy\n+#| msgid \"\"\n+#| \"We can use this simple definition to allocate points in many different \"\n+#| \"ways. For example, in this code, each of these three local variables \"\n+#| \"contains a point, but allocated in a different location:\"\n+msgid \"\"\n+\"We can use this simple definition to allocate points in many different ways. \"\n+\"For example, in this code, each of these three local variables contains a \"\n+\"point, but allocated in a different place:\"\n+msgstr \"\"\n+\"\u30b7\u30f3\u30d7\u30eb\u306a\u5b9a\u7fa9\u3067\u3059\u304c\u3001\u3053\u306e\u5b9a\u7fa9\u3092\u4f7f\u3063\u3066 `Point` \u578b\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u69d8\u3005\u306a\u65b9\u6cd5\u3067\"\n+\"\u5272\u308a\u5f53\u3066\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u4f8b\u3048\u3070\u3001\u3053\u306e\u30b3\u30fc\u30c9\u306e3\u3064\u306e\u30ed\u30fc\u30ab\u30eb\u5909\u6570\u306f\u3001\u305d\u308c\u305e\u308c\u7570\"\n+\"\u306a\u3063\u305f\u5834\u6240\u306b `Point` \u578b\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u5272\u308a\u5f53\u3066\u3066\u3044\u307e\u3059\u3002\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:48\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"~~~\\n\"\n+\"# struct Point {x: f64, y: f64}\\n\"\n+\"let on_the_stack :  Point =  Point {x: 3.0, y: 4.0};\\n\"\n+\"let managed_box  : @Point = @Point {x: 5.0, y: 1.0};\\n\"\n+\"let owned_box    : ~Point = ~Point {x: 7.0, y: 9.0};\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:60\n+#, fuzzy\n+#| msgid \"\"\n+#| \"Suppose we want to write a procedure that computes the distance between \"\n+#| \"any two points, no matter where they are stored. For example, we might \"\n+#| \"like to compute the distance between `on_the_stack` and `managed_box`, or \"\n+#| \"between `managed_box` and `owned_box`. One option is to define a function \"\n+#| \"that takes two arguments of type point\u2014that is, it takes the points by \"\n+#| \"value. But this will cause the points to be copied when we call the \"\n+#| \"function. For points, this is probably not so bad, but often copies are \"\n+#| \"expensive. So we\u2019d like to define a function that takes the points by \"\n+#| \"pointer. We can use borrowed pointers to do this:\"\n+msgid \"\"\n+\"Suppose we wanted to write a procedure that computed the distance between \"\n+\"any two points, no matter where they were stored. For example, we might like \"\n+\"to compute the distance between `on_the_stack` and `managed_box`, or between \"\n+\"`managed_box` and `owned_box`. One option is to define a function that takes \"\n+\"two arguments of type `Point`\u2014that is, it takes the points by value. But if \"\n+\"we define it this way, calling the function will cause the points to be \"\n+\"copied. For points, this is probably not so bad, but often copies are \"\n+\"expensive. Worse, if the data type contains mutable fields, copying can \"\n+\"change the semantics of your program in unexpected ways. So we'd like to \"\n+\"define a function that takes the points by pointer. We can use references to \"\n+\"do this:\"\n+msgstr \"\"\n+\"`Point` \u578b\u306e\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u5272\u308a\u5f53\u3066\u5148\u304c\u3069\u3053\u3067\u3042\u3063\u305f\u3068\u3057\u3066\u3082\u5229\u7528\u53ef\u80fd\u306a\u3001\u4efb\u610f\u306e \"\n+\"2 \u70b9\u9593\u306e\u8ddd\u96e2\u3092\u8a08\u7b97\u3059\u308b\u51e6\u7406\u3092\u66f8\u304d\u305f\u3044\u3068\u3057\u307e\u3059\u3002\u4f8b\u3048\u3070\u3001 `on_the_stack`, \"\n+\"`managed_box` \u9593\u3084 `managed_box`, `owned_box` \u9593\u306e\u8ddd\u96e2\u3092\u8a08\u7b97\u3059\u308b\u51e6\u7406\u3067\u3059\u3002 1\"\n+\"\u3064\u76ee\u306e\u5b9f\u88c5\u65b9\u6cd5\u3068\u3057\u3066\u30012\u3064\u306e `Point` \u578b\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u5f15\u6570\u306b\u3068\u308b\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\"\n+\"\u65b9\u6cd5\u3001\u3059\u306a\u308f\u3061\u3001\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u5024\u3067\u53d7\u3051\u6e21\u3059\u65b9\u6cd5\u304c\u3042\u308a\u307e\u3059\u3002\u3057\u304b\u3057\u3001\u3053\u306e\u65b9\u6cd5\u3067\"\n+\"\u306f\u95a2\u6570\u547c\u3073\u51fa\u3057\u6642\u306b `Point` \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u306e\u30b3\u30d4\u30fc\u304c\u884c\u308f\u308c\u307e\u3059\u3002`Point` \u30aa\u30d6\u30b8\u30a7\"\n+\"\u30af\u30c8\u306e\u5834\u5408\u3001\u3053\u306e\u3088\u3046\u306a\u5b9f\u88c5\u306f\u305d\u308c\u307b\u3069\u60aa\u3044\u3082\u306e\u3067\u306f\u306a\u3044\u3067\u3057\u3087\u3046\u304c\u3001\u30b3\u30d4\u30fc\u51e6\u7406\u306e\"\n+\"\u30b3\u30b9\u30c8\u306f\u9ad8\u3044\u5834\u5408\u3082\u3042\u308a\u307e\u3059\u3002\u3057\u305f\u304c\u3063\u3066\u3001`Point` \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u30dd\u30a4\u30f3\u30bf\u6e21\u3057\u3059\"\n+\"\u308b\u95a2\u6570\u3092\u5b9a\u7fa9\u3059\u308b\u5fc5\u8981\u304c\u3042\u308a\u307e\u3059\u3002\u305d\u306e\u305f\u3081\u306b\u3001\u501f\u7528\u30dd\u30a4\u30f3\u30bf\u3092\u5229\u7528\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\"\n+\"\u3067\u3059\u3002\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:72 doc/tutorial.md:1394\n+msgid \"Now we can call `compute_distance()` in various ways:\"\n+msgstr \"\"\n+\"\u4e0a\u8a18\u306e `compute_distance()` \u95a2\u6570\u306f\u3001\u69d8\u3005\u306a\u65b9\u6cd5\u3067\u547c\u3073\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:82\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"~~~\\n\"\n+\"# struct Point {x: f64, y: f64}\\n\"\n+\"# let on_the_stack :  Point =  Point{x: 3.0, y: 4.0};\\n\"\n+\"# let managed_box  : @Point = @Point{x: 5.0, y: 1.0};\\n\"\n+\"# let owned_box    : ~Point = ~Point{x: 7.0, y: 9.0};\\n\"\n+\"# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\\n\"\n+\"compute_distance(&on_the_stack, managed_box);\\n\"\n+\"compute_distance(managed_box, owned_box);\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:89\n+#, fuzzy\n+#| msgid \"\"\n+#| \"Here the `&` operator is used to take the address of the variable \"\n+#| \"`on_the_stack`; this is because `on_the_stack` has the type `Point` (that \"\n+#| \"is, a struct value) and we have to take its address to get a value. We \"\n+#| \"also call this _borrowing_ the local variable `on_the_stack`, because we \"\n+#| \"are creating an alias: that is, another route to the same data.\"\n+msgid \"\"\n+\"Here, the `&` operator takes the address of the variable `on_the_stack`; \"\n+\"this is because `on_the_stack` has the type `Point` (that is, a struct \"\n+\"value) and we have to take its address to get a value. We also call this \"\n+\"_borrowing_ the local variable `on_the_stack`, because we have created an \"\n+\"alias: that is, another name for the same data.\"\n+msgstr \"\"\n+\"\u3053\u3053\u3067 `&` \u6f14\u7b97\u5b50\u306f `on_the_stack` \u5909\u6570\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u53d6\u5f97\u3059\u308b\u305f\u3081\u306b\u4f7f\u308f\u308c\u3066\u3044\u307e\"\n+\"\u3059\u3002\u3053\u308c\u306f\u3001 `on_the_stack` \u306e\u578b\u306f `Point` (\u3064\u307e\u308a\u3001\u69cb\u9020\u4f53\u306e\u5024) \u3067\u3042\u308a\u3001\u547c\u3073\"\n+\"\u51fa\u3057\u305f\u95a2\u6570\u304b\u3089\u5024\u3092\u53d6\u5f97\u3055\u305b\u308b\u305f\u3081\u3001\u69cb\u9020\u4f53\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u6e21\u3059\u5fc5\u8981\u304c\u3042\u308b\u304b\u3089\u3067\u3059\u3002\"\n+\"\u5024\u306e\u5225\u540d (\u30a8\u30a4\u30ea\u30a2\u30b9)\u3001\u3059\u306a\u308f\u3061\u3001\u540c\u3058\u30c7\u30fc\u30bf\u3078\u30a2\u30af\u30bb\u30b9\u3059\u308b\u305f\u3081\u306e\u5225\u306e\u65b9\u6cd5\u3092\u63d0\u4f9b\"\n+\"\u3059\u308b\u306e\u3067\u3001\u3053\u306e\u3088\u3046\u306a\u64cd\u4f5c\u306e\u3053\u3068\u3092\u30ed\u30fc\u30ab\u30eb\u5909\u6570 `on_the_stack` \u306e __\u501f\u7528__ \"\n+\"(_borrowing_) \u3068\u547c\u3073\u307e\u3059\u3002\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:95\n+#, fuzzy\n+#| msgid \"\"\n+#| \"In the case of the boxes `managed_box` and `owned_box`, however, no \"\n+#| \"explicit action is necessary. The compiler will automatically convert a \"\n+#| \"box like `@point` or `~point` to a borrowed pointer like `&point`. This \"\n+#| \"is another form of borrowing; in this case, the contents of the managed/\"\n+#| \"owned box are being lent out.\"\n+msgid \"\"\n+\"In contrast, we can pass the boxes `managed_box` and `owned_box` to \"\n+\"`compute_distance` directly. The compiler automatically converts a box like \"\n+\"`@Point` or `~Point` to a reference like `&Point`. This is another form of \"\n+\"borrowing: in this case, the caller lends the contents of the managed or \"\n+\"owned box to the callee.\"\n+msgstr \"\"\n+\"\u30dc\u30c3\u30af\u30b9\u3067\u3042\u308b `managed_box` \u3068 `owned_box` \u306e\u5834\u5408\u306f\u3001\u7279\u306b\u660e\u793a\u7684\u306a\u64cd\u4f5c\u3092\u884c\u3046\"\n+\"\u5fc5\u8981\u306f\u3042\u308a\u307e\u305b\u3093\u3002\u30b3\u30f3\u30d1\u30a4\u30e9\u306f `@point` \u3084 `~point` \u306e\u3088\u3046\u306a\u30dc\u30c3\u30af\u30b9\u3092\u81ea\u52d5\u7684\"\n+\"\u306b `&point` \u306e\u3088\u3046\u306a\u501f\u7528\u30dd\u30a4\u30f3\u30bf\u3078\u3068\u5909\u63db\u3057\u307e\u3059\u3002\u3053\u308c\u306f\u3001\u5225\u306e\u5f62\u614b\u306e\u501f\u7528 \"\n+\"(borrowing) \u3067\u3059\u3002\u3053\u306e\u5834\u5408\u3001\u30de\u30cd\u30fc\u30b8\u30c9/\u6240\u6709\u30dc\u30c3\u30af\u30b9\u306e\u5185\u5bb9\u304c\u8cb8\u3057\u51fa\u3055\u308c\u3066\u3044\u307e\"\n+\"\u3059\u3002\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:105\n+#, fuzzy\n+#| msgid \"\"\n+#| \"Whenever a value is borrowed, there are some limitations on what you can \"\n+#| \"do with the original. For example, if the contents of a variable have \"\n+#| \"been lent out, you cannot send that variable to another task, nor will \"\n+#| \"you be permitted to take actions that might cause the borrowed value to \"\n+#| \"be freed or to change its type. This rule should make intuitive sense: \"\n+#| \"you must wait for a borrowed value to be returned (that is, for the \"\n+#| \"borrowed pointer to go out of scope) before you can make full use of it \"\n+#| \"again.\"\n+msgid \"\"\n+\"Whenever a caller lends data to a callee, there are some limitations on what \"\n+\"the caller can do with the original. For example, if the contents of a \"\n+\"variable have been lent out, you cannot send that variable to another task. \"\n+\"In addition, the compiler will reject any code that might cause the borrowed \"\n+\"value to be freed or overwrite its component fields with values of different \"\n+\"types (I'll get into what kinds of actions those are shortly). This rule \"\n+\"should make intuitive sense: you must wait for a borrower to return the \"\n+\"value that you lent it (that is, wait for the reference to go out of scope)  \"\n+\"before you can make full use of it again.\"\n+msgstr \"\"\n+\"\u5024\u304c\u501f\u7528\u3055\u308c\u3066\u3044\u308b\u9593\u3001\u501f\u7528\u5143\u306e\u5024\u306b\u5bfe\u3057\u3066\u884c\u3048\u308b\u64cd\u4f5c\u304c\u3044\u304f\u3089\u304b\u5236\u9650\u3055\u308c\u307e\u3059\u3002\u4f8b\"\n+\"\u3048\u3070\u3001\u5909\u6570\u306e\u5185\u5bb9\u304c\u8cb8\u3057\u51fa\u3055\u308c\u305f\u5834\u5408\u3001\u305d\u306e\u5909\u6570\u3092\u4ed6\u306e\u30bf\u30b9\u30af\u306b\u9001\u4fe1\u3059\u308b\u3053\u3068\u306f\u3067\u304d\"\n+\"\u307e\u305b\u3093\u3057\u3001\u501f\u7528\u3055\u308c\u305f\u5024\u3092\u89e3\u653e\u3057\u305f\u308a\u3001\u578b\u304c\u5909\u5316\u3055\u305b\u308b\u3088\u3046\u306a\u64cd\u4f5c\u3082\u884c\u3046\u3053\u3068\u304c\u3067\u304d\"\n+\"\u307e\u305b\u3093\u3002\u3053\u306e\u30eb\u30fc\u30eb\u306f\u7406\u306b\u304b\u306a\u3063\u305f\u3082\u306e\u3067\u3057\u3087\u3046\u3002\u8cb8\u3057\u51fa\u3057\u305f\u5024\u3092\u6700\u5927\u9650\u306b\u6d3b\u7528\u3059\u308b \"\n+\"(make full use of it) \u305f\u3081\u306b\u306f\u3001\u8cb8\u3057\u51fa\u3057\u305f\u5024\u306e\u8fd4\u5374 (\u501f\u7528\u30dd\u30a4\u30f3\u30bf\u304c\u5b58\u5728\u3059\u308b\u30b9\"\n+\"\u30b3\u30fc\u30d7\u3092\u629c\u3051\u308b) \u3092\u5f85\u305f\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:114\n+#, fuzzy\n+#| msgid \"\"\n+#| \"~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: \"\n+#| \"20f }; println(fmt!(\\\"%f\\\", point.x)); ~~~\"\n+msgid \"\"\n+\"~~~ # struct Point {x: f64, y: f64} let on_the_stack: Point = Point {x: 3.0, \"\n+\"y: 4.0}; ~~~\"\n+msgstr \"\"\n+\"~~~\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let point = &@~Point { x: 10f, y: 20f };\\n\"\n+\"println(fmt!(\\\"%f\\\", point.x));\\n\"\n+\"~~~\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:124\n+#, fuzzy\n+#| msgid \"\"\n+#| \"~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: \"\n+#| \"20f }; println(fmt!(\\\"%f\\\", point.x)); ~~~\"\n+msgid \"\"\n+\"~~~ # struct Point {x: f64, y: f64} let on_the_stack2: &Point = &Point {x: \"\n+\"3.0, y: 4.0}; ~~~\"\n+msgstr \"\"\n+\"~~~\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let point = &@~Point { x: 10f, y: 20f };\\n\"\n+\"println(fmt!(\\\"%f\\\", point.x));\\n\"\n+\"~~~\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:134\n+#, fuzzy\n+#| msgid \"\"\n+#| \"~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: \"\n+#| \"20f }; println(fmt!(\\\"%f\\\", point.x)); ~~~\"\n+msgid \"\"\n+\"~~~ # struct Point {x: f64, y: f64} let tmp = Point {x: 3.0, y: 4.0}; let \"\n+\"on_the_stack2 : &Point = &tmp; ~~~\"\n+msgstr \"\"\n+\"~~~\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let point = &@~Point { x: 10f, y: 20f };\\n\"\n+\"println(fmt!(\\\"%f\\\", point.x));\\n\"\n+\"~~~\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:180\n+#, fuzzy\n+#| msgid \"# Borrowed pointers\"\n+msgid \"# Borrowing managed boxes and rooting\"\n+msgstr \"# \u501f\u7528\u30dd\u30a4\u30f3\u30bf\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:262\n+#, fuzzy\n+#| msgid \"# Borrowed pointers\"\n+msgid \"# Borrowing owned boxes\"\n+msgstr \"# \u501f\u7528\u30dd\u30a4\u30f3\u30bf\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:367\n+#, fuzzy\n+#| msgid \"# Borrowed pointers\"\n+msgid \"# Borrowing and enums\"\n+msgstr \"# \u501f\u7528\u30dd\u30a4\u30f3\u30bf\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:477\n+#, fuzzy\n+#| msgid \"# Dereferencing pointers\"\n+msgid \"# Returning references\"\n+msgstr \"# \u30dd\u30a4\u30f3\u30bf\u306e\u30c7\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:490\n+#, fuzzy\n+#| msgid \"\"\n+#| \"~~~ # struct Point { x: f64, y: f64 } let point = &@~Point { x: 10f, y: \"\n+#| \"20f }; println(fmt!(\\\"%f\\\", point.x)); ~~~\"\n+msgid \"\"\n+\"~~~ struct Point {x: f64, y: f64} fn get_x<'r>(p: &'r Point) -> &'r f64 { &p.\"\n+\"x } ~~~\"\n+msgstr \"\"\n+\"~~~\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let point = &@~Point { x: 10f, y: 20f };\\n\"\n+\"println(fmt!(\\\"%f\\\", point.x));\\n\"\n+\"~~~\"\n+\n+#. type: Plain text\n+#: doc/guide-lifetimes.md:659\n+#, fuzzy\n+#| msgid \"## Conventions\"\n+msgid \"# Conclusion\"\n+msgstr \"## \u672c\u66f8\u306e\u8868\u8a18\u306b\u3064\u3044\u3066\""}, {"sha": "41ba4b049265729222fcdf0a809fc5d677fcb6ae", "filename": "doc/po/ja/guide-macros.md.po", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-macros.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-macros.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-macros.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,94 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4\n+#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4\n+#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n+msgid \"# Introduction\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Plain text\n+#: doc/guide-macros.md:2\n+#, fuzzy\n+#| msgid \"% The Rust Language Tutorial\"\n+msgid \"% The Rust Macros Guide\"\n+msgstr \"% Rust \u8a00\u8a9e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\"\n+\n+#. type: Plain text\n+#: doc/guide-macros.md:67\n+#, fuzzy\n+#| msgid \"## Do syntax\"\n+msgid \"# Invocation syntax\"\n+msgstr \"## do \u69cb\u6587\"\n+\n+#. type: Plain text\n+#: doc/guide-macros.md:100\n+#, fuzzy\n+#| msgid \"# Introduction\"\n+msgid \"## Invocation location\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Plain text\n+#: doc/guide-macros.md:115\n+#, fuzzy\n+#| msgid \"## Traits\"\n+msgid \"# Transcription syntax\"\n+msgstr \"## \u30c8\u30ec\u30a4\u30c8\"\n+\n+#. type: Plain text\n+#: doc/guide-macros.md:135\n+#, fuzzy\n+#| msgid \"# Introduction\"\n+msgid \"## Interpolation location\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Plain text\n+#: doc/guide-macros.md:143\n+#, fuzzy\n+#| msgid \"# Introduction\"\n+msgid \"## Invocation\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Plain text\n+#: doc/guide-macros.md:181\n+#, fuzzy\n+#| msgid \"## Traits\"\n+msgid \"### Transcription\"\n+msgstr \"## \u30c8\u30ec\u30a4\u30c8\"\n+\n+#. type: Plain text\n+#: doc/guide-macros.md:193\n+#, fuzzy\n+#| msgid \"## Pattern matching\"\n+msgid \"## Parsing limitations\"\n+msgstr \"## \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\"\n+\n+#. type: Plain text\n+#: doc/guide-macros.md:212\n+#, fuzzy\n+#| msgid \"## Pattern matching\"\n+msgid \"# Macro argument pattern matching\"\n+msgstr \"## \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\"\n+\n+#. type: Plain text\n+#: doc/guide-macros.md:214\n+#, fuzzy\n+#| msgid \"## Conventions\"\n+msgid \"## Motivation\"\n+msgstr \"## \u672c\u66f8\u306e\u8868\u8a18\u306b\u3064\u3044\u3066\""}, {"sha": "bd23e1a466694280bec4869384fcf87235e1eb9d", "filename": "doc/po/ja/guide-pointers.md.po", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-pointers.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-pointers.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-pointers.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,292 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:2\n+#, fuzzy\n+#| msgid \"% The Rust Language Tutorial\"\n+msgid \"% The Rust Pointer Guide\"\n+msgstr \"% Rust \u8a00\u8a9e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:21\n+#, fuzzy\n+#| msgid \"~~~~ let square = |x: int| -> uint { (x * x) as uint }; ~~~~\"\n+msgid \"~~~rust fn succ(x: &int) -> int { *x + 1 } ~~~\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"let square = |x: int| -> uint { (x * x) as uint };\\n\"\n+\"~~~~~~~~\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:58\n+#, fuzzy\n+#| msgid \"~~~~ let square = |x: int| -> uint { (x * x) as uint }; ~~~~\"\n+msgid \"~~~rust fn succ(x: int) -> int { x + 1 }\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"let square = |x: int| -> uint { (x * x) as uint };\\n\"\n+\"~~~~~~~~\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:115\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"fn main() {\\n\"\n+\"    let p0 = Point { x: 5, y: 10};\\n\"\n+\"    let p1 = transform(p0);\\n\"\n+\"    println!(\\\"{:?}\\\", p1);\\n\"\n+\"}\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:129\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"~~~rust\\n\"\n+\"# struct Point {\\n\"\n+\"#     x: int,\\n\"\n+\"#     y: int,\\n\"\n+\"# }\\n\"\n+\"# let p0 = Point { x: 5, y: 10};\\n\"\n+\"fn transform(p: &Point) -> Point {\\n\"\n+\"    Point { x: p.x + 1, y: p.y + 1}\\n\"\n+\"}\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:145\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"fn transform(p: Point) -> Point {\\n\"\n+\"    Point { x: p.x + 1, y: p.y + 1}\\n\"\n+\"}\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:152\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"fn main() {\\n\"\n+\"    let p0 = Point { x: 5, y: 10};\\n\"\n+\"    let p1 = transform(p0);\\n\"\n+\"    println!(\\\"{:?}\\\", p1);\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:162\n+#, fuzzy\n+#| msgid \"# Borrowed pointers\"\n+msgid \"# Owned Pointers\"\n+msgstr \"# \u501f\u7528\u30dd\u30a4\u30f3\u30bf\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:175\n+#, fuzzy\n+msgid \"## References to Traits\"\n+msgstr \"# \u30dd\u30a4\u30f3\u30bf\u306e\u30c7\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:181\n+#, fuzzy\n+#| msgid \"# Data structures\"\n+msgid \"## Recursive Data Structures\"\n+msgstr \"# \u30c7\u30fc\u30bf\u69cb\u9020\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:229\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"fn main() {\\n\"\n+\"    let a = Point { x: 10, y: 20 };\\n\"\n+\"    do spawn {\\n\"\n+\"        println!(\\\"{}\\\", a.x);\\n\"\n+\"    }\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:246\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"fn main() {\\n\"\n+\"    let a = ~Point { x: 10, y: 20 };\\n\"\n+\"    do spawn {\\n\"\n+\"        println!(\\\"{}\\\", a.x);\\n\"\n+\"    }\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:251\n+#, fuzzy\n+#| msgid \"## Managed boxes\"\n+msgid \"# Managed Pointers\"\n+msgstr \"## \u30de\u30cd\u30fc\u30b8\u30c9\u30dc\u30c3\u30af\u30b9\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:277\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"fn main() {\\n\"\n+\"    let a = ~Point { x: 10, y: 20 };\\n\"\n+\"    let b = a;\\n\"\n+\"    println!(\\\"{}\\\", b.x);\\n\"\n+\"    println!(\\\"{}\\\", a.x);\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:308\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"fn main() {\\n\"\n+\"    let a = @Point { x: 10, y: 20 };\\n\"\n+\"    let b = a;\\n\"\n+\"    println!(\\\"{}\\\", b.x);\\n\"\n+\"    println!(\\\"{}\\\", a.x);\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:326 doc/tutorial.md:1345\n+#, fuzzy\n+msgid \"# References\"\n+msgstr \"# \u30dd\u30a4\u30f3\u30bf\u306e\u30c7\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:336\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~rust use std::num::sqrt;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:352\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+msgid \"\"\n+\"fn main() {\\n\"\n+\"    let origin = @Point { x: 0.0, y: 0.0 };\\n\"\n+\"    let p1     = ~Point { x: 5.0, y: 3.0 };\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"# struct Point { x: f64, y: f64 }\\n\"\n+\"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n+\"let origin = Point { x: 0.0, y: 0.0 };\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:378\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+msgid \"\"\n+\"~~~rust{.xfail-test}\\n\"\n+\"fn main() {\\n\"\n+\"    println!(\\\"{}\\\", x);\\n\"\n+\"    let x = 5;\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"// main.rs\\n\"\n+\"extern mod world;\\n\"\n+\"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n+\"~~~~\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:433\n+#, fuzzy\n+#| msgid \"# Dereferencing pointers\"\n+msgid \"# Returning Pointers\"\n+msgstr \"# \u30dd\u30a4\u30f3\u30bf\u306e\u30c7\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:444\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ let square = |x: int| -> uint { (x * x) as uint }; ~~~~\"\n+msgid \"\"\n+\"~~~rust\\n\"\n+\"fn foo(x: ~int) -> ~int {\\n\"\n+\"    return ~*x;\\n\"\n+\"}\\n\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"let square = |x: int| -> uint { (x * x) as uint };\\n\"\n+\"~~~~~~~~\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-pointers.md:457 doc/guide-pointers.md:471\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ let square = |x: int| -> uint { (x * x) as uint }; ~~~~\"\n+msgid \"\"\n+\"~~~rust\\n\"\n+\"fn foo(x: ~int) -> int {\\n\"\n+\"    return *x;\\n\"\n+\"}\\n\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"let square = |x: int| -> uint { (x * x) as uint };\\n\"\n+\"~~~~~~~~\\n\""}, {"sha": "d8d2b808e9d5a50b876817022a7dc40c57852083", "filename": "doc/po/ja/guide-rustpkg.md.po", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-rustpkg.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-rustpkg.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-rustpkg.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,112 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4\n+#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4\n+#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n+msgid \"# Introduction\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Plain text\n+#: doc/guide-rustpkg.md:2\n+#, fuzzy\n+#| msgid \"% The Rust Language Tutorial\"\n+msgid \"% The Rust Packaging Guide\"\n+msgstr \"% Rust \u8a00\u8a9e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\"\n+\n+#. type: Plain text\n+#: doc/guide-rustpkg.md:11\n+#, fuzzy\n+#| msgid \"## Using other crates\"\n+msgid \"# Installing External Packages\"\n+msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n+\n+#. type: Plain text\n+#: doc/guide-rustpkg.md:22\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+msgid \"\"\n+\"fn main() {\\n\"\n+\"    hello::world();\\n\"\n+\"}\\n\"\n+\"~~~~\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"// main.rs\\n\"\n+\"extern mod world;\\n\"\n+\"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n+\"~~~~\"\n+\n+#. type: Plain text\n+#: doc/guide-rustpkg.md:91\n+#, fuzzy\n+#| msgid \"## Using other crates\"\n+msgid \"# Building your own Package\"\n+msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n+\n+#. type: Plain text\n+#: doc/guide-rustpkg.md:98\n+#, fuzzy\n+#| msgid \"## Using other crates\"\n+msgid \"## Creating our workspace\"\n+msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n+\n+#. type: Plain text\n+#: doc/guide-rustpkg.md:115\n+#, fuzzy\n+#| msgid \"# Introduction\"\n+msgid \"## Installation\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Plain text\n+#: doc/guide-rustpkg.md:149\n+#, fuzzy, no-wrap\n+#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+msgid \"\"\n+\"pub fn world() {\\n\"\n+\"    println!(\\\"Hello, world.\\\");\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\"~~~~ {.xfail-test}\\n\"\n+\"// main.rs\\n\"\n+\"extern mod world;\\n\"\n+\"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n+\"~~~~\"\n+\n+#. type: Plain text\n+#: doc/guide-rustpkg.md:161\n+#, fuzzy\n+#| msgid \"## Using other crates\"\n+msgid \"## Building your package\"\n+msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n+\n+#. type: Plain text\n+#: doc/guide-rustpkg.md:209\n+#, fuzzy\n+#| msgid \"## Using other crates\"\n+msgid \"# Testing your Package\"\n+msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n+\n+#. type: Plain text\n+#: doc/guide-rustpkg.md:257\n+#, fuzzy\n+#| msgid \"## Managed boxes\"\n+msgid \"# More resources\"\n+msgstr \"## \u30de\u30cd\u30fc\u30b8\u30c9\u30dc\u30c3\u30af\u30b9\""}, {"sha": "a86a204397bdacd1cb03a9828e76e3ac0575d3c7", "filename": "doc/po/ja/guide-tasks.md.po", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-tasks.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-tasks.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-tasks.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,81 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4\n+#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4\n+#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n+msgid \"# Introduction\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n+\n+#. type: Plain text\n+#: doc/guide-tasks.md:2\n+#, fuzzy\n+#| msgid \"[Tasks and communication][tasks]\"\n+msgid \"% The Rust Tasks and Communication Guide\"\n+msgstr \"[\u30bf\u30b9\u30af\u3068\u901a\u4fe1][tasks]\"\n+\n+#. type: Plain text\n+#: doc/guide-tasks.md:64\n+#, fuzzy\n+#| msgid \"# Syntax basics\"\n+msgid \"# Basics\"\n+msgstr \"# \u57fa\u672c\u7684\u306a\u69cb\u6587\"\n+\n+#. type: Plain text\n+#: doc/guide-tasks.md:73 doc/guide-tasks.md:132\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~~ # use std::task::spawn;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/guide-tasks.md:113\n+#, fuzzy\n+#| msgid \"## Conditionals\"\n+msgid \"## Communication\"\n+msgstr \"## \u6761\u4ef6\u5f0f\"\n+\n+#. type: Plain text\n+#: doc/guide-tasks.md:214\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~ # use std::task::spawn;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/guide-tasks.md:246\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~ # use std::task::spawn; # use std::vec;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/guide-tasks.md:327\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~ # use std::vec; # use std::rand; use extra::arc::Arc;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\""}, {"sha": "b42d0feee2f69d666ed3fd42966c57305bf2e3f0", "filename": "doc/po/ja/guide-testing.md.po", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-testing.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Fguide-testing.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-testing.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,75 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/guide-testing.md:2\n+#, fuzzy\n+#| msgid \"% The Rust Language Tutorial\"\n+msgid \"% The Rust Testing Guide\"\n+msgstr \"% Rust \u8a00\u8a9e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\"\n+\n+#. type: Plain text\n+#: doc/guide-testing.md:4\n+#, fuzzy\n+#| msgid \"# Getting started\"\n+msgid \"# Quick start\"\n+msgstr \"# \u306f\u3058\u3081\u306b\"\n+\n+#. type: Plain text\n+#: doc/guide-testing.md:127 doc/tutorial.md:776\n+#, fuzzy\n+#| msgid \"## A minimal example\"\n+msgid \"For example:\"\n+msgstr \"## \u6700\u5c0f\u9650\u306e\u4f8b\"\n+\n+#. type: Plain text\n+#: doc/guide-testing.md:131\n+#, fuzzy\n+#| msgid \"~~~~ use std::task::spawn;\"\n+msgid \"~~~ extern mod extra; use std::vec;\"\n+msgstr \"\"\n+\"~~~~\\n\"\n+\"use std::task::spawn;\"\n+\n+#. type: Plain text\n+#: doc/guide-testing.md:167\n+#, fuzzy\n+#| msgid \"## Tuples\"\n+msgid \"## Examples\"\n+msgstr \"## \u30bf\u30d7\u30eb\"\n+\n+#. type: Plain text\n+#: doc/guide-testing.md:169\n+#, fuzzy\n+#| msgid \"## Tuple structs\"\n+msgid \"### Typical test run\"\n+msgstr \"## \u30bf\u30d7\u30eb\u69cb\u9020\u4f53\"\n+\n+#. type: Plain text\n+#: doc/guide-testing.md:197\n+#, fuzzy\n+#| msgid \"# Dereferencing pointers\"\n+msgid \"### Running ignored tests\"\n+msgstr \"# \u30dd\u30a4\u30f3\u30bf\u306e\u30c7\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\"\n+\n+#. type: Plain text\n+#: doc/guide-testing.md:235\n+#, fuzzy\n+#| msgid \"## Declaring and implementing traits\"\n+msgid \"## Saving and ratcheting metrics\"\n+msgstr \"## \u30c8\u30ec\u30a4\u30c8\u306e\u5ba3\u8a00\u3068\u5b9f\u88c5\""}, {"sha": "2941d50012d6d7219bf29d9af0d99e2501fe334c", "filename": "doc/po/ja/index.md.po", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Findex.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Findex.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Findex.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,31 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-14 21:02+0900\\n\"\n+\"PO-Revision-Date: 2014-01-14 21:02+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/index.md:2\n+#, fuzzy\n+#| msgid \"## Using the rust tool\"\n+msgid \"% Rust documentation\"\n+msgstr \"## `rust` \u30b3\u30de\u30f3\u30c9\u3092\u5229\u7528\u3059\u308b\"\n+\n+#. type: Plain text\n+#: doc/index.md:26\n+#, fuzzy\n+#| msgid \"## Using other crates\"\n+msgid \"# Libraries\"\n+msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\""}, {"sha": "d3567449e0e9eb3f4fe953e2a4d0c25e9edb381e", "filename": "doc/po/ja/rust.md.po", "status": "modified", "additions": 747, "deletions": 6222, "changes": 6969, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Frust.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Frust.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Frust.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1"}, {"sha": "9d5146ece7c861eb7cdadc3f5f66005a0eecb5e9", "filename": "doc/po/ja/rustdoc.md.po", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Frustdoc.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Frustdoc.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Frustdoc.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -0,0 +1,52 @@\n+# Japanese translations for Rust package\n+# Copyright (C) 2014 The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n+# Automatically generated, 2014.\n+#\n+msgid \"\"\n+msgstr \"\"\n+\"Project-Id-Version: Rust 0.10-pre\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n+\"PO-Revision-Date: 2014-01-13 12:01+0900\\n\"\n+\"Last-Translator: Automatically generated\\n\"\n+\"Language-Team: none\\n\"\n+\"Language: ja\\n\"\n+\"MIME-Version: 1.0\\n\"\n+\"Content-Type: text/plain; charset=UTF-8\\n\"\n+\"Content-Transfer-Encoding: 8bit\\n\"\n+\"Plural-Forms: nplurals=1; plural=0;\\n\"\n+\n+#. type: Plain text\n+#: doc/rustdoc.md:2\n+#, fuzzy\n+#| msgid \"## Using the rust tool\"\n+msgid \"% Rust Documentation\"\n+msgstr \"## `rust` \u30b3\u30de\u30f3\u30c9\u3092\u5229\u7528\u3059\u308b\"\n+\n+#. type: Plain text\n+#: doc/rustdoc.md:9\n+#, fuzzy\n+#| msgid \"## Using the rust tool\"\n+msgid \"# Creating Documentation\"\n+msgstr \"## `rust` \u30b3\u30de\u30f3\u30c9\u3092\u5229\u7528\u3059\u308b\"\n+\n+#. type: Plain text\n+#: doc/rustdoc.md:79\n+#, fuzzy\n+#| msgid \"## Using the rust tool\"\n+msgid \"# Using the Documentation\"\n+msgstr \"## `rust` \u30b3\u30de\u30f3\u30c9\u3092\u5229\u7528\u3059\u308b\"\n+\n+#. type: Plain text\n+#: doc/rustdoc.md:90\n+#, fuzzy\n+#| msgid \"## Using the rust tool\"\n+msgid \"# Testing the Documentation\"\n+msgstr \"## `rust` \u30b3\u30de\u30f3\u30c9\u3092\u5229\u7528\u3059\u308b\"\n+\n+#. type: Plain text\n+#: doc/rustdoc.md:102\n+#, fuzzy\n+#| msgid \"# Dereferencing pointers\"\n+msgid \"## Defining tests\"\n+msgstr \"# \u30dd\u30a4\u30f3\u30bf\u306e\u30c7\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\""}, {"sha": "4df7d2fa5832fda67b2359e8c5c800700a618488", "filename": "doc/po/ja/rustpkg.md.po", "status": "modified", "additions": 23, "deletions": 281, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Frustpkg.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Frustpkg.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Frustpkg.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1", "patch": "@@ -6,7 +6,7 @@\n msgid \"\"\n msgstr \"\"\n \"Project-Id-Version: Rust 0.8\\n\"\n-\"POT-Creation-Date: 2013-07-30 07:07+0900\\n\"\n+\"POT-Creation-Date: 2014-01-13 12:01+0900\\n\"\n \"PO-Revision-Date: 2013-07-28 20:32+0900\\n\"\n \"Last-Translator: Automatically generated\\n\"\n \"Language-Team: none\\n\"\n@@ -17,307 +17,49 @@ msgstr \"\"\n \"Plural-Forms: nplurals=1; plural=0;\\n\"\n \n #. type: Plain text\n+#: doc/guide-conditions.md:4 doc/guide-ffi.md:4 doc/guide-lifetimes.md:4\n+#: doc/guide-macros.md:4 doc/guide-rustpkg.md:4 doc/guide-tasks.md:4\n #: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n-#: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n msgid \"# Introduction\"\n msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n \n-#. type: Plain text\n-#: doc/rust.md:30 doc/rustpkg.md:8\n-msgid \"## Disclaimer\"\n-msgstr \"\"\n-\n #. type: Plain text\n #: doc/rustpkg.md:2\n+#, fuzzy\n+#| msgid \"% The Rust Language Tutorial\"\n msgid \"% Rustpkg Reference Manual\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:6\n-msgid \"\"\n-\"This document is the reference manual for the Rustpkg packaging and build \"\n-\"tool for the Rust programming language.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:12\n-msgid \"\"\n-\"Rustpkg is a work in progress, as is this reference manual.  If the actual \"\n-\"behavior of rustpkg differs from the behavior described in this reference, \"\n-\"that reflects either an incompleteness or a bug in rustpkg.\"\n-msgstr \"\"\n+msgstr \"% Rust \u8a00\u8a9e\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb\"\n \n #. type: Plain text\n #: doc/rustpkg.md:14\n+#, fuzzy\n+#| msgid \"## Pattern matching\"\n msgid \"# Package searching\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:17\n-msgid \"\"\n-\"rustpkg searches for packages using the `RUST_PATH` environment variable, \"\n-\"which is a colon-separated list (semicolon-separated on Windows) of \"\n-\"directories.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:19\n-msgid \"Each directory in this list is a *workspace* for rustpkg.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:30\n-msgid \"\"\n-\"`RUST_PATH` implicitly contains an entry for `./.rust` (as well as `../.\"\n-\"rust`, `../../.rust`, and so on for every parent of `.` up to the filesystem \"\n-\"root).  That means that if `RUST_PATH` is not set, then rustpkg will still \"\n-\"search for workspaces in `./.rust` and so on.  `RUST_PATH` also implicitly \"\n-\"contains an entry for the system path: `/usr/local` or the equivalent on \"\n-\"Windows.  This entry comes after the implicit entries for `./.rust` and so \"\n-\"on.  Finally, the last implicit entry in `RUST_PATH` is `~/.rust` or the \"\n-\"equivalent on Windows.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:32\n-msgid \"Each workspace may contain one or more packages.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:38\n-msgid \"\"\n-\"When building code that contains one or more directives of the form `extern \"\n-\"mod P`, rustpkg automatically searches for packages named `P` in the \"\n-\"`RUST_PATH` (as described above).  It builds those dependencies if \"\n-\"necessary.  Thus, when using rustpkg, there is no need for `-L` flags to \"\n-\"tell the linker where to find libraries for external crates.\"\n-msgstr \"\"\n+msgstr \"## \u30d1\u30bf\u30fc\u30f3\u30de\u30c3\u30c1\"\n \n #. type: Plain text\n #: doc/rustpkg.md:40\n+#, fuzzy\n+#| msgid \"# Data structures\"\n msgid \"# Package structure\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:42\n-msgid \"A valid workspace must contain each of the following subdirectories:\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/rustpkg.md:44\n-msgid \"\"\n-\"'src/': contains one subdirectory per package. Each subdirectory contains \"\n-\"source files for a given package.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:49\n-#, no-wrap\n-msgid \"\"\n-\"     For example, if `foo` is a workspace containing the package `bar`,\\n\"\n-\"     then `foo/src/bar/main.rs` could be the `main` entry point for\\n\"\n-\"     building a `bar` executable.\\n\"\n-\"* 'lib/': `rustpkg install` installs libraries into a target-specific subdirectory of this directory.\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:56\n-#, no-wrap\n-msgid \"\"\n-\"     For example, on a 64-bit machine running Mac OS X,\\n\"\n-\"     if `foo` is a workspace containing the package `bar`,\\n\"\n-\"     rustpkg will install libraries for bar to `foo/lib/x86_64-apple-darwin/`.\\n\"\n-\"     The libraries will have names of the form `foo/lib/x86_64-apple-darwin/libbar-[hash].dylib`,\\n\"\n-\"     where [hash] is a hash of the package ID.\\n\"\n-\"* 'bin/': `rustpkg install` installs executable binaries into a target-specific subdirectory of this directory.\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:63\n-#, no-wrap\n-msgid \"\"\n-\"     For example, on a 64-bit machine running Mac OS X,\\n\"\n-\"     if `foo` is a workspace, containing the package `bar`,\\n\"\n-\"     rustpkg will install executables for `bar` to\\n\"\n-\"     `foo/bin/x86_64-apple-darwin/`.\\n\"\n-\"     The executables will have names of the form `foo/bin/x86_64-apple-darwin/bar`.\\n\"\n-\"* 'build/': `rustpkg build` stores temporary build artifacts in a target-specific subdirectory of this directory.\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:67\n-#, no-wrap\n-msgid \"\"\n-\"     For example, on a 64-bit machine running Mac OS X,\\n\"\n-\"     if `foo` is a workspace containing the package `bar` and `foo/src/bar/main.rs` exists,\\n\"\n-\"     then `rustpkg build` will create `foo/build/x86_64-apple-darwin/bar/main.o`.\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:69\n-msgid \"# Package identifiers\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:87\n-msgid \"\"\n-\"A package identifier identifies a package uniquely.  A package can be stored \"\n-\"in a workspace on the local file system, or on a remote Web server, in which \"\n-\"case the package ID resembles a URL.  For example, `github.com/mozilla/rust` \"\n-\"is a package ID that would refer to the git repository browsable at `http://\"\n-\"github.com/mozilla/rust`.  A package ID can also specify a version, like: \"\n-\"`github.com/mozilla/rust#0.3`.  In this case, `rustpkg` will check that the \"\n-\"repository `github.com/mozilla/rust` has a tag named `0.3`, and report an \"\n-\"error otherwise.  A package ID can also specify a particular revision of a \"\n-\"repository, like: `github.com/mozilla/rust#release-0.7`.  When the refspec \"\n-\"(portion of the package ID after the `#`) can't be parsed as a decimal \"\n-\"number, rustpkg passes the refspec along to the version control system \"\n-\"without interpreting it.  rustpkg also interprets any dependencies on such a \"\n-\"package ID literally (as opposed to versions, where a newer version \"\n-\"satisfies a dependency on an older version).  Thus, `github.com/mozilla/\"\n-\"rust#5c4cd30f80` is also a valid package ID, since git can deduce that \"\n-\"5c4cd30f80 refers to a revision of the desired repository.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:89\n-msgid \"## Source files\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:91\n-msgid \"\"\n-\"rustpkg searches for four different fixed filenames in order to determine \"\n-\"the crates to build:\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/rustpkg.md:96\n-msgid \"`main.rs`: Assumed to be a main entry point for building an executable.\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/rustpkg.md:96\n-msgid \"`lib.rs`: Assumed to be a library crate.\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/rustpkg.md:96\n-msgid \"\"\n-\"`test.rs`: Assumed to contain tests declared with the `#[test]` attribute.\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/rustpkg.md:96\n-msgid \"\"\n-\"`bench.rs`: Assumed to contain benchmarks declared with the `#[bench]` \"\n-\"attribute.\"\n-msgstr \"\"\n+msgstr \"# \u30c7\u30fc\u30bf\u69cb\u9020\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:98\n+#: doc/rustpkg.md:106\n+#, fuzzy\n+#| msgid \"## Conventions\"\n msgid \"## Versions\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:105\n-msgid \"\"\n-\"`rustpkg` packages do not need to declare their versions with an attribute \"\n-\"inside one of the source files, because `rustpkg` infers it from the version \"\n-\"control system.  When building a package that is in a `git` repository, \"\n-\"`rustpkg` assumes that the most recent tag specifies the current version.  \"\n-\"When building a package that is not under version control, or that has no \"\n-\"tags, `rustpkg` assumes the intended version is 0.1.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:107\n-msgid \"# Dependencies\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:111\n-msgid \"\"\n-\"rustpkg infers dependencies from `extern mod` directives.  Thus, there \"\n-\"should be no need to pass a `-L` flag to rustpkg to tell it where to find a \"\n-\"library.  (In the future, it will also be possible to write an `extern mod` \"\n-\"directive referring to a remote package.)\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:113\n-msgid \"# Custom build scripts\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:117\n-msgid \"\"\n-\"A file called `pkg.rs` at the root level in a workspace is called a *package \"\n-\"script*.  If a package script exists, rustpkg executes it to build the \"\n-\"package rather than inferring crates as described previously.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:121\n-msgid \"\"\n-\"Inside `pkg.rs`, it's possible to call back into rustpkg to finish up the \"\n-\"build.  `rustpkg::api` contains functions to build, install, or clean \"\n-\"libraries and executables in the way rustpkg normally would without custom \"\n-\"build logic.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:123\n-msgid \"# Command reference\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:125\n-msgid \"## build\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:131\n-msgid \"\"\n-\"`rustpkg build foo` searches for a package with ID `foo` and builds it in \"\n-\"any workspace(s) where it finds one.  Supposing such packages are found in \"\n-\"workspaces X, Y, and Z, the command leaves behind files in `X`'s, `Y`'s, and \"\n-\"`Z`'s `build` directories, but not in their `lib` or `bin` directories.\"\n-msgstr \"\"\n+msgstr \"## \u672c\u66f8\u306e\u8868\u8a18\u306b\u3064\u3044\u3066\"\n \n #. type: Plain text\n #: doc/rustpkg.md:133\n-msgid \"## clean\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:135\n-msgid \"`rustpkg clean foo` deletes the contents of `foo`'s `build` directory.\"\n-msgstr \"\"\n+#, fuzzy\n+msgid \"# Command reference\"\n+msgstr \"# \u30dd\u30a4\u30f3\u30bf\u306e\u30c7\u30ea\u30d5\u30a1\u30ec\u30f3\u30b9\"\n \n #. type: Plain text\n-#: doc/rustpkg.md:137\n+#: doc/rustpkg.md:150\n+#, fuzzy\n+#| msgid \"# Introduction\"\n msgid \"## install\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:141\n-msgid \"\"\n-\"`rustpkg install foo` builds the libraries and/or executables that are \"\n-\"targets for `foo`, and then installs them either into `foo`'s `lib` and \"\n-\"`bin` directories, or into the `lib` and `bin` subdirectories of the first \"\n-\"entry in `RUST_PATH`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:143\n-msgid \"## test\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/rustpkg.md:145\n-msgid \"\"\n-\"`rustpkg test foo` builds `foo`'s `test.rs` file if necessary, then runs the \"\n-\"resulting test executable.\"\n-msgstr \"\"\n+msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\""}, {"sha": "19bf3adeb0b24ae96bf8633a54c02bb61faf22d0", "filename": "doc/po/ja/tutorial-borrowed-ptr.md.po", "status": "removed", "additions": 0, "deletions": 1071, "changes": 1071, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fpo%2Fja%2Ftutorial-borrowed-ptr.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fpo%2Fja%2Ftutorial-borrowed-ptr.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial-borrowed-ptr.md.po?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -1,1071 +0,0 @@\n-# Japanese translations for Rust package\n-# Copyright (C) 2013 The Rust Project Developers\n-# This file is distributed under the same license as the Rust package.\n-# Automatically generated, 2013.\n-#\n-msgid \"\"\n-msgstr \"\"\n-\"Project-Id-Version: Rust 0.8\\n\"\n-\"POT-Creation-Date: 2013-07-22 23:37+0900\\n\"\n-\"PO-Revision-Date: 2013-07-28 20:32+0900\\n\"\n-\"Last-Translator: Automatically generated\\n\"\n-\"Language-Team: none\\n\"\n-\"Language: ja\\n\"\n-\"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=UTF-8\\n\"\n-\"Content-Transfer-Encoding: 8bit\\n\"\n-\"Plural-Forms: nplurals=1; plural=0;\\n\"\n-\n-#. type: Plain text\n-#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n-#: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n-msgid \"# Introduction\"\n-msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n-\n-#. type: Plain text\n-#: doc/tutorial.md:1108 doc/tutorial-borrowed-ptr.md:72\n-msgid \"Now we can call `compute_distance()` in various ways:\"\n-msgstr \"\"\n-\"\u4e0a\u8a18\u306e `compute_distance()` \u95a2\u6570\u306f\u3001\u69d8\u3005\u306a\u65b9\u6cd5\u3067\u547c\u3073\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:2\n-msgid \"% Rust Borrowed Pointers Tutorial\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:14\n-msgid \"\"\n-\"Borrowed pointers are one of the more flexible and powerful tools available \"\n-\"in Rust. A borrowed pointer can point anywhere: into the managed or exchange \"\n-\"heap, into the stack, and even into the interior of another data structure. \"\n-\"A borrowed pointer is as flexible as a C pointer or C++ reference. However, \"\n-\"unlike C and C++ compilers, the Rust compiler includes special static checks \"\n-\"that ensure that programs use borrowed pointers safely. Another advantage of \"\n-\"borrowed pointers is that they are invisible to the garbage collector, so \"\n-\"working with borrowed pointers helps reduce the overhead of automatic memory \"\n-\"management.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:18\n-msgid \"\"\n-\"Despite their complete safety, a borrowed pointer's representation at \"\n-\"runtime is the same as that of an ordinary pointer in a C program. They \"\n-\"introduce zero overhead. The compiler does all safety checks at compile time.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:24\n-msgid \"\"\n-\"Although borrowed pointers have rather elaborate theoretical underpinnings \"\n-\"(region pointers), the core concepts will be familiar to anyone who has \"\n-\"worked with C or C++. Therefore, the best way to explain how they are used\u2014\"\n-\"and their limitations\u2014is probably just to work through several examples.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:26\n-msgid \"# By example\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:31\n-msgid \"\"\n-\"Borrowed pointers are called *borrowed* because they are only valid for a \"\n-\"limited duration. Borrowed pointers never claim any kind of ownership over \"\n-\"the data that they point to: instead, they are used for cases where you \"\n-\"would like to use data for a short time.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:33\n-msgid \"As an example, consider a simple struct type `Point`:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:37\n-msgid \"~~~ struct Point {x: float, y: float} ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:41\n-msgid \"\"\n-\"We can use this simple definition to allocate points in many different ways. \"\n-\"For example, in this code, each of these three local variables contains a \"\n-\"point, but allocated in a different place:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:48\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct Point {x: float, y: float}\\n\"\n-\"let on_the_stack :  Point =  Point {x: 3.0, y: 4.0};\\n\"\n-\"let managed_box  : @Point = @Point {x: 5.0, y: 1.0};\\n\"\n-\"let owned_box    : ~Point = ~Point {x: 7.0, y: 9.0};\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:60\n-msgid \"\"\n-\"Suppose we wanted to write a procedure that computed the distance between \"\n-\"any two points, no matter where they were stored. For example, we might like \"\n-\"to compute the distance between `on_the_stack` and `managed_box`, or between \"\n-\"`managed_box` and `owned_box`. One option is to define a function that takes \"\n-\"two arguments of type `Point`\u2014that is, it takes the points by value. But if \"\n-\"we define it this way, calling the function will cause the points to be \"\n-\"copied. For points, this is probably not so bad, but often copies are \"\n-\"expensive. Worse, if the data type contains mutable fields, copying can \"\n-\"change the semantics of your program in unexpected ways. So we'd like to \"\n-\"define a function that takes the points by pointer. We can use borrowed \"\n-\"pointers to do this:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:70\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct Point {x: float, y: float}\\n\"\n-\"# fn sqrt(f: float) -> float { 0f }\\n\"\n-\"fn compute_distance(p1: &Point, p2: &Point) -> float {\\n\"\n-\"    let x_d = p1.x - p2.x;\\n\"\n-\"    let y_d = p1.y - p2.y;\\n\"\n-\"    sqrt(x_d * x_d + y_d * y_d)\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:82\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct Point {x: float, y: float}\\n\"\n-\"# let on_the_stack :  Point =  Point{x: 3.0, y: 4.0};\\n\"\n-\"# let managed_box  : @Point = @Point{x: 5.0, y: 1.0};\\n\"\n-\"# let owned_box    : ~Point = ~Point{x: 7.0, y: 9.0};\\n\"\n-\"# fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\\n\"\n-\"compute_distance(&on_the_stack, managed_box);\\n\"\n-\"compute_distance(managed_box, owned_box);\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:89\n-msgid \"\"\n-\"Here, the `&` operator takes the address of the variable `on_the_stack`; \"\n-\"this is because `on_the_stack` has the type `Point` (that is, a struct \"\n-\"value) and we have to take its address to get a value. We also call this \"\n-\"_borrowing_ the local variable `on_the_stack`, because we have created an \"\n-\"alias: that is, another name for the same data.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:95\n-msgid \"\"\n-\"In contrast, we can pass the boxes `managed_box` and `owned_box` to \"\n-\"`compute_distance` directly. The compiler automatically converts a box like \"\n-\"`@Point` or `~Point` to a borrowed pointer like `&Point`. This is another \"\n-\"form of borrowing: in this case, the caller lends the contents of the \"\n-\"managed or owned box to the callee.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:105\n-msgid \"\"\n-\"Whenever a caller lends data to a callee, there are some limitations on what \"\n-\"the caller can do with the original. For example, if the contents of a \"\n-\"variable have been lent out, you cannot send that variable to another task. \"\n-\"In addition, the compiler will reject any code that might cause the borrowed \"\n-\"value to be freed or overwrite its component fields with values of different \"\n-\"types (I'll get into what kinds of actions those are shortly). This rule \"\n-\"should make intuitive sense: you must wait for a borrower to return the \"\n-\"value that you lent it (that is, wait for the borrowed pointer to go out of \"\n-\"scope)  before you can make full use of it again.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:107\n-msgid \"# Other uses for the & operator\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:109\n-msgid \"In the previous example, the value `on_the_stack` was defined like so:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:114\n-msgid \"\"\n-\"~~~ # struct Point {x: float, y: float} let on_the_stack: Point = Point {x: \"\n-\"3.0, y: 4.0}; ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:119\n-msgid \"\"\n-\"This declaration means that code can only pass `Point` by value to other \"\n-\"functions. As a consequence, we had to explicitly take the address of \"\n-\"`on_the_stack` to get a borrowed pointer. Sometimes however it is more \"\n-\"convenient to move the & operator into the definition of `on_the_stack`:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:124\n-msgid \"\"\n-\"~~~ # struct Point {x: float, y: float} let on_the_stack2: &Point = &Point \"\n-\"{x: 3.0, y: 4.0}; ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:128\n-msgid \"\"\n-\"Applying `&` to an rvalue (non-assignable location) is just a convenient \"\n-\"shorthand for creating a temporary and taking its address. A more verbose \"\n-\"way to write the same code is:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:134\n-msgid \"\"\n-\"~~~ # struct Point {x: float, y: float} let tmp = Point {x: 3.0, y: 4.0}; \"\n-\"let on_the_stack2 : &Point = &tmp; ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:136\n-msgid \"# Taking the address of fields\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:141\n-msgid \"\"\n-\"As in C, the `&` operator is not limited to taking the address of local \"\n-\"variables. It can also take the address of fields or individual array \"\n-\"elements. For example, consider this type definition for `rectangle`:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:147\n-msgid \"\"\n-\"~~~ struct Point {x: float, y: float} // as before struct Size {w: float, h: \"\n-\"float} // as before struct Rectangle {origin: Point, size: Size} ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:149\n-msgid \"Now, as before, we can define rectangles in a few different ways:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:161\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct Point {x: float, y: float}\\n\"\n-\"# struct Size {w: float, h: float} // as before\\n\"\n-\"# struct Rectangle {origin: Point, size: Size}\\n\"\n-\"let rect_stack   = &Rectangle {origin: Point {x: 1f, y: 2f},\\n\"\n-\"                               size: Size {w: 3f, h: 4f}};\\n\"\n-\"let rect_managed = @Rectangle {origin: Point {x: 3f, y: 4f},\\n\"\n-\"                               size: Size {w: 3f, h: 4f}};\\n\"\n-\"let rect_owned   = ~Rectangle {origin: Point {x: 5f, y: 6f},\\n\"\n-\"                               size: Size {w: 3f, h: 4f}};\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:164\n-msgid \"\"\n-\"In each case, we can extract out individual subcomponents with the `&` \"\n-\"operator. For example, I could write:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:175\n-msgid \"\"\n-\"~~~ # struct Point {x: float, y: float} // as before # struct Size {w: \"\n-\"float, h: float} // as before # struct Rectangle {origin: Point, size: Size} \"\n-\"# let rect_stack = &Rectangle {origin: Point {x: 1f, y: 2f}, size: Size {w: \"\n-\"3f, h: 4f}}; # let rect_managed = @Rectangle {origin: Point {x: 3f, y: 4f}, \"\n-\"size: Size {w: 3f, h: 4f}}; # let rect_owned = ~Rectangle {origin: Point {x: \"\n-\"5f, y: 6f}, size: Size {w: 3f, h: 4f}}; # fn compute_distance(p1: &Point, \"\n-\"p2: &Point) -> float { 0f } compute_distance(&rect_stack.origin, \"\n-\"&rect_managed.origin); ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:178\n-msgid \"\"\n-\"which would borrow the field `origin` from the rectangle on the stack as \"\n-\"well as from the managed box, and then compute the distance between them.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:180\n-msgid \"# Borrowing managed boxes and rooting\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:186\n-msgid \"\"\n-\"We\u2019ve seen a few examples so far of borrowing heap boxes, both managed and \"\n-\"owned. Up till this point, we\u2019ve glossed over issues of safety. As stated in \"\n-\"the introduction, at runtime a borrowed pointer is simply a pointer, nothing \"\n-\"more. Therefore, avoiding C's problems with dangling pointers requires a \"\n-\"compile-time safety check.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:197\n-msgid \"\"\n-\"The basis for the check is the notion of _lifetimes_. A lifetime is a static \"\n-\"approximation of the span of execution during which the pointer is valid: it \"\n-\"always corresponds to some expression or block within the program. Code \"\n-\"inside that expression can use the pointer without restrictions. But if the \"\n-\"pointer escapes from that expression (for example, if the expression \"\n-\"contains an assignment expression that assigns the pointer to a mutable \"\n-\"field of a data structure with a broader scope than the pointer itself), the \"\n-\"compiler reports an error. We'll be discussing lifetimes more in the \"\n-\"examples to come, and a more thorough introduction is also available.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:202\n-msgid \"\"\n-\"When the `&` operator creates a borrowed pointer, the compiler must ensure \"\n-\"that the pointer remains valid for its entire lifetime. Sometimes this is \"\n-\"relatively easy, such as when taking the address of a local variable or a \"\n-\"field that is stored on the stack:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:211\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"struct X { f: int }\\n\"\n-\"fn example1() {\\n\"\n-\"    let mut x = X { f: 3 };\\n\"\n-\"    let y = &mut x.f;  // -+ L\\n\"\n-\"    ...                //  |\\n\"\n-\"}                      // -+\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:216\n-msgid \"\"\n-\"Here, the lifetime of the borrowed pointer `y` is simply L, the remainder of \"\n-\"the function body. The compiler need not do any other work to prove that \"\n-\"code will not free `x.f`. This is true even if the code mutates `x`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:218\n-msgid \"The situation gets more complex when borrowing data inside heap boxes:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:227\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct X { f: int }\\n\"\n-\"fn example2() {\\n\"\n-\"    let mut x = @X { f: 3 };\\n\"\n-\"    let y = &x.f;      // -+ L\\n\"\n-\"    ...                //  |\\n\"\n-\"}                      // -+\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:238\n-msgid \"\"\n-\"In this example, the value `x` is a heap box, and `y` is therefore a pointer \"\n-\"into that heap box. Again the lifetime of `y` is L, the remainder of the \"\n-\"function body. But there is a crucial difference: suppose `x` were to be \"\n-\"reassigned during the lifetime L? If the compiler isn't careful, the managed \"\n-\"box could become *unrooted*, and would therefore be subject to garbage \"\n-\"collection. A heap box that is unrooted is one such that no pointer values \"\n-\"in the heap point to it. It would violate memory safety for the box that was \"\n-\"originally assigned to `x` to be garbage-collected, since a non-heap pointer \"\n-\"*`y`* still points into it.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:241\n-msgid \"\"\n-\"> ***Note:*** Our current implementation implements the garbage collector > \"\n-\"using reference counting and cycle detection.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:247\n-msgid \"\"\n-\"For this reason, whenever an `&` expression borrows the interior of a \"\n-\"managed box stored in a mutable location, the compiler inserts a temporary \"\n-\"that ensures that the managed box remains live for the entire lifetime. So, \"\n-\"the above example would be compiled as if it were written\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:257\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct X { f: int }\\n\"\n-\"fn example2() {\\n\"\n-\"    let mut x = @X {f: 3};\\n\"\n-\"    let x1 = x;\\n\"\n-\"    let y = &x1.f;     // -+ L\\n\"\n-\"    ...                //  |\\n\"\n-\"}                      // -+\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:260\n-msgid \"\"\n-\"Now if `x` is reassigned, the pointer `y` will still remain valid. This \"\n-\"process is called *rooting*.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:262\n-msgid \"# Borrowing owned boxes\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:268\n-msgid \"\"\n-\"The previous example demonstrated *rooting*, the process by which the \"\n-\"compiler ensures that managed boxes remain live for the duration of a \"\n-\"borrow. Unfortunately, rooting does not work for borrows of owned boxes, \"\n-\"because it is not possible to have two references to a owned box.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:274\n-msgid \"\"\n-\"For owned boxes, therefore, the compiler will only allow a borrow *if the \"\n-\"compiler can guarantee that the owned box will not be reassigned or moved \"\n-\"for the lifetime of the pointer*. This does not necessarily mean that the \"\n-\"owned box is stored in immutable memory. For example, the following function \"\n-\"is legal:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:289\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# fn some_condition() -> bool { true }\\n\"\n-\"# struct Foo { f: int }\\n\"\n-\"fn example3() -> int {\\n\"\n-\"    let mut x = ~Foo {f: 3};\\n\"\n-\"    if some_condition() {\\n\"\n-\"        let y = &x.f;      // -+ L\\n\"\n-\"        return *y;         //  |\\n\"\n-\"    }                      // -+\\n\"\n-\"    x = ~Foo {f: 4};\\n\"\n-\"    ...\\n\"\n-\"# return 0;\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:295\n-msgid \"\"\n-\"Here, as before, the interior of the variable `x` is being borrowed and `x` \"\n-\"is declared as mutable. However, the compiler can prove that `x` is not \"\n-\"assigned anywhere in the lifetime L of the variable `y`. Therefore, it \"\n-\"accepts the function, even though `x` is mutable and in fact is mutated \"\n-\"later in the function.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:301\n-msgid \"\"\n-\"It may not be clear why we are so concerned about mutating a borrowed \"\n-\"variable. The reason is that the runtime system frees any owned box _as soon \"\n-\"as its owning reference changes or goes out of scope_. Therefore, a program \"\n-\"like this is illegal (and would be rejected by the compiler):\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:310\n-#, no-wrap\n-msgid \"\"\n-\"~~~ {.xfail-test}\\n\"\n-\"fn example3() -> int {\\n\"\n-\"    let mut x = ~X {f: 3};\\n\"\n-\"    let y = &x.f;\\n\"\n-\"    x = ~X {f: 4};  // Error reported here.\\n\"\n-\"    *y\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:313\n-msgid \"\"\n-\"To make this clearer, consider this diagram showing the state of memory \"\n-\"immediately before the re-assignment of `x`:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:316 doc/tutorial-borrowed-ptr.md:330\n-#, no-wrap\n-msgid \"\"\n-\"~~~ {.notrust}\\n\"\n-\"    Stack               Exchange Heap\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:325\n-#, no-wrap\n-msgid \"\"\n-\"  x +----------+\\n\"\n-\"    | ~{f:int} | ----+\\n\"\n-\"  y +----------+     |\\n\"\n-\"    | &int     | ----+\\n\"\n-\"    +----------+     |    +---------+\\n\"\n-\"                     +--> |  f: 3   |\\n\"\n-\"                          +---------+\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:327\n-msgid \"Once the reassignment occurs, the memory will look like this:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:339\n-#, no-wrap\n-msgid \"\"\n-\"  x +----------+          +---------+\\n\"\n-\"    | ~{f:int} | -------> |  f: 4   |\\n\"\n-\"  y +----------+          +---------+\\n\"\n-\"    | &int     | ----+\\n\"\n-\"    +----------+     |    +---------+\\n\"\n-\"                     +--> | (freed) |\\n\"\n-\"                          +---------+\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:342\n-msgid \"\"\n-\"Here you can see that the variable `y` still points at the old box, which \"\n-\"has been freed.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:348\n-msgid \"\"\n-\"In fact, the compiler can apply the same kind of reasoning to any memory \"\n-\"that is _(uniquely) owned by the stack frame_. So we could modify the \"\n-\"previous example to introduce additional owned pointers and structs, and the \"\n-\"compiler will still be able to detect possible mutations:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:353\n-#, no-wrap\n-msgid \"\"\n-\"~~~ {.xfail-test}\\n\"\n-\"fn example3() -> int {\\n\"\n-\"    struct R { g: int }\\n\"\n-\"    struct S { f: ~R }\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:361\n-#, no-wrap\n-msgid \"\"\n-\"    let mut x = ~S {f: ~R {g: 3}};\\n\"\n-\"    let y = &x.f.g;\\n\"\n-\"    x = ~S {f: ~R {g: 4}};  // Error reported here.\\n\"\n-\"    x.f = ~R {g: 5};        // Error reported here.\\n\"\n-\"    *y\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:365\n-msgid \"\"\n-\"In this case, two errors are reported, one when the variable `x` is modified \"\n-\"and another when `x.f` is modified. Either modification would invalidate the \"\n-\"pointer `y`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:367\n-msgid \"# Borrowing and enums\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:373\n-msgid \"\"\n-\"The previous example showed that the type system forbids any borrowing of \"\n-\"owned boxes found in aliasable, mutable memory. This restriction prevents \"\n-\"pointers from pointing into freed memory. There is one other case where the \"\n-\"compiler must be very careful to ensure that pointers remain valid: pointers \"\n-\"into the interior of an `enum`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:376\n-msgid \"\"\n-\"As an example, let\u2019s look at the following `shape` type that can represent \"\n-\"both rectangles and circles:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:385\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"struct Point {x: float, y: float}; // as before\\n\"\n-\"struct Size {w: float, h: float}; // as before\\n\"\n-\"enum Shape {\\n\"\n-\"    Circle(Point, float),   // origin, radius\\n\"\n-\"    Rectangle(Point, Size)  // upper-left, dimensions\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:389\n-msgid \"\"\n-\"Now we might write a function to compute the area of a shape. This function \"\n-\"takes a borrowed pointer to a shape, to avoid the need for copying.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:405\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct Point {x: float, y: float}; // as before\\n\"\n-\"# struct Size {w: float, h: float}; // as before\\n\"\n-\"# enum Shape {\\n\"\n-\"#     Circle(Point, float),   // origin, radius\\n\"\n-\"#     Rectangle(Point, Size)  // upper-left, dimensions\\n\"\n-\"# }\\n\"\n-\"# static tau: float = 6.28f;\\n\"\n-\"fn compute_area(shape: &Shape) -> float {\\n\"\n-\"    match *shape {\\n\"\n-\"        Circle(_, radius) => 0.5 * tau * radius * radius,\\n\"\n-\"        Rectangle(_, ref size) => size.w * size.h\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:410\n-msgid \"\"\n-\"The first case matches against circles. Here, the pattern extracts the \"\n-\"radius from the shape variant and the action uses it to compute the area of \"\n-\"the circle. (Like any up-to-date engineer, we use the [tau circle constant]\"\n-\"[tau] and not that dreadfully outdated notion of pi).\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:412\n-msgid \"[tau]: http://www.math.utah.edu/~palais/pi.html\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:418\n-msgid \"\"\n-\"The second match is more interesting. Here we match against a rectangle and \"\n-\"extract its size: but rather than copy the `size` struct, we use a by-\"\n-\"reference binding to create a pointer to it. In other words, a pattern \"\n-\"binding like `ref size` binds the name `size` to a pointer of type `&size` \"\n-\"into the _interior of the enum_.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:421\n-msgid \"\"\n-\"To make this more clear, let's look at a diagram of memory layout in the \"\n-\"case where `shape` points at a rectangle:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:424 doc/tutorial-borrowed-ptr.md:449\n-#, no-wrap\n-msgid \"\"\n-\"~~~ {.notrust}\\n\"\n-\"Stack             Memory\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:433\n-#, no-wrap\n-msgid \"\"\n-\"+-------+         +---------------+\\n\"\n-\"| shape | ------> | rectangle(    |\\n\"\n-\"+-------+         |   {x: float,  |\\n\"\n-\"| size  | -+      |    y: float}, |\\n\"\n-\"+-------+  +----> |   {w: float,  |\\n\"\n-\"                  |    h: float}) |\\n\"\n-\"                  +---------------+\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:440\n-msgid \"\"\n-\"Here you can see that rectangular shapes are composed of five words of \"\n-\"memory. The first is a tag indicating which variant this enum is \"\n-\"(`rectangle`, in this case). The next two words are the `x` and `y` fields \"\n-\"for the point and the remaining two are the `w` and `h` fields for the size. \"\n-\"The binding `size` is then a pointer into the inside of the shape.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:446\n-msgid \"\"\n-\"Perhaps you can see where the danger lies: if the shape were somehow to be \"\n-\"reassigned, perhaps to a circle, then although the memory used to store that \"\n-\"shape value would still be valid, _it would have a different type_! The \"\n-\"following diagram shows what memory would look like if code overwrote \"\n-\"`shape` with a circle:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:458\n-#, no-wrap\n-msgid \"\"\n-\"+-------+         +---------------+\\n\"\n-\"| shape | ------> | circle(       |\\n\"\n-\"+-------+         |   {x: float,  |\\n\"\n-\"| size  | -+      |    y: float}, |\\n\"\n-\"+-------+  +----> |   float)      |\\n\"\n-\"                  |               |\\n\"\n-\"                  +---------------+\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:463\n-msgid \"\"\n-\"As you can see, the `size` pointer would be pointing at a `float` instead of \"\n-\"a struct. This is not good: dereferencing the second field of a `float` as \"\n-\"if it were a struct with two fields would be a memory safety violation.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:475\n-msgid \"\"\n-\"So, in fact, for every `ref` binding, the compiler will impose the same \"\n-\"rules as the ones we saw for borrowing the interior of a owned box: it must \"\n-\"be able to guarantee that the `enum` will not be overwritten for the \"\n-\"duration of the borrow.  In fact, the compiler would accept the example we \"\n-\"gave earlier. The example is safe because the shape pointer has type \"\n-\"`&Shape`, which means \\\"borrowed pointer to immutable memory containing a \"\n-\"`shape`\\\". If, however, the type of that pointer were `&mut Shape`, then the \"\n-\"ref binding would be ill-typed.  Just as with owned boxes, the compiler will \"\n-\"permit `ref` bindings into data owned by the stack frame even if the data \"\n-\"are mutable, but otherwise it requires that the data reside in immutable \"\n-\"memory.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:477\n-msgid \"# Returning borrowed pointers\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:483\n-msgid \"\"\n-\"So far, all of the examples we have looked at, use borrowed pointers in a \"\n-\"\u201cdownward\u201d direction. That is, a method or code block creates a borrowed \"\n-\"pointer, then uses it within the same scope. It is also possible to return \"\n-\"borrowed pointers as the result of a function, but as we'll see, doing so \"\n-\"requires some explicit annotation.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:485\n-msgid \"For example, we could write a subroutine like this:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:490\n-msgid \"\"\n-\"~~~ struct Point {x: float, y: float} fn get_x<'r>(p: &'r Point) -> &'r \"\n-\"float { &p.x } ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:498\n-msgid \"\"\n-\"Here, the function `get_x()` returns a pointer into the structure it was \"\n-\"given. The type of the parameter (`&'r Point`) and return type (`&'r float`) \"\n-\"both use a new syntactic form that we have not seen so far.  Here the \"\n-\"identifier `r` names the lifetime of the pointer explicitly. So in effect, \"\n-\"this function declares that it takes a pointer with lifetime `r` and returns \"\n-\"a pointer with that same lifetime.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:504\n-msgid \"\"\n-\"In general, it is only possible to return borrowed pointers if they are \"\n-\"derived from a parameter to the procedure. In that case, the pointer result \"\n-\"will always have the same lifetime as one of the parameters; named lifetimes \"\n-\"indicate which parameter that is.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:510\n-msgid \"\"\n-\"In the previous examples, function parameter types did not include a \"\n-\"lifetime name. In those examples, the compiler simply creates a fresh name \"\n-\"for the lifetime automatically: that is, the lifetime name is guaranteed to \"\n-\"refer to a distinct lifetime from the lifetimes of all other parameters.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:518\n-msgid \"\"\n-\"Named lifetimes that appear in function signatures are conceptually the same \"\n-\"as the other lifetimes we have seen before, but they are a bit abstract: \"\n-\"they don\u2019t refer to a specific expression within `get_x()`, but rather to \"\n-\"some expression within the *caller of `get_x()`*.  The lifetime `r` is \"\n-\"actually a kind of *lifetime parameter*: it is defined by the caller to \"\n-\"`get_x()`, just as the value for the parameter `p` is defined by that caller.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:523\n-msgid \"\"\n-\"In any case, whatever the lifetime of `r` is, the pointer produced by `&p.x` \"\n-\"always has the same lifetime as `p` itself: a pointer to a field of a struct \"\n-\"is valid as long as the struct is valid. Therefore, the compiler accepts the \"\n-\"function `get_x()`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:526\n-msgid \"\"\n-\"To emphasize this point, let\u2019s look at a variation on the example, this time \"\n-\"one that does not compile:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:533\n-#, no-wrap\n-msgid \"\"\n-\"~~~ {.xfail-test}\\n\"\n-\"struct Point {x: float, y: float}\\n\"\n-\"fn get_x_sh(p: @Point) -> &float {\\n\"\n-\"    &p.x // Error reported here\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:541\n-msgid \"\"\n-\"Here, the function `get_x_sh()` takes a managed box as input and returns a \"\n-\"borrowed pointer. As before, the lifetime of the borrowed pointer that will \"\n-\"be returned is a parameter (specified by the caller). That means that \"\n-\"`get_x_sh()` promises to return a borrowed pointer that is valid for as long \"\n-\"as the caller would like: this is subtly different from the first example, \"\n-\"which promised to return a pointer that was valid for as long as its pointer \"\n-\"argument was valid.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:552\n-msgid \"\"\n-\"Within `get_x_sh()`, we see the expression `&p.x` which takes the address of \"\n-\"a field of a managed box. The presence of this expression implies that the \"\n-\"compiler must guarantee that, so long as the resulting pointer is valid, the \"\n-\"managed box will not be reclaimed by the garbage collector. But recall that \"\n-\"`get_x_sh()` also promised to return a pointer that was valid for as long as \"\n-\"the caller wanted it to be. Clearly, `get_x_sh()` is not in a position to \"\n-\"make both of these guarantees; in fact, it cannot guarantee that the pointer \"\n-\"will remain valid at all once it returns, as the parameter `p` may or may \"\n-\"not be live in the caller. Therefore, the compiler will report an error here.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:559\n-msgid \"\"\n-\"In general, if you borrow a managed (or owned) box to create a borrowed \"\n-\"pointer, the pointer will only be valid within the function and cannot be \"\n-\"returned. This is why the typical way to return borrowed pointers is to take \"\n-\"borrowed pointers as input (the only other case in which it can be legal to \"\n-\"return a borrowed pointer is if the pointer points at a static constant).\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:561\n-msgid \"# Named lifetimes\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:565\n-msgid \"\"\n-\"Let's look at named lifetimes in more detail. Named lifetimes allow for \"\n-\"grouping of parameters by lifetime. For example, consider this function:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:579\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct Point {x: float, y: float}; // as before\\n\"\n-\"# struct Size {w: float, h: float}; // as before\\n\"\n-\"# enum Shape {\\n\"\n-\"#     Circle(Point, float),   // origin, radius\\n\"\n-\"#     Rectangle(Point, Size)  // upper-left, dimensions\\n\"\n-\"# }\\n\"\n-\"# fn compute_area(shape: &Shape) -> float { 0f }\\n\"\n-\"fn select<'r, T>(shape: &'r Shape, threshold: float,\\n\"\n-\"                 a: &'r T, b: &'r T) -> &'r T {\\n\"\n-\"    if compute_area(shape) > threshold {a} else {b}\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:585\n-msgid \"\"\n-\"This function takes three borrowed pointers and assigns each the same \"\n-\"lifetime `r`.  In practice, this means that, in the caller, the lifetime `r` \"\n-\"will be the *intersection of the lifetime of the three region parameters*. \"\n-\"This may be overly conservative, as in this example:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:607\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct Point {x: float, y: float}; // as before\\n\"\n-\"# struct Size {w: float, h: float}; // as before\\n\"\n-\"# enum Shape {\\n\"\n-\"#     Circle(Point, float),   // origin, radius\\n\"\n-\"#     Rectangle(Point, Size)  // upper-left, dimensions\\n\"\n-\"# }\\n\"\n-\"# fn compute_area(shape: &Shape) -> float { 0f }\\n\"\n-\"# fn select<'r, T>(shape: &Shape, threshold: float,\\n\"\n-\"#                  a: &'r T, b: &'r T) -> &'r T {\\n\"\n-\"#     if compute_area(shape) > threshold {a} else {b}\\n\"\n-\"# }\\n\"\n-\"                                                     // -+ r\\n\"\n-\"fn select_based_on_unit_circle<'r, T>(               //  |-+ B\\n\"\n-\"    threshold: float, a: &'r T, b: &'r T) -> &'r T { //  | |\\n\"\n-\"                                                     //  | |\\n\"\n-\"    let shape = Circle(Point {x: 0., y: 0.}, 1.);    //  | |\\n\"\n-\"    select(&shape, threshold, a, b)                  //  | |\\n\"\n-\"}                                                    //  |-+\\n\"\n-\"                                                     // -+\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:617\n-msgid \"\"\n-\"In this call to `select()`, the lifetime of the first parameter shape is B, \"\n-\"the function body. Both of the second two parameters `a` and `b` share the \"\n-\"same lifetime, `r`, which is a lifetime parameter of \"\n-\"`select_based_on_unit_circle()`. The caller will infer the intersection of \"\n-\"these two lifetimes as the lifetime of the returned value, and hence the \"\n-\"return value of `select()` will be assigned a lifetime of B. This will in \"\n-\"turn lead to a compilation error, because `select_based_on_unit_circle()` is \"\n-\"supposed to return a value with the lifetime `r`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:622\n-msgid \"\"\n-\"To address this, we can modify the definition of `select()` to distinguish \"\n-\"the lifetime of the first parameter from the lifetime of the latter two. \"\n-\"After all, the first parameter is not being returned. Here is how the new \"\n-\"`select()` might look:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:636\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct Point {x: float, y: float}; // as before\\n\"\n-\"# struct Size {w: float, h: float}; // as before\\n\"\n-\"# enum Shape {\\n\"\n-\"#     Circle(Point, float),   // origin, radius\\n\"\n-\"#     Rectangle(Point, Size)  // upper-left, dimensions\\n\"\n-\"# }\\n\"\n-\"# fn compute_area(shape: &Shape) -> float { 0f }\\n\"\n-\"fn select<'r, 'tmp, T>(shape: &'tmp Shape, threshold: float,\\n\"\n-\"                       a: &'r T, b: &'r T) -> &'r T {\\n\"\n-\"    if compute_area(shape) > threshold {a} else {b}\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:641\n-msgid \"\"\n-\"Here you can see that `shape`'s lifetime is now named `tmp`. The parameters \"\n-\"`a`, `b`, and the return value all have the lifetime `r`.  However, since \"\n-\"the lifetime `tmp` is not returned, it would be more concise to just omit \"\n-\"the named lifetime for `shape` altogether:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:655\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"# struct Point {x: float, y: float}; // as before\\n\"\n-\"# struct Size {w: float, h: float}; // as before\\n\"\n-\"# enum Shape {\\n\"\n-\"#     Circle(Point, float),   // origin, radius\\n\"\n-\"#     Rectangle(Point, Size)  // upper-left, dimensions\\n\"\n-\"# }\\n\"\n-\"# fn compute_area(shape: &Shape) -> float { 0f }\\n\"\n-\"fn select<'r, T>(shape: &Shape, threshold: float,\\n\"\n-\"                 a: &'r T, b: &'r T) -> &'r T {\\n\"\n-\"    if compute_area(shape) > threshold {a} else {b}\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:657\n-msgid \"This is equivalent to the previous definition.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:659\n-msgid \"# Conclusion\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-borrowed-ptr.md:663\n-msgid \"\"\n-\"So there you have it: a (relatively) brief tour of the borrowed pointer \"\n-\"system. For more details, we refer to the (yet to be written) reference \"\n-\"document on borrowed pointers, which will explain the full notation and give \"\n-\"more examples.\"\n-msgstr \"\""}, {"sha": "02513417844f784825f925c615247edd6edfe8b6", "filename": "doc/po/ja/tutorial-container.md.po", "status": "removed", "additions": 0, "deletions": 673, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fpo%2Fja%2Ftutorial-container.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fpo%2Fja%2Ftutorial-container.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial-container.md.po?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -1,673 +0,0 @@\n-# Japanese translations for Rust package\n-# Copyright (C) 2013 The Rust Project Developers\n-# This file is distributed under the same license as the Rust package.\n-# Automatically generated, 2013.\n-#\n-msgid \"\"\n-msgstr \"\"\n-\"Project-Id-Version: Rust 0.8\\n\"\n-\"POT-Creation-Date: 2013-08-05 19:40+0900\\n\"\n-\"PO-Revision-Date: 2013-07-28 20:32+0900\\n\"\n-\"Last-Translator: Automatically generated\\n\"\n-\"Language-Team: none\\n\"\n-\"Language: ja\\n\"\n-\"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=UTF-8\\n\"\n-\"Content-Transfer-Encoding: 8bit\\n\"\n-\"Plural-Forms: nplurals=1; plural=0;\\n\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:2\n-msgid \"% Containers and iterators\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:4\n-msgid \"# Containers\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:6\n-msgid \"The container traits are defined in the `std::container` module.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:8\n-msgid \"## Unique and managed vectors\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:12\n-msgid \"\"\n-\"Vectors have `O(1)` indexing and removal from the end, along with `O(1)` \"\n-\"amortized insertion. Vectors are the most common container in Rust, and are \"\n-\"flexible enough to fit many use cases.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:16\n-msgid \"\"\n-\"Vectors can also be sorted and used as efficient lookup tables with the \"\n-\"`std::vec::bsearch` function, if all the elements are inserted at one time \"\n-\"and deletions are unnecessary.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:18\n-msgid \"## Maps and sets\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:22\n-msgid \"\"\n-\"Maps are collections of unique keys with corresponding values, and sets are \"\n-\"just unique keys without a corresponding value. The `Map` and `Set` traits \"\n-\"in `std::container` define the basic interface.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:24\n-msgid \"The standard library provides three owned map/set types:\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-container.md:30\n-msgid \"\"\n-\"`std::hashmap::HashMap` and `std::hashmap::HashSet`, requiring the keys to \"\n-\"implement `Eq` and `Hash`\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-container.md:30\n-msgid \"\"\n-\"`std::trie::TrieMap` and `std::trie::TrieSet`, requiring the keys to be \"\n-\"`uint`\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-container.md:30\n-msgid \"\"\n-\"`extra::treemap::TreeMap` and `extra::treemap::TreeSet`, requiring the keys \"\n-\"to implement `TotalOrd`\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:34\n-msgid \"\"\n-\"These maps do not use managed pointers so they can be sent between tasks as \"\n-\"long as the key and value types are sendable. Neither the key or value type \"\n-\"has to be copyable.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:37\n-msgid \"\"\n-\"The `TrieMap` and `TreeMap` maps are ordered, while `HashMap` uses an \"\n-\"arbitrary order.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:42\n-msgid \"\"\n-\"Each `HashMap` instance has a random 128-bit key to use with a keyed hash, \"\n-\"making the order of a set of keys in a given hash table randomized. Rust \"\n-\"provides a [SipHash](https://131002.net/siphash/) implementation for any \"\n-\"type implementing the `IterBytes` trait.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:44\n-msgid \"## Double-ended queues\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:49\n-msgid \"\"\n-\"The `extra::deque` module implements a double-ended queue with `O(1)` \"\n-\"amortized inserts and removals from both ends of the container. It also has \"\n-\"`O(1)` indexing like a vector. The contained elements are not required to be \"\n-\"copyable, and the queue will be sendable if the contained type is sendable.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:51\n-msgid \"## Priority queues\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:55\n-msgid \"\"\n-\"The `extra::priority_queue` module implements a queue ordered by a key.  The \"\n-\"contained elements are not required to be copyable, and the queue will be \"\n-\"sendable if the contained type is sendable.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:61\n-msgid \"\"\n-\"Insertions have `O(log n)` time complexity and checking or popping the \"\n-\"largest element is `O(1)`. Converting a vector to a priority queue can be \"\n-\"done in-place, and has `O(n)` complexity. A priority queue can also be \"\n-\"converted to a sorted vector in-place, allowing it to be used for an `O(n \"\n-\"log n)` in-place heapsort.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:63\n-msgid \"# Iterators\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:65\n-msgid \"## Iteration protocol\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:69\n-msgid \"\"\n-\"The iteration protocol is defined by the `Iterator` trait in the `std::\"\n-\"iterator` module. The minimal implementation of the trait is a `next` \"\n-\"method, yielding the next element from an iterator object:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:73\n-msgid \"~~~ /// An infinite stream of zeroes struct ZeroStream;\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:80\n-#, no-wrap\n-msgid \"\"\n-\"impl Iterator<int> for ZeroStream {\\n\"\n-\"    fn next(&mut self) -> Option<int> {\\n\"\n-\"        Some(0)\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:83\n-msgid \"\"\n-\"Reaching the end of the iterator is signalled by returning `None` instead of \"\n-\"`Some(item)`:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:89 doc/tutorial-container.md:262\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"/// A stream of N zeroes\\n\"\n-\"struct ZeroStream {\\n\"\n-\"    priv remaining: uint\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:95\n-#, no-wrap\n-msgid \"\"\n-\"impl ZeroStream {\\n\"\n-\"    fn new(n: uint) -> ZeroStream {\\n\"\n-\"        ZeroStream { remaining: n }\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:107 doc/tutorial-container.md:284\n-#, no-wrap\n-msgid \"\"\n-\"impl Iterator<int> for ZeroStream {\\n\"\n-\"    fn next(&mut self) -> Option<int> {\\n\"\n-\"        if self.remaining == 0 {\\n\"\n-\"            None\\n\"\n-\"        } else {\\n\"\n-\"            self.remaining -= 1;\\n\"\n-\"            Some(0)\\n\"\n-\"        }\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:109\n-msgid \"## Container iterators\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:112\n-msgid \"\"\n-\"Containers implement iteration over the contained elements by returning an \"\n-\"iterator object. For example, vector slices several iterators available:\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-container.md:116\n-msgid \"`iter()` and `rev_iter()`, for immutable references to the elements\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-container.md:116\n-msgid \"\"\n-\"`mut_iter()` and `mut_rev_iter()`, for mutable references to the elements\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-container.md:116\n-msgid \"\"\n-\"`consume_iter()` and `consume_rev_iter`, to move the elements out by-value\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:119\n-msgid \"\"\n-\"A typical mutable container will implement at least `iter()`, `mut_iter()` \"\n-\"and `consume_iter()` along with the reverse variants if it maintains an \"\n-\"order.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:121\n-msgid \"### Freezing\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:125\n-msgid \"\"\n-\"Unlike most other languages with external iterators, Rust has no *iterator \"\n-\"invalidation*. As long an iterator is still in scope, the compiler will \"\n-\"prevent modification of the container through another handle.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:130\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"let mut xs = [1, 2, 3];\\n\"\n-\"{\\n\"\n-\"    let _it = xs.iter();\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:136\n-#, no-wrap\n-msgid \"\"\n-\"    // the vector is frozen for this scope, the compiler will statically\\n\"\n-\"    // prevent modification\\n\"\n-\"}\\n\"\n-\"// the vector becomes unfrozen again at the end of the scope\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:139\n-msgid \"\"\n-\"These semantics are due to most container iterators being implemented with \"\n-\"`&` and `&mut`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:141\n-msgid \"## Iterator adaptors\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:145\n-msgid \"\"\n-\"The `IteratorUtil` trait implements common algorithms as methods extending \"\n-\"every `Iterator` implementation. For example, the `fold` method will \"\n-\"accumulate the items yielded by an `Iterator` into a single value:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:151\n-msgid \"\"\n-\"~~~ let xs = [1, 9, 2, 3, 14, 12]; let result = xs.iter().fold(0, |\"\n-\"accumulator, item| accumulator - *item); assert_eq!(result, -41); ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:153\n-msgid \"\"\n-\"Some adaptors return an adaptor object implementing the `Iterator` trait \"\n-\"itself:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:160\n-msgid \"\"\n-\"~~~ let xs = [1, 9, 2, 3, 14, 12]; let ys = [5, 2, 1, 8]; let sum = xs.\"\n-\"iter().chain_(ys.iter()).fold(0, |a, b| a + *b); assert_eq!(sum, 57); ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:164\n-msgid \"\"\n-\"Note that some adaptors like the `chain_` method above use a trailing \"\n-\"underscore to work around an issue with method resolve. The underscores will \"\n-\"be dropped when they become unnecessary.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:166\n-msgid \"## For loops\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:168\n-msgid \"\"\n-\"The `for` keyword can be used as sugar for iterating through any iterator:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:171\n-msgid \"~~~ let xs = [2, 3, 5, 7, 11, 13, 17];\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:176\n-#, no-wrap\n-msgid \"\"\n-\"// print out all the elements in the vector\\n\"\n-\"for x in xs.iter() {\\n\"\n-\"    println(x.to_str())\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:182\n-#, no-wrap\n-msgid \"\"\n-\"// print out all but the first 3 elements in the vector\\n\"\n-\"for x in xs.iter().skip(3) {\\n\"\n-\"    println(x.to_str())\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:185\n-msgid \"\"\n-\"For loops are *often* used with a temporary iterator object, as above. They \"\n-\"can also advance the state of an iterator in a mutable location:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:189\n-msgid \"\"\n-\"~~~ let xs = [1, 2, 3, 4, 5]; let ys = [\\\"foo\\\", \\\"bar\\\", \\\"baz\\\", \\\"foobar\"\n-\"\\\"];\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:192\n-msgid \"\"\n-\"// create an iterator yielding tuples of elements from both vectors let mut \"\n-\"it = xs.iter().zip(ys.iter());\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:196\n-#, no-wrap\n-msgid \"\"\n-\"// print out the pairs of elements up to (&3, &\\\"baz\\\")\\n\"\n-\"for (x, y) in it {\\n\"\n-\"    printfln!(\\\"%d %s\\\", *x, *y);\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:201\n-#, no-wrap\n-msgid \"\"\n-\"    if *x == 3 {\\n\"\n-\"        break;\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:204\n-msgid \"\"\n-\"// yield and print the last pair from the iterator printfln!(\\\"last: %?\\\", \"\n-\"it.next());\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:208\n-msgid \"// the iterator is now fully consumed assert!(it.next().is_none()); ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:210\n-msgid \"## Conversion\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:212\n-msgid \"\"\n-\"Iterators offer generic conversion to containers with the `collect` adaptor:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:218\n-msgid \"\"\n-\"~~~ let xs = [0, 1, 1, 2, 3, 5, 8]; let ys = xs.rev_iter().skip(1).\"\n-\"transform(|&x| x * 2).collect::<~[int]>(); assert_eq!(ys, ~[10, 6, 4, 2, 2, \"\n-\"0]); ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:221\n-msgid \"\"\n-\"The method requires a type hint for the container type, if the surrounding \"\n-\"code does not provide sufficient information.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:225\n-msgid \"\"\n-\"Containers can provide conversion from iterators through `collect` by \"\n-\"implementing the `FromIterator` trait. For example, the implementation for \"\n-\"vectors is as follows:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:238\n-#, no-wrap\n-msgid \"\"\n-\"~~~\\n\"\n-\"impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\\n\"\n-\"    pub fn from_iterator(iterator: &mut T) -> ~[A] {\\n\"\n-\"        let (lower, _) = iterator.size_hint();\\n\"\n-\"        let mut xs = with_capacity(lower);\\n\"\n-\"        for x in iterator {\\n\"\n-\"            xs.push(x);\\n\"\n-\"        }\\n\"\n-\"        xs\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:240\n-msgid \"### Size hints\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:243\n-msgid \"\"\n-\"The `Iterator` trait provides a `size_hint` default method, returning a \"\n-\"lower bound and optionally on upper bound on the length of the iterator:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:247\n-msgid \"~~~ fn size_hint(&self) -> (uint, Option<uint>) { (0, None) } ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:251\n-msgid \"\"\n-\"The vector implementation of `FromIterator` from above uses the lower bound \"\n-\"to pre-allocate enough space to hold the minimum number of elements the \"\n-\"iterator will yield.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:254\n-msgid \"\"\n-\"The default implementation is always correct, but it should be overridden if \"\n-\"the iterator can provide better information.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:256\n-msgid \"\"\n-\"The `ZeroStream` from earlier can provide an exact lower and upper bound:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:267\n-#, no-wrap\n-msgid \"\"\n-\"impl ZeroStream {\\n\"\n-\"    fn new(n: uint) -> ZeroStream {\\n\"\n-\"        ZeroStream { remaining: n }\\n\"\n-\"    }\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:272\n-#, no-wrap\n-msgid \"\"\n-\"    fn size_hint(&self) -> (uint, Option<uint>) {\\n\"\n-\"        (self.remaining, Some(self.remaining))\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:286\n-msgid \"## Double-ended iterators\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:290\n-msgid \"\"\n-\"The `DoubleEndedIterator` trait represents an iterator able to yield \"\n-\"elements from either end of a range. It inherits from the `Iterator` trait \"\n-\"and extends it with the `next_back` function.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:293\n-msgid \"\"\n-\"A `DoubleEndedIterator` can be flipped with the `invert` adaptor, returning \"\n-\"another `DoubleEndedIterator` with `next` and `next_back` exchanged.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:300\n-msgid \"\"\n-\"~~~ let xs = [1, 2, 3, 4, 5, 6]; let mut it = xs.iter(); printfln!(\\\"%?\\\", \"\n-\"it.next()); // prints `Some(&1)` printfln!(\\\"%?\\\", it.next()); // prints \"\n-\"`Some(&2)` printfln!(\\\"%?\\\", it.next_back()); // prints `Some(&6)`\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:306\n-#, no-wrap\n-msgid \"\"\n-\"// prints `5`, `4` and `3`\\n\"\n-\"for &x in it.invert() {\\n\"\n-\"    printfln!(\\\"%?\\\", x)\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:309\n-msgid \"\"\n-\"The `rev_iter` and `mut_rev_iter` methods on vectors just return an inverted \"\n-\"version of the standard immutable and mutable vector iterators.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:312\n-msgid \"\"\n-\"The `chain_`, `transform`, `filter`, `filter_map` and `peek` adaptors are \"\n-\"`DoubleEndedIterator` implementations if the underlying iterators are.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:317\n-msgid \"\"\n-\"~~~ let xs = [1, 2, 3, 4]; let ys = [5, 6, 7, 8]; let mut it = xs.iter().\"\n-\"chain_(ys.iter()).transform(|&x| x * 2);\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:319\n-msgid \"printfln!(\\\"%?\\\", it.next()); // prints `Some(2)`\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:325\n-#, no-wrap\n-msgid \"\"\n-\"// prints `16`, `14`, `12`, `10`, `8`, `6`, `4`\\n\"\n-\"for x in it.invert() {\\n\"\n-\"    printfln!(\\\"%?\\\", x);\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:327\n-msgid \"## Random-access iterators\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:331\n-msgid \"\"\n-\"The `RandomAccessIterator` trait represents an iterator offering random \"\n-\"access to the whole range. The `indexable` method retrieves the number of \"\n-\"elements accessible with the `idx` method.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:334\n-msgid \"\"\n-\"The `chain_` adaptor is an implementation of `RandomAccessIterator` if the \"\n-\"underlying iterators are.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:343\n-msgid \"\"\n-\"~~~ let xs = [1, 2, 3, 4, 5]; let ys = ~[7, 9, 11]; let mut it = xs.iter().\"\n-\"chain_(ys.iter()); printfln!(\\\"%?\\\", it.idx(0)); // prints `Some(&1)` \"\n-\"printfln!(\\\"%?\\\", it.idx(5)); // prints `Some(&7)` printfln!(\\\"%?\\\", it.\"\n-\"idx(7)); // prints `Some(&11)` printfln!(\\\"%?\\\", it.idx(8)); // prints `None`\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:348\n-msgid \"\"\n-\"// yield two elements from the beginning, and one from the end it.next(); it.\"\n-\"next(); it.next_back();\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-container.md:352\n-msgid \"\"\n-\"printfln!(\\\"%?\\\", it.idx(0)); // prints `Some(&3)` printfln!(\\\"%?\\\", it.\"\n-\"idx(4)); // prints `Some(&9)` printfln!(\\\"%?\\\", it.idx(6)); // prints `None` \"\n-\"~~~\"\n-msgstr \"\""}, {"sha": "088970bf00d2829c5fb6c44f173d1aeca7ac87f7", "filename": "doc/po/ja/tutorial-ffi.md.po", "status": "removed", "additions": 0, "deletions": 602, "changes": 602, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -1,602 +0,0 @@\n-# Japanese translations for Rust package\n-# Copyright (C) 2013 The Rust Project Developers\n-# This file is distributed under the same license as the Rust package.\n-# Automatically generated, 2013.\n-#\n-msgid \"\"\n-msgstr \"\"\n-\"Project-Id-Version: Rust 0.8\\n\"\n-\"POT-Creation-Date: 2013-08-10 07:44+0900\\n\"\n-\"PO-Revision-Date: 2013-07-22 23:37+0900\\n\"\n-\"Last-Translator: Automatically generated\\n\"\n-\"Language-Team: none\\n\"\n-\"Language: ja\\n\"\n-\"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=UTF-8\\n\"\n-\"Content-Transfer-Encoding: 8bit\\n\"\n-\"Plural-Forms: nplurals=1; plural=0;\\n\"\n-\n-#. type: Plain text\n-#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n-#: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n-msgid \"# Introduction\"\n-msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n-\n-#. type: Plain text\n-#: doc/tutorial.md:868 doc/tutorial-ffi.md:143\n-msgid \"# Destructors\"\n-msgstr \"# \u30c7\u30b9\u30c8\u30e9\u30af\u30bf\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:2\n-msgid \"% Rust Foreign Function Interface Tutorial\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:10\n-msgid \"\"\n-\"This tutorial will use the [snappy](https://code.google.com/p/snappy/)  \"\n-\"compression/decompression library as an introduction to writing bindings for \"\n-\"foreign code. Rust is currently unable to call directly into a C++ library, \"\n-\"but snappy includes a C interface (documented in [`snappy-c.h`](https://code.\"\n-\"google.com/p/snappy/source/browse/trunk/snappy-c.h)).\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:13\n-msgid \"\"\n-\"The following is a minimal example of calling a foreign function which will \"\n-\"compile if snappy is installed:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:16\n-msgid \"~~~~ {.xfail-test} use std::libc::size_t;\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:21\n-#, no-wrap\n-msgid \"\"\n-\"#[link_args = \\\"-lsnappy\\\"]\\n\"\n-\"extern {\\n\"\n-\"    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:27\n-#, no-wrap\n-msgid \"\"\n-\"fn main() {\\n\"\n-\"    let x = unsafe { snappy_max_compressed_length(100) };\\n\"\n-\"    println(fmt!(\\\"max compressed length of a 100 byte buffer: %?\\\", x));\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:31\n-msgid \"\"\n-\"The `extern` block is a list of function signatures in a foreign library, in \"\n-\"this case with the platform's C ABI. The `#[link_args]` attribute is used to \"\n-\"instruct the linker to link against the snappy library so the symbols are \"\n-\"resolved.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:37\n-msgid \"\"\n-\"Foreign functions are assumed to be unsafe so calls to them need to be \"\n-\"wrapped with `unsafe {}` as a promise to the compiler that everything \"\n-\"contained within truly is safe. C libraries often expose interfaces that \"\n-\"aren't thread-safe, and almost any function that takes a pointer argument \"\n-\"isn't valid for all possible inputs since the pointer could be dangling, and \"\n-\"raw pointers fall outside of Rust's safe memory model.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:41\n-msgid \"\"\n-\"When declaring the argument types to a foreign function, the Rust compiler \"\n-\"will not check if the declaration is correct, so specifying it correctly is \"\n-\"part of keeping the binding correct at runtime.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:43\n-msgid \"The `extern` block can be extended to cover the entire snappy API:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:46\n-msgid \"~~~~ {.xfail-test} use std::libc::{c_int, size_t};\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:65\n-#, no-wrap\n-msgid \"\"\n-\"#[link_args = \\\"-lsnappy\\\"]\\n\"\n-\"extern {\\n\"\n-\"    fn snappy_compress(input: *u8,\\n\"\n-\"                       input_length: size_t,\\n\"\n-\"                       compressed: *mut u8,\\n\"\n-\"                       compressed_length: *mut size_t) -> c_int;\\n\"\n-\"    fn snappy_uncompress(compressed: *u8,\\n\"\n-\"                         compressed_length: size_t,\\n\"\n-\"                         uncompressed: *mut u8,\\n\"\n-\"                         uncompressed_length: *mut size_t) -> c_int;\\n\"\n-\"    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\\n\"\n-\"    fn snappy_uncompressed_length(compressed: *u8,\\n\"\n-\"                                  compressed_length: size_t,\\n\"\n-\"                                  result: *mut size_t) -> c_int;\\n\"\n-\"    fn snappy_validate_compressed_buffer(compressed: *u8,\\n\"\n-\"                                         compressed_length: size_t) -> c_int;\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:67\n-msgid \"# Creating a safe interface\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:71\n-msgid \"\"\n-\"The raw C API needs to be wrapped to provide memory safety and make use of \"\n-\"higher-level concepts like vectors. A library can choose to expose only the \"\n-\"safe, high-level interface and hide the unsafe internal details.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:76\n-msgid \"\"\n-\"Wrapping the functions which expect buffers involves using the `vec::raw` \"\n-\"module to manipulate Rust vectors as pointers to memory. Rust's vectors are \"\n-\"guaranteed to be a contiguous block of memory. The length is number of \"\n-\"elements currently contained, and the capacity is the total size in elements \"\n-\"of the allocated memory. The length is less than or equal to the capacity.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:84\n-#, no-wrap\n-msgid \"\"\n-\"~~~~ {.xfail-test}\\n\"\n-\"pub fn validate_compressed_buffer(src: &[u8]) -> bool {\\n\"\n-\"    unsafe {\\n\"\n-\"        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:88\n-msgid \"\"\n-\"The `validate_compressed_buffer` wrapper above makes use of an `unsafe` \"\n-\"block, but it makes the guarantee that calling it is safe for all inputs by \"\n-\"leaving off `unsafe` from the function signature.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:91\n-msgid \"\"\n-\"The `snappy_compress` and `snappy_uncompress` functions are more complex, \"\n-\"since a buffer has to be allocated to hold the output too.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:96\n-msgid \"\"\n-\"The `snappy_max_compressed_length` function can be used to allocate a vector \"\n-\"with the maximum required capacity to hold the compressed output. The vector \"\n-\"can then be passed to the `snappy_compress` function as an output parameter. \"\n-\"An output parameter is also passed to retrieve the true length after \"\n-\"compression for setting the length.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:102\n-#, no-wrap\n-msgid \"\"\n-\"~~~~ {.xfail-test}\\n\"\n-\"pub fn compress(src: &[u8]) -> ~[u8] {\\n\"\n-\"    unsafe {\\n\"\n-\"        let srclen = src.len() as size_t;\\n\"\n-\"        let psrc = src.as_ptr();\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:106\n-#, no-wrap\n-msgid \"\"\n-\"        let mut dstlen = snappy_max_compressed_length(srclen);\\n\"\n-\"        let mut dst = vec::with_capacity(dstlen as uint);\\n\"\n-\"        let pdst = dst.as_mut_ptr();\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:113\n-#, no-wrap\n-msgid \"\"\n-\"        snappy_compress(psrc, srclen, pdst, &mut dstlen);\\n\"\n-\"        dst.set_len(dstlen as uint);\\n\"\n-\"        dst\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:116\n-msgid \"\"\n-\"Decompression is similar, because snappy stores the uncompressed size as \"\n-\"part of the compression format and `snappy_uncompressed_length` will \"\n-\"retrieve the exact buffer size required.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:122\n-#, no-wrap\n-msgid \"\"\n-\"~~~~ {.xfail-test}\\n\"\n-\"pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\\n\"\n-\"    unsafe {\\n\"\n-\"        let srclen = src.len() as size_t;\\n\"\n-\"        let psrc = src.as_ptr();\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:125\n-#, no-wrap\n-msgid \"\"\n-\"        let mut dstlen: size_t = 0;\\n\"\n-\"        snappy_uncompressed_length(psrc, srclen, &mut dstlen);\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:128\n-#, no-wrap\n-msgid \"\"\n-\"        let mut dst = vec::with_capacity(dstlen as uint);\\n\"\n-\"        let pdst = dst.as_mut_ptr();\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:138\n-#, no-wrap\n-msgid \"\"\n-\"        if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\\n\"\n-\"            dst.set_len(dstlen as uint);\\n\"\n-\"            Some(dst)\\n\"\n-\"        } else {\\n\"\n-\"            None // SNAPPY_INVALID_INPUT\\n\"\n-\"        }\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:141\n-msgid \"\"\n-\"For reference, the examples used here are also available as an [library on \"\n-\"GitHub](https://github.com/thestinger/rust-snappy).\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:147\n-msgid \"\"\n-\"Foreign libraries often hand off ownership of resources to the calling code, \"\n-\"which should be wrapped in a destructor to provide safety and guarantee \"\n-\"their release.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:150\n-msgid \"\"\n-\"A type with the same functionality as owned boxes can be implemented by \"\n-\"wrapping `malloc` and `free`:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:156\n-msgid \"\"\n-\"~~~~ use std::cast; use std::libc::{c_void, size_t, malloc, free}; use std::\"\n-\"ptr; use std::unstable::intrinsics;\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:161\n-#, no-wrap\n-msgid \"\"\n-\"// a wrapper around the handle returned by the foreign code\\n\"\n-\"pub struct Unique<T> {\\n\"\n-\"    priv ptr: *mut T\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:172\n-#, no-wrap\n-msgid \"\"\n-\"impl<T: Send> Unique<T> {\\n\"\n-\"    pub fn new(value: T) -> Unique<T> {\\n\"\n-\"        unsafe {\\n\"\n-\"            let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\\n\"\n-\"            assert!(!ptr::is_null(ptr));\\n\"\n-\"            // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\\n\"\n-\"            intrinsics::move_val_init(&mut *ptr, value);\\n\"\n-\"            Unique{ptr: ptr}\\n\"\n-\"        }\\n\"\n-\"    }\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:177\n-#, no-wrap\n-msgid \"\"\n-\"    // the 'r lifetime results in the same semantics as `&*x` with ~T\\n\"\n-\"    pub fn borrow<'r>(&'r self) -> &'r T {\\n\"\n-\"        unsafe { cast::copy_lifetime(self, &*self.ptr) }\\n\"\n-\"    }\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:183\n-#, no-wrap\n-msgid \"\"\n-\"    // the 'r lifetime results in the same semantics as `&mut *x` with ~T\\n\"\n-\"    pub fn borrow_mut<'r>(&'r mut self) -> &'r mut T {\\n\"\n-\"        unsafe { cast::copy_mut_lifetime(self, &mut *self.ptr) }\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:195\n-#, no-wrap\n-msgid \"\"\n-\"#[unsafe_destructor]\\n\"\n-\"impl<T: Send> Drop for Unique<T> {\\n\"\n-\"    fn drop(&self) {\\n\"\n-\"        unsafe {\\n\"\n-\"            let x = intrinsics::init(); // dummy value to swap in\\n\"\n-\"            // moving the object out is needed to call the destructor\\n\"\n-\"            ptr::replace_ptr(self.ptr, x);\\n\"\n-\"            free(self.ptr as *c_void)\\n\"\n-\"        }\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:202\n-#, no-wrap\n-msgid \"\"\n-\"// A comparison between the built-in ~ and this reimplementation\\n\"\n-\"fn main() {\\n\"\n-\"    {\\n\"\n-\"        let mut x = ~5;\\n\"\n-\"        *x = 10;\\n\"\n-\"    } // `x` is freed here\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:209\n-#, no-wrap\n-msgid \"\"\n-\"    {\\n\"\n-\"        let mut y = Unique::new(5);\\n\"\n-\"        *y.borrow_mut() = 10;\\n\"\n-\"    } // `y` is freed here\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:211\n-msgid \"# Linking\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:215\n-msgid \"\"\n-\"In addition to the `#[link_args]` attribute for explicitly passing arguments \"\n-\"to the linker, an `extern mod` block will pass `-lmodname` to the linker by \"\n-\"default unless it has a `#[nolink]` attribute applied.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:217\n-msgid \"# Unsafe blocks\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:221\n-msgid \"\"\n-\"Some operations, like dereferencing unsafe pointers or calling functions \"\n-\"that have been marked unsafe are only allowed inside unsafe blocks. Unsafe \"\n-\"blocks isolate unsafety and are a promise to the compiler that the unsafety \"\n-\"does not leak out of the block.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:224\n-msgid \"\"\n-\"Unsafe functions, on the other hand, advertise it to the world. An unsafe \"\n-\"function is written like this:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:228\n-msgid \"~~~~ unsafe fn kaboom(ptr: *int) -> int { *ptr } ~~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:230\n-msgid \"\"\n-\"This function can only be called from an `unsafe` block or another `unsafe` \"\n-\"function.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:232\n-msgid \"# Accessing foreign globals\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:236\n-msgid \"\"\n-\"Foreign APIs often export a global variable which could do something like \"\n-\"track global state. In order to access these variables, you declare them in \"\n-\"`extern` blocks with the `static` keyword:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:239\n-msgid \"~~~{.xfail-test} use std::libc;\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:244\n-#, no-wrap\n-msgid \"\"\n-\"#[link_args = \\\"-lreadline\\\"]\\n\"\n-\"extern {\\n\"\n-\"    static rl_readline_version: libc::c_int;\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:250\n-#, no-wrap\n-msgid \"\"\n-\"fn main() {\\n\"\n-\"    println(fmt!(\\\"You have readline version %d installed.\\\",\\n\"\n-\"                 rl_readline_version as int));\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:254\n-msgid \"\"\n-\"Alternatively, you may need to alter global state provided by a foreign \"\n-\"interface. To do this, statics can be declared with `mut` so rust can mutate \"\n-\"them.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:258\n-msgid \"~~~{.xfail-test} use std::libc; use std::ptr;\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:263\n-#, no-wrap\n-msgid \"\"\n-\"#[link_args = \\\"-lreadline\\\"]\\n\"\n-\"extern {\\n\"\n-\"    static mut rl_prompt: *libc::c_char;\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:272\n-#, no-wrap\n-msgid \"\"\n-\"fn main() {\\n\"\n-\"    do \\\"[my-awesome-shell] $\\\".as_c_str |buf| {\\n\"\n-\"        unsafe { rl_prompt = buf; }\\n\"\n-\"        // get a line, process it\\n\"\n-\"        unsafe { rl_prompt = ptr::null(); }\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:274\n-msgid \"# Foreign calling conventions\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:279\n-msgid \"\"\n-\"Most foreign code exposes a C ABI, and Rust uses the platform's C calling \"\n-\"convention by default when calling foreign functions. Some foreign \"\n-\"functions, most notably the Windows API, use other calling conventions. Rust \"\n-\"provides the `abi` attribute as a way to hint to the compiler which calling \"\n-\"convention to use:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:288\n-#, no-wrap\n-msgid \"\"\n-\"~~~~\\n\"\n-\"#[cfg(target_os = \\\"win32\\\")]\\n\"\n-\"#[abi = \\\"stdcall\\\"]\\n\"\n-\"#[link_name = \\\"kernel32\\\"]\\n\"\n-\"extern {\\n\"\n-\"    fn SetEnvironmentVariableA(n: *u8, v: *u8) -> int;\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:292\n-msgid \"\"\n-\"The `abi` attribute applies to a foreign module (it cannot be applied to a \"\n-\"single function within a module), and must be either `\\\"cdecl\\\"` or `\"\n-\"\\\"stdcall\\\"`. The compiler may eventually support other calling conventions.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:294\n-msgid \"# Interoperability with foreign code\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:298\n-msgid \"\"\n-\"Rust guarantees that the layout of a `struct` is compatible with the \"\n-\"platform's representation in C.  A `#[packed]` attribute is available, which \"\n-\"will lay out the struct members without padding.  However, there are \"\n-\"currently no guarantees about the layout of an `enum`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:305\n-msgid \"\"\n-\"Rust's owned and managed boxes use non-nullable pointers as handles which \"\n-\"point to the contained object. However, they should not be manually created \"\n-\"because they are managed by internal allocators. Borrowed pointers can \"\n-\"safely be assumed to be non-nullable pointers directly to the type. However, \"\n-\"breaking the borrow checking or mutability rules is not guaranteed to be \"\n-\"safe, so prefer using raw pointers (`*`) if that's needed because the \"\n-\"compiler can't make as many assumptions about them.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:310\n-msgid \"\"\n-\"Vectors and strings share the same basic memory layout, and utilities are \"\n-\"available in the `vec` and `str` modules for working with C APIs. Strings \"\n-\"are terminated with `\\\\0` for interoperability with C, but it should not be \"\n-\"assumed because a slice will not always be nul-terminated. Instead, the \"\n-\"`str::as_c_str` function should be used.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-ffi.md:312\n-msgid \"\"\n-\"The standard library includes type aliases and function definitions for the \"\n-\"C standard library in the `libc` module, and Rust links against `libc` and \"\n-\"`libm` by default.\"\n-msgstr \"\""}, {"sha": "a7704bc94c1d2a111d3915384d9349c08d12761a", "filename": "doc/po/ja/tutorial-macros.md.po", "status": "removed", "additions": 0, "deletions": 683, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fpo%2Fja%2Ftutorial-macros.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fpo%2Fja%2Ftutorial-macros.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial-macros.md.po?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -1,683 +0,0 @@\n-# Japanese translations for Rust package\n-# Copyright (C) 2013 The Rust Project Developers\n-# This file is distributed under the same license as the Rust package.\n-# Automatically generated, 2013.\n-#\n-msgid \"\"\n-msgstr \"\"\n-\"Project-Id-Version: Rust 0.8\\n\"\n-\"POT-Creation-Date: 2013-07-28 20:32+0900\\n\"\n-\"PO-Revision-Date: 2013-07-28 20:32+0900\\n\"\n-\"Last-Translator: Automatically generated\\n\"\n-\"Language-Team: none\\n\"\n-\"Language: ja\\n\"\n-\"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=UTF-8\\n\"\n-\"Content-Transfer-Encoding: 8bit\\n\"\n-\"Plural-Forms: nplurals=1; plural=0;\\n\"\n-\n-#. type: Plain text\n-#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n-#: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n-msgid \"# Introduction\"\n-msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n-\n-#. type: Plain text\n-#: doc/rust.md:2136 doc/rust.md:2223 doc/tutorial-macros.md:323\n-msgid \"~~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:2\n-msgid \"% Rust Macros Tutorial\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:12\n-msgid \"\"\n-\"Functions are the primary tool that programmers can use to build \"\n-\"abstractions.  Sometimes, however, programmers want to abstract over compile-\"\n-\"time syntax rather than run-time values.  Macros provide syntactic \"\n-\"abstraction.  For an example of how this can be useful, consider the \"\n-\"following two code fragments, which both pattern-match on their input and \"\n-\"both return early in one case, doing nothing otherwise:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:30\n-#, no-wrap\n-msgid \"\"\n-\"~~~~\\n\"\n-\"# enum t { special_a(uint), special_b(uint) };\\n\"\n-\"# fn f() -> uint {\\n\"\n-\"# let input_1 = special_a(0);\\n\"\n-\"# let input_2 = special_a(0);\\n\"\n-\"match input_1 {\\n\"\n-\"    special_a(x) => { return x; }\\n\"\n-\"    _ => {}\\n\"\n-\"}\\n\"\n-\"// ...\\n\"\n-\"match input_2 {\\n\"\n-\"    special_b(x) => { return x; }\\n\"\n-\"    _ => {}\\n\"\n-\"}\\n\"\n-\"# return 0u;\\n\"\n-\"# }\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:38\n-msgid \"\"\n-\"This code could become tiresome if repeated many times.  However, no \"\n-\"function can capture its functionality to make it possible to abstract the \"\n-\"repetition away.  Rust's macro system, however, can eliminate the \"\n-\"repetition. Macros are lightweight custom syntax extensions, themselves \"\n-\"defined using the `macro_rules!` syntax extension. The following \"\n-\"`early_return` macro captures the pattern in the above code:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:59\n-#, no-wrap\n-msgid \"\"\n-\"~~~~\\n\"\n-\"# enum t { special_a(uint), special_b(uint) };\\n\"\n-\"# fn f() -> uint {\\n\"\n-\"# let input_1 = special_a(0);\\n\"\n-\"# let input_2 = special_a(0);\\n\"\n-\"macro_rules! early_return(\\n\"\n-\"    ($inp:expr $sp:ident) => ( // invoke it like `(input_5 special_e)`\\n\"\n-\"        match $inp {\\n\"\n-\"            $sp(x) => { return x; }\\n\"\n-\"            _ => {}\\n\"\n-\"        }\\n\"\n-\"    );\\n\"\n-\")\\n\"\n-\"// ...\\n\"\n-\"early_return!(input_1 special_a);\\n\"\n-\"// ...\\n\"\n-\"early_return!(input_2 special_b);\\n\"\n-\"# return 0;\\n\"\n-\"# }\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:65\n-msgid \"\"\n-\"Macros are defined in pattern-matching style: in the above example, the text \"\n-\"`($inp:expr $sp:ident)` that appears on the left-hand side of the `=>` is \"\n-\"the *macro invocation syntax*, a pattern denoting how to write a call to the \"\n-\"macro. The text on the right-hand side of the `=>`, beginning with `match \"\n-\"$inp`, is the *macro transcription syntax*: what the macro expands to.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:67\n-msgid \"# Invocation syntax\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:71\n-msgid \"\"\n-\"The macro invocation syntax specifies the syntax for the arguments to the \"\n-\"macro. It appears on the left-hand side of the `=>` in a macro definition. \"\n-\"It conforms to the following rules:\"\n-msgstr \"\"\n-\n-#. type: Bullet: '1. '\n-#: doc/tutorial-macros.md:76\n-msgid \"It must be surrounded by parentheses.\"\n-msgstr \"\"\n-\n-#. type: Bullet: '2. '\n-#: doc/tutorial-macros.md:76\n-msgid \"`$` has special meaning (described below).\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:76\n-#, no-wrap\n-msgid \"\"\n-\"3. The `()`s, `[]`s, and `{}`s it contains must balance. For example, `([)` is\\n\"\n-\"forbidden.\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:78\n-msgid \"Otherwise, the invocation syntax is free-form.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:83\n-#, no-wrap\n-msgid \"\"\n-\"To take as an argument a fragment of Rust code, write `$` followed by a name\\n\"\n-\" (for use on the right-hand side), followed by a `:`, followed by a *fragment\\n\"\n-\" specifier*. The fragment specifier denotes the sort of fragment to match. The\\n\"\n-\" most common fragment specifiers are:\\n\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-macros.md:92\n-msgid \"\"\n-\"`ident` (an identifier, referring to a variable or item. Examples: `f`, `x`, \"\n-\"`foo`.)\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-macros.md:92\n-msgid \"\"\n-\"`expr` (an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`; \"\n-\"`f(42)`.)\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-macros.md:92\n-msgid \"`ty` (a type. Examples: `int`, `~[(char, ~str)]`, `&T`.)\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-macros.md:92\n-msgid \"\"\n-\"`pat` (a pattern, usually appearing in a `match` or on the left-hand side of \"\n-\"a declaration. Examples: `Some(t)`; `(17, 'a')`; `_`.)\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-macros.md:92\n-msgid \"\"\n-\"`block` (a sequence of actions. Example: `{ log(error, \\\"hi\\\"); return 12; }\"\n-\"`)\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:95\n-msgid \"\"\n-\"The parser interprets any token that's not preceded by a `$` literally. \"\n-\"Rust's usual rules of tokenization apply,\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:98\n-msgid \"\"\n-\"So `($x:ident -> (($e:expr)))`, though excessively fancy, would designate a \"\n-\"macro that could be invoked like: `my_macro!(i->(( 2+2 )))`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:100\n-msgid \"## Invocation location\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:105\n-msgid \"\"\n-\"A macro invocation may take the place of (and therefore expand to)  an \"\n-\"expression, an item, or a statement.  The Rust parser will parse the macro \"\n-\"invocation as a \\\"placeholder\\\" for whichever of those three nonterminals is \"\n-\"appropriate for the location.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:112\n-msgid \"\"\n-\"At expansion time, the output of the macro will be parsed as whichever of \"\n-\"the three nonterminals it stands in for. This means that a single macro \"\n-\"might, for example, expand to an item or an expression, depending on its \"\n-\"arguments (and cause a syntax error if it is called with the wrong argument \"\n-\"for its location). Although this behavior sounds excessively dynamic, it is \"\n-\"known to be useful under some circumstances.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:115\n-msgid \"# Transcription syntax\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:119\n-msgid \"\"\n-\"The right-hand side of the `=>` follows the same rules as the left-hand \"\n-\"side, except that a `$` need only be followed by the name of the syntactic \"\n-\"fragment to transcribe into the macro expansion; its type need not be \"\n-\"repeated.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:126\n-msgid \"\"\n-\"The right-hand side must be enclosed by delimiters, which the transcriber \"\n-\"ignores.  Therefore `() => ((1,2,3))` is a macro that expands to a tuple \"\n-\"expression, `() => (let $x=$val)` is a macro that expands to a statement, \"\n-\"and `() => (1,2,3)` is a macro that expands to a syntax error (since the \"\n-\"transcriber interprets the parentheses on the right-hand-size as delimiters, \"\n-\"and `1,2,3` is not a valid Rust expression on its own).\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:133\n-msgid \"\"\n-\"Except for permissibility of `$name` (and `$(...)*`, discussed below), the \"\n-\"right-hand side of a macro definition is ordinary Rust syntax. In \"\n-\"particular, macro invocations (including invocations of the macro currently \"\n-\"being defined)  are permitted in expression, statement, and item locations. \"\n-\"However, nothing else about the code is examined or executed by the macro \"\n-\"system; execution still has to wait until run-time.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:135\n-msgid \"## Interpolation location\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:139\n-msgid \"\"\n-\"The interpolation `$argument_name` may appear in any location consistent \"\n-\"with its fragment specifier (i.e., if it is specified as `ident`, it may be \"\n-\"used anywhere an identifier is permitted).\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:141\n-msgid \"# Multiplicity\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:143\n-msgid \"## Invocation\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:150\n-msgid \"\"\n-\"Going back to the motivating example, recall that `early_return` expanded \"\n-\"into a `match` that would `return` if the `match`'s scrutinee matched the \"\n-\"\\\"special case\\\" identifier provided as the second argument to \"\n-\"`early_return`, and do nothing otherwise. Now suppose that we wanted to \"\n-\"write a version of `early_return` that could handle a variable number of \"\n-\"\\\"special\\\" cases.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:156\n-msgid \"\"\n-\"The syntax `$(...)*` on the left-hand side of the `=>` in a macro definition \"\n-\"accepts zero or more occurrences of its contents. It works much like the `*` \"\n-\"operator in regular expressions. It also supports a separator token (a comma-\"\n-\"separated list could be written `$(...),*`), and `+` instead of `*` to mean \"\n-\"\\\"at least one\\\".\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:179\n-#, no-wrap\n-msgid \"\"\n-\"~~~~\\n\"\n-\"# enum t { special_a(uint),special_b(uint),special_c(uint),special_d(uint)};\\n\"\n-\"# fn f() -> uint {\\n\"\n-\"# let input_1 = special_a(0);\\n\"\n-\"# let input_2 = special_a(0);\\n\"\n-\"macro_rules! early_return(\\n\"\n-\"    ($inp:expr, [ $($sp:ident)|+ ]) => (\\n\"\n-\"        match $inp {\\n\"\n-\"            $(\\n\"\n-\"                $sp(x) => { return x; }\\n\"\n-\"            )+\\n\"\n-\"            _ => {}\\n\"\n-\"        }\\n\"\n-\"    );\\n\"\n-\")\\n\"\n-\"// ...\\n\"\n-\"early_return!(input_1, [special_a|special_c|special_d]);\\n\"\n-\"// ...\\n\"\n-\"early_return!(input_2, [special_b]);\\n\"\n-\"# return 0;\\n\"\n-\"# }\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:181\n-msgid \"### Transcription\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:191\n-msgid \"\"\n-\"As the above example demonstrates, `$(...)*` is also valid on the right-hand \"\n-\"side of a macro definition. The behavior of `*` in transcription, especially \"\n-\"in cases where multiple `*`s are nested, and multiple different names are \"\n-\"involved, can seem somewhat magical and intuitive at first. The system that \"\n-\"interprets them is called \\\"Macro By Example\\\". The two rules to keep in \"\n-\"mind are (1) the behavior of `$(...)*` is to walk through one \\\"layer\\\" of \"\n-\"repetitions for all of the `$name`s it contains in lockstep, and (2) each `\"\n-\"$name` must be under at least as many `$(...)*`s as it was matched against.  \"\n-\"If it is under more, it'll be repeated, as appropriate.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:193\n-msgid \"## Parsing limitations\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:197\n-msgid \"\"\n-\"For technical reasons, there are two limitations to the treatment of syntax \"\n-\"fragments by the macro parser:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:210\n-#, no-wrap\n-msgid \"\"\n-\"1. The parser will always parse as much as possible of a Rust syntactic\\n\"\n-\"fragment. For example, if the comma were omitted from the syntax of\\n\"\n-\"`early_return!` above, `input_1 [` would've been interpreted as the beginning\\n\"\n-\"of an array index. In fact, invoking the macro would have been impossible.\\n\"\n-\"2. The parser must have eliminated all ambiguity by the time it reaches a\\n\"\n-\"`$name:fragment_specifier` declaration. This limitation can result in parse\\n\"\n-\"errors when declarations occur at the beginning of, or immediately after,\\n\"\n-\"a `$(...)*`. For example, the grammar `$($t:ty)* $e:expr` will always fail to\\n\"\n-\"parse because the parser would be forced to choose between parsing `t` and\\n\"\n-\"parsing `e`. Changing the invocation syntax to require a distinctive token in\\n\"\n-\"front can solve the problem. In the above example, `$(T $t:ty)* E $e:exp`\\n\"\n-\"solves the problem.\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:212\n-msgid \"# Macro argument pattern matching\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:214\n-msgid \"Now consider code like the following:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:216\n-msgid \"## Motivation\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:236\n-#, no-wrap\n-msgid \"\"\n-\"~~~~\\n\"\n-\"# enum t1 { good_1(t2, uint), bad_1 };\\n\"\n-\"# pub struct t2 { body: t3 }\\n\"\n-\"# enum t3 { good_2(uint), bad_2};\\n\"\n-\"# fn f(x: t1) -> uint {\\n\"\n-\"match x {\\n\"\n-\"    good_1(g1, val) => {\\n\"\n-\"        match g1.body {\\n\"\n-\"            good_2(result) => {\\n\"\n-\"                // complicated stuff goes here\\n\"\n-\"                return result + val;\\n\"\n-\"            },\\n\"\n-\"            _ => fail!(\\\"Didn't get good_2\\\")\\n\"\n-\"        }\\n\"\n-\"    }\\n\"\n-\"    _ => return 0 // default value\\n\"\n-\"}\\n\"\n-\"# }\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:241\n-msgid \"\"\n-\"All the complicated stuff is deeply indented, and the error-handling code is \"\n-\"separated from matches that fail. We'd like to write a macro that performs a \"\n-\"match, but with a syntax that suits the problem better. The following macro \"\n-\"can solve the problem:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:263\n-#, no-wrap\n-msgid \"\"\n-\"~~~~\\n\"\n-\"macro_rules! biased_match (\\n\"\n-\"    // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\\n\"\n-\"    ( ($e:expr) ~ ($p:pat) else $err:stmt ;\\n\"\n-\"      binds $bind_res:ident\\n\"\n-\"    ) => (\\n\"\n-\"        let $bind_res = match $e {\\n\"\n-\"            $p => ( $bind_res ),\\n\"\n-\"            _ => { $err }\\n\"\n-\"        };\\n\"\n-\"    );\\n\"\n-\"    // more than one name; use a tuple\\n\"\n-\"    ( ($e:expr) ~ ($p:pat) else $err:stmt ;\\n\"\n-\"      binds $( $bind_res:ident ),*\\n\"\n-\"    ) => (\\n\"\n-\"        let ( $( $bind_res ),* ) = match $e {\\n\"\n-\"            $p => ( $( $bind_res ),* ),\\n\"\n-\"            _ => { $err }\\n\"\n-\"        };\\n\"\n-\"    )\\n\"\n-\")\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:277\n-#, no-wrap\n-msgid \"\"\n-\"# enum t1 { good_1(t2, uint), bad_1 };\\n\"\n-\"# pub struct t2 { body: t3 }\\n\"\n-\"# enum t3 { good_2(uint), bad_2};\\n\"\n-\"# fn f(x: t1) -> uint {\\n\"\n-\"biased_match!((x)       ~ (good_1(g1, val)) else { return 0 };\\n\"\n-\"              binds g1, val )\\n\"\n-\"biased_match!((g1.body) ~ (good_2(result) )\\n\"\n-\"                  else { fail!(\\\"Didn't get good_2\\\") };\\n\"\n-\"              binds result )\\n\"\n-\"// complicated stuff goes here\\n\"\n-\"return result + val;\\n\"\n-\"# }\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:288\n-#, no-wrap\n-msgid \"\"\n-\"This solves the indentation problem. But if we have a lot of chained matches\\n\"\n-\"like this, we might prefer to write a single macro invocation. The input\\n\"\n-\"pattern we want is clear:\\n\"\n-\"~~~~\\n\"\n-\"# macro_rules! b(\\n\"\n-\"    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\\n\"\n-\"      binds $( $bind_res:ident ),*\\n\"\n-\"    )\\n\"\n-\"# => (0))\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:291\n-msgid \"\"\n-\"However, it's not possible to directly expand to nested match statements. \"\n-\"But there is a solution.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:293\n-msgid \"## The recursive approach to macro writing\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:297\n-msgid \"\"\n-\"A macro may accept multiple different input grammars. The first one to \"\n-\"successfully match the actual argument to a macro invocation is the one that \"\n-\"\\\"wins\\\".\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:301\n-msgid \"\"\n-\"In the case of the example above, we want to write a recursive macro to \"\n-\"process the semicolon-terminated lines, one-by-one. So, we want the \"\n-\"following input patterns:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:308\n-#, no-wrap\n-msgid \"\"\n-\"~~~~\\n\"\n-\"# macro_rules! b(\\n\"\n-\"    ( binds $( $bind_res:ident ),* )\\n\"\n-\"# => (0))\\n\"\n-\"~~~~\\n\"\n-\"...and:\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:317\n-#, no-wrap\n-msgid \"\"\n-\"~~~~\\n\"\n-\"# macro_rules! b(\\n\"\n-\"    (    ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\\n\"\n-\"      $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\\n\"\n-\"      binds  $( $bind_res:ident ),*\\n\"\n-\"    )\\n\"\n-\"# => (0))\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:321\n-msgid \"\"\n-\"The resulting macro looks like this. Note that the separation into \"\n-\"`biased_match!` and `biased_match_rec!` occurs only because we have an outer \"\n-\"piece of syntax (the `let`) which we only want to transcribe once.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:342\n-#, no-wrap\n-msgid \"\"\n-\"macro_rules! biased_match_rec (\\n\"\n-\"    // Handle the first layer\\n\"\n-\"    (   ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\\n\"\n-\"     $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\\n\"\n-\"     binds $( $bind_res:ident ),*\\n\"\n-\"    ) => (\\n\"\n-\"        match $e {\\n\"\n-\"            $p => {\\n\"\n-\"                // Recursively handle the next layer\\n\"\n-\"                biased_match_rec!($( ($e_rest) ~ ($p_rest) else $err_rest ; )*\\n\"\n-\"                                  binds $( $bind_res ),*\\n\"\n-\"                )\\n\"\n-\"            }\\n\"\n-\"            _ => { $err }\\n\"\n-\"        }\\n\"\n-\"    );\\n\"\n-\"    ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\\n\"\n-\")\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:364\n-#, no-wrap\n-msgid \"\"\n-\"// Wrap the whole thing in a `let`.\\n\"\n-\"macro_rules! biased_match (\\n\"\n-\"    // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\\n\"\n-\"    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\\n\"\n-\"      binds $bind_res:ident\\n\"\n-\"    ) => (\\n\"\n-\"        let ( $( $bind_res ),* ) = biased_match_rec!(\\n\"\n-\"            $( ($e) ~ ($p) else $err ; )*\\n\"\n-\"            binds $bind_res\\n\"\n-\"        );\\n\"\n-\"    );\\n\"\n-\"    // more than one name: use a tuple\\n\"\n-\"    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\\n\"\n-\"      binds  $( $bind_res:ident ),*\\n\"\n-\"    ) => (\\n\"\n-\"        let ( $( $bind_res ),* ) = biased_match_rec!(\\n\"\n-\"            $( ($e) ~ ($p) else $err ; )*\\n\"\n-\"            binds $( $bind_res ),*\\n\"\n-\"        );\\n\"\n-\"    )\\n\"\n-\")\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:378\n-#, no-wrap\n-msgid \"\"\n-\"# enum t1 { good_1(t2, uint), bad_1 };\\n\"\n-\"# pub struct t2 { body: t3 }\\n\"\n-\"# enum t3 { good_2(uint), bad_2};\\n\"\n-\"# fn f(x: t1) -> uint {\\n\"\n-\"biased_match!(\\n\"\n-\"    (x)       ~ (good_1(g1, val)) else { return 0 };\\n\"\n-\"    (g1.body) ~ (good_2(result) ) else { fail!(\\\"Didn't get good_2\\\") };\\n\"\n-\"    binds val, result )\\n\"\n-\"// complicated stuff goes here\\n\"\n-\"return result + val;\\n\"\n-\"# }\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:382\n-msgid \"\"\n-\"This technique applies to many cases where transcribing a result all at once \"\n-\"is not possible.  The resulting code resembles ordinary functional \"\n-\"programming in some respects, but has some important differences from \"\n-\"functional programming.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:390\n-msgid \"\"\n-\"The first difference is important, but also easy to forget: the \"\n-\"transcription (right-hand) side of a `macro_rules!` rule is literal syntax, \"\n-\"which can only be executed at run-time. If a piece of transcription syntax \"\n-\"does not itself appear inside another macro invocation, it will become part \"\n-\"of the final program. If it is inside a macro invocation (for example, the \"\n-\"recursive invocation of `biased_match_rec!`), it does have the opportunity \"\n-\"to affect transcription, but only through the process of attempted pattern \"\n-\"matching.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:398\n-msgid \"\"\n-\"The second, related, difference is that the evaluation order of macros feels \"\n-\"\\\"backwards\\\" compared to ordinary programming. Given an invocation `m1!(m2!\"\n-\"())`, the expander first expands `m1!`, giving it as input the literal \"\n-\"syntax `m2!()`. If it transcribes its argument unchanged into an appropriate \"\n-\"position (in particular, not as an argument to yet another macro \"\n-\"invocation), the expander will then proceed to evaluate `m2!()` (along with \"\n-\"any other macro invocations `m1!(m2!())` produced).\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:400\n-msgid \"# A final note\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-macros.md:407\n-msgid \"\"\n-\"Macros, as currently implemented, are not for the faint of heart. Even \"\n-\"ordinary syntax errors can be more difficult to debug when they occur inside \"\n-\"a macro, and errors caused by parse problems in generated code can be very \"\n-\"tricky. Invoking the `log_syntax!` macro can help elucidate intermediate \"\n-\"states, invoking `trace_macros!(true)` will automatically print those \"\n-\"intermediate states out, and passing the flag `--pretty expanded` as a \"\n-\"command-line argument to the compiler will show the result of expansion.\"\n-msgstr \"\""}, {"sha": "2276d0052a643956d297b9d39653be2cb77e77ec", "filename": "doc/po/ja/tutorial-tasks.md.po", "status": "removed", "additions": 0, "deletions": 1070, "changes": 1070, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fpo%2Fja%2Ftutorial-tasks.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fpo%2Fja%2Ftutorial-tasks.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial-tasks.md.po?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -1,1070 +0,0 @@\n-# Japanese translations for Rust package\n-# Copyright (C) 2013 The Rust Project Developers\n-# This file is distributed under the same license as the Rust package.\n-# Automatically generated, 2013.\n-#\n-msgid \"\"\n-msgstr \"\"\n-\"Project-Id-Version: Rust 0.8\\n\"\n-\"POT-Creation-Date: 2013-08-08 22:27+0900\\n\"\n-\"PO-Revision-Date: 2013-07-28 20:32+0900\\n\"\n-\"Last-Translator: Automatically generated\\n\"\n-\"Language-Team: none\\n\"\n-\"Language: ja\\n\"\n-\"MIME-Version: 1.0\\n\"\n-\"Content-Type: text/plain; charset=UTF-8\\n\"\n-\"Content-Transfer-Encoding: 8bit\\n\"\n-\"Plural-Forms: nplurals=1; plural=0;\\n\"\n-\n-#. type: Plain text\n-#: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n-#: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n-msgid \"# Introduction\"\n-msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n-\n-#. type: Plain text\n-#: doc/rust.md:1952 doc/tutorial-tasks.md:648\n-msgid \"# } ~~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:2\n-msgid \"% Rust Tasks and Communication Tutorial\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:10\n-msgid \"\"\n-\"Rust provides safe concurrency through a combination of lightweight, memory-\"\n-\"isolated tasks and message passing.  This tutorial will describe the \"\n-\"concurrency model in Rust, how it relates to the Rust type system, and \"\n-\"introduce the fundamental library abstractions for constructing concurrent \"\n-\"programs.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:19\n-msgid \"\"\n-\"Rust tasks are not the same as traditional threads: rather, they are \"\n-\"considered _green threads_, lightweight units of execution that the Rust \"\n-\"runtime schedules cooperatively onto a small number of operating system \"\n-\"threads.  On a multi-core system Rust tasks will be scheduled in parallel by \"\n-\"default.  Because tasks are significantly cheaper to create than traditional \"\n-\"threads, Rust can create hundreds of thousands of concurrent tasks on a \"\n-\"typical 32-bit system.  In general, all Rust code executes inside a task, \"\n-\"including the `main` function.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:26\n-msgid \"\"\n-\"In order to make efficient use of memory Rust tasks have dynamically sized \"\n-\"stacks.  A task begins its life with a small amount of stack space \"\n-\"(currently in the low thousands of bytes, depending on platform), and \"\n-\"acquires more stack as needed.  Unlike in languages such as C, a Rust task \"\n-\"cannot accidentally write to memory beyond the end of the stack, causing \"\n-\"crashes or worse.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:32\n-msgid \"\"\n-\"Tasks provide failure isolation and recovery. When a fatal error occurs in \"\n-\"Rust code as a result of an explicit call to `fail!()`, an assertion \"\n-\"failure, or another invalid operation, the runtime system destroys the \"\n-\"entire task. Unlike in languages such as Java and C++, there is no way to \"\n-\"`catch` an exception. Instead, tasks may monitor each other for failure.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:37\n-msgid \"\"\n-\"Tasks use Rust's type system to provide strong memory safety guarantees. In \"\n-\"particular, the type system guarantees that tasks cannot share mutable state \"\n-\"with each other. Tasks communicate with each other by transferring _owned_ \"\n-\"data through the global _exchange heap_.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:39\n-msgid \"## A note about the libraries\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:44\n-msgid \"\"\n-\"While Rust's type system provides the building blocks needed for safe and \"\n-\"efficient tasks, all of the task functionality itself is implemented in the \"\n-\"standard and extra libraries, which are still under development and do not \"\n-\"always present a consistent or complete interface.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:47\n-msgid \"\"\n-\"For your reference, these are the standard modules involved in Rust \"\n-\"concurrency at this writing:\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-tasks.md:56\n-msgid \"[`std::task`] - All code relating to tasks and task scheduling,\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-tasks.md:56\n-msgid \"[`std::comm`] - The message passing interface,\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-tasks.md:56\n-msgid \"[`std::pipes`] - The underlying messaging infrastructure,\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-tasks.md:56\n-msgid \"[`extra::comm`] - Additional messaging types based on `std::pipes`,\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-tasks.md:56\n-msgid \"[`extra::sync`] - More exotic synchronization tools, including locks,\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-tasks.md:56\n-msgid \"\"\n-\"[`extra::arc`] - The Arc (atomically reference counted) type, for safely \"\n-\"sharing immutable data,\"\n-msgstr \"\"\n-\n-#. type: Bullet: '* '\n-#: doc/tutorial-tasks.md:56\n-msgid \"\"\n-\"[`extra::future`] - A type representing values that may be computed \"\n-\"concurrently and retrieved at a later time.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:64\n-msgid \"\"\n-\"[`std::task`]: std/task.html [`std::comm`]: std/comm.html [`std::pipes`]: \"\n-\"std/pipes.html [`extra::comm`]: extra/comm.html [`extra::sync`]: extra/sync.\"\n-\"html [`extra::arc`]: extra/arc.html [`extra::future`]: extra/future.html\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:66\n-msgid \"# Basics\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:72\n-msgid \"\"\n-\"The programming interface for creating and managing tasks lives in the \"\n-\"`task` module of the `std` library, and is thus available to all Rust code \"\n-\"by default. At its simplest, creating a task is a matter of calling the \"\n-\"`spawn` function with a closure argument. `spawn` executes the closure in \"\n-\"the new task.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:76\n-msgid \"~~~~ # use std::io::println; # use std::task::spawn;\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:80\n-msgid \"\"\n-\"// Print something profound in a different task using a named function fn \"\n-\"print_message() { println(\\\"I am running in a different task!\\\"); } \"\n-\"spawn(print_message);\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:83\n-msgid \"\"\n-\"// Print something more profound in a different task using a lambda \"\n-\"expression spawn( || println(\\\"I am also running in a different task!\\\") );\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:89\n-#, no-wrap\n-msgid \"\"\n-\"// The canonical way to spawn is using `do` notation\\n\"\n-\"do spawn {\\n\"\n-\"    println(\\\"I too am running in a different task!\\\");\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:95\n-msgid \"\"\n-\"In Rust, there is nothing special about creating tasks: a task is not a \"\n-\"concept that appears in the language semantics. Instead, Rust's type system \"\n-\"provides all the tools necessary to implement safe concurrency: \"\n-\"particularly, _owned types_. The language leaves the implementation details \"\n-\"to the standard library.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:102\n-msgid \"\"\n-\"The `spawn` function has a very simple type signature: `fn spawn(f: proc())`. \"\n-\"Because it accepts only owned closures, and owned closures contain only \"\n-\"owned data, `spawn` can safely move the entire closure and all its \"\n-\"associated state into an entirely different task for execution. Like any \"\n-\"closure, the function passed to `spawn` may capture an environment that it \"\n-\"carries across tasks.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:109\n-msgid \"\"\n-\"~~~ # use std::io::println; # use std::task::spawn; # fn \"\n-\"generate_task_number() -> int { 0 } // Generate some state locally let \"\n-\"child_task_number = generate_task_number();\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:115\n-#, no-wrap\n-msgid \"\"\n-\"do spawn {\\n\"\n-\"   // Capture it in the remote task\\n\"\n-\"   println(fmt!(\\\"I am child number %d\\\", child_task_number));\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:119\n-msgid \"\"\n-\"By default, the scheduler multiplexes tasks across the available cores, \"\n-\"running in parallel. Thus, on a multicore machine, running the following \"\n-\"code should interleave the output in vaguely random order.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:123\n-msgid \"~~~ # use std::io::print; # use std::task::spawn;\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:130\n-#, no-wrap\n-msgid \"\"\n-\"for child_task_number in range(0, 20) {\\n\"\n-\"    do spawn {\\n\"\n-\"       print(fmt!(\\\"I am child number %d\\\\n\\\", child_task_number));\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:132\n-msgid \"## Communication\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:137\n-msgid \"\"\n-\"Now that we have spawned a new task, it would be nice if we could \"\n-\"communicate with it. Recall that Rust does not have shared mutable state, so \"\n-\"one task may not manipulate variables owned by another task.  Instead we use \"\n-\"*pipes*.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:142\n-msgid \"\"\n-\"A pipe is simply a pair of endpoints: one for sending messages and another \"\n-\"for receiving messages. Pipes are low-level communication building-blocks \"\n-\"and so come in a variety of forms, each one appropriate for a different use \"\n-\"case. In what follows, we cover the most commonly used varieties.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:148\n-msgid \"\"\n-\"The simplest way to create a pipe is to use the `pipes::stream` function to \"\n-\"create a `(Port, Chan)` pair. In Rust parlance, a *channel* is a sending \"\n-\"endpoint of a pipe, and a *port* is the receiving endpoint. Consider the \"\n-\"following example of calculating two results concurrently:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:152\n-msgid \"~~~~ # use std::task::spawn; # use std::comm::{stream, Port, Chan};\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:154\n-msgid \"let (port, chan): (Port<int>, Chan<int>) = stream();\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:159\n-#, no-wrap\n-msgid \"\"\n-\"do spawn || {\\n\"\n-\"    let result = some_expensive_computation();\\n\"\n-\"    chan.send(result);\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:165\n-msgid \"\"\n-\"some_other_expensive_computation(); let result = port.recv(); # fn \"\n-\"some_expensive_computation() -> int { 42 } # fn \"\n-\"some_other_expensive_computation() {} ~~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:170\n-msgid \"\"\n-\"Let's examine this example in detail. First, the `let` statement creates a \"\n-\"stream for sending and receiving integers (the left-hand side of the `let`, \"\n-\"`(chan, port)`, is an example of a *destructuring let*: the pattern \"\n-\"separates a tuple into its component parts).\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:175\n-msgid \"\"\n-\"~~~~ # use std::comm::{stream, Chan, Port}; let (port, chan): (Port<int>, \"\n-\"Chan<int>) = stream(); ~~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:179\n-msgid \"\"\n-\"The child task will use the channel to send data to the parent task, which \"\n-\"will wait to receive the data on the port. The next statement spawns the \"\n-\"child task.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:190\n-#, no-wrap\n-msgid \"\"\n-\"~~~~\\n\"\n-\"# use std::task::spawn;\\n\"\n-\"# use std::comm::stream;\\n\"\n-\"# fn some_expensive_computation() -> int { 42 }\\n\"\n-\"# let (port, chan) = stream();\\n\"\n-\"do spawn || {\\n\"\n-\"    let result = some_expensive_computation();\\n\"\n-\"    chan.send(result);\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:196\n-msgid \"\"\n-\"Notice that the creation of the task closure transfers `chan` to the child \"\n-\"task implicitly: the closure captures `chan` in its environment. Both `Chan` \"\n-\"and `Port` are sendable types and may be captured into tasks or otherwise \"\n-\"transferred between them. In the example, the child task runs an expensive \"\n-\"computation, then sends the result over the captured channel.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:200\n-msgid \"\"\n-\"Finally, the parent continues with some other expensive computation, then \"\n-\"waits for the child's result to arrive on the port:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:209\n-msgid \"\"\n-\"~~~~ # use std::comm::{stream}; # fn some_other_expensive_computation() {} # \"\n-\"let (port, chan) = stream::<int>(); # chan.send(0); \"\n-\"some_other_expensive_computation(); let result = port.recv(); ~~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:215\n-msgid \"\"\n-\"The `Port` and `Chan` pair created by `stream` enables efficient \"\n-\"communication between a single sender and a single receiver, but multiple \"\n-\"senders cannot use a single `Chan`, and multiple receivers cannot use a \"\n-\"single `Port`.  What if our example needed to compute multiple results \"\n-\"across a number of tasks? The following program is ill-typed:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:221\n-msgid \"\"\n-\"~~~ {.xfail-test} # use std::task::{spawn}; # use std::comm::{stream, Port, \"\n-\"Chan}; # fn some_expensive_computation() -> int { 42 } let (port, chan) = \"\n-\"stream();\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:225\n-#, no-wrap\n-msgid \"\"\n-\"do spawn {\\n\"\n-\"    chan.send(some_expensive_computation());\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:232\n-#, no-wrap\n-msgid \"\"\n-\"// ERROR! The previous spawn statement already owns the channel,\\n\"\n-\"// so the compiler will not allow it to be captured again\\n\"\n-\"do spawn {\\n\"\n-\"    chan.send(some_expensive_computation());\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:235\n-msgid \"\"\n-\"Instead we can use a `SharedChan`, a type that allows a single `Chan` to be \"\n-\"shared by multiple senders.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:239\n-msgid \"~~~ # use std::task::spawn; # use std::comm::{stream, SharedChan};\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:242\n-msgid \"let (port, chan) = stream(); let chan = SharedChan::new(chan);\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:250\n-#, no-wrap\n-msgid \"\"\n-\"for init_val in range(0u, 3) {\\n\"\n-\"    // Create a new channel handle to distribute to the child task\\n\"\n-\"    let child_chan = chan.clone();\\n\"\n-\"    do spawn {\\n\"\n-\"        child_chan.send(some_expensive_computation(init_val));\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:254\n-msgid \"\"\n-\"let result = port.recv() + port.recv() + port.recv(); # fn \"\n-\"some_expensive_computation(_i: uint) -> int { 42 } ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:263\n-msgid \"\"\n-\"Here we transfer ownership of the channel into a new `SharedChan` value.  \"\n-\"Like `Chan`, `SharedChan` is a non-copyable, owned type (sometimes also \"\n-\"referred to as an *affine* or *linear* type). Unlike with `Chan`, though, \"\n-\"the programmer may duplicate a `SharedChan`, with the `clone()` method.  A \"\n-\"cloned `SharedChan` produces a new handle to the same channel, allowing \"\n-\"multiple tasks to send data to a single port.  Between `spawn`, `stream` and \"\n-\"`SharedChan`, we have enough tools to implement many useful concurrency \"\n-\"patterns.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:268\n-msgid \"\"\n-\"Note that the above `SharedChan` example is somewhat contrived since you \"\n-\"could also simply use three `stream` pairs, but it serves to illustrate the \"\n-\"point. For reference, written with multiple streams, it might look like the \"\n-\"example below.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:273\n-msgid \"~~~ # use std::task::spawn; # use std::comm::stream; # use std::vec;\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:282\n-#, no-wrap\n-msgid \"\"\n-\"// Create a vector of ports, one for each child task\\n\"\n-\"let ports = do vec::from_fn(3) |init_val| {\\n\"\n-\"    let (port, chan) = stream();\\n\"\n-\"    do spawn {\\n\"\n-\"        chan.send(some_expensive_computation(init_val));\\n\"\n-\"    }\\n\"\n-\"    port\\n\"\n-\"};\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:287\n-msgid \"\"\n-\"// Wait on each port, accumulating the results let result = ports.iter().\"\n-\"fold(0, |accum, port| accum + port.recv() ); # fn \"\n-\"some_expensive_computation(_i: uint) -> int { 42 } ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:291\n-msgid \"\"\n-\"## Backgrounding computations: Futures With `extra::future`, rust has a \"\n-\"mechanism for requesting a computation and getting the result later.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:299\n-#, no-wrap\n-msgid \"\"\n-\"The basic example below illustrates this.\\n\"\n-\"~~~\\n\"\n-\"# fn make_a_sandwich() {};\\n\"\n-\"fn fib(n: u64) -> u64 {\\n\"\n-\"    // lengthy computation returning an uint\\n\"\n-\"    12586269025\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:304\n-msgid \"\"\n-\"let mut delayed_fib = extra::future::spawn (|| fib(50) ); make_a_sandwich(); \"\n-\"println(fmt!(\\\"fib(50) = %?\\\", delayed_fib.get()))  ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:310\n-msgid \"\"\n-\"The call to `future::spawn` returns immediately a `future` object regardless \"\n-\"of how long it takes to run `fib(50)`. You can then make yourself a sandwich \"\n-\"while the computation of `fib` is running. The result of the execution of \"\n-\"the method is obtained by calling `get` on the future.  This call will block \"\n-\"until the value is available (*i.e.* the computation is complete). Note that \"\n-\"the future needs to be mutable so that it can save the result for next time \"\n-\"`get` is called.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:322\n-#, no-wrap\n-msgid \"\"\n-\"Here is another example showing how futures allow you to background computations. The workload will\\n\"\n-\"be distributed on the available cores.\\n\"\n-\"~~~\\n\"\n-\"# use std::vec;\\n\"\n-\"fn partial_sum(start: uint) -> f64 {\\n\"\n-\"    let mut local_sum = 0f64;\\n\"\n-\"    for num in range(start*100000, (start+1)*100000) {\\n\"\n-\"        local_sum += (num as f64 + 1.0).pow(&-2.0);\\n\"\n-\"    }\\n\"\n-\"    local_sum\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:325\n-#, no-wrap\n-msgid \"\"\n-\"fn main() {\\n\"\n-\"    let mut futures = vec::from_fn(1000, |ind| do extra::future::spawn { partial_sum(ind) });\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:333\n-#, no-wrap\n-msgid \"\"\n-\"    let mut final_res = 0f64;\\n\"\n-\"    for ft in futures.mut_iter()  {\\n\"\n-\"        final_res += ft.get();\\n\"\n-\"    }\\n\"\n-\"    println(fmt!(\\\"\u03c0^2/6 is not far from : %?\\\", final_res));\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:335\n-msgid \"## Sharing immutable data without copy: Arc\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:340\n-msgid \"\"\n-\"To share immutable data between tasks, a first approach would be to only use \"\n-\"pipes as we have seen previously. A copy of the data to share would then be \"\n-\"made for each task. In some cases, this would add up to a significant amount \"\n-\"of wasted memory and would require copying the same data more than necessary.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:344\n-msgid \"\"\n-\"To tackle this issue, one can use an Atomically Reference Counted wrapper \"\n-\"(`Arc`) as implemented in the `extra` library of Rust. With an Arc, the data \"\n-\"will no longer be copied for each task. The Arc acts as a reference to the \"\n-\"shared data and only this reference is shared and cloned.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:351\n-msgid \"\"\n-\"Here is a small example showing how to use Arcs. We wish to run concurrently \"\n-\"several computations on a single large vector of floats. Each task needs the \"\n-\"full vector to perform its duty.  ~~~ # use std::vec; # use std::rand; use \"\n-\"extra::arc::Arc;\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:355\n-#, no-wrap\n-msgid \"\"\n-\"fn pnorm(nums: &~[float], p: uint) -> float {\\n\"\n-\"    nums.iter().fold(0.0, |a,b| a+(*b).pow(&(p as float)) ).pow(&(1f / (p as float)))\\n\"\n-\"}\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:359\n-#, no-wrap\n-msgid \"\"\n-\"fn main() {\\n\"\n-\"    let numbers = vec::from_fn(1000000, |_| rand::random::<float>());\\n\"\n-\"    println(fmt!(\\\"Inf-norm = %?\\\",  *numbers.iter().max().unwrap()));\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:361\n-#, no-wrap\n-msgid \"    let numbers_arc = Arc::new(numbers);\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:365\n-#, no-wrap\n-msgid \"\"\n-\"    for num in range(1u, 10) {\\n\"\n-\"        let (port, chan)  = stream();\\n\"\n-\"        chan.send(numbers_arc.clone());\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:374\n-#, no-wrap\n-msgid \"\"\n-\"        do spawn {\\n\"\n-\"            let local_arc : Arc<~[float]> = port.recv();\\n\"\n-\"            let task_numbers = local_arc.get();\\n\"\n-\"            println(fmt!(\\\"%u-norm = %?\\\", num, pnorm(task_numbers, num)));\\n\"\n-\"        }\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:396\n-msgid \"\"\n-\"The function `pnorm` performs a simple computation on the vector (it \"\n-\"computes the sum of its items at the power given as argument and takes the \"\n-\"inverse power of this value). The Arc on the vector is created by the line \"\n-\"~~~ # use extra::arc::Arc; # use std::vec; # use std::rand; # let numbers = \"\n-\"vec::from_fn(1000000, |_| rand::random::<float>()); let numbers_arc=Arc::\"\n-\"new(numbers); ~~~ and a clone of it is sent to each task ~~~ # use extra::\"\n-\"arc::Arc; # use std::vec; # use std::rand; # let numbers=vec::\"\n-\"from_fn(1000000, |_| rand::random::<float>()); # let numbers_arc = Arc::\"\n-\"new(numbers); # let (port, chan)  = stream(); chan.send(numbers_arc.\"\n-\"clone()); ~~~ copying only the wrapper and not its contents.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:410\n-msgid \"\"\n-\"Each task recovers the underlying data by ~~~ # use extra::arc::Arc; # use \"\n-\"std::vec; # use std::rand; # let numbers=vec::from_fn(1000000, |_| rand::\"\n-\"random::<float>()); # let numbers_arc=Arc::new(numbers); # let (port, chan)  \"\n-\"= stream(); # chan.send(numbers_arc.clone()); # let local_arc : \"\n-\"Arc<~[float]> = port.recv(); let task_numbers = local_arc.get(); ~~~ and can \"\n-\"use it as if it were local.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:412\n-msgid \"\"\n-\"The `arc` module also implements Arcs around mutable data that are not \"\n-\"covered here.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:414\n-msgid \"# Handling task failure\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:423\n-msgid \"\"\n-\"Rust has a built-in mechanism for raising exceptions. The `fail!()` macro \"\n-\"(which can also be written with an error string as an argument: `fail!\"\n-\"( ~reason)`) and the `assert!` construct (which effectively calls `fail!()` \"\n-\"if a boolean expression is false) are both ways to raise exceptions. When a \"\n-\"task raises an exception the task unwinds its stack---running destructors \"\n-\"and freeing memory along the way---and then exits. Unlike exceptions in C++, \"\n-\"exceptions in Rust are unrecoverable within a single task: once a task \"\n-\"fails, there is no way to \\\"catch\\\" the exception.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:426\n-msgid \"\"\n-\"All tasks are, by default, _linked_ to each other. That means that the fates \"\n-\"of all tasks are intertwined: if one fails, so do all the others.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:434\n-msgid \"\"\n-\"~~~{.xfail-test .linked-failure} # use std::task::spawn; # use std::task; # \"\n-\"fn do_some_work() { loop { task::yield() } } # do task::try { // Create a \"\n-\"child task that fails do spawn { fail!() }\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:439\n-msgid \"\"\n-\"// This will also fail because the task we spawned failed do_some_work(); \"\n-\"# }; ~~~\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:449\n-msgid \"\"\n-\"While it isn't possible for a task to recover from failure, tasks may notify \"\n-\"each other of failure. The simplest way of handling task failure is with the \"\n-\"`try` function, which is similar to `spawn`, but immediately blocks waiting \"\n-\"for the child task to finish. `try` returns a value of type `Result<int, \"\n-\"()>`. `Result` is an `enum` type with two variants: `Ok` and `Err`. In this \"\n-\"case, because the type arguments to `Result` are `int` and `()`, callers can \"\n-\"pattern-match on a result to check whether it's an `Ok` result with an `int` \"\n-\"field (representing a successful result) or an `Err` result (representing \"\n-\"termination with an error).\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:463\n-#, no-wrap\n-msgid \"\"\n-\"~~~{.xfail-test .linked-failure}\\n\"\n-\"# use std::task;\\n\"\n-\"# fn some_condition() -> bool { false }\\n\"\n-\"# fn calculate_result() -> int { 0 }\\n\"\n-\"let result: Result<int, ()> = do task::try {\\n\"\n-\"    if some_condition() {\\n\"\n-\"        calculate_result()\\n\"\n-\"    } else {\\n\"\n-\"        fail!(\\\"oops!\\\");\\n\"\n-\"    }\\n\"\n-\"};\\n\"\n-\"assert!(result.is_err());\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:469\n-msgid \"\"\n-\"Unlike `spawn`, the function spawned using `try` may return a value, which \"\n-\"`try` will dutifully propagate back to the caller in a [`Result`] enum. If \"\n-\"the child task terminates successfully, `try` will return an `Ok` result; if \"\n-\"the child task fails, `try` will return an `Error` result.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:471\n-msgid \"[`Result`]: std/result.html\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:476\n-msgid \"\"\n-\"> ***Note:*** A failed task does not currently produce a useful error > \"\n-\"value (`try` always returns `Err(())`). In the > future, it may be possible \"\n-\"for tasks to intercept the value passed to > `fail!()`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:479\n-msgid \"\"\n-\"TODO: Need discussion of `future_result` in order to make failure modes \"\n-\"useful.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:487\n-msgid \"\"\n-\"But not all failures are created equal. In some cases you might need to \"\n-\"abort the entire program (perhaps you're writing an assert which, if it \"\n-\"trips, indicates an unrecoverable logic error); in other cases you might \"\n-\"want to contain the failure at a certain boundary (perhaps a small piece of \"\n-\"input from the outside world, which you happen to be processing in parallel, \"\n-\"is malformed and its processing task can't proceed). Hence, you will need \"\n-\"different _linked failure modes_.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:489\n-msgid \"## Failure modes\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:492\n-msgid \"\"\n-\"By default, task failure is _bidirectionally linked_, which means that if \"\n-\"either task fails, it kills the other one.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:507\n-#, no-wrap\n-msgid \"\"\n-\"~~~{.xfail-test .linked-failure}\\n\"\n-\"# use std::task;\\n\"\n-\"# use std::comm::oneshot;\\n\"\n-\"# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\\n\"\n-\"# do task::try {\\n\"\n-\"do spawn {\\n\"\n-\"    do spawn {\\n\"\n-\"        fail!();  // All three tasks will fail.\\n\"\n-\"    }\\n\"\n-\"    sleep_forever();  // Will get woken up by force, then fail\\n\"\n-\"}\\n\"\n-\"sleep_forever();  // Will get woken up by force, then fail\\n\"\n-\"# };\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:514\n-msgid \"\"\n-\"If you want parent tasks to be able to kill their children, but do not want \"\n-\"a parent to fail automatically if one of its child task fails, you can call \"\n-\"`task::spawn_supervised` for _unidirectionally linked_ failure. The function \"\n-\"`task::try`, which we saw previously, uses `spawn_supervised` internally, \"\n-\"with additional logic to wait for the child task to finish before returning. \"\n-\"Hence:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:536\n-#, no-wrap\n-msgid \"\"\n-\"~~~{.xfail-test .linked-failure}\\n\"\n-\"# use std::comm::{stream, Chan, Port};\\n\"\n-\"# use std::comm::oneshot;\\n\"\n-\"# use std::task::{spawn, try};\\n\"\n-\"# use std::task;\\n\"\n-\"# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\\n\"\n-\"# do task::try {\\n\"\n-\"let (receiver, sender): (Port<int>, Chan<int>) = stream();\\n\"\n-\"do spawn {  // Bidirectionally linked\\n\"\n-\"    // Wait for the supervised child task to exist.\\n\"\n-\"    let message = receiver.recv();\\n\"\n-\"    // Kill both it and the parent task.\\n\"\n-\"    assert!(message != 42);\\n\"\n-\"}\\n\"\n-\"do try {  // Unidirectionally linked\\n\"\n-\"    sender.send(42);\\n\"\n-\"    sleep_forever();  // Will get woken up by force\\n\"\n-\"}\\n\"\n-\"// Flow never reaches here -- parent task was killed too.\\n\"\n-\"# };\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:542\n-msgid \"\"\n-\"Supervised failure is useful in any situation where one task manages \"\n-\"multiple fallible child tasks, and the parent task can recover if any child \"\n-\"fails. On the other hand, if the _parent_ (supervisor) fails, then there is \"\n-\"nothing the children can do to recover, so they should also fail.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:545\n-msgid \"\"\n-\"Supervised task failure propagates across multiple generations even if an \"\n-\"intermediate generation has already exited:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:562\n-#, no-wrap\n-msgid \"\"\n-\"~~~{.xfail-test .linked-failure}\\n\"\n-\"# use std::task;\\n\"\n-\"# use std::comm::oneshot;\\n\"\n-\"# fn sleep_forever() { loop { let (p, c) = oneshot::<()>(); p.recv(); } }\\n\"\n-\"# fn wait_for_a_while() { for _ in range(0, 1000u) { task::yield() } }\\n\"\n-\"# do task::try::<int> {\\n\"\n-\"do task::spawn_supervised {\\n\"\n-\"    do task::spawn_supervised {\\n\"\n-\"        sleep_forever();  // Will get woken up by force, then fail\\n\"\n-\"    }\\n\"\n-\"    // Intermediate task immediately exits\\n\"\n-\"}\\n\"\n-\"wait_for_a_while();\\n\"\n-\"fail!();  // Will kill grandchild even if child has already exited\\n\"\n-\"# };\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:565\n-msgid \"\"\n-\"Finally, tasks can be configured to not propagate failure to each other at \"\n-\"all, using `task::spawn_unlinked` for _isolated failure_.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:581\n-#, no-wrap\n-msgid \"\"\n-\"~~~{.xfail-test .linked-failure}\\n\"\n-\"# use std::task;\\n\"\n-\"# fn random() -> uint { 100 }\\n\"\n-\"# fn sleep_for(i: uint) { for _ in range(0, i) { task::yield() } }\\n\"\n-\"# do task::try::<()> {\\n\"\n-\"let (time1, time2) = (random(), random());\\n\"\n-\"do task::spawn_unlinked {\\n\"\n-\"    sleep_for(time2);  // Won't get forced awake\\n\"\n-\"    fail!();\\n\"\n-\"}\\n\"\n-\"sleep_for(time1);  // Won't get forced awake\\n\"\n-\"fail!();\\n\"\n-\"// It will take MAX(time1,time2) for the program to finish.\\n\"\n-\"# };\\n\"\n-\"~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:583\n-msgid \"## Creating a task with a bi-directional communication path\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:588\n-msgid \"\"\n-\"A very common thing to do is to spawn a child task where the parent and \"\n-\"child both need to exchange messages with each other. The function `extra::\"\n-\"comm::DuplexStream()` supports this pattern.  We'll look briefly at how to \"\n-\"use it.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:593\n-msgid \"\"\n-\"To see how `DuplexStream()` works, we will create a child task that \"\n-\"repeatedly receives a `uint` message, converts it to a string, and sends the \"\n-\"string in response.  The child terminates when it receives `0`.  Here is the \"\n-\"function that implements the child task:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:606\n-#, no-wrap\n-msgid \"\"\n-\"~~~{.xfail-test .linked-failure}\\n\"\n-\"# use extra::comm::DuplexStream;\\n\"\n-\"# use std::uint;\\n\"\n-\"fn stringifier(channel: &DuplexStream<~str, uint>) {\\n\"\n-\"    let mut value: uint;\\n\"\n-\"    loop {\\n\"\n-\"        value = channel.recv();\\n\"\n-\"        channel.send(uint::to_str(value));\\n\"\n-\"        if value == 0 { break; }\\n\"\n-\"    }\\n\"\n-\"}\\n\"\n-\"~~~~\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:614\n-msgid \"\"\n-\"The implementation of `DuplexStream` supports both sending and receiving. \"\n-\"The `stringifier` function takes a `DuplexStream` that can send strings (the \"\n-\"first type parameter) and receive `uint` messages (the second type \"\n-\"parameter). The body itself simply loops, reading from the channel and then \"\n-\"sending its response back.  The actual response itself is simply the \"\n-\"stringified version of the received value, `uint::to_str(value)`.\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:616\n-msgid \"Here is the code for the parent task:\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:630\n-#, no-wrap\n-msgid \"\"\n-\"~~~{.xfail-test .linked-failure}\\n\"\n-\"# use std::task::spawn;\\n\"\n-\"# use std::uint;\\n\"\n-\"# use extra::comm::DuplexStream;\\n\"\n-\"# fn stringifier(channel: &DuplexStream<~str, uint>) {\\n\"\n-\"#     let mut value: uint;\\n\"\n-\"#     loop {\\n\"\n-\"#         value = channel.recv();\\n\"\n-\"#         channel.send(uint::to_str(value));\\n\"\n-\"#         if value == 0u { break; }\\n\"\n-\"#     }\\n\"\n-\"# }\\n\"\n-\"# fn main() {\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:632\n-msgid \"let (from_child, to_child) = DuplexStream();\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:636\n-#, no-wrap\n-msgid \"\"\n-\"do spawn {\\n\"\n-\"    stringifier(&to_child);\\n\"\n-\"};\\n\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:639\n-msgid \"from_child.send(22); assert!(from_child.recv() == ~\\\"22\\\");\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:642\n-msgid \"from_child.send(23); from_child.send(0);\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:645\n-msgid \"\"\n-\"assert!(from_child.recv() == ~\\\"23\\\"); assert!(from_child.recv() == ~\\\"0\\\");\"\n-msgstr \"\"\n-\n-#. type: Plain text\n-#: doc/tutorial-tasks.md:652\n-msgid \"\"\n-\"The parent task first calls `DuplexStream` to create a pair of bidirectional \"\n-\"endpoints. It then uses `task::spawn` to create the child task, which \"\n-\"captures one end of the communication channel.  As a result, both parent and \"\n-\"child can send and receive data to and from the other.\"\n-msgstr \"\""}, {"sha": "1c47dba9f04b4e3b4b8ec4431e93a08f905e5ca9", "filename": "doc/po/ja/tutorial.md.po", "status": "modified", "additions": 1487, "deletions": 2535, "changes": 4022, "blob_url": "https://github.com/rust-lang/rust/blob/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Ftutorial.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/729715779a904860fb75898b0f6df89d0c675ab1/doc%2Fpo%2Fja%2Ftutorial.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial.md.po?ref=729715779a904860fb75898b0f6df89d0c675ab1"}]}