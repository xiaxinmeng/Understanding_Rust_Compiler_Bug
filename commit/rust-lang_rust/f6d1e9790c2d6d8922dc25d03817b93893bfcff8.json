{"sha": "f6d1e9790c2d6d8922dc25d03817b93893bfcff8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZDFlOTc5MGMyZDZkODkyMmRjMjVkMDM4MTdiOTM4OTNiZmNmZjg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-02-05T08:37:28Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-02-14T11:36:51Z"}, "message": "rustc_mir: split qualify_consts' checking and value qualification.", "tree": {"sha": "7635f3ac551cb8296db516d3c617666fe51cabf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7635f3ac551cb8296db516d3c617666fe51cabf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6d1e9790c2d6d8922dc25d03817b93893bfcff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d1e9790c2d6d8922dc25d03817b93893bfcff8", "html_url": "https://github.com/rust-lang/rust/commit/f6d1e9790c2d6d8922dc25d03817b93893bfcff8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb", "html_url": "https://github.com/rust-lang/rust/commit/732a2dc09577f93c5eb9e4f037f7ce6723d8d7eb"}], "stats": {"total": 1099, "additions": 628, "deletions": 471}, "files": [{"sha": "e1d0ead130c024a23382c040f8f441ed6353663a", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 608, "deletions": 451, "changes": 1059, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=f6d1e9790c2d6d8922dc25d03817b93893bfcff8", "patch": "@@ -60,14 +60,29 @@ bitflags::bitflags! {\n }\n \n impl<'a, 'tcx> Qualif {\n+    /// Compute the qualifications for the given type.\n+    fn for_ty(ty: Ty<'tcx>,\n+              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+              param_env: ty::ParamEnv<'tcx>) -> Self {\n+        let mut qualif = Self::empty();\n+        if !ty.is_freeze(tcx, param_env, DUMMY_SP) {\n+            qualif = qualif | Qualif::MUTABLE_INTERIOR;\n+        }\n+        if ty.needs_drop(tcx, param_env) {\n+            qualif = qualif | Qualif::NEEDS_DROP;\n+        }\n+        qualif\n+    }\n+\n     /// Remove flags which are impossible for the given type.\n     fn restrict(&mut self, ty: Ty<'tcx>,\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 param_env: ty::ParamEnv<'tcx>) {\n-        if ty.is_freeze(tcx, param_env, DUMMY_SP) {\n+        let ty_qualif = Self::for_ty(ty, tcx, param_env);\n+        if !ty_qualif.contains(Qualif::MUTABLE_INTERIOR) {\n             *self = *self - Qualif::MUTABLE_INTERIOR;\n         }\n-        if !ty.needs_drop(tcx, param_env) {\n+        if !ty_qualif.contains(Qualif::NEEDS_DROP) {\n             *self = *self - Qualif::NEEDS_DROP;\n         }\n     }\n@@ -94,29 +109,367 @@ impl fmt::Display for Mode {\n     }\n }\n \n-struct State {\n-    local_qualif: IndexVec<Local, Option<Qualif>>,\n+struct Qualifier<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    mode: Mode,\n+    mir: &'a Mir<'tcx>,\n \n-    qualif: Qualif,\n+    local_qualif: &'a IndexVec<Local, Option<Qualif>>,\n+    temp_promotion_state: &'a IndexVec<Local, TempState>,\n }\n \n-impl State {\n-    /// Add the given qualification to self.qualif.\n-    fn add(&mut self, qualif: Qualif) {\n-        self.qualif = self.qualif | qualif;\n+impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n+    fn qualif_for_ty(&self, ty: Ty<'tcx>) -> Qualif {\n+        Qualif::for_ty(ty, self.tcx, self.param_env)\n+    }\n+\n+    fn qualify_local(&self, local: Local) -> Qualif {\n+        let kind = self.mir.local_kind(local);\n+        match kind {\n+            LocalKind::ReturnPointer => Qualif::NOT_CONST,\n+            LocalKind::Var if self.mode == Mode::Fn => Qualif::NOT_CONST,\n+\n+            LocalKind::Var |\n+            LocalKind::Arg |\n+            LocalKind::Temp => {\n+                let mut qualif = self.local_qualif[local]\n+                    .unwrap_or(Qualif::NOT_CONST);\n+\n+                if let LocalKind::Arg = kind {\n+                    qualif = qualif | Qualif::FN_ARGUMENT;\n+                }\n+\n+                if !self.temp_promotion_state[local].is_promotable() {\n+                    qualif = qualif | Qualif::NOT_PROMOTABLE;\n+                }\n+\n+                qualif\n+            }\n+        }\n+    }\n+\n+    fn qualify_projection_elem(&self, proj: &PlaceElem<'tcx>) -> Qualif {\n+        match *proj {\n+            ProjectionElem::Deref |\n+            ProjectionElem::Subslice { .. } |\n+            ProjectionElem::Field(..) |\n+            ProjectionElem::ConstantIndex { .. } |\n+            ProjectionElem::Downcast(..) => Qualif::empty(),\n+\n+            ProjectionElem::Index(local) => self.qualify_local(local),\n+        }\n+    }\n+\n+    fn qualify_place(&self, place: &Place<'tcx>) -> Qualif {\n+        match *place {\n+            Place::Local(local) => self.qualify_local(local),\n+            Place::Promoted(_) => bug!(\"qualifying already promoted MIR\"),\n+            Place::Static(ref global) => {\n+                if self.tcx\n+                       .get_attrs(global.def_id)\n+                       .iter()\n+                       .any(|attr| attr.check_name(\"thread_local\")) {\n+                    return Qualif::NOT_CONST;\n+                }\n+\n+                // Only allow statics (not consts) to refer to other statics.\n+                if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n+                    Qualif::empty()\n+                } else {\n+                    Qualif::NOT_CONST\n+                }\n+            }\n+            Place::Projection(ref proj) => {\n+                let mut qualif =\n+                    self.qualify_place(&proj.base) |\n+                    self.qualify_projection_elem(&proj.elem);\n+                match proj.elem {\n+                    ProjectionElem::Deref |\n+                    ProjectionElem::Downcast(..) => qualif | Qualif::NOT_CONST,\n+\n+                    ProjectionElem::ConstantIndex {..} |\n+                    ProjectionElem::Subslice {..} |\n+                    ProjectionElem::Field(..) |\n+                    ProjectionElem::Index(_) => {\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        if let Some(def) = base_ty.ty_adt_def() {\n+                            if def.is_union() {\n+                                match self.mode {\n+                                    Mode::Fn => qualif = qualif | Qualif::NOT_CONST,\n+\n+                                    Mode::ConstFn |\n+                                    Mode::Static |\n+                                    Mode::StaticMut |\n+                                    Mode::Const => {}\n+                                }\n+                            }\n+                        }\n+\n+                        let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        qualif.restrict(ty, self.tcx, self.param_env);\n+                        qualif\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn qualify_operand(&self, operand: &Operand<'tcx>) -> Qualif {\n+        match *operand {\n+            Operand::Copy(ref place) |\n+            Operand::Move(ref place) => self.qualify_place(place),\n+\n+            Operand::Constant(ref constant) => {\n+                if let ty::LazyConst::Unevaluated(def_id, _) = constant.literal {\n+                    // Don't peek inside trait associated constants.\n+                    if self.tcx.trait_of_item(*def_id).is_some() {\n+                        self.qualif_for_ty(constant.ty)\n+                    } else {\n+                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(*def_id);\n+\n+                        let mut qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n+\n+                        // Just in case the type is more specific than\n+                        // the definition, e.g., impl associated const\n+                        // with type parameters, take it into account.\n+                        qualif.restrict(constant.ty, self.tcx, self.param_env);\n+                        qualif\n+                    }\n+                } else {\n+                    Qualif::empty()\n+                }\n+            }\n+        }\n+    }\n+\n+    fn qualify_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Qualif {\n+        match *rvalue {\n+            Rvalue::NullaryOp(NullOp::SizeOf, _) => Qualif::empty(),\n+\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::UnaryOp(UnOp::Neg, ref operand) |\n+            Rvalue::UnaryOp(UnOp::Not, ref operand) |\n+            Rvalue::Cast(CastKind::ReifyFnPointer, ref operand, _) |\n+            Rvalue::Cast(CastKind::UnsafeFnPointer, ref operand, _) |\n+            Rvalue::Cast(CastKind::ClosureFnPointer, ref operand, _) |\n+            Rvalue::Cast(CastKind::Unsize, ref operand, _) => {\n+                self.qualify_operand(operand)\n+            }\n+\n+            Rvalue::CheckedBinaryOp(_, ref lhs, ref rhs) => {\n+                self.qualify_operand(lhs) | self.qualify_operand(rhs)\n+            }\n+\n+            Rvalue::Discriminant(ref place) |\n+            Rvalue::Len(ref place) => self.qualify_place(place),\n+\n+            Rvalue::Ref(_, kind, ref place) => {\n+                let mut reborrow_qualif = None;\n+                if let Place::Projection(ref proj) = *place {\n+                    if let ProjectionElem::Deref = proj.elem {\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        if let ty::Ref(..) = base_ty.sty {\n+                            reborrow_qualif = Some(self.qualify_place(&proj.base));\n+                        }\n+                    }\n+                }\n+\n+                let mut qualif = reborrow_qualif.unwrap_or_else(|| {\n+                    self.qualify_place(place)\n+                });\n+\n+                let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+\n+                if let BorrowKind::Mut { .. } = kind {\n+                    // In theory, any zero-sized value could be borrowed\n+                    // mutably without consequences. However, only &mut []\n+                    // is allowed right now, and only in functions.\n+                    let allowed = if self.mode == Mode::StaticMut {\n+                        // Inside a `static mut`, &mut [...] is also allowed.\n+                        match ty.sty {\n+                            ty::Array(..) | ty::Slice(_) => true,\n+                            _ => false\n+                        }\n+                    } else if let ty::Array(_, len) = ty.sty {\n+                        // FIXME(eddyb) the `self.mode == Mode::Fn` condition\n+                        // seems unnecessary, given that this is merely a ZST.\n+                        len.unwrap_usize(self.tcx) == 0 && self.mode == Mode::Fn\n+                    } else {\n+                        false\n+                    };\n+\n+                    if !allowed {\n+                        qualif = qualif | Qualif::MUTABLE_INTERIOR;\n+                    }\n+                }\n+\n+                qualif\n+            }\n+\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n+                let mut qualif = self.qualify_operand(operand);\n+\n+                let operand_ty = operand.ty(self.mir, self.tcx);\n+                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                match (cast_in, cast_out) {\n+                    (CastTy::Ptr(_), CastTy::Int(_)) |\n+                    (CastTy::FnPtr, CastTy::Int(_)) => {\n+                        if let Mode::Fn = self.mode {\n+                            // in normal functions, mark such casts as not promotable\n+                            qualif = qualif | Qualif::NOT_CONST;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                qualif\n+            }\n+\n+            Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+                let mut qualif = self.qualify_operand(lhs) | self.qualify_operand(rhs);\n+\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.mir, self.tcx).sty {\n+                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n+                            op == BinOp::Le || op == BinOp::Lt ||\n+                            op == BinOp::Ge || op == BinOp::Gt ||\n+                            op == BinOp::Offset);\n+\n+                    if let Mode::Fn = self.mode {\n+                        // raw pointer operations are not allowed inside promoteds\n+                        qualif = qualif | Qualif::NOT_CONST;\n+                    }\n+                }\n+\n+                qualif\n+            }\n+\n+            Rvalue::NullaryOp(NullOp::Box, _) => Qualif::NOT_CONST,\n+\n+            Rvalue::Aggregate(ref kind, ref operands) => {\n+                let mut qualif = operands.iter().map(|o| self.qualify_operand(o))\n+                    .fold(Qualif::empty(), |a, b| a | b);\n+\n+                if let AggregateKind::Adt(def, ..) = **kind {\n+                    if Some(def.did) == self.tcx.lang_items().unsafe_cell_type() {\n+                        let ty = rvalue.ty(self.mir, self.tcx);\n+                        qualif = qualif | self.qualif_for_ty(ty);\n+                        assert!(qualif.contains(Qualif::MUTABLE_INTERIOR));\n+                    }\n+\n+                    if def.has_dtor(self.tcx) {\n+                        qualif = qualif | Qualif::NEEDS_DROP;\n+                    }\n+                }\n+\n+                qualif\n+            }\n+        }\n+    }\n+\n+    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n+        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n+        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+    }\n+\n+    fn qualify_call(\n+        &self,\n+        callee: &Operand<'tcx>,\n+        args: &[Operand<'tcx>],\n+        return_ty: Ty<'tcx>,\n+    ) -> Qualif {\n+        let fn_ty = callee.ty(self.mir, self.tcx);\n+        let mut is_promotable_const_fn = false;\n+        let is_const_fn = match fn_ty.sty {\n+            ty::FnDef(def_id, _) => {\n+                match self.tcx.fn_sig(def_id).abi() {\n+                    Abi::RustIntrinsic |\n+                    Abi::PlatformIntrinsic => {\n+                        assert!(!self.tcx.is_const_fn(def_id));\n+                        match &self.tcx.item_name(def_id).as_str()[..] {\n+                            | \"size_of\"\n+                            | \"min_align_of\"\n+                            | \"needs_drop\"\n+                            | \"type_id\"\n+                            | \"bswap\"\n+                            | \"bitreverse\"\n+                            | \"ctpop\"\n+                            | \"cttz\"\n+                            | \"cttz_nonzero\"\n+                            | \"ctlz\"\n+                            | \"ctlz_nonzero\"\n+                            | \"overflowing_add\"\n+                            | \"overflowing_sub\"\n+                            | \"overflowing_mul\"\n+                            | \"unchecked_shl\"\n+                            | \"unchecked_shr\"\n+                            | \"rotate_left\"\n+                            | \"rotate_right\"\n+                            | \"add_with_overflow\"\n+                            | \"sub_with_overflow\"\n+                            | \"mul_with_overflow\"\n+                            | \"saturating_add\"\n+                            | \"saturating_sub\"\n+                            | \"transmute\"\n+                            => true,\n+\n+                            _ => false,\n+                        }\n+                    }\n+                    _ => {\n+                        // Never promote runtime `const fn` calls of\n+                        // functions without `#[rustc_promotable]`.\n+                        if self.tcx.is_promotable_const_fn(def_id) {\n+                            is_promotable_const_fn = true;\n+                        }\n+\n+                        if self.mode == Mode::Fn {\n+                            self.tcx.is_const_fn(def_id)\n+                        } else {\n+                            self.tcx.is_const_fn(def_id) ||\n+                            self.is_const_panic_fn(def_id) ||\n+                            self.tcx.is_unstable_const_fn(def_id).is_some()\n+                        }\n+                    }\n+                }\n+            }\n+            _ => false,\n+        };\n+\n+        // Bail out on oon-`const fn` calls or if the callee had errors.\n+        if !is_const_fn || self.qualify_operand(callee).intersects(Qualif::CONST_ERROR) {\n+            return Qualif::NOT_CONST;\n+        }\n+\n+        // Bail out if any arguments had errors.\n+        for arg in args {\n+            if self.qualify_operand(arg).intersects(Qualif::CONST_ERROR) {\n+                return Qualif::NOT_CONST;\n+            }\n+        }\n+\n+        // Be conservative about the returned value of a const fn.\n+        let qualif = self.qualif_for_ty(return_ty);\n+        if !is_promotable_const_fn && self.mode == Mode::Fn {\n+            qualif | Qualif::NOT_PROMOTABLE\n+        } else {\n+            qualif\n+        }\n     }\n }\n \n-struct Checker<'a, 'gcx, 'tcx> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct Checker<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     mode: Mode,\n     span: Span,\n     def_id: DefId,\n     mir: &'a Mir<'tcx>,\n     rpo: ReversePostorder<'a, 'tcx>,\n \n-    state: State,\n+    local_qualif: IndexVec<Local, Option<Qualif>>,\n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>,\n }\n@@ -130,12 +483,12 @@ macro_rules! unleash_miri {\n     }}\n }\n \n-impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            def_id: DefId,\n            mir: &'a Mir<'tcx>,\n            mode: Mode)\n-           -> Checker<'a, 'tcx, 'tcx> {\n+           -> Self {\n         assert!(def_id.is_local());\n         let mut rpo = traversal::reverse_postorder(mir);\n         let temps = promote_consts::collect_temps(mir, &mut rpo);\n@@ -158,21 +511,28 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n             rpo,\n             tcx,\n             param_env,\n-            state: State {\n-                local_qualif,\n-                qualif: Qualif::empty(),\n-            },\n+            local_qualif,\n             temp_promotion_state: temps,\n             promotion_candidates: vec![]\n         }\n     }\n \n+    fn qualifier(&'a self) -> Qualifier<'a, 'tcx> {\n+        Qualifier {\n+            tcx: self.tcx,\n+            param_env: self.param_env,\n+            mode: self.mode,\n+            mir: self.mir,\n+            local_qualif: &self.local_qualif,\n+            temp_promotion_state: &self.temp_promotion_state,\n+        }\n+    }\n+\n     // FIXME(eddyb) we could split the errors into meaningful\n     // categories, but enabling full miri would make that\n     // slightly pointless (even with feature-gating).\n     fn not_const(&mut self) {\n         unleash_miri!(self);\n-        self.state.add(Qualif::NOT_CONST);\n         if self.mode != Mode::Fn {\n             let mut err = struct_span_err!(\n                 self.tcx.sess,\n@@ -191,41 +551,21 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    /// Adds the given type's qualification to self.state.qualif.\n-    fn add_type(&mut self, ty: Ty<'tcx>) {\n-        self.state.add(Qualif::MUTABLE_INTERIOR | Qualif::NEEDS_DROP);\n-        self.state.qualif.restrict(ty, self.tcx, self.param_env);\n-    }\n-\n-    /// Within the provided closure, `self.state.qualif` will start\n-    /// out empty, and its value after the closure returns will\n-    /// be combined with the value before the call to nest.\n-    fn nest<F: FnOnce(&mut Self)>(&mut self, f: F) {\n-        let original = self.state.qualif;\n-        self.state.qualif = Qualif::empty();\n-        f(self);\n-        self.state.add(original);\n-    }\n-\n-    /// Assign the current qualification to the given destination.\n-    fn assign(&mut self, dest: &Place<'tcx>, location: Location) {\n-        trace!(\"assign: {:?}\", dest);\n-        let qualif = self.state.qualif;\n-        let span = self.span;\n-        let store = |slot: &mut Option<Qualif>| {\n-            if slot.is_some() {\n-                span_bug!(span, \"multiple assignments to {:?}\", dest);\n-            }\n-            *slot = Some(qualif);\n-        };\n+    /// Assigns an rvalue/call qualification to the given destination.\n+    fn assign(&mut self, dest: &Place<'tcx>, qualif: Qualif, location: Location) {\n+        trace!(\"assign: {:?} <- {:?}\", dest, qualif);\n \n         // Only handle promotable temps in non-const functions.\n         if self.mode == Mode::Fn {\n             if let Place::Local(index) = *dest {\n                 if self.mir.local_kind(index) == LocalKind::Temp\n                 && self.temp_promotion_state[index].is_promotable() {\n                     debug!(\"store to promotable temp {:?} ({:?})\", index, qualif);\n-                    store(&mut self.state.local_qualif[index]);\n+                    let slot = &mut self.local_qualif[index];\n+                    if slot.is_some() {\n+                        span_bug!(self.span, \"multiple assignments to {:?}\", dest);\n+                    }\n+                    *slot = Some(qualif);\n                 }\n             }\n             return;\n@@ -263,18 +603,15 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n             }\n         };\n         debug!(\"store to var {:?}\", index);\n-        match &mut self.state.local_qualif[index] {\n-            // this is overly restrictive, because even full assignments do not clear the qualif\n-            // While we could special case full assignments, this would be inconsistent with\n-            // aggregates where we overwrite all fields via assignments, which would not get\n-            // that feature.\n-            Some(ref mut qualif) => *qualif = *qualif | self.state.qualif,\n-            // insert new qualification\n-            qualif @ None => *qualif = Some(self.state.qualif),\n-        }\n+        // this is overly restrictive, because even full assignments do not clear the qualif\n+        // While we could special case full assignments, this would be inconsistent with\n+        // aggregates where we overwrite all fields via assignments, which would not get\n+        // that feature.\n+        let slot = &mut self.local_qualif[index];\n+        *slot = Some(slot.unwrap_or(Qualif::empty()) | qualif);\n     }\n \n-    /// Qualify a whole const, static initializer or const fn.\n+    /// Check a whole const, static initializer or const fn.\n     fn check_const(&mut self) -> (Qualif, Lrc<BitSet<Local>>) {\n         debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n \n@@ -327,14 +664,12 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        self.state.qualif = self.state.local_qualif[RETURN_PLACE].unwrap_or(Qualif::NOT_CONST);\n+        let mut qualif = self.local_qualif[RETURN_PLACE].unwrap_or(Qualif::NOT_CONST);\n \n         // Account for errors in consts by using the\n         // conservative type qualification instead.\n-        if self.state.qualif.intersects(Qualif::CONST_ERROR) {\n-            self.state.qualif = Qualif::empty();\n-            let return_ty = mir.return_ty();\n-            self.add_type(return_ty);\n+        if qualif.intersects(Qualif::CONST_ERROR) {\n+            qualif = self.qualifier().qualif_for_ty(mir.return_ty());\n         }\n \n \n@@ -356,50 +691,23 @@ impl<'a, 'tcx> Checker<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        (self.state.qualif, Lrc::new(promoted_temps))\n-    }\n-\n-    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n-        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n-        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+        (qualif, Lrc::new(promoted_temps))\n     }\n }\n \n-/// Accumulates an Rvalue or Call's effects in self.state.qualif.\n+/// Checks MIR for const-correctness, using `Qualifier`\n+/// for value qualifications, and accumulates writes of\n+/// rvalue/call results to locals, in `local_qualif`.\n /// For functions (constant or not), it also records\n-/// candidates for promotion in promotion_candidates.\n-impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n+/// candidates for promotion in `promotion_candidates`.\n+impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     fn visit_local(&mut self,\n                    &local: &Local,\n                    _: PlaceContext<'tcx>,\n                    _: Location) {\n         debug!(\"visit_local: local={:?}\", local);\n-        let kind = self.mir.local_kind(local);\n-        match kind {\n-            LocalKind::ReturnPointer => {\n-                self.not_const();\n-            }\n-            LocalKind::Var if self.mode == Mode::Fn => {\n-                self.state.add(Qualif::NOT_CONST);\n-            }\n-            LocalKind::Var |\n-            LocalKind::Arg |\n-            LocalKind::Temp => {\n-                if let LocalKind::Arg = kind {\n-                    self.state.add(Qualif::FN_ARGUMENT);\n-                }\n-\n-                if !self.temp_promotion_state[local].is_promotable() {\n-                    debug!(\"visit_local: (not promotable) local={:?}\", local);\n-                    self.state.add(Qualif::NOT_PROMOTABLE);\n-                }\n-\n-                if let Some(qualif) = self.state.local_qualif[local] {\n-                    self.state.add(qualif);\n-                } else {\n-                    self.not_const();\n-                }\n-            }\n+        if self.local_qualif[local].is_none() {\n+            self.not_const();\n         }\n     }\n \n@@ -408,9 +716,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n         debug!(\"visit_place: place={:?} context={:?} location={:?}\", place, context, location);\n+        self.super_place(place, context, location);\n         match *place {\n-            Place::Local(ref local) => self.visit_local(local, context, location),\n-            Place::Promoted(_) => bug!(\"promoting already promoted MIR\"),\n+            Place::Local(_) |\n+            Place::Promoted(_) => {}\n             Place::Static(ref global) => {\n                 if self.tcx\n                        .get_attrs(global.def_id)\n@@ -421,7 +730,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                                   \"thread-local statics cannot be \\\n                                    accessed at compile-time\");\n                     }\n-                    self.state.add(Qualif::NOT_CONST);\n                     return;\n                 }\n \n@@ -440,7 +748,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     return;\n                 }\n                 unleash_miri!(self);\n-                self.state.add(Qualif::NOT_CONST);\n \n                 if self.mode != Mode::Fn {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n@@ -459,73 +766,64 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                 }\n             }\n             Place::Projection(ref proj) => {\n-                self.nest(|this| {\n-                    this.super_place(place, context, location);\n-                    match proj.elem {\n-                        ProjectionElem::Deref => {\n-                            if context.is_mutating_use() {\n-                                // `not_const` errors out in const contexts\n-                                this.not_const()\n-                            } else {\n-                                // just make sure this doesn't get promoted\n-                                this.state.add(Qualif::NOT_CONST);\n-                            }\n-                            let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n-                            match this.mode {\n-                                Mode::Fn => {},\n-                                _ => {\n-                                    if let ty::RawPtr(_) = base_ty.sty {\n-                                        if !this.tcx.features().const_raw_ptr_deref {\n-                                            emit_feature_err(\n-                                                &this.tcx.sess.parse_sess, \"const_raw_ptr_deref\",\n-                                                this.span, GateIssue::Language,\n-                                                &format!(\n-                                                    \"dereferencing raw pointers in {}s is unstable\",\n-                                                    this.mode,\n-                                                ),\n-                                            );\n-                                        }\n+                match proj.elem {\n+                    ProjectionElem::Deref => {\n+                        if context.is_mutating_use() {\n+                            // `not_const` errors out in const contexts\n+                            self.not_const()\n+                        }\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        match self.mode {\n+                            Mode::Fn => {},\n+                            _ => {\n+                                if let ty::RawPtr(_) = base_ty.sty {\n+                                    if !self.tcx.features().const_raw_ptr_deref {\n+                                        emit_feature_err(\n+                                            &self.tcx.sess.parse_sess, \"const_raw_ptr_deref\",\n+                                            self.span, GateIssue::Language,\n+                                            &format!(\n+                                                \"dereferencing raw pointers in {}s is unstable\",\n+                                                self.mode,\n+                                            ),\n+                                        );\n                                     }\n                                 }\n                             }\n                         }\n+                    }\n \n-                        ProjectionElem::ConstantIndex {..} |\n-                        ProjectionElem::Subslice {..} |\n-                        ProjectionElem::Field(..) |\n-                        ProjectionElem::Index(_) => {\n-                            let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n-                            if let Some(def) = base_ty.ty_adt_def() {\n-                                if def.is_union() {\n-                                    match this.mode {\n-                                        Mode::Fn => this.not_const(),\n-                                        Mode::ConstFn => {\n-                                            if !this.tcx.features().const_fn_union {\n-                                                emit_feature_err(\n-                                                    &this.tcx.sess.parse_sess, \"const_fn_union\",\n-                                                    this.span, GateIssue::Language,\n-                                                    \"unions in const fn are unstable\",\n-                                                );\n-                                            }\n-                                        },\n-\n-                                        | Mode::Static\n-                                        | Mode::StaticMut\n-                                        | Mode::Const\n-                                        => {},\n-                                    }\n+                    ProjectionElem::ConstantIndex {..} |\n+                    ProjectionElem::Subslice {..} |\n+                    ProjectionElem::Field(..) |\n+                    ProjectionElem::Index(_) => {\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        if let Some(def) = base_ty.ty_adt_def() {\n+                            if def.is_union() {\n+                                match self.mode {\n+                                    Mode::ConstFn => {\n+                                        if !self.tcx.features().const_fn_union {\n+                                            emit_feature_err(\n+                                                &self.tcx.sess.parse_sess, \"const_fn_union\",\n+                                                self.span, GateIssue::Language,\n+                                                \"unions in const fn are unstable\",\n+                                            );\n+                                        }\n+                                    },\n+\n+                                    | Mode::Fn\n+                                    | Mode::Static\n+                                    | Mode::StaticMut\n+                                    | Mode::Const\n+                                    => {},\n                                 }\n                             }\n-\n-                            let ty = place.ty(this.mir, this.tcx).to_ty(this.tcx);\n-                            this.state.qualif.restrict(ty, this.tcx, this.param_env);\n                         }\n+                    }\n \n-                        ProjectionElem::Downcast(..) => {\n-                            this.not_const()\n-                        }\n+                    ProjectionElem::Downcast(..) => {\n+                        self.not_const()\n                     }\n-                });\n+                }\n             }\n         }\n     }\n@@ -535,40 +833,25 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n         self.super_operand(operand, location);\n \n         match *operand {\n-            Operand::Copy(_) |\n-            Operand::Move(_) => {\n+            Operand::Move(ref place) => {\n                 // Mark the consumed locals to indicate later drops are noops.\n-                if let Operand::Move(Place::Local(local)) = *operand {\n-                    self.state.local_qualif[local] = self.state.local_qualif[local].map(|q|\n+                if let Place::Local(local) = *place {\n+                    self.local_qualif[local] = self.local_qualif[local].map(|q|\n                         q - Qualif::NEEDS_DROP\n                     );\n                 }\n             }\n-            Operand::Constant(ref constant) => {\n-                if let ty::LazyConst::Unevaluated(def_id, _) = constant.literal {\n-                    // Don't peek inside trait associated constants.\n-                    if self.tcx.trait_of_item(*def_id).is_some() {\n-                        self.add_type(constant.ty);\n-                    } else {\n-                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(*def_id);\n-\n-                        let qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n-                        self.state.add(qualif);\n-\n-                        // Just in case the type is more specific than\n-                        // the definition, e.g., impl associated const\n-                        // with type parameters, take it into account.\n-                        self.state.qualif.restrict(constant.ty, self.tcx, self.param_env);\n-                    }\n-                }\n-            }\n+            Operand::Copy(_) |\n+            Operand::Constant(_) => {}\n         }\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         debug!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n-        // Recurse through operands and places.\n+\n+        // Check nested operands and places.\n         if let Rvalue::Ref(region, kind, ref place) = *rvalue {\n+            // Special-case reborrows.\n             let mut is_reborrow = false;\n             if let Place::Projection(ref proj) = *place {\n                 if let ProjectionElem::Deref = proj.elem {\n@@ -581,14 +864,18 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n \n             if is_reborrow {\n                 let ctx = match kind {\n-                    BorrowKind::Shared =>\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow(region)),\n-                    BorrowKind::Shallow =>\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow(region)),\n-                    BorrowKind::Unique =>\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow(region)),\n-                    BorrowKind::Mut { .. } =>\n-                        PlaceContext::MutatingUse(MutatingUseContext::Borrow(region)),\n+                    BorrowKind::Shared => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::SharedBorrow(region),\n+                    ),\n+                    BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::ShallowBorrow(region),\n+                    ),\n+                    BorrowKind::Unique => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::UniqueBorrow(region),\n+                    ),\n+                    BorrowKind::Mut { .. } => PlaceContext::MutatingUse(\n+                        MutatingUseContext::Borrow(region),\n+                    ),\n                 };\n                 self.super_place(place, ctx, location);\n             } else {\n@@ -610,124 +897,19 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n             Rvalue::Cast(CastKind::ClosureFnPointer, ..) |\n             Rvalue::Cast(CastKind::Unsize, ..) |\n             Rvalue::Discriminant(..) |\n-            Rvalue::Len(_) => {}\n-\n-            Rvalue::Ref(_, kind, ref place) => {\n-                let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n-\n-                // Default to forbidding the borrow and/or its promotion,\n-                // due to the potential for direct or interior mutability,\n-                // and only proceed by setting `forbidden_mut` to `false`.\n-                let mut forbidden_mut = true;\n-\n-                if let BorrowKind::Mut { .. } = kind {\n-                    // In theory, any zero-sized value could be borrowed\n-                    // mutably without consequences. However, only &mut []\n-                    // is allowed right now, and only in functions.\n-                    if self.mode == Mode::StaticMut {\n-                        // Inside a `static mut`, &mut [...] is also allowed.\n-                        match ty.sty {\n-                            ty::Array(..) | ty::Slice(_) => forbidden_mut = false,\n-                            _ => {}\n-                        }\n-                    } else if let ty::Array(_, len) = ty.sty {\n-                        // FIXME(eddyb) the `self.mode == Mode::Fn` condition\n-                        // seems unnecessary, given that this is merely a ZST.\n-                        if len.unwrap_usize(self.tcx) == 0 && self.mode == Mode::Fn {\n-                            forbidden_mut = false;\n-                        }\n-                    }\n-\n-                    if forbidden_mut {\n-                        unleash_miri!(self);\n-                        self.state.add(Qualif::NOT_CONST);\n-                        if self.mode != Mode::Fn {\n-                            let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                                           \"references in {}s may only refer \\\n-                                                            to immutable values\", self.mode);\n-                            err.span_label(self.span, format!(\"{}s require immutable values\",\n-                                                                self.mode));\n-                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                                err.note(\"References in statics and constants may only refer to \\\n-                                          immutable values.\\n\\n\\\n-                                          Statics are shared everywhere, and if they refer to \\\n-                                          mutable data one might violate memory safety since \\\n-                                          holding multiple mutable references to shared data is \\\n-                                          not allowed.\\n\\n\\\n-                                          If you really want global mutable state, try using \\\n-                                          static mut or a global UnsafeCell.\");\n-                            }\n-                            err.emit();\n-                        }\n-                    }\n-                } else {\n-                    // Constants cannot be borrowed if they contain interior mutability as\n-                    // it means that our \"silent insertion of statics\" could change\n-                    // initializer values (very bad).\n-                    if self.state.qualif.contains(Qualif::MUTABLE_INTERIOR) {\n-                        // A reference of a MUTABLE_INTERIOR place is instead\n-                        // NOT_CONST (see `if forbidden_mut` below), to avoid\n-                        // duplicate errors (from reborrowing, for example).\n-                        self.state.qualif = self.state.qualif - Qualif::MUTABLE_INTERIOR;\n-                        if self.mode != Mode::Fn {\n-                            span_err!(self.tcx.sess, self.span, E0492,\n-                                      \"cannot borrow a constant which may contain \\\n-                                       interior mutability, create a static instead\");\n-                        }\n-                    } else {\n-                        // We allow immutable borrows of frozen data.\n-                        forbidden_mut = false;\n-                    }\n-                }\n-\n-                debug!(\"visit_rvalue: forbidden_mut={:?}\", forbidden_mut);\n-                if forbidden_mut {\n-                    unleash_miri!(self);\n-                    self.state.add(Qualif::NOT_CONST);\n-                } else {\n-                    // We might have a candidate for promotion.\n-                    let candidate = Candidate::Ref(location);\n-                    // We can only promote interior borrows of promotable temps.\n-                    let mut place = place;\n-                    while let Place::Projection(ref proj) = *place {\n-                        if proj.elem == ProjectionElem::Deref {\n-                            break;\n-                        }\n-                        place = &proj.base;\n-                    }\n-                    debug!(\"visit_rvalue: place={:?}\", place);\n-                    if let Place::Local(local) = *place {\n-                        if self.mir.local_kind(local) == LocalKind::Temp {\n-                            debug!(\"visit_rvalue: local={:?}\", local);\n-                            if let Some(qualif) = self.state.local_qualif[local] {\n-                                // `forbidden_mut` is false, so we can safely ignore\n-                                // `MUTABLE_INTERIOR` from the local's qualifications.\n-                                // This allows borrowing fields which don't have\n-                                // `MUTABLE_INTERIOR`, from a type that does, e.g.:\n-                                // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                                debug!(\"visit_rvalue: qualif={:?}\", qualif);\n-                                if (qualif - Qualif::MUTABLE_INTERIOR).is_empty() {\n-                                    debug!(\"visit_rvalue: candidate={:?}\", candidate);\n-                                    self.promotion_candidates.push(candidate);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n+            Rvalue::Len(_) |\n+            Rvalue::Ref(..) |\n+            Rvalue::Aggregate(..) => {}\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n                 let operand_ty = operand.ty(self.mir, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n                     (CastTy::Ptr(_), CastTy::Int(_)) |\n-                    (CastTy::FnPtr, CastTy::Int(_)) => {\n+                    (CastTy::FnPtr, CastTy::Int(_)) if self.mode != Mode::Fn => {\n                         unleash_miri!(self);\n-                        if let Mode::Fn = self.mode {\n-                            // in normal functions, mark such casts as not promotable\n-                            self.state.add(Qualif::NOT_CONST);\n-                        } else if !self.tcx.features().const_raw_ptr_to_usize_cast {\n+                        if !self.tcx.features().const_raw_ptr_to_usize_cast {\n                             // in const fn and constants require the feature gate\n                             // FIXME: make it unsafe inside const fn and constants\n                             emit_feature_err(\n@@ -752,10 +934,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                             op == BinOp::Offset);\n \n                     unleash_miri!(self);\n-                    if let Mode::Fn = self.mode {\n-                        // raw pointer operations are not allowed inside promoteds\n-                        self.state.add(Qualif::NOT_CONST);\n-                    } else if !self.tcx.features().const_compare_raw_pointers {\n+                    if self.mode != Mode::Fn && !self.tcx.features().const_compare_raw_pointers {\n                         // require the feature gate inside constants and const fn\n                         // FIXME: make it unsafe to use these operations\n                         emit_feature_err(\n@@ -771,7 +950,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n \n             Rvalue::NullaryOp(NullOp::Box, _) => {\n                 unleash_miri!(self);\n-                self.state.add(Qualif::NOT_CONST);\n                 if self.mode != Mode::Fn {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n                                                    \"allocations are not allowed in {}s\", self.mode);\n@@ -787,20 +965,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     err.emit();\n                 }\n             }\n-\n-            Rvalue::Aggregate(ref kind, _) => {\n-                if let AggregateKind::Adt(def, ..) = **kind {\n-                    if def.has_dtor(self.tcx) {\n-                        self.state.add(Qualif::NEEDS_DROP);\n-                    }\n-\n-                    if Some(def.did) == self.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(self.mir, self.tcx);\n-                        self.add_type(ty);\n-                        assert!(self.state.qualif.contains(Qualif::MUTABLE_INTERIOR));\n-                    }\n-                }\n-            }\n         }\n     }\n \n@@ -810,13 +974,15 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                              location: Location) {\n         debug!(\"visit_terminator_kind: bb={:?} kind={:?} location={:?}\", bb, kind, location);\n         if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n-            self.visit_operand(func, location);\n+            if let Some((ref dest, _)) = *destination {\n+                let ty = dest.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                let qualif = self.qualifier().qualify_call(func, args, ty);\n+                self.assign(dest, qualif, location);\n+            }\n \n             let fn_ty = func.ty(self.mir, self.tcx);\n             let mut callee_def_id = None;\n             let mut is_shuffle = false;\n-            let mut is_const_fn = false;\n-            let mut is_promotable_const_fn = false;\n             match fn_ty.sty {\n                 ty::FnDef(def_id, _) => {\n                     callee_def_id = Some(def_id);\n@@ -825,38 +991,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                         Abi::PlatformIntrinsic => {\n                             assert!(!self.tcx.is_const_fn(def_id));\n                             match &self.tcx.item_name(def_id).as_str()[..] {\n-                                | \"size_of\"\n-                                | \"min_align_of\"\n-                                | \"needs_drop\"\n-                                | \"type_id\"\n-                                | \"bswap\"\n-                                | \"bitreverse\"\n-                                | \"ctpop\"\n-                                | \"cttz\"\n-                                | \"cttz_nonzero\"\n-                                | \"ctlz\"\n-                                | \"ctlz_nonzero\"\n-                                | \"overflowing_add\"\n-                                | \"overflowing_sub\"\n-                                | \"overflowing_mul\"\n-                                | \"unchecked_shl\"\n-                                | \"unchecked_shr\"\n-                                | \"rotate_left\"\n-                                | \"rotate_right\"\n-                                | \"add_with_overflow\"\n-                                | \"sub_with_overflow\"\n-                                | \"mul_with_overflow\"\n-                                | \"saturating_add\"\n-                                | \"saturating_sub\"\n-                                // no need to check feature gates, intrinsics are only callable\n-                                // from the libstd or with forever unstable feature gates\n-                                => is_const_fn = true,\n                                 // special intrinsic that can be called diretly without an intrinsic\n                                 // feature gate needs a language feature gate\n                                 \"transmute\" => {\n                                     // never promote transmute calls\n                                     if self.mode != Mode::Fn {\n-                                        is_const_fn = true;\n                                         // const eval transmute calls only with the feature gate\n                                         if !self.tcx.features().const_transmute {\n                                             emit_feature_err(\n@@ -872,39 +1011,30 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                                     is_shuffle = true;\n                                 }\n \n+                                // no need to check feature gates, intrinsics are only callable\n+                                // from the libstd or with forever unstable feature gates\n                                 _ => {}\n                             }\n                         }\n                         _ => {\n-                            // In normal functions we only care about promotion.\n-                            if self.mode == Mode::Fn {\n-                                // Never promote const fn calls of\n-                                // functions without `#[rustc_promotable]`.\n-                                if self.tcx.is_promotable_const_fn(def_id) {\n-                                    is_const_fn = true;\n-                                    is_promotable_const_fn = true;\n-                                } else if self.tcx.is_const_fn(def_id) {\n-                                    is_const_fn = true;\n-                                }\n-                            } else {\n-                                // stable const fns or unstable const fns with their feature gate\n-                                // active\n+                            // In normal functions no calls are feature-gated.\n+                            if self.mode != Mode::Fn {\n                                 let unleash_miri = self\n                                     .tcx\n                                     .sess\n                                     .opts\n                                     .debugging_opts\n                                     .unleash_the_miri_inside_of_you;\n                                 if self.tcx.is_const_fn(def_id) || unleash_miri {\n-                                    is_const_fn = true;\n-                                } else if self.is_const_panic_fn(def_id) {\n+                                    // stable const fns or unstable const fns\n+                                    // with their feature gate active\n+                                    // FIXME(eddyb) move stability checks from `is_const_fn` here.\n+                                } else if self.qualifier().is_const_panic_fn(def_id) {\n                                     // Check the const_panic feature gate.\n                                     // FIXME: cannot allow this inside `allow_internal_unstable`\n                                     // because that would make `panic!` insta stable in constants,\n                                     // since the macro is marked with the attribute.\n-                                    if self.tcx.features().const_panic {\n-                                        is_const_fn = true;\n-                                    } else {\n+                                    if !self.tcx.features().const_panic {\n                                         // Don't allow panics in constants without the feature gate.\n                                         emit_feature_err(\n                                             &self.tcx.sess.parse_sess,\n@@ -919,10 +1049,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                                     // Check `#[unstable]` const fns or `#[rustc_const_unstable]`\n                                     // functions without the feature gate active in this crate in\n                                     // order to report a better error message than the one below.\n-                                    if self.span.allows_unstable(&feature.as_str()) {\n-                                        // `allow_internal_unstable` can make such calls stable.\n-                                        is_const_fn = true;\n-                                    } else {\n+                                    if !self.span.allows_unstable(&feature.as_str()) {\n                                         let mut err = self.tcx.sess.struct_span_err(self.span,\n                                             &format!(\"`{}` is not yet stable as a const fn\",\n                                                     self.tcx.item_path_str(def_id)));\n@@ -966,50 +1093,30 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                             }\n                         }\n                     }\n-                },\n+                }\n                 ty::FnPtr(_) => {\n                     if self.mode != Mode::Fn {\n                         let mut err = self.tcx.sess.struct_span_err(\n                             self.span,\n                             &format!(\"function pointers are not allowed in const fn\"));\n                         err.emit();\n                     }\n-                },\n+                }\n                 _ => {\n                     self.not_const();\n-                    return\n                 }\n             }\n \n-\n-            let constant_arguments = callee_def_id.and_then(|id| {\n-                args_required_const(self.tcx, id)\n-            });\n-            for (i, arg) in args.iter().enumerate() {\n-                self.nest(|this| {\n-                    this.visit_operand(arg, location);\n-                    if this.mode != Mode::Fn {\n-                        return\n-                    }\n-                    let candidate = Candidate::Argument { bb, index: i };\n-                    if is_shuffle && i == 2 {\n-                        if this.state.qualif.is_empty() {\n-                            debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n-                            this.promotion_candidates.push(candidate);\n-                        } else {\n-                            span_err!(this.tcx.sess, this.span, E0526,\n-                                      \"shuffle indices are not constant\");\n-                        }\n-                        return\n+            if self.mode == Mode::Fn {\n+                let constant_args = callee_def_id.and_then(|id| {\n+                    args_required_const(self.tcx, id)\n+                }).unwrap_or_default();\n+                for (i, arg) in args.iter().enumerate() {\n+                    if !(is_shuffle && i == 2 || constant_args.contains(&i)) {\n+                        continue;\n                     }\n \n-                    let constant_arguments = match constant_arguments.as_ref() {\n-                        Some(s) => s,\n-                        None => return,\n-                    };\n-                    if !constant_arguments.contains(&i) {\n-                        return\n-                    }\n+                    let candidate = Candidate::Argument { bb, index: i };\n                     // Since the argument is required to be constant,\n                     // we care about constness, not promotability.\n                     // If we checked for promotability, we'd miss out on\n@@ -1020,44 +1127,27 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     // which happens even without the user requesting it.\n                     // We can error out with a hard error if the argument is not\n                     // constant here.\n-                    if (this.state.qualif - Qualif::NOT_PROMOTABLE).is_empty() {\n+                    let arg_qualif = self.qualifier().qualify_operand(arg);\n+                    if (arg_qualif - Qualif::NOT_PROMOTABLE).is_empty() {\n                         debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n-                        this.promotion_candidates.push(candidate);\n+                        self.promotion_candidates.push(candidate);\n                     } else {\n-                        this.tcx.sess.span_err(this.span,\n-                            &format!(\"argument {} is required to be a constant\",\n-                                     i + 1));\n+                        if is_shuffle {\n+                            span_err!(self.tcx.sess, self.span, E0526,\n+                                      \"shuffle indices are not constant\");\n+                        } else {\n+                            self.tcx.sess.span_err(self.span,\n+                                &format!(\"argument {} is required to be a constant\",\n+                                         i + 1));\n+                        }\n                     }\n-                });\n-            }\n-\n-            // non-const fn calls\n-            if !is_const_fn {\n-                self.state.qualif = Qualif::NOT_CONST;\n-                if self.mode != Mode::Fn {\n-                    self.tcx.sess.delay_span_bug(\n-                        self.span,\n-                        \"should have reported an error about non-const fn calls in constants\",\n-                    )\n                 }\n             }\n \n-            if let Some((ref dest, _)) = *destination {\n-                // Avoid propagating irrelevant callee/argument qualifications.\n-                if self.state.qualif.intersects(Qualif::CONST_ERROR) {\n-                    self.state.qualif = Qualif::NOT_CONST;\n-                } else {\n-                    // Be conservative about the returned value of a const fn.\n-                    let tcx = self.tcx;\n-                    let ty = dest.ty(self.mir, tcx).to_ty(tcx);\n-                    if is_const_fn && !is_promotable_const_fn && self.mode == Mode::Fn {\n-                        self.state.qualif = Qualif::NOT_PROMOTABLE;\n-                    } else {\n-                        self.state.qualif = Qualif::empty();\n-                    }\n-                    self.add_type(ty);\n-                }\n-                self.assign(dest, location);\n+            // Check callee and argument operands.\n+            self.visit_operand(func, location);\n+            for arg in args {\n+                self.visit_operand(arg, location);\n             }\n         } else if let TerminatorKind::Drop { location: ref place, .. } = *kind {\n             self.super_terminator_kind(bb, kind, location);\n@@ -1068,7 +1158,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place::Local(local) = *place {\n-                    let local_needs_drop = self.state.local_qualif[local]\n+                    let local_needs_drop = self.local_qualif[local]\n                         .map_or(true, |q| q.contains(Qualif::NEEDS_DROP));\n                     if local_needs_drop {\n                         Some(self.mir.local_decls[local].source_info.span)\n@@ -1103,9 +1193,78 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         debug!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n-        self.visit_rvalue(rvalue, location);\n+        let mut qualif = self.qualifier().qualify_rvalue(rvalue);\n+\n+        if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n+            // Getting `MUTABLE_INTERIOR` from `qualify_rvalue` means\n+            // the borrowed place is disallowed from being borrowed,\n+            // due to either a mutable borrow (with some exceptions),\n+            // or an shared borrow of a value with interior mutability.\n+            // Then `MUTABLE_INTERIOR` is replaced with `NOT_CONST`,\n+            // to avoid duplicate errors (e.g. from reborrowing).\n+            if qualif.contains(Qualif::MUTABLE_INTERIOR) {\n+                qualif = (qualif - Qualif::MUTABLE_INTERIOR) | Qualif::NOT_CONST;\n+\n+                if self.mode != Mode::Fn {\n+                    if let BorrowKind::Mut { .. } = kind {\n+                        let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n+                                                       \"references in {}s may only refer \\\n+                                                        to immutable values\", self.mode);\n+                        err.span_label(self.span, format!(\"{}s require immutable values\",\n+                                                            self.mode));\n+                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                            err.note(\"References in statics and constants may only refer to \\\n+                                      immutable values.\\n\\n\\\n+                                      Statics are shared everywhere, and if they refer to \\\n+                                      mutable data one might violate memory safety since \\\n+                                      holding multiple mutable references to shared data is \\\n+                                      not allowed.\\n\\n\\\n+                                      If you really want global mutable state, try using \\\n+                                      static mut or a global UnsafeCell.\");\n+                        }\n+                        err.emit();\n+                    } else {\n+                        span_err!(self.tcx.sess, self.span, E0492,\n+                                  \"cannot borrow a constant which may contain \\\n+                                   interior mutability, create a static instead\");\n+                    }\n+                }\n+            } else {\n+                // We might have a candidate for promotion.\n+                let candidate = Candidate::Ref(location);\n+                // We can only promote interior borrows of promotable temps.\n+                let mut place = place;\n+                while let Place::Projection(ref proj) = *place {\n+                    if proj.elem == ProjectionElem::Deref {\n+                        break;\n+                    }\n+                    place = &proj.base;\n+                }\n+                debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n+                if let Place::Local(local) = *place {\n+                    if self.mir.local_kind(local) == LocalKind::Temp {\n+                        debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n+                        if let Some(qualif) = self.local_qualif[local] {\n+                            // The borrowed place doesn't have `MUTABLE_INTERIOR`\n+                            // (from `qualify_rvalue`), so we can safely ignore\n+                            // `MUTABLE_INTERIOR` from the local's qualifications.\n+                            // This allows borrowing fields which don't have\n+                            // `MUTABLE_INTERIOR`, from a type that does, e.g.:\n+                            // `let _: &'static _ = &(Cell::new(1), 2).1;`\n+                            debug!(\"qualify_consts: promotion candidate: qualif={:?}\", qualif);\n+                            if (qualif - Qualif::MUTABLE_INTERIOR).is_empty() {\n+                                debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n+                                self.promotion_candidates.push(candidate);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.assign(dest, qualif, location);\n \n-        self.assign(dest, location);\n+        self.visit_rvalue(rvalue, location);\n     }\n \n     fn visit_source_info(&mut self, source_info: &SourceInfo) {\n@@ -1115,30 +1274,28 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx, 'tcx> {\n \n     fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>, location: Location) {\n         debug!(\"visit_statement: bb={:?} statement={:?} location={:?}\", bb, statement, location);\n-        self.nest(|this| {\n-            this.visit_source_info(&statement.source_info);\n-            match statement.kind {\n-                StatementKind::Assign(ref place, ref rvalue) => {\n-                    this.visit_assign(bb, place, rvalue, location);\n-                }\n-                StatementKind::FakeRead(..) |\n-                StatementKind::SetDiscriminant { .. } |\n-                StatementKind::StorageLive(_) |\n-                StatementKind::StorageDead(_) |\n-                StatementKind::InlineAsm {..} |\n-                StatementKind::Retag { .. } |\n-                StatementKind::AscribeUserType(..) |\n-                StatementKind::Nop => {}\n+        match statement.kind {\n+            StatementKind::Assign(..) => {\n+                self.super_statement(bb, statement, location);\n             }\n-        });\n+            // FIXME(eddyb) should these really do nothing?\n+            StatementKind::FakeRead(..) |\n+            StatementKind::SetDiscriminant { .. } |\n+            StatementKind::StorageLive(_) |\n+            StatementKind::StorageDead(_) |\n+            StatementKind::InlineAsm {..} |\n+            StatementKind::Retag { .. } |\n+            StatementKind::AscribeUserType(..) |\n+            StatementKind::Nop => {}\n+        }\n     }\n \n     fn visit_terminator(&mut self,\n                         bb: BasicBlock,\n                         terminator: &Terminator<'tcx>,\n                         location: Location) {\n         debug!(\"visit_terminator: bb={:?} terminator={:?} location={:?}\", bb, terminator, location);\n-        self.nest(|this| this.super_terminator(bb, terminator, location));\n+        self.super_terminator(bb, terminator, location);\n     }\n }\n "}, {"sha": "0477f06010b0277c1df26357ab05b90c24eafefa", "filename": "src/test/ui/error-codes/E0017.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr?ref=f6d1e9790c2d6d8922dc25d03817b93893bfcff8", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n    |                              ^^^^^^ constants require immutable values\n \n-error: cannot mutate statics in the initializer of another static\n+error[E0017]: references in statics may only refer to immutable values\n   --> $DIR/E0017.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^\n+   |                                       ^^^^^^ statics require immutable values\n \n-error[E0017]: references in statics may only refer to immutable values\n+error: cannot mutate statics in the initializer of another static\n   --> $DIR/E0017.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^ statics require immutable values\n+   |                                       ^^^^^^\n \n error[E0596]: cannot borrow immutable static item `X` as mutable\n   --> $DIR/E0017.rs:5:39"}, {"sha": "cc202ec912e96b2665d592910733deabc9b65ccb", "filename": "src/test/ui/error-codes/E0017.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr?ref=f6d1e9790c2d6d8922dc25d03817b93893bfcff8", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n    |                              ^^^^^^ constants require immutable values\n \n-error: cannot mutate statics in the initializer of another static\n+error[E0017]: references in statics may only refer to immutable values\n   --> $DIR/E0017.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^\n+   |                                       ^^^^^^ statics require immutable values\n \n-error[E0017]: references in statics may only refer to immutable values\n+error: cannot mutate statics in the initializer of another static\n   --> $DIR/E0017.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^ statics require immutable values\n+   |                                       ^^^^^^\n \n error[E0596]: cannot borrow immutable static item as mutable\n   --> $DIR/E0017.rs:5:44"}, {"sha": "a898d60a98595c9d81380eeba3cee165ccf12838", "filename": "src/test/ui/error-codes/E0388.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr?ref=f6d1e9790c2d6d8922dc25d03817b93893bfcff8", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n    |                              ^^^^^^ constants require immutable values\n \n-error: cannot mutate statics in the initializer of another static\n+error[E0017]: references in statics may only refer to immutable values\n   --> $DIR/E0388.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^\n+   |                                       ^^^^^^ statics require immutable values\n \n-error[E0017]: references in statics may only refer to immutable values\n+error: cannot mutate statics in the initializer of another static\n   --> $DIR/E0388.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^ statics require immutable values\n+   |                                       ^^^^^^\n \n error[E0596]: cannot borrow immutable static item `X` as mutable\n   --> $DIR/E0388.rs:5:39"}, {"sha": "f641830ae9ff23076c40f76efcb3ca639fdc531a", "filename": "src/test/ui/error-codes/E0388.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr?ref=f6d1e9790c2d6d8922dc25d03817b93893bfcff8", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n    |                              ^^^^^^ constants require immutable values\n \n-error: cannot mutate statics in the initializer of another static\n+error[E0017]: references in statics may only refer to immutable values\n   --> $DIR/E0388.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^\n+   |                                       ^^^^^^ statics require immutable values\n \n-error[E0017]: references in statics may only refer to immutable values\n+error: cannot mutate statics in the initializer of another static\n   --> $DIR/E0388.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^ statics require immutable values\n+   |                                       ^^^^^^\n \n error[E0596]: cannot borrow immutable static item as mutable\n   --> $DIR/E0388.rs:5:44"}, {"sha": "95ef2b1b010087121b6eed5f79718bae7633e862", "filename": "src/test/ui/issues/issue-17718-const-bad-values.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1e9790c2d6d8922dc25d03817b93893bfcff8/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr?ref=f6d1e9790c2d6d8922dc25d03817b93893bfcff8", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const C1: &'static mut [usize] = &mut [];\n    |                                  ^^^^^^^ constants require immutable values\n \n-error[E0013]: constants cannot refer to statics, use a constant instead\n+error[E0017]: references in constants may only refer to immutable values\n   --> $DIR/issue-17718-const-bad-values.rs:5:41\n    |\n LL | const C2: &'static mut usize = unsafe { &mut S };\n-   |                                         ^^^^^^\n+   |                                         ^^^^^^ constants require immutable values\n \n-error[E0017]: references in constants may only refer to immutable values\n+error[E0013]: constants cannot refer to statics, use a constant instead\n   --> $DIR/issue-17718-const-bad-values.rs:5:41\n    |\n LL | const C2: &'static mut usize = unsafe { &mut S };\n-   |                                         ^^^^^^ constants require immutable values\n+   |                                         ^^^^^^\n \n error: aborting due to 3 previous errors\n "}]}