{"sha": "a957a36ddcb1a735719a96f1fb35c9ac0d604bf3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NTdhMzZkZGNiMWE3MzU3MTlhOTZmMWZiMzVjOWFjMGQ2MDRiZjM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-01-07T18:36:25Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-01-07T18:36:25Z"}, "message": "tweak merging to give up if we don't make any progress", "tree": {"sha": "4c1910c4487d1e58c3e97ab0370f2f1a5d4de07c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c1910c4487d1e58c3e97ab0370f2f1a5d4de07c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a957a36ddcb1a735719a96f1fb35c9ac0d604bf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a957a36ddcb1a735719a96f1fb35c9ac0d604bf3", "html_url": "https://github.com/rust-lang/rust/commit/a957a36ddcb1a735719a96f1fb35c9ac0d604bf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a957a36ddcb1a735719a96f1fb35c9ac0d604bf3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17d11ebe6e9599d804c0378900b92a5a8054aec3", "url": "https://api.github.com/repos/rust-lang/rust/commits/17d11ebe6e9599d804c0378900b92a5a8054aec3", "html_url": "https://github.com/rust-lang/rust/commit/17d11ebe6e9599d804c0378900b92a5a8054aec3"}], "stats": {"total": 40, "additions": 26, "deletions": 14}, "files": [{"sha": "48cbc57f0ebce263083178cfb9991ff8bb29a88c", "filename": "src/range_map.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a957a36ddcb1a735719a96f1fb35c9ac0d604bf3/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a957a36ddcb1a735719a96f1fb35c9ac0d604bf3/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=a957a36ddcb1a735719a96f1fb35c9ac0d604bf3", "patch": "@@ -145,7 +145,12 @@ impl<T> RangeMap<T> {\n                 // is doing the same linear scan anyway -- no increase in complexity.\n                 // We combine this scan with a scan for duplicates that we can merge, to reduce\n                 // the number of elements.\n+                // We stop searching after the first \"block\" of size 1, to avoid spending excessive\n+                // amounts of time on the merging.\n                 let mut equal_since_idx = first_idx;\n+                // Once we see too many non-mergeable blocks, we stop.\n+                // The initial value is chosen via... magic.  Benchmarking and magic.\n+                let mut successful_merge_count = 3usize;\n                 let mut end_idx = first_idx; // when the loop is done, this is the first excluded element.\n                 loop {\n                     // Compute if `end` is the last element we need to look at.\n@@ -154,21 +159,28 @@ impl<T> RangeMap<T> {\n                     end_idx += 1;\n                     debug_assert!(done || end_idx < self.v.len(), \"iter_mut: end-offset {} is out-of-bounds\", offset+len);\n                     // see if we want to merge everything in `equal_since..end` (exclusive at the end!)\n-                    if done || self.v[end_idx].data != self.v[equal_since_idx].data {\n-                        // Everything in `equal_since..end` was equal.  Make them just one element covering\n-                        // the entire range.\n-                        let equal_elems = end_idx - equal_since_idx; // number of equal elements\n-                        if equal_elems > 1 {\n-                            // Adjust the range of the first element to cover all of them.\n-                            let equal_until = self.v[end_idx - 1].range.end; // end of range of last of the equal elements\n-                            self.v[equal_since_idx].range.end = equal_until;\n-                            // Delete the rest of them.\n-                            self.v.splice(equal_since_idx+1..end_idx, std::iter::empty());\n-                            // Adjust `end_idx` because we made the list shorter.\n-                            end_idx -= (equal_elems - 1);\n+                    if successful_merge_count > 0 {\n+                        if done || self.v[end_idx].data != self.v[equal_since_idx].data {\n+                            // Everything in `equal_since..end` was equal.  Make them just one element covering\n+                            // the entire range.\n+                            let removed_elems = end_idx - equal_since_idx - 1; // number of elements that we would remove\n+                            if removed_elems > 0 {\n+                                // Adjust the range of the first element to cover all of them.\n+                                let equal_until = self.v[end_idx - 1].range.end; // end of range of last of the equal elements\n+                                self.v[equal_since_idx].range.end = equal_until;\n+                                // Delete the rest of them.\n+                                self.v.splice(equal_since_idx+1..end_idx, std::iter::empty());\n+                                // Adjust `end_idx` because we made the list shorter.\n+                                end_idx -= removed_elems;\n+                                // adjust the count for the cutoff\n+                                successful_merge_count += removed_elems;\n+                            } else {\n+                                // adjust the count for the cutoff\n+                                successful_merge_count -= 1;\n+                            }\n+                            // Go on scanning for the next block starting here.\n+                            equal_since_idx = end_idx;\n                         }\n-                        // Go on scanning.\n-                        equal_since_idx = end_idx;\n                     }\n                     // Leave loop if this is the last element.\n                     if done {"}]}