{"sha": "74815249787076f0e3cd9c8dc72553f73e612856", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ODE1MjQ5Nzg3MDc2ZjBlM2NkOWM4ZGM3MjU1M2Y3M2U2MTI4NTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-26T05:24:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-26T05:24:57Z"}, "message": "auto merge of #5528 : thestinger/rust/find_mut, r=brson\n\nThis currently requires workarounds for the borrow checker not being flow-sensitive for `LinearMap` and `TrieMap`, but it can already be expressed for `TreeMap` and `SmallIntMap` without that.", "tree": {"sha": "c4a21aa3f8b47b13b47c632ea93f3368ed4a5c28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4a21aa3f8b47b13b47c632ea93f3368ed4a5c28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74815249787076f0e3cd9c8dc72553f73e612856", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74815249787076f0e3cd9c8dc72553f73e612856", "html_url": "https://github.com/rust-lang/rust/commit/74815249787076f0e3cd9c8dc72553f73e612856", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74815249787076f0e3cd9c8dc72553f73e612856/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47ddb59b802faa25b733416caf3d1b5588ab60a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/47ddb59b802faa25b733416caf3d1b5588ab60a3", "html_url": "https://github.com/rust-lang/rust/commit/47ddb59b802faa25b733416caf3d1b5588ab60a3"}, {"sha": "e8bf0a4a49405cfde21910af889d626fbdd5bd52", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8bf0a4a49405cfde21910af889d626fbdd5bd52", "html_url": "https://github.com/rust-lang/rust/commit/e8bf0a4a49405cfde21910af889d626fbdd5bd52"}], "stats": {"total": 144, "additions": 135, "deletions": 9}, "files": [{"sha": "e20821b919b6cf24ffcf19bc12830537c3290d50", "filename": "src/libcore/container.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74815249787076f0e3cd9c8dc72553f73e612856/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74815249787076f0e3cd9c8dc72553f73e612856/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=74815249787076f0e3cd9c8dc72553f73e612856", "patch": "@@ -38,9 +38,12 @@ pub trait Map<K, V>: Mutable {\n     /// Iterate over the map and mutate the contained values\n     fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n \n-    /// Return the value corresponding to the key in the map\n+    /// Return a reference to the value corresponding to the key\n     fn find(&self, key: &K) -> Option<&'self V>;\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    fn find_mut(&mut self, key: &K) -> Option<&'self mut V>;\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map."}, {"sha": "8c290553a45994608b6ba937c7ebec7197c6fcde", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/74815249787076f0e3cd9c8dc72553f73e612856/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74815249787076f0e3cd9c8dc72553f73e612856/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=74815249787076f0e3cd9c8dc72553f73e612856", "patch": "@@ -24,6 +24,7 @@ pub mod linear {\n     use rand;\n     use uint;\n     use vec;\n+    use util::unreachable;\n \n     static INITIAL_CAPACITY: uint = 32u; // 2^5\n \n@@ -192,6 +193,14 @@ pub mod linear {\n             }\n         }\n \n+        #[inline(always)]\n+        fn mut_value_for_bucket(&mut self, idx: uint) -> &'self mut V {\n+            match self.buckets[idx] {\n+                Some(ref mut bkt) => &mut bkt.value,\n+                None => unreachable()\n+            }\n+        }\n+\n         /// Inserts the key value pair into the buckets.\n         /// Assumes that there will be a bucket.\n         /// True if there was no previous entry with that key\n@@ -338,14 +347,25 @@ pub mod linear {\n             }\n         }\n \n-        /// Return the value corresponding to the key in the map\n+        /// Return a reference to the value corresponding to the key\n         fn find(&self, k: &K) -> Option<&'self V> {\n             match self.bucket_for_key(k) {\n                 FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n                 TableFull | FoundHole(_) => None,\n             }\n         }\n \n+        /// Return a mutable reference to the value corresponding to the key\n+        fn find_mut(&mut self, k: &K) -> Option<&'self mut V> {\n+            let idx = match self.bucket_for_key(k) {\n+                FoundEntry(idx) => idx,\n+                TableFull | FoundHole(_) => return None\n+            };\n+            unsafe {  // FIXME(#4903)---requires flow-sensitive borrow checker\n+                Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n+            }\n+        }\n+\n         /// Insert a key-value pair into the map. An existing value for a\n         /// key is replaced by the new value. Return true if the key did\n         /// not already exist in the map.\n@@ -655,6 +675,19 @@ pub mod linear {\n             fail_unless!(*m.get(&2) == 4);\n         }\n \n+        #[test]\n+        fn test_find_mut() {\n+            let mut m = LinearMap::new();\n+            fail_unless!(m.insert(1, 12));\n+            fail_unless!(m.insert(2, 8));\n+            fail_unless!(m.insert(5, 14));\n+            let new = 100;\n+            match m.find_mut(&5) {\n+                None => fail!(), Some(x) => *x = new\n+            }\n+            assert_eq!(m.find(&5), Some(&new));\n+        }\n+\n         #[test]\n         pub fn test_insert_overwrite() {\n             let mut m = LinearMap::new();"}, {"sha": "012e00556743478db47cd3e4ed7ab4ef084528b0", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/74815249787076f0e3cd9c8dc72553f73e612856/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74815249787076f0e3cd9c8dc72553f73e612856/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=74815249787076f0e3cd9c8dc72553f73e612856", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A radix trie for storing integers in sorted order\n+//! An ordered map and set for integer keys implemented as a radix trie\n \n use prelude::*;\n \n@@ -90,7 +90,7 @@ impl<T> Map<uint, T> for TrieMap<T> {\n         self.root.mutate_values(f);\n     }\n \n-    /// Return the value corresponding to the key in the map\n+    /// Return a reference to the value corresponding to the key\n     #[inline(hint)]\n     fn find(&self, key: &uint) -> Option<&'self T> {\n         let mut node: &'self TrieNode<T> = &self.root;\n@@ -111,6 +111,12 @@ impl<T> Map<uint, T> for TrieMap<T> {\n         }\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[inline(always)]\n+    fn find_mut(&mut self, key: &uint) -> Option<&'self mut T> {\n+        find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -276,6 +282,17 @@ fn chunk(n: uint, idx: uint) -> uint {\n     (n >> sh) & MASK\n }\n \n+fn find_mut<T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n+    unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+        (match *child {\n+            External(_, ref value) => Some(cast::transmute_mut(value)),\n+            Internal(ref x) => find_mut(cast::transmute_mut(&x.children[chunk(key, idx)]),\n+                                        key, idx + 1),\n+            Nothing => None\n+        }).map_consume(|x| cast::transmute_mut_region(x))\n+    }\n+}\n+\n fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,\n              idx: uint) -> bool {\n     let mut tmp = Nothing;\n@@ -357,8 +374,22 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use core::option::{Some, None};\n     use uint;\n \n+    #[test]\n+    fn test_find_mut() {\n+        let mut m = TrieMap::new();\n+        fail_unless!(m.insert(1, 12));\n+        fail_unless!(m.insert(2, 8));\n+        fail_unless!(m.insert(5, 14));\n+        let new = 100;\n+        match m.find_mut(&5) {\n+            None => fail!(), Some(x) => *x = new\n+        }\n+        assert_eq!(m.find(&5), Some(&new));\n+    }\n+\n     #[test]\n     fn test_step() {\n         let mut trie = TrieMap::new();"}, {"sha": "4ad8d38b072b15d48dc39397fd0336a7f46c2d60", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/74815249787076f0e3cd9c8dc72553f73e612856/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74815249787076f0e3cd9c8dc72553f73e612856/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=74815249787076f0e3cd9c8dc72553f73e612856", "patch": "@@ -86,7 +86,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         self.each(|&(_, v)| blk(v))\n     }\n \n-    /// Visit all key-value pairs in order\n+    /// Iterate over the map and mutate the contained values\n     fn mutate_values(&mut self, it: &fn(&uint, &'self mut V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n@@ -96,7 +96,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n-    /// Iterate over the map and mutate the contained values\n+    /// Return a reference to the value corresponding to the key\n     fn find(&self, key: &uint) -> Option<&'self V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -108,6 +108,18 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    fn find_mut(&mut self, key: &uint) -> Option<&'self mut V> {\n+        if *key < self.v.len() {\n+            match self.v[*key] {\n+              Some(ref mut value) => Some(value),\n+              None => None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -160,6 +172,20 @@ pub impl<V:Copy> SmallIntMap<V> {\n #[cfg(test)]\n mod tests {\n     use super::SmallIntMap;\n+    use core::prelude::*;\n+\n+    #[test]\n+    fn test_find_mut() {\n+        let mut m = SmallIntMap::new();\n+        fail_unless!(m.insert(1, 12));\n+        fail_unless!(m.insert(2, 8));\n+        fail_unless!(m.insert(5, 14));\n+        let new = 100;\n+        match m.find_mut(&5) {\n+            None => fail!(), Some(x) => *x = new\n+        }\n+        assert_eq!(m.find(&5), Some(&new));\n+    }\n \n     #[test]\n     fn test_len() {"}, {"sha": "fccf58ddb6f74a79b81553acc6fd9ccddcba30a0", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/74815249787076f0e3cd9c8dc72553f73e612856/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74815249787076f0e3cd9c8dc72553f73e612856/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=74815249787076f0e3cd9c8dc72553f73e612856", "patch": "@@ -135,7 +135,7 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n         mutate_values(&mut self.root, f);\n     }\n \n-    /// Return the value corresponding to the key in the map\n+    /// Return a reference to the value corresponding to the key\n     fn find(&self, key: &K) -> Option<&'self V> {\n         let mut current: &'self Option<~TreeNode<K, V>> = &self.root;\n         loop {\n@@ -152,6 +152,12 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n         }\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[inline(always)]\n+    fn find_mut(&mut self, key: &K) -> Option<&'self mut V> {\n+        find_mut(&mut self.root, key)\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -584,8 +590,20 @@ fn split<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     }\n }\n \n-fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n-                          value: V) -> bool {\n+fn find_mut<K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>, key: &K) -> Option<&'r mut V> {\n+    match *node {\n+      Some(ref mut x) => {\n+        match key.cmp(&x.key) {\n+          Less => find_mut(&mut x.left, key),\n+          Greater => find_mut(&mut x.right, key),\n+          Equal => Some(&mut x.value),\n+        }\n+      }\n+      None => None\n+    }\n+}\n+\n+fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>, key: K, value: V) -> bool {\n     match *node {\n       Some(ref mut save) => {\n         match key.cmp(&save.key) {\n@@ -716,6 +734,19 @@ mod test_treemap {\n         fail_unless!(m.find(&2) == None);\n     }\n \n+    #[test]\n+    fn test_find_mut() {\n+        let mut m = TreeMap::new();\n+        fail_unless!(m.insert(1, 12));\n+        fail_unless!(m.insert(2, 8));\n+        fail_unless!(m.insert(5, 14));\n+        let new = 100;\n+        match m.find_mut(&5) {\n+          None => fail!(), Some(x) => *x = new\n+        }\n+        assert_eq!(m.find(&5), Some(&new));\n+    }\n+\n     #[test]\n     fn insert_replace() {\n         let mut m = TreeMap::new();"}, {"sha": "281d520be0f60a211403f577db5392ccfd9d074f", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74815249787076f0e3cd9c8dc72553f73e612856/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74815249787076f0e3cd9c8dc72553f73e612856/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=74815249787076f0e3cd9c8dc72553f73e612856", "patch": "@@ -98,6 +98,8 @@ impl<T> Map<int, T> for cat<T> {\n         }\n     }\n \n+    fn find_mut(&mut self, k: &int) -> Option<&'self mut T> { fail!() }\n+\n     fn remove(&mut self, k: &int) -> bool {\n         if self.find(k).is_some() {\n             self.meows -= *k; true"}]}