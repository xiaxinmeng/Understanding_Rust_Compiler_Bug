{"sha": "69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "node_id": "C_kwDOAAsO6NoAKDY5ZTViZDVhMjUzMmNmZTQ3ZTU1MTdkNzIwZWI3MGNiZjNmNGE5MDg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-10T21:24:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-10T21:24:11Z"}, "message": "Merge #11676\n\n11676: internal: Expand into pseudo-derive attribute expansions in completions r=Veykril a=Veykril\n\nWith this we now properly handle qualified path completions in derives\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "0260d414a64e281a5c0496380d492dc3fec910cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0260d414a64e281a5c0496380d492dc3fec910cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiKmx8CRBK7hj4Ov3rIwAA/54IABvsVvsWGjiR0Kdo47zdnRoS\n1mgB0uh8YDKmfrdSR4AfIZ2zLsYj909V/gLmlt1NCB1tuwJ32FhuVCs+lfzzV6Sf\njDi9USZdgueH+g6ce09Tdql/N7EDVxFcHep7SL0UNDp86UuitqMV8Xd8ki5AMh/6\nAJvXXaviTRWgMtG8Clzb4ekML4bTXUL2eiwtO2SC4hz2cM6zyw8qq7zekS87KoUK\nEKbmQNDnDIqvXmp8X0KdYeTS1YWDe1XqO6u+8xGrfx5+kSux0r9/pUiy5omjdpBU\nArMflHje0YVTB4aWVko1gFo4lslkcxHsVZGYrR6rRzhHeFGyYpe/nNrSEBWcdVM=\n=wAeK\n-----END PGP SIGNATURE-----\n", "payload": "tree 0260d414a64e281a5c0496380d492dc3fec910cb\nparent e963443a0d79ab4704e9fcb44b342e0de2f1b05c\nparent 6c8c02f625165bb397068ca0adecd93f49289d6b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1646947451 +0000\ncommitter GitHub <noreply@github.com> 1646947451 +0000\n\nMerge #11676\n\n11676: internal: Expand into pseudo-derive attribute expansions in completions r=Veykril a=Veykril\n\nWith this we now properly handle qualified path completions in derives\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "html_url": "https://github.com/rust-lang/rust/commit/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e963443a0d79ab4704e9fcb44b342e0de2f1b05c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e963443a0d79ab4704e9fcb44b342e0de2f1b05c", "html_url": "https://github.com/rust-lang/rust/commit/e963443a0d79ab4704e9fcb44b342e0de2f1b05c"}, {"sha": "6c8c02f625165bb397068ca0adecd93f49289d6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c8c02f625165bb397068ca0adecd93f49289d6b", "html_url": "https://github.com/rust-lang/rust/commit/6c8c02f625165bb397068ca0adecd93f49289d6b"}], "stats": {"total": 862, "additions": 478, "deletions": 384}, "files": [{"sha": "6e3285fd4ff006f46a5661f9c7c75e1241e8f491", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -18,8 +18,8 @@ use syntax::SmolStr;\n \n use crate::{\n     Adt, Const, ConstParam, Enum, Field, Function, GenericParam, HasCrate, HasVisibility,\n-    LifetimeParam, Module, Static, Struct, Trait, TyBuilder, Type, TypeAlias, TypeOrConstParam,\n-    TypeParam, Union, Variant,\n+    LifetimeParam, Macro, Module, Static, Struct, Trait, TyBuilder, Type, TypeAlias,\n+    TypeOrConstParam, TypeParam, Union, Variant,\n };\n \n impl HirDisplay for Function {\n@@ -509,3 +509,14 @@ impl HirDisplay for Module {\n         }\n     }\n }\n+\n+impl HirDisplay for Macro {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match self.id {\n+            hir_def::MacroId::Macro2Id(_) => write!(f, \"macro\"),\n+            hir_def::MacroId::MacroRulesId(_) => write!(f, \"macro_rules!\"),\n+            hir_def::MacroId::ProcMacroId(_) => write!(f, \"proc_macro\"),\n+        }?;\n+        write!(f, \" {}\", self.name(f.db))\n+    }\n+}"}, {"sha": "a90120a46763e0718fd0be996a5f5ff3f878d341", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -1811,6 +1811,10 @@ impl Macro {\n     pub fn is_attr(&self, db: &dyn HirDatabase) -> bool {\n         matches!(self.kind(db), MacroKind::Attr)\n     }\n+\n+    pub fn is_derive(&self, db: &dyn HirDatabase) -> bool {\n+        matches!(self.kind(db), MacroKind::Derive)\n+    }\n }\n \n impl HasVisibility for Macro {"}, {"sha": "45544559eabaae7d1a4cc6369d2745d968dddb0b", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -151,6 +151,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.expand_attr_macro(item)\n     }\n \n+    pub fn expand_derive_as_pseudo_attr_macro(&self, attr: &ast::Attr) -> Option<SyntaxNode> {\n+        self.imp.expand_derive_as_pseudo_attr_macro(attr)\n+    }\n+\n     pub fn resolve_derive_macro(&self, derive: &ast::Attr) -> Option<Vec<Option<Macro>>> {\n         self.imp.resolve_derive_macro(derive)\n     }\n@@ -185,6 +189,19 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.speculative_expand_attr(actual_macro_call, speculative_args, token_to_map)\n     }\n \n+    pub fn speculative_expand_derive_as_pseudo_attr_macro(\n+        &self,\n+        actual_macro_call: &ast::Attr,\n+        speculative_args: &ast::Attr,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        self.imp.speculative_expand_derive_as_pseudo_attr_macro(\n+            actual_macro_call,\n+            speculative_args,\n+            token_to_map,\n+        )\n+    }\n+\n     /// Descend the token into macrocalls to its first mapped counterpart.\n     pub fn descend_into_macros_single(&self, token: SyntaxToken) -> SyntaxToken {\n         self.imp.descend_into_macros_single(token)\n@@ -438,9 +455,16 @@ impl<'db> SemanticsImpl<'db> {\n     fn expand_attr_macro(&self, item: &ast::Item) -> Option<SyntaxNode> {\n         let src = self.wrap_node_infile(item.clone());\n         let macro_call_id = self.with_ctx(|ctx| ctx.item_to_macro_call(src))?;\n-        let file_id = macro_call_id.as_file();\n-        let node = self.parse_or_expand(file_id)?;\n-        Some(node)\n+        self.parse_or_expand(macro_call_id.as_file())\n+    }\n+\n+    fn expand_derive_as_pseudo_attr_macro(&self, attr: &ast::Attr) -> Option<SyntaxNode> {\n+        let src = self.wrap_node_infile(attr.clone());\n+        let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n+        let call_id = self.with_ctx(|ctx| {\n+            ctx.attr_to_derive_macro_call(src.with_value(&adt), src).map(|(_, it, _)| it)\n+        })?;\n+        self.parse_or_expand(call_id.as_file())\n     }\n \n     fn resolve_derive_macro(&self, attr: &ast::Attr) -> Option<Vec<Option<Macro>>> {\n@@ -533,6 +557,25 @@ impl<'db> SemanticsImpl<'db> {\n         )\n     }\n \n+    fn speculative_expand_derive_as_pseudo_attr_macro(\n+        &self,\n+        actual_macro_call: &ast::Attr,\n+        speculative_args: &ast::Attr,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        let attr = self.wrap_node_infile(actual_macro_call.clone());\n+        let adt = actual_macro_call.syntax().parent().and_then(ast::Adt::cast)?;\n+        let macro_call_id = self.with_ctx(|ctx| {\n+            ctx.attr_to_derive_macro_call(attr.with_value(&adt), attr).map(|(_, it, _)| it)\n+        })?;\n+        hir_expand::db::expand_speculative(\n+            self.db.upcast(),\n+            macro_call_id,\n+            speculative_args.syntax(),\n+            token_to_map,\n+        )\n+    }\n+\n     // This might not be the correct way to do this, but it works for now\n     fn descend_node_into_attributes<N: AstNode>(&self, node: N) -> SmallVec<[N; 1]> {\n         let mut res = smallvec![];"}, {"sha": "0c886ac4da9dbc3b0d67f65fe500f178e8feb450", "filename": "crates/hir_expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -1,7 +1,5 @@\n //! Builtin attributes.\n \n-use itertools::Itertools;\n-\n use crate::{db::AstDatabase, name, ExpandResult, MacroCallId, MacroCallKind};\n \n macro_rules! register_builtin {\n@@ -98,10 +96,16 @@ fn derive_attr_expand(\n ) -> ExpandResult<tt::Subtree> {\n     let loc = db.lookup_intern_macro_call(id);\n     let derives = match &loc.kind {\n-        MacroCallKind::Attr { attr_args, .. } => &attr_args.0,\n-        _ => return ExpandResult::ok(tt.clone()),\n+        MacroCallKind::Attr { attr_args, is_derive: true, .. } => &attr_args.0,\n+        _ => return ExpandResult::ok(Default::default()),\n     };\n+    pseudo_derive_attr_expansion(tt, derives)\n+}\n \n+pub fn pseudo_derive_attr_expansion(\n+    tt: &tt::Subtree,\n+    args: &tt::Subtree,\n+) -> ExpandResult<tt::Subtree> {\n     let mk_leaf = |char| {\n         tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n             char,\n@@ -111,21 +115,12 @@ fn derive_attr_expand(\n     };\n \n     let mut token_trees = Vec::new();\n-    for (comma, group) in &derives\n-        .token_trees\n-        .iter()\n-        .filter_map(|tt| match tt {\n-            tt::TokenTree::Leaf(l) => Some(l),\n-            tt::TokenTree::Subtree(_) => None,\n-        })\n-        .group_by(|l| matches!(l, tt::Leaf::Punct(tt::Punct { char: ',', .. })))\n+    for tt in (&args.token_trees)\n+        .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: ',', .. }))))\n     {\n-        if comma {\n-            continue;\n-        }\n         token_trees.push(mk_leaf('#'));\n         token_trees.push(mk_leaf('['));\n-        token_trees.extend(group.cloned().map(tt::TokenTree::Leaf));\n+        token_trees.extend(tt.iter().cloned());\n         token_trees.push(mk_leaf(']'));\n     }\n     token_trees.push(mk_leaf('('));"}, {"sha": "9fe414de264ee53e9a9d065219aab7f281941527", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -14,10 +14,10 @@ use syntax::{\n };\n \n use crate::{\n-    ast_id_map::AstIdMap, fixup, hygiene::HygieneFrame, BuiltinAttrExpander, BuiltinDeriveExpander,\n-    BuiltinFnLikeExpander, ExpandError, ExpandResult, ExpandTo, HirFileId, HirFileIdRepr,\n-    MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile,\n-    ProcMacroExpander,\n+    ast_id_map::AstIdMap, builtin_attr_macro::pseudo_derive_attr_expansion, fixup,\n+    hygiene::HygieneFrame, BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n+    ExpandError, ExpandResult, ExpandTo, HirFileId, HirFileIdRepr, MacroCallId, MacroCallKind,\n+    MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -161,14 +161,16 @@ pub fn expand_speculative(\n     );\n \n     let (attr_arg, token_id) = match loc.kind {\n-        MacroCallKind::Attr { invoc_attr_index, .. } => {\n-            // Attributes may have an input token tree, build the subtree and map for this as well\n-            // then try finding a token id for our token if it is inside this input subtree.\n-            let item = ast::Item::cast(speculative_args.clone())?;\n-            let attr = item\n-                .doc_comments_and_attrs()\n-                .nth(invoc_attr_index as usize)\n-                .and_then(Either::left)?;\n+        MacroCallKind::Attr { invoc_attr_index, is_derive, .. } => {\n+            let attr = if is_derive {\n+                // for pseudo-derive expansion we actually pass the attribute itself only\n+                ast::Attr::cast(speculative_args.clone())\n+            } else {\n+                // Attributes may have an input token tree, build the subtree and map for this as well\n+                // then try finding a token id for our token if it is inside this input subtree.\n+                let item = ast::Item::cast(speculative_args.clone())?;\n+                item.doc_comments_and_attrs().nth(invoc_attr_index as usize).and_then(Either::left)\n+            }?;\n             match attr.token_tree() {\n                 Some(token_tree) => {\n                     let (mut tree, map) = syntax_node_to_token_tree(attr.token_tree()?.syntax());\n@@ -205,11 +207,15 @@ pub fn expand_speculative(\n \n     // Do the actual expansion, we need to directly expand the proc macro due to the attribute args\n     // Otherwise the expand query will fetch the non speculative attribute args and pass those instead.\n-    let mut speculative_expansion = if let MacroDefKind::ProcMacro(expander, ..) = loc.def.kind {\n-        tt.delimiter = None;\n-        expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n-    } else {\n-        macro_def.expand(db, actual_macro_call, &tt)\n+    let mut speculative_expansion = match loc.def.kind {\n+        MacroDefKind::ProcMacro(expander, ..) => {\n+            tt.delimiter = None;\n+            expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n+        }\n+        MacroDefKind::BuiltInAttr(BuiltinAttrExpander::Derive, _) => {\n+            pseudo_derive_attr_expansion(&tt, attr_arg.as_ref()?)\n+        }\n+        _ => macro_def.expand(db, actual_macro_call, &tt),\n     };\n \n     let expand_to = macro_expand_to(db, actual_macro_call);"}, {"sha": "2e141600e80b1c4f56cf54019d5a3704cd5dd79f", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -2,7 +2,7 @@\n use std::fmt::Display;\n \n use either::Either;\n-use hir::{AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n+use hir::{AsAssocItem, AttributeTemplate, HasAttrs, HirDisplay, Semantics, TypeInfo};\n use ide_db::{\n     base_db::SourceDatabase,\n     defs::Definition,\n@@ -13,9 +13,7 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n-    algo, ast,\n-    display::{fn_as_proc_macro_label, macro_label},\n-    match_ast, AstNode, Direction,\n+    algo, ast, match_ast, AstNode, Direction,\n     SyntaxKind::{LET_EXPR, LET_STMT},\n     SyntaxToken, T,\n };\n@@ -342,14 +340,8 @@ pub(super) fn definition(\n ) -> Option<Markup> {\n     let mod_path = definition_mod_path(db, &def);\n     let (label, docs) = match def {\n-        Definition::Macro(it) => (\n-            match &it.source(db)?.value {\n-                Either::Left(mac) => macro_label(mac),\n-                Either::Right(mac_fn) => fn_as_proc_macro_label(mac_fn),\n-            },\n-            it.attrs(db).docs(),\n-        ),\n-        Definition::Field(def) => label_and_docs(db, def),\n+        Definition::Macro(it) => label_and_docs(db, it),\n+        Definition::Field(it) => label_and_docs(db, it),\n         Definition::Module(it) => label_and_docs(db, it),\n         Definition::Function(it) => label_and_docs(db, it),\n         Definition::Adt(it) => label_and_docs(db, it),"}, {"sha": "df27f935c84c44f34677355fb5e86f372e350b3e", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -4102,16 +4102,16 @@ identity!{\n }\n \"#,\n         expect![[r#\"\n-                *Copy*\n+            *Copy*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                pub macro Copy\n-                ```\n-            \"#]],\n+            ```rust\n+            macro Copy\n+            ```\n+        \"#]],\n     );\n }\n \n@@ -4126,16 +4126,16 @@ pub macro Copy {}\n struct Foo;\n \"#,\n         expect![[r#\"\n-                *Copy*\n+            *Copy*\n \n-                ```rust\n-                test\n-                ```\n+            ```rust\n+            test\n+            ```\n \n-                ```rust\n-                pub macro Copy\n-                ```\n-            \"#]],\n+            ```rust\n+            macro Copy\n+            ```\n+        \"#]],\n     );\n     check(\n         r#\"\n@@ -4148,16 +4148,16 @@ mod foo {\n struct Foo;\n \"#,\n         expect![[r#\"\n-                *Copy*\n+            *Copy*\n \n-                ```rust\n-                test::foo\n-                ```\n+            ```rust\n+            test::foo\n+            ```\n \n-                ```rust\n-                pub macro Copy\n-                ```\n-            \"#]],\n+            ```rust\n+            macro Copy\n+            ```\n+        \"#]],\n     );\n }\n "}, {"sha": "ebea2d5dea8db74641ac33ecfddd545bd2f6f71e", "filename": "crates/ide_assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -32,7 +32,7 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     }\n \n     let mac_input = tt.syntax().children_with_tokens().skip(1).take_while(|it| *it != r_delim);\n-    let input_expressions = mac_input.into_iter().group_by(|tok| tok.kind() == T![,]);\n+    let input_expressions = mac_input.group_by(|tok| tok.kind() == T![,]);\n     let input_expressions = input_expressions\n         .into_iter()\n         .filter_map(|(is_sep, group)| (!is_sep).then(|| group))"}, {"sha": "6b51e19bbbe33c81829070d9df31ba3f331f6b5e", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -29,6 +29,8 @@ mod derive;\n mod lint;\n mod repr;\n \n+pub(crate) use self::derive::complete_derive;\n+\n /// Complete inputs to known builtin attributes as well as derive attributes\n pub(crate) fn complete_known_attribute_input(\n     acc: &mut Completions,\n@@ -46,7 +48,6 @@ pub(crate) fn complete_known_attribute_input(\n \n     match path.text().as_str() {\n         \"repr\" => repr::complete_repr(acc, ctx, tt),\n-        \"derive\" => derive::complete_derive(acc, ctx, ctx.attr.as_ref()?),\n         \"feature\" => lint::complete_lint(acc, ctx, &parse_tt_as_comma_sep_paths(tt)?, FEATURES),\n         \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n             let existing_lints = parse_tt_as_comma_sep_paths(tt)?;\n@@ -62,9 +63,7 @@ pub(crate) fn complete_known_attribute_input(\n \n             lint::complete_lint(acc, ctx, &existing_lints, &lints);\n         }\n-        \"cfg\" => {\n-            cfg::complete_cfg(acc, ctx);\n-        }\n+        \"cfg\" => cfg::complete_cfg(acc, ctx),\n         _ => (),\n     }\n     Some(())\n@@ -347,7 +346,7 @@ fn parse_comma_sep_expr(input: ast::TokenTree) -> Option<Vec<ast::Expr>> {\n         .children_with_tokens()\n         .skip(1)\n         .take_while(|it| it.as_token() != Some(&r_paren));\n-    let input_expressions = tokens.into_iter().group_by(|tok| tok.kind() == T![,]);\n+    let input_expressions = tokens.group_by(|tok| tok.kind() == T![,]);\n     Some(\n         input_expressions\n             .into_iter()"}, {"sha": "1edc92d5d628a3ba2d01f112567990f765c2c1eb", "filename": "crates/ide_completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 92, "deletions": 104, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -1,123 +1,111 @@\n //! Completion for derives\n-use hir::{HasAttrs, Macro, MacroKind};\n-use ide_db::{\n-    imports::{import_assets::ImportAssets, insert_use::ImportScope},\n-    SymbolKind,\n-};\n+use hir::{HasAttrs, ScopeDef};\n+use ide_db::SymbolKind;\n use itertools::Itertools;\n-use rustc_hash::FxHashSet;\n-use syntax::{ast, SmolStr, SyntaxKind};\n+use syntax::SmolStr;\n \n use crate::{\n-    completions::flyimport::compute_fuzzy_completion_order_key, context::CompletionContext,\n-    item::CompletionItem, Completions, ImportEdit,\n+    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n+    item::CompletionItem,\n+    Completions,\n };\n \n-pub(super) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext, attr: &ast::Attr) {\n+pub(crate) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext) {\n+    let (qualifier, is_absolute_path) = match ctx.path_context {\n+        Some(PathCompletionCtx {\n+            kind: Some(PathKind::Derive),\n+            ref qualifier,\n+            is_absolute_path,\n+            ..\n+        }) => (qualifier, is_absolute_path),\n+        _ => return,\n+    };\n+\n     let core = ctx.famous_defs().core();\n-    let existing_derives: FxHashSet<_> =\n-        ctx.sema.resolve_derive_macro(attr).into_iter().flatten().flatten().collect();\n \n-    for (name, mac) in get_derives_in_scope(ctx) {\n-        if existing_derives.contains(&mac) {\n-            continue;\n-        }\n+    match qualifier {\n+        Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+            if *is_super_chain {\n+                acc.add_keyword(ctx, \"super::\");\n+            }\n \n-        let name = name.to_smol_str();\n-        let (label, lookup) = match (core, mac.module(ctx.db).krate()) {\n-            // show derive dependencies for `core`/`std` derives\n-            (Some(core), mac_krate) if core == mac_krate => {\n-                if let Some(derive_completion) = DEFAULT_DERIVE_DEPENDENCIES\n-                    .iter()\n-                    .find(|derive_completion| derive_completion.label == name)\n-                {\n-                    let mut components = vec![derive_completion.label];\n-                    components.extend(derive_completion.dependencies.iter().filter(\n-                        |&&dependency| {\n-                            !existing_derives\n-                                .iter()\n-                                .map(|it| it.name(ctx.db))\n-                                .any(|it| it.to_smol_str() == dependency)\n-                        },\n-                    ));\n-                    let lookup = components.join(\", \");\n-                    let label = Itertools::intersperse(components.into_iter().rev(), \", \");\n-                    (SmolStr::from_iter(label), Some(lookup))\n-                } else {\n-                    (name, None)\n+            let module = match resolution {\n+                Some(hir::PathResolution::Def(hir::ModuleDef::Module(it))) => it,\n+                _ => return,\n+            };\n+\n+            for (name, def) in module.scope(ctx.db, ctx.module) {\n+                let add_def = match def {\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => {\n+                        !ctx.existing_derives.contains(&mac) && mac.is_derive(ctx.db)\n+                    }\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => true,\n+                    _ => false,\n+                };\n+                if add_def {\n+                    acc.add_resolution(ctx, name, def);\n                 }\n             }\n-            _ => (name, None),\n-        };\n-\n-        let mut item = CompletionItem::new(SymbolKind::Derive, ctx.source_range(), label);\n-        if let Some(docs) = mac.docs(ctx.db) {\n-            item.documentation(docs);\n+            return;\n         }\n-        if let Some(lookup) = lookup {\n-            item.lookup_by(lookup);\n-        }\n-        item.add_to(acc);\n-    }\n+        None if is_absolute_path => acc.add_crate_roots(ctx),\n+        // only show modules in a fresh UseTree\n+        None => {\n+            ctx.process_all_names(&mut |name, def| {\n+                let mac = match def {\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac))\n+                        if !ctx.existing_derives.contains(&mac) && mac.is_derive(ctx.db) =>\n+                    {\n+                        mac\n+                    }\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => {\n+                        return acc.add_resolution(ctx, name, def);\n+                    }\n+                    _ => return,\n+                };\n \n-    flyimport_derive(acc, ctx);\n-}\n+                match (core, mac.module(ctx.db).krate()) {\n+                    // show derive dependencies for `core`/`std` derives\n+                    (Some(core), mac_krate) if core == mac_krate && qualifier.is_none() => {}\n+                    _ => return acc.add_resolution(ctx, name, def),\n+                };\n \n-fn get_derives_in_scope(ctx: &CompletionContext) -> Vec<(hir::Name, Macro)> {\n-    let mut result = Vec::default();\n-    ctx.process_all_names(&mut |name, scope_def| {\n-        if let hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) = scope_def {\n-            if mac.kind(ctx.db) == hir::MacroKind::Derive {\n-                result.push((name, mac));\n-            }\n-        }\n-    });\n-    result\n-}\n+                let name_ = name.to_smol_str();\n+                let find = DEFAULT_DERIVE_DEPENDENCIES\n+                    .iter()\n+                    .find(|derive_completion| derive_completion.label == name_);\n \n-fn flyimport_derive(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    if ctx.token.kind() != SyntaxKind::IDENT {\n-        return None;\n-    };\n-    let potential_import_name = ctx.token.to_string();\n-    let module = ctx.module?;\n-    let parent = ctx.token.parent()?;\n-    let user_input_lowercased = potential_import_name.to_lowercase();\n-    let import_assets = ImportAssets::for_fuzzy_path(\n-        module,\n-        None,\n-        potential_import_name,\n-        &ctx.sema,\n-        parent.clone(),\n-    )?;\n-    let import_scope = ImportScope::find_insert_use_container(&parent, &ctx.sema)?;\n-    acc.add_all(\n-        import_assets\n-            .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n-            .into_iter()\n-            .filter_map(|import| match import.original_item {\n-                hir::ItemInNs::Macros(mac) => Some((import, mac)),\n-                _ => None,\n-            })\n-            .filter(|&(_, mac)| mac.kind(ctx.db) == MacroKind::Derive)\n-            .filter(|&(_, mac)| !ctx.is_item_hidden(&hir::ItemInNs::Macros(mac)))\n-            .sorted_by_key(|(import, _)| {\n-                compute_fuzzy_completion_order_key(&import.import_path, &user_input_lowercased)\n-            })\n-            .filter_map(|(import, mac)| {\n-                let mut item = CompletionItem::new(\n-                    SymbolKind::Derive,\n-                    ctx.source_range(),\n-                    mac.name(ctx.db).to_smol_str(),\n-                );\n-                item.add_import(ImportEdit { import, scope: import_scope.clone() });\n-                if let Some(docs) = mac.docs(ctx.db) {\n-                    item.documentation(docs);\n+                match find {\n+                    Some(derive_completion) => {\n+                        let mut components = vec![derive_completion.label];\n+                        components.extend(derive_completion.dependencies.iter().filter(\n+                            |&&dependency| {\n+                                !ctx.existing_derives\n+                                    .iter()\n+                                    .map(|it| it.name(ctx.db))\n+                                    .any(|it| it.to_smol_str() == dependency)\n+                            },\n+                        ));\n+                        let lookup = components.join(\", \");\n+                        let label = Itertools::intersperse(components.into_iter().rev(), \", \");\n+\n+                        let mut item = CompletionItem::new(\n+                            SymbolKind::Derive,\n+                            ctx.source_range(),\n+                            SmolStr::from_iter(label),\n+                        );\n+                        if let Some(docs) = mac.docs(ctx.db) {\n+                            item.documentation(docs);\n+                        }\n+                        item.lookup_by(lookup);\n+                        item.add_to(acc);\n+                    }\n+                    None => acc.add_resolution(ctx, name, def),\n                 }\n-                Some(item.build())\n-            }),\n-    );\n-    Some(())\n+            });\n+            acc.add_nameref_keywords(ctx);\n+        }\n+    }\n }\n \n struct DeriveDependencies {"}, {"sha": "aee2bbb53c3ebb546655c500aab8234b9935569e", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -142,7 +142,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n     )?;\n \n     let ns_filter = |import: &LocatedImport| {\n-        let kind = match ctx.path_kind() {\n+        let path_kind = match ctx.path_kind() {\n             Some(kind) => kind,\n             None => {\n                 return match import.original_item {\n@@ -151,7 +151,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n                 }\n             }\n         };\n-        match (kind, import.original_item) {\n+        match (path_kind, import.original_item) {\n             // Aren't handled in flyimport\n             (PathKind::Vis { .. } | PathKind::Use, _) => false,\n             // modules are always fair game\n@@ -173,6 +173,11 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n \n             (PathKind::Attr { .. }, ItemInNs::Macros(mac)) => mac.is_attr(ctx.db),\n             (PathKind::Attr { .. }, _) => false,\n+\n+            (PathKind::Derive, ItemInNs::Macros(mac)) => {\n+                mac.is_derive(ctx.db) && !ctx.existing_derives.contains(&mac)\n+            }\n+            (PathKind::Derive, _) => false,\n         }\n     };\n "}, {"sha": "acd02616b157b2a4febd09e8199855dfd5db419a", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -63,7 +63,13 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     }\n \n     match kind {\n-        Some(PathKind::Pat | PathKind::Attr { .. } | PathKind::Vis { .. } | PathKind::Use) => {\n+        Some(\n+            PathKind::Pat\n+            | PathKind::Attr { .. }\n+            | PathKind::Vis { .. }\n+            | PathKind::Use\n+            | PathKind::Derive,\n+        ) => {\n             return;\n         }\n         _ => {\n@@ -415,10 +421,10 @@ macro_rules! foo { () => {} }\n \n fn main() { let _ = crate::$0 }\n \"#,\n-            expect![[r##\"\n+            expect![[r#\"\n                 fn main()  fn()\n-                ma foo!(\u2026) #[macro_export] macro_rules! foo\n-            \"##]],\n+                ma foo!(\u2026) macro_rules! foo\n+            \"#]],\n         );\n     }\n "}, {"sha": "235d7870c7ca71069a1bd3c7c5fc4bd40c51f834", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -19,10 +19,11 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         Some(PathCompletionCtx {\n             kind:\n                 Some(\n-                    PathKind::Vis { .. }\n-                    | PathKind::Attr { .. }\n+                    PathKind::Attr { .. }\n+                    | PathKind::Derive\n+                    | PathKind::Pat\n                     | PathKind::Use { .. }\n-                    | PathKind::Pat,\n+                    | PathKind::Vis { .. },\n                 ),\n             ..\n         }) => return,\n@@ -207,12 +208,12 @@ mod macros {\n     macro_rules! concat { }\n }\n \"#,\n-            expect![[r##\"\n+            expect![[r#\"\n                 fn f()        fn()\n-                ma concat!(\u2026) #[macro_export] macro_rules! concat\n+                ma concat!(\u2026) macro_rules! concat\n                 md std\n                 bt u32\n-            \"##]],\n+            \"#]],\n         );\n     }\n "}, {"sha": "51bbd66ff3729b8746050366a25fe7fd05c78989", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -12,6 +12,7 @@ use ide_db::{\n     famous_defs::FamousDefs,\n     RootDatabase,\n };\n+use rustc_hash::FxHashSet;\n use syntax::{\n     algo::{find_node_at_offset, non_trivia_sibling},\n     ast::{self, AttrKind, HasName, NameOrNameRef},\n@@ -43,11 +44,12 @@ pub(crate) enum Visible {\n     No,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(super) enum PathKind {\n     Expr,\n     Type,\n     Attr { kind: AttrKind, annotated_item_kind: Option<SyntaxKind> },\n+    Derive,\n     Mac,\n     Pat,\n     Vis { has_in_token: bool },\n@@ -126,7 +128,6 @@ pub(crate) struct CompletionContext<'a> {\n \n     /// The parent function of the cursor position if it exists.\n     pub(super) function_def: Option<ast::Fn>,\n-    pub(super) attr: Option<ast::Attr>,\n     /// The parent impl of the cursor position if it exists.\n     pub(super) impl_def: Option<ast::Impl>,\n     /// The NameLike under the cursor in the original file if it exists.\n@@ -142,6 +143,8 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) pattern_ctx: Option<PatternContext>,\n     pub(super) path_context: Option<PathCompletionCtx>,\n \n+    pub(super) existing_derives: FxHashSet<hir::Macro>,\n+\n     pub(super) locals: Vec<(Name, Local)>,\n \n     no_completion_required: bool,\n@@ -439,7 +442,6 @@ impl<'a> CompletionContext<'a> {\n             expected_name: None,\n             expected_type: None,\n             function_def: None,\n-            attr: None,\n             impl_def: None,\n             name_syntax: None,\n             lifetime_ctx: None,\n@@ -452,6 +454,7 @@ impl<'a> CompletionContext<'a> {\n             locals,\n             incomplete_let: false,\n             no_completion_required: false,\n+            existing_derives: Default::default(),\n         };\n         ctx.expand_and_fill(\n             original_file.syntax().clone(),\n@@ -472,6 +475,8 @@ impl<'a> CompletionContext<'a> {\n         mut fake_ident_token: SyntaxToken,\n     ) {\n         let _p = profile::span(\"CompletionContext::expand_and_fill\");\n+        let mut derive_ctx = None;\n+\n         'expansion: loop {\n             let parent_item =\n                 |item: &ast::Item| item.syntax().ancestors().skip(1).find_map(ast::Item::cast);\n@@ -509,11 +514,45 @@ impl<'a> CompletionContext<'a> {\n                     _ => break 'expansion,\n                 }\n             }\n+            let orig_tt = match find_node_at_offset::<ast::TokenTree>(&original_file, offset) {\n+                Some(it) => it,\n+                None => break,\n+            };\n+            let spec_tt = match find_node_at_offset::<ast::TokenTree>(&speculative_file, offset) {\n+                Some(it) => it,\n+                None => break,\n+            };\n+\n+            // Expand pseudo-derive expansion\n+            if let (Some(orig_attr), Some(spec_attr)) = (\n+                orig_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+                spec_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+            ) {\n+                match (\n+                    self.sema.expand_derive_as_pseudo_attr_macro(&orig_attr),\n+                    self.sema.speculative_expand_derive_as_pseudo_attr_macro(\n+                        &orig_attr,\n+                        &spec_attr,\n+                        fake_ident_token.clone(),\n+                    ),\n+                ) {\n+                    // Clearly not a derive macro\n+                    (None, None) => (),\n+                    // successful expansions\n+                    (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n+                        let new_offset = fake_mapped_token.text_range().start();\n+                        derive_ctx = Some((actual_expansion, fake_expansion, new_offset));\n+                        break 'expansion;\n+                    }\n+                    // exactly one expansion failed, inconsistent state so stop expanding completely\n+                    _ => break 'expansion,\n+                }\n+            }\n \n             // Expand fn-like macro calls\n             if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n-                find_node_at_offset::<ast::MacroCall>(&original_file, offset),\n-                find_node_at_offset::<ast::MacroCall>(&speculative_file, offset),\n+                orig_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n+                spec_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n             ) {\n                 let mac_call_path0 = actual_macro_call.path().as_ref().map(|s| s.syntax().text());\n                 let mac_call_path1 =\n@@ -553,7 +592,7 @@ impl<'a> CompletionContext<'a> {\n             break;\n         }\n \n-        self.fill(&original_file, speculative_file, offset);\n+        self.fill(&original_file, speculative_file, offset, derive_ctx);\n     }\n \n     fn expected_type_and_name(&self) -> (Option<Type>, Option<NameOrNameRef>) {\n@@ -697,6 +736,7 @@ impl<'a> CompletionContext<'a> {\n         original_file: &SyntaxNode,\n         file_with_fake_ident: SyntaxNode,\n         offset: TextSize,\n+        derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize)>,\n     ) {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n         let syntax_element = NodeOrToken::Token(fake_ident_token);\n@@ -708,11 +748,6 @@ impl<'a> CompletionContext<'a> {\n             (fn_is_prev && !inside_impl_trait_block) || for_is_prev2\n         };\n \n-        self.attr = self\n-            .sema\n-            .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-            .find_map(ast::Attr::cast);\n         self.fake_attribute_under_caret = syntax_element.ancestors().find_map(ast::Attr::cast);\n \n         self.incomplete_let =\n@@ -724,6 +759,33 @@ impl<'a> CompletionContext<'a> {\n         self.expected_type = expected_type;\n         self.expected_name = expected_name;\n \n+        // Overwrite the path kind for derives\n+        if let Some((original_file, file_with_fake_ident, offset)) = derive_ctx {\n+            let attr = self\n+                .sema\n+                .token_ancestors_with_macros(self.token.clone())\n+                .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n+                .find_map(ast::Attr::cast);\n+            if let Some(attr) = &attr {\n+                self.existing_derives =\n+                    self.sema.resolve_derive_macro(attr).into_iter().flatten().flatten().collect();\n+            }\n+\n+            if let Some(ast::NameLike::NameRef(name_ref)) =\n+                find_node_at_offset(&file_with_fake_ident, offset)\n+            {\n+                self.name_syntax =\n+                    find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n+                if let Some((path_ctx, _)) =\n+                    Self::classify_name_ref(&self.sema, &original_file, name_ref)\n+                {\n+                    self.path_context =\n+                        Some(PathCompletionCtx { kind: Some(PathKind::Derive), ..path_ctx });\n+                }\n+            }\n+            return;\n+        }\n+\n         let name_like = match find_node_at_offset(&file_with_fake_ident, offset) {\n             Some(it) => it,\n             None => return,\n@@ -743,6 +805,7 @@ impl<'a> CompletionContext<'a> {\n             .token_ancestors_with_macros(self.token.clone())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::Fn::cast);\n+\n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n                 self.lifetime_ctx ="}, {"sha": "86a6947b1dda8212372c910cd7585d6a61cc52ce", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -152,6 +152,7 @@ pub fn completions(\n \n     let mut acc = Completions::default();\n     completions::attribute::complete_attribute(&mut acc, &ctx);\n+    completions::attribute::complete_derive(&mut acc, &ctx);\n     completions::attribute::complete_known_attribute_input(&mut acc, &ctx);\n     completions::dot::complete_dot(&mut acc, &ctx);\n     completions::extern_abi::complete_extern_abi(&mut acc, &ctx);"}, {"sha": "d3b0de429ca607c92899351f53d475f3abbf91d8", "filename": "crates/ide_completion/src/render/macro_.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -1,12 +1,8 @@\n //! Renderer for macro invocations.\n \n-use either::Either;\n-use hir::{Documentation, HasSource, InFile, Semantics};\n-use ide_db::{RootDatabase, SymbolKind};\n-use syntax::{\n-    display::{fn_as_proc_macro_label, macro_label},\n-    SmolStr,\n-};\n+use hir::{Documentation, HirDisplay};\n+use ide_db::SymbolKind;\n+use syntax::SmolStr;\n \n use crate::{\n     context::PathKind,\n@@ -52,7 +48,7 @@ fn render(\n         label(&ctx, needs_bang, bra, ket, &name),\n     );\n     item.set_deprecated(ctx.is_deprecated(macro_))\n-        .set_detail(detail(&completion.sema, macro_))\n+        .detail(macro_.display(completion.db).to_string())\n         .set_documentation(docs)\n         .set_relevance(ctx.completion_relevance());\n \n@@ -103,17 +99,6 @@ fn banged_name(name: &str) -> SmolStr {\n     SmolStr::from_iter([name, \"!\"])\n }\n \n-fn detail(sema: &Semantics<RootDatabase>, macro_: hir::Macro) -> Option<String> {\n-    // FIXME: This is parsing the file!\n-    let InFile { file_id, value } = macro_.source(sema.db)?;\n-    let _ = sema.parse_or_expand(file_id);\n-    let detail = match value {\n-        Either::Left(node) => macro_label(&node),\n-        Either::Right(node) => fn_as_proc_macro_label(&node),\n-    };\n-    Some(detail)\n-}\n-\n fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static str) {\n     let mut votes = [0, 0, 0];\n     for (idx, s) in docs.match_indices(&macro_name) {"}, {"sha": "4ee95e8928170e3bd116d2881b95798da2b3a4a2", "filename": "crates/ide_completion/src/tests/attribute.rs", "status": "modified", "additions": 60, "deletions": 31, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -62,7 +62,7 @@ fn proc_macros_qualified() {\n struct Foo;\n \"#,\n         expect![[r#\"\n-            at identity pub macro identity\n+            at identity proc_macro identity\n         \"#]],\n     )\n }\n@@ -302,7 +302,7 @@ struct Foo;\n \"#,\n         expect![[r#\"\n             md core\n-            at derive           pub macro derive\n+            at derive           macro derive\n             kw self::\n             kw super::\n             kw crate::\n@@ -688,13 +688,17 @@ mod derive {\n #[derive($0)] struct Test;\n \"#,\n             expect![[r#\"\n-                de Default\n+                md core\n+                de Default                macro Default\n                 de Clone, Copy\n-                de PartialEq\n+                de PartialEq              macro PartialEq\n                 de PartialEq, Eq\n                 de PartialEq, Eq, PartialOrd, Ord\n-                de Clone\n+                de Clone                  macro Clone\n                 de PartialEq, PartialOrd\n+                kw self::\n+                kw super::\n+                kw crate::\n             \"#]],\n         );\n     }\n@@ -707,12 +711,16 @@ mod derive {\n #[derive(serde::Serialize, PartialEq, $0)] struct Test;\n \"#,\n             expect![[r#\"\n-                de Default\n+                md core\n+                de Default             macro Default\n                 de Clone, Copy\n                 de Eq\n                 de Eq, PartialOrd, Ord\n-                de Clone\n+                de Clone               macro Clone\n                 de PartialOrd\n+                kw self::\n+                kw super::\n+                kw crate::\n             \"#]],\n         )\n     }\n@@ -725,33 +733,17 @@ mod derive {\n #[derive($0 serde::Serialize, PartialEq)] struct Test;\n \"#,\n             expect![[r#\"\n-                de Default\n+                md core\n+                de Default             macro Default\n                 de Clone, Copy\n                 de Eq\n                 de Eq, PartialOrd, Ord\n-                de Clone\n+                de Clone               macro Clone\n                 de PartialOrd\n+                kw self::\n+                kw super::\n+                kw crate::\n             \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn derive_no_attrs() {\n-        check_derive(\n-            r#\"\n-//- proc_macros: identity\n-//- minicore: derive\n-#[derive($0)] struct Test;\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-        check_derive(\n-            r#\"\n-//- proc_macros: identity\n-//- minicore: derive\n-#[derive(i$0)] struct Test;\n-\"#,\n-            expect![[r#\"\"#]],\n         );\n     }\n \n@@ -760,20 +752,32 @@ mod derive {\n         check_derive(\n             r#\"\n //- proc_macros: derive_identity\n+//- minicore: derive\n #[derive(der$0)] struct Test;\n \"#,\n             expect![[r#\"\n-                de DeriveIdentity (use proc_macros::DeriveIdentity)\n+                md proc_macros\n+                md core\n+                kw self::\n+                kw super::\n+                kw crate::\n+                de DeriveIdentity (use proc_macros::DeriveIdentity) proc_macro DeriveIdentity\n             \"#]],\n         );\n         check_derive(\n             r#\"\n //- proc_macros: derive_identity\n+//- minicore: derive\n use proc_macros::DeriveIdentity;\n #[derive(der$0)] struct Test;\n \"#,\n             expect![[r#\"\n-                de DeriveIdentity\n+                de DeriveIdentity proc_macro DeriveIdentity\n+                md proc_macros\n+                md core\n+                kw self::\n+                kw super::\n+                kw crate::\n             \"#]],\n         );\n     }\n@@ -784,6 +788,7 @@ use proc_macros::DeriveIdentity;\n             \"DeriveIdentity\",\n             r#\"\n //- proc_macros: derive_identity\n+//- minicore: derive\n #[derive(der$0)] struct Test;\n \"#,\n             r#\"\n@@ -793,6 +798,30 @@ use proc_macros::DeriveIdentity;\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn qualified() {\n+        check_derive(\n+            r#\"\n+//- proc_macros: derive_identity\n+//- minicore: derive, copy, clone\n+#[derive(proc_macros::$0)] struct Test;\n+\"#,\n+            expect![[r#\"\n+                de DeriveIdentity proc_macro DeriveIdentity\n+            \"#]],\n+        );\n+        check_derive(\n+            r#\"\n+//- proc_macros: derive_identity\n+//- minicore: derive, copy, clone\n+#[derive(proc_macros::C$0)] struct Test;\n+\"#,\n+            expect![[r#\"\n+                de DeriveIdentity proc_macro DeriveIdentity\n+            \"#]],\n+        );\n+    }\n }\n \n mod lint {"}, {"sha": "a841605e496c4ac449607078721931279b3927e4", "filename": "crates/ide_completion/src/tests/expression.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -30,7 +30,7 @@ fn baz() {\n }\n             \"#,\n         // This should not contain `FooDesc {\u2026}`.\n-        expect![[r##\"\n+        expect![[r#\"\n             kw unsafe\n             kw match\n             kw while\n@@ -57,13 +57,13 @@ fn baz() {\n             fn baz()         fn()\n             st Unit\n             md _69latrick\n-            ma makro!(\u2026)     #[macro_export] macro_rules! makro\n+            ma makro!(\u2026)     macro_rules! makro\n             fn function()    fn()\n             sc STATIC\n             un Union\n             ev TupleV(\u2026)     (u32)\n             ct CONST\n-        \"##]],\n+        \"#]],\n     )\n }\n \n@@ -125,7 +125,7 @@ impl Unit {\n }\n \"#,\n         // `self` is in here twice, once as the module, once as the local\n-        expect![[r##\"\n+        expect![[r#\"\n             me self.foo()   fn(self)\n             kw unsafe\n             kw fn\n@@ -166,14 +166,14 @@ impl Unit {\n             md module\n             st Unit\n             md qualified\n-            ma makro!(\u2026)    #[macro_export] macro_rules! makro\n+            ma makro!(\u2026)    macro_rules! makro\n             ?? Unresolved\n             fn function()   fn()\n             sc STATIC\n             un Union\n             ev TupleV(\u2026)    (u32)\n             ct CONST\n-        \"##]],\n+        \"#]],\n     );\n     check(\n         r#\"\n@@ -187,22 +187,22 @@ impl Unit {\n     }\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             tt Trait\n             en Enum\n             st Record\n             st Tuple\n             md module\n             st Unit\n             md qualified\n-            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n+            ma makro!(\u2026)  macro_rules! makro\n             ?? Unresolved\n             fn function() fn()\n             sc STATIC\n             un Union\n             ev TupleV(\u2026)  (u32)\n             ct CONST\n-        \"##]],\n+        \"#]],\n     );\n }\n "}, {"sha": "c996a5f01f87372cbfcbc4fb16e09dfa4de83ba5", "filename": "crates/ide_completion/src/tests/flyimport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -1108,7 +1108,7 @@ fn flyimport_attribute() {\n struct Foo;\n \"#,\n         expect![[r#\"\n-            at identity (use proc_macros::identity) pub macro identity\n+            at identity (use proc_macros::identity) proc_macro identity\n         \"#]],\n     );\n     check_edit("}, {"sha": "1d5ddc092e5080462851576f2ad9827135eea200", "filename": "crates/ide_completion/src/tests/item.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -17,7 +17,7 @@ fn target_type_or_trait_in_impl_block() {\n         r#\"\n impl Tra$0\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n@@ -27,10 +27,10 @@ impl Tra$0\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             un Union\n             bt u32\n-        \"##]],\n+        \"#]],\n     )\n }\n \n@@ -40,7 +40,7 @@ fn target_type_in_trait_impl_block() {\n         r#\"\n impl Trait for Str$0\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n@@ -50,10 +50,10 @@ impl Trait for Str$0\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             un Union\n             bt u32\n-        \"##]],\n+        \"#]],\n     )\n }\n \n@@ -85,7 +85,7 @@ fn after_struct_name() {\n     // FIXME: This should emit `kw where` only\n     check(\n         r\"struct Struct $0\",\n-        expect![[r##\"\n+        expect![[r#\"\n             kw pub(crate)\n             kw pub(super)\n             kw pub\n@@ -109,8 +109,8 @@ fn after_struct_name() {\n             kw super\n             kw crate\n             md module\n-            ma makro!(\u2026)           #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026)           macro_rules! makro\n+        \"#]],\n     );\n }\n \n@@ -119,7 +119,7 @@ fn after_fn_name() {\n     // FIXME: This should emit `kw where` only\n     check(\n         r\"fn func() $0\",\n-        expect![[r##\"\n+        expect![[r#\"\n             kw pub(crate)\n             kw pub(super)\n             kw pub\n@@ -143,8 +143,8 @@ fn after_fn_name() {\n             kw super\n             kw crate\n             md module\n-            ma makro!(\u2026)           #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026)           macro_rules! makro\n+        \"#]],\n     );\n }\n "}, {"sha": "82824fd3932b4497e6a2320e99f47dc6a697d2a7", "filename": "crates/ide_completion/src/tests/item_list.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -12,7 +12,7 @@ fn check(ra_fixture: &str, expect: Expect) {\n fn in_mod_item_list() {\n     check(\n         r#\"mod tests { $0 }\"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw pub(crate)\n             kw pub(super)\n             kw pub\n@@ -35,16 +35,16 @@ fn in_mod_item_list() {\n             kw self\n             kw super\n             kw crate\n-            ma makro!(\u2026)           #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026)           macro_rules! makro\n+        \"#]],\n     )\n }\n \n #[test]\n fn in_source_file_item_list() {\n     check(\n         r#\"$0\"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw pub(crate)\n             kw pub(super)\n             kw pub\n@@ -68,8 +68,8 @@ fn in_source_file_item_list() {\n             kw super\n             kw crate\n             md module\n-            ma makro!(\u2026)           #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026)           macro_rules! makro\n+        \"#]],\n     )\n }\n \n@@ -106,10 +106,10 @@ fn in_qualified_path() {\n     cov_mark::check!(no_keyword_completion_in_non_trivial_path);\n     check(\n         r#\"crate::$0\"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             md module\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n     )\n }\n \n@@ -162,7 +162,7 @@ fn after_visibility_unsafe() {\n fn in_impl_assoc_item_list() {\n     check(\n         r#\"impl Struct { $0 }\"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw pub(crate)\n             kw pub(super)\n             kw pub\n@@ -174,8 +174,8 @@ fn in_impl_assoc_item_list() {\n             kw super\n             kw crate\n             md module\n-            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026)  macro_rules! makro\n+        \"#]],\n     )\n }\n \n@@ -199,7 +199,7 @@ fn in_impl_assoc_item_list_after_attr() {\n fn in_trait_assoc_item_list() {\n     check(\n         r\"trait Foo { $0 }\",\n-        expect![[r##\"\n+        expect![[r#\"\n             kw unsafe\n             kw fn\n             kw const\n@@ -208,8 +208,8 @@ fn in_trait_assoc_item_list() {\n             kw super\n             kw crate\n             md module\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n     );\n }\n \n@@ -233,7 +233,7 @@ impl Test for () {\n     $0\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw pub(crate)\n             kw pub(super)\n             kw pub\n@@ -245,7 +245,7 @@ impl Test for () {\n             kw super\n             kw crate\n             md module\n-            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026)  macro_rules! makro\n+        \"#]],\n     );\n }"}, {"sha": "0ca20f93b5e25cc0716f23a1078afc13e07b37f5", "filename": "crates/ide_completion/src/tests/pattern.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -102,7 +102,7 @@ fn foo() {\n     if let a$0\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw ref\n             kw mut\n             en Enum\n@@ -112,11 +112,11 @@ fn foo() {\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             bn TupleV    TupleV($1)$0\n             ev TupleV\n             ct CONST\n-        \"##]],\n+        \"#]],\n     );\n }\n \n@@ -132,7 +132,7 @@ fn foo() {\n    let a$0\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw ref\n             kw mut\n             bn Record            Record { field$1 }$0\n@@ -142,8 +142,8 @@ fn foo() {\n             ev Variant\n             en SingleVariantEnum\n             st Unit\n-            ma makro!(\u2026)         #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026)         macro_rules! makro\n+        \"#]],\n     );\n }\n \n@@ -154,32 +154,32 @@ fn in_param() {\n fn foo(a$0) {\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw ref\n             kw mut\n             bn Record    Record { field$1 }: Record$0\n             st Record\n             bn Tuple     Tuple($1): Tuple$0\n             st Tuple\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n     );\n     check(\n         r#\"\n fn foo(a$0: Tuple) {\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw ref\n             kw mut\n             bn Record    Record { field$1 }$0\n             st Record\n             bn Tuple     Tuple($1)$0\n             st Tuple\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n     );\n }\n "}, {"sha": "5e975d715f66423387e0c62ba66219c50165a58c", "filename": "crates/ide_completion/src/tests/predicate.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fpredicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Fpredicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpredicate.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -15,7 +15,7 @@ fn predicate_start() {\n         r#\"\n struct Foo<'lt, T, const C: usize> where $0 {}\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n@@ -26,10 +26,10 @@ struct Foo<'lt, T, const C: usize> where $0 {}\n             md module\n             st Foo<\u2026>\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             un Union\n             bt u32\n-        \"##]],\n+        \"#]],\n     );\n }\n \n@@ -39,14 +39,14 @@ fn bound_for_type_pred() {\n         r#\"\n struct Foo<'lt, T, const C: usize> where T: $0 {}\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n             tt Trait\n             md module\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n     );\n }\n \n@@ -58,14 +58,14 @@ fn bound_for_lifetime_pred() {\n         r#\"\n struct Foo<'lt, T, const C: usize> where 'lt: $0 {}\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n             tt Trait\n             md module\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n     );\n }\n \n@@ -75,14 +75,14 @@ fn bound_for_for_pred() {\n         r#\"\n struct Foo<'lt, T, const C: usize> where for<'a> T: $0 {}\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n             tt Trait\n             md module\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n-        \"##]],\n+            ma makro!(\u2026) macro_rules! makro\n+        \"#]],\n     );\n }\n \n@@ -92,7 +92,7 @@ fn param_list_for_for_pred() {\n         r#\"\n struct Foo<'lt, T, const C: usize> where for<'a> $0 {}\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n@@ -103,10 +103,10 @@ struct Foo<'lt, T, const C: usize> where for<'a> $0 {}\n             md module\n             st Foo<\u2026>\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             un Union\n             bt u32\n-        \"##]],\n+        \"#]],\n     );\n }\n \n@@ -118,7 +118,7 @@ impl Record {\n     fn method(self) where $0 {}\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n@@ -129,9 +129,9 @@ impl Record {\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             un Union\n             bt u32\n-        \"##]],\n+        \"#]],\n     );\n }"}, {"sha": "c8260f6e23c0345d8269e2688cb1797444a06d58", "filename": "crates/ide_completion/src/tests/type_pos.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -16,7 +16,7 @@ struct Foo<'lt, T, const C: usize> {\n     f: $0\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n@@ -29,10 +29,10 @@ struct Foo<'lt, T, const C: usize> {\n             md module\n             st Foo<\u2026>\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             un Union\n             bt u32\n-        \"##]],\n+        \"#]],\n     )\n }\n \n@@ -42,7 +42,7 @@ fn tuple_struct_field() {\n         r#\"\n struct Foo<'lt, T, const C: usize>(f$0);\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw pub(crate)\n             kw pub(super)\n             kw pub\n@@ -58,10 +58,10 @@ struct Foo<'lt, T, const C: usize>(f$0);\n             md module\n             st Foo<\u2026>\n             st Unit\n-            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n+            ma makro!(\u2026)  macro_rules! makro\n             un Union\n             bt u32\n-        \"##]],\n+        \"#]],\n     )\n }\n \n@@ -71,7 +71,7 @@ fn fn_return_type() {\n         r#\"\n fn x<'lt, T, const C: usize>() -> $0\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n@@ -82,10 +82,10 @@ fn x<'lt, T, const C: usize>() -> $0\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             un Union\n             bt u32\n-        \"##]],\n+        \"#]],\n     );\n }\n \n@@ -98,7 +98,7 @@ fn foo<'lt, T, const C: usize>() {\n     let _: $0;\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n@@ -109,10 +109,10 @@ fn foo<'lt, T, const C: usize>() {\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             un Union\n             bt u32\n-        \"##]],\n+        \"#]],\n     );\n     check(\n         r#\"\n@@ -121,16 +121,16 @@ fn foo<'lt, T, const C: usize>() {\n     let _: self::$0;\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             tt Trait\n             en Enum\n             st Record\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             un Union\n-        \"##]],\n+        \"#]],\n     );\n }\n \n@@ -144,7 +144,7 @@ trait Trait2 {\n \n fn foo<'lt, T: Trait2<$0>, const CONST_PARAM: usize>(_: T) {}\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             kw self\n             kw super\n             kw crate\n@@ -157,12 +157,12 @@ fn foo<'lt, T: Trait2<$0>, const CONST_PARAM: usize>(_: T) {}\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026)          #[macro_export] macro_rules! makro\n+            ma makro!(\u2026)          macro_rules! makro\n             tt Trait2\n             un Union\n             ct CONST\n             bt u32\n-        \"##]],\n+        \"#]],\n     );\n     check(\n         r#\"\n@@ -172,18 +172,18 @@ trait Trait2 {\n \n fn foo<'lt, T: Trait2<self::$0>, const CONST_PARAM: usize>(_: T) {}\n     \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             tt Trait\n             en Enum\n             st Record\n             st Tuple\n             md module\n             st Unit\n-            ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            ma makro!(\u2026) macro_rules! makro\n             tt Trait2\n             un Union\n             ct CONST\n-        \"##]],\n+        \"#]],\n     );\n }\n "}, {"sha": "c0f052996631b21ea3a7d952a4ea67bcc3b47f53", "filename": "crates/ide_db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fide_db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -443,7 +443,7 @@ pub fn parse_tt_as_comma_sep_paths(input: ast::TokenTree) -> Option<Vec<ast::Pat\n             None => None,\n             Some(tok) => Some(tok),\n         });\n-    let input_expressions = tokens.into_iter().group_by(|tok| tok.kind() == T![,]);\n+    let input_expressions = tokens.group_by(|tok| tok.kind() == T![,]);\n     let paths = input_expressions\n         .into_iter()\n         .filter_map(|(is_sep, group)| (!is_sep).then(|| group))"}, {"sha": "f7322656a3e0c449c118d86be7142af796322307", "filename": "crates/syntax/src/display.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fsyntax%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e5bd5a2532cfe47e5517d720eb70cbf3f4a908/crates%2Fsyntax%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fdisplay.rs?ref=69e5bd5a2532cfe47e5517d720eb70cbf3f4a908", "patch": "@@ -1,6 +1,6 @@\n //! This module contains utilities for rendering syntax nodes into a string representing their signature.\n \n-use crate::ast::{self, HasAttrs, HasGenericParams, HasName};\n+use crate::ast::{self, HasGenericParams, HasName};\n \n use ast::HasVisibility;\n use stdx::format_to;\n@@ -49,37 +49,3 @@ pub fn function_declaration(node: &ast::Fn) -> String {\n     }\n     buf\n }\n-\n-pub fn macro_label(node: &ast::Macro) -> String {\n-    let name = node.name();\n-    let mut s = String::new();\n-    match node {\n-        ast::Macro::MacroRules(node) => {\n-            let vis = if node.has_atom_attr(\"macro_export\") { \"#[macro_export] \" } else { \"\" };\n-            format_to!(s, \"{}macro_rules!\", vis);\n-        }\n-        ast::Macro::MacroDef(node) => {\n-            if let Some(vis) = node.visibility() {\n-                format_to!(s, \"{} \", vis);\n-            }\n-            format_to!(s, \"macro\");\n-        }\n-    }\n-    if let Some(name) = name {\n-        format_to!(s, \" {}\", name);\n-    }\n-    s\n-}\n-\n-pub fn fn_as_proc_macro_label(node: &ast::Fn) -> String {\n-    let name = node.name();\n-    let mut s = String::new();\n-    if let Some(vis) = node.visibility() {\n-        format_to!(s, \"{} \", vis);\n-    }\n-    format_to!(s, \"macro\");\n-    if let Some(name) = name {\n-        format_to!(s, \" {}\", name);\n-    }\n-    s\n-}"}]}