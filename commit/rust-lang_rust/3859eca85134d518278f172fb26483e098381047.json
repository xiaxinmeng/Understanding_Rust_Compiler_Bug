{"sha": "3859eca85134d518278f172fb26483e098381047", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NTllY2E4NTEzNGQ1MTgyNzhmMTcyZmIyNjQ4M2UwOTgzODEwNDc=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-29T22:26:11Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-30T18:42:51Z"}, "message": "Improved tests + typo fixes + assert", "tree": {"sha": "dfdb91a05d91b8280996694dfd54df9f1d1aac69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfdb91a05d91b8280996694dfd54df9f1d1aac69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3859eca85134d518278f172fb26483e098381047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3859eca85134d518278f172fb26483e098381047", "html_url": "https://github.com/rust-lang/rust/commit/3859eca85134d518278f172fb26483e098381047", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3859eca85134d518278f172fb26483e098381047/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6943430e6d0ff11db4d99544cef7d480b15385e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6943430e6d0ff11db4d99544cef7d480b15385e5", "html_url": "https://github.com/rust-lang/rust/commit/6943430e6d0ff11db4d99544cef7d480b15385e5"}], "stats": {"total": 106, "additions": 89, "deletions": 17}, "files": [{"sha": "bde1010b523aba4783dedfd12eef561cbca1476f", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3859eca85134d518278f172fb26483e098381047/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3859eca85134d518278f172fb26483e098381047/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=3859eca85134d518278f172fb26483e098381047", "patch": "@@ -396,6 +396,8 @@ where\n         // be a `?` separator followed by any Kleene operator. We need to look ahead 1 token to\n         // find out which.\n         Ok(Ok(op)) => {\n+            assert_eq!(op, KleeneOp::ZeroOrOne);\n+\n             // Lookahead at #2. If it is a KleenOp, then #1 is a separator.\n             let is_1_sep = if let Some(&tokenstream::TokenTree::Token(_, ref tok2)) = input.peek() {\n                 kleene_op(tok2).is_some()"}, {"sha": "6da049374086a28cc65b793654c4eeb1e7b8e9cb", "filename": "src/test/compile-fail/issue-39388.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3859eca85134d518278f172fb26483e098381047/src%2Ftest%2Fcompile-fail%2Fissue-39388.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3859eca85134d518278f172fb26483e098381047/src%2Ftest%2Fcompile-fail%2Fissue-39388.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39388.rs?ref=3859eca85134d518278f172fb26483e098381047", "patch": "@@ -11,7 +11,7 @@\n #![allow(unused_macros)]\n \n macro_rules! assign {\n-    (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR 14:22: 14:29: expected one of: `*`, `+`, or `?`\n+    (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR expected one of: `*`, `+`, or `?`\n         $($a)* = $($b)*\n     }\n }"}, {"sha": "a5660f8b41f8da43aeeea29deefa8607dc764bf4", "filename": "src/test/compile-fail/macro-at-most-once-rep-ambig.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3859eca85134d518278f172fb26483e098381047/src%2Ftest%2Fcompile-fail%2Fmacro-at-most-once-rep-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3859eca85134d518278f172fb26483e098381047/src%2Ftest%2Fcompile-fail%2Fmacro-at-most-once-rep-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-at-most-once-rep-ambig.rs?ref=3859eca85134d518278f172fb26483e098381047", "patch": "@@ -8,6 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// The logic for parsing Kleene operators in macros has a special case to disambiguate `?`.\n+// Specifically, `$(pat)?` is the ZeroOrOne operator whereas `$(pat)?+` or `$(pat)?*` are the\n+// ZeroOrMore and OneOrMore operators using `?` as a separator. These tests are intended to\n+// exercise that logic in the macro parser.\n+//\n+// Moreover, we also throw in some tests for using a separator with `?`, which is meaningless but\n+// included for consistency with `+` and `*`.\n+//\n+// This test focuses on error cases.\n+\n #![feature(macro_at_most_once_rep)]\n \n macro_rules! foo {\n@@ -18,10 +28,14 @@ macro_rules! baz {\n     ($(a),?) => {} // comma separator is meaningless for `?`\n }\n \n-macro_rules! bar {\n+macro_rules! barplus {\n     ($(a)?+) => {}\n }\n \n+macro_rules! barstar {\n+    ($(a)?*) => {}\n+}\n+\n pub fn main() {\n     foo!(a?a?a); //~ ERROR no rules expected the token `?`\n     foo!(a?a); //~ ERROR no rules expected the token `?`\n@@ -33,6 +47,7 @@ pub fn main() {\n     baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n     baz!(a?a,); //~ ERROR no rules expected the token `?`\n     baz!(a?,); //~ ERROR no rules expected the token `?`\n-    bar!(); //~ ERROR unexpected end of macro invocation\n-    bar!(a?); //~ ERROR unexpected end of macro invocation\n+    barplus!(); //~ ERROR unexpected end of macro invocation\n+    barplus!(a?); //~ ERROR unexpected end of macro invocation\n+    barstar!(a?); //~ ERROR unexpected end of macro invocation\n }"}, {"sha": "b7e942f938321ae8f033a65909cea38975d856e2", "filename": "src/test/run-pass/macro-at-most-once-rep.rs", "status": "modified", "additions": 66, "deletions": 11, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3859eca85134d518278f172fb26483e098381047/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3859eca85134d518278f172fb26483e098381047/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs?ref=3859eca85134d518278f172fb26483e098381047", "patch": "@@ -8,26 +8,81 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// The logic for parsing Kleene operators in macros has a special case to disambiguate `?`.\n+// Specifically, `$(pat)?` is the ZeroOrOne operator whereas `$(pat)?+` or `$(pat)?*` are the\n+// ZeroOrMore and OneOrMore operators using `?` as a separator. These tests are intended to\n+// exercise that logic in the macro parser.\n+//\n+// Moreover, we also throw in some tests for using a separator with `?`, which is meaningless but\n+// included for consistency with `+` and `*`.\n+//\n+// This test focuses on non-error cases and making sure the correct number of repetitions happen.\n+\n #![feature(macro_at_most_once_rep)]\n \n macro_rules! foo {\n-    ($(a)?) => {}\n+    ($($a:ident)? ; $num:expr) => { {\n+        let mut x = 0;\n+\n+        $(\n+            x += $a;\n+         )?\n+\n+        assert_eq!(x, $num);\n+    } }\n }\n \n macro_rules! baz {\n-    ($(a),?) => {} // comma separator is meaningless for `?`\n+    ($($a:ident),? ; $num:expr) => { { // comma separator is meaningless for `?`\n+        let mut x = 0;\n+\n+        $(\n+            x += $a;\n+         )?\n+\n+        assert_eq!(x, $num);\n+    } }\n }\n \n-macro_rules! bar {\n-    ($(a)?+) => {}\n+macro_rules! barplus {\n+    ($($a:ident)?+ ; $num:expr) => { {\n+        let mut x = 0;\n+\n+        $(\n+            x += $a;\n+         )+\n+\n+        assert_eq!(x, $num);\n+    } }\n+}\n+\n+macro_rules! barstar {\n+    ($($a:ident)?* ; $num:expr) => { {\n+        let mut x = 0;\n+\n+        $(\n+            x += $a;\n+         )*\n+\n+        assert_eq!(x, $num);\n+    } }\n }\n \n pub fn main() {\n-    foo!();\n-    foo!(a);\n-    baz!();\n-    baz!(a);\n-    bar!(a);\n-    bar!(a?a);\n-    bar!(a?a?a);\n+    let a = 1;\n+\n+    // accept 0 or 1 repetitions\n+    foo!( ; 0);\n+    foo!(a ; 1);\n+    baz!( ; 0);\n+    baz!(a ; 1);\n+\n+    // Make sure using ? as a separator works as before\n+    barplus!(a ; 1);\n+    barplus!(a?a ; 2);\n+    barplus!(a?a?a ; 3);\n+    barstar!( ; 0);\n+    barstar!(a ; 1);\n+    barstar!(a?a ; 2);\n+    barstar!(a?a?a ; 3);\n }"}, {"sha": "19f5aca5730e1b18d0f2b4ae83462de391378d25", "filename": "src/test/ui/feature-gate-macro_at_most_once_rep.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3859eca85134d518278f172fb26483e098381047/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3859eca85134d518278f172fb26483e098381047/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.rs?ref=3859eca85134d518278f172fb26483e098381047", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that the MSP430 interrupt ABI cannot be used when msp430_interrupt\n-// feature gate is not used.\n+// Test that `?` macro Kleene operator can not be used when the `macro_at_most_once_rep` feature\n+// gate is not used.\n \n macro_rules! m { ($(a)?) => {} }\n //~^ ERROR Using the `?` macro Kleene operator for \"at most one\" repetition is unstable"}]}