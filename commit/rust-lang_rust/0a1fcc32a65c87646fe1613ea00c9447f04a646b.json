{"sha": "0a1fcc32a65c87646fe1613ea00c9447f04a646b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMWZjYzMyYTY1Yzg3NjQ2ZmUxNjEzZWEwMGM5NDQ3ZjA0YTY0NmI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-26T15:33:50Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:28Z"}, "message": "rustc_trans: use *[T; 0] for slice data pointers instead of *T.", "tree": {"sha": "c09dec48219e050a15f9e9538ad91e3041627d2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c09dec48219e050a15f9e9538ad91e3041627d2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a1fcc32a65c87646fe1613ea00c9447f04a646b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1fcc32a65c87646fe1613ea00c9447f04a646b", "html_url": "https://github.com/rust-lang/rust/commit/0a1fcc32a65c87646fe1613ea00c9447f04a646b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a1fcc32a65c87646fe1613ea00c9447f04a646b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "url": "https://api.github.com/repos/rust-lang/rust/commits/84b5a3d84d6cc81423821cb3cbcf6cca3985b601", "html_url": "https://github.com/rust-lang/rust/commit/84b5a3d84d6cc81423821cb3cbcf6cca3985b601"}], "stats": {"total": 62, "additions": 29, "deletions": 33}, "files": [{"sha": "749c5393e43e9c17635e961c4cd3a748ada93c20", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=0a1fcc32a65c87646fe1613ea00c9447f04a646b", "patch": "@@ -265,7 +265,8 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     let len = s.len();\n-    let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n+    let cs = consts::ptrcast(C_cstr(cx, s, false),\n+        cx.llvm_type_of(cx.tcx().mk_str()).ptr_to());\n     C_named_struct(cx.str_slice_type(), &[cs, C_usize(cx, len as u64)])\n }\n "}, {"sha": "4e003edac3c6b992097c154009447d6a560ac34f", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=0a1fcc32a65c87646fe1613ea00c9447f04a646b", "patch": "@@ -395,7 +395,9 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                     let dummy_ccx = LocalCrateContext::dummy_ccx(shared,\n                                                                  local_ccxs.as_mut_slice());\n                     let mut str_slice_ty = Type::named_struct(&dummy_ccx, \"str_slice\");\n-                    str_slice_ty.set_struct_body(&[Type::i8p(&dummy_ccx),\n+\n+                    let llptrty = dummy_ccx.llvm_type_of(shared.tcx.mk_str()).ptr_to();\n+                    str_slice_ty.set_struct_body(&[llptrty,\n                                                    Type::isize(&dummy_ccx)],\n                                                  false);\n                     (Type::isize(&dummy_ccx), str_slice_ty)"}, {"sha": "8bd4142f2c1a43d046448b47d2549bb04f1a588a", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=0a1fcc32a65c87646fe1613ea00c9447f04a646b", "patch": "@@ -456,18 +456,8 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n     pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef)\n                          -> LvalueRef<'tcx> {\n-        let ty = self.ty.to_ty(bcx.tcx());\n-        let (ptr, elem_ty) = match ty.sty {\n-            ty::TySlice(ty) => {\n-                // Slices already point to the array element type.\n-                (bcx.inbounds_gep(self.llval, &[llindex]), ty)\n-            }\n-            ty::TyArray(ty, _) => {\n-                let zero = common::C_usize(bcx.ccx, 0);\n-                (bcx.inbounds_gep(self.llval, &[zero, llindex]), ty)\n-            }\n-            _ => bug!(\"unexpected type `{}` in LvalueRef::project_index\", ty)\n-        };\n+        let ptr = bcx.inbounds_gep(self.llval, &[common::C_usize(bcx.ccx, 0), llindex]);\n+        let elem_ty = self.ty.to_ty(bcx.tcx()).builtin_index().unwrap();\n         LvalueRef::new_sized(ptr, elem_ty, self.alignment)\n     }\n \n@@ -577,12 +567,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         subslice.ty = self.monomorphize(&subslice.ty);\n \n                         match subslice.ty.to_ty(tcx).sty {\n-                            ty::TyArray(..) => {\n-                                // must cast the lvalue pointer type to the new\n-                                // array type (*[%_; new_len]).\n-                                subslice.llval = bcx.pointercast(subslice.llval,\n-                                    bcx.ccx.llvm_type_of(subslice.ty.to_ty(tcx)).ptr_to())\n-                            }\n+                            ty::TyArray(..) => {}\n                             ty::TySlice(..) => {\n                                 assert!(tr_base.has_extra());\n                                 subslice.llextra = bcx.sub(tr_base.llextra,\n@@ -591,6 +576,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             _ => bug!(\"unexpected type {:?} in Subslice\", subslice.ty)\n                         }\n \n+                        // Cast the lvalue pointer type to the new\n+                        // array or slice type (*[%_; new_len]).\n+                        subslice.llval = bcx.pointercast(subslice.llval,\n+                            bcx.ccx.llvm_type_of(subslice.ty.to_ty(tcx)).ptr_to());\n+\n                         subslice\n                     }\n                     mir::ProjectionElem::Downcast(_, v) => {"}, {"sha": "d130595763447f05f65973c96bcfbb2c42df3170", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=0a1fcc32a65c87646fe1613ea00c9447f04a646b", "patch": "@@ -115,12 +115,14 @@ fn compute_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type\n           Type::array(&llty, size)\n       }\n \n-      // Unsized slice types (and str) have the type of their element, and\n-      // traits have the type of u8. This is so that the data pointer inside\n-      // fat pointers is of the right type (e.g. for array accesses), even\n-      // when taking the address of an unsized field in a struct.\n-      ty::TySlice(ty) => cx.llvm_type_of(ty),\n-      ty::TyStr | ty::TyDynamic(..) | ty::TyForeign(..) => Type::i8(cx),\n+      ty::TySlice(ty) => {\n+          Type::array(&cx.llvm_type_of(ty), 0)\n+      }\n+      ty::TyStr => {\n+          Type::array(&Type::i8(cx), 0)\n+      }\n+      ty::TyDynamic(..) |\n+      ty::TyForeign(..) => adt::type_of(cx, t),\n \n       ty::TyFnDef(..) => Type::nil(cx),\n       ty::TyFnPtr(sig) => {"}, {"sha": "56f9b98b48294d636ced64689a572b4cc455c785", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=0a1fcc32a65c87646fe1613ea00c9447f04a646b", "patch": "@@ -23,9 +23,10 @@ pub fn helper(_: usize) {\n pub fn no_op_slice_adjustment(x: &[u8]) -> &[u8] {\n     // We used to generate an extra alloca and memcpy for the block's trailing expression value, so\n     // check that we copy directly to the return value slot\n-// CHECK: %0 = insertvalue { i8*, [[USIZE]] } undef, i8* %x.ptr, 0\n-// CHECK: %1 = insertvalue { i8*, [[USIZE]] } %0, [[USIZE]] %x.meta, 1\n-// CHECK: ret { i8*, [[USIZE]] } %1\n+// CHECK: %x.ptr = bitcast i8* %0 to [0 x i8]*\n+// CHECK: %1 = insertvalue { [0 x i8]*, [[USIZE]] } undef, [0 x i8]* %x.ptr, 0\n+// CHECK: %2 = insertvalue { [0 x i8]*, [[USIZE]] } %1, [[USIZE]] %x.meta, 1\n+// CHECK: ret { [0 x i8]*, [[USIZE]] } %2\n     { x }\n }\n "}, {"sha": "0bacb81624120bf86c7e8c41bd9e3ca2248ccf42", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=0a1fcc32a65c87646fe1613ea00c9447f04a646b", "patch": "@@ -132,7 +132,7 @@ pub fn trait_borrow(_: &Drop) {\n pub fn trait_box(_: Box<Drop>) {\n }\n \n-// CHECK: { i16*, [[USIZE]] } @return_slice(i16* noalias nonnull readonly %x.ptr, [[USIZE]] %x.meta)\n+// CHECK: { [0 x i16]*, [[USIZE]] } @return_slice(i16* noalias nonnull readonly %x.ptr, [[USIZE]] %x.meta)\n #[no_mangle]\n pub fn return_slice(x: &[u16]) -> &[u16] {\n   x"}, {"sha": "d191bedee5d99f99ca0fad6323d9e3c87dff639b", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1fcc32a65c87646fe1613ea00c9447f04a646b/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=0a1fcc32a65c87646fe1613ea00c9447f04a646b", "patch": "@@ -23,9 +23,9 @@ pub fn helper(_: usize) {\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n-// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 0\n-// CHECK: store i8* %s.ptr, i8** [[X0]]\n-// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 1\n+// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { [0 x i8]*, [[USIZE]] }* %x, i32 0, i32 0\n+// CHECK: store [0 x i8]* %s.ptr, [0 x i8]** [[X0]]\n+// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { [0 x i8]*, [[USIZE]] }* %x, i32 0, i32 1\n // CHECK: store [[USIZE]] %s.meta, [[USIZE]]* [[X1]]\n \n     let x = &*s;"}]}