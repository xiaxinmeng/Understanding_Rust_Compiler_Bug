{"sha": "fec7a790888f103b8aa5374e7ddba50295ba64ec", "node_id": "C_kwDOAAsO6NoAKGZlYzdhNzkwODg4ZjEwM2I4YWE1Mzc0ZTdkZGJhNTAyOTViYTY0ZWM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-03-03T19:01:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-03T19:01:44Z"}, "message": "Rollup merge of #94057 - lcnr:simplify_type-uwu, r=nikomatsakis\n\nimprove comments for `simplify_type`\n\nShould now correctly describe what's going on. Experimented with checking the invariant for projections\nbut that ended up requiring fairly involved changes. I assume that it is not possible to get unsoundness here,\nat least for now and I can pretty much guarantee that it's impossible to trigger it by accident.\n\nr? `````@nikomatsakis````` cc #92721", "tree": {"sha": "549e94dabab1646a5516b7b0aaaa5f453cbbac7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/549e94dabab1646a5516b7b0aaaa5f453cbbac7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fec7a790888f103b8aa5374e7ddba50295ba64ec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiIRCZCRBK7hj4Ov3rIwAAvo4IABuE9cjHE18Wy7BeRlynK04d\nre0DrJjEeYo7/C0yYqGw3sM7nW8+9HcollfOOrDW0wd01JJ5nq2RDFNp/3Q7DqiP\nFOwtpb9kl8XclGjsYgK4gOZb7cb1+alFr+UTx5lcLo66Xo0CJDnki5OqY/H14uOs\nnCwl1uktl7SextqaBFonU0SU+P8l7m85ho4dWl0fr4te4KefEPmQyChFm92HsKd/\nPTmMRQpgf5oKoZt9aoAAKKcw/MNimaX5Sk1b4ZkvtGMD1OShTC3pCCdGp3rhURwF\nxddMgLTyiXaxfCe8HupGKrcnVzXggnOL88S9dcNU0Mn4mSYDH0efgBByrvQf9Ik=\n=vUDy\n-----END PGP SIGNATURE-----\n", "payload": "tree 549e94dabab1646a5516b7b0aaaa5f453cbbac7f\nparent a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed\nparent ba2e0ca6f0574d317fdbc7d228b0f621ca89ac9f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1646334104 +0100\ncommitter GitHub <noreply@github.com> 1646334104 +0100\n\nRollup merge of #94057 - lcnr:simplify_type-uwu, r=nikomatsakis\n\nimprove comments for `simplify_type`\n\nShould now correctly describe what's going on. Experimented with checking the invariant for projections\nbut that ended up requiring fairly involved changes. I assume that it is not possible to get unsoundness here,\nat least for now and I can pretty much guarantee that it's impossible to trigger it by accident.\n\nr? `````@nikomatsakis````` cc #92721\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fec7a790888f103b8aa5374e7ddba50295ba64ec", "html_url": "https://github.com/rust-lang/rust/commit/fec7a790888f103b8aa5374e7ddba50295ba64ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fec7a790888f103b8aa5374e7ddba50295ba64ec/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed", "html_url": "https://github.com/rust-lang/rust/commit/a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed"}, {"sha": "ba2e0ca6f0574d317fdbc7d228b0f621ca89ac9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba2e0ca6f0574d317fdbc7d228b0f621ca89ac9f", "html_url": "https://github.com/rust-lang/rust/commit/ba2e0ca6f0574d317fdbc7d228b0f621ca89ac9f"}], "stats": {"total": 126, "additions": 66, "deletions": 60}, "files": [{"sha": "06f73c1c91600d4a955e39c5331dc4190b3efcce", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=fec7a790888f103b8aa5374e7ddba50295ba64ec", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::mir::interpret;\n use rustc_middle::thir;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n@@ -2043,7 +2043,7 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplsVisitor<'tcx> {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),\n-                        SimplifyParams::No,\n+                        TreatParams::AsPlaceholders,\n                     );\n \n                     self.impls"}, {"sha": "c0dd4db2945dc0f0c710b0449d08a3d215943fc8", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=fec7a790888f103b8aa5374e7ddba50295ba64ec", "patch": "@@ -49,36 +49,36 @@ where\n }\n \n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n-pub enum SimplifyParams {\n-    Yes,\n-    No,\n+pub enum TreatParams {\n+    /// Treat parameters as bound types in the given environment.\n+    ///\n+    /// For this to be correct the input has to be fully normalized\n+    /// in its param env as it may otherwise cause us to ignore\n+    /// potentially applying impls.\n+    AsBoundTypes,\n+    AsPlaceholders,\n }\n \n /// Tries to simplify a type by only returning the outermost injective\u00b9 layer, if one exists.\n ///\n /// The idea is to get something simple that we can use to quickly decide if two types could unify,\n /// for example during method lookup.\n ///\n-/// A special case here are parameters and projections. Projections can be normalized to\n-/// a different type, meaning that `<T as Trait>::Assoc` and `u8` can be unified, even though\n-/// their outermost layer is different while parameters like `T` of impls are later replaced\n-/// with an inference variable, which then also allows unification with other types.\n+/// A special case here are parameters and projections, which are only injective\n+/// if they are treated as bound types.\n ///\n-/// When using `SimplifyParams::Yes`, we still return a simplified type for params and projections\u00b2,\n-/// the reasoning for this can be seen at the places doing this.\n+/// For example when storing impls based on their simplified self type, we treat\n+/// generic parameters as placeholders. We must not simplify them here,\n+/// as they can unify with any other type.\n ///\n+/// With projections we have to be even more careful, as even when treating them as bound types\n+/// this is still only correct if they are fully normalized.\n ///\n-/// \u00b9 meaning that if two outermost layers are different, then the whole types are also different.\n-/// \u00b2 FIXME(@lcnr): this seems like it can actually end up being unsound with the way it's used during\n-///   candidate selection. We do not consider non blanket impls for `<_ as Trait>::Assoc` even\n-///   though `_` can be inferred to a concrete type later at which point a concrete impl\n-///   could actually apply. After experimenting for about an hour I wasn't able to cause any issues\n-///   this way so I am not going to change this until we actually find an issue as I am really\n-///   interesting in getting an actual test for this.\n-pub fn simplify_type(\n-    tcx: TyCtxt<'_>,\n-    ty: Ty<'_>,\n-    can_simplify_params: SimplifyParams,\n+/// \u00b9 meaning that if the outermost layers are different, then the whole types are also different.\n+pub fn simplify_type<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    treat_params: TreatParams,\n ) -> Option<SimplifiedType> {\n     match *ty.kind() {\n         ty::Bool => Some(BoolSimplifiedType),\n@@ -91,7 +91,7 @@ pub fn simplify_type(\n         ty::Array(..) => Some(ArraySimplifiedType),\n         ty::Slice(..) => Some(SliceSimplifiedType),\n         ty::RawPtr(ptr) => Some(PtrSimplifiedType(ptr.mutbl)),\n-        ty::Dynamic(ref trait_info, ..) => match trait_info.principal_def_id() {\n+        ty::Dynamic(trait_info, ..) => match trait_info.principal_def_id() {\n             Some(principal_def_id) if !tcx.trait_is_auto(principal_def_id) => {\n                 Some(TraitSimplifiedType(principal_def_id))\n             }\n@@ -100,24 +100,21 @@ pub fn simplify_type(\n         ty::Ref(_, _, mutbl) => Some(RefSimplifiedType(mutbl)),\n         ty::FnDef(def_id, _) | ty::Closure(def_id, _) => Some(ClosureSimplifiedType(def_id)),\n         ty::Generator(def_id, _, _) => Some(GeneratorSimplifiedType(def_id)),\n-        ty::GeneratorWitness(ref tys) => {\n-            Some(GeneratorWitnessSimplifiedType(tys.skip_binder().len()))\n-        }\n+        ty::GeneratorWitness(tys) => Some(GeneratorWitnessSimplifiedType(tys.skip_binder().len())),\n         ty::Never => Some(NeverSimplifiedType),\n-        ty::Tuple(ref tys) => Some(TupleSimplifiedType(tys.len())),\n-        ty::FnPtr(ref f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n-        ty::Projection(_) | ty::Param(_) => {\n-            if can_simplify_params == SimplifyParams::Yes {\n-                // In normalized types, projections don't unify with\n-                // anything. when lazy normalization happens, this\n-                // will change. It would still be nice to have a way\n-                // to deal with known-not-to-unify-with-anything\n-                // projections (e.g., the likes of <__S as Encoder>::Error).\n+        ty::Tuple(tys) => Some(TupleSimplifiedType(tys.len())),\n+        ty::FnPtr(f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n+        ty::Param(_) | ty::Projection(_) => match treat_params {\n+            // When treated as bound types, projections don't unify with\n+            // anything as long as they are fully normalized.\n+            //\n+            // We will have to be careful with lazy normalization here.\n+            TreatParams::AsBoundTypes => {\n+                debug!(\"treating `{}` as a bound type\", ty);\n                 Some(ParameterSimplifiedType)\n-            } else {\n-                None\n             }\n-        }\n+            TreatParams::AsPlaceholders => None,\n+        },\n         ty::Opaque(def_id, _) => Some(OpaqueSimplifiedType(def_id)),\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Placeholder(..) | ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,"}, {"sha": "8ebeca50c4174c5b8d353fc7bbc0be39c81fa5d5", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=fec7a790888f103b8aa5374e7ddba50295ba64ec", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::specialization_graph;\n-use crate::ty::fast_reject::{self, SimplifiedType, SimplifyParams};\n+use crate::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{Ident, Ty, TyCtxt};\n use rustc_hir as hir;\n@@ -150,7 +150,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n     ) -> impl Iterator<Item = DefId> + 'tcx {\n         let impls = self.trait_impls_of(def_id);\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, SimplifyParams::No) {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsPlaceholders) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 return impls.iter().copied();\n             }\n@@ -180,14 +180,14 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        // Note that we're using `SimplifyParams::Yes` to query `non_blanket_impls` while using\n-        // `SimplifyParams::No` while actually adding them.\n+        // Note that we're using `TreatParams::AsBoundTypes` to query `non_blanket_impls` while using\n+        // `TreatParams::AsPlaceholders` while actually adding them.\n         //\n         // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n         // whose outer level is not a parameter or projection. Especially for things like\n         // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n         // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, SimplifyParams::Yes) {\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsBoundTypes) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n                     if let result @ Some(_) = f(impl_def_id) {\n@@ -247,7 +247,7 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n         }\n \n         if let Some(simplified_self_ty) =\n-            fast_reject::simplify_type(tcx, impl_self_ty, SimplifyParams::No)\n+            fast_reject::simplify_type(tcx, impl_self_ty, TreatParams::AsPlaceholders)\n         {\n             impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n         } else {"}, {"sha": "63efa951f9674717f5af28044c85678c20160027", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=fec7a790888f103b8aa5374e7ddba50295ba64ec", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::CRATE_HIR_ID;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n-use rustc_middle::ty::fast_reject::{self, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, TreatParams};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -87,8 +87,8 @@ where\n         impl2_ref.iter().flat_map(|tref| tref.substs.types()),\n     )\n     .any(|(ty1, ty2)| {\n-        let t1 = fast_reject::simplify_type(tcx, ty1, SimplifyParams::No);\n-        let t2 = fast_reject::simplify_type(tcx, ty2, SimplifyParams::No);\n+        let t1 = fast_reject::simplify_type(tcx, ty1, TreatParams::AsPlaceholders);\n+        let t2 = fast_reject::simplify_type(tcx, ty2, TreatParams::AsPlaceholders);\n \n         if let (Some(t1), Some(t2)) = (t1, t2) {\n             // Simplified successfully"}, {"sha": "8af4606db85200eec7d87ecd70e71776ee725ffe", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=fec7a790888f103b8aa5374e7ddba50295ba64ec", "patch": "@@ -36,7 +36,7 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n-use rustc_middle::ty::fast_reject::{self, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, TreatParams};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n@@ -2176,8 +2176,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn fast_reject_trait_refs(\n         &mut self,\n-        obligation: &TraitObligation<'_>,\n-        impl_trait_ref: &ty::TraitRef<'_>,\n+        obligation: &TraitObligation<'tcx>,\n+        impl_trait_ref: &ty::TraitRef<'tcx>,\n     ) -> bool {\n         // We can avoid creating type variables and doing the full\n         // substitution if we find that any of the input types, when\n@@ -2193,10 +2193,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         let simplified_obligation_ty = fast_reject::simplify_type(\n                             self.tcx(),\n                             obligation_ty,\n-                            SimplifyParams::Yes,\n+                            TreatParams::AsBoundTypes,\n+                        );\n+                        let simplified_impl_ty = fast_reject::simplify_type(\n+                            self.tcx(),\n+                            impl_ty,\n+                            TreatParams::AsPlaceholders,\n                         );\n-                        let simplified_impl_ty =\n-                            fast_reject::simplify_type(self.tcx(), impl_ty, SimplifyParams::No);\n \n                         simplified_obligation_ty.is_some()\n                             && simplified_impl_ty.is_some()"}, {"sha": "8b23dcfe3808abce209899d91b369e28e7dfd85f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=fec7a790888f103b8aa5374e7ddba50295ba64ec", "patch": "@@ -2,7 +2,7 @@ use super::OverlapError;\n \n use crate::traits;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n \n@@ -49,7 +49,9 @@ impl ChildrenExt<'_> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'_>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), SimplifyParams::No) {\n+        if let Some(st) =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders)\n+        {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             self.non_blanket_impls.entry(st).or_default().push(impl_def_id)\n         } else {\n@@ -64,7 +66,9 @@ impl ChildrenExt<'_> for Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'_>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), SimplifyParams::No) {\n+        if let Some(st) =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders)\n+        {\n             debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             vec = self.non_blanket_impls.get_mut(&st).unwrap();\n         } else {\n@@ -312,7 +316,8 @@ impl GraphExt for Graph {\n \n         let mut parent = trait_def_id;\n         let mut last_lint = None;\n-        let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), SimplifyParams::No);\n+        let simplified =\n+            fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsPlaceholders);\n \n         // Descend the specialization tree, where `parent` is the current parent node.\n         loop {"}, {"sha": "0ae2dfa180b9eaaf940ca348cd98afd21bf80ff7", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec7a790888f103b8aa5374e7ddba50295ba64ec/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=fec7a790888f103b8aa5374e7ddba50295ba64ec", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n-use rustc_middle::ty::fast_reject::{simplify_type, SimplifyParams};\n+use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::ToPolyTraitRef;\n use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -1777,7 +1777,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // FIXME: Even though negative bounds are not implemented, we could maybe handle\n                 // cases where a positive bound implies a negative impl.\n                 (candidates, Vec::new())\n-            } else if let Some(simp_rcvr_ty) = simplify_type(self.tcx, rcvr_ty, SimplifyParams::Yes)\n+            } else if let Some(simp_rcvr_ty) =\n+                simplify_type(self.tcx, rcvr_ty, TreatParams::AsBoundTypes)\n             {\n                 let mut potential_candidates = Vec::new();\n                 let mut explicitly_negative = Vec::new();\n@@ -1792,7 +1793,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .any(|imp_did| {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap();\n                             let imp_simp =\n-                                simplify_type(self.tcx, imp.self_ty(), SimplifyParams::Yes);\n+                                simplify_type(self.tcx, imp.self_ty(), TreatParams::AsBoundTypes);\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n                         })\n                     {"}]}