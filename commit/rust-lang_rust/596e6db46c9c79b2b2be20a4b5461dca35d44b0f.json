{"sha": "596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NmU2ZGI0NmM5Yzc5YjJiMmJlMjBhNGI1NDYxZGNhMzVkNDRiMGY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-08T11:52:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-08T11:52:43Z"}, "message": "Merge #2499\n\n2499: Remove ty from code_model r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "e2ed14ae5aaf7756b1b8f19eaf1318102bd9a26b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2ed14ae5aaf7756b1b8f19eaf1318102bd9a26b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd7OQLCRBK7hj4Ov3rIwAAdHIIAAIfTZTgry8MjWJd5m8gYvqC\n39rI1LobpKzwzGPxojxMUgJoHAPMocRaJ63i1UdKojB6HSBgg2z9mdSiT3Oq+WKS\ncWQ4Ph+gzY2bqdRZ9BhxPx+rx6Rvl/NRVOekvlTv9yBp1UK1x+FmmdrLFyUdhRfR\nuVzmgxwW24oUE+kTKBpsuuw6q3Rtp3duyjcRLPcX14Iwy+kX4pUAVTBy1mxod/6E\n7ugloBylHDPLYeMaSGlgDp9gdBgGRYbjgqF7gtz5Tj/ryWIPajYfbD8BtdrxinE+\nnQbrTmx97zAbl6K47d/qwbdsoBLNldzbrJzQ7EpAmtG+6EDQMU9e+FxNT00dJoI=\n=e9lh\n-----END PGP SIGNATURE-----\n", "payload": "tree e2ed14ae5aaf7756b1b8f19eaf1318102bd9a26b\nparent 7a6b6ed0a5311cabee9d68a89100aed46523243b\nparent e2cc55207619f987fd5cc274628b8e49e15ec856\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575805963 +0000\ncommitter GitHub <noreply@github.com> 1575805963 +0000\n\nMerge #2499\n\n2499: Remove ty from code_model r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "html_url": "https://github.com/rust-lang/rust/commit/596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a6b6ed0a5311cabee9d68a89100aed46523243b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a6b6ed0a5311cabee9d68a89100aed46523243b", "html_url": "https://github.com/rust-lang/rust/commit/7a6b6ed0a5311cabee9d68a89100aed46523243b"}, {"sha": "e2cc55207619f987fd5cc274628b8e49e15ec856", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2cc55207619f987fd5cc274628b8e49e15ec856", "html_url": "https://github.com/rust-lang/rust/commit/e2cc55207619f987fd5cc274628b8e49e15ec856"}], "stats": {"total": 164, "additions": 54, "deletions": 110}, "files": [{"sha": "d80e5854824bf8dc2da60e5ede150c57fd99a2b1", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "patch": "@@ -919,6 +919,8 @@ dependencies = [\n  \"ra_batch 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_hir 0.1.0\",\n+ \"ra_hir_def 0.1.0\",\n+ \"ra_hir_ty 0.1.0\",\n  \"ra_ide 0.1.0\",\n  \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\","}, {"sha": "12af075f7df06219f9d045bb5d5a30724bb2dca0", "filename": "crates/ra_cli/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2FCargo.toml?ref=596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "patch": "@@ -12,7 +12,9 @@ env_logger = { version = \"0.7.1\", default-features = false, features = [\"humanti\n ra_syntax = { path = \"../ra_syntax\" }\n ra_ide = { path = \"../ra_ide\" }\n ra_batch = { path = \"../ra_batch\" }\n-ra_hir = { path = \"../ra_hir\" }\n+hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n+hir_ty = { path = \"../ra_hir_ty\", package = \"ra_hir_ty\" }\n+hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n ra_db = { path = \"../ra_db\" }\n \n [dependencies.ra_prof]"}, {"sha": "ac65415a5e7ed207166b7bec497812a3933d6377", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "patch": "@@ -2,8 +2,13 @@\n \n use std::{collections::HashSet, fmt::Write, path::Path, time::Instant};\n \n+use hir::{\n+    db::{DefDatabase, HirDatabase},\n+    AssocItem, Crate, HasSource, HirDisplay, ModuleDef,\n+};\n+use hir_def::FunctionId;\n+use hir_ty::{Ty, TypeWalk};\n use ra_db::SourceDatabaseExt;\n-use ra_hir::{AssocItem, Crate, HasSource, HirDisplay, ModuleDef, Ty, TypeWalk};\n use ra_syntax::AstNode;\n \n use crate::{progress_report::ProgressReport, Result, Verbosity};\n@@ -101,8 +106,9 @@ pub fn run(\n                 continue;\n             }\n         }\n-        let body = f.body(db);\n-        let inference_result = f.infer(db);\n+        let f_id = FunctionId::from(f);\n+        let body = db.body(f_id.into());\n+        let inference_result = db.infer(f_id.into());\n         for (expr_id, _) in body.exprs.iter() {\n             let ty = &inference_result[expr_id];\n             num_exprs += 1;\n@@ -122,7 +128,8 @@ pub fn run(\n             if let Some(mismatch) = inference_result.type_mismatch_for_expr(expr_id) {\n                 num_type_mismatches += 1;\n                 if verbosity.is_verbose() {\n-                    let src = f.body_source_map(db).expr_syntax(expr_id);\n+                    let (_, sm) = db.body_with_source_map(f_id.into());\n+                    let src = sm.expr_syntax(expr_id);\n                     if let Some(src) = src {\n                         // FIXME: it might be nice to have a function (on Analysis?) that goes from Source<T> -> (LineCol, LineCol) directly\n                         let original_file = src.file_id.original_file(db);"}, {"sha": "7ac1bf461a4fa67cc37ac4262eb3105f96e73afa", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 17, "deletions": 75, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "patch": "@@ -7,7 +7,6 @@ use std::sync::Arc;\n use either::Either;\n use hir_def::{\n     adt::VariantData,\n-    body::{Body, BodySourceMap},\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     expr::{BindingAnnotation, Pat, PatId},\n@@ -24,14 +23,15 @@ use hir_expand::{\n     name::{self, AsName},\n     MacroDefId,\n };\n-use hir_ty::expr::ExprValidator;\n+use hir_ty::{\n+    autoderef, display::HirFormatter, expr::ExprValidator, ApplicationTy, Canonical, InEnvironment,\n+    TraitEnvironment, Ty, TyDefId, TypeCtor, TypeWalk,\n+};\n use ra_db::{CrateId, Edition, FileId};\n use ra_syntax::ast;\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n-    ty::display::HirFormatter,\n-    ty::{self, InEnvironment, InferenceResult, TraitEnvironment, Ty, TyDefId, TypeCtor, TypeWalk},\n     CallableDef, HirDisplay, InFile, Name,\n };\n \n@@ -88,10 +88,6 @@ impl Crate {\n     pub fn all(db: &impl DefDatabase) -> Vec<Crate> {\n         db.crate_graph().iter().map(|id| Crate { id }).collect()\n     }\n-\n-    pub fn crate_id(self) -> CrateId {\n-        self.id\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -511,44 +507,8 @@ impl Function {\n         db.function_data(self.id).params.clone()\n     }\n \n-    pub fn body_source_map(self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map(self.id.into()).1\n-    }\n-\n-    pub fn body(self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body(self.id.into())\n-    }\n-\n-    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.id.into())\n-    }\n-\n-    /// The containing impl block, if this is a method.\n-    pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        match self.container(db) {\n-            Some(Container::ImplBlock(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    /// The containing trait, if this is a trait method definition.\n-    pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        match self.container(db) {\n-            Some(Container::Trait(it)) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n-        match self.id.lookup(db).container {\n-            ContainerId::TraitId(it) => Some(Container::Trait(it.into())),\n-            ContainerId::ImplId(it) => Some(Container::ImplBlock(it.into())),\n-            ContainerId::ModuleId(_) => None,\n-        }\n-    }\n-\n     pub fn diagnostics(self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n-        let infer = self.infer(db);\n+        let infer = db.infer(self.id.into());\n         infer.add_diagnostics(db, self.id, sink);\n         let mut validator = ExprValidator::new(self.id, infer, sink);\n         validator.validate_body(db);\n@@ -573,10 +533,6 @@ impl Const {\n         db.const_data(self.id).name.clone()\n     }\n \n-    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.id.into())\n-    }\n-\n     /// The containing impl block, if this is a type alias.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         match self.container(db) {\n@@ -615,10 +571,6 @@ impl Static {\n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n         Some(self.module(db).krate())\n     }\n-\n-    pub fn infer(self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.id.into())\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -733,15 +685,6 @@ impl AssocItem {\n             AssocItem::TypeAlias(t) => t.module(db),\n         }\n     }\n-\n-    pub fn container(self, db: &impl DefDatabase) -> Container {\n-        match self {\n-            AssocItem::Function(f) => f.container(db),\n-            AssocItem::Const(c) => c.container(db),\n-            AssocItem::TypeAlias(t) => t.container(db),\n-        }\n-        .expect(\"AssocItem without container\")\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n@@ -958,7 +901,7 @@ impl Type {\n     pub fn fields(&self, db: &impl HirDatabase) -> Vec<(StructField, Type)> {\n         if let Ty::Apply(a_ty) = &self.ty.value {\n             match a_ty.ctor {\n-                ty::TypeCtor::Adt(AdtId::StructId(s)) => {\n+                TypeCtor::Adt(AdtId::StructId(s)) => {\n                     let var_def = s.into();\n                     return db\n                         .field_types(var_def)\n@@ -980,7 +923,7 @@ impl Type {\n         let mut res = Vec::new();\n         if let Ty::Apply(a_ty) = &self.ty.value {\n             match a_ty.ctor {\n-                ty::TypeCtor::Tuple { .. } => {\n+                TypeCtor::Tuple { .. } => {\n                     for ty in a_ty.parameters.iter() {\n                         let ty = ty.clone().subst(&a_ty.parameters);\n                         res.push(self.derived(ty));\n@@ -1016,10 +959,10 @@ impl Type {\n     pub fn autoderef<'a>(&'a self, db: &'a impl HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n-        let canonical = crate::ty::Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n         let environment = self.ty.environment.clone();\n         let ty = InEnvironment { value: canonical, environment: environment.clone() };\n-        ty::autoderef(db, Some(self.krate), ty)\n+        autoderef(db, Some(self.krate), ty)\n             .map(|canonical| canonical.value)\n             .map(move |ty| self.derived(ty))\n     }\n@@ -1059,15 +1002,14 @@ impl Type {\n     // FIXME: provide required accessors such that it becomes implementable from outside.\n     pub fn is_equal_for_find_impls(&self, other: &Type) -> bool {\n         match (&self.ty.value, &other.ty.value) {\n-            (Ty::Apply(a_original_ty), Ty::Apply(ty::ApplicationTy { ctor, parameters })) => {\n-                match ctor {\n-                    TypeCtor::Ref(..) => match parameters.as_single() {\n-                        Ty::Apply(a_ty) => a_original_ty.ctor == a_ty.ctor,\n-                        _ => false,\n-                    },\n-                    _ => a_original_ty.ctor == *ctor,\n-                }\n-            }\n+            (Ty::Apply(a_original_ty), Ty::Apply(ApplicationTy { ctor, parameters })) => match ctor\n+            {\n+                TypeCtor::Ref(..) => match parameters.as_single() {\n+                    Ty::Apply(a_ty) => a_original_ty.ctor == a_ty.ctor,\n+                    _ => false,\n+                },\n+                _ => a_original_ty.ctor == *ctor,\n+            },\n             _ => false,\n         }\n     }"}, {"sha": "75a1a77722102e94893af81f4f4f33adc1e35882", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "patch": "@@ -9,27 +9,27 @@ use hir_def::{\n };\n \n use crate::{\n-    Adt, AssocItem, AttrDef, Crate, DefWithBody, EnumVariant, GenericDef, ModuleDef, StructField,\n+    Adt, AssocItem, AttrDef, DefWithBody, EnumVariant, GenericDef, ModuleDef, StructField,\n     VariantDef,\n };\n \n-impl From<ra_db::CrateId> for Crate {\n-    fn from(id: ra_db::CrateId) -> Self {\n-        Crate { id }\n-    }\n-}\n-\n macro_rules! from_id {\n     ($(($id:path, $ty:path)),*) => {$(\n         impl From<$id> for $ty {\n             fn from(id: $id) -> $ty {\n                 $ty { id }\n             }\n         }\n+        impl From<$ty> for $id {\n+            fn from(ty: $ty) -> $id {\n+                ty.id\n+            }\n+        }\n     )*}\n }\n \n from_id![\n+    (ra_db::CrateId, crate::Crate),\n     (hir_def::ModuleId, crate::Module),\n     (hir_def::StructId, crate::Struct),\n     (hir_def::UnionId, crate::Union),"}, {"sha": "bb22882b139d41ddb13532856c5e4a356a99f42c", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "patch": "@@ -31,7 +31,6 @@ pub mod debug;\n pub mod db;\n pub mod source_binder;\n \n-mod ty;\n pub mod diagnostics;\n \n mod from_id;\n@@ -48,11 +47,6 @@ pub use crate::{\n     },\n     from_source::FromSource,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n-    ty::{\n-        display::HirDisplay,\n-        primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain},\n-        ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n-    },\n };\n \n pub use hir_def::{\n@@ -66,3 +60,4 @@ pub use hir_def::{\n pub use hir_expand::{\n     name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, MacroFile,\n };\n+pub use hir_ty::{display::HirDisplay, CallableDef};"}, {"sha": "9efd0477c1be5b2cee0b67c650e454c6693061cc", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "patch": "@@ -22,6 +22,10 @@ use hir_def::{\n use hir_expand::{\n     hygiene::Hygiene, name::AsName, AstId, HirFileId, InFile, MacroCallId, MacroCallKind,\n };\n+use hir_ty::{\n+    method_resolution::{self, implements_trait},\n+    Canonical, InEnvironment, InferenceResult, TraitEnvironment, Ty,\n+};\n use ra_syntax::{\n     ast::{self, AstNode},\n     match_ast, AstPtr,\n@@ -30,13 +34,9 @@ use ra_syntax::{\n };\n \n use crate::{\n-    db::HirDatabase,\n-    ty::{\n-        method_resolution::{self, implements_trait},\n-        InEnvironment, TraitEnvironment, Ty,\n-    },\n-    Adt, AssocItem, Const, DefWithBody, Enum, EnumVariant, FromSource, Function, ImplBlock, Local,\n-    MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n+    db::HirDatabase, Adt, AssocItem, Const, DefWithBody, Enum, EnumVariant, FromSource, Function,\n+    ImplBlock, Local, MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Type, TypeAlias,\n+    TypeParam,\n };\n \n fn try_get_resolver_for_node(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> Option<Resolver> {\n@@ -100,7 +100,7 @@ pub struct SourceAnalyzer {\n     resolver: Resolver,\n     body_owner: Option<DefWithBody>,\n     body_source_map: Option<Arc<BodySourceMap>>,\n-    infer: Option<Arc<crate::ty::InferenceResult>>,\n+    infer: Option<Arc<InferenceResult>>,\n     scopes: Option<Arc<ExprScopes>>,\n }\n \n@@ -376,7 +376,7 @@ impl SourceAnalyzer {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = crate::ty::Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n         method_resolution::iterate_method_candidates(\n             &canonical,\n             db,\n@@ -400,7 +400,7 @@ impl SourceAnalyzer {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = crate::ty::Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n+        let canonical = Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n         method_resolution::iterate_method_candidates(\n             &canonical,\n             db,\n@@ -418,7 +418,7 @@ impl SourceAnalyzer {\n     // ) -> impl Iterator<Item = Ty> + 'a {\n     //     // There should be no inference vars in types passed here\n     //     // FIXME check that?\n-    //     let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+    //     let canonical = Canonical { value: ty, num_vars: 0 };\n     //     let krate = self.resolver.krate();\n     //     let environment = TraitEnvironment::lower(db, &self.resolver);\n     //     let ty = crate::ty::InEnvironment { value: canonical, environment };\n@@ -440,7 +440,7 @@ impl SourceAnalyzer {\n             _ => return false,\n         };\n \n-        let canonical_ty = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        let canonical_ty = Canonical { value: ty, num_vars: 0 };\n         implements_trait(&canonical_ty, db, &self.resolver, krate.into(), std_future_trait)\n     }\n "}, {"sha": "4ed69c00dc4f8a951429b7d1f6071800a90762fb", "filename": "crates/ra_hir/src/ty.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a6b6ed0a5311cabee9d68a89100aed46523243b/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=7a6b6ed0a5311cabee9d68a89100aed46523243b", "patch": "@@ -1,4 +0,0 @@\n-//! The type system. We currently use this to infer types for completion, hover\n-//! information and various assists.\n-\n-pub use hir_ty::*;"}, {"sha": "f5a788c07cff07b6f3a1032ff5458e6c1a56b599", "filename": "crates/ra_ide/src/parent_module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/596e6db46c9c79b2b2be20a4b5461dca35d44b0f/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=596e6db46c9c79b2b2be20a4b5461dca35d44b0f", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n             None => return Vec::new(),\n         };\n     let krate = module.krate();\n-    vec![krate.crate_id()]\n+    vec![krate.into()]\n }\n \n #[cfg(test)]"}]}