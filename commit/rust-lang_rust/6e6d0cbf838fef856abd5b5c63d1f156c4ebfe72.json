{"sha": "6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "node_id": "C_kwDOAAsO6NoAKDZlNmQwY2JmODM4ZmVmODU2YWJkNWI1YzYzZDFmMTU2YzRlYmZlNzI", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-01-09T04:55:09Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-03-29T15:05:24Z"}, "message": "Add debug assertions to some unsafe functions\n\nThese debug assertions are all implemented only at runtime using\n`const_eval_select`, and in the error path they execute\n`intrinsics::abort` instead of being a normal debug assertion to\nminimize the impact of these assertions on code size, when enabled.\n\nOf all these changes, the bounds checks for unchecked indexing are\nexpected to be most impactful (case in point, they found a problem in\nrustc).", "tree": {"sha": "da08d09e5c771f37b3072c25a8df157a2e956729", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da08d09e5c771f37b3072c25a8df157a2e956729"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "html_url": "https://github.com/rust-lang/rust/commit/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba14a836c7038da21f5e102aacc7e6d5964f79a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba14a836c7038da21f5e102aacc7e6d5964f79a6", "html_url": "https://github.com/rust-lang/rust/commit/ba14a836c7038da21f5e102aacc7e6d5964f79a6"}], "stats": {"total": 251, "additions": 123, "deletions": 128}, "files": [{"sha": "874de03d37ac6295f8398e22acd0e3ac677bc38c", "filename": "compiler/rustc_data_structures/src/map_in_place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs?ref=6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "patch": "@@ -30,13 +30,13 @@ impl<T> MapInPlace<T> for Vec<T> {\n             while read_i < old_len {\n                 // move the read_i'th item out of the vector and map it\n                 // to an iterator\n-                let e = ptr::read(self.get_unchecked(read_i));\n+                let e = ptr::read(self.as_ptr().add(read_i));\n                 let iter = f(e).into_iter();\n                 read_i += 1;\n \n                 for e in iter {\n                     if write_i < read_i {\n-                        ptr::write(self.get_unchecked_mut(write_i), e);\n+                        ptr::write(self.as_mut_ptr().add(write_i), e);\n                         write_i += 1;\n                     } else {\n                         // If this is reached we ran out of space\n@@ -76,13 +76,13 @@ impl<T, A: Array<Item = T>> MapInPlace<T> for SmallVec<A> {\n             while read_i < old_len {\n                 // move the read_i'th item out of the vector and map it\n                 // to an iterator\n-                let e = ptr::read(self.get_unchecked(read_i));\n+                let e = ptr::read(self.as_ptr().add(read_i));\n                 let iter = f(e).into_iter();\n                 read_i += 1;\n \n                 for e in iter {\n                     if write_i < read_i {\n-                        ptr::write(self.get_unchecked_mut(write_i), e);\n+                        ptr::write(self.as_mut_ptr().add(write_i), e);\n                         write_i += 1;\n                     } else {\n                         // If this is reached we ran out of space"}, {"sha": "333b3c20d1d399493bde20aae853091ca5e23c8e", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "patch": "@@ -627,10 +627,10 @@ fn bench_map_regular(b: &mut Bencher) {\n fn bench_map_fast(b: &mut Bencher) {\n     let data = black_box([(0, 0); LEN]);\n     b.iter(|| {\n-        let mut result = Vec::with_capacity(data.len());\n+        let mut result: Vec<u32> = Vec::with_capacity(data.len());\n         for i in 0..data.len() {\n             unsafe {\n-                *result.get_unchecked_mut(i) = data[i].0;\n+                *result.as_mut_ptr().add(i) = data[i].0;\n                 result.set_len(i);\n             }\n         }"}, {"sha": "d3e32995f18e6f87f3115d8c9ce968f5d749208d", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 48, "deletions": 53, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "patch": "@@ -1969,6 +1969,40 @@ extern \"rust-intrinsic\" {\n // (`transmute` also falls into this category, but it cannot be wrapped due to the\n // check that `T` and `U` have the same size.)\n \n+/// Check that the preconditions of an unsafe function are followed, if debug_assertions are on,\n+/// and only at runtime.\n+///\n+/// # Safety\n+///\n+/// Invoking this macro is only sound if the following code is already UB when the passed\n+/// expression evaluates to false.\n+///\n+/// This macro expands to a check at runtime if debug_assertions is set. It has no effect at\n+/// compile time, but the semantics of the contained `const_eval_select` must be the same at\n+/// runtime and at compile time. Thus if the expression evaluates to false, this macro produces\n+/// different behavior at compile time and at runtime, and invoking it is incorrect.\n+///\n+/// So in a sense it is UB if this macro is useful, but we expect callers of `unsafe fn` to make\n+/// the occasional mistake, and this check should help them figure things out.\n+#[allow_internal_unstable(const_eval_select)] // permit this to be called in stably-const fn\n+macro_rules! assert_unsafe_precondition {\n+    ($e:expr) => {\n+        if cfg!(debug_assertions) {\n+            // Use a closure so that we can capture arbitrary expressions from the invocation\n+            let runtime = || {\n+                if !$e {\n+                    // abort instead of panicking to reduce impact on code size\n+                    ::core::intrinsics::abort();\n+                }\n+            };\n+            const fn comptime() {}\n+\n+            ::core::intrinsics::const_eval_select((), comptime, runtime);\n+        }\n+    };\n+}\n+pub(crate) use assert_unsafe_precondition;\n+\n /// Checks whether `ptr` is properly aligned with respect to\n /// `align_of::<T>()`.\n pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n@@ -1977,7 +2011,6 @@ pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n \n /// Checks whether the regions of memory starting at `src` and `dst` of size\n /// `count * size_of::<T>()` do *not* overlap.\n-#[cfg(debug_assertions)]\n pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -> bool {\n     let src_usize = src as usize;\n     let dst_usize = dst as usize;\n@@ -2079,28 +2112,16 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n         pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    #[cfg(debug_assertions)]\n-    fn runtime_check<T>(src: *const T, dst: *mut T, count: usize) {\n-        if !is_aligned_and_not_null(src)\n-            || !is_aligned_and_not_null(dst)\n-            || !is_nonoverlapping(src, dst, count)\n-        {\n-            // Not panicking to keep codegen impact smaller.\n-            abort();\n-        }\n-    }\n-    #[cfg(debug_assertions)]\n-    const fn compiletime_check<T>(_src: *const T, _dst: *mut T, _count: usize) {}\n-    #[cfg(debug_assertions)]\n-    // SAFETY: As per our safety precondition, we may assume that the `abort` above is never reached.\n-    // Therefore, compiletime_check and runtime_check are observably equivalent.\n-    unsafe {\n-        const_eval_select((src, dst, count), compiletime_check, runtime_check);\n-    }\n-\n     // SAFETY: the safety contract for `copy_nonoverlapping` must be\n     // upheld by the caller.\n-    unsafe { copy_nonoverlapping(src, dst, count) }\n+    unsafe {\n+        assert_unsafe_precondition!(\n+            is_aligned_and_not_null(src)\n+                && is_aligned_and_not_null(dst)\n+                && is_nonoverlapping(src, dst, count)\n+        );\n+        copy_nonoverlapping(src, dst, count)\n+    }\n }\n \n /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n@@ -2173,24 +2194,11 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    #[cfg(debug_assertions)]\n-    fn runtime_check<T>(src: *const T, dst: *mut T) {\n-        if !is_aligned_and_not_null(src) || !is_aligned_and_not_null(dst) {\n-            // Not panicking to keep codegen impact smaller.\n-            abort();\n-        }\n-    }\n-    #[cfg(debug_assertions)]\n-    const fn compiletime_check<T>(_src: *const T, _dst: *mut T) {}\n-    #[cfg(debug_assertions)]\n-    // SAFETY: As per our safety precondition, we may assume that the `abort` above is never reached.\n-    // Therefore, compiletime_check and runtime_check are observably equivalent.\n+    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n     unsafe {\n-        const_eval_select((src, dst), compiletime_check, runtime_check);\n+        assert_unsafe_precondition!(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst));\n+        copy(src, dst, count)\n     }\n-\n-    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n-    unsafe { copy(src, dst, count) }\n }\n \n /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n@@ -2274,24 +2282,11 @@ pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n         fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n     }\n \n-    #[cfg(debug_assertions)]\n-    fn runtime_check<T>(ptr: *mut T) {\n-        debug_assert!(\n-            is_aligned_and_not_null(ptr),\n-            \"attempt to write to unaligned or null pointer\"\n-        );\n-    }\n-    #[cfg(debug_assertions)]\n-    const fn compiletime_check<T>(_ptr: *mut T) {}\n-    #[cfg(debug_assertions)]\n-    // SAFETY: runtime debug-assertions are a best-effort basis; it's fine to\n-    // not do them during compile time\n+    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n     unsafe {\n-        const_eval_select((dst,), compiletime_check, runtime_check);\n+        assert_unsafe_precondition!(is_aligned_and_not_null(dst));\n+        write_bytes(dst, val, count)\n     }\n-\n-    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n-    unsafe { write_bytes(dst, val, count) }\n }\n \n /// Selects which function to call depending on the context."}, {"sha": "b42b6a939c4266dfe01e36f89b462067effdaa2f", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "patch": "@@ -52,9 +52,13 @@ macro_rules! nonzero_integers {\n                 #[$const_new_unchecked_stability]\n                 #[must_use]\n                 #[inline]\n+                #[rustc_allow_const_fn_unstable(const_fn_fn_ptr_basics)] // required by assert_unsafe_precondition\n                 pub const unsafe fn new_unchecked(n: $Int) -> Self {\n                     // SAFETY: this is guaranteed to be safe by the caller.\n-                    unsafe { Self(n) }\n+                    unsafe {\n+                        core::intrinsics::assert_unsafe_precondition!(n != 0);\n+                        Self(n)\n+                    }\n                 }\n \n                 /// Creates a non-zero if the given value is not zero."}, {"sha": "f589c2670b7a00dc1b871c13f30c60e42d8700dd", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "patch": "@@ -75,7 +75,10 @@\n use crate::cmp::Ordering;\n use crate::fmt;\n use crate::hash;\n-use crate::intrinsics::{self, abort, is_aligned_and_not_null};\n+use crate::intrinsics::{\n+    self, assert_unsafe_precondition, is_aligned_and_not_null, is_nonoverlapping,\n+};\n+\n use crate::mem::{self, MaybeUninit};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -438,6 +441,16 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n         };\n     }\n \n+    // SAFETY: the caller must guarantee that `x` and `y` are\n+    // valid for writes and properly aligned.\n+    unsafe {\n+        assert_unsafe_precondition!(\n+            is_aligned_and_not_null(x)\n+                && is_aligned_and_not_null(y)\n+                && is_nonoverlapping(x, y, count)\n+        );\n+    }\n+\n     // NOTE(scottmcm) MIRI is disabled here as reading in smaller units is a\n     // pessimization for it.  Also, if the type contains any unaligned pointers,\n     // copying those over multiple reads is difficult to support.\n@@ -528,6 +541,7 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n     // and cannot overlap `src` since `dst` must point to a distinct\n     // allocated object.\n     unsafe {\n+        assert_unsafe_precondition!(is_aligned_and_not_null(dst));\n         mem::swap(&mut *dst, &mut src); // cannot overlap\n     }\n     src\n@@ -1007,12 +1021,11 @@ pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n-    if cfg!(debug_assertions) && !is_aligned_and_not_null(src) {\n-        // Not panicking to keep codegen impact smaller.\n-        abort();\n-    }\n     // SAFETY: the caller must uphold the safety contract for `volatile_load`.\n-    unsafe { intrinsics::volatile_load(src) }\n+    unsafe {\n+        assert_unsafe_precondition!(is_aligned_and_not_null(src));\n+        intrinsics::volatile_load(src)\n+    }\n }\n \n /// Performs a volatile write of a memory location with the given value without\n@@ -1078,12 +1091,9 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n-    if cfg!(debug_assertions) && !is_aligned_and_not_null(dst) {\n-        // Not panicking to keep codegen impact smaller.\n-        abort();\n-    }\n     // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n     unsafe {\n+        assert_unsafe_precondition!(is_aligned_and_not_null(dst));\n         intrinsics::volatile_store(dst, src);\n     }\n }"}, {"sha": "2b46e6b5a0a1c18cc62bd7559e3702ce20b9d3a9", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "patch": "@@ -1,5 +1,6 @@\n //! Indexing implementations for `[T]`.\n \n+use crate::intrinsics::assert_unsafe_precondition;\n use crate::intrinsics::const_eval_select;\n use crate::ops;\n use crate::ptr;\n@@ -219,13 +220,19 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n         // cannot be longer than `isize::MAX`. They also guarantee that\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n-        unsafe { slice.as_ptr().add(self) }\n+        unsafe {\n+            assert_unsafe_precondition!(self < slice.len());\n+            slice.as_ptr().add(self)\n+        }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut T {\n         // SAFETY: see comments for `get_unchecked` above.\n-        unsafe { slice.as_mut_ptr().add(self) }\n+        unsafe {\n+            assert_unsafe_precondition!(self < slice.len());\n+            slice.as_mut_ptr().add(self)\n+        }\n     }\n \n     #[inline]\n@@ -272,13 +279,18 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n         // cannot be longer than `isize::MAX`. They also guarantee that\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n-        unsafe { ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n+\n+        unsafe {\n+            assert_unsafe_precondition!(self.end >= self.start && self.end <= slice.len());\n+            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n+        }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n+            assert_unsafe_precondition!(self.end >= self.start && self.end <= slice.len());\n             ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n         }\n     }"}, {"sha": "341187fcfb042bd9a91eb772961d60fb23b90bc7", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "patch": "@@ -7,6 +7,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering::{self, Greater, Less};\n+use crate::intrinsics::{assert_unsafe_precondition, exact_div};\n use crate::marker::Copy;\n use crate::mem;\n use crate::num::NonZeroUsize;\n@@ -637,15 +638,10 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_swap_unchecked\", issue = \"88539\")]\n     #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n     pub const unsafe fn swap_unchecked(&mut self, a: usize, b: usize) {\n-        #[cfg(debug_assertions)]\n-        {\n-            let _ = &self[a];\n-            let _ = &self[b];\n-        }\n-\n         let ptr = self.as_mut_ptr();\n         // SAFETY: caller has to guarantee that `a < self.len()` and `b < self.len()`\n         unsafe {\n+            assert_unsafe_precondition!(a < self.len() && b < self.len());\n             ptr::swap(ptr.add(a), ptr.add(b));\n         }\n     }\n@@ -950,11 +946,11 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n     #[inline]\n     pub unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n-        debug_assert_ne!(N, 0);\n-        debug_assert_eq!(self.len() % N, 0);\n-        let new_len =\n-            // SAFETY: Our precondition is exactly what's needed to call this\n-            unsafe { crate::intrinsics::exact_div(self.len(), N) };\n+        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n+        let new_len = unsafe {\n+            assert_unsafe_precondition!(N != 0 && self.len() % N == 0);\n+            exact_div(self.len(), N)\n+        };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n         // a slice of `new_len` many `N` elements chunks.\n         unsafe { from_raw_parts(self.as_ptr().cast(), new_len) }\n@@ -1086,11 +1082,11 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_as_chunks\", issue = \"74985\")]\n     #[inline]\n     pub unsafe fn as_chunks_unchecked_mut<const N: usize>(&mut self) -> &mut [[T; N]] {\n-        debug_assert_ne!(N, 0);\n-        debug_assert_eq!(self.len() % N, 0);\n-        let new_len =\n-            // SAFETY: Our precondition is exactly what's needed to call this\n-            unsafe { crate::intrinsics::exact_div(self.len(), N) };\n+        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n+        let new_len = unsafe {\n+            assert_unsafe_precondition!(N != 0 && self.len() % N == 0);\n+            exact_div(self.len(), N)\n+        };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n         // a slice of `new_len` many `N` elements chunks.\n         unsafe { from_raw_parts_mut(self.as_mut_ptr().cast(), new_len) }\n@@ -1646,7 +1642,10 @@ impl<T> [T] {\n         //\n         // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n         // is fine.\n-        unsafe { (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid)) }\n+        unsafe {\n+            assert_unsafe_precondition!(mid <= len);\n+            (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid))\n+        }\n     }\n \n     /// Divides one slice into an array and a remainder slice at an index."}, {"sha": "e1be4ca49b6e87e87a1bd18c3938109755ee13ac", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=6e6d0cbf838fef856abd5b5c63d1f156c4ebfe72", "patch": "@@ -1,6 +1,7 @@\n //! Free functions to create `&[T]` and `&mut [T]`.\n \n use crate::array;\n+use crate::intrinsics::{assert_unsafe_precondition, is_aligned_and_not_null};\n use crate::ops::Range;\n use crate::ptr;\n \n@@ -86,10 +87,14 @@ use crate::ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n-    debug_check_data_len(data, len);\n-\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n-    unsafe { &*ptr::slice_from_raw_parts(data, len) }\n+    unsafe {\n+        assert_unsafe_precondition!(\n+            is_aligned_and_not_null(data)\n+                && crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize\n+        );\n+        &*ptr::slice_from_raw_parts(data, len)\n+    }\n }\n \n /// Performs the same functionality as [`from_raw_parts`], except that a\n@@ -125,46 +130,16 @@ pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n pub const unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n-    debug_check_data_len(data as _, len);\n-\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n-    unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n-}\n-\n-// In debug builds checks that `data` pointer is aligned and non-null and that slice with given `len` would cover less than half the address space\n-#[cfg(debug_assertions)]\n-#[unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n-#[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n-const fn debug_check_data_len<T>(data: *const T, len: usize) {\n-    fn rt_check<T>(data: *const T) {\n-        use crate::intrinsics::is_aligned_and_not_null;\n-\n-        assert!(is_aligned_and_not_null(data), \"attempt to create unaligned or null slice\");\n-    }\n-\n-    const fn noop<T>(_: *const T) {}\n-\n-    // SAFETY:\n-    //\n-    // `rt_check` is just a debug assert to hint users that they are causing UB,\n-    // it is not required for safety (the safety must be guatanteed by\n-    // the `from_raw_parts[_mut]` caller).\n-    //\n-    // As per our safety precondition, we may assume that assertion above never fails.\n-    // Therefore, noop and rt_check are observably equivalent.\n     unsafe {\n-        crate::intrinsics::const_eval_select((data,), noop, rt_check);\n+        assert_unsafe_precondition!(\n+            is_aligned_and_not_null(data)\n+                && crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize\n+        );\n+        &mut *ptr::slice_from_raw_parts_mut(data, len)\n     }\n-\n-    assert!(\n-        crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n-        \"attempt to create slice covering at least half the address space\"\n-    );\n }\n \n-#[cfg(not(debug_assertions))]\n-const fn debug_check_data_len<T>(_data: *const T, _len: usize) {}\n-\n /// Converts a reference to T into a slice of length 1 (without copying).\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_ref\", issue = \"90206\")]"}]}