{"sha": "fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZDBiNzcyZTBhNTY1MDZjNDc0YzhhYmQ1YmZlMDQ5ZWEwOGQwZTA=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-26T11:57:11Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-26T11:57:11Z"}, "message": "Merge #1057\n\n1057: simplify r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "7ed196ac7bdc372091afe07b9799479539c99f2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ed196ac7bdc372091afe07b9799479539c99f2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "html_url": "https://github.com/rust-lang/rust/commit/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "8254244e4970b085809d42a34282649b4a4e16a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8254244e4970b085809d42a34282649b4a4e16a2", "html_url": "https://github.com/rust-lang/rust/commit/8254244e4970b085809d42a34282649b4a4e16a2"}, {"sha": "f6f2d69bb8318815ff87cd1bfe504fe5aa09ed63", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f2d69bb8318815ff87cd1bfe504fe5aa09ed63", "html_url": "https://github.com/rust-lang/rust/commit/f6f2d69bb8318815ff87cd1bfe504fe5aa09ed63"}], "stats": {"total": 256, "additions": 131, "deletions": 125}, "files": [{"sha": "3296b9b31dbbb73c131fd3e4e24578cd08091546", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "patch": "@@ -34,10 +34,10 @@ pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(crate::traits::TraitData::trait_data_query)]\n     fn trait_data(&self, t: Trait) -> Arc<TraitData>;\n \n-    #[salsa::invoke(crate::ids::SourceFileItems::file_items_query)]\n+    #[salsa::invoke(crate::source_id::SourceFileItems::file_items_query)]\n     fn file_items(&self, file_id: HirFileId) -> Arc<SourceFileItems>;\n \n-    #[salsa::invoke(crate::ids::SourceFileItems::file_item_query)]\n+    #[salsa::invoke(crate::source_id::SourceFileItems::file_item_query)]\n     fn file_item(&self, source_item_id: SourceItemId) -> TreeArc<SyntaxNode>;\n \n     #[salsa::invoke(RawItems::raw_items_query)]"}, {"sha": "e73dd5d21d6e76e09662efb8db5f5d1416809df2", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 3, "deletions": 111, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "patch": "@@ -5,13 +5,12 @@ use std::{\n };\n \n use ra_db::{LocationInterner, FileId};\n-use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, SyntaxNodePtr, ast};\n-use ra_arena::{Arena, RawId, ArenaId, impl_arena_id};\n+use ra_syntax::{TreeArc, SourceFile, AstNode, ast};\n+use ra_arena::{RawId, ArenaId, impl_arena_id};\n use mbe::MacroRules;\n \n use crate::{\n-    Module,\n-    DefDatabase,\n+    Module, DefDatabase, SourceItemId, SourceFileItemId,\n };\n \n #[derive(Debug, Default)]\n@@ -304,110 +303,3 @@ impl AstItemDef<ast::TypeAliasDef> for TypeId {\n         &interner.types\n     }\n }\n-\n-/// Identifier of item within a specific file. This is stable over reparses, so\n-/// it's OK to use it as a salsa key/value.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct SourceFileItemId(RawId);\n-impl_arena_id!(SourceFileItemId);\n-\n-impl SourceFileItemId {\n-    pub(crate) fn with_file_id(self, file_id: HirFileId) -> SourceItemId {\n-        SourceItemId { file_id, item_id: self }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct SourceItemId {\n-    pub(crate) file_id: HirFileId,\n-    pub(crate) item_id: SourceFileItemId,\n-}\n-\n-/// Maps items' `SyntaxNode`s to `SourceFileItemId`s and back.\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct SourceFileItems {\n-    file_id: HirFileId,\n-    arena: Arena<SourceFileItemId, SyntaxNodePtr>,\n-}\n-\n-impl SourceFileItems {\n-    pub(crate) fn file_items_query(\n-        db: &impl DefDatabase,\n-        file_id: HirFileId,\n-    ) -> Arc<SourceFileItems> {\n-        let source_file = db.hir_parse(file_id);\n-        Arc::new(SourceFileItems::from_source_file(&source_file, file_id))\n-    }\n-\n-    pub(crate) fn file_item_query(\n-        db: &impl DefDatabase,\n-        source_item_id: SourceItemId,\n-    ) -> TreeArc<SyntaxNode> {\n-        let source_file = db.hir_parse(source_item_id.file_id);\n-        db.file_items(source_item_id.file_id)[source_item_id.item_id]\n-            .to_node(&source_file)\n-            .to_owned()\n-    }\n-\n-    pub(crate) fn from_source_file(\n-        source_file: &SourceFile,\n-        file_id: HirFileId,\n-    ) -> SourceFileItems {\n-        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n-        // By walking the tree in bread-first order we make sure that parents\n-        // get lower ids then children. That is, adding a new child does not\n-        // change parent's id. This means that, say, adding a new function to a\n-        // trait does not change ids of top-level items, which helps caching.\n-        bfs(source_file.syntax(), |it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it) {\n-                res.alloc(module_item.syntax());\n-            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n-                res.alloc(macro_call.syntax());\n-            }\n-        });\n-        res\n-    }\n-\n-    fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {\n-        self.arena.alloc(SyntaxNodePtr::new(item))\n-    }\n-    pub(crate) fn id_of(&self, file_id: HirFileId, item: &SyntaxNode) -> SourceFileItemId {\n-        assert_eq!(\n-            self.file_id, file_id,\n-            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n-            self.file_id, file_id\n-        );\n-        self.id_of_unchecked(item)\n-    }\n-    pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n-        let ptr = SyntaxNodePtr::new(item);\n-        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| **i == ptr) {\n-            return id;\n-        }\n-        panic!(\n-            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n-            item,\n-            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n-        );\n-    }\n-}\n-\n-impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n-    type Output = SyntaxNodePtr;\n-    fn index(&self, idx: SourceFileItemId) -> &SyntaxNodePtr {\n-        &self.arena[idx]\n-    }\n-}\n-\n-/// Walks the subtree in bfs order, calling `f` for each node.\n-fn bfs(node: &SyntaxNode, mut f: impl FnMut(&SyntaxNode)) {\n-    let mut curr_layer = vec![node];\n-    let mut next_layer = vec![];\n-    while !curr_layer.is_empty() {\n-        curr_layer.drain(..).for_each(|node| {\n-            next_layer.extend(node.children());\n-            f(node);\n-        });\n-        std::mem::swap(&mut curr_layer, &mut next_layer);\n-    }\n-}"}, {"sha": "ac2585de0fed1eb9b096b4144a17d7f6c6670af5", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "patch": "@@ -23,6 +23,7 @@ pub mod mock;\n mod path;\n pub mod source_binder;\n \n+mod source_id;\n mod ids;\n mod name;\n mod nameres;\n@@ -47,12 +48,13 @@ mod marks;\n use crate::{\n     db::{HirDatabase, DefDatabase},\n     name::{AsName, KnownName},\n-    ids::{SourceItemId, SourceFileItems},\n+    source_id::SourceFileItemId,\n };\n \n pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n+    source_id::{SourceFileItems, SourceItemId},\n     ids::{HirFileId, MacroDefId, MacroCallId, MacroCallLoc, HirInterner},\n     nameres::{PerNs, Namespace},\n     ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay},"}, {"sha": "36ef615a3ae648bded4934f002ffc20449cba417", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "patch": "@@ -61,9 +61,9 @@ use ra_db::{FileId, Edition};\n use test_utils::tested_by;\n \n use crate::{\n-    ModuleDef, Name, Crate, Module,\n+    ModuleDef, Name, Crate, Module, SourceItemId,\n     DefDatabase, Path, PathKind, HirFileId, Trait,\n-    ids::{SourceItemId, SourceFileItemId, MacroCallId, MacroDefId},\n+    ids::{MacroCallId, MacroDefId},\n     diagnostics::DiagnosticSink,\n     nameres::diagnostics::DefDiagnostic,\n };\n@@ -241,9 +241,8 @@ impl CrateDefMap {\n     pub(crate) fn find_module_by_source(\n         &self,\n         file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n+        decl_id: Option<SourceItemId>,\n     ) -> Option<CrateModuleId> {\n-        let decl_id = decl_id.map(|it| it.with_file_id(file_id));\n         let (module_id, _module_data) = self.modules.iter().find(|(_module_id, module_data)| {\n             if decl_id.is_some() {\n                 module_data.declaration == decl_id"}, {"sha": "4fb29815507d85bb7cce29e791d3eeee77040279", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "patch": "@@ -6,15 +6,15 @@ use ra_db::FileId;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    DefDatabase, HirFileId, Name, Path,\n+    DefDatabase, HirFileId, Name, Path, SourceItemId,\n     KnownName,\n     nameres::{\n         Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n         CrateDefMap, CrateModuleId, ModuleData,\n         diagnostics::DefDiagnostic,\n         raw,\n     },\n-    ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId, MacroDefId},\n+    ids::{AstItemDef, LocationCtx, MacroCallLoc, MacroCallId, MacroDefId},\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {"}, {"sha": "f32004601074b4c889d051d9b7531584d7765d58", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "patch": "@@ -12,7 +12,7 @@ use ra_syntax::{\n \n use crate::{\n     DefDatabase, Name, AsName, Path, HirFileId, ModuleSource,\n-    ids::{SourceFileItemId, SourceFileItems},\n+    SourceFileItemId, SourceFileItems,\n };\n \n /// `RawItems` is a set of top-level items in a file (except for impls)."}, {"sha": "db9e3a22e78fd7276b5fc8009b7446a3367724a1", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "patch": "@@ -13,9 +13,9 @@ use ra_syntax::{\n };\n \n use crate::{\n-    HirDatabase, Function, Struct, Enum,\n+    HirDatabase, Function, Struct, Enum, SourceItemId,\n     AsName, Module, HirFileId, Crate, Trait, Resolver,\n-    ids::{LocationCtx, SourceFileItemId},\n+    ids::LocationCtx,\n     expr\n };\n \n@@ -55,7 +55,7 @@ fn module_from_inline(\n     assert!(!module.has_semi());\n     let file_id = file_id.into();\n     let file_items = db.file_items(file_id);\n-    let item_id = file_items.id_of(file_id, module.syntax());\n+    let item_id = file_items.id_of(file_id, module.syntax()).with_file_id(file_id);\n     module_from_source(db, file_id, Some(item_id))\n }\n \n@@ -75,7 +75,7 @@ pub fn module_from_child_node(\n fn module_from_source(\n     db: &impl HirDatabase,\n     file_id: HirFileId,\n-    decl_id: Option<SourceFileItemId>,\n+    decl_id: Option<SourceItemId>,\n ) -> Option<Module> {\n     let source_root_id = db.file_source_root(file_id.as_original_file());\n     db.source_root_crates(source_root_id).iter().map(|&crate_id| Crate { crate_id }).find_map("}, {"sha": "62707ba6ac91837171ab8728d9d078eaa3e9f31d", "filename": "crates/ra_hir/src/source_id.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd0b772e0a56506c474c8abd5bfe049ea08d0e0/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=fbd0b772e0a56506c474c8abd5bfe049ea08d0e0", "patch": "@@ -0,0 +1,113 @@\n+use std::sync::Arc;\n+\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_syntax::{SyntaxNodePtr, TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n+\n+use crate::{HirFileId, DefDatabase};\n+\n+/// Identifier of item within a specific file. This is stable over reparses, so\n+/// it's OK to use it as a salsa key/value.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub(crate) struct SourceFileItemId(RawId);\n+impl_arena_id!(SourceFileItemId);\n+\n+impl SourceFileItemId {\n+    pub(crate) fn with_file_id(self, file_id: HirFileId) -> SourceItemId {\n+        SourceItemId { file_id, item_id: self }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SourceItemId {\n+    pub(crate) file_id: HirFileId,\n+    pub(crate) item_id: SourceFileItemId,\n+}\n+\n+/// Maps items' `SyntaxNode`s to `SourceFileItemId`s and back.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct SourceFileItems {\n+    file_id: HirFileId,\n+    arena: Arena<SourceFileItemId, SyntaxNodePtr>,\n+}\n+\n+impl SourceFileItems {\n+    pub(crate) fn file_items_query(\n+        db: &impl DefDatabase,\n+        file_id: HirFileId,\n+    ) -> Arc<SourceFileItems> {\n+        let source_file = db.hir_parse(file_id);\n+        Arc::new(SourceFileItems::from_source_file(&source_file, file_id))\n+    }\n+\n+    pub(crate) fn file_item_query(\n+        db: &impl DefDatabase,\n+        source_item_id: SourceItemId,\n+    ) -> TreeArc<SyntaxNode> {\n+        let source_file = db.hir_parse(source_item_id.file_id);\n+        db.file_items(source_item_id.file_id)[source_item_id.item_id]\n+            .to_node(&source_file)\n+            .to_owned()\n+    }\n+\n+    pub(crate) fn from_source_file(\n+        source_file: &SourceFile,\n+        file_id: HirFileId,\n+    ) -> SourceFileItems {\n+        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n+        // By walking the tree in bread-first order we make sure that parents\n+        // get lower ids then children. That is, adding a new child does not\n+        // change parent's id. This means that, say, adding a new function to a\n+        // trait does not change ids of top-level items, which helps caching.\n+        bfs(source_file.syntax(), |it| {\n+            if let Some(module_item) = ast::ModuleItem::cast(it) {\n+                res.alloc(module_item.syntax());\n+            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n+                res.alloc(macro_call.syntax());\n+            }\n+        });\n+        res\n+    }\n+\n+    fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {\n+        self.arena.alloc(SyntaxNodePtr::new(item))\n+    }\n+    pub(crate) fn id_of(&self, file_id: HirFileId, item: &SyntaxNode) -> SourceFileItemId {\n+        assert_eq!(\n+            self.file_id, file_id,\n+            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n+            self.file_id, file_id\n+        );\n+        self.id_of_unchecked(item)\n+    }\n+    pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n+        let ptr = SyntaxNodePtr::new(item);\n+        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| **i == ptr) {\n+            return id;\n+        }\n+        panic!(\n+            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n+            item,\n+            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n+        );\n+    }\n+}\n+\n+impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n+    type Output = SyntaxNodePtr;\n+    fn index(&self, idx: SourceFileItemId) -> &SyntaxNodePtr {\n+        &self.arena[idx]\n+    }\n+}\n+\n+/// Walks the subtree in bfs order, calling `f` for each node.\n+fn bfs(node: &SyntaxNode, mut f: impl FnMut(&SyntaxNode)) {\n+    let mut curr_layer = vec![node];\n+    let mut next_layer = vec![];\n+    while !curr_layer.is_empty() {\n+        curr_layer.drain(..).for_each(|node| {\n+            next_layer.extend(node.children());\n+            f(node);\n+        });\n+        std::mem::swap(&mut curr_layer, &mut next_layer);\n+    }\n+}"}]}