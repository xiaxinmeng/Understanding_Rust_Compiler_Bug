{"sha": "96a83b57e51793de579dc90dc82525cd9f018148", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YTgzYjU3ZTUxNzkzZGU1NzlkYzkwZGM4MjUyNWNkOWYwMTgxNDg=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-18T04:49:06Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-03-18T23:23:53Z"}, "message": "Add some doc comments and factor out add_repeat and add_delimited", "tree": {"sha": "6072a0a908c69abb3a1bf7573e99c01d4f492b85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6072a0a908c69abb3a1bf7573e99c01d4f492b85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96a83b57e51793de579dc90dc82525cd9f018148", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96a83b57e51793de579dc90dc82525cd9f018148", "html_url": "https://github.com/rust-lang/rust/commit/96a83b57e51793de579dc90dc82525cd9f018148", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96a83b57e51793de579dc90dc82525cd9f018148/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fd174d5f1e51a03b6454617c780f2ea6cd4cb6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fd174d5f1e51a03b6454617c780f2ea6cd4cb6b", "html_url": "https://github.com/rust-lang/rust/commit/0fd174d5f1e51a03b6454617c780f2ea6cd4cb6b"}], "stats": {"total": 148, "additions": 91, "deletions": 57}, "files": [{"sha": "9c7a7177ea14ac62e43a1207f2ac0c78f7475232", "filename": "src/macros.rs", "status": "modified", "additions": 91, "deletions": 57, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/96a83b57e51793de579dc90dc82525cd9f018148/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a83b57e51793de579dc90dc82525cd9f018148/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=96a83b57e51793de579dc90dc82525cd9f018148", "patch": "@@ -465,15 +465,25 @@ fn replace_names(input: &str) -> Option<(String, HashMap<String, String>)> {\n \n #[derive(Debug, Clone)]\n enum MacroArgKind {\n+    /// e.g. `$x: expr`.\n     MetaVariable(ast::Ident, String),\n+    /// e.g. `$($foo: expr),*`\n     Repeat(\n+        /// `()`, `[]` or `{}`.\n         DelimToken,\n+        /// Inner arguments inside delimiters.\n         Vec<ParsedMacroArg>,\n+        /// Something after the closing delimiter and the repeat token, if available.\n         Option<Box<ParsedMacroArg>>,\n+        /// The repeat token. This could be one of `*`, `+` or `?`.\n         Token,\n     ),\n+    /// e.g. `[derive(Debug)]`\n     Delimited(DelimToken, Vec<ParsedMacroArg>),\n+    /// A possible separator. e.g. `,` or `;`.\n     Separator(String, String),\n+    /// Other random stuff that does not fit to other kinds.\n+    /// e.g. `== foo` in `($x: expr == foo)`.\n     Other(String, String),\n }\n \n@@ -589,13 +599,21 @@ impl ParsedMacroArg {\n     }\n }\n \n+/// Parses macro arguments on macro def.\n struct MacroArgParser {\n+    /// Holds either a name of the next metavariable, a separator or a junk.\n+    buf: String,\n+    /// The start position on the current buffer.\n     lo: BytePos,\n+    /// The first token of the current buffer.\n+    start_tok: Token,\n+    /// Set to true if we are parsing a metavariable or a repeat.\n+    is_meta_var: bool,\n+    /// The position of the last token.\n     hi: BytePos,\n-    buf: String,\n-    is_arg: bool,\n+    /// The last token parsed.\n     last_tok: Token,\n-    start_tok: Token,\n+    /// Holds the parsed arguments.\n     result: Vec<ParsedMacroArg>,\n }\n \n@@ -612,7 +630,7 @@ impl MacroArgParser {\n             lo: BytePos(0),\n             hi: BytePos(0),\n             buf: String::new(),\n-            is_arg: false,\n+            is_meta_var: false,\n             last_tok: Token::Eof,\n             start_tok: Token::Eof,\n             result: vec![],\n@@ -659,12 +677,70 @@ impl MacroArgParser {\n                 });\n \n                 self.buf.clear();\n-                self.is_arg = false;\n+                self.is_meta_var = false;\n             }\n             _ => unreachable!(),\n         }\n     }\n \n+    fn add_delimited(&mut self, inner: Vec<ParsedMacroArg>, delim: DelimToken, span: Span) {\n+        self.result.push(ParsedMacroArg {\n+            kind: MacroArgKind::Delimited(delim, inner),\n+            span,\n+        });\n+    }\n+\n+    // $($foo: expr),?\n+    fn add_repeat(\n+        &mut self,\n+        inner: Vec<ParsedMacroArg>,\n+        delim: DelimToken,\n+        iter: &mut Cursor,\n+        span: Span,\n+    ) {\n+        let mut buffer = String::new();\n+        let mut first = false;\n+        let mut lo = span.lo();\n+        let mut hi = span.hi();\n+\n+        // Parse '*', '+' or '?.\n+        while let Some(ref tok) = iter.next() {\n+            self.set_last_tok(tok);\n+            if first {\n+                first = false;\n+                lo = tok.span().lo();\n+            }\n+\n+            match tok {\n+                TokenTree::Token(_, Token::BinOp(BinOpToken::Plus))\n+                | TokenTree::Token(_, Token::Question)\n+                | TokenTree::Token(_, Token::BinOp(BinOpToken::Star)) => {\n+                    break;\n+                }\n+                TokenTree::Token(sp, ref t) => {\n+                    buffer.push_str(&pprust::token_to_string(t));\n+                    hi = sp.hi();\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        // There could be some random stuff between ')' and '*', '+' or '?'.\n+        let another = if buffer.trim().is_empty() {\n+            None\n+        } else {\n+            Some(Box::new(ParsedMacroArg {\n+                kind: MacroArgKind::Other(buffer, \"\".to_owned()),\n+                span: mk_sp(lo, hi),\n+            }))\n+        };\n+\n+        self.result.push(ParsedMacroArg {\n+            kind: MacroArgKind::Repeat(delim, inner, another, self.last_tok.clone()),\n+            span: mk_sp(self.lo, self.hi),\n+        });\n+    }\n+\n     fn update_buffer(&mut self, lo: BytePos, t: &Token) {\n         if self.buf.is_empty() {\n             self.lo = lo;\n@@ -716,15 +792,15 @@ impl MacroArgParser {\n                     }\n \n                     // Start keeping the name of this metavariable in the buffer.\n-                    self.is_arg = true;\n+                    self.is_meta_var = true;\n                     self.lo = sp.lo();\n                     self.start_tok = Token::Dollar;\n                 }\n-                TokenTree::Token(_, Token::Colon) if self.is_arg => {\n+                TokenTree::Token(_, Token::Colon) if self.is_meta_var => {\n                     self.add_meta_variable(&mut iter);\n                 }\n                 TokenTree::Token(sp, ref t) => self.update_buffer(sp.lo(), t),\n-                TokenTree::Delimited(sp, ref delimited) => {\n+                TokenTree::Delimited(sp, delimited) => {\n                     if !self.buf.is_empty() {\n                         if next_space(&self.last_tok) == SpaceState::Always {\n                             self.add_separator();\n@@ -733,66 +809,24 @@ impl MacroArgParser {\n                         }\n                     }\n \n+                    // Parse the stuff inside delimiters.\n                     let mut parser = MacroArgParser::new();\n                     parser.lo = sp.lo();\n-                    let mut delimited_arg = parser.parse(delimited.tts.clone());\n-\n-                    if self.is_arg {\n-                        // Parse '*' or '+'.\n-                        let mut buffer = String::new();\n-                        let mut first = false;\n-                        let mut lo = sp.lo();\n-\n-                        while let Some(ref next_tok) = iter.next() {\n-                            self.set_last_tok(next_tok);\n-                            if first {\n-                                first = false;\n-                                lo = next_tok.span().lo();\n-                            }\n-\n-                            match next_tok {\n-                                TokenTree::Token(_, Token::BinOp(BinOpToken::Plus))\n-                                | TokenTree::Token(_, Token::Question)\n-                                | TokenTree::Token(_, Token::BinOp(BinOpToken::Star)) => {\n-                                    break;\n-                                }\n-                                TokenTree::Token(_, ref t) => {\n-                                    buffer.push_str(&pprust::token_to_string(t))\n-                                }\n-                                _ => unreachable!(),\n-                            }\n-                        }\n+                    let delimited_arg = parser.parse(delimited.tts.clone());\n \n-                        let another = if buffer.trim().is_empty() {\n-                            None\n-                        } else {\n-                            Some(Box::new(ParsedMacroArg {\n-                                kind: MacroArgKind::Other(buffer, \"\".to_owned()),\n-                                span: mk_sp(lo, self.hi),\n-                            }))\n-                        };\n-\n-                        self.result.push(ParsedMacroArg {\n-                            kind: MacroArgKind::Repeat(\n-                                delimited.delim,\n-                                delimited_arg,\n-                                another,\n-                                self.last_tok.clone(),\n-                            ),\n-                            span: mk_sp(self.lo, self.hi),\n-                        });\n+                    if self.is_meta_var {\n+                        self.add_repeat(delimited_arg, delimited.delim, &mut iter, *sp);\n                     } else {\n-                        self.result.push(ParsedMacroArg {\n-                            kind: MacroArgKind::Delimited(delimited.delim, delimited_arg),\n-                            span: *sp,\n-                        });\n+                        self.add_delimited(delimited_arg, delimited.delim, *sp);\n                     }\n                 }\n             }\n \n             self.set_last_tok(tok);\n         }\n \n+        // We are left with some stuff in the buffer. Since there is nothing\n+        // left to separate, add this as `Other`.\n         if !self.buf.is_empty() {\n             self.add_other();\n         }"}]}