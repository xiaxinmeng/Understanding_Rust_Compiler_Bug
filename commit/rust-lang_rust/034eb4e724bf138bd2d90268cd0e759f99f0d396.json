{"sha": "034eb4e724bf138bd2d90268cd0e759f99f0d396", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNGViNGU3MjRiZjEzOGJkMmQ5MDI2OGNkMGU3NTlmOTlmMGQzOTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-27T19:08:27Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-28T00:49:31Z"}, "message": "native: Ignore stdio fds with /dev/null\n\nWhen spawning a process, stdio file descriptors can be configured to be ignored,\nwhich basically means that they'll be closed. Currently this is done by\nliterally closing the file descriptors in the child, but this can have adverse\nside effects if the child process then opens a new file descriptor, assigning it\nto a stdio number.\n\nTo work around the problems of the child, this commit alters the process\nspawning code to map stdio fds to /dev/null on unix (and a similar equivalent on\nwindows) when they are specified as being ignored. This should allow spawned\nprograms to have more expected behavior when opening new files.\n\nCloses #14456", "tree": {"sha": "5941c72b81bc4a09adcf0173d5d6a9c1b9895b5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5941c72b81bc4a09adcf0173d5d6a9c1b9895b5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/034eb4e724bf138bd2d90268cd0e759f99f0d396", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/034eb4e724bf138bd2d90268cd0e759f99f0d396", "html_url": "https://github.com/rust-lang/rust/commit/034eb4e724bf138bd2d90268cd0e759f99f0d396", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/034eb4e724bf138bd2d90268cd0e759f99f0d396/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "746d086f9322d24fa7b389dd911e204ca35012ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/746d086f9322d24fa7b389dd911e204ca35012ae", "html_url": "https://github.com/rust-lang/rust/commit/746d086f9322d24fa7b389dd911e204ca35012ae"}], "stats": {"total": 194, "additions": 140, "deletions": 54}, "files": [{"sha": "c082ebcbd63055874d6e7eb81764cb74d2a90008", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/034eb4e724bf138bd2d90268cd0e759f99f0d396/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034eb4e724bf138bd2d90268cd0e759f99f0d396/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=034eb4e724bf138bd2d90268cd0e759f99f0d396", "patch": "@@ -235,6 +235,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use types::os::arch::extra::{LARGE_INTEGER, LPVOID, LONG};\n #[cfg(windows)] pub use types::os::arch::extra::{time64_t, OVERLAPPED, LPCWSTR};\n #[cfg(windows)] pub use types::os::arch::extra::{LPOVERLAPPED, SIZE_T, LPDWORD};\n+#[cfg(windows)] pub use types::os::arch::extra::{SECURITY_ATTRIBUTES};\n #[cfg(windows)] pub use funcs::c95::string::{wcslen};\n #[cfg(windows)] pub use funcs::posix88::stat_::{wstat, wutime, wchmod, wrmdir};\n #[cfg(windows)] pub use funcs::bsd43::{closesocket};\n@@ -1140,8 +1141,12 @@ pub mod types {\n                 pub type LPWCH = *mut WCHAR;\n                 pub type LPCH = *mut CHAR;\n \n-                // Not really, but opaque to us.\n-                pub type LPSECURITY_ATTRIBUTES = LPVOID;\n+                pub struct SECURITY_ATTRIBUTES {\n+                    pub nLength: DWORD,\n+                    pub lpSecurityDescriptor: LPVOID,\n+                    pub bInheritHandle: BOOL,\n+                }\n+                pub type LPSECURITY_ATTRIBUTES = *mut SECURITY_ATTRIBUTES;\n \n                 pub type LPVOID = *mut c_void;\n                 pub type LPCVOID = *c_void;"}, {"sha": "73371373eb73c50e8431d460e735ce751fa4d408", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 78, "deletions": 52, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/034eb4e724bf138bd2d90268cd0e759f99f0d396/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034eb4e724bf138bd2d90268cd0e759f99f0d396/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=034eb4e724bf138bd2d90268cd0e759f99f0d396", "patch": "@@ -244,7 +244,8 @@ struct SpawnProcessResult {\n }\n \n #[cfg(windows)]\n-fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_int)\n+fn spawn_process_os(cfg: ProcessConfig,\n+                    in_fd: c_int, out_fd: c_int, err_fd: c_int)\n                  -> IoResult<SpawnProcessResult> {\n     use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n     use libc::consts::os::extra::{\n@@ -278,38 +279,51 @@ fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_i\n \n         let cur_proc = GetCurrentProcess();\n \n-        if in_fd != -1 {\n-            let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n-            if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n-                fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-            }\n-            if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n-                               0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-                fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n-            }\n-        }\n-\n-        if out_fd != -1 {\n-            let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n-            if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n-                fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-            }\n-            if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n-                               0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-                fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n+        // Similarly to unix, we don't actually leave holes for the stdio file\n+        // descriptors, but rather open up /dev/null equivalents. These\n+        // equivalents are drawn from libuv's windows process spawning.\n+        let set_fd = |fd: c_int, slot: &mut HANDLE, is_stdin: bool| {\n+            if fd == -1 {\n+                let access = if is_stdin {\n+                    libc::FILE_GENERIC_READ\n+                } else {\n+                    libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n+                };\n+                let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n+                let mut sa = libc::SECURITY_ATTRIBUTES {\n+                    nLength: size as libc::DWORD,\n+                    lpSecurityDescriptor: ptr::mut_null(),\n+                    bInheritHandle: 1,\n+                };\n+                *slot = os::win32::as_utf16_p(\"NUL\", |filename| {\n+                    libc::CreateFileW(filename,\n+                                      access,\n+                                      libc::FILE_SHARE_READ |\n+                                          libc::FILE_SHARE_WRITE,\n+                                      &mut sa,\n+                                      libc::OPEN_EXISTING,\n+                                      0,\n+                                      ptr::mut_null())\n+                });\n+                if *slot == INVALID_HANDLE_VALUE as libc::HANDLE {\n+                    return Err(super::last_error())\n+                }\n+            } else {\n+                let orig = get_osfhandle(fd) as HANDLE;\n+                if orig == INVALID_HANDLE_VALUE as HANDLE {\n+                    return Err(super::last_error())\n+                }\n+                if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n+                                   0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+                    return Err(super::last_error())\n+                }\n             }\n-        }\n+            Ok(())\n+        };\n \n-        if err_fd != -1 {\n-            let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n-            if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n-                fail!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-            }\n-            if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n-                               0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-                fail!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n-            }\n-        }\n+        try!(set_fd(in_fd, &mut si.hStdInput, true));\n+        try!(set_fd(out_fd, &mut si.hStdOutput, false));\n+        try!(set_fd(err_fd, &mut si.hStdError, false));\n \n         let cmd_str = make_command_line(cfg.program, cfg.args);\n         let mut pi = zeroed_process_information();\n@@ -338,9 +352,9 @@ fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_i\n             })\n         });\n \n-        if in_fd != -1 { assert!(CloseHandle(si.hStdInput) != 0); }\n-        if out_fd != -1 { assert!(CloseHandle(si.hStdOutput) != 0); }\n-        if err_fd != -1 { assert!(CloseHandle(si.hStdError) != 0); }\n+        assert!(CloseHandle(si.hStdInput) != 0);\n+        assert!(CloseHandle(si.hStdOutput) != 0);\n+        assert!(CloseHandle(si.hStdError) != 0);\n \n         match create_err {\n             Some(err) => return Err(err),\n@@ -379,9 +393,9 @@ fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n         wShowWindow: 0,\n         cbReserved2: 0,\n         lpReserved2: ptr::mut_null(),\n-        hStdInput: ptr::mut_null(),\n-        hStdOutput: ptr::mut_null(),\n-        hStdError: ptr::mut_null()\n+        hStdInput: libc::INVALID_HANDLE_VALUE as libc::HANDLE,\n+        hStdOutput: libc::INVALID_HANDLE_VALUE as libc::HANDLE,\n+        hStdError: libc::INVALID_HANDLE_VALUE as libc::HANDLE,\n     }\n }\n \n@@ -489,6 +503,10 @@ fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_i\n             let mut input = file::FileDesc::new(pipe.input, true);\n             let mut output = file::FileDesc::new(pipe.out, true);\n \n+            // We may use this in the child, so perform allocations before the\n+            // fork\n+            let devnull = \"/dev/null\".to_c_str();\n+\n             set_cloexec(output.fd());\n \n             let pid = fork();\n@@ -563,21 +581,29 @@ fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_i\n \n             rustrt::rust_unset_sigprocmask();\n \n-            if in_fd == -1 {\n-                let _ = libc::close(libc::STDIN_FILENO);\n-            } else if retry(|| dup2(in_fd, 0)) == -1 {\n-                fail(&mut output);\n-            }\n-            if out_fd == -1 {\n-                let _ = libc::close(libc::STDOUT_FILENO);\n-            } else if retry(|| dup2(out_fd, 1)) == -1 {\n-                fail(&mut output);\n-            }\n-            if err_fd == -1 {\n-                let _ = libc::close(libc::STDERR_FILENO);\n-            } else if retry(|| dup2(err_fd, 2)) == -1 {\n-                fail(&mut output);\n-            }\n+            // If a stdio file descriptor is set to be ignored (via a -1 file\n+            // descriptor), then we don't actually close it, but rather open\n+            // up /dev/null into that file descriptor. Otherwise, the first file\n+            // descriptor opened up in the child would be numbered as one of the\n+            // stdio file descriptors, which is likely to wreak havoc.\n+            let setup = |src: c_int, dst: c_int| {\n+                let src = if src == -1 {\n+                    let flags = if dst == libc::STDIN_FILENO {\n+                        libc::O_RDONLY\n+                    } else {\n+                        libc::O_RDWR\n+                    };\n+                    devnull.with_ref(|p| libc::open(p, flags, 0))\n+                } else {\n+                    src\n+                };\n+                src != -1 && retry(|| dup2(src, dst)) != -1\n+            };\n+\n+            if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n+            if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n+            if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n+\n             // close all other fds\n             for fd in range(3, getdtablesize()).rev() {\n                 if fd != output.fd() {"}, {"sha": "79203503373effbb6d668817aee5310285d6260a", "filename": "src/test/run-pass/issue-14456.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/034eb4e724bf138bd2d90268cd0e759f99f0d396/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034eb4e724bf138bd2d90268cd0e759f99f0d396/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14456.rs?ref=034eb4e724bf138bd2d90268cd0e759f99f0d396", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(phase)]\n+\n+#[phase(syntax, link)]\n+extern crate green;\n+extern crate native;\n+\n+use std::io::process;\n+use std::io::Command;\n+use std::io;\n+use std::os;\n+\n+green_start!(main)\n+\n+fn main() {\n+    let args = os::args();\n+    if args.len() > 1 && args.get(1).as_slice() == \"child\" {\n+        return child()\n+    }\n+\n+    test();\n+\n+    let (tx, rx) = channel();\n+    native::task::spawn(proc() {\n+        tx.send(test());\n+    });\n+    rx.recv();\n+\n+}\n+\n+fn child() {\n+    io::stdout().write_line(\"foo\").unwrap();\n+    io::stderr().write_line(\"bar\").unwrap();\n+    assert_eq!(io::stdin().read_line().err().unwrap().kind, io::EndOfFile);\n+}\n+\n+fn test() {\n+    let args = os::args();\n+    let mut p = Command::new(args.get(0).as_slice()).arg(\"child\")\n+                                     .stdin(process::Ignored)\n+                                     .stdout(process::Ignored)\n+                                     .stderr(process::Ignored)\n+                                     .spawn().unwrap();\n+    assert!(p.wait().unwrap().success());\n+}\n+"}]}