{"sha": "6609e71b16567e1a342f5c2461701d93d1273c93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MDllNzFiMTY1NjdlMWEzNDJmNWMyNDYxNzAxZDkzZDEyNzNjOTM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-15T08:25:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-15T08:25:05Z"}, "message": "Merge #4882\n\n4882: _match.rs: improve comment formatting r=matklad a=jonas-schievink\n\nThis results in much nicer rustdoc output\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "d5fdbf0e43c8b4c317ee2867e173379d95508184", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5fdbf0e43c8b4c317ee2867e173379d95508184"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6609e71b16567e1a342f5c2461701d93d1273c93", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe5zBhCRBK7hj4Ov3rIwAAdHIIAKoRfS+cnoDqe2N6Ojtat64i\npvpriAABsWLWLbHhBU7gfitXrBO6iiQcukpeahPGqK02Z1R1ts2g0iPwNLAm/6e5\nh4funaR0cTi6L464Hew3tUN3OwS1/t3/Fo394DXsrlLVd7IZxBfI/Y7ZDaaGg65p\n8p0EfH7fd6GNxOrcvbSvWQvnPkz9Icaj/VA2xWHiLzbNMdSyscB1M3S4IFTqSWWC\nGmDLfG3w0fx/RPBjTCH6XUFJzRw1EBGl3YdBJMnSC306FXdtSaagrujGD0U1LPuZ\nzuqN9NaDirKCYae67vhh9/yqFwgoozB4zZWJIGeDOYjrijXSxxxHCOr0dk+27yk=\n=58Ha\n-----END PGP SIGNATURE-----\n", "payload": "tree d5fdbf0e43c8b4c317ee2867e173379d95508184\nparent 99c1df3599c9fff37e028229aa986c37b42abd14\nparent 4ebafb900561babe780e3f3ee06597acff33f885\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1592209505 +0000\ncommitter GitHub <noreply@github.com> 1592209505 +0000\n\nMerge #4882\n\n4882: _match.rs: improve comment formatting r=matklad a=jonas-schievink\n\nThis results in much nicer rustdoc output\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6609e71b16567e1a342f5c2461701d93d1273c93", "html_url": "https://github.com/rust-lang/rust/commit/6609e71b16567e1a342f5c2461701d93d1273c93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6609e71b16567e1a342f5c2461701d93d1273c93/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99c1df3599c9fff37e028229aa986c37b42abd14", "url": "https://api.github.com/repos/rust-lang/rust/commits/99c1df3599c9fff37e028229aa986c37b42abd14", "html_url": "https://github.com/rust-lang/rust/commit/99c1df3599c9fff37e028229aa986c37b42abd14"}, {"sha": "4ebafb900561babe780e3f3ee06597acff33f885", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ebafb900561babe780e3f3ee06597acff33f885", "html_url": "https://github.com/rust-lang/rust/commit/4ebafb900561babe780e3f3ee06597acff33f885"}], "stats": {"total": 255, "additions": 142, "deletions": 113}, "files": [{"sha": "fff25719325eccf5679cac94f692c8a1f5498ec5", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 142, "deletions": 113, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/6609e71b16567e1a342f5c2461701d93d1273c93/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6609e71b16567e1a342f5c2461701d93d1273c93/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=6609e71b16567e1a342f5c2461701d93d1273c93", "patch": "@@ -8,11 +8,11 @@\n //! This file includes the logic for exhaustiveness and usefulness checking for\n //! pattern-matching. Specifically, given a list of patterns for a type, we can\n //! tell whether:\n-//! (a) the patterns cover every possible constructor for the type [exhaustiveness]\n-//! (b) each pattern is necessary [usefulness]\n+//! - (a) the patterns cover every possible constructor for the type (exhaustiveness).\n+//! - (b) each pattern is necessary (usefulness).\n //!\n-//! The algorithm implemented here is a modified version of the one described in:\n-//! http://moscova.inria.fr/~maranget/papers/warn/index.html\n+//! The algorithm implemented here is a modified version of the one described in\n+//! <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n //! However, to save future implementors from reading the original paper, we\n //! summarise the algorithm here to hopefully save time and be a little clearer\n //! (without being so rigorous).\n@@ -37,20 +37,26 @@\n //! new pattern `p`.\n //!\n //! For example, say we have the following:\n+//!\n+//! ```ignore\n+//! // x: (Option<bool>, Result<()>)\n+//! match x {\n+//!     (Some(true), _) => {}\n+//!     (None, Err(())) => {}\n+//!     (None, Err(_)) => {}\n+//! }\n //! ```\n-//!     // x: (Option<bool>, Result<()>)\n-//!     match x {\n-//!         (Some(true), _) => {}\n-//!         (None, Err(())) => {}\n-//!         (None, Err(_)) => {}\n-//!     }\n-//! ```\n+//!\n //! Here, the matrix `P` starts as:\n+//!\n+//! ```text\n //! [\n //!     [(Some(true), _)],\n //!     [(None, Err(()))],\n //!     [(None, Err(_))],\n //! ]\n+//! ```\n+//!\n //! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n //! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n //! all the values it covers are already covered by row 2.\n@@ -60,53 +66,61 @@\n //! To match the paper, the top of the stack is at the beginning / on the left.\n //!\n //! There are two important operations on pattern-stacks necessary to understand the algorithm:\n-//!     1. We can pop a given constructor off the top of a stack. This operation is called\n-//!        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n-//!        `None`) and `p` a pattern-stack.\n-//!        If the pattern on top of the stack can cover `c`, this removes the constructor and\n-//!        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n-//!        Otherwise the pattern-stack is discarded.\n-//!        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n-//!        discards the others.\n //!\n-//!        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n-//!        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n-//!        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n-//!        nothing back.\n+//! 1. We can pop a given constructor off the top of a stack. This operation is called\n+//!    `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+//!    `None`) and `p` a pattern-stack.\n+//!    If the pattern on top of the stack can cover `c`, this removes the constructor and\n+//!    pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+//!    Otherwise the pattern-stack is discarded.\n+//!    This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+//!    discards the others.\n+//!\n+//!    For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+//!    pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+//!    `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+//!    nothing back.\n+//!\n+//!    This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+//!    on top of the stack, and we have four cases:\n+//!\n+//!    * 1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We push onto\n+//!           the stack the arguments of this constructor, and return the result:\n+//!\n+//!          r_1, .., r_a, p_2, .., p_n\n+//!\n+//!    * 1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and return\n+//!           nothing.\n+//!    * 1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+//!           arguments (its arity), and return the resulting stack:\n //!\n-//!        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n-//!        on top of the stack, and we have four cases:\n-//!             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n-//!                  push onto the stack the arguments of this constructor, and return the result:\n-//!                     r_1, .., r_a, p_2, .., p_n\n-//!             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n-//!                  return nothing.\n-//!             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n-//!                  arguments (its arity), and return the resulting stack:\n-//!                     _, .., _, p_2, .., p_n\n-//!             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-//!                  stack:\n-//!                     S(c, (r_1, p_2, .., p_n))\n-//!                     S(c, (r_2, p_2, .., p_n))\n+//!          _, .., _, p_2, .., p_n\n //!\n-//!     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n-//!        a pattern-stack.\n-//!        This is used when we know there are missing constructor cases, but there might be\n-//!        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n-//!        all its *other* components.\n+//!    * 1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting stack:\n //!\n-//!        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n-//!        and we have three cases:\n-//!             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-//!             1.2. `p_1 = _`. We return the rest of the stack:\n-//!                     p_2, .., p_n\n-//!             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-//!               stack.\n-//!                     D((r_1, p_2, .., p_n))\n-//!                     D((r_2, p_2, .., p_n))\n+//!          S(c, (r_1, p_2, .., p_n))\n+//!          S(c, (r_2, p_2, .., p_n))\n //!\n-//!     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n-//!     exhaustive integer matching rules, so they're written here for posterity.\n+//! 2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n+//!    a pattern-stack.\n+//!    This is used when we know there are missing constructor cases, but there might be\n+//!    existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+//!    all its *other* components.\n+//!\n+//!    It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+//!    and we have three cases:\n+//!    * 1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!    * 1.2. `p_1 = _`. We return the rest of the stack:\n+//!\n+//!          p_2, .., p_n\n+//!\n+//!    * 1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting stack:\n+//!\n+//!          D((r_1, p_2, .., p_n))\n+//!          D((r_2, p_2, .., p_n))\n+//!\n+//!    Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+//!    exhaustive integer matching rules, so they're written here for posterity.\n //!\n //! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n //! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n@@ -120,73 +134,88 @@\n //! operates principally on the first component of the matrix and new pattern-stack `p`.\n //! This algorithm is realised in the `is_useful` function.\n //!\n-//! Base case. (`n = 0`, i.e., an empty tuple pattern)\n-//!     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n-//!       then `U(P, p)` is false.\n-//!     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n+//! Base case (`n = 0`, i.e., an empty tuple pattern):\n+//! - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`), then\n+//!   `U(P, p)` is false.\n+//! - Otherwise, `P` must be empty, so `U(P, p)` is true.\n+//!\n+//! Inductive step (`n > 0`, i.e., whether there's at least one column [which may then be expanded\n+//! into further columns later]). We're going to match on the top of the new pattern-stack, `p_1`:\n+//!\n+//! - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+//!   Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+//!   we ignore all the patterns in the first column of `P` that involve other constructors.\n+//!   This is where `S(c, P)` comes in:\n+//!\n+//!   ```text\n+//!   U(P, p) := U(S(c, P), S(c, p))\n+//!   ```\n+//!\n+//!   This special case is handled in `is_useful_specialized`.\n+//!\n+//!   For example, if `P` is:\n+//!\n+//!   ```text\n+//!   [\n+//!       [Some(true), _],\n+//!       [None, 0],\n+//!   ]\n+//!   ```\n //!\n-//! Inductive step. (`n > 0`, i.e., whether there's at least one column\n-//!                  [which may then be expanded into further columns later])\n-//!     We're going to match on the top of the new pattern-stack, `p_1`.\n-//!         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n-//!           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n-//!           we ignore all the patterns in the first column of `P` that involve other constructors.\n-//!           This is where `S(c, P)` comes in:\n-//!           `U(P, p) := U(S(c, P), S(c, p))`\n-//!           This special case is handled in `is_useful_specialized`.\n+//!   and `p` is `[Some(false), 0]`, then we don't care about row 2 since we know `p` only\n+//!   matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+//!   arguments of `Some` to know whether some new value is covered. So we compute\n+//!   `U([[true, _]], [false, 0])`.\n //!\n-//!           For example, if `P` is:\n-//!           [\n-//!               [Some(true), _],\n-//!               [None, 0],\n-//!           ]\n-//!           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n-//!           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n-//!           arguments of `Some` to know whether some new value is covered. So we compute\n-//!           `U([[true, _]], [false, 0])`.\n+//! - If `p_1 == _`, then we look at the list of constructors that appear in the first component of\n+//!   the rows of `P`:\n+//!     - If there are some constructors that aren't present, then we might think that the\n+//!       wildcard `_` is useful, since it covers those constructors that weren't covered\n+//!       before.\n+//!       That's almost correct, but only works if there were no wildcards in those first\n+//!       components. So we need to check that `p` is useful with respect to the rows that\n+//!       start with a wildcard, if there are any. This is where `D` comes in:\n+//!       `U(P, p) := U(D(P), D(p))`\n //!\n-//!         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n-//!               component of the rows of `P`:\n-//!             + If there are some constructors that aren't present, then we might think that the\n-//!               wildcard `_` is useful, since it covers those constructors that weren't covered\n-//!               before.\n-//!               That's almost correct, but only works if there were no wildcards in those first\n-//!               components. So we need to check that `p` is useful with respect to the rows that\n-//!               start with a wildcard, if there are any. This is where `D` comes in:\n-//!               `U(P, p) := U(D(P), D(p))`\n+//!       For example, if `P` is:\n+//!       ```text\n+//!       [\n+//!           [_, true, _],\n+//!           [None, false, 1],\n+//!       ]\n+//!       ```\n+//!       and `p` is `[_, false, _]`, the `Some` constructor doesn't appear in `P`. So if we\n+//!       only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+//!       wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n //!\n-//!               For example, if `P` is:\n-//!               [\n-//!                   [_, true, _],\n-//!                   [None, false, 1],\n-//!               ]\n-//!               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n-//!               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n-//!               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//!     - Otherwise, all possible constructors (for the relevant type) are present. In this\n+//!       case we must check whether the wildcard pattern covers any unmatched value. For\n+//!       that, we can think of the `_` pattern as a big OR-pattern that covers all\n+//!       possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+//!       example. The wildcard pattern is useful in this case if it is useful when\n+//!       specialized to one of the possible constructors. So we compute:\n+//!       `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n //!\n-//!             + Otherwise, all possible constructors (for the relevant type) are present. In this\n-//!               case we must check whether the wildcard pattern covers any unmatched value. For\n-//!               that, we can think of the `_` pattern as a big OR-pattern that covers all\n-//!               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n-//!               example. The wildcard pattern is useful in this case if it is useful when\n-//!               specialized to one of the possible constructors. So we compute:\n-//!               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//!       For example, if `P` is:\n+//!       ```text\n+//!       [\n+//!           [Some(true), _],\n+//!           [None, false],\n+//!       ]\n+//!       ```\n+//!       and `p` is `[_, false]`, both `None` and `Some` constructors appear in the first\n+//!       components of `P`. We will therefore try popping both constructors in turn: we\n+//!       compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n+//!       [false])` for the `None` constructor. The first case returns true, so we know that\n+//!       `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+//!       before.\n //!\n-//!               For example, if `P` is:\n-//!               [\n-//!                   [Some(true), _],\n-//!                   [None, false],\n-//!               ]\n-//!               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n-//!               components of `P`. We will therefore try popping both constructors in turn: we\n-//!               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n-//!               [false]) for the `None` constructor. The first case returns true, so we know that\n-//!               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n-//!               before.\n+//! - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n //!\n-//!         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n-//!           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n-//!                    || U(P, (r_2, p_2, .., p_n))`\n+//!   ```text\n+//!   U(P, p) := U(P, (r_1, p_2, .., p_n))\n+//!            || U(P, (r_2, p_2, .., p_n))\n+//!   ```\n use std::sync::Arc;\n \n use smallvec::{smallvec, SmallVec};"}]}