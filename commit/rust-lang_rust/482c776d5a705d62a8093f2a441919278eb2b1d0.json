{"sha": "482c776d5a705d62a8093f2a441919278eb2b1d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MmM3NzZkNWE3MDVkNjJhODA5M2YyYTQ0MTkxOTI3OGViMmIxZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-24T11:46:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-24T11:46:15Z"}, "message": "auto merge of #15856 : treeman/rust/doc-priorityqueue, r=huonw\n\nAdd examples to methods.", "tree": {"sha": "eb29f3512aa97294b093858cde1e1dcd39a27787", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb29f3512aa97294b093858cde1e1dcd39a27787"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/482c776d5a705d62a8093f2a441919278eb2b1d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/482c776d5a705d62a8093f2a441919278eb2b1d0", "html_url": "https://github.com/rust-lang/rust/commit/482c776d5a705d62a8093f2a441919278eb2b1d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/482c776d5a705d62a8093f2a441919278eb2b1d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e70ee120bf70d5b6195c2b355b9820a8609564cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e70ee120bf70d5b6195c2b355b9820a8609564cf", "html_url": "https://github.com/rust-lang/rust/commit/e70ee120bf70d5b6195c2b355b9820a8609564cf"}, {"sha": "571692c0abc1213d5ba2bfbb8f0787bbffd04acf", "url": "https://api.github.com/repos/rust-lang/rust/commits/571692c0abc1213d5ba2bfbb8f0787bbffd04acf", "html_url": "https://github.com/rust-lang/rust/commit/571692c0abc1213d5ba2bfbb8f0787bbffd04acf"}], "stats": {"total": 221, "additions": 193, "deletions": 28}, "files": [{"sha": "f76fae39f3426d443b258ae88557be6273cfd4ba", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 193, "deletions": 28, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/482c776d5a705d62a8093f2a441919278eb2b1d0/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/482c776d5a705d62a8093f2a441919278eb2b1d0/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=482c776d5a705d62a8093f2a441919278eb2b1d0", "patch": "@@ -158,7 +158,9 @@ use {Collection, Mutable, MutableSeq};\n use slice;\n use vec::Vec;\n \n-/// A priority queue implemented with a binary heap\n+/// A priority queue implemented with a binary heap.\n+///\n+/// This will be a max-heap.\n #[deriving(Clone)]\n pub struct PriorityQueue<T> {\n     data: Vec<T>,\n@@ -180,35 +182,147 @@ impl<T: Ord> Default for PriorityQueue<T> {\n }\n \n impl<T: Ord> PriorityQueue<T> {\n+    /// Create an empty PriorityQueue as a max-heap.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    /// let pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// ```\n+    pub fn new() -> PriorityQueue<T> { PriorityQueue{data: vec!(),} }\n+\n+    /// Create an empty PriorityQueue with a specific capacity.\n+    /// This preallocates enough memory for `capacity` elements,\n+    /// so that the PriorityQueue does not have to be reallocated\n+    /// until it contains at least that many values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    /// let pq: PriorityQueue<uint> = PriorityQueue::with_capacity(10u);\n+    /// ```\n+    pub fn with_capacity(capacity: uint) -> PriorityQueue<T> {\n+        PriorityQueue { data: Vec::with_capacity(capacity) }\n+    }\n+\n+    /// Create a PriorityQueue from a vector. This is sometimes called\n+    /// `heapifying` the vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    /// let pq = PriorityQueue::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n+    /// ```\n+    pub fn from_vec(xs: Vec<T>) -> PriorityQueue<T> {\n+        let mut q = PriorityQueue{data: xs,};\n+        let mut n = q.len() / 2;\n+        while n > 0 {\n+            n -= 1;\n+            q.siftdown(n)\n+        }\n+        q\n+    }\n+\n     /// An iterator visiting all values in underlying vector, in\n     /// arbitrary order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    /// let pq = PriorityQueue::from_vec(vec![1i, 2, 3, 4]);\n+    ///\n+    /// // Print 1, 2, 3, 4 in arbitrary order\n+    /// for x in pq.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         Items { iter: self.data.iter() }\n     }\n \n-    /// Returns the greatest item in a queue or None if it is empty\n+    /// Returns the greatest item in a queue or `None` if it is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::new();\n+    /// assert_eq!(pq.top(), None);\n+    ///\n+    /// pq.push(1i);\n+    /// pq.push(5i);\n+    /// pq.push(2i);\n+    /// assert_eq!(pq.top(), Some(&5i));\n+    ///\n+    /// ```\n     pub fn top<'a>(&'a self) -> Option<&'a T> {\n         if self.is_empty() { None } else { Some(self.data.get(0)) }\n     }\n \n     #[deprecated=\"renamed to `top`\"]\n     pub fn maybe_top<'a>(&'a self) -> Option<&'a T> { self.top() }\n \n-    /// Returns the number of elements the queue can hold without reallocating\n+    /// Returns the number of elements the queue can hold without reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let pq: PriorityQueue<uint> = PriorityQueue::with_capacity(100u);\n+    /// assert!(pq.capacity() >= 100u);\n+    /// ```\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    /// Reserve capacity for exactly n elements in the PriorityQueue.\n+    /// Reserve capacity for exactly `n` elements in the PriorityQueue.\n     /// Do nothing if the capacity is already sufficient.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// pq.reserve_exact(100u);\n+    /// assert!(pq.capacity() == 100u);\n+    /// ```\n     pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }\n \n-    /// Reserve capacity for at least n elements in the PriorityQueue.\n+    /// Reserve capacity for at least `n` elements in the PriorityQueue.\n     /// Do nothing if the capacity is already sufficient.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq: PriorityQueue<uint> = PriorityQueue::new();\n+    /// pq.reserve(100u);\n+    /// assert!(pq.capacity() >= 100u);\n+    /// ```\n     pub fn reserve(&mut self, n: uint) {\n         self.data.reserve(n)\n     }\n \n     /// Remove the greatest item from a queue and return it, or `None` if it is\n     /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::from_vec(vec![1i, 3]);\n+    ///\n+    /// assert_eq!(pq.pop(), Some(3i));\n+    /// assert_eq!(pq.pop(), Some(1i));\n+    /// assert_eq!(pq.pop(), None);\n+    /// ```\n     pub fn pop(&mut self) -> Option<T> {\n         match self.data.pop() {\n             None           => { None }\n@@ -225,14 +339,43 @@ impl<T: Ord> PriorityQueue<T> {\n     #[deprecated=\"renamed to `pop`\"]\n     pub fn maybe_pop(&mut self) -> Option<T> { self.pop() }\n \n-    /// Push an item onto the queue\n+    /// Push an item onto the queue.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::new();\n+    /// pq.push(3i);\n+    /// pq.push(5i);\n+    /// pq.push(1i);\n+    ///\n+    /// assert_eq!(pq.len(), 3);\n+    /// assert_eq!(pq.top(), Some(&5i));\n+    /// ```\n     pub fn push(&mut self, item: T) {\n         self.data.push(item);\n         let new_len = self.len() - 1;\n         self.siftup(0, new_len);\n     }\n \n-    /// Optimized version of a push followed by a pop\n+    /// Optimized version of a push followed by a pop.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::new();\n+    /// pq.push(1i);\n+    /// pq.push(5i);\n+    ///\n+    /// assert_eq!(pq.push_pop(3i), 5);\n+    /// assert_eq!(pq.push_pop(9i), 9);\n+    /// assert_eq!(pq.len(), 2);\n+    /// assert_eq!(pq.top(), Some(&3i));\n+    /// ```\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         if !self.is_empty() && *self.top().unwrap() > item {\n             swap(&mut item, self.data.get_mut(0));\n@@ -243,6 +386,19 @@ impl<T: Ord> PriorityQueue<T> {\n \n     /// Optimized version of a pop followed by a push. The push is done\n     /// regardless of whether the queue is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::new();\n+    ///\n+    /// assert_eq!(pq.replace(1i), None);\n+    /// assert_eq!(pq.replace(3i), Some(1i));\n+    /// assert_eq!(pq.len(), 1);\n+    /// assert_eq!(pq.top(), Some(&3i));\n+    /// ```\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n             swap(&mut item, self.data.get_mut(0));\n@@ -263,10 +419,38 @@ impl<T: Ord> PriorityQueue<T> {\n     fn to_sorted_vec(self) -> Vec<T> { self.into_sorted_vec() }\n \n     /// Consume the PriorityQueue and return the underlying vector\n+    /// in arbitrary order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let pq = PriorityQueue::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// let vec = pq.into_vec();\n+    ///\n+    /// // Will print in some order\n+    /// for x in vec.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     pub fn into_vec(self) -> Vec<T> { let PriorityQueue{data: v} = self; v }\n \n     /// Consume the PriorityQueue and return a vector in sorted\n-    /// (ascending) order\n+    /// (ascending) order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::PriorityQueue;\n+    ///\n+    /// let mut pq = PriorityQueue::from_vec(vec![1i, 2, 4, 5, 7]);\n+    /// pq.push(6);\n+    /// pq.push(3);\n+    ///\n+    /// let vec = pq.into_sorted_vec();\n+    /// assert_eq!(vec, vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// ```\n     pub fn into_sorted_vec(self) -> Vec<T> {\n         let mut q = self;\n         let mut end = q.len();\n@@ -278,25 +462,6 @@ impl<T: Ord> PriorityQueue<T> {\n         q.into_vec()\n     }\n \n-    /// Create an empty PriorityQueue\n-    pub fn new() -> PriorityQueue<T> { PriorityQueue{data: vec!(),} }\n-\n-    /// Create an empty PriorityQueue with capacity `capacity`\n-    pub fn with_capacity(capacity: uint) -> PriorityQueue<T> {\n-        PriorityQueue { data: Vec::with_capacity(capacity) }\n-    }\n-\n-    /// Create a PriorityQueue from a vector (heapify)\n-    pub fn from_vec(xs: Vec<T>) -> PriorityQueue<T> {\n-        let mut q = PriorityQueue{data: xs,};\n-        let mut n = q.len() / 2;\n-        while n > 0 {\n-            n -= 1;\n-            q.siftdown(n)\n-        }\n-        q\n-    }\n-\n     // The implementations of siftup and siftdown use unsafe blocks in\n     // order to move an element out of the vector (leaving behind a\n     // zeroed element), shift along the others and move it back into the\n@@ -348,7 +513,7 @@ impl<T: Ord> PriorityQueue<T> {\n     }\n }\n \n-/// PriorityQueue iterator\n+/// PriorityQueue iterator.\n pub struct Items <'a, T> {\n     iter: slice::Items<'a, T>,\n }"}]}