{"sha": "ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNjdkYTYzZWE0Y2E5YjE5ZTFlOGVlOTdkZTAwMmE2NGEyYTA0NzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-29T14:53:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-29T14:53:33Z"}, "message": "Auto merge of #36752 - jonas-schievink:vartmparg, r=eddyb\n\nMove MIR towards a single kind of local\n\nThis PR modifies MIR to handle function arguments (`Arg`), user-defined variable bindings (`Var`), compiler-generated temporaries (`Tmp`), as well as the return value pointer equally. All of them are replaced with a single `Local` type, a few functions for iterating over different kinds of locals, and a way to get the kind of local we're dealing with (mainly used in the constant qualification/propagation passes).\n\n~~I haven't managed to fix one remaining issue: A `StorageDead` not getting emitted for a variable (see the `TODO` in the test). If that's fixed, this is basically good to go.~~ Found the issue (an off-by-one error), fix incoming.\n\nr? @eddyb for changes to constant qualification and propagation I'm not quite sure about", "tree": {"sha": "13299f7238d77d904402578a9600bb9f4b4f2be8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13299f7238d77d904402578a9600bb9f4b4f2be8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "html_url": "https://github.com/rust-lang/rust/commit/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "704bcc0ddafc0b3c3f4879286204442d43169e30", "url": "https://api.github.com/repos/rust-lang/rust/commits/704bcc0ddafc0b3c3f4879286204442d43169e30", "html_url": "https://github.com/rust-lang/rust/commit/704bcc0ddafc0b3c3f4879286204442d43169e30"}, {"sha": "d2c8893137fa98ce3b0de68b1d6ee95aecb743ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2c8893137fa98ce3b0de68b1d6ee95aecb743ee", "html_url": "https://github.com/rust-lang/rust/commit/d2c8893137fa98ce3b0de68b1d6ee95aecb743ee"}], "stats": {"total": 1326, "additions": 645, "deletions": 681}, "files": [{"sha": "5da2e2f6fda5444d763ad1c1ffe515fa033d4a00", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 149, "deletions": 141, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -70,29 +70,37 @@ pub struct Mir<'tcx> {\n \n     /// Rvalues promoted from this function, such as borrows of constants.\n     /// Each of them is the Mir of a constant with the fn's type parameters\n-    /// in scope, but no vars or args and a separate set of temps.\n+    /// in scope, but a separate set of locals.\n     pub promoted: IndexVec<Promoted, Mir<'tcx>>,\n \n     /// Return type of the function.\n     pub return_ty: Ty<'tcx>,\n \n-    /// Variables: these are stack slots corresponding to user variables. They may be\n-    /// assigned many times.\n-    pub var_decls: IndexVec<Var, VarDecl<'tcx>>,\n-\n-    /// Args: these are stack slots corresponding to the input arguments.\n-    pub arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n+    /// Declarations of locals.\n+    ///\n+    /// The first local is the return value pointer, followed by `arg_count`\n+    /// locals for the function arguments, followed by any user-declared\n+    /// variables and temporaries.\n+    pub local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n \n-    /// Temp declarations: stack slots that for temporaries created by\n-    /// the compiler. These are assigned once, but they are not SSA\n-    /// values in that it is possible to borrow them and mutate them\n-    /// through the resulting reference.\n-    pub temp_decls: IndexVec<Temp, TempDecl<'tcx>>,\n+    /// Number of arguments this function takes.\n+    ///\n+    /// Starting at local 1, `arg_count` locals will be provided by the caller\n+    /// and can be assumed to be initialized.\n+    ///\n+    /// If this MIR was built for a constant, this will be 0.\n+    pub arg_count: usize,\n \n     /// Names and capture modes of all the closure upvars, assuming\n     /// the first argument is either the closure or a reference to it.\n     pub upvar_decls: Vec<UpvarDecl>,\n \n+    /// Mark an argument local (which must be a tuple) as getting passed as\n+    /// its individual components at the LLVM level.\n+    ///\n+    /// This is used for the \"rust-call\" ABI.\n+    pub spread_arg: Option<Local>,\n+\n     /// A span representing this MIR, for error reporting\n     pub span: Span,\n \n@@ -108,21 +116,25 @@ impl<'tcx> Mir<'tcx> {\n                visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n                promoted: IndexVec<Promoted, Mir<'tcx>>,\n                return_ty: Ty<'tcx>,\n-               var_decls: IndexVec<Var, VarDecl<'tcx>>,\n-               arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n-               temp_decls: IndexVec<Temp, TempDecl<'tcx>>,\n+               local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+               arg_count: usize,\n                upvar_decls: Vec<UpvarDecl>,\n                span: Span) -> Self\n     {\n+        // We need `arg_count` locals, and one for the return pointer\n+        assert!(local_decls.len() >= arg_count + 1,\n+            \"expected at least {} locals, got {}\", arg_count + 1, local_decls.len());\n+        assert_eq!(local_decls[RETURN_POINTER].ty, return_ty);\n+\n         Mir {\n             basic_blocks: basic_blocks,\n             visibility_scopes: visibility_scopes,\n             promoted: promoted,\n             return_ty: return_ty,\n-            var_decls: var_decls,\n-            arg_decls: arg_decls,\n-            temp_decls: temp_decls,\n+            local_decls: local_decls,\n+            arg_count: arg_count,\n             upvar_decls: upvar_decls,\n+            spread_arg: None,\n             span: span,\n             cache: Cache::new()\n         }\n@@ -154,56 +166,66 @@ impl<'tcx> Mir<'tcx> {\n         dominators(self)\n     }\n \n-    /// Maps locals (Arg's, Var's, Temp's and ReturnPointer, in that order)\n-    /// to their index in the whole list of locals. This is useful if you\n-    /// want to treat all locals the same instead of repeating yourself.\n-    pub fn local_index(&self, lvalue: &Lvalue<'tcx>) -> Option<Local> {\n-        let idx = match *lvalue {\n-            Lvalue::Arg(arg) => arg.index(),\n-            Lvalue::Var(var) => {\n-                self.arg_decls.len() +\n-                var.index()\n-            }\n-            Lvalue::Temp(temp) => {\n-                self.arg_decls.len() +\n-                self.var_decls.len() +\n-                temp.index()\n+    #[inline]\n+    pub fn local_kind(&self, local: Local) -> LocalKind {\n+        let index = local.0 as usize;\n+        if index == 0 {\n+            debug_assert!(self.local_decls[local].mutability == Mutability::Mut,\n+                          \"return pointer should be mutable\");\n+\n+            LocalKind::ReturnPointer\n+        } else if index < self.arg_count + 1 {\n+            LocalKind::Arg\n+        } else if self.local_decls[local].name.is_some() {\n+            LocalKind::Var\n+        } else {\n+            debug_assert!(self.local_decls[local].mutability == Mutability::Mut,\n+                          \"temp should be mutable\");\n+\n+            LocalKind::Temp\n+        }\n+    }\n+\n+    /// Returns an iterator over all temporaries.\n+    #[inline]\n+    pub fn temps_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n+        (self.arg_count+1..self.local_decls.len()).filter_map(move |index| {\n+            let local = Local::new(index);\n+            if self.local_decls[local].source_info.is_none() {\n+                Some(local)\n+            } else {\n+                None\n             }\n-            Lvalue::ReturnPointer => {\n-                self.arg_decls.len() +\n-                self.var_decls.len() +\n-                self.temp_decls.len()\n+        })\n+    }\n+\n+    /// Returns an iterator over all user-declared locals.\n+    #[inline]\n+    pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n+        (self.arg_count+1..self.local_decls.len()).filter_map(move |index| {\n+            let local = Local::new(index);\n+            if self.local_decls[local].source_info.is_none() {\n+                None\n+            } else {\n+                Some(local)\n             }\n-            Lvalue::Static(_) |\n-            Lvalue::Projection(_) => return None\n-        };\n-        Some(Local::new(idx))\n+        })\n     }\n \n-    /// Counts the number of locals, such that local_index\n-    /// will always return an index smaller than this count.\n-    pub fn count_locals(&self) -> usize {\n-        self.arg_decls.len() +\n-        self.var_decls.len() +\n-        self.temp_decls.len() + 1\n+    /// Returns an iterator over all function arguments.\n+    #[inline]\n+    pub fn args_iter(&self) -> impl Iterator<Item=Local> {\n+        let arg_count = self.arg_count;\n+        (1..arg_count+1).map(Local::new)\n     }\n \n-    pub fn format_local(&self, local: Local) -> String {\n-        let mut index = local.index();\n-        index = match index.checked_sub(self.arg_decls.len()) {\n-            None => return format!(\"{:?}\", Arg::new(index)),\n-            Some(index) => index,\n-        };\n-        index = match index.checked_sub(self.var_decls.len()) {\n-            None => return format!(\"{:?}\", Var::new(index)),\n-            Some(index) => index,\n-        };\n-        index = match index.checked_sub(self.temp_decls.len()) {\n-            None => return format!(\"{:?}\", Temp::new(index)),\n-            Some(index) => index,\n-        };\n-        debug_assert!(index == 0);\n-        return \"ReturnPointer\".to_string()\n+    /// Returns an iterator over all user-defined variables and compiler-generated temporaries (all\n+    /// locals that are neither arguments nor the return pointer).\n+    #[inline]\n+    pub fn vars_and_temps_iter(&self) -> impl Iterator<Item=Local> {\n+        let arg_count = self.arg_count;\n+        let local_count = self.local_decls.len();\n+        (arg_count+1..local_count).map(Local::new)\n     }\n \n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n@@ -301,53 +323,76 @@ pub enum BorrowKind {\n ///////////////////////////////////////////////////////////////////////////\n // Variables and temps\n \n-/// A \"variable\" is a binding declared by the user as part of the fn\n-/// decl, a let, etc.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct VarDecl<'tcx> {\n-    /// `let mut x` vs `let x`\n-    pub mutability: Mutability,\n-\n-    /// name that user gave the variable; not that, internally,\n-    /// mir references variables by index\n-    pub name: Name,\n+newtype_index!(Local, \"_\");\n \n-    /// type inferred for this variable (`let x: ty = ...`)\n-    pub ty: Ty<'tcx>,\n+pub const RETURN_POINTER: Local = Local(0);\n \n-    /// source information (span, scope, etc.) for the declaration\n-    pub source_info: SourceInfo,\n-}\n-\n-/// A \"temp\" is a temporary that we place on the stack. They are\n-/// anonymous, always mutable, and have only a type.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct TempDecl<'tcx> {\n-    pub ty: Ty<'tcx>,\n+/// Classifies locals into categories. See `Mir::local_kind`.\n+#[derive(PartialEq, Eq, Debug)]\n+pub enum LocalKind {\n+    /// User-declared variable binding\n+    Var,\n+    /// Compiler-introduced temporary\n+    Temp,\n+    /// Function argument\n+    Arg,\n+    /// Location of function's return value\n+    ReturnPointer,\n }\n \n-/// A \"arg\" is one of the function's formal arguments. These are\n-/// anonymous and distinct from the bindings that the user declares.\n-///\n-/// For example, in this function:\n-///\n-/// ```\n-/// fn foo((x, y): (i32, u32)) { ... }\n-/// ```\n+/// A MIR local.\n ///\n-/// there is only one argument, of type `(i32, u32)`, but two bindings\n-/// (`x` and `y`).\n+/// This can be a binding declared by the user, a temporary inserted by the compiler, a function\n+/// argument, or the return pointer.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct ArgDecl<'tcx> {\n+pub struct LocalDecl<'tcx> {\n+    /// `let mut x` vs `let x`.\n+    ///\n+    /// Temporaries and the return pointer are always mutable.\n+    pub mutability: Mutability,\n+\n+    /// Type of this local.\n     pub ty: Ty<'tcx>,\n \n-    /// If true, this argument is a tuple after monomorphization,\n-    /// and has to be collected from multiple actual arguments.\n-    pub spread: bool,\n+    /// Name of the local, used in debuginfo and pretty-printing.\n+    ///\n+    /// Note that function arguments can also have this set to `Some(_)`\n+    /// to generate better debuginfo.\n+    pub name: Option<Name>,\n \n-    /// Either keywords::Invalid or the name of a single-binding\n-    /// pattern associated with this argument. Useful for debuginfo.\n-    pub debug_name: Name\n+    /// For user-declared variables, stores their source information.\n+    ///\n+    /// For temporaries, this is `None`.\n+    ///\n+    /// This is the primary way to differentiate between user-declared\n+    /// variables and compiler-generated temporaries.\n+    pub source_info: Option<SourceInfo>,\n+}\n+\n+impl<'tcx> LocalDecl<'tcx> {\n+    /// Create a new `LocalDecl` for a temporary.\n+    #[inline]\n+    pub fn new_temp(ty: Ty<'tcx>) -> Self {\n+        LocalDecl {\n+            mutability: Mutability::Mut,\n+            ty: ty,\n+            name: None,\n+            source_info: None,\n+        }\n+    }\n+\n+    /// Builds a `LocalDecl` for the return pointer.\n+    ///\n+    /// This must be inserted into the `local_decls` list as the first local.\n+    #[inline]\n+    pub fn new_return_pointer(return_ty: Ty) -> LocalDecl {\n+        LocalDecl {\n+            mutability: Mutability::Mut,\n+            ty: return_ty,\n+            source_info: None,\n+            name: None,     // FIXME maybe we do want some name here?\n+        }\n+    }\n }\n \n /// A closure capture, with its name and mode.\n@@ -439,7 +484,7 @@ pub enum TerminatorKind<'tcx> {\n     /// continue. Emitted by build::scope::diverge_cleanup.\n     Resume,\n \n-    /// Indicates a normal return. The ReturnPointer lvalue should\n+    /// Indicates a normal return. The return pointer lvalue should\n     /// have been filled in by now. This should occur at most once.\n     Return,\n \n@@ -756,31 +801,16 @@ impl<'tcx> Debug for Statement<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Lvalues\n \n-newtype_index!(Var, \"var\");\n-newtype_index!(Temp, \"tmp\");\n-newtype_index!(Arg, \"arg\");\n-newtype_index!(Local, \"local\");\n-\n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Lvalue<'tcx> {\n-    /// local variable declared by the user\n-    Var(Var),\n-\n-    /// temporary introduced during lowering into MIR\n-    Temp(Temp),\n-\n-    /// formal parameter of the function; note that these are NOT the\n-    /// bindings that the user declares, which are vars\n-    Arg(Arg),\n+    /// local variable\n+    Local(Local),\n \n     /// static or static mut variable\n     Static(DefId),\n \n-    /// the return pointer of the fn\n-    ReturnPointer,\n-\n     /// projection out of an lvalue (access a field, deref a pointer, etc)\n     Projection(Box<LvalueProjection<'tcx>>),\n }\n@@ -862,38 +892,16 @@ impl<'tcx> Lvalue<'tcx> {\n             elem: elem,\n         }))\n     }\n-\n-    pub fn from_local(mir: &Mir<'tcx>, local: Local) -> Lvalue<'tcx> {\n-        let mut index = local.index();\n-        index = match index.checked_sub(mir.arg_decls.len()) {\n-            None => return Lvalue::Arg(Arg(index as u32)),\n-            Some(index) => index,\n-        };\n-        index = match index.checked_sub(mir.var_decls.len()) {\n-            None => return Lvalue::Var(Var(index as u32)),\n-            Some(index) => index,\n-        };\n-        index = match index.checked_sub(mir.temp_decls.len()) {\n-            None => return Lvalue::Temp(Temp(index as u32)),\n-            Some(index) => index,\n-        };\n-        debug_assert!(index == 0);\n-        Lvalue::ReturnPointer\n-    }\n }\n \n impl<'tcx> Debug for Lvalue<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::Lvalue::*;\n \n         match *self {\n-            Var(id) => write!(fmt, \"{:?}\", id),\n-            Arg(id) => write!(fmt, \"{:?}\", id),\n-            Temp(id) => write!(fmt, \"{:?}\", id),\n+            Local(id) => write!(fmt, \"{:?}\", id),\n             Static(def_id) =>\n                 write!(fmt, \"{}\", ty::tls::with(|tcx| tcx.item_path_str(def_id))),\n-            ReturnPointer =>\n-                write!(fmt, \"return\"),\n             Projection(ref data) =>\n                 match data.elem {\n                     ProjectionElem::Downcast(ref adt_def, index) =>"}, {"sha": "19e980ec73eb148464f492cd0553ef9333fc8515", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -49,12 +49,17 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n                          -> LvalueTy<'tcx>\n     {\n         match *elem {\n-            ProjectionElem::Deref =>\n+            ProjectionElem::Deref => {\n+                let ty = self.to_ty(tcx)\n+                             .builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                             .unwrap_or_else(|| {\n+                                 bug!(\"deref projection of non-dereferencable ty {:?}\", self)\n+                             })\n+                             .ty;\n                 LvalueTy::Ty {\n-                    ty: self.to_ty(tcx).builtin_deref(true, ty::LvaluePreference::NoPreference)\n-                                          .unwrap()\n-                                          .ty\n-                },\n+                    ty: ty,\n+                }\n+            }\n             ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } =>\n                 LvalueTy::Ty {\n                     ty: self.to_ty(tcx).builtin_index().unwrap()\n@@ -116,18 +121,12 @@ impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n \n impl<'tcx> Lvalue<'tcx> {\n     pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> LvalueTy<'tcx> {\n-        match self {\n-            &Lvalue::Var(index) =>\n-                LvalueTy::Ty { ty: mir.var_decls[index].ty },\n-            &Lvalue::Temp(index) =>\n-                LvalueTy::Ty { ty: mir.temp_decls[index].ty },\n-            &Lvalue::Arg(index) =>\n-                LvalueTy::Ty { ty: mir.arg_decls[index].ty },\n-            &Lvalue::Static(def_id) =>\n+        match *self {\n+            Lvalue::Local(index) =>\n+                LvalueTy::Ty { ty: mir.local_decls[index].ty },\n+            Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n-            &Lvalue::ReturnPointer =>\n-                LvalueTy::Ty { ty: mir.return_ty },\n-            &Lvalue::Projection(ref proj) =>\n+            Lvalue::Projection(ref proj) =>\n                 proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n         }\n     }"}, {"sha": "9e0bafa4e310f22bafe9244c0c3dfff26c979840", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 14, "deletions": 53, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -236,19 +236,9 @@ macro_rules! make_mir_visitor {\n                 self.super_typed_const_val(val, location);\n             }\n \n-            fn visit_var_decl(&mut self,\n-                              var_decl: & $($mutability)* VarDecl<'tcx>) {\n-                self.super_var_decl(var_decl);\n-            }\n-\n-            fn visit_temp_decl(&mut self,\n-                               temp_decl: & $($mutability)* TempDecl<'tcx>) {\n-                self.super_temp_decl(temp_decl);\n-            }\n-\n-            fn visit_arg_decl(&mut self,\n-                              arg_decl: & $($mutability)* ArgDecl<'tcx>) {\n-                self.super_arg_decl(arg_decl);\n+            fn visit_local_decl(&mut self,\n+                                local_decl: & $($mutability)* LocalDecl<'tcx>) {\n+                self.super_local_decl(local_decl);\n             }\n \n             fn visit_visibility_scope(&mut self,\n@@ -272,16 +262,8 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_ty(&$($mutability)* mir.return_ty);\n \n-                for var_decl in &$($mutability)* mir.var_decls {\n-                    self.visit_var_decl(var_decl);\n-                }\n-\n-                for arg_decl in &$($mutability)* mir.arg_decls {\n-                    self.visit_arg_decl(arg_decl);\n-                }\n-\n-                for temp_decl in &$($mutability)* mir.temp_decls {\n-                    self.visit_temp_decl(temp_decl);\n+                for local_decl in &$($mutability)* mir.local_decls {\n+                    self.visit_local_decl(local_decl);\n                 }\n \n                 self.visit_span(&$($mutability)* mir.span);\n@@ -584,10 +566,7 @@ macro_rules! make_mir_visitor {\n                             context: LvalueContext<'tcx>,\n                             location: Location) {\n                 match *lvalue {\n-                    Lvalue::Var(_) |\n-                    Lvalue::Temp(_) |\n-                    Lvalue::Arg(_) |\n-                    Lvalue::ReturnPointer => {\n+                    Lvalue::Local(_) => {\n                     }\n                     Lvalue::Static(ref $($mutability)* def_id) => {\n                         self.visit_def_id(def_id, location);\n@@ -639,37 +618,19 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n-            fn super_var_decl(&mut self,\n-                              var_decl: & $($mutability)* VarDecl<'tcx>) {\n-                let VarDecl {\n+            fn super_local_decl(&mut self,\n+                                local_decl: & $($mutability)* LocalDecl<'tcx>) {\n+                let LocalDecl {\n                     mutability: _,\n-                    name: _,\n                     ref $($mutability)* ty,\n+                    name: _,\n                     ref $($mutability)* source_info,\n-                } = *var_decl;\n-\n-                self.visit_ty(ty);\n-                self.visit_source_info(source_info);\n-            }\n-\n-            fn super_temp_decl(&mut self,\n-                               temp_decl: & $($mutability)* TempDecl<'tcx>) {\n-                let TempDecl {\n-                    ref $($mutability)* ty,\n-                } = *temp_decl;\n-\n-                self.visit_ty(ty);\n-            }\n-\n-            fn super_arg_decl(&mut self,\n-                              arg_decl: & $($mutability)* ArgDecl<'tcx>) {\n-                let ArgDecl {\n-                    ref $($mutability)* ty,\n-                    spread: _,\n-                    debug_name: _\n-                } = *arg_decl;\n+                } = *local_decl;\n \n                 self.visit_ty(ty);\n+                if let Some(ref $($mutability)* info) = *source_info {\n+                    self.visit_source_info(info);\n+                }\n             }\n \n             fn super_visibility_scope(&mut self,"}, {"sha": "5e22d477c518556b65fb6c123fa33231ed76cd9c", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -73,11 +73,13 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n     assert!(args.len() == 1);\n     let peek_arg_lval = match args[0] {\n-        repr::Operand::Consume(ref lval @ repr::Lvalue::Temp(_)) => {\n-            lval\n-        }\n-        repr::Operand::Consume(_) |\n-        repr::Operand::Constant(_) => {\n+        repr::Operand::Consume(ref lval @ repr::Lvalue::Local(_)) => Some(lval),\n+        _ => None,\n+    };\n+\n+    let peek_arg_lval = match peek_arg_lval {\n+        Some(arg) => arg,\n+        None => {\n             tcx.sess.diagnostic().span_err(\n                 span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n             return;"}, {"sha": "188fce467be52c8024be3e5f2606fb51493b7afa", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -118,7 +118,7 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     env: &'a MoveDataParamEnv<'tcx>,\n     flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n     flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n-    drop_flags: FnvHashMap<MovePathIndex, Temp>,\n+    drop_flags: FnvHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }\n \n@@ -164,7 +164,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flag(&mut self, index: MovePathIndex) -> Option<Lvalue<'tcx>> {\n-        self.drop_flags.get(&index).map(|t| Lvalue::Temp(*t))\n+        self.drop_flags.get(&index).map(|t| Lvalue::Local(*t))\n     }\n \n     /// create a patch that elaborates all drops in the input\n@@ -847,14 +847,14 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             statements.push(Statement {\n                 source_info: c.source_info,\n                 kind: StatementKind::Assign(\n-                    Lvalue::Temp(flag),\n+                    Lvalue::Local(flag),\n                     self.constant_bool(c.source_info.span, false)\n                 )\n             });\n         }\n \n         let tcx = self.tcx;\n-        let unit_temp = Lvalue::Temp(self.patch.new_temp(tcx.mk_nil()));\n+        let unit_temp = Lvalue::Local(self.patch.new_temp(tcx.mk_nil()));\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n         let substs = Substs::new(tcx, iter::once(Kind::from(ty)));\n@@ -917,7 +917,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         if let Some(&flag) = self.drop_flags.get(&path) {\n             let span = self.patch.source_info_for_location(self.mir, loc).span;\n             let val = self.constant_bool(span, val.value());\n-            self.patch.add_assign(loc, Lvalue::Temp(flag), val);\n+            self.patch.add_assign(loc, Lvalue::Local(flag), val);\n         }\n     }\n \n@@ -926,7 +926,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let span = self.patch.source_info_for_location(self.mir, loc).span;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n-            self.patch.add_assign(loc, Lvalue::Temp(*flag), false_.clone());\n+            self.patch.add_assign(loc, Lvalue::Local(*flag), false_.clone());\n         }\n     }\n "}, {"sha": "16e25d2b7725810c6bfa3f8086f5f819e995ab22", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 5, "deletions": 35, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -173,13 +173,7 @@ impl fmt::Debug for MoveOut {\n /// Tables mapping from an l-value to its MovePathIndex.\n #[derive(Debug)]\n pub struct MovePathLookup<'tcx> {\n-    vars: IndexVec<Var, MovePathIndex>,\n-    temps: IndexVec<Temp, MovePathIndex>,\n-    args: IndexVec<Arg, MovePathIndex>,\n-\n-    /// The move path representing the return value is constructed\n-    /// lazily when we first encounter it in the input MIR.\n-    return_ptr: Option<MovePathIndex>,\n+    locals: IndexVec<Local, MovePathIndex>,\n \n     /// projections are made from a base-lvalue and a projection\n     /// elem. The base-lvalue will have a unique MovePathIndex; we use\n@@ -218,16 +212,9 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 moves: IndexVec::new(),\n                 loc_map: LocationMap::new(mir),\n                 rev_lookup: MovePathLookup {\n-                    vars: mir.var_decls.indices().map(Lvalue::Var).map(|v| {\n+                    locals: mir.local_decls.indices().map(Lvalue::Local).map(|v| {\n                         Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n                     }).collect(),\n-                    temps: mir.temp_decls.indices().map(Lvalue::Temp).map(|t| {\n-                        Self::new_move_path(&mut move_paths, &mut path_map, None, t)\n-                    }).collect(),\n-                    args: mir.arg_decls.indices().map(Lvalue::Arg).map(|a| {\n-                        Self::new_move_path(&mut move_paths, &mut path_map, None, a)\n-                    }).collect(),\n-                    return_ptr: None,\n                     projections: FnvHashMap(),\n                 },\n                 move_paths: move_paths,\n@@ -272,23 +259,9 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     {\n         debug!(\"lookup({:?})\", lval);\n         match *lval {\n-            Lvalue::Var(var) => Ok(self.data.rev_lookup.vars[var]),\n-            Lvalue::Arg(arg) => Ok(self.data.rev_lookup.args[arg]),\n-            Lvalue::Temp(temp) => Ok(self.data.rev_lookup.temps[temp]),\n+            Lvalue::Local(local) => Ok(self.data.rev_lookup.locals[local]),\n             // error: can't move out of a static\n             Lvalue::Static(..) => Err(MovePathError::IllegalMove),\n-            Lvalue::ReturnPointer => match self.data.rev_lookup.return_ptr {\n-                Some(ptr) => Ok(ptr),\n-                ref mut ptr @ None => {\n-                    let path = Self::new_move_path(\n-                        &mut self.data.move_paths,\n-                        &mut self.data.path_map,\n-                        None,\n-                        lval.clone());\n-                    *ptr = Some(path);\n-                    Ok(path)\n-                }\n-            },\n             Lvalue::Projection(ref proj) => {\n                 self.move_path_for_projection(lval, proj)\n             }\n@@ -373,11 +346,8 @@ impl<'tcx> MovePathLookup<'tcx> {\n     // parent.\n     pub fn find(&self, lval: &Lvalue<'tcx>) -> LookupResult {\n         match *lval {\n-            Lvalue::Var(var) => LookupResult::Exact(self.vars[var]),\n-            Lvalue::Temp(temp) => LookupResult::Exact(self.temps[temp]),\n-            Lvalue::Arg(arg) => LookupResult::Exact(self.args[arg]),\n+            Lvalue::Local(local) => LookupResult::Exact(self.locals[local]),\n             Lvalue::Static(..) => LookupResult::Parent(None),\n-            Lvalue::ReturnPointer => LookupResult::Exact(self.return_ptr.unwrap()),\n             Lvalue::Projection(ref proj) => {\n                 match self.find(&proj.base) {\n                     LookupResult::Exact(base_path) => {\n@@ -486,7 +456,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n-                self.gather_move(loc, &Lvalue::ReturnPointer);\n+                self.gather_move(loc, &Lvalue::Local(RETURN_POINTER));\n             }\n \n             TerminatorKind::If { .. } |"}, {"sha": "2a3c602b134e77074342603728aaa7558f0126e7", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -338,8 +338,8 @@ fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n     where F: FnMut(MovePathIndex, DropFlagState)\n {\n     let move_data = &ctxt.move_data;\n-    for (arg, _) in mir.arg_decls.iter_enumerated() {\n-        let lvalue = repr::Lvalue::Arg(arg);\n+    for arg in mir.args_iter() {\n+        let lvalue = repr::Lvalue::Local(arg);\n         let lookup_result = move_data.rev_lookup.find(&lvalue);\n         on_lookup_result_bits(tcx, mir, move_data,\n                               lookup_result,"}, {"sha": "5d018c98684e32870315574b771efd6c814bdb36", "filename": "src/librustc_borrowck/borrowck/mir/patch.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -19,19 +19,19 @@ pub struct MirPatch<'tcx> {\n     patch_map: IndexVec<BasicBlock, Option<TerminatorKind<'tcx>>>,\n     new_blocks: Vec<BasicBlockData<'tcx>>,\n     new_statements: Vec<(Location, StatementKind<'tcx>)>,\n-    new_temps: Vec<TempDecl<'tcx>>,\n+    new_locals: Vec<LocalDecl<'tcx>>,\n     resume_block: BasicBlock,\n-    next_temp: usize,\n+    next_local: usize,\n }\n \n impl<'tcx> MirPatch<'tcx> {\n     pub fn new(mir: &Mir<'tcx>) -> Self {\n         let mut result = MirPatch {\n             patch_map: IndexVec::from_elem(None, mir.basic_blocks()),\n             new_blocks: vec![],\n-            new_temps: vec![],\n             new_statements: vec![],\n-            next_temp: mir.temp_decls.len(),\n+            new_locals: vec![],\n+            next_local: mir.local_decls.len(),\n             resume_block: START_BLOCK\n         };\n \n@@ -92,11 +92,11 @@ impl<'tcx> MirPatch<'tcx> {\n         }\n     }\n \n-    pub fn new_temp(&mut self, ty: Ty<'tcx>) -> Temp {\n-        let index = self.next_temp;\n-        self.next_temp += 1;\n-        self.new_temps.push(TempDecl { ty: ty });\n-        Temp::new(index as usize)\n+    pub fn new_temp(&mut self, ty: Ty<'tcx>) -> Local {\n+        let index = self.next_local;\n+        self.next_local += 1;\n+        self.new_locals.push(LocalDecl::new_temp(ty));\n+        Local::new(index as usize)\n     }\n \n     pub fn new_block(&mut self, data: BasicBlockData<'tcx>) -> BasicBlock {\n@@ -124,11 +124,11 @@ impl<'tcx> MirPatch<'tcx> {\n \n     pub fn apply(self, mir: &mut Mir<'tcx>) {\n         debug!(\"MirPatch: {:?} new temps, starting from index {}: {:?}\",\n-               self.new_temps.len(), mir.temp_decls.len(), self.new_temps);\n+               self.new_locals.len(), mir.local_decls.len(), self.new_locals);\n         debug!(\"MirPatch: {} new blocks, starting from index {}\",\n                self.new_blocks.len(), mir.basic_blocks().len());\n         mir.basic_blocks_mut().extend(self.new_blocks);\n-        mir.temp_decls.extend(self.new_temps);\n+        mir.local_decls.extend(self.new_locals);\n         for (src, patch) in self.patch_map.into_iter_enumerated() {\n             if let Some(patch) = patch {\n                 debug!(\"MirPatch: patching block {:?}\", src);"}, {"sha": "a9dfc6ea651e411499c584d392518a5b6b7d7233", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -77,11 +77,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 success.and(slice.index(idx))\n             }\n             ExprKind::SelfRef => {\n-                block.and(Lvalue::Arg(Arg::new(0)))\n+                block.and(Lvalue::Local(Local::new(1)))\n             }\n             ExprKind::VarRef { id } => {\n                 let index = this.var_indices[&id];\n-                block.and(Lvalue::Var(index))\n+                block.and(Lvalue::Local(index))\n             }\n             ExprKind::StaticRef { id } => {\n                 block.and(Lvalue::Static(id))"}, {"sha": "9448527e6e65f0b9d21cc42084641be7faaf8d3f", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -90,9 +90,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Return { value } => {\n                 block = match value {\n-                    Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n+                    Some(value) => {\n+                        unpack!(this.into(&Lvalue::Local(RETURN_POINTER), block, value))\n+                    }\n                     None => {\n-                        this.cfg.push_assign_unit(block, source_info, &Lvalue::ReturnPointer);\n+                        this.cfg.push_assign_unit(block,\n+                                                  source_info,\n+                                                  &Lvalue::Local(RETURN_POINTER));\n                         block\n                     }\n                 };"}, {"sha": "a9ea82140b536eaf4b985bccba170057bd14aa88", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                    var,\n                                    subpattern: None, .. } => {\n                 self.storage_live_for_bindings(block, &irrefutable_pat);\n-                let lvalue = Lvalue::Var(self.var_indices[&var]);\n+                let lvalue = Lvalue::Local(self.var_indices[&var]);\n                 return self.into(&lvalue, block, initializer);\n             }\n             _ => {}\n@@ -214,7 +214,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      pattern: &Pattern<'tcx>) {\n         match *pattern.kind {\n             PatternKind::Binding { var, ref subpattern, .. } => {\n-                let lvalue = Lvalue::Var(self.var_indices[&var]);\n+                let lvalue = Lvalue::Local(self.var_indices[&var]);\n                 let source_info = self.source_info(pattern.span);\n                 self.cfg.push(block, Statement {\n                     source_info: source_info,\n@@ -705,10 +705,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let source_info = self.source_info(binding.span);\n             self.cfg.push(block, Statement {\n                 source_info: source_info,\n-                kind: StatementKind::StorageLive(Lvalue::Var(var_index))\n+                kind: StatementKind::StorageLive(Lvalue::Local(var_index))\n             });\n             self.cfg.push_assign(block, source_info,\n-                                 &Lvalue::Var(var_index), rvalue);\n+                                 &Lvalue::Local(var_index), rvalue);\n         }\n     }\n \n@@ -718,19 +718,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        name: Name,\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>)\n-                       -> Var\n+                       -> Local\n     {\n         debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, source_info={:?})\",\n                var_id, name, var_ty, source_info);\n \n-        let var = self.var_decls.push(VarDecl::<'tcx> {\n-            source_info: source_info,\n+        let var = self.local_decls.push(LocalDecl::<'tcx> {\n             mutability: mutability,\n-            name: name,\n             ty: var_ty.clone(),\n+            name: Some(name),\n+            source_info: Some(source_info),\n         });\n         let extent = self.extent_of_innermost_scope();\n-        self.schedule_drop(source_info.span, extent, &Lvalue::Var(var), var_ty);\n+        self.schedule_drop(source_info.span, extent, &Lvalue::Local(var), var_ty);\n         self.var_indices.insert(var_id, var);\n \n         debug!(\"declare_binding: var={:?}\", var);"}, {"sha": "4bc51c3a6252db89c3b1fccadafdf871273ddcaa", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -28,10 +28,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// NB: **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n     pub fn temp(&mut self, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n-        let temp = self.temp_decls.push(TempDecl { ty: ty });\n-        let lvalue = Lvalue::Temp(temp);\n+        let temp = self.local_decls.push(LocalDecl::new_temp(ty));\n+        let lvalue = Lvalue::Local(temp);\n         debug!(\"temp: created temp {:?} with type {:?}\",\n-               lvalue, self.temp_decls[temp].ty);\n+               lvalue, self.local_decls[temp].ty);\n         lvalue\n     }\n "}, {"sha": "353aaaa45e18bed2d9f9bc9c9794ac37404edf55", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 63, "deletions": 49, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -28,6 +28,7 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     cfg: CFG<'tcx>,\n \n     fn_span: Span,\n+    arg_count: usize,\n \n     /// the current set of scopes, updated as we traverse;\n     /// see the `scope` module for more details\n@@ -49,9 +50,9 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n     visibility_scope: VisibilityScope,\n \n-    var_decls: IndexVec<Var, VarDecl<'tcx>>,\n-    var_indices: NodeMap<Var>,\n-    temp_decls: IndexVec<Temp, TempDecl<'tcx>>,\n+    /// Maps node ids of variable bindings to the `Local`s created for them.\n+    var_indices: NodeMap<Local>,\n+    local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     unit_temp: Option<Lvalue<'tcx>>,\n \n     /// cached block with the RESUME terminator; this is created\n@@ -157,9 +158,11 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec)\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n+    let arguments: Vec<_> = arguments.collect();\n+\n     let tcx = hir.tcx();\n     let span = tcx.map.span(fn_id);\n-    let mut builder = Builder::new(hir, span);\n+    let mut builder = Builder::new(hir, span, arguments.len(), return_ty);\n \n     let body_id = ast_block.id;\n     let call_site_extent =\n@@ -169,9 +172,9 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         tcx.region_maps.lookup_code_extent(\n             CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n     let mut block = START_BLOCK;\n-    let mut arg_decls = unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n-        let arg_decls = unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n-            builder.args_and_body(block, return_ty, arguments, arg_extent, ast_block)\n+    unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n+        unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n+            builder.args_and_body(block, return_ty, &arguments, arg_extent, ast_block)\n         }));\n \n         let source_info = builder.source_info(span);\n@@ -180,16 +183,15 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                               TerminatorKind::Goto { target: return_block });\n         builder.cfg.terminate(return_block, source_info,\n                               TerminatorKind::Return);\n-        return_block.and(arg_decls)\n+        return_block.unit()\n     }));\n     assert_eq!(block, builder.return_block());\n \n+    let mut spread_arg = None;\n     match tcx.node_id_to_type(fn_id).sty {\n         ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n             // RustCall pseudo-ABI untuples the last argument.\n-            if let Some(last_arg) = arg_decls.last() {\n-                arg_decls[last_arg].spread = true;\n-            }\n+            spread_arg = Some(Local::new(arguments.len()));\n         }\n         _ => {}\n     }\n@@ -218,23 +220,26 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         }).collect()\n     });\n \n-    builder.finish(upvar_decls, arg_decls, return_ty)\n+    let (mut mir, aux) = builder.finish(upvar_decls, return_ty);\n+    mir.spread_arg = spread_arg;\n+    (mir, aux)\n }\n \n pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        item_id: ast::NodeId,\n                                        ast_expr: &'tcx hir::Expr)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n     let tcx = hir.tcx();\n+    let ty = tcx.expr_ty_adjusted(ast_expr);\n     let span = tcx.map.span(item_id);\n-    let mut builder = Builder::new(hir, span);\n+    let mut builder = Builder::new(hir, span, 0, ty);\n \n     let extent = tcx.region_maps.temporary_scope(ast_expr.id)\n                     .unwrap_or(ROOT_CODE_EXTENT);\n     let mut block = START_BLOCK;\n     let _ = builder.in_scope(extent, block, |builder| {\n         let expr = builder.hir.mirror(ast_expr);\n-        unpack!(block = builder.into(&Lvalue::ReturnPointer, block, expr));\n+        unpack!(block = builder.into(&Lvalue::Local(RETURN_POINTER), block, expr));\n \n         let source_info = builder.source_info(span);\n         let return_block = builder.return_block();\n@@ -246,23 +251,26 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n         return_block.unit()\n     });\n \n-    let ty = tcx.expr_ty_adjusted(ast_expr);\n-    builder.finish(vec![], IndexVec::new(), ty)\n+    builder.finish(vec![], ty)\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n-    fn new(hir: Cx<'a, 'gcx, 'tcx>, span: Span) -> Builder<'a, 'gcx, 'tcx> {\n+    fn new(hir: Cx<'a, 'gcx, 'tcx>,\n+           span: Span,\n+           arg_count: usize,\n+           return_ty: Ty<'tcx>)\n+           -> Builder<'a, 'gcx, 'tcx> {\n         let mut builder = Builder {\n             hir: hir,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,\n+            arg_count: arg_count,\n             scopes: vec![],\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n             scope_auxiliary: IndexVec::new(),\n             loop_scopes: vec![],\n-            temp_decls: IndexVec::new(),\n-            var_decls: IndexVec::new(),\n+            local_decls: IndexVec::from_elem_n(LocalDecl::new_return_pointer(return_ty), 1),\n             var_indices: NodeMap(),\n             unit_temp: None,\n             cached_resume_block: None,\n@@ -278,7 +286,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn finish(self,\n               upvar_decls: Vec<UpvarDecl>,\n-              arg_decls: IndexVec<Arg, ArgDecl<'tcx>>,\n               return_ty: Ty<'tcx>)\n               -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n@@ -291,27 +298,45 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                   self.visibility_scopes,\n                   IndexVec::new(),\n                   return_ty,\n-                  self.var_decls,\n-                  arg_decls,\n-                  self.temp_decls,\n+                  self.local_decls,\n+                  self.arg_count,\n                   upvar_decls,\n                   self.fn_span\n         ), self.scope_auxiliary)\n     }\n \n-    fn args_and_body<A>(&mut self,\n-                        mut block: BasicBlock,\n-                        return_ty: Ty<'tcx>,\n-                        arguments: A,\n-                        argument_extent: CodeExtent,\n-                        ast_block: &'gcx hir::Block)\n-                        -> BlockAnd<IndexVec<Arg, ArgDecl<'tcx>>>\n-        where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n+    fn args_and_body(&mut self,\n+                     mut block: BasicBlock,\n+                     return_ty: Ty<'tcx>,\n+                     arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n+                     argument_extent: CodeExtent,\n+                     ast_block: &'gcx hir::Block)\n+                     -> BlockAnd<()>\n     {\n-        // to start, translate the argument patterns and collect the argument types.\n+        // Allocate locals for the function arguments\n+        for &(ty, pattern) in arguments.iter() {\n+            // If this is a simple binding pattern, give the local a nice name for debuginfo.\n+            let mut name = None;\n+            if let Some(pat) = pattern {\n+                if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n+                    name = Some(ident.node);\n+                }\n+            }\n+\n+            self.local_decls.push(LocalDecl {\n+                mutability: Mutability::Not,\n+                ty: ty,\n+                source_info: None,\n+                name: name,\n+            });\n+        }\n+\n         let mut scope = None;\n-        let arg_decls = arguments.enumerate().map(|(index, (ty, pattern))| {\n-            let lvalue = Lvalue::Arg(Arg::new(index));\n+        // Bind the argument patterns\n+        for (index, &(ty, pattern)) in arguments.iter().enumerate() {\n+            // Function arguments always get the first Local indices after the return pointer\n+            let lvalue = Lvalue::Local(Local::new(index + 1));\n+\n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.irrefutable_pat(pattern);\n                 scope = self.declare_bindings(scope, ast_block.span, &pattern);\n@@ -322,19 +347,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n                                argument_extent, &lvalue, ty);\n \n-            let mut name = keywords::Invalid.name();\n-            if let Some(pat) = pattern {\n-                if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n-                    name = ident.node;\n-                }\n-            }\n-\n-            ArgDecl {\n-                ty: ty,\n-                spread: false,\n-                debug_name: name\n-            }\n-        }).collect();\n+        }\n \n         // Enter the argument pattern bindings visibility scope, if it exists.\n         if let Some(visibility_scope) = scope {\n@@ -344,9 +357,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // FIXME(#32959): temporary hack for the issue at hand\n         let return_is_unit = return_ty.is_nil();\n         // start the first basic block and translate the body\n-        unpack!(block = self.ast_block(&Lvalue::ReturnPointer, return_is_unit, block, ast_block));\n+        unpack!(block = self.ast_block(&Lvalue::Local(RETURN_POINTER),\n+                return_is_unit, block, ast_block));\n \n-        block.and(arg_decls)\n+        block.unit()\n     }\n \n     fn get_unit_temp(&mut self) -> Lvalue<'tcx> {"}, {"sha": "01cce3c7dd79474d2b2c55fc8a7091474f032dde", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -26,7 +26,7 @@ multiple-exit (SEME) region in the control-flow graph.\n For now, we keep a mapping from each `CodeExtent` to its\n corresponding SEME region for later reference (see caveat in next\n paragraph). This is because region scopes are tied to\n-them. Eventually, when we shift to non-lexical lifetimes, three should\n+them. Eventually, when we shift to non-lexical lifetimes, there should\n be no need to remember this mapping.\n \n There is one additional wrinkle, actually, that I wanted to hide from\n@@ -67,7 +67,7 @@ There are numerous \"normal\" ways to early exit a scope: `break`,\n early exit occurs, the method `exit_scope` is called. It is given the\n current point in execution where the early exit occurs, as well as the\n scope you want to branch to (note that all early exits from to some\n-other enclosing scope). `exit_scope` will record thid exit point and\n+other enclosing scope). `exit_scope` will record this exit point and\n also add all drops.\n \n Panics are handled in a similar fashion, except that a panic always\n@@ -322,7 +322,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.diverge_cleanup();\n         let scope = self.scopes.pop().unwrap();\n         assert_eq!(scope.extent, extent);\n-        unpack!(block = build_scope_drops(&mut self.cfg, &scope, &self.scopes, block));\n+        unpack!(block = build_scope_drops(&mut self.cfg,\n+                                          &scope,\n+                                          &self.scopes,\n+                                          block,\n+                                          self.arg_count));\n         self.scope_auxiliary[scope.id]\n             .postdoms\n             .push(self.cfg.current_location(block));\n@@ -362,7 +366,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 scope.cached_exits.insert((target, extent), b);\n                 b\n             };\n-            unpack!(block = build_scope_drops(&mut self.cfg, scope, rest, block));\n+            unpack!(block = build_scope_drops(&mut self.cfg,\n+                                              scope,\n+                                              rest,\n+                                              block,\n+                                              self.arg_count));\n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n                 let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n@@ -454,7 +462,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         } else {\n             // Only temps and vars need their storage dead.\n             match *lvalue {\n-                Lvalue::Temp(_) | Lvalue::Var(_) => DropKind::Storage,\n+                Lvalue::Local(index) if index.index() > self.arg_count => DropKind::Storage,\n                 _ => return\n             }\n         };\n@@ -671,7 +679,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n                            scope: &Scope<'tcx>,\n                            earlier_scopes: &[Scope<'tcx>],\n-                           mut block: BasicBlock)\n+                           mut block: BasicBlock,\n+                           arg_count: usize)\n                            -> BlockAnd<()> {\n     let mut iter = scope.drops.iter().rev().peekable();\n     while let Some(drop_data) = iter.next() {\n@@ -703,7 +712,7 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n             DropKind::Storage => {\n                 // Only temps and vars need their storage dead.\n                 match drop_data.location {\n-                    Lvalue::Temp(_) | Lvalue::Var(_) => {}\n+                    Lvalue::Local(index) if index.index() > arg_count => {}\n                     _ => continue\n                 }\n "}, {"sha": "343d802119ea0d8287c58aa22f1d26e5dbb5b38f", "filename": "src/librustc_mir/def_use.rs", "status": "modified", "additions": 13, "deletions": 47, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdef_use.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -12,13 +12,12 @@\n \n use rustc::mir::repr::{Local, Location, Lvalue, Mir};\n use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use std::marker::PhantomData;\n use std::mem;\n \n pub struct DefUseAnalysis<'tcx> {\n     info: IndexVec<Local, Info<'tcx>>,\n-    mir_summary: MirSummary,\n }\n \n #[derive(Clone)]\n@@ -35,15 +34,13 @@ pub struct Use<'tcx> {\n impl<'tcx> DefUseAnalysis<'tcx> {\n     pub fn new(mir: &Mir<'tcx>) -> DefUseAnalysis<'tcx> {\n         DefUseAnalysis {\n-            info: IndexVec::from_elem_n(Info::new(), mir.count_locals()),\n-            mir_summary: MirSummary::new(mir),\n+            info: IndexVec::from_elem_n(Info::new(), mir.local_decls.len()),\n         }\n     }\n \n     pub fn analyze(&mut self, mir: &Mir<'tcx>) {\n         let mut finder = DefUseFinder {\n             info: mem::replace(&mut self.info, IndexVec::new()),\n-            mir_summary: self.mir_summary,\n         };\n         finder.visit_mir(mir);\n         self.info = finder.info\n@@ -64,7 +61,6 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n         for lvalue_use in &self.info[local].defs_and_uses {\n             MutateUseVisitor::new(local,\n                                   &mut callback,\n-                                  self.mir_summary,\n                                   mir).visit_location(mir, lvalue_use.location)\n         }\n     }\n@@ -80,13 +76,17 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n \n struct DefUseFinder<'tcx> {\n     info: IndexVec<Local, Info<'tcx>>,\n-    mir_summary: MirSummary,\n }\n \n impl<'tcx> DefUseFinder<'tcx> {\n     fn lvalue_mut_info(&mut self, lvalue: &Lvalue<'tcx>) -> Option<&mut Info<'tcx>> {\n         let info = &mut self.info;\n-        self.mir_summary.local_index(lvalue).map(move |local| &mut info[local])\n+\n+        if let Lvalue::Local(local) = *lvalue {\n+            Some(&mut info[local])\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -132,18 +132,16 @@ impl<'tcx> Info<'tcx> {\n struct MutateUseVisitor<'tcx, F> {\n     query: Local,\n     callback: F,\n-    mir_summary: MirSummary,\n     phantom: PhantomData<&'tcx ()>,\n }\n \n impl<'tcx, F> MutateUseVisitor<'tcx, F> {\n-    fn new(query: Local, callback: F, mir_summary: MirSummary, _: &Mir<'tcx>)\n+    fn new(query: Local, callback: F, _: &Mir<'tcx>)\n            -> MutateUseVisitor<'tcx, F>\n            where F: for<'a> FnMut(&'a mut Lvalue<'tcx>, LvalueContext<'tcx>, Location) {\n         MutateUseVisitor {\n             query: query,\n             callback: callback,\n-            mir_summary: mir_summary,\n             phantom: PhantomData,\n         }\n     }\n@@ -155,43 +153,11 @@ impl<'tcx, F> MutVisitor<'tcx> for MutateUseVisitor<'tcx, F>\n                     lvalue: &mut Lvalue<'tcx>,\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n-        if self.mir_summary.local_index(lvalue) == Some(self.query) {\n-            (self.callback)(lvalue, context, location)\n-        }\n-        self.super_lvalue(lvalue, context, location)\n-    }\n-}\n-\n-/// A small structure that enables various metadata of the MIR to be queried\n-/// without a reference to the MIR itself.\n-#[derive(Clone, Copy)]\n-pub struct MirSummary {\n-    arg_count: usize,\n-    var_count: usize,\n-    temp_count: usize,\n-}\n-\n-impl MirSummary {\n-    pub fn new(mir: &Mir) -> MirSummary {\n-        MirSummary {\n-            arg_count: mir.arg_decls.len(),\n-            var_count: mir.var_decls.len(),\n-            temp_count: mir.temp_decls.len(),\n-        }\n-    }\n-\n-    pub fn local_index<'tcx>(&self, lvalue: &Lvalue<'tcx>) -> Option<Local> {\n-        match *lvalue {\n-            Lvalue::Arg(arg) => Some(Local::new(arg.index())),\n-            Lvalue::Var(var) => Some(Local::new(var.index() + self.arg_count)),\n-            Lvalue::Temp(temp) => {\n-                Some(Local::new(temp.index() + self.arg_count + self.var_count))\n+        if let Lvalue::Local(local) = *lvalue {\n+            if local == self.query {\n+                (self.callback)(lvalue, context, location)\n             }\n-            Lvalue::ReturnPointer => {\n-                Some(Local::new(self.arg_count + self.var_count + self.temp_count))\n-            }\n-            _ => None,\n         }\n+        self.super_lvalue(lvalue, context, location)\n     }\n }\n-"}, {"sha": "1c1f0ca790267fe5b66f43c21e74d115a9caf3ef", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -136,30 +136,31 @@ fn write_graph_label<'a, 'tcx, W: Write>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.node_path_str(nid)))?;\n \n     // fn argument types.\n-    for (i, arg) in mir.arg_decls.iter().enumerate() {\n+    for (i, arg) in mir.args_iter().enumerate() {\n         if i > 0 {\n             write!(w, \", \")?;\n         }\n-        write!(w, \"{:?}: {}\", Lvalue::Arg(Arg::new(i)), escape(&arg.ty))?;\n+        write!(w, \"{:?}: {}\", Lvalue::Local(arg), escape(&mir.local_decls[arg].ty))?;\n     }\n \n     write!(w, \") -&gt; {}\", escape(mir.return_ty))?;\n     write!(w, r#\"<br align=\"left\"/>\"#)?;\n \n-    // User variable types (including the user's name in a comment).\n-    for (i, var) in mir.var_decls.iter().enumerate() {\n+    for local in mir.vars_and_temps_iter() {\n+        let decl = &mir.local_decls[local];\n+\n         write!(w, \"let \")?;\n-        if var.mutability == Mutability::Mut {\n+        if decl.mutability == Mutability::Mut {\n             write!(w, \"mut \")?;\n         }\n-        write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n-               Lvalue::Var(Var::new(i)), escape(&var.ty), var.name)?;\n-    }\n \n-    // Compiler-introduced temporary types.\n-    for (i, temp) in mir.temp_decls.iter().enumerate() {\n-        write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n-               Lvalue::Temp(Temp::new(i)), escape(&temp.ty))?;\n+        if let Some(name) = decl.name {\n+            write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n+                   Lvalue::Local(local), escape(&decl.ty), name)?;\n+        } else {\n+            write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n+                   Lvalue::Local(local), escape(&decl.ty))?;\n+        }\n     }\n \n     writeln!(w, \">;\")"}, {"sha": "5c88c89862126be6060d6e87a777087259f43a33", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -214,6 +214,9 @@ fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n     format!(\"scope {} at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n }\n \n+/// Prints user-defined variables in a scope tree.\n+///\n+/// Returns the total number of variables printed.\n fn write_scope_tree(tcx: TyCtxt,\n                     mir: &Mir,\n                     scope_tree: &FnvHashMap<VisibilityScope, Vec<VisibilityScope>>,\n@@ -234,11 +237,14 @@ fn write_scope_tree(tcx: TyCtxt,\n         writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n \n         // User variable types (including the user's name in a comment).\n-        for (id, var) in mir.var_decls.iter_enumerated() {\n-            // Skip if not declared in this scope.\n-            if var.source_info.scope != child {\n+        for local in mir.vars_iter() {\n+            let var = &mir.local_decls[local];\n+            let (name, source_info) = if var.source_info.unwrap().scope == child {\n+                (var.name.unwrap(), var.source_info.unwrap())\n+            } else {\n+                // Not a variable or not declared in this scope.\n                 continue;\n-            }\n+            };\n \n             let mut_str = if var.mutability == Mutability::Mut {\n                 \"mut \"\n@@ -251,13 +257,13 @@ fn write_scope_tree(tcx: TyCtxt,\n                                        INDENT,\n                                        indent,\n                                        mut_str,\n-                                       id,\n+                                       local,\n                                        var.ty);\n             writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n                      indented_var,\n                      ALIGN,\n-                     var.name,\n-                     comment(tcx, var.source_info))?;\n+                     name,\n+                     comment(tcx, source_info))?;\n         }\n \n         write_scope_tree(tcx, mir, scope_tree, w, child, depth + 1)?;\n@@ -291,9 +297,23 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n+    // Print return pointer\n+    let indented_retptr = format!(\"{}let mut {:?}: {};\",\n+                                  INDENT,\n+                                  RETURN_POINTER,\n+                                  mir.return_ty);\n+    writeln!(w, \"{0:1$} // return pointer\",\n+             indented_retptr,\n+             ALIGN)?;\n+\n     write_scope_tree(tcx, mir, &scope_tree, w, ARGUMENT_VISIBILITY_SCOPE, 1)?;\n \n-    write_mir_decls(mir, w)\n+    write_temp_decls(mir, w)?;\n+\n+    // Add an empty line before the first block is printed.\n+    writeln!(w, \"\")?;\n+\n+    Ok(())\n }\n \n fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n@@ -313,29 +333,24 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n         write!(w, \"(\")?;\n \n         // fn argument types.\n-        for (i, arg) in mir.arg_decls.iter_enumerated() {\n-            if i.index() != 0 {\n+        for (i, arg) in mir.args_iter().enumerate() {\n+            if i != 0 {\n                 write!(w, \", \")?;\n             }\n-            write!(w, \"{:?}: {}\", Lvalue::Arg(i), arg.ty)?;\n+            write!(w, \"{:?}: {}\", Lvalue::Local(arg), mir.local_decls[arg].ty)?;\n         }\n \n         write!(w, \") -> {}\", mir.return_ty)\n     } else {\n-        assert!(mir.arg_decls.is_empty());\n+        assert_eq!(mir.arg_count, 0);\n         write!(w, \": {} =\", mir.return_ty)\n     }\n }\n \n-fn write_mir_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n+fn write_temp_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n     // Compiler-introduced temporary types.\n-    for (id, temp) in mir.temp_decls.iter_enumerated() {\n-        writeln!(w, \"{}let mut {:?}: {};\", INDENT, id, temp.ty)?;\n-    }\n-\n-    // Wrote any declaration? Add an empty line before the first block is printed.\n-    if !mir.var_decls.is_empty() || !mir.temp_decls.is_empty() {\n-        writeln!(w, \"\")?;\n+    for temp in mir.temps_iter() {\n+        writeln!(w, \"{}let mut {:?}: {};\", INDENT, temp, mir.local_decls[temp].ty)?;\n     }\n \n     Ok(())"}, {"sha": "783162cd5588fd90510ad4c7b6c008d57691b13e", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -29,12 +29,11 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use def_use::{DefUseAnalysis, MirSummary};\n+use def_use::DefUseAnalysis;\n use rustc::mir::repr::{Constant, Local, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::indexed_vec::Idx;\n use transform::qualify_consts;\n \n pub struct CopyPropagation;\n@@ -78,9 +77,8 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n             def_use_analysis.analyze(mir);\n \n             let mut changed = false;\n-            for dest_local_index in 0..mir.count_locals() {\n-                let dest_local = Local::new(dest_local_index);\n-                debug!(\"Considering destination local: {}\", mir.format_local(dest_local));\n+            for dest_local in mir.local_decls.indices() {\n+                debug!(\"Considering destination local: {:?}\", dest_local);\n \n                 let action;\n                 let location;\n@@ -89,19 +87,19 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     let dest_use_info = def_use_analysis.local_info(dest_local);\n                     let dest_def_count = dest_use_info.def_count_not_including_drop();\n                     if dest_def_count == 0 {\n-                        debug!(\"  Can't copy-propagate local: dest {} undefined\",\n-                               mir.format_local(dest_local));\n+                        debug!(\"  Can't copy-propagate local: dest {:?} undefined\",\n+                               dest_local);\n                         continue\n                     }\n                     if dest_def_count > 1 {\n-                        debug!(\"  Can't copy-propagate local: dest {} defined {} times\",\n-                               mir.format_local(dest_local),\n+                        debug!(\"  Can't copy-propagate local: dest {:?} defined {} times\",\n+                               dest_local,\n                                dest_use_info.def_count());\n                         continue\n                     }\n                     if dest_use_info.use_count() == 0 {\n-                        debug!(\"  Can't copy-propagate local: dest {} unused\",\n-                               mir.format_local(dest_local));\n+                        debug!(\"  Can't copy-propagate local: dest {:?} unused\",\n+                               dest_local);\n                         continue\n                     }\n                     let dest_lvalue_def = dest_use_info.defs_and_uses.iter().filter(|lvalue_def| {\n@@ -121,11 +119,11 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n \n                     // That use of the source must be an assignment.\n                     match statement.kind {\n-                        StatementKind::Assign(ref dest_lvalue, Rvalue::Use(ref operand)) if\n-                                Some(dest_local) == mir.local_index(dest_lvalue) => {\n+                        StatementKind::Assign(Lvalue::Local(local), Rvalue::Use(ref operand)) if\n+                                local == dest_local => {\n                             let maybe_action = match *operand {\n                                 Operand::Consume(ref src_lvalue) => {\n-                                    Action::local_copy(mir, &def_use_analysis, src_lvalue)\n+                                    Action::local_copy(&def_use_analysis, src_lvalue)\n                                 }\n                                 Operand::Constant(ref src_constant) => {\n                                     Action::constant(src_constant)\n@@ -162,15 +160,14 @@ enum Action<'tcx> {\n }\n \n impl<'tcx> Action<'tcx> {\n-    fn local_copy(mir: &Mir<'tcx>, def_use_analysis: &DefUseAnalysis, src_lvalue: &Lvalue<'tcx>)\n+    fn local_copy(def_use_analysis: &DefUseAnalysis, src_lvalue: &Lvalue<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n-        let src_local = match mir.local_index(src_lvalue) {\n-            Some(src_local) => src_local,\n-            None => {\n-                debug!(\"  Can't copy-propagate local: source is not a local\");\n-                return None\n-            }\n+        let src_local = if let Lvalue::Local(local) = *src_lvalue {\n+            local\n+        } else {\n+            debug!(\"  Can't copy-propagate local: source is not a local\");\n+            return None;\n         };\n \n         // We're trying to copy propagate a local.\n@@ -225,9 +222,9 @@ impl<'tcx> Action<'tcx> {\n                 // First, remove all markers.\n                 //\n                 // FIXME(pcwalton): Don't do this. Merge live ranges instead.\n-                debug!(\"  Replacing all uses of {} with {} (local)\",\n-                       mir.format_local(dest_local),\n-                       mir.format_local(src_local));\n+                debug!(\"  Replacing all uses of {:?} with {:?} (local)\",\n+                       dest_local,\n+                       src_local);\n                 for lvalue_use in &def_use_analysis.local_info(dest_local).defs_and_uses {\n                     if lvalue_use.context.is_storage_marker() {\n                         mir.make_statement_nop(lvalue_use.location)\n@@ -240,7 +237,7 @@ impl<'tcx> Action<'tcx> {\n                 }\n \n                 // Replace all uses of the destination local with the source local.\n-                let src_lvalue = Lvalue::from_local(mir, src_local);\n+                let src_lvalue = Lvalue::Local(src_local);\n                 def_use_analysis.replace_all_defs_and_uses_with(dest_local, mir, src_lvalue);\n \n                 // Finally, zap the now-useless assignment instruction.\n@@ -253,8 +250,8 @@ impl<'tcx> Action<'tcx> {\n                 // First, remove all markers.\n                 //\n                 // FIXME(pcwalton): Don't do this. Merge live ranges instead.\n-                debug!(\"  Replacing all uses of {} with {:?} (constant)\",\n-                       mir.format_local(dest_local),\n+                debug!(\"  Replacing all uses of {:?} with {:?} (constant)\",\n+                       dest_local,\n                        src_constant);\n                 let dest_local_info = def_use_analysis.local_info(dest_local);\n                 for lvalue_use in &dest_local_info.defs_and_uses {\n@@ -264,8 +261,7 @@ impl<'tcx> Action<'tcx> {\n                 }\n \n                 // Replace all uses of the destination local with the constant.\n-                let mut visitor = ConstantPropagationVisitor::new(MirSummary::new(mir),\n-                                                                  dest_local,\n+                let mut visitor = ConstantPropagationVisitor::new(dest_local,\n                                                                   src_constant);\n                 for dest_lvalue_use in &dest_local_info.defs_and_uses {\n                     visitor.visit_location(mir, dest_lvalue_use.location)\n@@ -298,17 +294,15 @@ impl<'tcx> Action<'tcx> {\n struct ConstantPropagationVisitor<'tcx> {\n     dest_local: Local,\n     constant: Constant<'tcx>,\n-    mir_summary: MirSummary,\n     uses_replaced: usize,\n }\n \n impl<'tcx> ConstantPropagationVisitor<'tcx> {\n-    fn new(mir_summary: MirSummary, dest_local: Local, constant: Constant<'tcx>)\n+    fn new(dest_local: Local, constant: Constant<'tcx>)\n            -> ConstantPropagationVisitor<'tcx> {\n         ConstantPropagationVisitor {\n             dest_local: dest_local,\n             constant: constant,\n-            mir_summary: mir_summary,\n             uses_replaced: 0,\n         }\n     }\n@@ -319,16 +313,11 @@ impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n         self.super_operand(operand, location);\n \n         match *operand {\n-            Operand::Consume(ref lvalue) => {\n-                if self.mir_summary.local_index(lvalue) != Some(self.dest_local) {\n-                    return\n-                }\n-            }\n-            Operand::Constant(_) => return,\n+            Operand::Consume(Lvalue::Local(local)) if local == self.dest_local => {}\n+            _ => return,\n         }\n \n         *operand = Operand::Constant(self.constant.clone());\n         self.uses_replaced += 1\n     }\n }\n-"}, {"sha": "b4159af6f071d8d64de0c6eb5d52a729543944f9", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -10,11 +10,12 @@\n \n //! Performs various peephole optimizations.\n \n-use rustc::mir::repr::{Location, Lvalue, Mir, Operand, ProjectionElem, Rvalue};\n+use rustc::mir::repr::{Location, Lvalue, Mir, Operand, ProjectionElem, Rvalue, Local};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::TyCtxt;\n use rustc::util::nodemap::FnvHashSet;\n+use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n \n pub struct InstCombine {\n@@ -61,7 +62,8 @@ impl<'tcx> MutVisitor<'tcx> for InstCombine {\n             debug!(\"Replacing `&*`: {:?}\", rvalue);\n             let new_lvalue = match *rvalue {\n                 Rvalue::Ref(_, _, Lvalue::Projection(ref mut projection)) => {\n-                    mem::replace(&mut projection.base, Lvalue::ReturnPointer)\n+                    // Replace with dummy\n+                    mem::replace(&mut projection.base, Lvalue::Local(Local::new(0)))\n                 }\n                 _ => bug!(\"Detected `&*` but didn't find `&*`!\"),\n             };\n@@ -107,4 +109,3 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n struct OptimizationList {\n     and_stars: FnvHashSet<Location>,\n }\n-"}, {"sha": "9afc97d1e319a1f2523dc98f664f7d581bd50972", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 48, "deletions": 33, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -30,6 +30,7 @@ use syntax_pos::Span;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n+use std::iter;\n use std::mem;\n use std::usize;\n \n@@ -74,15 +75,24 @@ pub enum Candidate {\n     ShuffleIndices(BasicBlock)\n }\n \n-struct TempCollector {\n-    temps: IndexVec<Temp, TempState>,\n-    span: Span\n+struct TempCollector<'tcx> {\n+    temps: IndexVec<Local, TempState>,\n+    span: Span,\n+    mir: &'tcx Mir<'tcx>,\n }\n \n-impl<'tcx> Visitor<'tcx> for TempCollector {\n-    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext, location: Location) {\n+impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n         self.super_lvalue(lvalue, context, location);\n-        if let Lvalue::Temp(index) = *lvalue {\n+        if let Lvalue::Local(index) = *lvalue {\n+            // We're only interested in temporaries\n+            if self.mir.local_kind(index) != LocalKind::Temp {\n+                return;\n+            }\n+\n             // Ignore drops, if the temp gets promoted,\n             // then it's constant and thus drop is noop.\n             // Storage live ranges are also irrelevant.\n@@ -126,10 +136,11 @@ impl<'tcx> Visitor<'tcx> for TempCollector {\n     }\n }\n \n-pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> IndexVec<Temp, TempState> {\n+pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> IndexVec<Local, TempState> {\n     let mut collector = TempCollector {\n-        temps: IndexVec::from_elem(TempState::Undefined, &mir.temp_decls),\n-        span: mir.span\n+        temps: IndexVec::from_elem(TempState::Undefined, &mir.local_decls),\n+        span: mir.span,\n+        mir: mir,\n     };\n     for (bb, data) in rpo {\n         collector.visit_basic_block_data(bb, data);\n@@ -140,7 +151,7 @@ pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> IndexVec<Temp, Te\n struct Promoter<'a, 'tcx: 'a> {\n     source: &'a mut Mir<'tcx>,\n     promoted: Mir<'tcx>,\n-    temps: &'a mut IndexVec<Temp, TempState>,\n+    temps: &'a mut IndexVec<Local, TempState>,\n \n     /// If true, all nested temps are also kept in the\n     /// source MIR, not moved to the promoted MIR.\n@@ -163,21 +174,21 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         })\n     }\n \n-    fn assign(&mut self, dest: Lvalue<'tcx>, rvalue: Rvalue<'tcx>, span: Span) {\n+    fn assign(&mut self, dest: Local, rvalue: Rvalue<'tcx>, span: Span) {\n         let last = self.promoted.basic_blocks().last().unwrap();\n         let data = &mut self.promoted[last];\n         data.statements.push(Statement {\n             source_info: SourceInfo {\n                 span: span,\n                 scope: ARGUMENT_VISIBILITY_SCOPE\n             },\n-            kind: StatementKind::Assign(dest, rvalue)\n+            kind: StatementKind::Assign(Lvalue::Local(dest), rvalue)\n         });\n     }\n \n     /// Copy the initialization of this temp to the\n     /// promoted MIR, recursing through temps.\n-    fn promote_temp(&mut self, temp: Temp) -> Temp {\n+    fn promote_temp(&mut self, temp: Local) -> Local {\n         let old_keep_original = self.keep_original;\n         let (bb, stmt_idx) = match self.temps[temp] {\n             TempState::Defined {\n@@ -259,20 +270,19 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             });\n         }\n \n-        let new_temp = self.promoted.temp_decls.push(TempDecl {\n-            ty: self.source.temp_decls[temp].ty\n-        });\n+        let new_temp = self.promoted.local_decls.push(\n+            LocalDecl::new_temp(self.source.local_decls[temp].ty));\n \n         // Inject the Rvalue or Call into the promoted MIR.\n         if stmt_idx < no_stmts {\n-            self.assign(Lvalue::Temp(new_temp), rvalue.unwrap(), source_info.span);\n+            self.assign(new_temp, rvalue.unwrap(), source_info.span);\n         } else {\n             let last = self.promoted.basic_blocks().last().unwrap();\n             let new_target = self.new_block();\n             let mut call = call.unwrap();\n             match call {\n                 TerminatorKind::Call { ref mut destination, ..}  => {\n-                    *destination = Some((Lvalue::Temp(new_temp), new_target));\n+                    *destination = Some((Lvalue::Local(new_temp), new_target));\n                 }\n                 _ => bug!()\n             }\n@@ -315,11 +325,12 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 }\n             }\n         };\n-        self.visit_rvalue(&mut rvalue, Location{\n+        self.visit_rvalue(&mut rvalue, Location {\n             block: BasicBlock::new(0),\n             statement_index: usize::MAX\n         });\n-        self.assign(Lvalue::ReturnPointer, rvalue, span);\n+\n+        self.assign(RETURN_POINTER, rvalue, span);\n         self.source.promoted.push(self.promoted);\n     }\n }\n@@ -330,16 +341,18 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n                     lvalue: &mut Lvalue<'tcx>,\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n-        if let Lvalue::Temp(ref mut temp) = *lvalue {\n-            *temp = self.promote_temp(*temp);\n+        if let Lvalue::Local(ref mut temp) = *lvalue {\n+            if self.source.local_kind(*temp) == LocalKind::Temp {\n+                *temp = self.promote_temp(*temp);\n+            }\n         }\n         self.super_lvalue(lvalue, context, location);\n     }\n }\n \n pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    mut temps: IndexVec<Temp, TempState>,\n+                                    mut temps: IndexVec<Local, TempState>,\n                                     candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested.\n     for candidate in candidates.into_iter().rev() {\n@@ -353,7 +366,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                                   \"expected assignment to promote\");\n                     }\n                 };\n-                if let Lvalue::Temp(index) = *dest {\n+                if let Lvalue::Local(index) = *dest {\n                     if temps[index] == TempState::PromotedOut {\n                         // Already promoted.\n                         continue;\n@@ -376,8 +389,10 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n             }\n         };\n \n+        // Declare return pointer local\n+        let initial_locals = iter::once(LocalDecl::new_return_pointer(ty)).collect();\n+\n         let mut promoter = Promoter {\n-            source: mir,\n             promoted: Mir::new(\n                 IndexVec::new(),\n                 Some(VisibilityScopeData {\n@@ -386,12 +401,12 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 }).into_iter().collect(),\n                 IndexVec::new(),\n                 ty,\n-                IndexVec::new(),\n-                IndexVec::new(),\n-                IndexVec::new(),\n+                initial_locals,\n+                0,\n                 vec![],\n                 span\n             ),\n+            source: mir,\n             temps: &mut temps,\n             keep_original: false\n         };\n@@ -400,21 +415,21 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n     }\n \n     // Eliminate assignments to, and drops of promoted temps.\n-    let promoted = |index: Temp| temps[index] == TempState::PromotedOut;\n+    let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n     for block in mir.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match statement.kind {\n-                StatementKind::Assign(Lvalue::Temp(index), _) |\n-                StatementKind::StorageLive(Lvalue::Temp(index)) |\n-                StatementKind::StorageDead(Lvalue::Temp(index)) => {\n+                StatementKind::Assign(Lvalue::Local(index), _) |\n+                StatementKind::StorageLive(Lvalue::Local(index)) |\n+                StatementKind::StorageDead(Lvalue::Local(index)) => {\n                     !promoted(index)\n                 }\n                 _ => true\n             }\n         });\n         let terminator = block.terminator_mut();\n         match terminator.kind {\n-            TerminatorKind::Drop { location: Lvalue::Temp(index), target, .. } => {\n+            TerminatorKind::Drop { location: Lvalue::Local(index), target, .. } => {\n                 if promoted(index) {\n                     terminator.kind = TerminatorKind::Goto {\n                         target: target"}, {"sha": "b00a88093d72655f5364a5c5f02daa12750d5fb2", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 59, "deletions": 39, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -143,11 +143,11 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     param_env: ty::ParameterEnvironment<'tcx>,\n     qualif_map: &'a mut DefIdMap<Qualif>,\n     mir_map: Option<&'a MirMap<'tcx>>,\n-    temp_qualif: IndexVec<Temp, Option<Qualif>>,\n+    temp_qualif: IndexVec<Local, Option<Qualif>>,\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n     const_fn_arg_vars: BitVector,\n-    temp_promotion_state: IndexVec<Temp, TempState>,\n+    temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n \n@@ -173,10 +173,10 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             param_env: param_env,\n             qualif_map: qualif_map,\n             mir_map: mir_map,\n-            temp_qualif: IndexVec::from_elem(None, &mir.temp_decls),\n+            temp_qualif: IndexVec::from_elem(None, &mir.local_decls),\n             return_qualif: None,\n             qualif: Qualif::empty(),\n-            const_fn_arg_vars: BitVector::new(mir.var_decls.len()),\n+            const_fn_arg_vars: BitVector::new(mir.local_decls.len()),\n             temp_promotion_state: temps,\n             promotion_candidates: vec![]\n         }\n@@ -332,22 +332,31 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n         // Only handle promotable temps in non-const functions.\n         if self.mode == Mode::Fn {\n-            if let Lvalue::Temp(index) = *dest {\n-                if self.temp_promotion_state[index].is_promotable() {\n+            if let Lvalue::Local(index) = *dest {\n+                if self.mir.local_kind(index) == LocalKind::Temp\n+                && self.temp_promotion_state[index].is_promotable() {\n+                    debug!(\"store to promotable temp {:?}\", index);\n                     store(&mut self.temp_qualif[index]);\n                 }\n             }\n             return;\n         }\n \n         match *dest {\n-            Lvalue::Temp(index) => store(&mut self.temp_qualif[index]),\n-            Lvalue::ReturnPointer => store(&mut self.return_qualif),\n+            Lvalue::Local(index) if self.mir.local_kind(index) == LocalKind::Temp => {\n+                debug!(\"store to temp {:?}\", index);\n+                store(&mut self.temp_qualif[index])\n+            }\n+            Lvalue::Local(index) if self.mir.local_kind(index) == LocalKind::ReturnPointer => {\n+                debug!(\"store to return pointer {:?}\", index);\n+                store(&mut self.return_qualif)\n+            }\n \n             Lvalue::Projection(box Projection {\n-                base: Lvalue::Temp(index),\n+                base: Lvalue::Local(index),\n                 elem: ProjectionElem::Deref\n-            }) if self.mir.temp_decls[index].ty.is_unique()\n+            }) if self.mir.local_kind(index) == LocalKind::Temp\n+               && self.mir.local_decls[index].ty.is_unique()\n                && self.temp_qualif[index].map_or(false, |qualif| {\n                     qualif.intersects(Qualif::NOT_CONST)\n                }) => {\n@@ -366,6 +375,8 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n     /// Qualify a whole const, static initializer or const fn.\n     fn qualify_const(&mut self) -> Qualif {\n+        debug!(\"qualifying {} {}\", self.mode, self.tcx.item_path_str(self.def_id));\n+\n         let mir = self.mir;\n \n         let mut seen_blocks = BitVector::new(mir.basic_blocks().len());\n@@ -399,7 +410,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 TerminatorKind::Return => {\n                     // Check for unused values. This usually means\n                     // there are extra statements in the AST.\n-                    for temp in mir.temp_decls.indices() {\n+                    for temp in mir.temps_iter() {\n                         if self.temp_qualif[temp].is_none() {\n                             continue;\n                         }\n@@ -424,9 +435,10 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n                     // Make sure there are no extra unassigned variables.\n                     self.qualif = Qualif::NOT_CONST;\n-                    for index in 0..mir.var_decls.len() {\n-                        if !self.const_fn_arg_vars.contains(index) {\n-                            self.assign(&Lvalue::Var(Var::new(index)), Location {\n+                    for index in mir.vars_iter() {\n+                        if !self.const_fn_arg_vars.contains(index.index()) {\n+                            debug!(\"unassigned variable {:?}\", index);\n+                            self.assign(&Lvalue::Local(index), Location {\n                                 block: bb,\n                                 statement_index: usize::MAX,\n                             });\n@@ -480,23 +492,28 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n         match *lvalue {\n-            Lvalue::Arg(_) => {\n-                self.add(Qualif::FN_ARGUMENT);\n-            }\n-            Lvalue::Var(_) => {\n-                self.add(Qualif::NOT_CONST);\n-            }\n-            Lvalue::Temp(index) => {\n-                if !self.temp_promotion_state[index].is_promotable() {\n-                    self.add(Qualif::NOT_PROMOTABLE);\n+            Lvalue::Local(local) => match self.mir.local_kind(local) {\n+                LocalKind::ReturnPointer => {\n+                    self.not_const();\n+                }\n+                LocalKind::Arg => {\n+                    self.add(Qualif::FN_ARGUMENT);\n+                }\n+                LocalKind::Var => {\n+                    self.add(Qualif::NOT_CONST);\n                 }\n+                LocalKind::Temp => {\n+                    if !self.temp_promotion_state[local].is_promotable() {\n+                        self.add(Qualif::NOT_PROMOTABLE);\n+                    }\n \n-                if let Some(qualif) = self.temp_qualif[index] {\n-                    self.add(qualif);\n-                } else {\n-                    self.not_const();\n+                    if let Some(qualif) = self.temp_qualif[local] {\n+                        self.add(qualif);\n+                    } else {\n+                        self.not_const();\n+                    }\n                 }\n-            }\n+            },\n             Lvalue::Static(_) => {\n                 self.add(Qualif::STATIC);\n                 if self.mode == Mode::Const || self.mode == Mode::ConstFn {\n@@ -505,9 +522,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                a constant instead\", self.mode);\n                 }\n             }\n-            Lvalue::ReturnPointer => {\n-                self.not_const();\n-            }\n             Lvalue::Projection(ref proj) => {\n                 self.nest(|this| {\n                     this.super_lvalue(lvalue, context, location);\n@@ -685,8 +699,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 if self.mode == Mode::Fn || self.mode == Mode::ConstFn {\n                     if !self.qualif.intersects(Qualif::NEVER_PROMOTE) {\n                         // We can only promote direct borrows of temps.\n-                        if let Lvalue::Temp(_) = *lvalue {\n-                            self.promotion_candidates.push(candidate);\n+                        if let Lvalue::Local(local) = *lvalue {\n+                            if self.mir.local_kind(local) == LocalKind::Temp {\n+                                self.promotion_candidates.push(candidate);\n+                            }\n                         }\n                     }\n                 }\n@@ -879,17 +895,21 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         self.visit_rvalue(rvalue, location);\n \n         // Check the allowed const fn argument forms.\n-        if let (Mode::ConstFn, &Lvalue::Var(index)) = (self.mode, dest) {\n-            if self.const_fn_arg_vars.insert(index.index()) {\n+        if let (Mode::ConstFn, &Lvalue::Local(index)) = (self.mode, dest) {\n+            if self.mir.local_kind(index) == LocalKind::Var &&\n+               self.const_fn_arg_vars.insert(index.index()) {\n+\n                 // Direct use of an argument is permitted.\n-                if let Rvalue::Use(Operand::Consume(Lvalue::Arg(_))) = *rvalue {\n-                    return;\n+                if let Rvalue::Use(Operand::Consume(Lvalue::Local(local))) = *rvalue {\n+                    if self.mir.local_kind(local) == LocalKind::Arg {\n+                        return;\n+                    }\n                 }\n \n                 // Avoid a generic error for other uses of arguments.\n                 if self.qualif.intersects(Qualif::FN_ARGUMENT) {\n-                    let decl = &self.mir.var_decls[index];\n-                    span_err!(self.tcx.sess, decl.source_info.span, E0022,\n+                    let decl = &self.mir.local_decls[index];\n+                    span_err!(self.tcx.sess, decl.source_info.unwrap().span, E0022,\n                               \"arguments of constant functions can only \\\n                                be immutable by-value bindings\");\n                     return;"}, {"sha": "7a6822924295431230d4022c33797d0ab3453d1f", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -90,14 +90,8 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n         self.sanitize_type(&\"return type\", mir.return_ty);\n-        for var_decl in &mir.var_decls {\n-            self.sanitize_type(var_decl, var_decl.ty);\n-        }\n-        for (n, arg_decl) in mir.arg_decls.iter().enumerate() {\n-            self.sanitize_type(&(n, arg_decl), arg_decl.ty);\n-        }\n-        for (n, tmp_decl) in mir.temp_decls.iter().enumerate() {\n-            self.sanitize_type(&(n, tmp_decl), tmp_decl.ty);\n+        for local_decl in &mir.local_decls {\n+            self.sanitize_type(local_decl, local_decl.ty);\n         }\n         if self.errors_reported {\n             return;\n@@ -131,14 +125,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn sanitize_lvalue(&mut self, lvalue: &Lvalue<'tcx>, location: Location) -> LvalueTy<'tcx> {\n         debug!(\"sanitize_lvalue: {:?}\", lvalue);\n         match *lvalue {\n-            Lvalue::Var(index) => LvalueTy::Ty { ty: self.mir.var_decls[index].ty },\n-            Lvalue::Temp(index) => LvalueTy::Ty { ty: self.mir.temp_decls[index].ty },\n-            Lvalue::Arg(index) => LvalueTy::Ty { ty: self.mir.arg_decls[index].ty },\n+            Lvalue::Local(index) => LvalueTy::Ty { ty: self.mir.local_decls[index].ty },\n             Lvalue::Static(def_id) =>\n                 LvalueTy::Ty { ty: self.tcx().lookup_item_type(def_id).ty },\n-            Lvalue::ReturnPointer => {\n-                LvalueTy::Ty { ty: self.mir.return_ty }\n-            }\n             Lvalue::Projection(ref proj) => {\n                 let base_ty = self.sanitize_lvalue(&proj.base, location);\n                 if let LvalueTy::Ty { ty } = base_ty {\n@@ -380,9 +369,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             StatementKind::StorageLive(ref lv) |\n             StatementKind::StorageDead(ref lv) => {\n                 match *lv {\n-                    Lvalue::Temp(_) | Lvalue::Var(_) => {}\n+                    Lvalue::Local(_) => {}\n                     _ => {\n-                        span_mirbug!(self, stmt, \"bad lvalue: expected temp or var\");\n+                        span_mirbug!(self, stmt, \"bad lvalue: expected local\");\n                     }\n                 }\n             }\n@@ -711,6 +700,8 @@ impl TypeckMir {\n impl<'tcx> MirPass<'tcx> for TypeckMir {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     src: MirSource, mir: &mut Mir<'tcx>) {\n+        debug!(\"run_pass: {}\", tcx.node_path_str(src.item_id()));\n+\n         if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors."}, {"sha": "1d7e4991aa847e4566d77f4dc9bb23224cc5f889", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -63,8 +63,9 @@ pub fn create_mir_scopes(fcx: &FunctionContext) -> IndexVec<VisibilityScope, Mir\n \n     // Find all the scopes with variables defined in them.\n     let mut has_variables = BitVector::new(mir.visibility_scopes.len());\n-    for var in &mir.var_decls {\n-        has_variables.insert(var.source_info.scope.index());\n+    for var in mir.vars_iter() {\n+        let decl = &mir.local_decls[var];\n+        has_variables.insert(decl.source_info.unwrap().scope.index());\n     }\n \n     // Instantiate all scopes."}, {"sha": "455cf4eb455162c10f5a637de44a846157fdfdb8", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -20,7 +20,6 @@ use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use common::{self, Block, BlockAndBuilder};\n use glue;\n-use std::iter;\n use super::rvalue;\n \n pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n@@ -30,11 +29,7 @@ pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n \n     analyzer.visit_mir(mir);\n \n-    let local_types = mir.arg_decls.iter().map(|a| a.ty)\n-               .chain(mir.var_decls.iter().map(|v| v.ty))\n-               .chain(mir.temp_decls.iter().map(|t| t.ty))\n-               .chain(iter::once(mir.return_ty));\n-    for (index, ty) in local_types.enumerate() {\n+    for (index, ty) in mir.local_decls.iter().map(|l| l.ty).enumerate() {\n         let ty = bcx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n         if ty.is_scalar() ||\n@@ -80,12 +75,11 @@ impl<'mir, 'bcx, 'tcx> LocalAnalyzer<'mir, 'bcx, 'tcx> {\n     fn new(mir: &'mir mir::Mir<'tcx>,\n            bcx: &'mir BlockAndBuilder<'bcx, 'tcx>)\n            -> LocalAnalyzer<'mir, 'bcx, 'tcx> {\n-        let local_count = mir.count_locals();\n         LocalAnalyzer {\n             mir: mir,\n             bcx: bcx,\n-            lvalue_locals: BitVector::new(local_count),\n-            seen_assigned: BitVector::new(local_count)\n+            lvalue_locals: BitVector::new(mir.local_decls.len()),\n+            seen_assigned: BitVector::new(mir.local_decls.len())\n         }\n     }\n \n@@ -109,7 +103,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n                     location: Location) {\n         debug!(\"visit_assign(block={:?}, lvalue={:?}, rvalue={:?})\", block, lvalue, rvalue);\n \n-        if let Some(index) = self.mir.local_index(lvalue) {\n+        if let mir::Lvalue::Local(index) = *lvalue {\n             self.mark_assigned(index);\n             if !rvalue::rvalue_creates_operand(self.mir, self.bcx, rvalue) {\n                 self.mark_as_lvalue(index);\n@@ -153,7 +147,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n \n         // Allow uses of projections of immediate pair fields.\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            if self.mir.local_index(&proj.base).is_some() {\n+            if let mir::Lvalue::Local(_) = proj.base {\n                 let ty = proj.base.ty(self.mir, self.bcx.tcx());\n \n                 let ty = self.bcx.monomorphize(&ty.to_ty(self.bcx.tcx()));\n@@ -167,7 +161,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n             }\n         }\n \n-        if let Some(index) = self.mir.local_index(lvalue) {\n+        if let mir::Lvalue::Local(index) = *lvalue {\n             match context {\n                 LvalueContext::Call => {\n                     self.mark_assigned(index);"}, {"sha": "9e2d947c5e56342647bdeaaa9053275f07b65e45", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -192,8 +192,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n \n                 let llval = if let Some(cast_ty) = ret.cast {\n-                    let index = mir.local_index(&mir::Lvalue::ReturnPointer).unwrap();\n-                    let op = match self.locals[index] {\n+                    let op = match self.locals[mir::RETURN_POINTER] {\n                         LocalRef::Operand(Some(op)) => op,\n                         LocalRef::Operand(None) => bug!(\"use of return before def\"),\n                         LocalRef::Lvalue(tr_lvalue) => {\n@@ -218,7 +217,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                     load\n                 } else {\n-                    let op = self.trans_consume(&bcx, &mir::Lvalue::ReturnPointer);\n+                    let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n                     op.pack_if_pair(&bcx).immediate()\n                 };\n                 bcx.ret(llval);\n@@ -844,7 +843,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         if fn_ret_ty.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n-        let dest = if let Some(index) = self.mir.local_index(dest) {\n+        let dest = if let mir::Lvalue::Local(index) = *dest {\n             let ret_ty = self.monomorphized_lvalue_ty(dest);\n             match self.locals[index] {\n                 LocalRef::Lvalue(dest) => dest,"}, {"sha": "c0e7af845ec4f5c4b9d71902410bf3df9e1e6aa7", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -221,24 +221,25 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn new(ccx: &'a CrateContext<'a, 'tcx>,\n            mir: &'a mir::Mir<'tcx>,\n            substs: &'tcx Substs<'tcx>,\n-           args: IndexVec<mir::Arg, Const<'tcx>>)\n+           args: IndexVec<mir::Local, Const<'tcx>>)\n            -> MirConstContext<'a, 'tcx> {\n         let mut context = MirConstContext {\n             ccx: ccx,\n             mir: mir,\n             substs: substs,\n-            locals: (0..mir.count_locals()).map(|_| None).collect(),\n+            locals: (0..mir.local_decls.len()).map(|_| None).collect(),\n         };\n         for (i, arg) in args.into_iter().enumerate() {\n-            let index = mir.local_index(&mir::Lvalue::Arg(mir::Arg::new(i))).unwrap();\n+            // Locals after local 0 are the function arguments\n+            let index = mir::Local::new(i + 1);\n             context.locals[index] = Some(arg);\n         }\n         context\n     }\n \n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n                  mut instance: Instance<'tcx>,\n-                 args: IndexVec<mir::Arg, Const<'tcx>>)\n+                 args: IndexVec<mir::Local, Const<'tcx>>)\n                  -> Result<Const<'tcx>, ConstEvalErr> {\n         // Try to resolve associated constants.\n         if let Some(trait_id) = ccx.tcx().trait_of_item(instance.def) {\n@@ -311,8 +312,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 mir::TerminatorKind::Goto { target } => target,\n                 mir::TerminatorKind::Return => {\n                     failure?;\n-                    let index = self.mir.local_index(&mir::Lvalue::ReturnPointer).unwrap();\n-                    return Ok(self.locals[index].unwrap_or_else(|| {\n+                    return Ok(self.locals[mir::RETURN_POINTER].unwrap_or_else(|| {\n                         span_bug!(span, \"no returned value in constant\");\n                     }));\n                 }\n@@ -376,7 +376,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn store(&mut self, dest: &mir::Lvalue<'tcx>, value: Const<'tcx>, span: Span) {\n-        if let Some(index) = self.mir.local_index(dest) {\n+        if let mir::Lvalue::Local(index) = *dest {\n             self.locals[index] = Some(value);\n         } else {\n             span_bug!(span, \"assignment to {:?} in constant\", dest);\n@@ -387,17 +387,14 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     -> Result<ConstLvalue<'tcx>, ConstEvalErr> {\n         let tcx = self.ccx.tcx();\n \n-        if let Some(index) = self.mir.local_index(lvalue) {\n+        if let mir::Lvalue::Local(index) = *lvalue {\n             return Ok(self.locals[index].unwrap_or_else(|| {\n                 span_bug!(span, \"{:?} not initialized\", lvalue)\n             }).as_lvalue());\n         }\n \n         let lvalue = match *lvalue {\n-            mir::Lvalue::Var(_) |\n-            mir::Lvalue::Temp(_) |\n-            mir::Lvalue::Arg(_) |\n-            mir::Lvalue::ReturnPointer => bug!(), // handled above\n+            mir::Lvalue::Local(_)  => bug!(), // handled above\n             mir::Lvalue::Static(def_id) => {\n                 ConstLvalue {\n                     base: Base::Static(consts::get_static(self.ccx, def_id)),"}, {"sha": "7102bd81caf36e3d5243ab5a3014d11aa1650f6c", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -91,7 +91,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let ccx = bcx.ccx();\n         let tcx = bcx.tcx();\n \n-        if let Some(index) = self.mir.local_index(lvalue) {\n+        if let mir::Lvalue::Local(index) = *lvalue {\n             match self.locals[index] {\n                 LocalRef::Lvalue(lvalue) => {\n                     return lvalue;\n@@ -103,10 +103,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n \n         let result = match *lvalue {\n-            mir::Lvalue::Var(_) |\n-            mir::Lvalue::Temp(_) |\n-            mir::Lvalue::Arg(_) |\n-            mir::Lvalue::ReturnPointer => bug!(), // handled above\n+            mir::Lvalue::Local(_) => bug!(), // handled above\n             mir::Lvalue::Static(def_id) => {\n                 let const_ty = self.monomorphized_lvalue_ty(lvalue);\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id),\n@@ -235,7 +232,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                  lvalue: &mir::Lvalue<'tcx>, f: F) -> U\n     where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n     {\n-        if let Some(index) = self.mir.local_index(lvalue) {\n+        if let mir::Lvalue::Local(index) = *lvalue {\n             match self.locals[index] {\n                 LocalRef::Lvalue(lvalue) => f(self, lvalue),\n                 LocalRef::Operand(None) => {"}, {"sha": "fe71023ea34dea34dc16af6908eaee6cc12f5da6", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 55, "deletions": 44, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -237,51 +237,61 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     // Allocate variable and temp allocas\n     mircx.locals = {\n         let args = arg_local_refs(&bcx, &mir, &mircx.scopes, &lvalue_locals);\n-        let vars = mir.var_decls.iter().enumerate().map(|(i, decl)| {\n+\n+        let mut allocate_local = |local| {\n+            let decl = &mir.local_decls[local];\n             let ty = bcx.monomorphize(&decl.ty);\n-            let debug_scope = mircx.scopes[decl.source_info.scope];\n-            let dbg = debug_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo;\n \n-            let local = mir.local_index(&mir::Lvalue::Var(mir::Var::new(i))).unwrap();\n-            if !lvalue_locals.contains(local.index()) && !dbg {\n-                return LocalRef::new_operand(bcx.ccx(), ty);\n-            }\n+            if let Some(name) = decl.name {\n+                // User variable\n+                let source_info = decl.source_info.unwrap();\n+                let debug_scope = mircx.scopes[source_info.scope];\n+                let dbg = debug_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo;\n \n-            let lvalue = LvalueRef::alloca(&bcx, ty, &decl.name.as_str());\n-            if dbg {\n-                let dbg_loc = mircx.debug_loc(decl.source_info);\n-                if let DebugLoc::ScopeAt(scope, span) = dbg_loc {\n-                    bcx.with_block(|bcx| {\n-                        declare_local(bcx, decl.name, ty, scope,\n-                                    VariableAccess::DirectVariable { alloca: lvalue.llval },\n-                                    VariableKind::LocalVariable, span);\n-                    });\n-                } else {\n-                    panic!(\"Unexpected\");\n+                if !lvalue_locals.contains(local.index()) && !dbg {\n+                    debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n+                    return LocalRef::new_operand(bcx.ccx(), ty);\n                 }\n-            }\n-            LocalRef::Lvalue(lvalue)\n-        });\n-\n-        let locals = mir.temp_decls.iter().enumerate().map(|(i, decl)| {\n-            (mir::Lvalue::Temp(mir::Temp::new(i)), decl.ty)\n-        }).chain(iter::once((mir::Lvalue::ReturnPointer, mir.return_ty)));\n-\n-        args.into_iter().chain(vars).chain(locals.map(|(lvalue, ty)| {\n-            let ty = bcx.monomorphize(&ty);\n-            let local = mir.local_index(&lvalue).unwrap();\n-            if lvalue == mir::Lvalue::ReturnPointer && fcx.fn_ty.ret.is_indirect() {\n-                let llretptr = llvm::get_param(fcx.llfn, 0);\n-                LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty)))\n-            } else if lvalue_locals.contains(local.index()) {\n-                LocalRef::Lvalue(LvalueRef::alloca(&bcx, ty, &format!(\"{:?}\", lvalue)))\n+\n+                debug!(\"alloc: {:?} ({}) -> lvalue\", local, name);\n+                let lvalue = LvalueRef::alloca(&bcx, ty, &name.as_str());\n+                if dbg {\n+                    let dbg_loc = mircx.debug_loc(source_info);\n+                    if let DebugLoc::ScopeAt(scope, span) = dbg_loc {\n+                        bcx.with_block(|bcx| {\n+                            declare_local(bcx, name, ty, scope,\n+                                        VariableAccess::DirectVariable { alloca: lvalue.llval },\n+                                        VariableKind::LocalVariable, span);\n+                        });\n+                    } else {\n+                        panic!(\"Unexpected\");\n+                    }\n+                }\n+                LocalRef::Lvalue(lvalue)\n             } else {\n-                // If this is an immediate local, we do not create an\n-                // alloca in advance. Instead we wait until we see the\n-                // definition and update the operand there.\n-                LocalRef::new_operand(bcx.ccx(), ty)\n+                // Temporary or return pointer\n+                if local == mir::RETURN_POINTER && fcx.fn_ty.ret.is_indirect() {\n+                    debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n+                    let llretptr = llvm::get_param(fcx.llfn, 0);\n+                    LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty)))\n+                } else if lvalue_locals.contains(local.index()) {\n+                    debug!(\"alloc: {:?} -> lvalue\", local);\n+                    LocalRef::Lvalue(LvalueRef::alloca(&bcx, ty, &format!(\"{:?}\", local)))\n+                } else {\n+                    // If this is an immediate local, we do not create an\n+                    // alloca in advance. Instead we wait until we see the\n+                    // definition and update the operand there.\n+                    debug!(\"alloc: {:?} -> operand\", local);\n+                    LocalRef::new_operand(bcx.ccx(), ty)\n+                }\n             }\n-        })).collect()\n+        };\n+\n+        let retptr = allocate_local(mir::RETURN_POINTER);\n+        iter::once(retptr)\n+            .chain(args.into_iter())\n+            .chain(mir.vars_and_temps_iter().map(allocate_local))\n+            .collect()\n     };\n \n     // Branch to the START block\n@@ -346,10 +356,11 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n         None\n     };\n \n-    mir.arg_decls.iter().enumerate().map(|(arg_index, arg_decl)| {\n+    mir.args_iter().enumerate().map(|(arg_index, local)| {\n+        let arg_decl = &mir.local_decls[local];\n         let arg_ty = bcx.monomorphize(&arg_decl.ty);\n-        let local = mir.local_index(&mir::Lvalue::Arg(mir::Arg::new(arg_index))).unwrap();\n-        if arg_decl.spread {\n+\n+        if Some(local) == mir.spread_arg {\n             // This argument (e.g. the last argument in the \"rust-call\" ABI)\n             // is a tuple that was spread at the ABI level and now we have\n             // to reconstruct it into a tuple local variable, from multiple\n@@ -467,8 +478,8 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n         bcx.with_block(|bcx| arg_scope.map(|scope| {\n             // Is this a regular argument?\n             if arg_index > 0 || mir.upvar_decls.is_empty() {\n-                declare_local(bcx, arg_decl.debug_name, arg_ty, scope,\n-                              VariableAccess::DirectVariable { alloca: llval },\n+                declare_local(bcx, arg_decl.name.unwrap_or(keywords::Invalid.name()), arg_ty,\n+                              scope, VariableAccess::DirectVariable { alloca: llval },\n                               VariableKind::ArgumentVariable(arg_index + 1),\n                               bcx.fcx().span.unwrap_or(DUMMY_SP));\n                 return;"}, {"sha": "4f1ec40398ca97659d1bbcf2881a199981c82dcc", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -175,7 +175,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n         // watch out for locals that do not have an\n         // alloca; they are handled somewhat differently\n-        if let Some(index) = self.mir.local_index(lvalue) {\n+        if let mir::Lvalue::Local(index) = *lvalue {\n             match self.locals[index] {\n                 LocalRef::Operand(Some(o)) => {\n                     return o;\n@@ -191,7 +191,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n         // Moves out of pair fields are trivial.\n         if let &mir::Lvalue::Projection(ref proj) = lvalue {\n-            if let Some(index) = self.mir.local_index(&proj.base) {\n+            if let mir::Lvalue::Local(index) = proj.base {\n                 if let LocalRef::Operand(Some(o)) = self.locals[index] {\n                     match (o.val, &proj.elem) {\n                         (OperandValue::Pair(a, b),"}, {"sha": "3d6aad37ed571fd16a3960efdf17aafb66b46473", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -30,7 +30,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         debug_loc.apply(bcx.fcx());\n         match statement.kind {\n             mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                if let Some(index) = self.mir.local_index(lvalue) {\n+                if let mir::Lvalue::Local(index) = *lvalue {\n                     match self.locals[index] {\n                         LocalRef::Lvalue(tr_dest) => {\n                             self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n@@ -86,7 +86,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                               lvalue: &mir::Lvalue<'tcx>,\n                               intrinsic: base::Lifetime)\n                               -> BlockAndBuilder<'bcx, 'tcx> {\n-        if let Some(index) = self.mir.local_index(lvalue) {\n+        if let mir::Lvalue::Local(index) = *lvalue {\n             if let LocalRef::Lvalue(tr_lval) = self.locals[index] {\n                 intrinsic.call(&bcx, tr_lval.llval);\n             }"}, {"sha": "81f6cf309da50f3ee84e58a062dae5b6361d33f5", "filename": "src/test/codegen/lifetime_start_end.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -30,11 +30,11 @@ pub fn test() {\n // CHECK: [[S_b:%[0-9]+]] = bitcast %\"2.std::option::Option<i32>\"** %b to i8*\n // CHECK: call void @llvm.lifetime.start(i{{[0-9 ]+}}, i8* [[S_b]])\n \n-// CHECK: [[S_tmp2:%[0-9]+]] = bitcast %\"2.std::option::Option<i32>\"* %tmp2 to i8*\n-// CHECK: call void @llvm.lifetime.start(i{{[0-9 ]+}}, i8* [[S_tmp2]])\n+// CHECK: [[S__5:%[0-9]+]] = bitcast %\"2.std::option::Option<i32>\"* %_5 to i8*\n+// CHECK: call void @llvm.lifetime.start(i{{[0-9 ]+}}, i8* [[S__5]])\n \n-// CHECK: [[E_tmp2:%[0-9]+]] = bitcast %\"2.std::option::Option<i32>\"* %tmp2 to i8*\n-// CHECK: call void @llvm.lifetime.end(i{{[0-9 ]+}}, i8* [[E_tmp2]])\n+// CHECK: [[E__5:%[0-9]+]] = bitcast %\"2.std::option::Option<i32>\"* %_5 to i8*\n+// CHECK: call void @llvm.lifetime.end(i{{[0-9 ]+}}, i8* [[E__5]])\n \n // CHECK: [[E_b:%[0-9]+]] = bitcast %\"2.std::option::Option<i32>\"** %b to i8*\n // CHECK: call void @llvm.lifetime.end(i{{[0-9 ]+}}, i8* [[E_b]])"}, {"sha": "3304a66773ad2755c54e75ea169963aaaa6a8495", "filename": "src/test/mir-opt/deaggregator_test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -23,19 +23,19 @@ fn main() {}\n // END RUST SOURCE\n // START rustc.node13.Deaggregator.before.mir\n // bb0: {\n-//     var0 = arg0;                     // scope 0 at main.rs:8:8: 8:9\n-//     tmp0 = var0;                     // scope 1 at main.rs:9:14: 9:15\n-//     return = Baz { x: tmp0, y: const F32(0), z: const false }; // scope ...\n-//     goto -> bb1;                     // scope 1 at main.rs:8:1: 10:2\n+//     _2 = _1;\n+//     _3 = _2;\n+//     _0 = Baz { x: _3, y: const F32(0), z: const false };\n+//     goto -> bb1;\n // }\n // END rustc.node13.Deaggregator.before.mir\n // START rustc.node13.Deaggregator.after.mir\n // bb0: {\n-//     var0 = arg0;                     // scope 0 at main.rs:8:8: 8:9\n-//     tmp0 = var0;                     // scope 1 at main.rs:9:14: 9:15\n-//     (return.0: usize) = tmp0;        // scope 1 at main.rs:9:5: 9:34\n-//     (return.1: f32) = const F32(0);  // scope 1 at main.rs:9:5: 9:34\n-//     (return.2: bool) = const false;  // scope 1 at main.rs:9:5: 9:34\n-//     goto -> bb1;                     // scope 1 at main.rs:8:1: 10:2\n+//     _2 = _1;\n+//     _3 = _2;\n+//     (_0.0: usize) = _3;\n+//     (_0.1: f32) = const F32(0);\n+//     (_0.2: bool) = const false;\n+//     goto -> bb1;\n // }\n-// END rustc.node13.Deaggregator.after.mir\n\\ No newline at end of file\n+// END rustc.node13.Deaggregator.after.mir"}, {"sha": "a6f12886f5527aade58d19802e1f3f1d3cda066d", "filename": "src/test/mir-opt/deaggregator_test_enum.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -28,18 +28,18 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node10.Deaggregator.before.mir\n // bb0: {\n-//     var0 = arg0;                     // scope 0 at main.rs:7:8: 7:9\n-//     tmp0 = var0;                     // scope 1 at main.rs:8:19: 8:20\n-//     return = Baz::Foo { x: tmp0 };   // scope 1 at main.rs:8:5: 8:21\n-//     goto -> bb1;                     // scope 1 at main.rs:7:1: 9:2\n+//     _2 = _1;\n+//     _3 = _2;\n+//     _0 = Baz::Foo { x: _3 };\n+//     goto -> bb1;\n // }\n // END rustc.node10.Deaggregator.before.mir\n // START rustc.node10.Deaggregator.after.mir\n // bb0: {\n-//     var0 = arg0;                     // scope 0 at main.rs:7:8: 7:9\n-//     tmp0 = var0;                     // scope 1 at main.rs:8:19: 8:20\n-//     ((return as Foo).0: usize) = tmp0; // scope 1 at main.rs:8:5: 8:21\n-//     discriminant(return) = 1;         // scope 1 at main.rs:8:5: 8:21\n-//     goto -> bb1;                     // scope 1 at main.rs:7:1: 9:2\n+//     _2 = _1;\n+//     _3 = _2;\n+//     ((_0 as Foo).0: usize) = _3;\n+//     discriminant(_0) = 1;\n+//     goto -> bb1;\n // }\n-// END rustc.node10.Deaggregator.after.mir\n\\ No newline at end of file\n+// END rustc.node10.Deaggregator.after.mir"}, {"sha": "7239e32357b95eaba0e9622c2b7bdfdbf08e3abc", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -17,11 +17,11 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.SimplifyBranches.initial-before.mir\n // bb0: {\n-//     if(const false) -> [true: bb1, false: bb2]; // scope 0 at simplify_if.rs:12:5: 14:6\n+//     if(const false) -> [true: bb1, false: bb2];\n // }\n // END rustc.node4.SimplifyBranches.initial-before.mir\n // START rustc.node4.SimplifyBranches.initial-after.mir\n // bb0: {\n-//     goto -> bb2;                     // scope 0 at simplify_if.rs:12:5: 14:6\n+//     goto -> bb2;\n // }\n-// END rustc.node4.SimplifyBranches.initial-after.mir\n\\ No newline at end of file\n+// END rustc.node4.SimplifyBranches.initial-after.mir"}, {"sha": "3885b233fd296ddd79552cdad2c0edf8719f7ed9", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "patch": "@@ -21,27 +21,27 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.TypeckMir.before.mir\n //     bb0: {\n-//         StorageLive(var0);               // scope 0 at storage_ranges.rs:14:9: 14:10\n-//         var0 = const 0i32;               // scope 0 at storage_ranges.rs:14:13: 14:14\n-//         StorageLive(var1);               // scope 1 at storage_ranges.rs:16:13: 16:14\n-//         StorageLive(tmp1);               // scope 1 at storage_ranges.rs:16:18: 16:25\n-//         StorageLive(tmp2);               // scope 1 at storage_ranges.rs:16:23: 16:24\n-//         tmp2 = var0;                     // scope 1 at storage_ranges.rs:16:23: 16:24\n-//         tmp1 = std::option::Option<i32>::Some(tmp2,); // scope 1 at storage_ranges.rs:16:18: 16:25\n-//         var1 = &tmp1;                    // scope 1 at storage_ranges.rs:16:17: 16:25\n-//         StorageDead(tmp2);               // scope 1 at storage_ranges.rs:16:23: 16:24\n-//         tmp0 = ();                       // scope 2 at storage_ranges.rs:15:5: 17:6\n-//         StorageDead(tmp1);               // scope 1 at storage_ranges.rs:16:18: 16:25\n-//         StorageDead(var1);               // scope 1 at storage_ranges.rs:16:13: 16:14\n-//         StorageLive(var2);               // scope 1 at storage_ranges.rs:18:9: 18:10\n-//         var2 = const 1i32;               // scope 1 at storage_ranges.rs:18:13: 18:14\n-//         return = ();                     // scope 3 at storage_ranges.rs:13:11: 19:2\n-//         StorageDead(var2);               // scope 1 at storage_ranges.rs:18:9: 18:10\n-//         StorageDead(var0);               // scope 0 at storage_ranges.rs:14:9: 14:10\n-//         goto -> bb1;                     // scope 0 at storage_ranges.rs:13:1: 19:2\n+//         StorageLive(_1);\n+//         _1 = const 0i32;\n+//         StorageLive(_3);\n+//         StorageLive(_4);\n+//         StorageLive(_5);\n+//         _5 = _1;\n+//         _4 = std::option::Option<i32>::Some(_5,);\n+//         _3 = &_4;\n+//         StorageDead(_5);\n+//         _2 = ();\n+//         StorageDead(_4);\n+//         StorageDead(_3);\n+//         StorageLive(_6);\n+//         _6 = const 1i32;\n+//         _0 = ();\n+//         StorageDead(_6);\n+//         StorageDead(_1);\n+//         goto -> bb1;\n //     }\n //\n //     bb1: {\n-//         return;                          // scope 0 at storage_ranges.rs:13:1: 19:2\n+//         return;\n //     }\n // END rustc.node4.TypeckMir.before.mir"}]}