{"sha": "0528954c80631bcf4e816e8254135d1109292f4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1Mjg5NTRjODA2MzFiY2Y0ZTgxNmU4MjU0MTM1ZDExMDkyOTJmNGE=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-04-17T15:50:47Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-05-25T08:07:01Z"}, "message": "Group common printing code during constant pretty printing", "tree": {"sha": "42886f8466d424f29f7d1e482e0cff85df97fe4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42886f8466d424f29f7d1e482e0cff85df97fe4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0528954c80631bcf4e816e8254135d1109292f4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0528954c80631bcf4e816e8254135d1109292f4a", "html_url": "https://github.com/rust-lang/rust/commit/0528954c80631bcf4e816e8254135d1109292f4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0528954c80631bcf4e816e8254135d1109292f4a/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db652fcde4bfea48150ec54b315dd104ae0f4b59", "url": "https://api.github.com/repos/rust-lang/rust/commits/db652fcde4bfea48150ec54b315dd104ae0f4b59", "html_url": "https://github.com/rust-lang/rust/commit/db652fcde4bfea48150ec54b315dd104ae0f4b59"}], "stats": {"total": 129, "additions": 73, "deletions": 56}, "files": [{"sha": "6514017a3e74dddbcb12044eeb00437017502d60", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 73, "deletions": 56, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/0528954c80631bcf4e816e8254135d1109292f4a/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0528954c80631bcf4e816e8254135d1109292f4a/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=0528954c80631bcf4e816e8254135d1109292f4a", "patch": "@@ -1539,76 +1539,93 @@ define_print_and_forward_display! {\n \n     &'tcx ty::Const<'tcx> {\n         let u8 = cx.tcx().types.u8;\n-        match (self.val, &self.ty.sty) {\n-            (ConstValue::Unevaluated(did, substs), _) => {\n-                match cx.tcx().describe_def(did) {\n-                    | Some(Def::Static(_, _))\n-                    | Some(Def::Const(_))\n-                    | Some(Def::AssociatedConst(_)) => p!(write(\"{}\", cx.tcx().def_path_str(did))),\n-                    _ => p!(write(\"_\")),\n+        if let ty::FnDef(did, _) = self.ty.sty {\n+            p!(write(\"{}\", cx.tcx().def_path_str(did)));\n+            return Ok(cx);\n+        }\n+        if let ConstValue::Unevaluated(did, substs) = self.val {\n+            match cx.tcx().describe_def(did) {\n+                | Some(Def::Static(_, _))\n+                | Some(Def::Const(_, false))\n+                | Some(Def::AssociatedConst(_)) => p!(write(\"{}\", cx.tcx().def_path_str(did))),\n+                _ => p!(write(\"_\")),\n+            }\n+            return Ok(cx);\n+        }\n+        if let ConstValue::Infer(..) = self.val {\n+            p!(write(\"_: \"), print(self.ty));\n+            return Ok(cx);\n+        }\n+        if let ConstValue::Param(ParamConst { name, .. }) = self.val {\n+            p!(write(\"{}\", name));\n+            return Ok(cx);\n+        }\n+        if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = self.val {\n+            match self.ty.sty {\n+                ty::Bool => {\n+                    p!(write(\"{}\", if bits == 0 { \"false\" } else { \"true\" }));\n+                    return Ok(cx);\n+                },\n+                ty::Float(ast::FloatTy::F32) => {\n+                    p!(write(\"{}f32\", Single::from_bits(bits)));\n+                    return Ok(cx);\n+                },\n+                ty::Float(ast::FloatTy::F64) => {\n+                    p!(write(\"{}f64\", Double::from_bits(bits)));\n+                    return Ok(cx);\n+                },\n+                ty::Uint(ui) => {\n+                    p!(write(\"{}{}\", bits, ui));\n+                    return Ok(cx);\n+                },\n+                ty::Int(i) =>{\n+                    let ty = cx.tcx().lift_to_global(&self.ty).unwrap();\n+                    let size = cx.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n+                        .unwrap()\n+                        .size;\n+                    p!(write(\"{}{}\", sign_extend(bits, size) as i128, i));\n+                    return Ok(cx);\n+                },\n+                ty::Char => {\n+                    p!(write(\"{:?}\", ::std::char::from_u32(bits as u32).unwrap()));\n+                    return Ok(cx);\n                 }\n+                _ => {},\n             }\n-            (ConstValue::Infer(..), _) => p!(write(\"_: \"), print(self.ty)),\n-            (ConstValue::Param(ParamConst { name, .. }), _) => p!(write(\"{}\", name)),\n-            (ConstValue::Scalar(Scalar::Bits { bits: 0, .. }), ty::Bool) => p!(write(\"false\")),\n-            (ConstValue::Scalar(Scalar::Bits { bits: 1, .. }), ty::Bool) => p!(write(\"true\")),\n-            (ConstValue::Scalar(Scalar::Bits { bits, .. }), ty::Float(ast::FloatTy::F32)) =>\n-                p!(write(\n-                    \"{}f32\",\n-                    Single::from_bits(bits)\n-                )),\n-            (ConstValue::Scalar(Scalar::Bits { bits, .. }), ty::Float(ast::FloatTy::F64)) =>\n-                p!(write(\n-                    \"{}f64\",\n-                    Double::from_bits(bits)\n-                )),\n-            (ConstValue::Scalar(Scalar::Bits { bits, ..}), ty::Uint(ui)) =>\n-                p!(write(\"{}{}\", bits, ui)),\n-            (ConstValue::Scalar(Scalar::Bits { bits, ..}), ty::Int(i)) => {\n-                let ty = cx.tcx().lift_to_global(&self.ty).unwrap();\n-                let size = cx.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n-                    .unwrap()\n-                    .size;\n-                p!(write(\"{}{}\", sign_extend(bits, size) as i128, i))\n-            },\n-            (ConstValue::Scalar(Scalar::Bits { bits, ..}), ty::Char)\n-                => p!(write(\"{:?}\", ::std::char::from_u32(bits as u32).unwrap())),\n-            (_, ty::FnDef(did, _)) => p!(write(\"{}\", cx.tcx().def_path_str(*did))),\n-            (_, ty::Ref(_, ref_ty, _)) => match (self.val, &ref_ty.sty) {\n+        }\n+        if let ty::Ref(_, ref_ty, _) = self.ty.sty {\n+            let byte_str = match (self.val, &ref_ty.sty) {\n                 (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n                     let n = n.unwrap_usize(cx.tcx());\n-                    let slice = cx.tcx()\n+                    Some(cx.tcx()\n                         .alloc_map.lock()\n                         .unwrap_memory(ptr.alloc_id)\n-                        .get_bytes(&cx.tcx(), ptr, Size::from_bytes(n)).unwrap();\n-                    p!(write(\"b\\\"\"));\n-                    for &c in slice {\n-                        for e in std::ascii::escape_default(c) {\n-                            p!(write(\"{}\", e as char));\n-                        }\n-                    }\n-                    p!(write(\"\\\"\"));\n+                        .get_bytes(&cx.tcx(), ptr, Size::from_bytes(n)).unwrap())\n+                },\n+                (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n+                    Some(&data.bytes[start..end])\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Str) => {\n                     let slice = &data.bytes[start..end];\n                     let s = ::std::str::from_utf8(slice)\n                         .expect(\"non utf8 str from miri\");\n-                    p!(write(\"{:?}\", s))\n+                    p!(write(\"{:?}\", s));\n+                    return Ok(cx);\n                 },\n-                (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                    let slice = &data.bytes[start..end];\n-                    p!(write(\"b\\\"\"));\n-                    for &c in slice {\n-                        for e in std::ascii::escape_default(c) {\n-                            p!(write(\"{}\", e as char));\n-                        }\n+                _ => None,\n+            };\n+            if let Some(byte_str) = byte_str {\n+                p!(write(\"b\\\"\"));\n+                for &c in byte_str {\n+                    for e in std::ascii::escape_default(c) {\n+                        p!(write(\"{}\", e as char));\n                     }\n-                    p!(write(\"\\\"\"));\n-                },\n-                _ => p!(write(\"{:?} : \", self.val), print(self.ty)),\n-            },\n-            _ => p!(write(\"{:?} : \", self.val), print(self.ty)),\n+                }\n+                p!(write(\"\\\"\"));\n+                return Ok(cx);\n+            }\n         }\n+        p!(write(\"{:?} : \", self.val), print(self.ty));\n     }\n \n     ty::ParamTy {"}]}