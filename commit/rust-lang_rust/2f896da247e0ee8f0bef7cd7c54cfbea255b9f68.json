{"sha": "2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "node_id": "C_kwDOAAsO6NoAKDJmODk2ZGEyNDdlMGVlOGYwYmVmN2NkN2M1NGNmYmVhMjU1YjlmNjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-05T13:31:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-05T13:31:08Z"}, "message": "Auto merge of #112305 - lnicola:sync-from-ra, r=lnicola\n\n:arrow_up: rust-analyzer\n\nr? `@ghost`", "tree": {"sha": "b1fe3bce7a1da9e7c94f674715d3aae7337e00fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1fe3bce7a1da9e7c94f674715d3aae7337e00fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "html_url": "https://github.com/rust-lang/rust/commit/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7452822843cf461b56742f0fc648af35889a3070", "url": "https://api.github.com/repos/rust-lang/rust/commits/7452822843cf461b56742f0fc648af35889a3070", "html_url": "https://github.com/rust-lang/rust/commit/7452822843cf461b56742f0fc648af35889a3070"}, {"sha": "6c1f108453a1ad34d2395bcdc2a76f554712e985", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c1f108453a1ad34d2395bcdc2a76f554712e985", "html_url": "https://github.com/rust-lang/rust/commit/6c1f108453a1ad34d2395bcdc2a76f554712e985"}], "stats": {"total": 75378, "additions": 57731, "deletions": 17647}, "files": [{"sha": "c8ff3ec6e52c8fb61f94d3ad1ae9cda25d080a71", "filename": "src/tools/rust-analyzer/.github/actions/github-release/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2FREADME.md?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -10,7 +10,7 @@ perform github releases but they all tend to have their set of drawbacks.\n Additionally nothing handles deleting releases which we need for our rolling\n `dev` release.\n \n-To handle all this this action rolls-its-own implementation using the\n+To handle all this, this action rolls its own implementation using the\n actions/toolkit repository and packages published there. These run in a Docker\n container and take various inputs to orchestrate the release from the build.\n "}, {"sha": "7090c94d93cce6d718ebda10a019529ef7608bb8", "filename": "src/tools/rust-analyzer/.github/workflows/autopublish.yaml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fautopublish.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fautopublish.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fautopublish.yaml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -32,7 +32,7 @@ jobs:\n         shell: bash\n         run: |\n           git config --global user.email \"runner@gha.local\"\n-          git config --global user.name \"Github Action\"\n+          git config --global user.name \"GitHub Action\"\n           rm Cargo.lock\n           # Fix names for crates that were published before switch to kebab-case.\n           cargo workspaces rename --from base-db base_db"}, {"sha": "622da105fdd44711eb7c9d227e3f3ee71e60dfe3", "filename": "src/tools/rust-analyzer/.github/workflows/ci.yaml", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -18,12 +18,35 @@ env:\n   RUSTUP_MAX_RETRIES: 10\n \n jobs:\n+  changes:\n+    runs-on: ubuntu-latest\n+    permissions:\n+      pull-requests: read\n+    outputs:\n+      typescript: ${{ steps.filter.outputs.typescript }}\n+    steps:\n+      - uses: actions/checkout@v3\n+      - uses: dorny/paths-filter@4067d885736b84de7c414f582ac45897079b0a78\n+        id: filter\n+        with:\n+          filters: |\n+            typescript:\n+              - 'editors/code/**'\n+            proc_macros:\n+              - 'crates/proc-macro-api/**'\n+              - 'crates/proc-macro-srv/**'\n+              - 'crates/proc-macro-srv-cli/**'\n+              - 'crates/proc-macro-test/**'\n+\n   rust:\n+    needs: changes\n     if: github.repository == 'rust-lang/rust-analyzer'\n     name: Rust\n     runs-on: ${{ matrix.os }}\n     env:\n       CC: deny_c\n+      RUST_CHANNEL: \"${{ needs.changes.outputs.proc_macros == 'true' && 'nightly' || 'stable'}}\"\n+      USE_SYSROOT_ABI: \"${{ needs.changes.outputs.proc_macros == 'true' && '--features sysroot-abi' || ''}}\"\n \n     strategy:\n       fail-fast: false\n@@ -35,30 +58,31 @@ jobs:\n         uses: actions/checkout@v3\n         with:\n           ref: ${{ github.event.pull_request.head.sha }}\n-          fetch-depth: 20\n \n       - name: Install Rust toolchain\n         run: |\n-          rustup update --no-self-update stable\n+          rustup update --no-self-update ${{ env.RUST_CHANNEL }}\n           rustup component add rustfmt rust-src\n \n       - name: Cache Dependencies\n-        uses: Swatinem/rust-cache@76686c56f2b581d1bb5bda44b51f7e24bd9b8b8e\n+        uses: Swatinem/rust-cache@988c164c3d0e93c4dbab36aaf5bbeb77425b2894\n+        with:\n+          key: ${{ env.RUST_CHANNEL }}\n \n       - name: Bump opt-level\n         if: matrix.os == 'ubuntu-latest'\n         run: sed -i '/\\[profile.dev]/a opt-level=1' Cargo.toml\n \n       - name: Compile (tests)\n-        run: cargo test --no-run --locked\n+        run: cargo test --no-run --locked ${{ env.USE_SYSROOT_ABI }}\n \n       # It's faster to `test` before `build` \u00af\\_(\u30c4)_/\u00af\n       - name: Compile (rust-analyzer)\n         if: matrix.os == 'ubuntu-latest'\n-        run: cargo build --quiet\n+        run: cargo build --quiet ${{ env.USE_SYSROOT_ABI }}\n \n       - name: Test\n-        run: cargo test -- --nocapture --quiet\n+        run: cargo test ${{ env.USE_SYSROOT_ABI }} -- --nocapture --quiet\n \n       - name: Run analysis-stats on rust-analyzer\n         if: matrix.os == 'ubuntu-latest'\n@@ -90,7 +114,7 @@ jobs:\n           rustup target add ${{ env.targets }} ${{ env.targets_ide }}\n \n       - name: Cache Dependencies\n-        uses: Swatinem/rust-cache@76686c56f2b581d1bb5bda44b51f7e24bd9b8b8e\n+        uses: Swatinem/rust-cache@988c164c3d0e93c4dbab36aaf5bbeb77425b2894\n \n       - name: Check\n         run: |\n@@ -102,6 +126,7 @@ jobs:\n           done\n \n   typescript:\n+    needs: changes\n     if: github.repository == 'rust-lang/rust-analyzer'\n     name: TypeScript\n     strategy:\n@@ -114,45 +139,51 @@ jobs:\n     steps:\n       - name: Checkout repository\n         uses: actions/checkout@v3\n+        if: needs.changes.outputs.typescript == 'true'\n \n       - name: Install Nodejs\n         uses: actions/setup-node@v3\n         with:\n           node-version: 16\n+        if: needs.changes.outputs.typescript == 'true'\n \n       - name: Install xvfb\n-        if: matrix.os == 'ubuntu-latest'\n+        if: matrix.os == 'ubuntu-latest' && needs.changes.outputs.typescript == 'true'\n         run: sudo apt-get install -y xvfb\n \n       - run: npm ci\n         working-directory: ./editors/code\n+        if: needs.changes.outputs.typescript == 'true'\n \n       #    - run: npm audit || { sleep 10 && npm audit; } || { sleep 30 && npm audit; }\n       #      if: runner.os == 'Linux'\n       #      working-directory: ./editors/code\n \n       - run: npm run lint\n         working-directory: ./editors/code\n+        if: needs.changes.outputs.typescript == 'true'\n \n       - name: Run VS Code tests (Linux)\n-        if: matrix.os == 'ubuntu-latest'\n+        if: matrix.os == 'ubuntu-latest' && needs.changes.outputs.typescript == 'true'\n         env:\n           VSCODE_CLI: 1\n         run: xvfb-run npm test\n         working-directory: ./editors/code\n \n       - name: Run VS Code tests (Windows)\n-        if: matrix.os == 'windows-latest'\n+        if: matrix.os == 'windows-latest' && needs.changes.outputs.typescript == 'true'\n         env:\n           VSCODE_CLI: 1\n         run: npm test\n         working-directory: ./editors/code\n \n       - run: npm run pretest\n         working-directory: ./editors/code\n+        if: needs.changes.outputs.typescript == 'true'\n \n       - run: npm run package --scripts-prepend-node-path\n         working-directory: ./editors/code\n+        if: needs.changes.outputs.typescript == 'true'\n \n   end-success:\n     name: bors build finished\n@@ -165,7 +196,7 @@ jobs:\n \n   end-failure:\n     name: bors build finished\n-    if: github.event.pusher.name == 'bors' && (failure() || cancelled())\n+    if: github.event.pusher.name == 'bors' && !success()\n     runs-on: ubuntu-latest\n     needs: [rust, rust-cross, typescript]\n     steps:"}, {"sha": "6d026c9ad910b69022d96c351b77f56fbade2311", "filename": "src/tools/rust-analyzer/.github/workflows/publish-libs.yaml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish-libs.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish-libs.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish-libs.yaml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -3,9 +3,9 @@ on:\n   workflow_dispatch:\n   push:\n     branches:\n-      - main\n+      - master\n     paths:\n-      - 'lib/**'\n+      - \"lib/**\"\n \n jobs:\n   publish-libs:\n@@ -29,7 +29,7 @@ jobs:\n         shell: bash\n         run: |\n           git config --global user.email \"runner@gha.local\"\n-          git config --global user.name \"Github Action\"\n+          git config --global user.name \"GitHub Action\"\n           # Remove r-a crates from the workspaces so we don't auto-publish them as well\n           sed -i 's/ \"crates\\/\\*\"//' ./Cargo.toml\n           cargo workspaces publish --yes --exact --from-git --no-git-commit --allow-dirty"}, {"sha": "43681c785fdc0042bf2c4c3d9e6ede26f52f9055", "filename": "src/tools/rust-analyzer/.github/workflows/release.yaml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -270,7 +270,7 @@ jobs:\n       - name: Publish Extension (Code Marketplace, nightly)\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n         working-directory: ./editors/code\n-        run: npx vsce publish --pat ${{ secrets.MARKETPLACE_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix\n+        run: npx vsce publish --pat ${{ secrets.MARKETPLACE_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix --pre-release\n \n       - name: Publish Extension (OpenVSX, nightly)\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')"}, {"sha": "c353737a35a837435f63301d0d54f3e728766a83", "filename": "src/tools/rust-analyzer/.vscode/launch.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.vscode%2Flaunch.json", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2F.vscode%2Flaunch.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.vscode%2Flaunch.json?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -72,7 +72,7 @@\n     },\n     {\n       // Used for testing the extension with a local build of the LSP server (in `target/release`)\n-      // with all other extendions loaded.\n+      // with all other extensions loaded.\n       \"name\": \"Run With Extensions\",\n       \"type\": \"extensionHost\",\n       \"request\": \"launch\","}, {"sha": "e36aef6a6aa8debf3dfcbb9d825ce72ea92ce850", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 247, "deletions": 176, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -19,18 +19,18 @@ checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n \n [[package]]\n name = \"always-assert\"\n-version = \"0.1.2\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbf688625d06217d5b1bb0ea9d9c44a1635fd0ee3534466388d18203174f4d11\"\n+checksum = \"4436e0292ab1bb631b42973c61205e704475fe8126af845c8d923c0996328127\"\n dependencies = [\n  \"log\",\n ]\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.68\"\n+version = \"1.0.70\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2cb2f989d18dd141ab8ae82f64d1a8cdd37e0840f73a406896cf5e99502fab61\"\n+checksum = \"7de8ce5e0f9f8d88245311066a578d72b7af3e7088f32783804676302df237e4\"\n \n [[package]]\n name = \"anymap\"\n@@ -40,9 +40,9 @@ checksum = \"8f1f8f5a6f3d50d89e3797d7593a50f96bb2aaa20ca0cc7be1fb673232c91d72\"\n \n [[package]]\n name = \"arbitrary\"\n-version = \"1.2.2\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b0224938f92e7aef515fac2ff2d18bd1115c1394ddf4a092e0c87e8be9499ee5\"\n+checksum = \"e2d098ff73c1ca148721f37baad5ea6a465a13f9573aba8641fbbbae8164a54e\"\n \n [[package]]\n name = \"arrayvec\"\n@@ -87,12 +87,14 @@ name = \"base-db\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg\",\n+ \"la-arena\",\n  \"profile\",\n  \"rustc-hash\",\n  \"salsa\",\n  \"stdx\",\n  \"syntax\",\n  \"test-utils\",\n+ \"triomphe\",\n  \"tt\",\n  \"vfs\",\n ]\n@@ -103,6 +105,12 @@ version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n+[[package]]\n+name = \"bitflags\"\n+version = \"2.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c70beb79cbb5ce9c4f8e20849978f34225931f665bb49efa6982875a4d5facb3\"\n+\n [[package]]\n name = \"byteorder\"\n version = \"1.4.3\"\n@@ -111,9 +119,9 @@ checksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n \n [[package]]\n name = \"camino\"\n-version = \"1.1.2\"\n+version = \"1.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c77df041dc383319cc661b428b6961a005db4d6808d5e12536931b1ca9556055\"\n+checksum = \"c530edf18f37068ac2d977409ed5cd50d53d73bc653c7647b48eb78976ac9ae2\"\n dependencies = [\n  \"serde\",\n ]\n@@ -129,9 +137,9 @@ dependencies = [\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.15.2\"\n+version = \"0.15.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"982a0cf6a99c350d7246035613882e376d58cebe571785abc5da4f648d53ac0a\"\n+checksum = \"eee4243f1f26fc7a42710e7439c149e2b10b05472f88090acce52632f231a73a\"\n dependencies = [\n  \"camino\",\n  \"cargo-platform\",\n@@ -143,9 +151,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.78\"\n+version = \"1.0.79\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a20104e2335ce8a659d6dd92a51a767a0c062599c73b343fd152cb401e828c3d\"\n+checksum = \"50d30906286121d95be3d479533b458f87493b30a4b5f79a607db8f5d11aa91f\"\n \n [[package]]\n name = \"cfg\"\n@@ -185,7 +193,7 @@ version = \"0.89.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"473b480241695428c14e8f84f1c9a47ef232450a50faf3a4041e5c9dc11e0a3b\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n@@ -221,9 +229,9 @@ dependencies = [\n \n [[package]]\n name = \"command-group\"\n-version = \"2.0.1\"\n+version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"026c3922235f9f7d78f21251a026f3acdeb7cce3deba107fe09a4bfa63d850a2\"\n+checksum = \"5080df6b0f0ecb76cab30808f00d937ba725cebe266a3da8cd89dff92f2a9916\"\n dependencies = [\n  \"nix\",\n  \"winapi\",\n@@ -257,19 +265,19 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.5.6\"\n+version = \"0.5.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c2dd04ddaf88237dc3b8d8f9a3c1004b506b54b3313403944054d23c0870c521\"\n+checksum = \"a33c2bf77f2df06183c3aa30d1e96c0695a313d4f9c453cc3762a6db39f99200\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils\",\n ]\n \n [[package]]\n name = \"crossbeam-deque\"\n-version = \"0.8.2\"\n+version = \"0.8.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"715e8152b692bba2d374b53d4875445368fdf21a94751410af607a5ac677d1fc\"\n+checksum = \"ce6fd6f855243022dcecf8702fef0c297d4338e226845fe067f6341ad9fa0cef\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-epoch\",\n@@ -278,22 +286,22 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-epoch\"\n-version = \"0.9.13\"\n+version = \"0.9.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"01a9af1f4c2ef74bb8aa1f7e19706bc72d03598c8a570bb5de72243c7a9d9d5a\"\n+checksum = \"46bd5f3f85273295a9d14aedfb86f6aadbff6d8f5295c4a9edb08e819dcf5695\"\n dependencies = [\n  \"autocfg\",\n  \"cfg-if\",\n  \"crossbeam-utils\",\n- \"memoffset 0.7.1\",\n+ \"memoffset\",\n  \"scopeguard\",\n ]\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.8.14\"\n+version = \"0.8.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4fb766fa798726286dbbb842f174001dab8abc7b627a1dd86e0b7222a95d929f\"\n+checksum = \"3c063cd8cc95f5c377ed0d4b49a4b21f632396ff690e8470c29b3359b346984b\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -313,9 +321,9 @@ dependencies = [\n \n [[package]]\n name = \"derive_arbitrary\"\n-version = \"1.2.2\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf460bbff5f571bfc762da5102729f59f338be7db17a21fade44c5c4f5005350\"\n+checksum = \"f3cdeb9ec472d588e539a818b2dee436825730da08ad0017c4b1a17676bdc8b7\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -342,24 +350,24 @@ checksum = \"9bda8e21c04aca2ae33ffc2fd8c23134f3cac46db123ba97bd9d3f3b8a4a85e1\"\n \n [[package]]\n name = \"either\"\n-version = \"1.8.0\"\n+version = \"1.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"90e5c1c8368803113bf0c9584fc495a58b86dc8a29edbf8fe877d21d9507e797\"\n+checksum = \"7fcaabb2fef8c910e7f4c7ce9f67a1283a1715879a7c230ca9d6d1ae31f16d91\"\n \n [[package]]\n name = \"ena\"\n-version = \"0.14.0\"\n+version = \"0.14.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7402b94a93c24e742487327a7cd839dc9d36fec9de9fb25b09f2dae459f36c3\"\n+checksum = \"c533630cf40e9caa44bd91aadc88a75d75a4c3a12b4cfde353cbed41daa1e1f1\"\n dependencies = [\n  \"log\",\n ]\n \n [[package]]\n name = \"expect-test\"\n-version = \"1.4.0\"\n+version = \"1.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1d4661aca38d826eb7c72fe128e4238220616de4c0cc00db7bfc38e2e1364dd3\"\n+checksum = \"30d9eafeadd538e68fb28016364c9732d78e420b9ff8853fa5e4058861e9f8d3\"\n dependencies = [\n  \"dissimilar\",\n  \"once_cell\",\n@@ -400,7 +408,6 @@ dependencies = [\n  \"cargo_metadata\",\n  \"command-group\",\n  \"crossbeam-channel\",\n- \"jod-thread\",\n  \"paths\",\n  \"rustc-hash\",\n  \"serde\",\n@@ -419,12 +426,6 @@ dependencies = [\n  \"percent-encoding\",\n ]\n \n-[[package]]\n-name = \"fs_extra\"\n-version = \"1.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2022715d62ab30faffd124d40b76f4134a550a87792276512b18d63272333394\"\n-\n [[package]]\n name = \"fsevent-sys\"\n version = \"4.1.0\"\n@@ -442,9 +443,9 @@ checksum = \"7ab85b9b05e3978cc9a9cf8fea7f01b494e1a09ed3037e16ba39edc7a29eb61a\"\n \n [[package]]\n name = \"gimli\"\n-version = \"0.27.0\"\n+version = \"0.27.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dec7af912d60cdbd3677c1af9352ebae6fb8394d165568a2234df0fa00f87793\"\n+checksum = \"ad0a93d233ebf96623465aad4046a8d3aa4da22d4f4beba5388838c8a434bbb4\"\n \n [[package]]\n name = \"hashbrown\"\n@@ -497,6 +498,7 @@ dependencies = [\n  \"smallvec\",\n  \"stdx\",\n  \"syntax\",\n+ \"triomphe\",\n  \"tt\",\n ]\n \n@@ -507,7 +509,7 @@ dependencies = [\n  \"anymap\",\n  \"arrayvec\",\n  \"base-db\",\n- \"bitflags\",\n+ \"bitflags 2.1.0\",\n  \"cfg\",\n  \"cov-mark\",\n  \"dashmap\",\n@@ -533,6 +535,7 @@ dependencies = [\n  \"syntax\",\n  \"test-utils\",\n  \"tracing\",\n+ \"triomphe\",\n  \"tt\",\n ]\n \n@@ -557,6 +560,7 @@ dependencies = [\n  \"stdx\",\n  \"syntax\",\n  \"tracing\",\n+ \"triomphe\",\n  \"tt\",\n ]\n \n@@ -566,7 +570,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arrayvec\",\n  \"base-db\",\n- \"bitflags\",\n+ \"bitflags 2.1.0\",\n  \"chalk-derive\",\n  \"chalk-ir\",\n  \"chalk-recursive\",\n@@ -582,6 +586,7 @@ dependencies = [\n  \"itertools\",\n  \"la-arena\",\n  \"limit\",\n+ \"nohash-hasher\",\n  \"once_cell\",\n  \"profile\",\n  \"project-model\",\n@@ -594,6 +599,7 @@ dependencies = [\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n+ \"triomphe\",\n  \"typed-arena\",\n ]\n \n@@ -603,7 +609,7 @@ version = \"0.0.20221221\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"adabaadad9aa7576f97af02241cdf5554d62fb3d51a84cb05d77ba28edd3013f\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"hkalbasi-rustc-ap-rustc_index\",\n  \"tracing\",\n ]\n@@ -644,6 +650,7 @@ dependencies = [\n  \"ide-diagnostics\",\n  \"ide-ssr\",\n  \"itertools\",\n+ \"nohash-hasher\",\n  \"oorandom\",\n  \"profile\",\n  \"pulldown-cmark\",\n@@ -655,6 +662,7 @@ dependencies = [\n  \"text-edit\",\n  \"toolchain\",\n  \"tracing\",\n+ \"triomphe\",\n  \"url\",\n ]\n \n@@ -710,7 +718,9 @@ dependencies = [\n  \"indexmap\",\n  \"itertools\",\n  \"limit\",\n+ \"line-index\",\n  \"memchr\",\n+ \"nohash-hasher\",\n  \"once_cell\",\n  \"oorandom\",\n  \"parser\",\n@@ -723,6 +733,7 @@ dependencies = [\n  \"test-utils\",\n  \"text-edit\",\n  \"tracing\",\n+ \"triomphe\",\n  \"xshell\",\n ]\n \n@@ -755,11 +766,13 @@ dependencies = [\n  \"hir\",\n  \"ide-db\",\n  \"itertools\",\n+ \"nohash-hasher\",\n  \"parser\",\n  \"stdx\",\n  \"syntax\",\n  \"test-utils\",\n  \"text-edit\",\n+ \"triomphe\",\n ]\n \n [[package]]\n@@ -774,9 +787,9 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.9.2\"\n+version = \"1.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\n+checksum = \"bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\",\n@@ -788,7 +801,7 @@ version = \"0.9.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f8069d3ec154eb856955c1c0fbffefbf5f3c40a104ec912d4797314c1801abff\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"inotify-sys\",\n  \"libc\",\n ]\n@@ -819,6 +832,7 @@ dependencies = [\n  \"hashbrown\",\n  \"once_cell\",\n  \"rustc-hash\",\n+ \"triomphe\",\n ]\n \n [[package]]\n@@ -832,9 +846,9 @@ dependencies = [\n \n [[package]]\n name = \"itoa\"\n-version = \"1.0.5\"\n+version = \"1.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fad582f4b9e86b6caa621cabeb0963332d92eea04729ab12892c2533951e6440\"\n+checksum = \"453ad9f582a441959e5f0d088b02ce04cfe8d51a8eaf077f12ac6d3e94164ca6\"\n \n [[package]]\n name = \"jod-thread\"\n@@ -858,7 +872,7 @@ version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8367585489f01bc55dd27404dcf56b95e6da061a256a666ab23be9ba96a2e587\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"libc\",\n ]\n \n@@ -874,9 +888,9 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.139\"\n+version = \"0.2.141\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n+checksum = \"3304a64d199bb964be99741b7a14d26972741915b3649639149b2479bb46f4b5\"\n \n [[package]]\n name = \"libloading\"\n@@ -890,9 +904,9 @@ dependencies = [\n \n [[package]]\n name = \"libmimalloc-sys\"\n-version = \"0.1.30\"\n+version = \"0.1.32\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dd8c7cbf8b89019683667e347572e6d55a7df7ea36b0c4ce69961b0cde67b174\"\n+checksum = \"43a558e3d911bc3c7bfc8c78bc580b404d6e51c1cefbf656e176a94b49b0df40\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -902,6 +916,14 @@ dependencies = [\n name = \"limit\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"line-index\"\n+version = \"0.1.0-pre.1\"\n+dependencies = [\n+ \"nohash-hasher\",\n+ \"text-size\",\n+]\n+\n [[package]]\n name = \"lock_api\"\n version = \"0.4.9\"\n@@ -938,7 +960,7 @@ version = \"0.94.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0b63735a13a1f9cd4f4835223d828ed9c2e35c8c5e61837774399f558b6a1237\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"serde\",\n  \"serde_json\",\n  \"serde_repr\",\n@@ -977,36 +999,27 @@ checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n \n [[package]]\n name = \"memmap2\"\n-version = \"0.5.8\"\n+version = \"0.5.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4b182332558b18d807c4ce1ca8ca983b34c3ee32765e47b3f0f69b90355cc1dc\"\n+checksum = \"83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327\"\n dependencies = [\n  \"libc\",\n ]\n \n [[package]]\n name = \"memoffset\"\n-version = \"0.6.5\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce\"\n-dependencies = [\n- \"autocfg\",\n-]\n-\n-[[package]]\n-name = \"memoffset\"\n-version = \"0.7.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4\"\n+checksum = \"d61c719bcfbcf5d62b3a09efa6088de8c54bc0bfcd3ea7ae39fcc186108b8de1\"\n dependencies = [\n  \"autocfg\",\n ]\n \n [[package]]\n name = \"mimalloc\"\n-version = \"0.1.34\"\n+version = \"0.1.36\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9dcb174b18635f7561a0c6c9fc2ce57218ac7523cf72c50af80e2d79ab8f3ba1\"\n+checksum = \"3d88dad3f985ec267a3fcb7a1726f5cb1a7e8cad8b646e70a84f967210df23da\"\n dependencies = [\n  \"libmimalloc-sys\",\n ]\n@@ -1047,19 +1060,25 @@ version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bfdda3d196821d6af13126e40375cdf7da646a96114af134d5f417a9a1dc8e1a\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"cfg-if\",\n  \"libc\",\n  \"static_assertions\",\n ]\n \n+[[package]]\n+name = \"nohash-hasher\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2bf50223579dc7cdcfb3bfcacf7069ff68243f8c363f62ffa99cf000a6b9c451\"\n+\n [[package]]\n name = \"notify\"\n-version = \"5.0.0\"\n+version = \"5.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ed2c66da08abae1c024c01d635253e402341b4060a12e99b31c7594063bf490a\"\n+checksum = \"58ea850aa68a06e48fdb069c0ec44d0d64c8dbffa49bf3b6f7f0a901fdea1ba9\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"crossbeam-channel\",\n  \"filetime\",\n  \"fsevent-sys\",\n@@ -1068,7 +1087,7 @@ dependencies = [\n  \"libc\",\n  \"mio\",\n  \"walkdir\",\n- \"winapi\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n@@ -1093,18 +1112,18 @@ dependencies = [\n \n [[package]]\n name = \"object\"\n-version = \"0.30.2\"\n+version = \"0.30.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2b8c786513eb403643f2a88c244c2aaa270ef2153f55094587d0c48a3cf22a83\"\n+checksum = \"ea86265d3d3dcb6a27fc51bd29a4bf387fae9d2986b823079d4986af253eb439\"\n dependencies = [\n  \"memchr\",\n ]\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.17.0\"\n+version = \"1.17.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f61fba1741ea2b3d6a1e3178721804bb716a68a6aeba1149b5d52e3d464ea66\"\n+checksum = \"b7e5500299e16ebb147ae15a00a942af264cf3688f47923b8fc2cd5858f23ad3\"\n \n [[package]]\n name = \"oorandom\"\n@@ -1173,16 +1192,16 @@ dependencies = [\n  \"drop_bomb\",\n  \"expect-test\",\n  \"limit\",\n- \"rustc-ap-rustc_lexer\",\n+ \"ra-ap-rustc_lexer\",\n  \"sourcegen\",\n  \"stdx\",\n ]\n \n [[package]]\n name = \"paste\"\n-version = \"1.0.11\"\n+version = \"1.0.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d01a5bd0424d00070b0098dd17ebca6f961a959dead1dbcbbbc1d1cd8d3deeba\"\n+checksum = \"9f746c4065a8fa3fe23974dd82f15431cc8d40779821001404d10d2e79ca7d79\"\n \n [[package]]\n name = \"paths\"\n@@ -1242,6 +1261,7 @@ dependencies = [\n  \"snap\",\n  \"stdx\",\n  \"tracing\",\n+ \"triomphe\",\n  \"tt\",\n ]\n \n@@ -1257,13 +1277,15 @@ dependencies = [\n  \"paths\",\n  \"proc-macro-api\",\n  \"proc-macro-test\",\n+ \"stdx\",\n  \"tt\",\n ]\n \n [[package]]\n name = \"proc-macro-srv-cli\"\n version = \"0.0.0\"\n dependencies = [\n+ \"proc-macro-api\",\n  \"proc-macro-srv\",\n ]\n \n@@ -1282,9 +1304,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.50\"\n+version = \"1.0.56\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6ef7d57beacfaf2d8aee5937dab7b7f28de3cb8b1828479bb5de2a7106f2bae2\"\n+checksum = \"2b63bdb0cd06f1f4dedf69b254734f9b45af66e4a031e42a7480257d9898b435\"\n dependencies = [\n  \"unicode-ident\",\n ]\n@@ -1312,6 +1334,7 @@ dependencies = [\n  \"cargo_metadata\",\n  \"cfg\",\n  \"expect-test\",\n+ \"itertools\",\n  \"la-arena\",\n  \"paths\",\n  \"profile\",\n@@ -1322,6 +1345,7 @@ dependencies = [\n  \"stdx\",\n  \"toolchain\",\n  \"tracing\",\n+ \"triomphe\",\n ]\n \n [[package]]\n@@ -1350,7 +1374,7 @@ version = \"0.9.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2d9cc634bc78768157b5cbfe988ffcd1dcba95cd2b2f03a88316c08c6d00ed63\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"memchr\",\n  \"unicase\",\n ]\n@@ -1366,28 +1390,38 @@ dependencies = [\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.23\"\n+version = \"1.0.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8856d8364d252a14d474036ea1358d63c9e6965c8e5c1885c18f73d70bff9c7b\"\n+checksum = \"4424af4bf778aae2051a77b60283332f386554255d722233d09fbfc7e30da2fc\"\n dependencies = [\n  \"proc-macro2\",\n ]\n \n+[[package]]\n+name = \"ra-ap-rustc_lexer\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e1c145702ed3f237918e512685185dc8a4d0edc3a5326c63d20361d8ba9b45b3\"\n+dependencies = [\n+ \"unic-emoji-char\",\n+ \"unicode-xid\",\n+]\n+\n [[package]]\n name = \"rayon\"\n-version = \"1.6.1\"\n+version = \"1.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6db3a213adf02b3bcfd2d3846bb41cb22857d131789e01df434fb7e7bc0759b7\"\n+checksum = \"1d2df5196e37bcc87abebc0053e20787d73847bb33134a69841207dd0a47f03b\"\n dependencies = [\n  \"either\",\n  \"rayon-core\",\n ]\n \n [[package]]\n name = \"rayon-core\"\n-version = \"1.10.1\"\n+version = \"1.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cac410af5d00ab6884528b4ab69d1e8e146e8d471201800fa1b4524126de6ad3\"\n+checksum = \"4b8f95bd6966f5c87776639160a66bd8ab9895d9d4ab01ddba9fc60661aebe8d\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"crossbeam-deque\",\n@@ -1401,14 +1435,14 @@ version = \"0.2.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n ]\n \n [[package]]\n name = \"regex\"\n-version = \"1.7.1\"\n+version = \"1.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"48aaa5748ba571fb95cd2c85c09f629215d3a6ece942baa100950af03a34f733\"\n+checksum = \"8b1f693b24f6ac912f4893ef08244d70b6067480d2f1a46e950c9691e6749d1d\"\n dependencies = [\n  \"regex-syntax\",\n ]\n@@ -1424,19 +1458,19 @@ dependencies = [\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.6.28\"\n+version = \"0.6.29\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"456c603be3e8d448b072f410900c09faf164fbce2d480456f50eea6e25f9c848\"\n+checksum = \"f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1\"\n \n [[package]]\n name = \"rowan\"\n-version = \"0.15.10\"\n+version = \"0.15.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5811547e7ba31e903fe48c8ceab10d40d70a101f3d15523c847cce91aa71f332\"\n+checksum = \"64449cfef9483a475ed56ae30e2da5ee96448789fb2aa240a04beb6a055078bf\"\n dependencies = [\n  \"countme\",\n  \"hashbrown\",\n- \"memoffset 0.6.5\",\n+ \"memoffset\",\n  \"rustc-hash\",\n  \"text-size\",\n ]\n@@ -1451,6 +1485,7 @@ dependencies = [\n  \"crossbeam-channel\",\n  \"dissimilar\",\n  \"expect-test\",\n+ \"filetime\",\n  \"flycheck\",\n  \"hir\",\n  \"hir-def\",\n@@ -1459,34 +1494,38 @@ dependencies = [\n  \"ide-db\",\n  \"ide-ssr\",\n  \"itertools\",\n- \"jod-thread\",\n  \"lsp-server\",\n  \"lsp-types\",\n  \"mbe\",\n  \"mimalloc\",\n+ \"mio\",\n+ \"nohash-hasher\",\n  \"num_cpus\",\n  \"oorandom\",\n  \"parking_lot 0.12.1\",\n+ \"parking_lot_core 0.9.6\",\n  \"proc-macro-api\",\n- \"proc-macro-srv\",\n+ \"proc-macro-srv-cli\",\n  \"profile\",\n  \"project-model\",\n  \"rayon\",\n  \"rustc-hash\",\n  \"scip\",\n  \"serde\",\n  \"serde_json\",\n+ \"serde_repr\",\n  \"sourcegen\",\n  \"stdx\",\n  \"syntax\",\n  \"test-utils\",\n- \"threadpool\",\n+ \"thiserror\",\n  \"tikv-jemallocator\",\n  \"toolchain\",\n  \"tracing\",\n  \"tracing-log\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n+ \"triomphe\",\n  \"tt\",\n  \"vfs\",\n  \"vfs-notify\",\n@@ -1495,20 +1534,11 @@ dependencies = [\n  \"xshell\",\n ]\n \n-[[package]]\n-name = \"rustc-ap-rustc_lexer\"\n-version = \"727.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8f40f26e7abdcd3b982f36c09a634cc6187988fbf6ec466c91f8d30a12ac0237\"\n-dependencies = [\n- \"unicode-xid\",\n-]\n-\n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.21\"\n+version = \"0.1.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7ef03e0a2b150c7a90d01faf6254c9c48a41e95fb2a8c2ac1c6f0d2b9aefc342\"\n+checksum = \"d4a36c42d1873f9a77c53bde094f9664d9891bc604a45b4798fd2c389ed12e5b\"\n \n [[package]]\n name = \"rustc-hash\"\n@@ -1518,9 +1548,9 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n \n [[package]]\n name = \"ryu\"\n-version = \"1.0.12\"\n+version = \"1.0.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7b4b9743ed687d4b4bcedf9ff5eaa7398495ae14e61cba0a295704edbc7decde\"\n+checksum = \"f91339c0467de62360649f8d3e185ca8de4224ff281f66000de5eb2a77a79041\"\n \n [[package]]\n name = \"salsa\"\n@@ -1583,27 +1613,27 @@ checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n [[package]]\n name = \"semver\"\n-version = \"1.0.16\"\n+version = \"1.0.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"58bc9567378fc7690d6b2addae4e60ac2eeea07becb2c64b9f218b53865cba2a\"\n+checksum = \"bebd363326d05ec3e2f532ab7660680f3b02130d780c299bca73469d521bc0ed\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.152\"\n+version = \"1.0.156\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb7d1f0d3021d347a83e556fc4683dea2ea09d87bccdf88ff5c12545d89d5efb\"\n+checksum = \"314b5b092c0ade17c00142951e50ced110ec27cea304b1037c6969246c2469a4\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.152\"\n+version = \"1.0.156\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"af487d118eecd09402d70a5d72551860e788df87b464af30e5ea6a38c75c541e\"\n+checksum = \"d7e29c4601e36bcec74a223228dce795f4cd3616341a4af93520ca1a837c087d\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1612,9 +1642,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.91\"\n+version = \"1.0.96\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"877c235533714907a8c2464236f5c4b2a17262ef1bd71f38f35ea592c8da6883\"\n+checksum = \"057d394a50403bcac12672b2b18fb387ab6d289d957dab67dd201875391e52f1\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\",\n@@ -1624,9 +1654,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_repr\"\n-version = \"0.1.10\"\n+version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9a5ec9fa74a20ebbe5d9ac23dac1fc96ba0ecfe9f50f2843b52e537b10fbcb4e\"\n+checksum = \"395627de918015623b32e7669714206363a7fc00382bf477e72c1f7533e8eafc\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1650,9 +1680,9 @@ checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n \n [[package]]\n name = \"smol_str\"\n-version = \"0.1.23\"\n+version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7475118a28b7e3a2e157ce0131ba8c5526ea96e90ee601d9f6bb2e286a35ab44\"\n+checksum = \"74212e6bbe9a4352329b2f68ba3130c15a3f26fe88ff22dbdc6cdd58fa85e99c\"\n dependencies = [\n  \"serde\",\n ]\n@@ -1682,16 +1712,18 @@ version = \"0.0.0\"\n dependencies = [\n  \"always-assert\",\n  \"backtrace\",\n+ \"crossbeam-channel\",\n+ \"jod-thread\",\n  \"libc\",\n  \"miow\",\n  \"winapi\",\n ]\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.107\"\n+version = \"1.0.109\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1f4064b5b16e03ae50984a5a8ed5d4f8803e6bc1fd170a3cda91a1be4b18e3f5\"\n+checksum = \"72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1724,15 +1756,16 @@ dependencies = [\n  \"proc-macro2\",\n  \"profile\",\n  \"quote\",\n+ \"ra-ap-rustc_lexer\",\n  \"rayon\",\n  \"rowan\",\n- \"rustc-ap-rustc_lexer\",\n  \"rustc-hash\",\n  \"smol_str\",\n  \"sourcegen\",\n  \"stdx\",\n  \"test-utils\",\n  \"text-edit\",\n+ \"triomphe\",\n  \"ungrammar\",\n ]\n \n@@ -1763,18 +1796,18 @@ checksum = \"288cb548dbe72b652243ea797201f3d481a0609a967980fcc5b2315ea811560a\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.38\"\n+version = \"1.0.39\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6a9cd18aa97d5c45c6603caea1da6628790b37f7a34b6ca89522331c5180fed0\"\n+checksum = \"a5ab016db510546d856297882807df8da66a16fb8c4101cb8b30054b0d5b2d9c\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.38\"\n+version = \"1.0.39\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1fb327af4685e4d03fa8cbcf1716380da910eeb2bb8be417e7f9fd3fb164f36f\"\n+checksum = \"5420d42e90af0c38c3290abcca25b9b3bdf379fc9f55c528f53a269d9c9a267e\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1783,22 +1816,14 @@ dependencies = [\n \n [[package]]\n name = \"thread_local\"\n-version = \"1.1.4\"\n+version = \"1.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5516c27b78311c50bf42c071425c560ac799b11c30b31f87e3081965fe5e0180\"\n+checksum = \"3fdd6f064ccff2d6567adcb3873ca630700f00b5ad3f060c25b5dcfd9a4ce152\"\n dependencies = [\n+ \"cfg-if\",\n  \"once_cell\",\n ]\n \n-[[package]]\n-name = \"threadpool\"\n-version = \"1.8.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa\"\n-dependencies = [\n- \"num_cpus\",\n-]\n-\n [[package]]\n name = \"tikv-jemalloc-ctl\"\n version = \"0.5.0\"\n@@ -1812,12 +1837,11 @@ dependencies = [\n \n [[package]]\n name = \"tikv-jemalloc-sys\"\n-version = \"0.5.2+5.3.0-patched\"\n+version = \"0.5.3+5.3.0-patched\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec45c14da997d0925c7835883e4d5c181f196fa142f8c19d7643d1e9af2592c3\"\n+checksum = \"a678df20055b43e57ef8cddde41cdfda9a3c1a060b67f4c5836dfb1d78543ba8\"\n dependencies = [\n  \"cc\",\n- \"fs_extra\",\n  \"libc\",\n ]\n \n@@ -1833,9 +1857,9 @@ dependencies = [\n \n [[package]]\n name = \"time\"\n-version = \"0.3.17\"\n+version = \"0.3.20\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a561bf4617eebd33bca6434b988f39ed798e527f51a1e797d0ee4f61c0a38376\"\n+checksum = \"cd0cbfecb4d19b5ea75bb31ad904eb5b9fa13f21079c3b92017ebdf4999a5890\"\n dependencies = [\n  \"serde\",\n  \"time-core\",\n@@ -1858,9 +1882,9 @@ dependencies = [\n \n [[package]]\n name = \"tinyvec_macros\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cda74da7e1a664f795bb1f8a87ec406fb89a02522cf6e50620d016add6dbbf5c\"\n+checksum = \"1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20\"\n \n [[package]]\n name = \"toolchain\"\n@@ -1942,6 +1966,12 @@ dependencies = [\n  \"tracing-subscriber\",\n ]\n \n+[[package]]\n+name = \"triomphe\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f1ee9bd9239c339d714d657fac840c6d2a4f9c45f4f9ec7b0975113458be78db\"\n+\n [[package]]\n name = \"tt\"\n version = \"0.0.0\"\n@@ -1962,6 +1992,47 @@ version = \"1.16.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a3e5df347f0bf3ec1d670aad6ca5c6a1859cd9ea61d2113125794654ccced68f\"\n \n+[[package]]\n+name = \"unic-char-property\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a8c57a407d9b6fa02b4795eb81c5b6652060a15a7903ea981f3d723e6c0be221\"\n+dependencies = [\n+ \"unic-char-range\",\n+]\n+\n+[[package]]\n+name = \"unic-char-range\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0398022d5f700414f6b899e10b8348231abf9173fa93144cbc1a43b9793c1fbc\"\n+\n+[[package]]\n+name = \"unic-common\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"80d7ff825a6a654ee85a63e80f92f054f904f21e7d12da4e22f9834a4aaa35bc\"\n+\n+[[package]]\n+name = \"unic-emoji-char\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0b07221e68897210270a38bde4babb655869637af0f69407f96053a34f76494d\"\n+dependencies = [\n+ \"unic-char-property\",\n+ \"unic-char-range\",\n+ \"unic-ucd-version\",\n+]\n+\n+[[package]]\n+name = \"unic-ucd-version\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"96bd2f2237fe450fcd0a1d2f5f4e91711124f7857ba2e964247776ebeeb7b0c4\"\n+dependencies = [\n+ \"unic-common\",\n+]\n+\n [[package]]\n name = \"unicase\"\n version = \"2.6.0\"\n@@ -1973,15 +2044,15 @@ dependencies = [\n \n [[package]]\n name = \"unicode-bidi\"\n-version = \"0.3.10\"\n+version = \"0.3.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d54675592c1dbefd78cbd98db9bacd89886e1ca50692a0692baefffdeb92dd58\"\n+checksum = \"92888ba5573ff080736b3648696b70cafad7d250551175acbaa4e0385b3e1460\"\n \n [[package]]\n name = \"unicode-ident\"\n-version = \"1.0.6\"\n+version = \"1.0.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"84a22b9f218b40614adcb3f4ff08b703773ad44fa9423e4e0d346d5db86e4ebc\"\n+checksum = \"e5464a87b239f13a63a501f2701565754bae92d243d4bb7eb12f6d57d2269bf4\"\n \n [[package]]\n name = \"unicode-normalization\"\n@@ -1994,9 +2065,9 @@ dependencies = [\n \n [[package]]\n name = \"unicode-segmentation\"\n-version = \"1.10.0\"\n+version = \"1.10.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0fdbf052a0783de01e944a6ce7a8cb939e295b1e7be835a1112c3b9a7f047a5a\"\n+checksum = \"1dd624098567895118886609431a7c3b8f516e41d30e0643f03d94592a147e36\"\n \n [[package]]\n name = \"unicode-xid\"\n@@ -2034,6 +2105,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"fst\",\n  \"indexmap\",\n+ \"nohash-hasher\",\n  \"paths\",\n  \"rustc-hash\",\n  \"stdx\",\n@@ -2044,22 +2116,21 @@ name = \"vfs-notify\"\n version = \"0.0.0\"\n dependencies = [\n  \"crossbeam-channel\",\n- \"jod-thread\",\n  \"notify\",\n  \"paths\",\n+ \"stdx\",\n  \"tracing\",\n  \"vfs\",\n  \"walkdir\",\n ]\n \n [[package]]\n name = \"walkdir\"\n-version = \"2.3.2\"\n+version = \"2.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"808cf2735cd4b6866113f648b791c6adc5714537bc222d9347bb203386ffda56\"\n+checksum = \"36df944cda56c7d8d8b7496af378e6b16de9284591917d307c9b4d313c44e698\"\n dependencies = [\n  \"same-file\",\n- \"winapi\",\n  \"winapi-util\",\n ]\n \n@@ -2117,45 +2188,45 @@ dependencies = [\n \n [[package]]\n name = \"windows_aarch64_gnullvm\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8c9864e83243fdec7fc9c5444389dcbbfd258f745e7853198f365e3c4968a608\"\n+checksum = \"597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8\"\n \n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c8b1b673ffc16c47a9ff48570a9d85e25d265735c503681332589af6253c6c7\"\n+checksum = \"e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"de3887528ad530ba7bdbb1faa8275ec7a1155a45ffa57c37993960277145d640\"\n+checksum = \"c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf4d1122317eddd6ff351aa852118a2418ad4214e6613a50e0191f7004372605\"\n+checksum = \"44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c1040f221285e17ebccbc2591ffdc2d44ee1f9186324dd3e84e99ac68d699c45\"\n+checksum = \"8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36\"\n \n [[package]]\n name = \"windows_x86_64_gnullvm\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"628bfdf232daa22b0d64fdb62b09fcc36bb01f05a3939e20ab73aaf9470d0463\"\n+checksum = \"26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"447660ad36a13288b1db4d4248e857b510e8c3a225c822ba4fb748c0aafecffd\"\n+checksum = \"9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0\"\n \n [[package]]\n name = \"write-json\""}, {"sha": "3050cf764a4c5c2e87e9d549901c78d5ee915317", "filename": "src/tools/rust-analyzer/Cargo.toml", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.toml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,6 +1,7 @@\n [workspace]\n members = [\"xtask/\", \"lib/*\", \"crates/*\"]\n exclude = [\"crates/proc-macro-test/imp\"]\n+resolver = \"2\"\n \n [workspace.package]\n rust-version = \"1.66\"\n@@ -74,5 +75,20 @@ toolchain = { path = \"./crates/toolchain\", version = \"0.0.0\" }\n tt = { path = \"./crates/tt\", version = \"0.0.0\" }\n vfs-notify = { path = \"./crates/vfs-notify\", version = \"0.0.0\" }\n vfs = { path = \"./crates/vfs\", version = \"0.0.0\" }\n+line-index = { version = \"0.1.0-pre.1\", path = \"./lib/line-index\" }\n+\n # non-local crates\n-smallvec = { version = \"1.10.0\", features = [\"const_new\", \"union\", \"const_generics\"] }\n+smallvec = { version = \"1.10.0\", features = [\n+  \"const_new\",\n+  \"union\",\n+  \"const_generics\",\n+] }\n+smol_str = \"0.2.0\"\n+nohash-hasher = \"0.2.0\"\n+text-size = \"1.1.0\"\n+# the following crates are pinned to prevent us from pulling in syn 2 until all our dependencies have moved\n+serde = { version = \"=1.0.156\", features = [\"derive\"] }\n+serde_json = \"1.0.94\"\n+triomphe = { version = \"0.1.8\", default-features = false, features = [\"std\"] }\n+\n+rustc_lexer = { version = \"0.1.0\", package = \"ra-ap-rustc_lexer\" }"}, {"sha": "f593f2b2955acb2890e84454ed62f8e18f46ef35", "filename": "src/tools/rust-analyzer/bench_data/glorious_old_parser", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fglorious_old_parser", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fglorious_old_parser", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fglorious_old_parser?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -3808,7 +3808,7 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Else) || !cond.returns() {\n             let sp = self.sess.source_map().next_point(lo);\n             let mut err = self.diagnostic()\n-                .struct_span_err(sp, \"missing condition for `if` statemement\");\n+                .struct_span_err(sp, \"missing condition for `if` statement\");\n             err.span_label(sp, \"expected if condition here\");\n             return Err(err)\n         }"}, {"sha": "6001772c86ee4325af8d9e12ef4a13a1dd7445a6", "filename": "src/tools/rust-analyzer/crates/base-db/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -15,6 +15,10 @@ doctest = false\n salsa = \"0.17.0-pre.2\"\n rustc-hash = \"1.1.0\"\n \n+triomphe.workspace = true\n+\n+la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n+\n # local deps\n cfg.workspace = true\n profile.workspace = true"}, {"sha": "6a3b36b2312809625dd8a2ab0884e7175fce9759", "filename": "src/tools/rust-analyzer/crates/base-db/src/change.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Fchange.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,19 +1,21 @@\n //! Defines a unit of change that can applied to the database to get the next\n //! state. Changes are transactional.\n \n-use std::{fmt, sync::Arc};\n+use std::fmt;\n \n use salsa::Durability;\n+use triomphe::Arc;\n use vfs::FileId;\n \n-use crate::{CrateGraph, SourceDatabaseExt, SourceRoot, SourceRootId};\n+use crate::{CrateGraph, ProcMacros, SourceDatabaseExt, SourceRoot, SourceRootId};\n \n /// Encapsulate a bunch of raw `.set` calls on the database.\n #[derive(Default)]\n pub struct Change {\n     pub roots: Option<Vec<SourceRoot>>,\n-    pub files_changed: Vec<(FileId, Option<Arc<String>>)>,\n+    pub files_changed: Vec<(FileId, Option<Arc<str>>)>,\n     pub crate_graph: Option<CrateGraph>,\n+    pub proc_macros: Option<ProcMacros>,\n }\n \n impl fmt::Debug for Change {\n@@ -33,22 +35,26 @@ impl fmt::Debug for Change {\n }\n \n impl Change {\n-    pub fn new() -> Change {\n+    pub fn new() -> Self {\n         Change::default()\n     }\n \n     pub fn set_roots(&mut self, roots: Vec<SourceRoot>) {\n         self.roots = Some(roots);\n     }\n \n-    pub fn change_file(&mut self, file_id: FileId, new_text: Option<Arc<String>>) {\n+    pub fn change_file(&mut self, file_id: FileId, new_text: Option<Arc<str>>) {\n         self.files_changed.push((file_id, new_text))\n     }\n \n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         self.crate_graph = Some(graph);\n     }\n \n+    pub fn set_proc_macros(&mut self, proc_macros: ProcMacros) {\n+        self.proc_macros = Some(proc_macros);\n+    }\n+\n     pub fn apply(self, db: &mut dyn SourceDatabaseExt) {\n         let _p = profile::span(\"RootDatabase::apply_change\");\n         if let Some(roots) = self.roots {\n@@ -67,11 +73,14 @@ impl Change {\n             let source_root = db.source_root(source_root_id);\n             let durability = durability(&source_root);\n             // XXX: can't actually remove the file, just reset the text\n-            let text = text.unwrap_or_default();\n+            let text = text.unwrap_or_else(|| Arc::from(\"\"));\n             db.set_file_text_with_durability(file_id, text, durability)\n         }\n         if let Some(crate_graph) = self.crate_graph {\n-            db.set_crate_graph_with_durability(Arc::new(crate_graph), Durability::HIGH)\n+            db.set_crate_graph_with_durability(Arc::new(crate_graph), Durability::HIGH);\n+        }\n+        if let Some(proc_macros) = self.proc_macros {\n+            db.set_proc_macros_with_durability(Arc::new(proc_macros), Durability::HIGH);\n         }\n     }\n }"}, {"sha": "5b11343173b300396535bbfd0a714ed642343220", "filename": "src/tools/rust-analyzer/crates/base-db/src/fixture.rs", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,24 +1,27 @@\n //! A set of high-level utility fixture methods to use in tests.\n-use std::{mem, str::FromStr, sync::Arc};\n+use std::{mem, str::FromStr, sync};\n \n use cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n use test_utils::{\n-    extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER, ESCAPED_CURSOR_MARKER,\n+    extract_range_or_offset, Fixture, FixtureWithProjectMeta, RangeOrOffset, CURSOR_MARKER,\n+    ESCAPED_CURSOR_MARKER,\n };\n+use triomphe::Arc;\n use tt::token_id::{Leaf, Subtree, TokenTree};\n use vfs::{file_set::FileSet, VfsPath};\n \n use crate::{\n     input::{CrateName, CrateOrigin, LangCrateOrigin},\n     Change, CrateDisplayName, CrateGraph, CrateId, Dependency, Edition, Env, FileId, FilePosition,\n-    FileRange, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, SourceDatabaseExt,\n-    SourceRoot, SourceRootId,\n+    FileRange, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, ProcMacros, ReleaseChannel,\n+    SourceDatabaseExt, SourceRoot, SourceRootId,\n };\n \n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n \n pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n+    #[track_caller]\n     fn with_single_file(ra_fixture: &str) -> (Self, FileId) {\n         let fixture = ChangeFixture::parse(ra_fixture);\n         let mut db = Self::default();\n@@ -27,6 +30,7 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n         (db, fixture.files[0])\n     }\n \n+    #[track_caller]\n     fn with_many_files(ra_fixture: &str) -> (Self, Vec<FileId>) {\n         let fixture = ChangeFixture::parse(ra_fixture);\n         let mut db = Self::default();\n@@ -35,6 +39,7 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n         (db, fixture.files)\n     }\n \n+    #[track_caller]\n     fn with_files(ra_fixture: &str) -> Self {\n         let fixture = ChangeFixture::parse(ra_fixture);\n         let mut db = Self::default();\n@@ -43,6 +48,7 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n         db\n     }\n \n+    #[track_caller]\n     fn with_files_extra_proc_macros(\n         ra_fixture: &str,\n         proc_macros: Vec<(String, ProcMacro)>,\n@@ -54,18 +60,21 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n         db\n     }\n \n+    #[track_caller]\n     fn with_position(ra_fixture: &str) -> (Self, FilePosition) {\n         let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n         let offset = range_or_offset.expect_offset();\n         (db, FilePosition { file_id, offset })\n     }\n \n+    #[track_caller]\n     fn with_range(ra_fixture: &str) -> (Self, FileRange) {\n         let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n         let range = range_or_offset.expect_range();\n         (db, FileRange { file_id, range })\n     }\n \n+    #[track_caller]\n     fn with_range_or_offset(ra_fixture: &str) -> (Self, FileId, RangeOrOffset) {\n         let fixture = ChangeFixture::parse(ra_fixture);\n         let mut db = Self::default();\n@@ -100,9 +109,16 @@ impl ChangeFixture {\n \n     pub fn parse_with_proc_macros(\n         ra_fixture: &str,\n-        mut proc_macros: Vec<(String, ProcMacro)>,\n+        mut proc_macro_defs: Vec<(String, ProcMacro)>,\n     ) -> ChangeFixture {\n-        let (mini_core, proc_macro_names, fixture) = Fixture::parse(ra_fixture);\n+        let FixtureWithProjectMeta { fixture, mini_core, proc_macro_names, toolchain } =\n+            FixtureWithProjectMeta::parse(ra_fixture);\n+        let toolchain = toolchain\n+            .map(|it| {\n+                ReleaseChannel::from_str(&it)\n+                    .unwrap_or_else(|| panic!(\"unknown release channel found: {it}\"))\n+            })\n+            .unwrap_or(ReleaseChannel::Stable);\n         let mut change = Change::new();\n \n         let mut files = Vec::new();\n@@ -157,16 +173,16 @@ impl ChangeFixture {\n                     meta.edition,\n                     Some(crate_name.clone().into()),\n                     version,\n-                    meta.cfg.clone(),\n                     meta.cfg,\n+                    Default::default(),\n                     meta.env,\n-                    Ok(Vec::new()),\n                     false,\n                     origin,\n                     meta.target_data_layout\n                         .as_deref()\n                         .map(Arc::from)\n                         .ok_or_else(|| \"target_data_layout unset\".into()),\n+                    Some(toolchain),\n                 );\n                 let prev = crates.insert(crate_name.clone(), crate_id);\n                 assert!(prev.is_none());\n@@ -182,7 +198,7 @@ impl ChangeFixture {\n                 default_target_data_layout = meta.target_data_layout;\n             }\n \n-            change.change_file(file_id, Some(Arc::new(text)));\n+            change.change_file(file_id, Some(Arc::from(text)));\n             let path = VfsPath::new_virtual_path(meta.path);\n             file_set.insert(file_id, path);\n             files.push(file_id);\n@@ -197,15 +213,15 @@ impl ChangeFixture {\n                 Edition::CURRENT,\n                 Some(CrateName::new(\"test\").unwrap().into()),\n                 None,\n-                default_cfg.clone(),\n                 default_cfg,\n+                Default::default(),\n                 Env::default(),\n-                Ok(Vec::new()),\n                 false,\n-                CrateOrigin::CratesIo { repo: None, name: None },\n+                CrateOrigin::Local { repo: None, name: None },\n                 default_target_data_layout\n                     .map(|x| x.into())\n                     .ok_or_else(|| \"target_data_layout unset\".into()),\n+                Some(toolchain),\n             );\n         } else {\n             for (from, to, prelude) in crate_deps {\n@@ -232,7 +248,7 @@ impl ChangeFixture {\n             fs.insert(core_file, VfsPath::new_virtual_path(\"/sysroot/core/lib.rs\".to_string()));\n             roots.push(SourceRoot::new_library(fs));\n \n-            change.change_file(core_file, Some(Arc::new(mini_core.source_code())));\n+            change.change_file(core_file, Some(Arc::from(mini_core.source_code())));\n \n             let all_crates = crate_graph.crates_in_topological_order();\n \n@@ -241,13 +257,13 @@ impl ChangeFixture {\n                 Edition::Edition2021,\n                 Some(CrateDisplayName::from_canonical_name(\"core\".to_string())),\n                 None,\n-                CfgOptions::default(),\n-                CfgOptions::default(),\n+                Default::default(),\n+                Default::default(),\n                 Env::default(),\n-                Ok(Vec::new()),\n                 false,\n                 CrateOrigin::Lang(LangCrateOrigin::Core),\n                 target_layout.clone(),\n+                Some(toolchain),\n             );\n \n             for krate in all_crates {\n@@ -257,20 +273,21 @@ impl ChangeFixture {\n             }\n         }\n \n+        let mut proc_macros = ProcMacros::default();\n         if !proc_macro_names.is_empty() {\n             let proc_lib_file = file_id;\n             file_id.0 += 1;\n \n-            proc_macros.extend(default_test_proc_macros());\n-            let (proc_macro, source) = filter_test_proc_macros(&proc_macro_names, proc_macros);\n+            proc_macro_defs.extend(default_test_proc_macros());\n+            let (proc_macro, source) = filter_test_proc_macros(&proc_macro_names, proc_macro_defs);\n             let mut fs = FileSet::default();\n             fs.insert(\n                 proc_lib_file,\n                 VfsPath::new_virtual_path(\"/sysroot/proc_macros/lib.rs\".to_string()),\n             );\n             roots.push(SourceRoot::new_library(fs));\n \n-            change.change_file(proc_lib_file, Some(Arc::new(source)));\n+            change.change_file(proc_lib_file, Some(Arc::from(source)));\n \n             let all_crates = crate_graph.crates_in_topological_order();\n \n@@ -279,14 +296,15 @@ impl ChangeFixture {\n                 Edition::Edition2021,\n                 Some(CrateDisplayName::from_canonical_name(\"proc_macros\".to_string())),\n                 None,\n-                CfgOptions::default(),\n-                CfgOptions::default(),\n+                Default::default(),\n+                Default::default(),\n                 Env::default(),\n-                Ok(proc_macro),\n                 true,\n-                CrateOrigin::CratesIo { repo: None, name: None },\n+                CrateOrigin::Local { repo: None, name: None },\n                 target_layout,\n+                Some(toolchain),\n             );\n+            proc_macros.insert(proc_macros_crate, Ok(proc_macro));\n \n             for krate in all_crates {\n                 crate_graph\n@@ -305,6 +323,7 @@ impl ChangeFixture {\n         roots.push(root);\n         change.set_roots(roots);\n         change.set_crate_graph(crate_graph);\n+        change.set_proc_macros(proc_macros);\n \n         ChangeFixture { file_position, files, change }\n     }\n@@ -323,7 +342,7 @@ pub fn identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n             ProcMacro {\n                 name: \"identity\".into(),\n                 kind: crate::ProcMacroKind::Attr,\n-                expander: Arc::new(IdentityProcMacroExpander),\n+                expander: sync::Arc::new(IdentityProcMacroExpander),\n             },\n         ),\n         (\n@@ -337,7 +356,7 @@ pub fn derive_identity(item: TokenStream) -> TokenStream {\n             ProcMacro {\n                 name: \"DeriveIdentity\".into(),\n                 kind: crate::ProcMacroKind::CustomDerive,\n-                expander: Arc::new(IdentityProcMacroExpander),\n+                expander: sync::Arc::new(IdentityProcMacroExpander),\n             },\n         ),\n         (\n@@ -351,7 +370,7 @@ pub fn input_replace(attr: TokenStream, _item: TokenStream) -> TokenStream {\n             ProcMacro {\n                 name: \"input_replace\".into(),\n                 kind: crate::ProcMacroKind::Attr,\n-                expander: Arc::new(AttributeInputReplaceProcMacroExpander),\n+                expander: sync::Arc::new(AttributeInputReplaceProcMacroExpander),\n             },\n         ),\n         (\n@@ -365,7 +384,7 @@ pub fn mirror(input: TokenStream) -> TokenStream {\n             ProcMacro {\n                 name: \"mirror\".into(),\n                 kind: crate::ProcMacroKind::FuncLike,\n-                expander: Arc::new(MirrorProcMacroExpander),\n+                expander: sync::Arc::new(MirrorProcMacroExpander),\n             },\n         ),\n         (\n@@ -379,7 +398,7 @@ pub fn shorten(input: TokenStream) -> TokenStream {\n             ProcMacro {\n                 name: \"shorten\".into(),\n                 kind: crate::ProcMacroKind::FuncLike,\n-                expander: Arc::new(ShortenProcMacroExpander),\n+                expander: sync::Arc::new(ShortenProcMacroExpander),\n             },\n         ),\n     ]\n@@ -428,18 +447,17 @@ fn parse_crate(crate_str: String) -> (String, CrateOrigin, Option<String>) {\n         let (version, origin) = match b.split_once(':') {\n             Some((\"CratesIo\", data)) => match data.split_once(',') {\n                 Some((version, url)) => {\n-                    (version, CrateOrigin::CratesIo { repo: Some(url.to_owned()), name: None })\n+                    (version, CrateOrigin::Local { repo: Some(url.to_owned()), name: None })\n                 }\n                 _ => panic!(\"Bad crates.io parameter: {data}\"),\n             },\n             _ => panic!(\"Bad string for crate origin: {b}\"),\n         };\n         (a.to_owned(), origin, Some(version.to_string()))\n     } else {\n-        let crate_origin = match &*crate_str {\n-            \"std\" => CrateOrigin::Lang(LangCrateOrigin::Std),\n-            \"core\" => CrateOrigin::Lang(LangCrateOrigin::Core),\n-            _ => CrateOrigin::CratesIo { repo: None, name: None },\n+        let crate_origin = match LangCrateOrigin::from(&*crate_str) {\n+            LangCrateOrigin::Other => CrateOrigin::Local { repo: None, name: None },\n+            origin => CrateOrigin::Lang(origin),\n         };\n         (crate_str, crate_origin, None)\n     }"}, {"sha": "e8d521b42f868d0d6b3d2f15f3822d12a8facc3c", "filename": "src/tools/rust-analyzer/crates/base-db/src/input.rs", "status": "modified", "additions": 210, "deletions": 111, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -6,14 +6,20 @@\n //! actual IO. See `vfs` and `project_model` in the `rust-analyzer` crate for how\n //! actual IO is done and lowered to input.\n \n-use std::{fmt, ops, panic::RefUnwindSafe, str::FromStr, sync::Arc};\n+use std::{fmt, mem, ops, panic::RefUnwindSafe, str::FromStr, sync};\n \n use cfg::CfgOptions;\n-use rustc_hash::FxHashMap;\n-use stdx::hash::{NoHashHashMap, NoHashHashSet};\n+use la_arena::{Arena, Idx};\n+use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::SmolStr;\n+use triomphe::Arc;\n use tt::token_id::Subtree;\n-use vfs::{file_set::FileSet, AnchoredPath, FileId, VfsPath};\n+use vfs::{file_set::FileSet, AbsPathBuf, AnchoredPath, FileId, VfsPath};\n+\n+// Map from crate id to the name of the crate and path of the proc-macro. If the value is `None`,\n+// then the crate for the proc-macro hasn't been build yet as the build data is missing.\n+pub type ProcMacroPaths = FxHashMap<CrateId, Result<(Option<String>, AbsPathBuf), String>>;\n+pub type ProcMacros = FxHashMap<CrateId, ProcMacroLoadResult>;\n \n /// Files are grouped into source roots. A source root is a directory on the\n /// file systems which is watched for changes. Typically it corresponds to a\n@@ -79,17 +85,22 @@ impl SourceRoot {\n ///\n /// `CrateGraph` is `!Serialize` by design, see\n /// <https://github.com/rust-lang/rust-analyzer/blob/master/docs/dev/architecture.md#serialization>\n-#[derive(Debug, Clone, Default /* Serialize, Deserialize */)]\n+#[derive(Clone, Default)]\n pub struct CrateGraph {\n-    arena: NoHashHashMap<CrateId, CrateData>,\n+    arena: Arena<CrateData>,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct CrateId(pub u32);\n+impl fmt::Debug for CrateGraph {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_map()\n+            .entries(self.arena.iter().map(|(id, data)| (u32::from(id.into_raw()), data)))\n+            .finish()\n+    }\n+}\n \n-impl stdx::hash::NoHashHashable for CrateId {}\n+pub type CrateId = Idx<CrateData>;\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct CrateName(SmolStr);\n \n impl CrateName {\n@@ -130,8 +141,12 @@ impl ops::Deref for CrateName {\n /// Origin of the crates. It is used in emitting monikers.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum CrateOrigin {\n-    /// Crates that are from crates.io official registry,\n-    CratesIo { repo: Option<String>, name: Option<String> },\n+    /// Crates that are from the rustc workspace\n+    Rustc { name: String },\n+    /// Crates that are workspace members,\n+    Local { repo: Option<String>, name: Option<String> },\n+    /// Crates that are non member libraries.\n+    Library { repo: Option<String>, name: String },\n     /// Crates that are provided by the language, like std, core, proc-macro, ...\n     Lang(LangCrateOrigin),\n }\n@@ -173,7 +188,7 @@ impl fmt::Display for LangCrateOrigin {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct CrateDisplayName {\n     // The name we use to display various paths (with `_`).\n     crate_name: CrateName,\n@@ -249,10 +264,36 @@ pub type TargetLayoutLoadResult = Result<Arc<str>, Arc<str>>;\n pub struct ProcMacro {\n     pub name: SmolStr,\n     pub kind: ProcMacroKind,\n-    pub expander: Arc<dyn ProcMacroExpander>,\n+    pub expander: sync::Arc<dyn ProcMacroExpander>,\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub enum ReleaseChannel {\n+    Stable,\n+    Beta,\n+    Nightly,\n+}\n+\n+impl ReleaseChannel {\n+    pub fn as_str(self) -> &'static str {\n+        match self {\n+            ReleaseChannel::Stable => \"stable\",\n+            ReleaseChannel::Beta => \"beta\",\n+            ReleaseChannel::Nightly => \"nightly\",\n+        }\n+    }\n+\n+    pub fn from_str(str: &str) -> Option<Self> {\n+        Some(match str {\n+            \"\" => ReleaseChannel::Stable,\n+            \"nightly\" => ReleaseChannel::Nightly,\n+            _ if str.starts_with(\"beta\") => ReleaseChannel::Beta,\n+            _ => return None,\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub struct CrateData {\n     pub root_file_id: FileId,\n     pub edition: Edition,\n@@ -265,13 +306,15 @@ pub struct CrateData {\n     /// `Dependency` matters), this name should only be used for UI.\n     pub display_name: Option<CrateDisplayName>,\n     pub cfg_options: CfgOptions,\n-    pub potential_cfg_options: CfgOptions,\n-    pub target_layout: TargetLayoutLoadResult,\n+    /// The cfg options that could be used by the crate\n+    pub potential_cfg_options: Option<CfgOptions>,\n     pub env: Env,\n     pub dependencies: Vec<Dependency>,\n-    pub proc_macro: ProcMacroLoadResult,\n     pub origin: CrateOrigin,\n     pub is_proc_macro: bool,\n+    // FIXME: These things should not be per crate! These are more per workspace crate graph level things\n+    pub target_layout: TargetLayoutLoadResult,\n+    pub channel: Option<ReleaseChannel>,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -290,7 +333,7 @@ pub struct Env {\n     entries: FxHashMap<String, String>,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Dependency {\n     pub crate_id: CrateId,\n     pub name: CrateName,\n@@ -320,12 +363,12 @@ impl CrateGraph {\n         display_name: Option<CrateDisplayName>,\n         version: Option<String>,\n         cfg_options: CfgOptions,\n-        potential_cfg_options: CfgOptions,\n+        potential_cfg_options: Option<CfgOptions>,\n         env: Env,\n-        proc_macro: ProcMacroLoadResult,\n         is_proc_macro: bool,\n         origin: CrateOrigin,\n         target_layout: Result<Arc<str>, Arc<str>>,\n+        channel: Option<ReleaseChannel>,\n     ) -> CrateId {\n         let data = CrateData {\n             root_file_id,\n@@ -335,16 +378,44 @@ impl CrateGraph {\n             cfg_options,\n             potential_cfg_options,\n             env,\n-            proc_macro,\n             dependencies: Vec::new(),\n             origin,\n             target_layout,\n             is_proc_macro,\n+            channel,\n         };\n-        let crate_id = CrateId(self.arena.len() as u32);\n-        let prev = self.arena.insert(crate_id, data);\n-        assert!(prev.is_none());\n-        crate_id\n+        self.arena.alloc(data)\n+    }\n+\n+    /// Remove the crate from crate graph. If any crates depend on this crate, the dependency would be replaced\n+    /// with the second input.\n+    pub fn remove_and_replace(\n+        &mut self,\n+        id: CrateId,\n+        replace_with: CrateId,\n+    ) -> Result<(), CyclicDependenciesError> {\n+        for (x, data) in self.arena.iter() {\n+            if x == id {\n+                continue;\n+            }\n+            for edge in &data.dependencies {\n+                if edge.crate_id == id {\n+                    self.check_cycle_after_dependency(edge.crate_id, replace_with)?;\n+                }\n+            }\n+        }\n+        // if everything was ok, start to replace\n+        for (x, data) in self.arena.iter_mut() {\n+            if x == id {\n+                continue;\n+            }\n+            for edge in &mut data.dependencies {\n+                if edge.crate_id == id {\n+                    edge.crate_id = replace_with;\n+                }\n+            }\n+        }\n+        Ok(())\n     }\n \n     pub fn add_dep(\n@@ -354,17 +425,26 @@ impl CrateGraph {\n     ) -> Result<(), CyclicDependenciesError> {\n         let _p = profile::span(\"add_dep\");\n \n-        // Check if adding a dep from `from` to `to` creates a cycle. To figure\n-        // that out, look for a  path in the *opposite* direction, from `to` to\n-        // `from`.\n-        if let Some(path) = self.find_path(&mut NoHashHashSet::default(), dep.crate_id, from) {\n+        self.check_cycle_after_dependency(from, dep.crate_id)?;\n+\n+        self.arena[from].add_dep(dep);\n+        Ok(())\n+    }\n+\n+    /// Check if adding a dep from `from` to `to` creates a cycle. To figure\n+    /// that out, look for a  path in the *opposite* direction, from `to` to\n+    /// `from`.\n+    fn check_cycle_after_dependency(\n+        &self,\n+        from: CrateId,\n+        to: CrateId,\n+    ) -> Result<(), CyclicDependenciesError> {\n+        if let Some(path) = self.find_path(&mut FxHashSet::default(), to, from) {\n             let path = path.into_iter().map(|it| (it, self[it].display_name.clone())).collect();\n             let err = CyclicDependenciesError { path };\n-            assert!(err.from().0 == from && err.to().0 == dep.crate_id);\n+            assert!(err.from().0 == from && err.to().0 == to);\n             return Err(err);\n         }\n-\n-        self.arena.get_mut(&from).unwrap().add_dep(dep);\n         Ok(())\n     }\n \n@@ -373,14 +453,14 @@ impl CrateGraph {\n     }\n \n     pub fn iter(&self) -> impl Iterator<Item = CrateId> + '_ {\n-        self.arena.keys().copied()\n+        self.arena.iter().map(|(idx, _)| idx)\n     }\n \n     /// Returns an iterator over all transitive dependencies of the given crate,\n     /// including the crate itself.\n     pub fn transitive_deps(&self, of: CrateId) -> impl Iterator<Item = CrateId> {\n         let mut worklist = vec![of];\n-        let mut deps = NoHashHashSet::default();\n+        let mut deps = FxHashSet::default();\n \n         while let Some(krate) = worklist.pop() {\n             if !deps.insert(krate) {\n@@ -397,11 +477,11 @@ impl CrateGraph {\n     /// including the crate itself.\n     pub fn transitive_rev_deps(&self, of: CrateId) -> impl Iterator<Item = CrateId> {\n         let mut worklist = vec![of];\n-        let mut rev_deps = NoHashHashSet::default();\n+        let mut rev_deps = FxHashSet::default();\n         rev_deps.insert(of);\n \n-        let mut inverted_graph = NoHashHashMap::<_, Vec<_>>::default();\n-        self.arena.iter().for_each(|(&krate, data)| {\n+        let mut inverted_graph = FxHashMap::<_, Vec<_>>::default();\n+        self.arena.iter().for_each(|(krate, data)| {\n             data.dependencies\n                 .iter()\n                 .for_each(|dep| inverted_graph.entry(dep.crate_id).or_default().push(krate))\n@@ -424,17 +504,17 @@ impl CrateGraph {\n     /// come before the crate itself).\n     pub fn crates_in_topological_order(&self) -> Vec<CrateId> {\n         let mut res = Vec::new();\n-        let mut visited = NoHashHashSet::default();\n+        let mut visited = FxHashSet::default();\n \n-        for krate in self.arena.keys().copied() {\n+        for krate in self.iter() {\n             go(self, &mut visited, &mut res, krate);\n         }\n \n         return res;\n \n         fn go(\n             graph: &CrateGraph,\n-            visited: &mut NoHashHashSet<CrateId>,\n+            visited: &mut FxHashSet<CrateId>,\n             res: &mut Vec<CrateId>,\n             source: CrateId,\n         ) {\n@@ -450,31 +530,56 @@ impl CrateGraph {\n \n     // FIXME: this only finds one crate with the given root; we could have multiple\n     pub fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n-        let (&crate_id, _) =\n+        let (crate_id, _) =\n             self.arena.iter().find(|(_crate_id, data)| data.root_file_id == file_id)?;\n         Some(crate_id)\n     }\n \n+    pub fn sort_deps(&mut self) {\n+        self.arena\n+            .iter_mut()\n+            .for_each(|(_, data)| data.dependencies.sort_by_key(|dep| dep.crate_id));\n+    }\n+\n     /// Extends this crate graph by adding a complete disjoint second crate\n-    /// graph.\n+    /// graph and adjust the ids in the [`ProcMacroPaths`] accordingly.\n     ///\n-    /// The ids of the crates in the `other` graph are shifted by the return\n-    /// amount.\n-    pub fn extend(&mut self, other: CrateGraph) -> u32 {\n-        let start = self.arena.len() as u32;\n-        self.arena.extend(other.arena.into_iter().map(|(id, mut data)| {\n-            let new_id = id.shift(start);\n-            for dep in &mut data.dependencies {\n-                dep.crate_id = dep.crate_id.shift(start);\n+    /// This will deduplicate the crates of the graph where possible.\n+    /// Note that for deduplication to fully work, `self`'s crate dependencies must be sorted by crate id.\n+    /// If the crate dependencies were sorted, the resulting graph from this `extend` call will also have the crate dependencies sorted.\n+    pub fn extend(&mut self, mut other: CrateGraph, proc_macros: &mut ProcMacroPaths) {\n+        let topo = other.crates_in_topological_order();\n+        let mut id_map: FxHashMap<CrateId, CrateId> = FxHashMap::default();\n+\n+        for topo in topo {\n+            let crate_data = &mut other.arena[topo];\n+            crate_data.dependencies.iter_mut().for_each(|dep| dep.crate_id = id_map[&dep.crate_id]);\n+            crate_data.dependencies.sort_by_key(|dep| dep.crate_id);\n+\n+            let res = self.arena.iter().find_map(\n+                |(id, data)| {\n+                    if data == crate_data {\n+                        Some(id)\n+                    } else {\n+                        None\n+                    }\n+                },\n+            );\n+            if let Some(res) = res {\n+                id_map.insert(topo, res);\n+            } else {\n+                let id = self.arena.alloc(crate_data.clone());\n+                id_map.insert(topo, id);\n             }\n-            (new_id, data)\n-        }));\n-        start\n+        }\n+\n+        *proc_macros =\n+            mem::take(proc_macros).into_iter().map(|(id, macros)| (id_map[&id], macros)).collect();\n     }\n \n     fn find_path(\n         &self,\n-        visited: &mut NoHashHashSet<CrateId>,\n+        visited: &mut FxHashSet<CrateId>,\n         from: CrateId,\n         to: CrateId,\n     ) -> Option<Vec<CrateId>> {\n@@ -500,14 +605,14 @@ impl CrateGraph {\n     // Work around for https://github.com/rust-lang/rust-analyzer/issues/6038.\n     // As hacky as it gets.\n     pub fn patch_cfg_if(&mut self) -> bool {\n-        let cfg_if = self.hacky_find_crate(\"cfg_if\");\n-        let std = self.hacky_find_crate(\"std\");\n+        // we stupidly max by version in an attempt to have all duplicated std's depend on the same cfg_if so that deduplication still works\n+        let cfg_if =\n+            self.hacky_find_crate(\"cfg_if\").max_by_key(|&it| self.arena[it].version.clone());\n+        let std = self.hacky_find_crate(\"std\").next();\n         match (cfg_if, std) {\n             (Some(cfg_if), Some(std)) => {\n-                self.arena.get_mut(&cfg_if).unwrap().dependencies.clear();\n-                self.arena\n-                    .get_mut(&std)\n-                    .unwrap()\n+                self.arena[cfg_if].dependencies.clear();\n+                self.arena[std]\n                     .dependencies\n                     .push(Dependency::new(CrateName::new(\"cfg_if\").unwrap(), cfg_if));\n                 true\n@@ -516,21 +621,15 @@ impl CrateGraph {\n         }\n     }\n \n-    fn hacky_find_crate(&self, display_name: &str) -> Option<CrateId> {\n-        self.iter().find(|it| self[*it].display_name.as_deref() == Some(display_name))\n+    fn hacky_find_crate<'a>(&'a self, display_name: &'a str) -> impl Iterator<Item = CrateId> + 'a {\n+        self.iter().filter(move |it| self[*it].display_name.as_deref() == Some(display_name))\n     }\n }\n \n impl ops::Index<CrateId> for CrateGraph {\n     type Output = CrateData;\n     fn index(&self, crate_id: CrateId) -> &CrateData {\n-        &self.arena[&crate_id]\n-    }\n-}\n-\n-impl CrateId {\n-    fn shift(self, amount: u32) -> CrateId {\n-        CrateId(self.0 + amount)\n+        &self.arena[crate_id]\n     }\n }\n \n@@ -632,7 +731,7 @@ impl fmt::Display for CyclicDependenciesError {\n mod tests {\n     use crate::CrateOrigin;\n \n-    use super::{CfgOptions, CrateGraph, CrateName, Dependency, Edition::Edition2018, Env, FileId};\n+    use super::{CrateGraph, CrateName, Dependency, Edition::Edition2018, Env, FileId};\n \n     #[test]\n     fn detect_cyclic_dependency_indirect() {\n@@ -642,39 +741,39 @@ mod tests {\n             Edition2018,\n             None,\n             None,\n-            CfgOptions::default(),\n-            CfgOptions::default(),\n+            Default::default(),\n+            Default::default(),\n             Env::default(),\n-            Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None, name: None },\n+            CrateOrigin::Local { repo: None, name: None },\n             Err(\"\".into()),\n+            None,\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n             Edition2018,\n             None,\n             None,\n-            CfgOptions::default(),\n-            CfgOptions::default(),\n+            Default::default(),\n+            Default::default(),\n             Env::default(),\n-            Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None, name: None },\n+            CrateOrigin::Local { repo: None, name: None },\n             Err(\"\".into()),\n+            None,\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n             Edition2018,\n             None,\n             None,\n-            CfgOptions::default(),\n-            CfgOptions::default(),\n+            Default::default(),\n+            Default::default(),\n             Env::default(),\n-            Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None, name: None },\n+            CrateOrigin::Local { repo: None, name: None },\n             Err(\"\".into()),\n+            None,\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -695,26 +794,26 @@ mod tests {\n             Edition2018,\n             None,\n             None,\n-            CfgOptions::default(),\n-            CfgOptions::default(),\n+            Default::default(),\n+            Default::default(),\n             Env::default(),\n-            Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None, name: None },\n+            CrateOrigin::Local { repo: None, name: None },\n             Err(\"\".into()),\n+            None,\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n             Edition2018,\n             None,\n             None,\n-            CfgOptions::default(),\n-            CfgOptions::default(),\n+            Default::default(),\n+            Default::default(),\n             Env::default(),\n-            Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None, name: None },\n+            CrateOrigin::Local { repo: None, name: None },\n             Err(\"\".into()),\n+            None,\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -732,39 +831,39 @@ mod tests {\n             Edition2018,\n             None,\n             None,\n-            CfgOptions::default(),\n-            CfgOptions::default(),\n+            Default::default(),\n+            Default::default(),\n             Env::default(),\n-            Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None, name: None },\n+            CrateOrigin::Local { repo: None, name: None },\n             Err(\"\".into()),\n+            None,\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n             Edition2018,\n             None,\n             None,\n-            CfgOptions::default(),\n-            CfgOptions::default(),\n+            Default::default(),\n+            Default::default(),\n             Env::default(),\n-            Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None, name: None },\n+            CrateOrigin::Local { repo: None, name: None },\n             Err(\"\".into()),\n+            None,\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n             Edition2018,\n             None,\n             None,\n-            CfgOptions::default(),\n-            CfgOptions::default(),\n+            Default::default(),\n+            Default::default(),\n             Env::default(),\n-            Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None, name: None },\n+            CrateOrigin::Local { repo: None, name: None },\n             Err(\"\".into()),\n+            None,\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -782,26 +881,26 @@ mod tests {\n             Edition2018,\n             None,\n             None,\n-            CfgOptions::default(),\n-            CfgOptions::default(),\n+            Default::default(),\n+            Default::default(),\n             Env::default(),\n-            Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None, name: None },\n+            CrateOrigin::Local { repo: None, name: None },\n             Err(\"\".into()),\n+            None,\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n             Edition2018,\n             None,\n             None,\n-            CfgOptions::default(),\n-            CfgOptions::default(),\n+            Default::default(),\n+            Default::default(),\n             Env::default(),\n-            Ok(Vec::new()),\n             false,\n-            CrateOrigin::CratesIo { repo: None, name: None },\n+            CrateOrigin::Local { repo: None, name: None },\n             Err(\"\".into()),\n+            None,\n         );\n         assert!(graph\n             .add_dep("}, {"sha": "af204e44e6ee19ca4a87da21d77aecf9ae3d544a", "filename": "src/tools/rust-analyzer/crates/base-db/src/lib.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -6,18 +6,19 @@ mod input;\n mod change;\n pub mod fixture;\n \n-use std::{panic, sync::Arc};\n+use std::panic;\n \n-use stdx::hash::NoHashHashSet;\n+use rustc_hash::FxHashSet;\n use syntax::{ast, Parse, SourceFile, TextRange, TextSize};\n+use triomphe::Arc;\n \n pub use crate::{\n     change::Change,\n     input::{\n         CrateData, CrateDisplayName, CrateGraph, CrateId, CrateName, CrateOrigin, Dependency,\n         Edition, Env, LangCrateOrigin, ProcMacro, ProcMacroExpander, ProcMacroExpansionError,\n-        ProcMacroId, ProcMacroKind, ProcMacroLoadResult, SourceRoot, SourceRootId,\n-        TargetLayoutLoadResult,\n+        ProcMacroId, ProcMacroKind, ProcMacroLoadResult, ProcMacroPaths, ProcMacros,\n+        ReleaseChannel, SourceRoot, SourceRootId, TargetLayoutLoadResult,\n     },\n };\n pub use salsa::{self, Cancelled};\n@@ -53,13 +54,13 @@ pub struct FileRange {\n     pub range: TextRange,\n }\n \n-pub const DEFAULT_LRU_CAP: usize = 128;\n+pub const DEFAULT_PARSE_LRU_CAP: usize = 128;\n \n pub trait FileLoader {\n     /// Text of the file.\n-    fn file_text(&self, file_id: FileId) -> Arc<String>;\n+    fn file_text(&self, file_id: FileId) -> Arc<str>;\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId>;\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>>;\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>>;\n }\n \n /// Database which stores all significant input facts: source code and project\n@@ -73,6 +74,10 @@ pub trait SourceDatabase: FileLoader + std::fmt::Debug {\n     /// The crate graph.\n     #[salsa::input]\n     fn crate_graph(&self) -> Arc<CrateGraph>;\n+\n+    /// The crate graph.\n+    #[salsa::input]\n+    fn proc_macros(&self) -> Arc<ProcMacros>;\n }\n \n fn parse_query(db: &dyn SourceDatabase, file_id: FileId) -> Parse<ast::SourceFile> {\n@@ -86,7 +91,7 @@ fn parse_query(db: &dyn SourceDatabase, file_id: FileId) -> Parse<ast::SourceFil\n #[salsa::query_group(SourceDatabaseExtStorage)]\n pub trait SourceDatabaseExt: SourceDatabase {\n     #[salsa::input]\n-    fn file_text(&self, file_id: FileId) -> Arc<String>;\n+    fn file_text(&self, file_id: FileId) -> Arc<str>;\n     /// Path to a file, relative to the root of its source root.\n     /// Source root of the file.\n     #[salsa::input]\n@@ -95,10 +100,10 @@ pub trait SourceDatabaseExt: SourceDatabase {\n     #[salsa::input]\n     fn source_root(&self, id: SourceRootId) -> Arc<SourceRoot>;\n \n-    fn source_root_crates(&self, id: SourceRootId) -> Arc<NoHashHashSet<CrateId>>;\n+    fn source_root_crates(&self, id: SourceRootId) -> Arc<FxHashSet<CrateId>>;\n }\n \n-fn source_root_crates(db: &dyn SourceDatabaseExt, id: SourceRootId) -> Arc<NoHashHashSet<CrateId>> {\n+fn source_root_crates(db: &dyn SourceDatabaseExt, id: SourceRootId) -> Arc<FxHashSet<CrateId>> {\n     let graph = db.crate_graph();\n     let res = graph\n         .iter()\n@@ -114,7 +119,7 @@ fn source_root_crates(db: &dyn SourceDatabaseExt, id: SourceRootId) -> Arc<NoHas\n pub struct FileLoaderDelegate<T>(pub T);\n \n impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n-    fn file_text(&self, file_id: FileId) -> Arc<String> {\n+    fn file_text(&self, file_id: FileId) -> Arc<str> {\n         SourceDatabaseExt::file_text(self.0, file_id)\n     }\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n@@ -124,7 +129,7 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n         source_root.resolve_path(path)\n     }\n \n-    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         let _p = profile::span(\"relevant_crates\");\n         let source_root = self.0.file_source_root(file_id);\n         self.0.source_root_crates(source_root)"}, {"sha": "495119d5519c347bbf76de046397b1d51c9b760b", "filename": "src/tools/rust-analyzer/crates/cfg/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Flib.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -86,7 +86,7 @@ impl CfgOptions {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Default, Clone, Debug, PartialEq, Eq)]\n pub struct CfgDiff {\n     // Invariants: No duplicates, no atom that's both in `enable` and `disable`.\n     enable: Vec<CfgAtom>,"}, {"sha": "3f6671b1c43dd96f40c000fb244f247299c68bb6", "filename": "src/tools/rust-analyzer/crates/flycheck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -16,9 +16,8 @@ crossbeam-channel = \"0.5.5\"\n tracing = \"0.1.37\"\n cargo_metadata = \"0.15.0\"\n rustc-hash = \"1.1.0\"\n-serde = { version = \"1.0.137\", features = [\"derive\"] }\n-serde_json = \"1.0.86\"\n-jod-thread = \"0.1.2\"\n+serde_json.workspace = true\n+serde.workspace = true\n command-group = \"2.0.1\"\n \n # local deps"}, {"sha": "fbb943ccb99ddb78664ff6b3a60ef156eb2ff800", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -77,7 +77,7 @@ impl fmt::Display for FlycheckConfig {\n pub struct FlycheckHandle {\n     // XXX: drop order is significant\n     sender: Sender<StateChange>,\n-    _thread: jod_thread::JoinHandle,\n+    _thread: stdx::thread::JoinHandle,\n     id: usize,\n }\n \n@@ -90,7 +90,7 @@ impl FlycheckHandle {\n     ) -> FlycheckHandle {\n         let actor = FlycheckActor::new(id, sender, config, workspace_root);\n         let (sender, receiver) = unbounded::<StateChange>();\n-        let thread = jod_thread::Builder::new()\n+        let thread = stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker)\n             .name(\"Flycheck\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");\n@@ -395,7 +395,7 @@ struct CargoHandle {\n     /// The handle to the actual cargo process. As we cannot cancel directly from with\n     /// a read syscall dropping and therefore terminating the process is our best option.\n     child: JodGroupChild,\n-    thread: jod_thread::JoinHandle<io::Result<(bool, String)>>,\n+    thread: stdx::thread::JoinHandle<io::Result<(bool, String)>>,\n     receiver: Receiver<CargoMessage>,\n }\n \n@@ -409,7 +409,7 @@ impl CargoHandle {\n \n         let (sender, receiver) = unbounded();\n         let actor = CargoActor::new(sender, stdout, stderr);\n-        let thread = jod_thread::Builder::new()\n+        let thread = stdx::thread::Builder::new(stdx::thread::ThreadIntent::Worker)\n             .name(\"CargoHandle\".to_owned())\n             .spawn(move || actor.run())\n             .expect(\"failed to spawn thread\");\n@@ -485,7 +485,7 @@ impl CargoActor {\n \n             error.push_str(line);\n             error.push('\\n');\n-            return false;\n+            false\n         };\n         let output = streaming_output(\n             self.stdout,"}, {"sha": "83c7051646ed834cdd423b893c1bf428774d9096", "filename": "src/tools/rust-analyzer/crates/hir-def/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -14,7 +14,7 @@ doctest = false\n [dependencies]\n anymap = \"1.0.0-beta.2\"\n arrayvec = \"0.7.2\"\n-bitflags = \"1.3.2\"\n+bitflags = \"2.1.0\"\n cov-mark = \"2.0.0-pre.1\"\n # We need to freeze the version of the crate, as the raw-api feature is considered unstable\n dashmap = { version = \"=5.4.0\", features = [\"raw-api\"] }\n@@ -29,6 +29,7 @@ once_cell = \"1.17.0\"\n rustc-hash = \"1.1.0\"\n smallvec.workspace = true\n tracing = \"0.1.35\"\n+triomphe.workspace = true\n \n rustc_abi = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_abi\", default-features = false }\n rustc_index = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_index\", default-features = false }"}, {"sha": "bab3bbc2329a95f8ff1bdb2614f43906c37ddd79", "filename": "src/tools/rust-analyzer/crates/hir-def/src/attr.rs", "status": "modified", "additions": 197, "deletions": 44, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,6 +1,11 @@\n //! A higher level attributes based on TokenTree, with also some shortcuts.\n \n-use std::{hash::Hash, ops, sync::Arc};\n+pub mod builtin;\n+\n+#[cfg(test)]\n+mod tests;\n+\n+use std::{hash::Hash, ops};\n \n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n@@ -16,14 +21,16 @@ use syntax::{\n     ast::{self, HasAttrs, IsString},\n     AstPtr, AstToken, SmolStr, TextRange, TextSize,\n };\n+use triomphe::Arc;\n \n use crate::{\n     db::DefDatabase,\n     item_tree::{AttrOwner, Fields, ItemTreeId, ItemTreeNode},\n+    lang_item::LangItem,\n     nameres::{ModuleOrigin, ModuleSource},\n     src::{HasChildSource, HasSource},\n-    AdtId, AttrDefId, EnumId, GenericParamId, LocalEnumVariantId, LocalFieldId, Lookup, MacroId,\n-    VariantId,\n+    AdtId, AssocItemLoc, AttrDefId, EnumId, GenericParamId, ItemLoc, LocalEnumVariantId,\n+    LocalFieldId, Lookup, MacroId, VariantId,\n };\n \n /// Holds documentation\n@@ -88,6 +95,7 @@ impl Attrs {\n         db: &dyn DefDatabase,\n         e: EnumId,\n     ) -> Arc<ArenaMap<LocalEnumVariantId, Attrs>> {\n+        let _p = profile::span(\"variants_attrs_query\");\n         // FIXME: There should be some proper form of mapping between item tree enum variant ids and hir enum variant ids\n         let mut res = ArenaMap::default();\n \n@@ -114,6 +122,7 @@ impl Attrs {\n         db: &dyn DefDatabase,\n         v: VariantId,\n     ) -> Arc<ArenaMap<LocalFieldId, Attrs>> {\n+        let _p = profile::span(\"fields_attrs_query\");\n         // FIXME: There should be some proper form of mapping between item tree field ids and hir field ids\n         let mut res = ArenaMap::default();\n \n@@ -175,13 +184,13 @@ impl Attrs {\n \n         Arc::new(res)\n     }\n+}\n \n+impl Attrs {\n     pub fn by_key(&self, key: &'static str) -> AttrQuery<'_> {\n         AttrQuery { attrs: self, key }\n     }\n-}\n \n-impl Attrs {\n     pub fn cfg(&self) -> Option<CfgExpr> {\n         let mut cfgs = self.by_key(\"cfg\").tt_values().map(CfgExpr::parse);\n         let first = cfgs.next()?;\n@@ -193,6 +202,7 @@ impl Attrs {\n             None => Some(first),\n         }\n     }\n+\n     pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n         match self.cfg() {\n             None => true,\n@@ -204,6 +214,10 @@ impl Attrs {\n         self.by_key(\"lang\").string_value()\n     }\n \n+    pub fn lang_item(&self) -> Option<LangItem> {\n+        self.by_key(\"lang\").string_value().and_then(|it| LangItem::from_str(it))\n+    }\n+\n     pub fn docs(&self) -> Option<Documentation> {\n         let docs = self.by_key(\"doc\").attrs().filter_map(|attr| attr.string_value());\n         let indent = doc_indent(self);\n@@ -238,6 +252,14 @@ impl Attrs {\n         })\n     }\n \n+    pub fn doc_exprs(&self) -> impl Iterator<Item = DocExpr> + '_ {\n+        self.by_key(\"doc\").tt_values().map(DocExpr::parse)\n+    }\n+\n+    pub fn doc_aliases(&self) -> impl Iterator<Item = SmolStr> + '_ {\n+        self.doc_exprs().flat_map(|doc_expr| doc_expr.aliases().to_vec())\n+    }\n+\n     pub fn is_proc_macro(&self) -> bool {\n         self.by_key(\"proc_macro\").exists()\n     }\n@@ -249,10 +271,120 @@ impl Attrs {\n     pub fn is_proc_macro_derive(&self) -> bool {\n         self.by_key(\"proc_macro_derive\").exists()\n     }\n+\n+    pub fn is_unstable(&self) -> bool {\n+        self.by_key(\"unstable\").exists()\n+    }\n+}\n+\n+use std::slice::Iter as SliceIter;\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub enum DocAtom {\n+    /// eg. `#[doc(hidden)]`\n+    Flag(SmolStr),\n+    /// eg. `#[doc(alias = \"x\")]`\n+    ///\n+    /// Note that a key can have multiple values that are all considered \"active\" at the same time.\n+    /// For example, `#[doc(alias = \"x\")]` and `#[doc(alias = \"y\")]`.\n+    KeyValue { key: SmolStr, value: SmolStr },\n+}\n+\n+// Adapted from `CfgExpr` parsing code\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+// #[cfg_attr(test, derive(derive_arbitrary::Arbitrary))]\n+pub enum DocExpr {\n+    Invalid,\n+    /// eg. `#[doc(hidden)]`, `#[doc(alias = \"x\")]`\n+    Atom(DocAtom),\n+    /// eg. `#[doc(alias(\"x\", \"y\"))]`\n+    Alias(Vec<SmolStr>),\n+}\n+\n+impl From<DocAtom> for DocExpr {\n+    fn from(atom: DocAtom) -> Self {\n+        DocExpr::Atom(atom)\n+    }\n+}\n+\n+impl DocExpr {\n+    fn parse<S>(tt: &tt::Subtree<S>) -> DocExpr {\n+        next_doc_expr(&mut tt.token_trees.iter()).unwrap_or(DocExpr::Invalid)\n+    }\n+\n+    pub fn aliases(&self) -> &[SmolStr] {\n+        match self {\n+            DocExpr::Atom(DocAtom::KeyValue { key, value }) if key == \"alias\" => {\n+                std::slice::from_ref(value)\n+            }\n+            DocExpr::Alias(aliases) => aliases,\n+            _ => &[],\n+        }\n+    }\n+}\n+\n+fn next_doc_expr<S>(it: &mut SliceIter<'_, tt::TokenTree<S>>) -> Option<DocExpr> {\n+    let name = match it.next() {\n+        None => return None,\n+        Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) => ident.text.clone(),\n+        Some(_) => return Some(DocExpr::Invalid),\n+    };\n+\n+    // Peek\n+    let ret = match it.as_slice().first() {\n+        Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '=' => {\n+            match it.as_slice().get(1) {\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Literal(literal))) => {\n+                    it.next();\n+                    it.next();\n+                    // FIXME: escape? raw string?\n+                    let value =\n+                        SmolStr::new(literal.text.trim_start_matches('\"').trim_end_matches('\"'));\n+                    DocAtom::KeyValue { key: name, value }.into()\n+                }\n+                _ => return Some(DocExpr::Invalid),\n+            }\n+        }\n+        Some(tt::TokenTree::Subtree(subtree)) => {\n+            it.next();\n+            let subs = parse_comma_sep(subtree);\n+            match name.as_str() {\n+                \"alias\" => DocExpr::Alias(subs),\n+                _ => DocExpr::Invalid,\n+            }\n+        }\n+        _ => DocAtom::Flag(name).into(),\n+    };\n+\n+    // Eat comma separator\n+    if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = it.as_slice().first() {\n+        if punct.char == ',' {\n+            it.next();\n+        }\n+    }\n+    Some(ret)\n+}\n+\n+fn parse_comma_sep<S>(subtree: &tt::Subtree<S>) -> Vec<SmolStr> {\n+    subtree\n+        .token_trees\n+        .iter()\n+        .filter_map(|tt| match tt {\n+            tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => {\n+                // FIXME: escape? raw string?\n+                Some(SmolStr::new(lit.text.trim_start_matches('\"').trim_end_matches('\"')))\n+            }\n+            _ => None,\n+        })\n+        .collect()\n }\n \n impl AttrsWithOwner {\n-    pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Self {\n+    pub(crate) fn attrs_with_owner(db: &dyn DefDatabase, owner: AttrDefId) -> Self {\n+        Self { attrs: db.attrs(owner), owner }\n+    }\n+\n+    pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Attrs {\n+        let _p = profile::span(\"attrs_query\");\n         // FIXME: this should use `Trace` to avoid duplication in `source_map` below\n         let raw_attrs = match def {\n             AttrDefId::ModuleId(module) => {\n@@ -286,31 +418,29 @@ impl AttrsWithOwner {\n                 }\n             }\n             AttrDefId::FieldId(it) => {\n-                return Self { attrs: db.fields_attrs(it.parent)[it.local_id].clone(), owner: def };\n+                return db.fields_attrs(it.parent)[it.local_id].clone();\n             }\n             AttrDefId::EnumVariantId(it) => {\n-                return Self {\n-                    attrs: db.variants_attrs(it.parent)[it.local_id].clone(),\n-                    owner: def,\n-                };\n+                return db.variants_attrs(it.parent)[it.local_id].clone();\n             }\n+            // FIXME: DRY this up\n             AttrDefId::AdtId(it) => match it {\n-                AdtId::StructId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-                AdtId::EnumId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-                AdtId::UnionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                AdtId::StructId(it) => attrs_from_item_tree_loc(db, it),\n+                AdtId::EnumId(it) => attrs_from_item_tree_loc(db, it),\n+                AdtId::UnionId(it) => attrs_from_item_tree_loc(db, it),\n             },\n-            AttrDefId::TraitId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::TraitAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::TraitId(it) => attrs_from_item_tree_loc(db, it),\n+            AttrDefId::TraitAliasId(it) => attrs_from_item_tree_loc(db, it),\n             AttrDefId::MacroId(it) => match it {\n-                MacroId::Macro2Id(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-                MacroId::MacroRulesId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-                MacroId::ProcMacroId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                MacroId::Macro2Id(it) => attrs_from_item_tree(db, it.lookup(db).id),\n+                MacroId::MacroRulesId(it) => attrs_from_item_tree(db, it.lookup(db).id),\n+                MacroId::ProcMacroId(it) => attrs_from_item_tree(db, it.lookup(db).id),\n             },\n-            AttrDefId::ImplId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::ConstId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::StaticId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::FunctionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::TypeAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::ImplId(it) => attrs_from_item_tree_loc(db, it),\n+            AttrDefId::ConstId(it) => attrs_from_item_tree_assoc(db, it),\n+            AttrDefId::StaticId(it) => attrs_from_item_tree_assoc(db, it),\n+            AttrDefId::FunctionId(it) => attrs_from_item_tree_assoc(db, it),\n+            AttrDefId::TypeAliasId(it) => attrs_from_item_tree_assoc(db, it),\n             AttrDefId::GenericParamId(it) => match it {\n                 GenericParamId::ConstParamId(it) => {\n                     let src = it.parent().child_source(db);\n@@ -331,11 +461,11 @@ impl AttrsWithOwner {\n                     RawAttrs::from_attrs_owner(db.upcast(), src.with_value(&src.value[it.local_id]))\n                 }\n             },\n-            AttrDefId::ExternBlockId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::ExternBlockId(it) => attrs_from_item_tree_loc(db, it),\n         };\n \n         let attrs = raw_attrs.filter(db.upcast(), def.krate(db));\n-        Self { attrs: Attrs(attrs), owner: def }\n+        Attrs(attrs)\n     }\n \n     pub fn source_map(&self, db: &dyn DefDatabase) -> AttrSourceMap {\n@@ -371,36 +501,36 @@ impl AttrsWithOwner {\n             AttrDefId::FieldId(id) => {\n                 let map = db.fields_attrs_source_map(id.parent);\n                 let file_id = id.parent.file_id(db);\n-                let root = db.parse_or_expand(file_id).unwrap();\n+                let root = db.parse_or_expand(file_id);\n                 let owner = match &map[id.local_id] {\n                     Either::Left(it) => ast::AnyHasAttrs::new(it.to_node(&root)),\n                     Either::Right(it) => ast::AnyHasAttrs::new(it.to_node(&root)),\n                 };\n                 InFile::new(file_id, owner)\n             }\n             AttrDefId::AdtId(adt) => match adt {\n-                AdtId::StructId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-                AdtId::UnionId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-                AdtId::EnumId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+                AdtId::StructId(id) => any_has_attrs(db, id),\n+                AdtId::UnionId(id) => any_has_attrs(db, id),\n+                AdtId::EnumId(id) => any_has_attrs(db, id),\n             },\n-            AttrDefId::FunctionId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::FunctionId(id) => any_has_attrs(db, id),\n             AttrDefId::EnumVariantId(id) => {\n                 let map = db.variants_attrs_source_map(id.parent);\n                 let file_id = id.parent.lookup(db).id.file_id();\n-                let root = db.parse_or_expand(file_id).unwrap();\n+                let root = db.parse_or_expand(file_id);\n                 InFile::new(file_id, ast::AnyHasAttrs::new(map[id.local_id].to_node(&root)))\n             }\n-            AttrDefId::StaticId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-            AttrDefId::ConstId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-            AttrDefId::TraitId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-            AttrDefId::TraitAliasId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-            AttrDefId::TypeAliasId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::StaticId(id) => any_has_attrs(db, id),\n+            AttrDefId::ConstId(id) => any_has_attrs(db, id),\n+            AttrDefId::TraitId(id) => any_has_attrs(db, id),\n+            AttrDefId::TraitAliasId(id) => any_has_attrs(db, id),\n+            AttrDefId::TypeAliasId(id) => any_has_attrs(db, id),\n             AttrDefId::MacroId(id) => match id {\n-                MacroId::Macro2Id(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-                MacroId::MacroRulesId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-                MacroId::ProcMacroId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+                MacroId::Macro2Id(id) => any_has_attrs(db, id),\n+                MacroId::MacroRulesId(id) => any_has_attrs(db, id),\n+                MacroId::ProcMacroId(id) => any_has_attrs(db, id),\n             },\n-            AttrDefId::ImplId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::ImplId(id) => any_has_attrs(db, id),\n             AttrDefId::GenericParamId(id) => match id {\n                 GenericParamId::ConstParamId(id) => id\n                     .parent()\n@@ -415,7 +545,7 @@ impl AttrsWithOwner {\n                     .child_source(db)\n                     .map(|source| ast::AnyHasAttrs::new(source[id.local_id].clone())),\n             },\n-            AttrDefId::ExternBlockId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::ExternBlockId(id) => any_has_attrs(db, id),\n         };\n \n         AttrSourceMap::new(owner.as_ref().map(|node| node as &dyn HasAttrs))\n@@ -635,19 +765,42 @@ impl<'attr> AttrQuery<'attr> {\n                 .nth(2);\n \n             match name {\n-                Some(tt::TokenTree::Leaf(tt::Leaf::Literal(tt::Literal{ref text, ..}))) => Some(text),\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Literal(tt::Literal{ ref text, ..}))) => Some(text),\n                 _ => None\n             }\n         })\n     }\n }\n \n-fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase) -> RawAttrs {\n+fn any_has_attrs(\n+    db: &dyn DefDatabase,\n+    id: impl Lookup<Data = impl HasSource<Value = impl ast::HasAttrs>>,\n+) -> InFile<ast::AnyHasAttrs> {\n+    id.lookup(db).source(db).map(ast::AnyHasAttrs::new)\n+}\n+\n+fn attrs_from_item_tree<N: ItemTreeNode>(db: &dyn DefDatabase, id: ItemTreeId<N>) -> RawAttrs {\n     let tree = id.item_tree(db);\n     let mod_item = N::id_to_mod_item(id.value);\n     tree.raw_attrs(mod_item.into()).clone()\n }\n \n+fn attrs_from_item_tree_loc<N: ItemTreeNode>(\n+    db: &dyn DefDatabase,\n+    lookup: impl Lookup<Data = ItemLoc<N>>,\n+) -> RawAttrs {\n+    let id = lookup.lookup(db).id;\n+    attrs_from_item_tree(db, id)\n+}\n+\n+fn attrs_from_item_tree_assoc<N: ItemTreeNode>(\n+    db: &dyn DefDatabase,\n+    lookup: impl Lookup<Data = AssocItemLoc<N>>,\n+) -> RawAttrs {\n+    let id = lookup.lookup(db).id;\n+    attrs_from_item_tree(db, id)\n+}\n+\n pub(crate) fn variants_attrs_source_map(\n     db: &dyn DefDatabase,\n     def: EnumId,"}, {"sha": "cead64a33749fb14eee59c5585323d338394a9ef", "filename": "src/tools/rust-analyzer/crates/hir-def/src/attr/builtin.rs", "status": "renamed", "additions": 104, "deletions": 62, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr%2Fbuiltin.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -2,7 +2,7 @@\n //!\n //! The actual definitions were copied from rustc's `compiler/rustc_feature/src/builtin_attrs.rs`.\n //!\n-//! It was last synchronized with upstream commit c1a2db3372a4d6896744919284f3287650a38ab7.\n+//! It was last synchronized with upstream commit e29821ff85a2a3000d226f99f62f89464028d5d6.\n //!\n //! The macros were adjusted to only expand to the attribute name, since that is all we need to do\n //! name resolution, and `BUILTIN_ATTRIBUTES` is almost entirely unchanged from the original, to\n@@ -108,7 +108,7 @@ macro_rules! experimental {\n     };\n }\n \n-/// \"Inert\" built-in attributes that have a special meaning to rustc or rustdoc.\n+/// Attributes that have a special meaning to rustc or rustdoc.\n #[rustfmt::skip]\n pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n@@ -123,7 +123,7 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(ignore, Normal, template!(Word, NameValueStr: \"reason\"), WarnFollowing),\n     ungated!(\n         should_panic, Normal,\n-        template!(Word, List: r#\"expected = \"reason\"#, NameValueStr: \"reason\"), FutureWarnFollowing,\n+        template!(Word, List: r#\"expected = \"reason\"\"#, NameValueStr: \"reason\"), FutureWarnFollowing,\n     ),\n     // FIXME(Centril): This can be used on stable but shouldn't.\n     ungated!(reexport_test_harness_main, CrateLevel, template!(NameValueStr: \"name\"), ErrorFollowing),\n@@ -142,20 +142,24 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     // Lints:\n     ungated!(\n-        warn, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+        warn, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        DuplicatesOk, @only_local: true,\n     ),\n     ungated!(\n-        allow, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+        allow, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        DuplicatesOk, @only_local: true,\n     ),\n     gated!(\n         expect, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk,\n         lint_reasons, experimental!(expect)\n     ),\n     ungated!(\n-        forbid, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+        forbid, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        DuplicatesOk, @only_local: true,\n     ),\n     ungated!(\n-        deny, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+        deny, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        DuplicatesOk, @only_local: true,\n     ),\n     ungated!(must_use, Normal, template!(Word, NameValueStr: \"reason\"), FutureWarnFollowing),\n     gated!(\n@@ -181,16 +185,17 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ABI, linking, symbols, and FFI\n     ungated!(\n         link, Normal,\n-        template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ wasm_import_module = \"...\"\"#),\n+        template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ wasm_import_module = \"...\", /*opt*/ import_name_type = \"decorated|noprefix|undecorated\"\"#),\n         DuplicatesOk,\n     ),\n     ungated!(link_name, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(no_link, Normal, template!(Word), WarnFollowing),\n-    ungated!(repr, Normal, template!(List: \"C\"), DuplicatesOk),\n+    ungated!(repr, Normal, template!(List: \"C\"), DuplicatesOk, @only_local: true),\n     ungated!(export_name, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(link_section, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(no_mangle, Normal, template!(Word), WarnFollowing, @only_local: true),\n     ungated!(used, Normal, template!(Word, List: \"compiler|linker\"), WarnFollowing, @only_local: true),\n+    ungated!(link_ordinal, Normal, template!(List: \"ordinal\"), ErrorPreceding),\n \n     // Limits:\n     ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), FutureWarnFollowing),\n@@ -201,6 +206,7 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n \n     // Entry point:\n+    gated!(unix_sigpipe, Normal, template!(Word, NameValueStr: \"inherit|sig_ign|sig_dfl\"), ErrorFollowing, experimental!(unix_sigpipe)),\n     ungated!(start, Normal, template!(Word), WarnFollowing),\n     ungated!(no_start, CrateLevel, template!(Word), WarnFollowing),\n     ungated!(no_main, CrateLevel, template!(Word), WarnFollowing),\n@@ -222,11 +228,15 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(inline, Normal, template!(Word, List: \"always|never\"), FutureWarnFollowing, @only_local: true),\n     ungated!(cold, Normal, template!(Word), WarnFollowing, @only_local: true),\n     ungated!(no_builtins, CrateLevel, template!(Word), WarnFollowing),\n-    ungated!(target_feature, Normal, template!(List: r#\"enable = \"name\"\"#), DuplicatesOk),\n+    ungated!(\n+        target_feature, Normal, template!(List: r#\"enable = \"name\"\"#),\n+        DuplicatesOk, @only_local: true,\n+    ),\n     ungated!(track_caller, Normal, template!(Word), WarnFollowing),\n+    ungated!(instruction_set, Normal, template!(List: \"set\"), ErrorPreceding),\n     gated!(\n         no_sanitize, Normal,\n-        template!(List: \"address, memory, thread\"), DuplicatesOk,\n+        template!(List: \"address, kcfi, memory, thread\"), DuplicatesOk,\n         experimental!(no_sanitize)\n     ),\n     gated!(no_coverage, Normal, template!(Word), WarnFollowing, experimental!(no_coverage)),\n@@ -235,25 +245,23 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         doc, Normal, template!(List: \"hidden|inline|...\", NameValueStr: \"string\"), DuplicatesOk\n     ),\n \n+    // Debugging\n+    ungated!(\n+        debugger_visualizer, Normal,\n+        template!(List: r#\"natvis_file = \"...\", gdb_script_file = \"...\"\"#), DuplicatesOk\n+    ),\n+\n     // ==========================================================================\n     // Unstable attributes:\n     // ==========================================================================\n \n-    // RFC #3191: #[debugger_visualizer] support\n-    gated!(\n-        debugger_visualizer, Normal, template!(List: r#\"natvis_file = \"...\", gdb_script_file = \"...\"\"#),\n-        DuplicatesOk, experimental!(debugger_visualizer)\n-    ),\n-\n     // Linking:\n-    gated!(naked, Normal, template!(Word), WarnFollowing, @only_local: true, naked_functions, experimental!(naked)),\n     gated!(\n-        link_ordinal, Normal, template!(List: \"ordinal\"), ErrorPreceding, raw_dylib,\n-        experimental!(link_ordinal)\n+        naked, Normal, template!(Word), WarnFollowing, @only_local: true,\n+        naked_functions, experimental!(naked)\n     ),\n \n     // Plugins:\n-    // XXX Modified for use in rust-analyzer\n     // BuiltinAttribute {\n     //     name: sym::plugin,\n     //     only_local: false,\n@@ -270,10 +278,6 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     //         cfg_fn!(plugin)\n     //     ),\n     // },\n-    BuiltinAttribute {\n-        name: \"plugin\",\n-        template: template!(List: \"name\"),\n-    },\n \n     // Testing:\n     gated!(\n@@ -282,7 +286,8 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     // RFC #1268\n     gated!(\n-        marker, Normal, template!(Word), WarnFollowing, marker_trait_attr, experimental!(marker)\n+        marker, Normal, template!(Word), WarnFollowing, @only_local: true,\n+        marker_trait_attr, experimental!(marker)\n     ),\n     gated!(\n         thread_local, Normal, template!(Word), WarnFollowing,\n@@ -294,21 +299,12 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         optimize, Normal, template!(List: \"size|speed\"), ErrorPreceding, optimize_attribute,\n         experimental!(optimize),\n     ),\n-    // RFC 2867\n-    gated!(\n-        instruction_set, Normal, template!(List: \"set\"), ErrorPreceding,\n-        isa_attribute, experimental!(instruction_set)\n-    ),\n \n     gated!(\n         ffi_returns_twice, Normal, template!(Word), WarnFollowing, experimental!(ffi_returns_twice)\n     ),\n     gated!(ffi_pure, Normal, template!(Word), WarnFollowing, experimental!(ffi_pure)),\n     gated!(ffi_const, Normal, template!(Word), WarnFollowing, experimental!(ffi_const)),\n-    gated!(\n-        register_attr, CrateLevel, template!(List: \"attr1, attr2, ...\"), DuplicatesOk,\n-        experimental!(register_attr),\n-    ),\n     gated!(\n         register_tool, CrateLevel, template!(List: \"tool1, tool2, ...\"), DuplicatesOk,\n         experimental!(register_tool),\n@@ -321,7 +317,7 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // RFC 2632\n     gated!(\n         const_trait, Normal, template!(Word), WarnFollowing, const_trait_impl,\n-        \"`const` is a temporary placeholder for marking a trait that is suitable for `const` \\\n+        \"`const_trait` is a temporary placeholder for marking a trait that is suitable for `const` \\\n         `impls` and all default bodies as `const`, which may be removed or renamed in the \\\n         future.\"\n     ),\n@@ -331,22 +327,47 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         experimental!(deprecated_safe),\n     ),\n \n+    // `#[collapse_debuginfo]`\n+    gated!(\n+        collapse_debuginfo, Normal, template!(Word), WarnFollowing,\n+        experimental!(collapse_debuginfo)\n+    ),\n+\n+    // RFC 2397\n+    gated!(do_not_recommend, Normal, template!(Word), WarnFollowing, experimental!(do_not_recommend)),\n+\n+    // `#[cfi_encoding = \"\"]`\n+    gated!(\n+        cfi_encoding, Normal, template!(NameValueStr: \"encoding\"), ErrorPreceding,\n+        experimental!(cfi_encoding)\n+    ),\n+\n     // ==========================================================================\n     // Internal attributes: Stability, deprecation, and unsafe:\n     // ==========================================================================\n \n-    ungated!(feature, CrateLevel, template!(List: \"name1, name2, ...\"), DuplicatesOk),\n+    ungated!(\n+        feature, CrateLevel,\n+        template!(List: \"name1, name2, ...\"), DuplicatesOk, @only_local: true,\n+    ),\n     // DuplicatesOk since it has its own validation\n     ungated!(\n-        stable, Normal, template!(List: r#\"feature = \"name\", since = \"version\"\"#), DuplicatesOk,\n+        stable, Normal,\n+        template!(List: r#\"feature = \"name\", since = \"version\"\"#), DuplicatesOk, @only_local: true,\n     ),\n     ungated!(\n         unstable, Normal,\n         template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#), DuplicatesOk,\n     ),\n     ungated!(rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n-    ungated!(rustc_const_stable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n-    ungated!(rustc_safe_intrinsic, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n+    ungated!(\n+        rustc_const_stable, Normal,\n+        template!(List: r#\"feature = \"name\"\"#), DuplicatesOk, @only_local: true,\n+    ),\n+    ungated!(\n+        rustc_default_body_unstable, Normal,\n+        template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#), DuplicatesOk\n+    ),\n     gated!(\n         allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"), DuplicatesOk,\n         \"allow_internal_unstable side-steps feature gating and stability checks\",\n@@ -360,6 +381,10 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         allow_internal_unsafe, Normal, template!(Word), WarnFollowing,\n         \"allow_internal_unsafe side-steps the unsafe_code lint\",\n     ),\n+    ungated!(rustc_safe_intrinsic, Normal, template!(Word), DuplicatesOk),\n+    rustc_attr!(rustc_allowed_through_unstable_modules, Normal, template!(Word), WarnFollowing,\n+    \"rustc_allowed_through_unstable_modules special cases accidental stabilizations of stable items \\\n+    through unstable paths\"),\n \n     // ==========================================================================\n     // Internal attributes: Type system related:\n@@ -377,10 +402,9 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     rustc_attr!(rustc_allocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_nounwind, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n-    gated!(\n-        alloc_error_handler, Normal, template!(Word), WarnFollowing,\n-        experimental!(alloc_error_handler)\n-    ),\n+    rustc_attr!(rustc_reallocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n+    rustc_attr!(rustc_deallocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n+    rustc_attr!(rustc_allocator_zeroed, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     gated!(\n         default_lib_allocator, Normal, template!(Word), WarnFollowing, allocator_internals,\n         experimental!(default_lib_allocator),\n@@ -461,6 +485,12 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Used by the `rustc::untranslatable_diagnostic` and `rustc::diagnostic_outside_of_impl` lints\n     // to assist in changes to diagnostic APIs.\n     rustc_attr!(rustc_lint_diagnostics, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE),\n+    // Used by the `rustc::bad_opt_access` lint to identify `DebuggingOptions` and `CodegenOptions`\n+    // types (as well as any others in future).\n+    rustc_attr!(rustc_lint_opt_ty, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE),\n+    // Used by the `rustc::bad_opt_access` lint on fields\n+    // types (as well as any others in future).\n+    rustc_attr!(rustc_lint_opt_deny_field_access, Normal, template!(List: \"message\"), WarnFollowing, INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Const related:\n@@ -504,18 +534,25 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         \"language items are subject to change\",\n     ),\n     rustc_attr!(\n-        rustc_pass_by_value, Normal,\n-        template!(Word), ErrorFollowing,\n+        rustc_pass_by_value, Normal, template!(Word), ErrorFollowing,\n         \"#[rustc_pass_by_value] is used to mark types that must be passed by value instead of reference.\"\n     ),\n     rustc_attr!(\n         rustc_coherence_is_core, AttributeType::CrateLevel, template!(Word), ErrorFollowing, @only_local: true,\n         \"#![rustc_coherence_is_core] allows inherent methods on builtin types, only intended to be used in `core`.\"\n     ),\n+    rustc_attr!(\n+        rustc_coinductive, AttributeType::Normal, template!(Word), WarnFollowing, @only_local: true,\n+        \"#![rustc_coinductive] changes a trait to be coinductive, allowing cycles in the trait solver.\"\n+    ),\n     rustc_attr!(\n         rustc_allow_incoherent_impl, AttributeType::Normal, template!(Word), ErrorFollowing, @only_local: true,\n         \"#[rustc_allow_incoherent_impl] has to be added to all impl items of an incoherent inherent impl.\"\n     ),\n+    rustc_attr!(\n+        rustc_deny_explicit_impl, AttributeType::Normal, template!(Word), ErrorFollowing, @only_local: false,\n+        \"#[rustc_deny_explicit_impl] enforces that a trait can have no user-provided impls\"\n+    ),\n     rustc_attr!(\n         rustc_has_incoherent_inherent_impls, AttributeType::Normal, template!(Word), ErrorFollowing,\n         \"#[rustc_has_incoherent_inherent_impls] allows the addition of incoherent inherent impls for \\\n@@ -527,24 +564,20 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         and it is only intended to be used in `alloc`.\"\n     ),\n \n-    // modified for r-a\n-    // BuiltinAttribute {\n-    //     name: sym::rustc_diagnostic_item,\n-    //     // FIXME: This can be `true` once we always use `tcx.is_diagnostic_item`.\n-    //     only_local: false,\n-    //     type_: Normal,\n-    //     template: template!(NameValueStr: \"name\"),\n-    //     duplicates: ErrorFollowing,\n-    //     gate: Gated(\n-    //         Stability::Unstable,\n-    //         sym::rustc_attrs,\n-    //         \"diagnostic items compiler internal support for linting\",\n-    //         cfg_fn!(rustc_attrs),\n-    //     ),\n-    // },\n     BuiltinAttribute {\n+        // name: sym::rustc_diagnostic_item,\n         name: \"rustc_diagnostic_item\",\n+        // FIXME: This can be `true` once we always use `tcx.is_diagnostic_item`.\n+        // only_local: false,\n+        // type_: Normal,\n         template: template!(NameValueStr: \"name\"),\n+        // duplicates: ErrorFollowing,\n+        // gate: Gated(\n+            // Stability::Unstable,\n+            // sym::rustc_attrs,\n+            // \"diagnostic items compiler internal support for linting\",\n+            // cfg_fn!(rustc_attrs),\n+        // ),\n     },\n     gated!(\n         // Used in resolve:\n@@ -568,7 +601,7 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n          for reserving for `for<T> From<!> for T` impl\"\n     ),\n     rustc_attr!(\n-        rustc_test_marker, Normal, template!(Word), WarnFollowing,\n+        rustc_test_marker, Normal, template!(NameValueStr: \"name\"), WarnFollowing,\n         \"the `#[rustc_test_marker]` attribute is used internally to track tests\",\n     ),\n     rustc_attr!(\n@@ -594,11 +627,16 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         definition of a trait, it's currently in experimental form and should be changed before \\\n         being exposed outside of the std\"\n     ),\n+    rustc_attr!(\n+        rustc_doc_primitive, Normal, template!(NameValueStr: \"primitive name\"), ErrorFollowing,\n+        r#\"`rustc_doc_primitive` is a rustc internal attribute\"#,\n+    ),\n \n     // ==========================================================================\n     // Internal attributes, Testing:\n     // ==========================================================================\n \n+    rustc_attr!(TEST, rustc_effective_visibility, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_outlives, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_insignificant_dtor, Normal, template!(Word), WarnFollowing),\n@@ -639,6 +677,10 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_polymorphize_error, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_def_path, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_mir, Normal, template!(List: \"arg1, arg2, ...\"), DuplicatesOk),\n+    gated!(\n+        custom_mir, Normal, template!(List: r#\"dialect = \"...\", phase = \"...\"\"#),\n+        ErrorFollowing, \"the `#[custom_mir]` attribute is just used for the Rust test suite\",\n+    ),\n     rustc_attr!(TEST, rustc_dump_program_clauses, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_dump_env_program_clauses, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_object_lifetime_default, Normal, template!(Word), WarnFollowing),", "previous_filename": "src/tools/rust-analyzer/crates/hir-def/src/builtin_attr.rs"}, {"sha": "e4c8d446af7bd762c60246e5adee44487200f353", "filename": "src/tools/rust-analyzer/crates/hir-def/src/attr/tests.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr%2Ftests.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -0,0 +1,40 @@\n+//! This module contains tests for doc-expression parsing.\n+//! Currently, it tests `#[doc(hidden)]` and `#[doc(alias)]`.\n+\n+use mbe::syntax_node_to_token_tree;\n+use syntax::{ast, AstNode};\n+\n+use crate::attr::{DocAtom, DocExpr};\n+\n+fn assert_parse_result(input: &str, expected: DocExpr) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        syntax_node_to_token_tree(tt.syntax())\n+    };\n+    let cfg = DocExpr::parse(&tt);\n+    assert_eq!(cfg, expected);\n+}\n+\n+#[test]\n+fn test_doc_expr_parser() {\n+    assert_parse_result(\"#![doc(hidden)]\", DocAtom::Flag(\"hidden\".into()).into());\n+\n+    assert_parse_result(\n+        r#\"#![doc(alias = \"foo\")]\"#,\n+        DocAtom::KeyValue { key: \"alias\".into(), value: \"foo\".into() }.into(),\n+    );\n+\n+    assert_parse_result(r#\"#![doc(alias(\"foo\"))]\"#, DocExpr::Alias([\"foo\".into()].into()));\n+    assert_parse_result(\n+        r#\"#![doc(alias(\"foo\", \"bar\", \"baz\"))]\"#,\n+        DocExpr::Alias([\"foo\".into(), \"bar\".into(), \"baz\".into()].into()),\n+    );\n+\n+    assert_parse_result(\n+        r#\"\n+        #[doc(alias(\"Bar\", \"Qux\"))]\n+        struct Foo;\"#,\n+        DocExpr::Alias([\"Bar\".into(), \"Qux\".into()].into()),\n+    );\n+}"}, {"sha": "36626ed1a9b1f6156d5f61365fcc725063931d6f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body.rs", "status": "modified", "additions": 79, "deletions": 291, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -6,267 +6,30 @@ mod tests;\n pub mod scope;\n mod pretty;\n \n-use std::{ops::Index, sync::Arc};\n+use std::ops::Index;\n \n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n-use drop_bomb::DropBomb;\n use either::Either;\n-use hir_expand::{\n-    attrs::RawAttrs, hygiene::Hygiene, ExpandError, ExpandResult, HirFileId, InFile, MacroCallId,\n-};\n+use hir_expand::{name::Name, HirFileId, InFile};\n use la_arena::{Arena, ArenaMap};\n-use limit::Limit;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n+use syntax::{ast, AstPtr, SyntaxNodePtr};\n+use triomphe::Arc;\n \n use crate::{\n-    attr::Attrs,\n     db::DefDatabase,\n-    expr::{\n+    expander::Expander,\n+    hir::{\n         dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId, RecordFieldPat,\n     },\n-    item_scope::BuiltinShadowMode,\n-    macro_id_to_def_id,\n     nameres::DefMap,\n     path::{ModPath, Path},\n     src::{HasChildSource, HasSource},\n-    AsMacroCall, BlockId, DefWithBodyId, HasModule, LocalModuleId, Lookup, MacroId, ModuleId,\n-    UnresolvedMacro,\n+    BlockId, DefWithBodyId, HasModule, Lookup,\n };\n \n-pub use lower::LowerCtx;\n-\n-/// A subset of Expander that only deals with cfg attributes. We only need it to\n-/// avoid cyclic queries in crate def map during enum processing.\n-#[derive(Debug)]\n-pub(crate) struct CfgExpander {\n-    cfg_options: CfgOptions,\n-    hygiene: Hygiene,\n-    krate: CrateId,\n-}\n-\n-#[derive(Debug)]\n-pub struct Expander {\n-    cfg_expander: CfgExpander,\n-    def_map: Arc<DefMap>,\n-    current_file_id: HirFileId,\n-    module: LocalModuleId,\n-    /// `recursion_depth == usize::MAX` indicates that the recursion limit has been reached.\n-    recursion_depth: usize,\n-}\n-\n-impl CfgExpander {\n-    pub(crate) fn new(\n-        db: &dyn DefDatabase,\n-        current_file_id: HirFileId,\n-        krate: CrateId,\n-    ) -> CfgExpander {\n-        let hygiene = Hygiene::new(db.upcast(), current_file_id);\n-        let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n-        CfgExpander { cfg_options, hygiene, krate }\n-    }\n-\n-    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n-        Attrs::filter(db, self.krate, RawAttrs::new(db.upcast(), owner, &self.hygiene))\n-    }\n-\n-    pub(crate) fn is_cfg_enabled(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> bool {\n-        let attrs = self.parse_attrs(db, owner);\n-        attrs.is_cfg_enabled(&self.cfg_options)\n-    }\n-}\n-\n-impl Expander {\n-    pub fn new(db: &dyn DefDatabase, current_file_id: HirFileId, module: ModuleId) -> Expander {\n-        let cfg_expander = CfgExpander::new(db, current_file_id, module.krate);\n-        let def_map = module.def_map(db);\n-        Expander {\n-            cfg_expander,\n-            def_map,\n-            current_file_id,\n-            module: module.local_id,\n-            recursion_depth: 0,\n-        }\n-    }\n-\n-    pub fn enter_expand<T: ast::AstNode>(\n-        &mut self,\n-        db: &dyn DefDatabase,\n-        macro_call: ast::MacroCall,\n-    ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n-        let mut unresolved_macro_err = None;\n-\n-        let result = self.within_limit(db, |this| {\n-            let macro_call = InFile::new(this.current_file_id, &macro_call);\n-\n-            let resolver =\n-                |path| this.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n-\n-            let mut err = None;\n-            let call_id = match macro_call.as_call_id_with_errors(\n-                db,\n-                this.def_map.krate(),\n-                resolver,\n-                &mut |e| {\n-                    err.get_or_insert(e);\n-                },\n-            ) {\n-                Ok(call_id) => call_id,\n-                Err(resolve_err) => {\n-                    unresolved_macro_err = Some(resolve_err);\n-                    return ExpandResult { value: None, err: None };\n-                }\n-            };\n-            ExpandResult { value: call_id.ok(), err }\n-        });\n-\n-        if let Some(err) = unresolved_macro_err {\n-            Err(err)\n-        } else {\n-            Ok(result)\n-        }\n-    }\n-\n-    pub fn enter_expand_id<T: ast::AstNode>(\n-        &mut self,\n-        db: &dyn DefDatabase,\n-        call_id: MacroCallId,\n-    ) -> ExpandResult<Option<(Mark, T)>> {\n-        self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))\n-    }\n-\n-    fn enter_expand_inner(\n-        db: &dyn DefDatabase,\n-        call_id: MacroCallId,\n-        mut err: Option<ExpandError>,\n-    ) -> ExpandResult<Option<(HirFileId, SyntaxNode)>> {\n-        if err.is_none() {\n-            err = db.macro_expand_error(call_id);\n-        }\n-\n-        let file_id = call_id.as_file();\n-\n-        let raw_node = match db.parse_or_expand(file_id) {\n-            Some(it) => it,\n-            None => {\n-                // Only `None` if the macro expansion produced no usable AST.\n-                if err.is_none() {\n-                    tracing::warn!(\"no error despite `parse_or_expand` failing\");\n-                }\n-\n-                return ExpandResult::only_err(err.unwrap_or_else(|| {\n-                    ExpandError::Other(\"failed to parse macro invocation\".into())\n-                }));\n-            }\n-        };\n-\n-        ExpandResult { value: Some((file_id, raw_node)), err }\n-    }\n-\n-    pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n-        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n-        self.current_file_id = mark.file_id;\n-        if self.recursion_depth == usize::MAX {\n-            // Recursion limit has been reached somewhere in the macro expansion tree. Reset the\n-            // depth only when we get out of the tree.\n-            if !self.current_file_id.is_macro() {\n-                self.recursion_depth = 0;\n-            }\n-        } else {\n-            self.recursion_depth -= 1;\n-        }\n-        mark.bomb.defuse();\n-    }\n-\n-    pub(crate) fn to_source<T>(&self, value: T) -> InFile<T> {\n-        InFile { file_id: self.current_file_id, value }\n-    }\n-\n-    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n-        self.cfg_expander.parse_attrs(db, owner)\n-    }\n-\n-    pub(crate) fn cfg_options(&self) -> &CfgOptions {\n-        &self.cfg_expander.cfg_options\n-    }\n-\n-    pub fn current_file_id(&self) -> HirFileId {\n-        self.current_file_id\n-    }\n-\n-    fn parse_path(&mut self, db: &dyn DefDatabase, path: ast::Path) -> Option<Path> {\n-        let ctx = LowerCtx::with_hygiene(db, &self.cfg_expander.hygiene);\n-        Path::from_src(path, &ctx)\n-    }\n-\n-    fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n-        self.def_map.resolve_path(db, self.module, path, BuiltinShadowMode::Other).0.take_macros()\n-    }\n-\n-    fn recursion_limit(&self, db: &dyn DefDatabase) -> Limit {\n-        let limit = db.crate_limits(self.cfg_expander.krate).recursion_limit as _;\n-\n-        #[cfg(not(test))]\n-        return Limit::new(limit);\n-\n-        // Without this, `body::tests::your_stack_belongs_to_me` stack-overflows in debug\n-        #[cfg(test)]\n-        return Limit::new(std::cmp::min(32, limit));\n-    }\n-\n-    fn within_limit<F, T: ast::AstNode>(\n-        &mut self,\n-        db: &dyn DefDatabase,\n-        op: F,\n-    ) -> ExpandResult<Option<(Mark, T)>>\n-    where\n-        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,\n-    {\n-        if self.recursion_depth == usize::MAX {\n-            // Recursion limit has been reached somewhere in the macro expansion tree. We should\n-            // stop expanding other macro calls in this tree, or else this may result in\n-            // exponential number of macro expansions, leading to a hang.\n-            //\n-            // The overflow error should have been reported when it occurred (see the next branch),\n-            // so don't return overflow error here to avoid diagnostics duplication.\n-            cov_mark::hit!(overflow_but_not_me);\n-            return ExpandResult::only_err(ExpandError::RecursionOverflowPosioned);\n-        } else if self.recursion_limit(db).check(self.recursion_depth + 1).is_err() {\n-            self.recursion_depth = usize::MAX;\n-            cov_mark::hit!(your_stack_belongs_to_me);\n-            return ExpandResult::only_err(ExpandError::Other(\n-                \"reached recursion limit during macro expansion\".into(),\n-            ));\n-        }\n-\n-        let ExpandResult { value, err } = op(self);\n-        let Some(call_id) = value else {\n-            return ExpandResult { value: None, err };\n-        };\n-\n-        Self::enter_expand_inner(db, call_id, err).map(|value| {\n-            value.and_then(|(new_file_id, node)| {\n-                let node = T::cast(node)?;\n-\n-                self.recursion_depth += 1;\n-                self.cfg_expander.hygiene = Hygiene::new(db.upcast(), new_file_id);\n-                let old_file_id = std::mem::replace(&mut self.current_file_id, new_file_id);\n-                let mark =\n-                    Mark { file_id: old_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n-                Some((mark, node))\n-            })\n-        })\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct Mark {\n-    file_id: HirFileId,\n-    bomb: DropBomb,\n-}\n-\n /// The body of an item (function, const etc.).\n #[derive(Debug, Eq, PartialEq)]\n pub struct Body {\n@@ -343,6 +106,8 @@ pub enum BodyDiagnostic {\n     MacroError { node: InFile<AstPtr<ast::MacroCall>>, message: String },\n     UnresolvedProcMacro { node: InFile<AstPtr<ast::MacroCall>>, krate: CrateId },\n     UnresolvedMacroCall { node: InFile<AstPtr<ast::MacroCall>>, path: ModPath },\n+    UnreachableLabel { node: InFile<AstPtr<ast::Lifetime>>, name: Name },\n+    UndeclaredLabel { node: InFile<AstPtr<ast::Lifetime>>, name: Name },\n }\n \n impl Body {\n@@ -353,45 +118,54 @@ impl Body {\n         let _p = profile::span(\"body_with_source_map_query\");\n         let mut params = None;\n \n-        let (file_id, module, body) = match def {\n-            DefWithBodyId::FunctionId(f) => {\n-                let f = f.lookup(db);\n-                let src = f.source(db);\n-                params = src.value.param_list().map(|param_list| {\n-                    let item_tree = f.id.item_tree(db);\n-                    let func = &item_tree[f.id.value];\n-                    let krate = f.container.module(db).krate;\n-                    let crate_graph = db.crate_graph();\n+        let (file_id, module, body, is_async_fn) = {\n+            match def {\n+                DefWithBodyId::FunctionId(f) => {\n+                    let data = db.function_data(f);\n+                    let f = f.lookup(db);\n+                    let src = f.source(db);\n+                    params = src.value.param_list().map(|param_list| {\n+                        let item_tree = f.id.item_tree(db);\n+                        let func = &item_tree[f.id.value];\n+                        let krate = f.container.module(db).krate;\n+                        let crate_graph = db.crate_graph();\n+                        (\n+                            param_list,\n+                            func.params.clone().map(move |param| {\n+                                item_tree\n+                                    .attrs(db, krate, param.into())\n+                                    .is_cfg_enabled(&crate_graph[krate].cfg_options)\n+                            }),\n+                        )\n+                    });\n                     (\n-                        param_list,\n-                        func.params.clone().map(move |param| {\n-                            item_tree\n-                                .attrs(db, krate, param.into())\n-                                .is_cfg_enabled(&crate_graph[krate].cfg_options)\n-                        }),\n+                        src.file_id,\n+                        f.module(db),\n+                        src.value.body().map(ast::Expr::from),\n+                        data.has_async_kw(),\n                     )\n-                });\n-                (src.file_id, f.module(db), src.value.body().map(ast::Expr::from))\n-            }\n-            DefWithBodyId::ConstId(c) => {\n-                let c = c.lookup(db);\n-                let src = c.source(db);\n-                (src.file_id, c.module(db), src.value.body())\n-            }\n-            DefWithBodyId::StaticId(s) => {\n-                let s = s.lookup(db);\n-                let src = s.source(db);\n-                (src.file_id, s.module(db), src.value.body())\n-            }\n-            DefWithBodyId::VariantId(v) => {\n-                let e = v.parent.lookup(db);\n-                let src = v.parent.child_source(db);\n-                let variant = &src.value[v.local_id];\n-                (src.file_id, e.container, variant.expr())\n+                }\n+                DefWithBodyId::ConstId(c) => {\n+                    let c = c.lookup(db);\n+                    let src = c.source(db);\n+                    (src.file_id, c.module(db), src.value.body(), false)\n+                }\n+                DefWithBodyId::StaticId(s) => {\n+                    let s = s.lookup(db);\n+                    let src = s.source(db);\n+                    (src.file_id, s.module(db), src.value.body(), false)\n+                }\n+                DefWithBodyId::VariantId(v) => {\n+                    let e = v.parent.lookup(db);\n+                    let src = v.parent.child_source(db);\n+                    let variant = &src.value[v.local_id];\n+                    (src.file_id, e.container, variant.expr(), false)\n+                }\n             }\n         };\n         let expander = Expander::new(db, file_id, module);\n-        let (mut body, source_map) = Body::new(db, expander, params, body);\n+        let (mut body, source_map) =\n+            Body::new(db, def, expander, params, body, module.krate, is_async_fn);\n         body.shrink_to_fit();\n \n         (Arc::new(body), Arc::new(source_map))\n@@ -406,22 +180,32 @@ impl Body {\n         &'a self,\n         db: &'a dyn DefDatabase,\n     ) -> impl Iterator<Item = (BlockId, Arc<DefMap>)> + '_ {\n-        self.block_scopes\n-            .iter()\n-            .map(move |&block| (block, db.block_def_map(block).expect(\"block ID without DefMap\")))\n+        self.block_scopes.iter().map(move |&block| (block, db.block_def_map(block)))\n     }\n \n     pub fn pretty_print(&self, db: &dyn DefDatabase, owner: DefWithBodyId) -> String {\n         pretty::print_body_hir(db, self, owner)\n     }\n \n+    pub fn pretty_print_expr(\n+        &self,\n+        db: &dyn DefDatabase,\n+        owner: DefWithBodyId,\n+        expr: ExprId,\n+    ) -> String {\n+        pretty::print_expr_hir(db, self, owner, expr)\n+    }\n+\n     fn new(\n         db: &dyn DefDatabase,\n+        owner: DefWithBodyId,\n         expander: Expander,\n         params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n         body: Option<ast::Expr>,\n+        krate: CrateId,\n+        is_async_fn: bool,\n     ) -> (Body, BodySourceMap) {\n-        lower::lower(db, expander, params, body)\n+        lower::lower(db, owner, expander, params, body, krate, is_async_fn)\n     }\n \n     fn shrink_to_fit(&mut self) {\n@@ -437,15 +221,14 @@ impl Body {\n \n     pub fn walk_bindings_in_pat(&self, pat_id: PatId, mut f: impl FnMut(BindingId)) {\n         self.walk_pats(pat_id, &mut |pat| {\n-            if let Pat::Bind { id, .. } = pat {\n+            if let Pat::Bind { id, .. } = &self[pat] {\n                 f(*id);\n             }\n         });\n     }\n \n-    pub fn walk_pats(&self, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n+    pub fn walk_pats_shallow(&self, pat_id: PatId, mut f: impl FnMut(PatId)) {\n         let pat = &self[pat_id];\n-        f(pat);\n         match pat {\n             Pat::Range { .. }\n             | Pat::Lit(..)\n@@ -455,23 +238,28 @@ impl Body {\n             | Pat::Missing => {}\n             &Pat::Bind { subpat, .. } => {\n                 if let Some(subpat) = subpat {\n-                    self.walk_pats(subpat, f);\n+                    f(subpat);\n                 }\n             }\n             Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n-                args.iter().copied().for_each(|p| self.walk_pats(p, f));\n+                args.iter().copied().for_each(|p| f(p));\n             }\n-            Pat::Ref { pat, .. } => self.walk_pats(*pat, f),\n+            Pat::Ref { pat, .. } => f(*pat),\n             Pat::Slice { prefix, slice, suffix } => {\n                 let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n-                total_iter.copied().for_each(|p| self.walk_pats(p, f));\n+                total_iter.copied().for_each(|p| f(p));\n             }\n             Pat::Record { args, .. } => {\n-                args.iter().for_each(|RecordFieldPat { pat, .. }| self.walk_pats(*pat, f));\n+                args.iter().for_each(|RecordFieldPat { pat, .. }| f(*pat));\n             }\n-            Pat::Box { inner } => self.walk_pats(*inner, f),\n+            Pat::Box { inner } => f(*inner),\n         }\n     }\n+\n+    pub fn walk_pats(&self, pat_id: PatId, f: &mut impl FnMut(PatId)) {\n+        f(pat_id);\n+        self.walk_pats_shallow(pat_id, |p| self.walk_pats(p, f));\n+    }\n }\n \n impl Default for Body {"}, {"sha": "7b88e525bf1845a1319b3f43b4d78568d92bd29a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 775, "deletions": 283, "changes": 1058, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,88 +1,62 @@\n //! Transforms `ast::Expr` into an equivalent `hir_def::expr::Expr`\n //! representation.\n \n-use std::{mem, sync::Arc};\n+use std::mem;\n \n+use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     ast_id_map::AstIdMap,\n-    hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    AstId, ExpandError, HirFileId, InFile,\n+    AstId, ExpandError, InFile,\n };\n use intern::Interned;\n use la_arena::Arena;\n-use once_cell::unsync::OnceCell;\n use profile::Count;\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use syntax::{\n     ast::{\n-        self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n+        self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasAttrs, HasLoopBody, HasName,\n         SlicePatComponents,\n     },\n     AstNode, AstPtr, SyntaxNodePtr,\n };\n+use triomphe::Arc;\n \n use crate::{\n-    adt::StructKind,\n-    body::{Body, BodySourceMap, Expander, ExprPtr, LabelPtr, LabelSource, PatPtr},\n-    body::{BodyDiagnostic, ExprSource, PatSource},\n-    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n+    body::{Body, BodyDiagnostic, BodySourceMap, ExprPtr, LabelPtr, PatPtr},\n+    data::adt::StructKind,\n     db::DefDatabase,\n-    expr::{\n-        dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, ClosureKind, Expr, ExprId,\n-        FloatTypeWrapper, Label, LabelId, Literal, MatchArm, Movability, Pat, PatId,\n-        RecordFieldPat, RecordLitField, Statement,\n+    expander::Expander,\n+    hir::{\n+        dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, BindingProblems, CaptureBy,\n+        ClosureKind, Expr, ExprId, Label, LabelId, Literal, LiteralOrConst, MatchArm, Movability,\n+        Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n+    lang_item::LangItem,\n+    lower::LowerCtx,\n+    nameres::{DefMap, MacroSubNs},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n-    AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n+    AdtId, BlockId, BlockLoc, DefWithBodyId, ModuleDefId, UnresolvedMacro,\n };\n \n-pub struct LowerCtx<'a> {\n-    pub db: &'a dyn DefDatabase,\n-    hygiene: Hygiene,\n-    ast_id_map: Option<(HirFileId, OnceCell<Arc<AstIdMap>>)>,\n-}\n-\n-impl<'a> LowerCtx<'a> {\n-    pub fn new(db: &'a dyn DefDatabase, file_id: HirFileId) -> Self {\n-        LowerCtx {\n-            db,\n-            hygiene: Hygiene::new(db.upcast(), file_id),\n-            ast_id_map: Some((file_id, OnceCell::new())),\n-        }\n-    }\n-\n-    pub fn with_hygiene(db: &'a dyn DefDatabase, hygiene: &Hygiene) -> Self {\n-        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: None }\n-    }\n-\n-    pub(crate) fn hygiene(&self) -> &Hygiene {\n-        &self.hygiene\n-    }\n-\n-    pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n-        Path::from_src(ast, self)\n-    }\n-\n-    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> Option<AstId<N>> {\n-        let &(file_id, ref ast_id_map) = self.ast_id_map.as_ref()?;\n-        let ast_id_map = ast_id_map.get_or_init(|| self.db.ast_id_map(file_id));\n-        Some(InFile::new(file_id, ast_id_map.ast_id(item)))\n-    }\n-}\n-\n pub(super) fn lower(\n     db: &dyn DefDatabase,\n+    owner: DefWithBodyId,\n     expander: Expander,\n     params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n     body: Option<ast::Expr>,\n+    krate: CrateId,\n+    is_async_fn: bool,\n ) -> (Body, BodySourceMap) {\n     ExprCollector {\n         db,\n+        owner,\n+        krate,\n+        def_map: expander.module.def_map(db),\n         source_map: BodySourceMap::default(),\n         ast_id_map: db.ast_id_map(expander.current_file_id),\n         body: Body {\n@@ -96,25 +70,79 @@ pub(super) fn lower(\n             _c: Count::new(),\n         },\n         expander,\n+        current_try_block_label: None,\n         is_lowering_assignee_expr: false,\n         is_lowering_generator: false,\n+        label_ribs: Vec::new(),\n+        current_binding_owner: None,\n     }\n-    .collect(params, body)\n+    .collect(params, body, is_async_fn)\n }\n \n struct ExprCollector<'a> {\n     db: &'a dyn DefDatabase,\n     expander: Expander,\n+    owner: DefWithBodyId,\n+    def_map: Arc<DefMap>,\n     ast_id_map: Arc<AstIdMap>,\n+    krate: CrateId,\n     body: Body,\n     source_map: BodySourceMap,\n+\n     is_lowering_assignee_expr: bool,\n     is_lowering_generator: bool,\n+\n+    current_try_block_label: Option<LabelId>,\n+    // points to the expression that a try expression will target (replaces current_try_block_label)\n+    // catch_scope: Option<ExprId>,\n+    // points to the expression that an unlabeled control flow will target\n+    // loop_scope: Option<ExprId>,\n+    // needed to diagnose non label control flow in while conditions\n+    // is_in_loop_condition: bool,\n+\n+    // resolution\n+    label_ribs: Vec<LabelRib>,\n+    current_binding_owner: Option<ExprId>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct LabelRib {\n+    kind: RibKind,\n+    // Once we handle macro hygiene this will need to be a map\n+    label: Option<(Name, LabelId)>,\n+}\n+\n+impl LabelRib {\n+    fn new(kind: RibKind) -> Self {\n+        LabelRib { kind, label: None }\n+    }\n+    fn new_normal(label: (Name, LabelId)) -> Self {\n+        LabelRib { kind: RibKind::Normal, label: Some(label) }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum RibKind {\n+    Normal,\n+    Closure,\n+    Constant,\n+}\n+\n+impl RibKind {\n+    /// This rib forbids referring to labels defined in upwards ribs.\n+    fn is_label_barrier(self) -> bool {\n+        match self {\n+            RibKind::Normal => false,\n+            RibKind::Closure | RibKind::Constant => true,\n+        }\n+    }\n }\n \n #[derive(Debug, Default)]\n struct BindingList {\n     map: FxHashMap<Name, BindingId>,\n+    is_used: FxHashMap<BindingId, bool>,\n+    reject_new: bool,\n }\n \n impl BindingList {\n@@ -124,7 +152,27 @@ impl BindingList {\n         name: Name,\n         mode: BindingAnnotation,\n     ) -> BindingId {\n-        *self.map.entry(name).or_insert_with_key(|n| ec.alloc_binding(n.clone(), mode))\n+        let id = *self.map.entry(name).or_insert_with_key(|n| ec.alloc_binding(n.clone(), mode));\n+        if ec.body.bindings[id].mode != mode {\n+            ec.body.bindings[id].problems = Some(BindingProblems::BoundInconsistently);\n+        }\n+        self.check_is_used(ec, id);\n+        id\n+    }\n+\n+    fn check_is_used(&mut self, ec: &mut ExprCollector<'_>, id: BindingId) {\n+        match self.is_used.get(&id) {\n+            None => {\n+                if self.reject_new {\n+                    ec.body.bindings[id].problems = Some(BindingProblems::NotBoundAcrossAll);\n+                }\n+            }\n+            Some(true) => {\n+                ec.body.bindings[id].problems = Some(BindingProblems::BoundMoreThanOnce);\n+            }\n+            Some(false) => {}\n+        }\n+        self.is_used.insert(id, true);\n     }\n }\n \n@@ -133,6 +181,7 @@ impl ExprCollector<'_> {\n         mut self,\n         param_list: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n         body: Option<ast::Expr>,\n+        is_async_fn: bool,\n     ) -> (Body, BodySourceMap) {\n         if let Some((param_list, mut attr_enabled)) = param_list {\n             if let Some(self_param) =\n@@ -152,72 +201,35 @@ impl ExprCollector<'_> {\n                 self.body.params.push(param_pat);\n             }\n \n-            for pat in param_list\n-                .params()\n-                .zip(attr_enabled)\n-                .filter_map(|(param, enabled)| param.pat().filter(|_| enabled))\n+            for (param, _) in param_list.params().zip(attr_enabled).filter(|(_, enabled)| *enabled)\n             {\n-                let param_pat = self.collect_pat(pat);\n+                let param_pat = self.collect_pat_top(param.pat());\n                 self.body.params.push(param_pat);\n             }\n         };\n+        self.body.body_expr = self.with_label_rib(RibKind::Closure, |this| {\n+            if is_async_fn {\n+                match body {\n+                    Some(e) => {\n+                        let expr = this.collect_expr(e);\n+                        this.alloc_expr_desugared(Expr::Async {\n+                            id: None,\n+                            statements: Box::new([]),\n+                            tail: Some(expr),\n+                        })\n+                    }\n+                    None => this.missing_expr(),\n+                }\n+            } else {\n+                this.collect_expr_opt(body)\n+            }\n+        });\n \n-        self.body.body_expr = self.collect_expr_opt(body);\n         (self.body, self.source_map)\n     }\n \n     fn ctx(&self) -> LowerCtx<'_> {\n-        LowerCtx::new(self.db, self.expander.current_file_id)\n-    }\n-\n-    fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {\n-        let src = self.expander.to_source(ptr);\n-        let id = self.make_expr(expr, src.clone());\n-        self.source_map.expr_map.insert(src, id);\n-        id\n-    }\n-    // desugared exprs don't have ptr, that's wrong and should be fixed\n-    // somehow.\n-    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n-        self.body.exprs.alloc(expr)\n-    }\n-    fn missing_expr(&mut self) -> ExprId {\n-        self.alloc_expr_desugared(Expr::Missing)\n-    }\n-    fn make_expr(&mut self, expr: Expr, src: ExprSource) -> ExprId {\n-        let id = self.body.exprs.alloc(expr);\n-        self.source_map.expr_map_back.insert(id, src);\n-        id\n-    }\n-\n-    fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation) -> BindingId {\n-        self.body.bindings.alloc(Binding { name, mode, definitions: SmallVec::new() })\n-    }\n-    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n-        let src = self.expander.to_source(ptr);\n-        let id = self.make_pat(pat, src.clone());\n-        self.source_map.pat_map.insert(src, id);\n-        id\n-    }\n-    fn missing_pat(&mut self) -> PatId {\n-        self.body.pats.alloc(Pat::Missing)\n-    }\n-    fn make_pat(&mut self, pat: Pat, src: PatSource) -> PatId {\n-        let id = self.body.pats.alloc(pat);\n-        self.source_map.pat_map_back.insert(id, src);\n-        id\n-    }\n-\n-    fn alloc_label(&mut self, label: Label, ptr: LabelPtr) -> LabelId {\n-        let src = self.expander.to_source(ptr);\n-        let id = self.make_label(label, src.clone());\n-        self.source_map.label_map.insert(src, id);\n-        id\n-    }\n-    fn make_label(&mut self, label: Label, src: LabelSource) -> LabelId {\n-        let id = self.body.labels.alloc(label);\n-        self.source_map.label_map_back.insert(id, src);\n-        id\n+        self.expander.ctx(self.db)\n     }\n \n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n@@ -229,6 +241,7 @@ impl ExprCollector<'_> {\n         let syntax_ptr = AstPtr::new(&expr);\n         self.check_cfg(&expr)?;\n \n+        // FIXME: Move some of these arms out into separate methods for clarity\n         Some(match expr {\n             ast::Expr::IfExpr(e) => {\n                 let then_branch = self.collect_block_opt(e.then_branch());\n@@ -246,18 +259,12 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n             ast::Expr::LetExpr(e) => {\n-                let pat = self.collect_pat_opt(e.pat());\n+                let pat = self.collect_pat_top(e.pat());\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Let { pat, expr }, syntax_ptr)\n             }\n             ast::Expr::BlockExpr(e) => match e.modifier() {\n-                Some(ast::BlockModifier::Try(_)) => {\n-                    self.collect_block_(e, |id, statements, tail| Expr::TryBlock {\n-                        id,\n-                        statements,\n-                        tail,\n-                    })\n-                }\n+                Some(ast::BlockModifier::Try(_)) => self.desugar_try_block(e),\n                 Some(ast::BlockModifier::Unsafe(_)) => {\n                     self.collect_block_(e, |id, statements, tail| Expr::Unsafe {\n                         id,\n@@ -267,50 +274,74 @@ impl ExprCollector<'_> {\n                 }\n                 Some(ast::BlockModifier::Label(label)) => {\n                     let label = self.collect_label(label);\n-                    self.collect_block_(e, |id, statements, tail| Expr::Block {\n-                        id,\n-                        statements,\n-                        tail,\n-                        label: Some(label),\n+                    self.with_labeled_rib(label, |this| {\n+                        this.collect_block_(e, |id, statements, tail| Expr::Block {\n+                            id,\n+                            statements,\n+                            tail,\n+                            label: Some(label),\n+                        })\n+                    })\n+                }\n+                Some(ast::BlockModifier::Async(_)) => {\n+                    self.with_label_rib(RibKind::Closure, |this| {\n+                        this.collect_block_(e, |id, statements, tail| Expr::Async {\n+                            id,\n+                            statements,\n+                            tail,\n+                        })\n+                    })\n+                }\n+                Some(ast::BlockModifier::Const(_)) => {\n+                    self.with_label_rib(RibKind::Constant, |this| {\n+                        let (result_expr_id, prev_binding_owner) =\n+                            this.initialize_binding_owner(syntax_ptr);\n+                        let inner_expr = this.collect_block(e);\n+                        let x = this.db.intern_anonymous_const((this.owner, inner_expr));\n+                        this.body.exprs[result_expr_id] = Expr::Const(x);\n+                        this.current_binding_owner = prev_binding_owner;\n+                        result_expr_id\n                     })\n                 }\n-                Some(ast::BlockModifier::Async(_)) => self\n-                    .collect_block_(e, |id, statements, tail| Expr::Async { id, statements, tail }),\n-                Some(ast::BlockModifier::Const(_)) => self\n-                    .collect_block_(e, |id, statements, tail| Expr::Const { id, statements, tail }),\n                 None => self.collect_block(e),\n             },\n             ast::Expr::LoopExpr(e) => {\n                 let label = e.label().map(|label| self.collect_label(label));\n-                let body = self.collect_block_opt(e.loop_body());\n+                let body = self.collect_labelled_block_opt(label, e.loop_body());\n                 self.alloc_expr(Expr::Loop { body, label }, syntax_ptr)\n             }\n             ast::Expr::WhileExpr(e) => {\n                 let label = e.label().map(|label| self.collect_label(label));\n-                let body = self.collect_block_opt(e.loop_body());\n-\n+                let body = self.collect_labelled_block_opt(label, e.loop_body());\n                 let condition = self.collect_expr_opt(e.condition());\n \n                 self.alloc_expr(Expr::While { condition, body, label }, syntax_ptr)\n             }\n-            ast::Expr::ForExpr(e) => {\n-                let label = e.label().map(|label| self.collect_label(label));\n-                let iterable = self.collect_expr_opt(e.iterable());\n-                let pat = self.collect_pat_opt(e.pat());\n-                let body = self.collect_block_opt(e.loop_body());\n-                self.alloc_expr(Expr::For { iterable, pat, body, label }, syntax_ptr)\n-            }\n+            ast::Expr::ForExpr(e) => self.collect_for_loop(syntax_ptr, e),\n             ast::Expr::CallExpr(e) => {\n-                let callee = self.collect_expr_opt(e.expr());\n-                let args = if let Some(arg_list) = e.arg_list() {\n-                    arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()\n-                } else {\n-                    Box::default()\n+                let is_rustc_box = {\n+                    let attrs = e.attrs();\n+                    attrs.filter_map(|x| x.as_simple_atom()).any(|x| x == \"rustc_box\")\n                 };\n-                self.alloc_expr(\n-                    Expr::Call { callee, args, is_assignee_expr: self.is_lowering_assignee_expr },\n-                    syntax_ptr,\n-                )\n+                if is_rustc_box {\n+                    let expr = self.collect_expr_opt(e.arg_list().and_then(|x| x.args().next()));\n+                    self.alloc_expr(Expr::Box { expr }, syntax_ptr)\n+                } else {\n+                    let callee = self.collect_expr_opt(e.expr());\n+                    let args = if let Some(arg_list) = e.arg_list() {\n+                        arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()\n+                    } else {\n+                        Box::default()\n+                    };\n+                    self.alloc_expr(\n+                        Expr::Call {\n+                            callee,\n+                            args,\n+                            is_assignee_expr: self.is_lowering_assignee_expr,\n+                        },\n+                        syntax_ptr,\n+                    )\n+                }\n             }\n             ast::Expr::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.receiver());\n@@ -336,7 +367,7 @@ impl ExprCollector<'_> {\n                         .arms()\n                         .filter_map(|arm| {\n                             self.check_cfg(&arm).map(|()| MatchArm {\n-                                pat: self.collect_pat_opt(arm.pat()),\n+                                pat: self.collect_pat_top(arm.pat()),\n                                 expr: self.collect_expr_opt(arm.expr()),\n                                 guard: arm\n                                     .guard()\n@@ -357,16 +388,20 @@ impl ExprCollector<'_> {\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::Expr::ContinueExpr(e) => self.alloc_expr(\n-                Expr::Continue { label: e.lifetime().map(|l| Name::new_lifetime(&l)) },\n-                syntax_ptr,\n-            ),\n+            ast::Expr::ContinueExpr(e) => {\n+                let label = self.resolve_label(e.lifetime()).unwrap_or_else(|e| {\n+                    self.source_map.diagnostics.push(e);\n+                    None\n+                });\n+                self.alloc_expr(Expr::Continue { label }, syntax_ptr)\n+            }\n             ast::Expr::BreakExpr(e) => {\n+                let label = self.resolve_label(e.lifetime()).unwrap_or_else(|e| {\n+                    self.source_map.diagnostics.push(e);\n+                    None\n+                });\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(\n-                    Expr::Break { expr, label: e.lifetime().map(|l| Name::new_lifetime(&l)) },\n-                    syntax_ptr,\n-                )\n+                self.alloc_expr(Expr::Break { expr, label }, syntax_ptr)\n             }\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n@@ -437,10 +472,7 @@ impl ExprCollector<'_> {\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n             }\n-            ast::Expr::TryExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n-            }\n+            ast::Expr::TryExpr(e) => self.collect_try_operator(syntax_ptr, e),\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = Interned::new(TypeRef::from_ast_opt(&self.ctx(), e.ty()));\n@@ -470,29 +502,31 @@ impl ExprCollector<'_> {\n                     None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n-            ast::Expr::ClosureExpr(e) => {\n+            ast::Expr::ClosureExpr(e) => self.with_label_rib(RibKind::Closure, |this| {\n+                let (result_expr_id, prev_binding_owner) =\n+                    this.initialize_binding_owner(syntax_ptr);\n                 let mut args = Vec::new();\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n                     for param in pl.params() {\n-                        let pat = self.collect_pat_opt(param.pat());\n+                        let pat = this.collect_pat_top(param.pat());\n                         let type_ref =\n-                            param.ty().map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+                            param.ty().map(|it| Interned::new(TypeRef::from_ast(&this.ctx(), it)));\n                         args.push(pat);\n                         arg_types.push(type_ref);\n                     }\n                 }\n                 let ret_type = e\n                     .ret_type()\n                     .and_then(|r| r.ty())\n-                    .map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+                    .map(|it| Interned::new(TypeRef::from_ast(&this.ctx(), it)));\n \n-                let prev_is_lowering_generator = self.is_lowering_generator;\n-                self.is_lowering_generator = false;\n+                let prev_is_lowering_generator = mem::take(&mut this.is_lowering_generator);\n+                let prev_try_block_label = this.current_try_block_label.take();\n \n-                let body = self.collect_expr_opt(e.body());\n+                let body = this.collect_expr_opt(e.body());\n \n-                let closure_kind = if self.is_lowering_generator {\n+                let closure_kind = if this.is_lowering_generator {\n                     let movability = if e.static_token().is_some() {\n                         Movability::Static\n                     } else {\n@@ -504,19 +538,21 @@ impl ExprCollector<'_> {\n                 } else {\n                     ClosureKind::Closure\n                 };\n-                self.is_lowering_generator = prev_is_lowering_generator;\n-\n-                self.alloc_expr(\n-                    Expr::Closure {\n-                        args: args.into(),\n-                        arg_types: arg_types.into(),\n-                        ret_type,\n-                        body,\n-                        closure_kind,\n-                    },\n-                    syntax_ptr,\n-                )\n-            }\n+                let capture_by =\n+                    if e.move_token().is_some() { CaptureBy::Value } else { CaptureBy::Ref };\n+                this.is_lowering_generator = prev_is_lowering_generator;\n+                this.current_binding_owner = prev_binding_owner;\n+                this.current_try_block_label = prev_try_block_label;\n+                this.body.exprs[result_expr_id] = Expr::Closure {\n+                    args: args.into(),\n+                    arg_types: arg_types.into(),\n+                    ret_type,\n+                    body,\n+                    closure_kind,\n+                    capture_by,\n+                };\n+                result_expr_id\n+            }),\n             ast::Expr::BinExpr(e) => {\n                 let op = e.op_kind();\n                 if let Some(ast::BinaryOp::Assignment { op: None }) = op {\n@@ -528,9 +564,18 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::Expr::TupleExpr(e) => {\n-                let exprs = e.fields().map(|expr| self.collect_expr(expr)).collect();\n+                let mut exprs: Vec<_> = e.fields().map(|expr| self.collect_expr(expr)).collect();\n+                // if there is a leading comma, the user is most likely to type out a leading expression\n+                // so we insert a missing expression at the beginning for IDE features\n+                if comma_follows_token(e.l_paren_token()) {\n+                    exprs.insert(0, self.missing_expr());\n+                }\n+\n                 self.alloc_expr(\n-                    Expr::Tuple { exprs, is_assignee_expr: self.is_lowering_assignee_expr },\n+                    Expr::Tuple {\n+                        exprs: exprs.into_boxed_slice(),\n+                        is_assignee_expr: self.is_lowering_assignee_expr,\n+                    },\n                     syntax_ptr,\n                 )\n             }\n@@ -555,7 +600,17 @@ impl ExprCollector<'_> {\n                     }\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n                         let initializer = self.collect_expr_opt(initializer);\n-                        let repeat = self.collect_expr_opt(repeat);\n+                        let repeat = self.with_label_rib(RibKind::Constant, |this| {\n+                            if let Some(repeat) = repeat {\n+                                let syntax_ptr = AstPtr::new(&repeat);\n+                                this.collect_as_a_binding_owner_bad(\n+                                    |this| this.collect_expr(repeat),\n+                                    syntax_ptr,\n+                                )\n+                            } else {\n+                                this.missing_expr()\n+                            }\n+                        });\n                         self.alloc_expr(\n                             Expr::Array(Array::Repeat { initializer, repeat }),\n                             syntax_ptr,\n@@ -601,6 +656,244 @@ impl ExprCollector<'_> {\n         })\n     }\n \n+    fn initialize_binding_owner(\n+        &mut self,\n+        syntax_ptr: AstPtr<ast::Expr>,\n+    ) -> (ExprId, Option<ExprId>) {\n+        let result_expr_id = self.alloc_expr(Expr::Missing, syntax_ptr);\n+        let prev_binding_owner = self.current_binding_owner.take();\n+        self.current_binding_owner = Some(result_expr_id);\n+        (result_expr_id, prev_binding_owner)\n+    }\n+\n+    /// FIXME: This function is bad. It will produce a dangling `Missing` expr which wastes memory. Currently\n+    /// it is used only for const blocks and repeat expressions, which are also hacky and ideally should have\n+    /// their own body. Don't add more usage for this function so that we can remove this function after\n+    /// separating those bodies.\n+    fn collect_as_a_binding_owner_bad(\n+        &mut self,\n+        job: impl FnOnce(&mut ExprCollector<'_>) -> ExprId,\n+        syntax_ptr: AstPtr<ast::Expr>,\n+    ) -> ExprId {\n+        let (id, prev_owner) = self.initialize_binding_owner(syntax_ptr);\n+        let tmp = job(self);\n+        self.body.exprs[id] = mem::replace(&mut self.body.exprs[tmp], Expr::Missing);\n+        self.current_binding_owner = prev_owner;\n+        id\n+    }\n+\n+    /// Desugar `try { <stmts>; <expr> }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(<expr>) }`,\n+    /// `try { <stmts>; }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(()) }`\n+    /// and save the `<new_label>` to use it as a break target for desugaring of the `?` operator.\n+    fn desugar_try_block(&mut self, e: BlockExpr) -> ExprId {\n+        let Some(try_from_output) = LangItem::TryTraitFromOutput.path(self.db, self.krate) else {\n+            return self.collect_block(e);\n+        };\n+        let label = self.alloc_label_desugared(Label { name: Name::generate_new_name() });\n+        let old_label = self.current_try_block_label.replace(label);\n+\n+        let (btail, expr_id) = self.with_labeled_rib(label, |this| {\n+            let mut btail = None;\n+            let block = this.collect_block_(e, |id, statements, tail| {\n+                btail = tail;\n+                Expr::Block { id, statements, tail, label: Some(label) }\n+            });\n+            (btail, block)\n+        });\n+\n+        let callee = self.alloc_expr_desugared(Expr::Path(try_from_output));\n+        let next_tail = match btail {\n+            Some(tail) => self.alloc_expr_desugared(Expr::Call {\n+                callee,\n+                args: Box::new([tail]),\n+                is_assignee_expr: false,\n+            }),\n+            None => {\n+                let unit = self.alloc_expr_desugared(Expr::Tuple {\n+                    exprs: Box::new([]),\n+                    is_assignee_expr: false,\n+                });\n+                self.alloc_expr_desugared(Expr::Call {\n+                    callee,\n+                    args: Box::new([unit]),\n+                    is_assignee_expr: false,\n+                })\n+            }\n+        };\n+        let Expr::Block { tail, .. } = &mut self.body.exprs[expr_id] else {\n+            unreachable!(\"block was lowered to non-block\");\n+        };\n+        *tail = Some(next_tail);\n+        self.current_try_block_label = old_label;\n+        expr_id\n+    }\n+\n+    /// Desugar `ast::ForExpr` from: `[opt_ident]: for <pat> in <head> <body>` into:\n+    /// ```ignore (pseudo-rust)\n+    /// match IntoIterator::into_iter(<head>) {\n+    ///     mut iter => {\n+    ///         [opt_ident]: loop {\n+    ///             match Iterator::next(&mut iter) {\n+    ///                 None => break,\n+    ///                 Some(<pat>) => <body>,\n+    ///             };\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    fn collect_for_loop(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::ForExpr) -> ExprId {\n+        let (into_iter_fn, iter_next_fn, option_some, option_none) = 'if_chain: {\n+            if let Some(into_iter_fn) = LangItem::IntoIterIntoIter.path(self.db, self.krate) {\n+                if let Some(iter_next_fn) = LangItem::IteratorNext.path(self.db, self.krate) {\n+                    if let Some(option_some) = LangItem::OptionSome.path(self.db, self.krate) {\n+                        if let Some(option_none) = LangItem::OptionNone.path(self.db, self.krate) {\n+                            break 'if_chain (into_iter_fn, iter_next_fn, option_some, option_none);\n+                        }\n+                    }\n+                }\n+            }\n+            // Some of the needed lang items are missing, so we can't desugar\n+            return self.alloc_expr(Expr::Missing, syntax_ptr);\n+        };\n+        let head = self.collect_expr_opt(e.iterable());\n+        let into_iter_fn_expr = self.alloc_expr(Expr::Path(into_iter_fn), syntax_ptr.clone());\n+        let iterator = self.alloc_expr(\n+            Expr::Call {\n+                callee: into_iter_fn_expr,\n+                args: Box::new([head]),\n+                is_assignee_expr: false,\n+            },\n+            syntax_ptr.clone(),\n+        );\n+        let none_arm = MatchArm {\n+            pat: self.alloc_pat_desugared(Pat::Path(Box::new(option_none))),\n+            guard: None,\n+            expr: self.alloc_expr(Expr::Break { expr: None, label: None }, syntax_ptr.clone()),\n+        };\n+        let some_pat = Pat::TupleStruct {\n+            path: Some(Box::new(option_some)),\n+            args: Box::new([self.collect_pat_top(e.pat())]),\n+            ellipsis: None,\n+        };\n+        let label = e.label().map(|label| self.collect_label(label));\n+        let some_arm = MatchArm {\n+            pat: self.alloc_pat_desugared(some_pat),\n+            guard: None,\n+            expr: self.with_opt_labeled_rib(label, |this| {\n+                this.collect_expr_opt(e.loop_body().map(|x| x.into()))\n+            }),\n+        };\n+        let iter_name = Name::generate_new_name();\n+        let iter_binding = self.alloc_binding(iter_name.clone(), BindingAnnotation::Mutable);\n+        let iter_expr = self.alloc_expr(Expr::Path(Path::from(iter_name)), syntax_ptr.clone());\n+        let iter_expr_mut = self.alloc_expr(\n+            Expr::Ref { expr: iter_expr, rawness: Rawness::Ref, mutability: Mutability::Mut },\n+            syntax_ptr.clone(),\n+        );\n+        let iter_next_fn_expr = self.alloc_expr(Expr::Path(iter_next_fn), syntax_ptr.clone());\n+        let iter_next_expr = self.alloc_expr(\n+            Expr::Call {\n+                callee: iter_next_fn_expr,\n+                args: Box::new([iter_expr_mut]),\n+                is_assignee_expr: false,\n+            },\n+            syntax_ptr.clone(),\n+        );\n+        let loop_inner = self.alloc_expr(\n+            Expr::Match { expr: iter_next_expr, arms: Box::new([none_arm, some_arm]) },\n+            syntax_ptr.clone(),\n+        );\n+        let loop_outer =\n+            self.alloc_expr(Expr::Loop { body: loop_inner, label }, syntax_ptr.clone());\n+        let iter_pat = self.alloc_pat_desugared(Pat::Bind { id: iter_binding, subpat: None });\n+        self.alloc_expr(\n+            Expr::Match {\n+                expr: iterator,\n+                arms: Box::new([MatchArm { pat: iter_pat, guard: None, expr: loop_outer }]),\n+            },\n+            syntax_ptr.clone(),\n+        )\n+    }\n+\n+    /// Desugar `ast::TryExpr` from: `<expr>?` into:\n+    /// ```ignore (pseudo-rust)\n+    /// match Try::branch(<expr>) {\n+    ///     ControlFlow::Continue(val) => val,\n+    ///     ControlFlow::Break(residual) =>\n+    ///         // If there is an enclosing `try {...}`:\n+    ///         break 'catch_target Try::from_residual(residual),\n+    ///         // Otherwise:\n+    ///         return Try::from_residual(residual),\n+    /// }\n+    /// ```\n+    fn collect_try_operator(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::TryExpr) -> ExprId {\n+        let (try_branch, cf_continue, cf_break, try_from_residual) = 'if_chain: {\n+            if let Some(try_branch) = LangItem::TryTraitBranch.path(self.db, self.krate) {\n+                if let Some(cf_continue) = LangItem::ControlFlowContinue.path(self.db, self.krate) {\n+                    if let Some(cf_break) = LangItem::ControlFlowBreak.path(self.db, self.krate) {\n+                        if let Some(try_from_residual) =\n+                            LangItem::TryTraitFromResidual.path(self.db, self.krate)\n+                        {\n+                            break 'if_chain (try_branch, cf_continue, cf_break, try_from_residual);\n+                        }\n+                    }\n+                }\n+            }\n+            // Some of the needed lang items are missing, so we can't desugar\n+            return self.alloc_expr(Expr::Missing, syntax_ptr);\n+        };\n+        let operand = self.collect_expr_opt(e.expr());\n+        let try_branch = self.alloc_expr(Expr::Path(try_branch), syntax_ptr.clone());\n+        let expr = self.alloc_expr(\n+            Expr::Call { callee: try_branch, args: Box::new([operand]), is_assignee_expr: false },\n+            syntax_ptr.clone(),\n+        );\n+        let continue_name = Name::generate_new_name();\n+        let continue_binding =\n+            self.alloc_binding(continue_name.clone(), BindingAnnotation::Unannotated);\n+        let continue_bpat =\n+            self.alloc_pat_desugared(Pat::Bind { id: continue_binding, subpat: None });\n+        self.add_definition_to_binding(continue_binding, continue_bpat);\n+        let continue_arm = MatchArm {\n+            pat: self.alloc_pat_desugared(Pat::TupleStruct {\n+                path: Some(Box::new(cf_continue)),\n+                args: Box::new([continue_bpat]),\n+                ellipsis: None,\n+            }),\n+            guard: None,\n+            expr: self.alloc_expr(Expr::Path(Path::from(continue_name)), syntax_ptr.clone()),\n+        };\n+        let break_name = Name::generate_new_name();\n+        let break_binding = self.alloc_binding(break_name.clone(), BindingAnnotation::Unannotated);\n+        let break_bpat = self.alloc_pat_desugared(Pat::Bind { id: break_binding, subpat: None });\n+        self.add_definition_to_binding(break_binding, break_bpat);\n+        let break_arm = MatchArm {\n+            pat: self.alloc_pat_desugared(Pat::TupleStruct {\n+                path: Some(Box::new(cf_break)),\n+                args: Box::new([break_bpat]),\n+                ellipsis: None,\n+            }),\n+            guard: None,\n+            expr: {\n+                let x = self.alloc_expr(Expr::Path(Path::from(break_name)), syntax_ptr.clone());\n+                let callee = self.alloc_expr(Expr::Path(try_from_residual), syntax_ptr.clone());\n+                let result = self.alloc_expr(\n+                    Expr::Call { callee, args: Box::new([x]), is_assignee_expr: false },\n+                    syntax_ptr.clone(),\n+                );\n+                self.alloc_expr(\n+                    match self.current_try_block_label {\n+                        Some(label) => Expr::Break { expr: Some(result), label: Some(label) },\n+                        None => Expr::Return { expr: Some(result) },\n+                    },\n+                    syntax_ptr.clone(),\n+                )\n+            },\n+        };\n+        let arms = Box::new([continue_arm, break_arm]);\n+        self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n+    }\n+\n     fn collect_macro_call<F, T, U>(\n         &mut self,\n         mcall: ast::MacroCall,\n@@ -616,7 +909,19 @@ impl ExprCollector<'_> {\n         let outer_file = self.expander.current_file_id;\n \n         let macro_call_ptr = self.expander.to_source(AstPtr::new(&mcall));\n-        let res = self.expander.enter_expand(self.db, mcall);\n+        let module = self.expander.module.local_id;\n+        let res = self.expander.enter_expand(self.db, mcall, |path| {\n+            self.def_map\n+                .resolve_path(\n+                    self.db,\n+                    module,\n+                    &path,\n+                    crate::item_scope::BuiltinShadowMode::Other,\n+                    Some(MacroSubNs::Bang),\n+                )\n+                .0\n+                .take_macros()\n+        });\n \n         let res = match res {\n             Ok(res) => res,\n@@ -639,7 +944,7 @@ impl ExprCollector<'_> {\n                         krate: *krate,\n                     });\n                 }\n-                Some(ExpandError::RecursionOverflowPosioned) => {\n+                Some(ExpandError::RecursionOverflowPoisoned) => {\n                     // Recursion limit has been reached in the macro expansion tree, but not in\n                     // this very macro call. Don't add diagnostics to avoid duplication.\n                 }\n@@ -663,7 +968,11 @@ impl ExprCollector<'_> {\n                     self.db.ast_id_map(self.expander.current_file_id),\n                 );\n \n-                let id = collector(self, Some(expansion));\n+                if record_diagnostics {\n+                    // FIXME: Report parse errors here\n+                }\n+\n+                let id = collector(self, Some(expansion.tree()));\n                 self.ast_id_map = prev_ast_id_map;\n                 self.expander.exit(self.db, mark);\n                 id\n@@ -720,7 +1029,7 @@ impl ExprCollector<'_> {\n                 if self.check_cfg(&stmt).is_none() {\n                     return;\n                 }\n-                let pat = self.collect_pat_opt(stmt.pat());\n+                let pat = self.collect_pat_top(stmt.pat());\n                 let type_ref =\n                     stmt.ty().map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n                 let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n@@ -763,22 +1072,36 @@ impl ExprCollector<'_> {\n     fn collect_block_(\n         &mut self,\n         block: ast::BlockExpr,\n-        mk_block: impl FnOnce(BlockId, Box<[Statement]>, Option<ExprId>) -> Expr,\n+        mk_block: impl FnOnce(Option<BlockId>, Box<[Statement]>, Option<ExprId>) -> Expr,\n     ) -> ExprId {\n-        let file_local_id = self.ast_id_map.ast_id(&block);\n-        let ast_id = AstId::new(self.expander.current_file_id, file_local_id);\n-        let block_loc =\n-            BlockLoc { ast_id, module: self.expander.def_map.module_id(self.expander.module) };\n-        let block_id = self.db.intern_block(block_loc);\n-\n-        let (module, def_map) = match self.db.block_def_map(block_id) {\n-            Some(def_map) => {\n-                self.body.block_scopes.push(block_id);\n-                (def_map.root(), def_map)\n-            }\n-            None => (self.expander.module, self.expander.def_map.clone()),\n+        let block_has_items = {\n+            let statement_has_item = block.statements().any(|stmt| match stmt {\n+                ast::Stmt::Item(_) => true,\n+                // Macro calls can be both items and expressions. The syntax library always treats\n+                // them as expressions here, so we undo that.\n+                ast::Stmt::ExprStmt(es) => matches!(es.expr(), Some(ast::Expr::MacroExpr(_))),\n+                _ => false,\n+            });\n+            statement_has_item || matches!(block.tail_expr(), Some(ast::Expr::MacroExpr(_)))\n+        };\n+\n+        let block_id = if block_has_items {\n+            let file_local_id = self.ast_id_map.ast_id(&block);\n+            let ast_id = AstId::new(self.expander.current_file_id, file_local_id);\n+            Some(self.db.intern_block(BlockLoc { ast_id, module: self.expander.module }))\n+        } else {\n+            None\n         };\n-        let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n+\n+        let (module, def_map) =\n+            match block_id.map(|block_id| (self.db.block_def_map(block_id), block_id)) {\n+                Some((def_map, block_id)) => {\n+                    self.body.block_scopes.push(block_id);\n+                    (def_map.module_id(DefMap::ROOT), def_map)\n+                }\n+                None => (self.expander.module, self.def_map.clone()),\n+            };\n+        let prev_def_map = mem::replace(&mut self.def_map, def_map);\n         let prev_local_module = mem::replace(&mut self.expander.module, module);\n \n         let mut statements = Vec::new();\n@@ -800,7 +1123,7 @@ impl ExprCollector<'_> {\n         let expr_id = self\n             .alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);\n \n-        self.expander.def_map = prev_def_map;\n+        self.def_map = prev_def_map;\n         self.expander.module = prev_local_module;\n         expr_id\n     }\n@@ -812,43 +1135,46 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {\n-        let label = Label {\n-            name: ast_label.lifetime().as_ref().map_or_else(Name::missing, Name::new_lifetime),\n-        };\n-        self.alloc_label(label, AstPtr::new(&ast_label))\n+    fn collect_labelled_block_opt(\n+        &mut self,\n+        label: Option<LabelId>,\n+        expr: Option<ast::BlockExpr>,\n+    ) -> ExprId {\n+        match label {\n+            Some(label) => self.with_labeled_rib(label, |this| this.collect_block_opt(expr)),\n+            None => self.collect_block_opt(expr),\n+        }\n     }\n \n-    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        self.collect_pat_(pat, &mut BindingList::default())\n-    }\n+    // region: patterns\n \n-    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+    fn collect_pat_top(&mut self, pat: Option<ast::Pat>) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat(pat),\n+            Some(pat) => self.collect_pat(pat, &mut BindingList::default()),\n             None => self.missing_pat(),\n         }\n     }\n \n-    fn collect_pat_(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {\n+    fn collect_pat(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {\n         let pattern = match &pat {\n             ast::Pat::IdentPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n \n                 let annotation =\n                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n-                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat, binding_list));\n+                let subpat = bp.pat().map(|subpat| self.collect_pat(subpat, binding_list));\n \n                 let is_simple_ident_pat =\n                     annotation == BindingAnnotation::Unannotated && subpat.is_none();\n                 let (binding, pattern) = if is_simple_ident_pat {\n                     // This could also be a single-segment path pattern. To\n                     // decide that, we need to try resolving the name.\n-                    let (resolved, _) = self.expander.def_map.resolve_path(\n+                    let (resolved, _) = self.def_map.resolve_path(\n                         self.db,\n-                        self.expander.module,\n+                        self.expander.module.local_id,\n                         &name.clone().into(),\n                         BuiltinShadowMode::Other,\n+                        None,\n                     );\n                     match resolved.take_values() {\n                         Some(ModuleDefId::ConstId(_)) => (None, Pat::Path(name.into())),\n@@ -887,11 +1213,15 @@ impl ExprCollector<'_> {\n             ast::Pat::TupleStructPat(p) => {\n                 let path =\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n+                let (args, ellipsis) = self.collect_tuple_pat(\n+                    p.fields(),\n+                    comma_follows_token(p.l_paren_token()),\n+                    binding_list,\n+                );\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n-                let pat = self.collect_pat_opt_(p.pat(), binding_list);\n+                let pat = self.collect_pat_opt(p.pat(), binding_list);\n                 let mutability = Mutability::from_mutable(p.mut_token().is_some());\n                 Pat::Ref { pat, mutability }\n             }\n@@ -900,13 +1230,42 @@ impl ExprCollector<'_> {\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n-            ast::Pat::OrPat(p) => {\n-                let pats = p.pats().map(|p| self.collect_pat_(p, binding_list)).collect();\n-                Pat::Or(pats)\n+            ast::Pat::OrPat(p) => 'b: {\n+                let prev_is_used = mem::take(&mut binding_list.is_used);\n+                let prev_reject_new = mem::take(&mut binding_list.reject_new);\n+                let mut pats = Vec::with_capacity(p.pats().count());\n+                let mut it = p.pats();\n+                let Some(first) = it.next() else {\n+                    break 'b Pat::Or(Box::new([]));\n+                };\n+                pats.push(self.collect_pat(first, binding_list));\n+                binding_list.reject_new = true;\n+                for rest in it {\n+                    for (_, x) in binding_list.is_used.iter_mut() {\n+                        *x = false;\n+                    }\n+                    pats.push(self.collect_pat(rest, binding_list));\n+                    for (&id, &x) in binding_list.is_used.iter() {\n+                        if !x {\n+                            self.body.bindings[id].problems =\n+                                Some(BindingProblems::NotBoundAcrossAll);\n+                        }\n+                    }\n+                }\n+                binding_list.reject_new = prev_reject_new;\n+                let current_is_used = mem::replace(&mut binding_list.is_used, prev_is_used);\n+                for (id, _) in current_is_used.into_iter() {\n+                    binding_list.check_is_used(self, id);\n+                }\n+                Pat::Or(pats.into())\n             }\n-            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat(), binding_list),\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat(), binding_list),\n             ast::Pat::TuplePat(p) => {\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n+                let (args, ellipsis) = self.collect_tuple_pat(\n+                    p.fields(),\n+                    comma_follows_token(p.l_paren_token()),\n+                    binding_list,\n+                );\n                 Pat::Tuple { args, ellipsis }\n             }\n             ast::Pat::WildcardPat(_) => Pat::Wild,\n@@ -919,7 +1278,7 @@ impl ExprCollector<'_> {\n                     .fields()\n                     .filter_map(|f| {\n                         let ast_pat = f.pat()?;\n-                        let pat = self.collect_pat_(ast_pat, binding_list);\n+                        let pat = self.collect_pat(ast_pat, binding_list);\n                         let name = f.field_name()?.as_name();\n                         Some(RecordFieldPat { name, pat })\n                     })\n@@ -938,26 +1297,18 @@ impl ExprCollector<'_> {\n \n                 // FIXME properly handle `RestPat`\n                 Pat::Slice {\n-                    prefix: prefix\n-                        .into_iter()\n-                        .map(|p| self.collect_pat_(p, binding_list))\n-                        .collect(),\n-                    slice: slice.map(|p| self.collect_pat_(p, binding_list)),\n-                    suffix: suffix\n-                        .into_iter()\n-                        .map(|p| self.collect_pat_(p, binding_list))\n-                        .collect(),\n+                    prefix: prefix.into_iter().map(|p| self.collect_pat(p, binding_list)).collect(),\n+                    slice: slice.map(|p| self.collect_pat(p, binding_list)),\n+                    suffix: suffix.into_iter().map(|p| self.collect_pat(p, binding_list)).collect(),\n                 }\n             }\n-            ast::Pat::LiteralPat(lit) => {\n-                if let Some(ast_lit) = lit.literal() {\n-                    let expr = Expr::Literal(ast_lit.kind().into());\n-                    let expr_ptr = AstPtr::new(&ast::Expr::Literal(ast_lit));\n-                    let expr_id = self.alloc_expr(expr, expr_ptr);\n-                    Pat::Lit(expr_id)\n-                } else {\n-                    Pat::Missing\n-                }\n+            #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5676\n+            ast::Pat::LiteralPat(lit) => 'b: {\n+                let Some((hir_lit, ast_lit)) = pat_literal_to_hir(lit) else { break 'b Pat::Missing };\n+                let expr = Expr::Literal(hir_lit);\n+                let expr_ptr = AstPtr::new(&ast::Expr::Literal(ast_lit));\n+                let expr_id = self.alloc_expr(expr, expr_ptr);\n+                Pat::Lit(expr_id)\n             }\n             ast::Pat::RestPat(_) => {\n                 // `RestPat` requires special handling and should not be mapped\n@@ -969,12 +1320,18 @@ impl ExprCollector<'_> {\n                 Pat::Missing\n             }\n             ast::Pat::BoxPat(boxpat) => {\n-                let inner = self.collect_pat_opt_(boxpat.pat(), binding_list);\n+                let inner = self.collect_pat_opt(boxpat.pat(), binding_list);\n                 Pat::Box { inner }\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n-                if let Some(expr) = const_block_pat.block_expr() {\n-                    let expr_id = self.collect_block(expr);\n+                if let Some(block) = const_block_pat.block_expr() {\n+                    let expr_id = self.with_label_rib(RibKind::Constant, |this| {\n+                        let syntax_ptr = AstPtr::new(&block.clone().into());\n+                        this.collect_as_a_binding_owner_bad(\n+                            |this| this.collect_block(block),\n+                            syntax_ptr,\n+                        )\n+                    });\n                     Pat::ConstBlock(expr_id)\n                 } else {\n                     Pat::Missing\n@@ -986,44 +1343,74 @@ impl ExprCollector<'_> {\n                     let src = self.expander.to_source(Either::Left(AstPtr::new(&pat)));\n                     let pat =\n                         self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n-                            this.collect_pat_opt_(expanded_pat, binding_list)\n+                            this.collect_pat_opt(expanded_pat, binding_list)\n                         });\n                     self.source_map.pat_map.insert(src, pat);\n                     return pat;\n                 }\n                 None => Pat::Missing,\n             },\n-            // FIXME: implement\n-            ast::Pat::RangePat(_) => Pat::Missing,\n+            // FIXME: implement in a way that also builds source map and calculates assoc resolutions in type inference.\n+            ast::Pat::RangePat(p) => {\n+                let mut range_part_lower = |p: Option<ast::Pat>| {\n+                    p.and_then(|x| match &x {\n+                        ast::Pat::LiteralPat(x) => {\n+                            Some(Box::new(LiteralOrConst::Literal(pat_literal_to_hir(x)?.0)))\n+                        }\n+                        ast::Pat::IdentPat(p) => {\n+                            let name =\n+                                p.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+                            Some(Box::new(LiteralOrConst::Const(name.into())))\n+                        }\n+                        ast::Pat::PathPat(p) => p\n+                            .path()\n+                            .and_then(|path| self.expander.parse_path(self.db, path))\n+                            .map(LiteralOrConst::Const)\n+                            .map(Box::new),\n+                        _ => None,\n+                    })\n+                };\n+                let start = range_part_lower(p.start());\n+                let end = range_part_lower(p.end());\n+                Pat::Range { start, end }\n+            }\n         };\n         let ptr = AstPtr::new(&pat);\n         self.alloc_pat(pattern, Either::Left(ptr))\n     }\n \n-    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>, binding_list: &mut BindingList) -> PatId {\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>, binding_list: &mut BindingList) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat_(pat, binding_list),\n+            Some(pat) => self.collect_pat(pat, binding_list),\n             None => self.missing_pat(),\n         }\n     }\n \n     fn collect_tuple_pat(\n         &mut self,\n         args: AstChildren<ast::Pat>,\n+        has_leading_comma: bool,\n         binding_list: &mut BindingList,\n     ) -> (Box<[PatId]>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possibility of there being multiple `..` here.\n         let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n         // We want to skip the `..` pattern here, since we account for it above.\n-        let args = args\n+        let mut args: Vec<_> = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n-            .map(|p| self.collect_pat_(p, binding_list))\n+            .map(|p| self.collect_pat(p, binding_list))\n             .collect();\n+        // if there is a leading comma, the user is most likely to type out a leading pattern\n+        // so we insert a missing pattern at the beginning for IDE features\n+        if has_leading_comma {\n+            args.insert(0, self.missing_pat());\n+        }\n \n-        (args, ellipsis)\n+        (args.into_boxed_slice(), ellipsis)\n     }\n \n+    // endregion: patterns\n+\n     /// Returns `None` (and emits diagnostics) when `owner` if `#[cfg]`d out, and `Some(())` when\n     /// not.\n     fn check_cfg(&mut self, owner: &dyn ast::HasAttrs) -> Option<()> {\n@@ -1051,42 +1438,147 @@ impl ExprCollector<'_> {\n     fn add_definition_to_binding(&mut self, binding_id: BindingId, pat_id: PatId) {\n         self.body.bindings[binding_id].definitions.push(pat_id);\n     }\n-}\n \n-impl From<ast::LiteralKind> for Literal {\n-    fn from(ast_lit_kind: ast::LiteralKind) -> Self {\n-        match ast_lit_kind {\n-            // FIXME: these should have actual values filled in, but unsure on perf impact\n-            LiteralKind::IntNumber(lit) => {\n-                if let builtin @ Some(_) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n-                    Literal::Float(\n-                        FloatTypeWrapper::new(lit.float_value().unwrap_or(Default::default())),\n-                        builtin,\n-                    )\n-                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinInt::from_suffix) {\n-                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n-                } else {\n-                    let builtin = lit.suffix().and_then(BuiltinUint::from_suffix);\n-                    Literal::Uint(lit.value().unwrap_or(0), builtin)\n+    // region: labels\n+\n+    fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {\n+        let label = Label {\n+            name: ast_label.lifetime().as_ref().map_or_else(Name::missing, Name::new_lifetime),\n+        };\n+        self.alloc_label(label, AstPtr::new(&ast_label))\n+    }\n+\n+    fn resolve_label(\n+        &self,\n+        lifetime: Option<ast::Lifetime>,\n+    ) -> Result<Option<LabelId>, BodyDiagnostic> {\n+        let Some(lifetime) = lifetime else {\n+            return Ok(None)\n+        };\n+        let name = Name::new_lifetime(&lifetime);\n+\n+        for (rib_idx, rib) in self.label_ribs.iter().enumerate().rev() {\n+            if let Some((label_name, id)) = &rib.label {\n+                if *label_name == name {\n+                    return if self.is_label_valid_from_rib(rib_idx) {\n+                        Ok(Some(*id))\n+                    } else {\n+                        Err(BodyDiagnostic::UnreachableLabel {\n+                            name,\n+                            node: InFile::new(\n+                                self.expander.current_file_id,\n+                                AstPtr::new(&lifetime),\n+                            ),\n+                        })\n+                    };\n                 }\n             }\n-            LiteralKind::FloatNumber(lit) => {\n-                let ty = lit.suffix().and_then(BuiltinFloat::from_suffix);\n-                Literal::Float(FloatTypeWrapper::new(lit.value().unwrap_or(Default::default())), ty)\n-            }\n-            LiteralKind::ByteString(bs) => {\n-                let text = bs.value().map(Box::from).unwrap_or_else(Default::default);\n-                Literal::ByteString(text)\n-            }\n-            LiteralKind::String(s) => {\n-                let text = s.value().map(Box::from).unwrap_or_else(Default::default);\n-                Literal::String(text)\n-            }\n-            LiteralKind::Byte(b) => {\n-                Literal::Uint(b.value().unwrap_or_default() as u128, Some(BuiltinUint::U8))\n-            }\n-            LiteralKind::Char(c) => Literal::Char(c.value().unwrap_or_default()),\n-            LiteralKind::Bool(val) => Literal::Bool(val),\n         }\n+\n+        Err(BodyDiagnostic::UndeclaredLabel {\n+            name,\n+            node: InFile::new(self.expander.current_file_id, AstPtr::new(&lifetime)),\n+        })\n     }\n+\n+    fn is_label_valid_from_rib(&self, rib_index: usize) -> bool {\n+        !self.label_ribs[rib_index + 1..].iter().any(|rib| rib.kind.is_label_barrier())\n+    }\n+\n+    fn with_label_rib<T>(&mut self, kind: RibKind, f: impl FnOnce(&mut Self) -> T) -> T {\n+        self.label_ribs.push(LabelRib::new(kind));\n+        let res = f(self);\n+        self.label_ribs.pop();\n+        res\n+    }\n+\n+    fn with_labeled_rib<T>(&mut self, label: LabelId, f: impl FnOnce(&mut Self) -> T) -> T {\n+        self.label_ribs.push(LabelRib::new_normal((self.body[label].name.clone(), label)));\n+        let res = f(self);\n+        self.label_ribs.pop();\n+        res\n+    }\n+\n+    fn with_opt_labeled_rib<T>(\n+        &mut self,\n+        label: Option<LabelId>,\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n+        match label {\n+            None => f(self),\n+            Some(label) => self.with_labeled_rib(label, f),\n+        }\n+    }\n+    // endregion: labels\n+}\n+\n+fn pat_literal_to_hir(lit: &ast::LiteralPat) -> Option<(Literal, ast::Literal)> {\n+    let ast_lit = lit.literal()?;\n+    let mut hir_lit: Literal = ast_lit.kind().into();\n+    if lit.minus_token().is_some() {\n+        let Some(h) = hir_lit.negate() else {\n+            return None;\n+        };\n+        hir_lit = h;\n+    }\n+    Some((hir_lit, ast_lit))\n+}\n+\n+impl ExprCollector<'_> {\n+    fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.body.exprs.alloc(expr);\n+        self.source_map.expr_map_back.insert(id, src.clone());\n+        self.source_map.expr_map.insert(src, id);\n+        id\n+    }\n+    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n+        self.body.exprs.alloc(expr)\n+    }\n+    fn missing_expr(&mut self) -> ExprId {\n+        self.alloc_expr_desugared(Expr::Missing)\n+    }\n+\n+    fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation) -> BindingId {\n+        self.body.bindings.alloc(Binding {\n+            name,\n+            mode,\n+            definitions: SmallVec::new(),\n+            owner: self.current_binding_owner,\n+            problems: None,\n+        })\n+    }\n+\n+    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.body.pats.alloc(pat);\n+        self.source_map.pat_map_back.insert(id, src.clone());\n+        self.source_map.pat_map.insert(src, id);\n+        id\n+    }\n+    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {\n+        self.body.pats.alloc(pat)\n+    }\n+    fn missing_pat(&mut self) -> PatId {\n+        self.body.pats.alloc(Pat::Missing)\n+    }\n+\n+    fn alloc_label(&mut self, label: Label, ptr: LabelPtr) -> LabelId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.body.labels.alloc(label);\n+        self.source_map.label_map_back.insert(id, src.clone());\n+        self.source_map.label_map.insert(src, id);\n+        id\n+    }\n+    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_label_desugared(&mut self, label: Label) -> LabelId {\n+        self.body.labels.alloc(label)\n+    }\n+}\n+\n+fn comma_follows_token(t: Option<syntax::SyntaxToken>) -> bool {\n+    (|| syntax::algo::skip_trivia_token(t?.next_token()?, syntax::Direction::Next))()\n+        .map_or(false, |it| it.kind() == syntax::T![,])\n }"}, {"sha": "88380aa355d16c487632997f331942234c3ca541", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 83, "deletions": 54, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -2,58 +2,85 @@\n \n use std::fmt::{self, Write};\n \n+use hir_expand::db::ExpandDatabase;\n use syntax::ast::HasName;\n \n use crate::{\n-    expr::{Array, BindingAnnotation, BindingId, ClosureKind, Literal, Movability, Statement},\n+    hir::{\n+        Array, BindingAnnotation, BindingId, CaptureBy, ClosureKind, Literal, LiteralOrConst,\n+        Movability, Statement,\n+    },\n     pretty::{print_generic_args, print_path, print_type_ref},\n     type_ref::TypeRef,\n };\n \n use super::*;\n \n pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBodyId) -> String {\n-    let needs_semi;\n     let header = match owner {\n         DefWithBodyId::FunctionId(it) => {\n-            needs_semi = false;\n             let item_tree_id = it.lookup(db).id;\n-            format!(\"fn {}(\u2026) \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n+            format!(\n+                \"fn {}\",\n+                item_tree_id.item_tree(db)[item_tree_id.value].name.display(db.upcast())\n+            )\n         }\n         DefWithBodyId::StaticId(it) => {\n-            needs_semi = true;\n             let item_tree_id = it.lookup(db).id;\n-            format!(\"static {} = \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n+            format!(\n+                \"static {} = \",\n+                item_tree_id.item_tree(db)[item_tree_id.value].name.display(db.upcast())\n+            )\n         }\n         DefWithBodyId::ConstId(it) => {\n-            needs_semi = true;\n             let item_tree_id = it.lookup(db).id;\n             let name = match &item_tree_id.item_tree(db)[item_tree_id.value].name {\n-                Some(name) => name.to_string(),\n+                Some(name) => name.display(db.upcast()).to_string(),\n                 None => \"_\".to_string(),\n             };\n             format!(\"const {name} = \")\n         }\n         DefWithBodyId::VariantId(it) => {\n-            needs_semi = false;\n             let src = it.parent.child_source(db);\n             let variant = &src.value[it.local_id];\n-            let name = match &variant.name() {\n+            match &variant.name() {\n                 Some(name) => name.to_string(),\n                 None => \"_\".to_string(),\n-            };\n-            format!(\"{name}\")\n+            }\n         }\n     };\n \n-    let mut p = Printer { body, buf: header, indent_level: 0, needs_indent: false };\n+    let mut p =\n+        Printer { db: db.upcast(), body, buf: header, indent_level: 0, needs_indent: false };\n+    if let DefWithBodyId::FunctionId(it) = owner {\n+        p.buf.push('(');\n+        body.params.iter().zip(&db.function_data(it).params).for_each(|(&param, ty)| {\n+            p.print_pat(param);\n+            p.buf.push(':');\n+            p.print_type_ref(ty);\n+        });\n+        p.buf.push(')');\n+        p.buf.push(' ');\n+    }\n     p.print_expr(body.body_expr);\n-    if needs_semi {\n+    if matches!(owner, DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_)) {\n         p.buf.push(';');\n     }\n     p.buf\n }\n \n+pub(super) fn print_expr_hir(\n+    db: &dyn DefDatabase,\n+    body: &Body,\n+    _owner: DefWithBodyId,\n+    expr: ExprId,\n+) -> String {\n+    let mut p =\n+        Printer { db: db.upcast(), body, buf: String::new(), indent_level: 0, needs_indent: false };\n+    p.print_expr(expr);\n+    p.buf\n+}\n+\n macro_rules! w {\n     ($dst:expr, $($arg:tt)*) => {\n         { let _ = write!($dst, $($arg)*); }\n@@ -70,6 +97,7 @@ macro_rules! wln {\n }\n \n struct Printer<'a> {\n+    db: &'a dyn ExpandDatabase,\n     body: &'a Body,\n     buf: String,\n     indent_level: usize,\n@@ -144,29 +172,19 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Loop { body, label } => {\n                 if let Some(lbl) = label {\n-                    w!(self, \"{}: \", self.body[*lbl].name);\n+                    w!(self, \"{}: \", self.body[*lbl].name.display(self.db));\n                 }\n                 w!(self, \"loop \");\n                 self.print_expr(*body);\n             }\n             Expr::While { condition, body, label } => {\n                 if let Some(lbl) = label {\n-                    w!(self, \"{}: \", self.body[*lbl].name);\n+                    w!(self, \"{}: \", self.body[*lbl].name.display(self.db));\n                 }\n                 w!(self, \"while \");\n                 self.print_expr(*condition);\n                 self.print_expr(*body);\n             }\n-            Expr::For { iterable, pat, body, label } => {\n-                if let Some(lbl) = label {\n-                    w!(self, \"{}: \", self.body[*lbl].name);\n-                }\n-                w!(self, \"for \");\n-                self.print_pat(*pat);\n-                w!(self, \" in \");\n-                self.print_expr(*iterable);\n-                self.print_expr(*body);\n-            }\n             Expr::Call { callee, args, is_assignee_expr: _ } => {\n                 self.print_expr(*callee);\n                 w!(self, \"(\");\n@@ -182,10 +200,10 @@ impl<'a> Printer<'a> {\n             }\n             Expr::MethodCall { receiver, method_name, args, generic_args } => {\n                 self.print_expr(*receiver);\n-                w!(self, \".{}\", method_name);\n+                w!(self, \".{}\", method_name.display(self.db));\n                 if let Some(args) = generic_args {\n                     w!(self, \"::<\");\n-                    print_generic_args(args, self).unwrap();\n+                    print_generic_args(self.db, args, self).unwrap();\n                     w!(self, \">\");\n                 }\n                 w!(self, \"(\");\n@@ -219,14 +237,14 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Continue { label } => {\n                 w!(self, \"continue\");\n-                if let Some(label) = label {\n-                    w!(self, \" {}\", label);\n+                if let Some(lbl) = label {\n+                    w!(self, \" {}\", self.body[*lbl].name.display(self.db));\n                 }\n             }\n             Expr::Break { expr, label } => {\n                 w!(self, \"break\");\n-                if let Some(label) = label {\n-                    w!(self, \" {}\", label);\n+                if let Some(lbl) = label {\n+                    w!(self, \" {}\", self.body[*lbl].name.display(self.db));\n                 }\n                 if let Some(expr) = expr {\n                     self.whitespace();\n@@ -265,7 +283,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \"{{\");\n                 self.indented(|p| {\n                     for field in &**fields {\n-                        w!(p, \"{}: \", field.name);\n+                        w!(p, \"{}: \", field.name.display(self.db));\n                         p.print_expr(field.expr);\n                         wln!(p, \",\");\n                     }\n@@ -282,16 +300,12 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Field { expr, name } => {\n                 self.print_expr(*expr);\n-                w!(self, \".{}\", name);\n+                w!(self, \".{}\", name.display(self.db));\n             }\n             Expr::Await { expr } => {\n                 self.print_expr(*expr);\n                 w!(self, \".await\");\n             }\n-            Expr::Try { expr } => {\n-                self.print_expr(*expr);\n-                w!(self, \"?\");\n-            }\n             Expr::Cast { expr, type_ref } => {\n                 self.print_expr(*expr);\n                 w!(self, \" as \");\n@@ -359,7 +373,7 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*index);\n                 w!(self, \"]\");\n             }\n-            Expr::Closure { args, arg_types, ret_type, body, closure_kind } => {\n+            Expr::Closure { args, arg_types, ret_type, body, closure_kind, capture_by } => {\n                 match closure_kind {\n                     ClosureKind::Generator(Movability::Static) => {\n                         w!(self, \"static \");\n@@ -369,6 +383,12 @@ impl<'a> Printer<'a> {\n                     }\n                     _ => (),\n                 }\n+                match capture_by {\n+                    CaptureBy::Value => {\n+                        w!(self, \"move \");\n+                    }\n+                    CaptureBy::Ref => (),\n+                }\n                 w!(self, \"|\");\n                 for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {\n                     if i != 0 {\n@@ -418,28 +438,25 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Literal(lit) => self.print_literal(lit),\n             Expr::Block { id: _, statements, tail, label } => {\n-                let label = label.map(|lbl| format!(\"{}: \", self.body[lbl].name));\n+                let label = label.map(|lbl| format!(\"{}: \", self.body[lbl].name.display(self.db)));\n                 self.print_block(label.as_deref(), statements, tail);\n             }\n             Expr::Unsafe { id: _, statements, tail } => {\n                 self.print_block(Some(\"unsafe \"), statements, tail);\n             }\n-            Expr::TryBlock { id: _, statements, tail } => {\n-                self.print_block(Some(\"try \"), statements, tail);\n-            }\n             Expr::Async { id: _, statements, tail } => {\n                 self.print_block(Some(\"async \"), statements, tail);\n             }\n-            Expr::Const { id: _, statements, tail } => {\n-                self.print_block(Some(\"const \"), statements, tail);\n+            Expr::Const(id) => {\n+                w!(self, \"const {{ /* {id:?} */ }}\");\n             }\n         }\n     }\n \n     fn print_block(\n         &mut self,\n         label: Option<&str>,\n-        statements: &Box<[Statement]>,\n+        statements: &[Statement],\n         tail: &Option<la_arena::Idx<Expr>>,\n     ) {\n         self.whitespace();\n@@ -449,7 +466,7 @@ impl<'a> Printer<'a> {\n         w!(self, \"{{\");\n         if !statements.is_empty() || tail.is_some() {\n             self.indented(|p| {\n-                for stmt in &**statements {\n+                for stmt in statements {\n                     p.print_stmt(stmt);\n                 }\n                 if let Some(tail) = tail {\n@@ -497,7 +514,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \" {{\");\n                 self.indented(|p| {\n                     for arg in args.iter() {\n-                        w!(p, \"{}: \", arg.name);\n+                        w!(p, \"{}: \", arg.name.display(self.db));\n                         p.print_pat(arg.pat);\n                         wln!(p, \",\");\n                     }\n@@ -508,9 +525,13 @@ impl<'a> Printer<'a> {\n                 w!(self, \"}}\");\n             }\n             Pat::Range { start, end } => {\n-                self.print_expr(*start);\n-                w!(self, \"...\");\n-                self.print_expr(*end);\n+                if let Some(start) = start {\n+                    self.print_literal_or_const(start);\n+                }\n+                w!(self, \"..=\");\n+                if let Some(end) = end {\n+                    self.print_literal_or_const(end);\n+                }\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n                 w!(self, \"[\");\n@@ -601,10 +622,18 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n+    fn print_literal_or_const(&mut self, literal_or_const: &LiteralOrConst) {\n+        match literal_or_const {\n+            LiteralOrConst::Literal(l) => self.print_literal(l),\n+            LiteralOrConst::Const(c) => self.print_path(c),\n+        }\n+    }\n+\n     fn print_literal(&mut self, literal: &Literal) {\n         match literal {\n             Literal::String(it) => w!(self, \"{:?}\", it),\n             Literal::ByteString(it) => w!(self, \"\\\"{}\\\"\", it.escape_ascii()),\n+            Literal::CString(it) => w!(self, \"\\\"{}\\\\0\\\"\", it),\n             Literal::Char(it) => w!(self, \"'{}'\", it.escape_debug()),\n             Literal::Bool(it) => w!(self, \"{}\", it),\n             Literal::Int(i, suffix) => {\n@@ -629,11 +658,11 @@ impl<'a> Printer<'a> {\n     }\n \n     fn print_type_ref(&mut self, ty: &TypeRef) {\n-        print_type_ref(ty, self).unwrap();\n+        print_type_ref(self.db, ty, self).unwrap();\n     }\n \n     fn print_path(&mut self, path: &Path) {\n-        print_path(path, self).unwrap();\n+        print_path(self.db, path, self).unwrap();\n     }\n \n     fn print_binding(&mut self, id: BindingId) {\n@@ -644,6 +673,6 @@ impl<'a> Printer<'a> {\n             BindingAnnotation::Ref => \"ref \",\n             BindingAnnotation::RefMut => \"ref mut \",\n         };\n-        w!(self, \"{}{}\", mode, name);\n+        w!(self, \"{}{}\", mode, name.display(self.db));\n     }\n }"}, {"sha": "69741c445fbae4e3f720f3ed8b09691db99aa82e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,14 +1,13 @@\n //! Name resolution for expressions.\n-use std::sync::Arc;\n-\n use hir_expand::name::Name;\n-use la_arena::{Arena, Idx};\n+use la_arena::{Arena, Idx, IdxRange, RawIdx};\n use rustc_hash::FxHashMap;\n+use triomphe::Arc;\n \n use crate::{\n     body::Body,\n     db::DefDatabase,\n-    expr::{Binding, BindingId, Expr, ExprId, LabelId, Pat, PatId, Statement},\n+    hir::{Binding, BindingId, Expr, ExprId, LabelId, Pat, PatId, Statement},\n     BlockId, DefWithBodyId,\n };\n \n@@ -17,6 +16,7 @@ pub type ScopeId = Idx<ScopeData>;\n #[derive(Debug, PartialEq, Eq)]\n pub struct ExprScopes {\n     scopes: Arena<ScopeData>,\n+    scope_entries: Arena<ScopeEntry>,\n     scope_by_expr: FxHashMap<ExprId, ScopeId>,\n }\n \n@@ -41,7 +41,7 @@ pub struct ScopeData {\n     parent: Option<ScopeId>,\n     block: Option<BlockId>,\n     label: Option<(LabelId, Name)>,\n-    entries: Vec<ScopeEntry>,\n+    entries: IdxRange<ScopeEntry>,\n }\n \n impl ExprScopes {\n@@ -53,7 +53,7 @@ impl ExprScopes {\n     }\n \n     pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n+        &self.scope_entries[self.scopes[scope].entries.clone()]\n     }\n \n     /// If `scope` refers to a block expression scope, returns the corresponding `BlockId`.\n@@ -85,51 +85,69 @@ impl ExprScopes {\n     }\n }\n \n+fn empty_entries(idx: usize) -> IdxRange<ScopeEntry> {\n+    IdxRange::new(Idx::from_raw(RawIdx::from(idx as u32))..Idx::from_raw(RawIdx::from(idx as u32)))\n+}\n+\n impl ExprScopes {\n     fn new(body: &Body) -> ExprScopes {\n-        let mut scopes =\n-            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n+        let mut scopes = ExprScopes {\n+            scopes: Arena::default(),\n+            scope_entries: Arena::default(),\n+            scope_by_expr: FxHashMap::default(),\n+        };\n         let mut root = scopes.root_scope();\n         scopes.add_params_bindings(body, root, &body.params);\n         compute_expr_scopes(body.body_expr, body, &mut scopes, &mut root);\n         scopes\n     }\n \n     fn root_scope(&mut self) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: None, block: None, label: None, entries: vec![] })\n+        self.scopes.alloc(ScopeData {\n+            parent: None,\n+            block: None,\n+            label: None,\n+            entries: empty_entries(self.scope_entries.len()),\n+        })\n     }\n \n     fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n         self.scopes.alloc(ScopeData {\n             parent: Some(parent),\n             block: None,\n             label: None,\n-            entries: vec![],\n+            entries: empty_entries(self.scope_entries.len()),\n         })\n     }\n \n     fn new_labeled_scope(&mut self, parent: ScopeId, label: Option<(LabelId, Name)>) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: Some(parent), block: None, label, entries: vec![] })\n+        self.scopes.alloc(ScopeData {\n+            parent: Some(parent),\n+            block: None,\n+            label,\n+            entries: empty_entries(self.scope_entries.len()),\n+        })\n     }\n \n     fn new_block_scope(\n         &mut self,\n         parent: ScopeId,\n-        block: BlockId,\n+        block: Option<BlockId>,\n         label: Option<(LabelId, Name)>,\n     ) -> ScopeId {\n         self.scopes.alloc(ScopeData {\n             parent: Some(parent),\n-            block: Some(block),\n+            block,\n             label,\n-            entries: vec![],\n+            entries: empty_entries(self.scope_entries.len()),\n         })\n     }\n \n     fn add_bindings(&mut self, body: &Body, scope: ScopeId, binding: BindingId) {\n         let Binding { name, .. } = &body.bindings[binding];\n-        let entry = ScopeEntry { name: name.clone(), binding };\n-        self.scopes[scope].entries.push(entry);\n+        let entry = self.scope_entries.alloc(ScopeEntry { name: name.clone(), binding });\n+        self.scopes[scope].entries =\n+            IdxRange::new_inclusive(self.scopes[scope].entries.start()..=entry);\n     }\n \n     fn add_pat_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n@@ -150,9 +168,9 @@ impl ExprScopes {\n     }\n \n     fn shrink_to_fit(&mut self) {\n-        let ExprScopes { scopes, scope_by_expr } = self;\n+        let ExprScopes { scopes, scope_entries, scope_by_expr } = self;\n         scopes.shrink_to_fit();\n-        scopes.values_mut().for_each(|it| it.entries.shrink_to_fit());\n+        scope_entries.shrink_to_fit();\n         scope_by_expr.shrink_to_fit();\n     }\n }\n@@ -200,22 +218,16 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n             scopes.set_scope(expr, scope);\n             compute_block_scopes(statements, *tail, body, scopes, &mut scope);\n         }\n-        Expr::Unsafe { id, statements, tail }\n-        | Expr::Async { id, statements, tail }\n-        | Expr::Const { id, statements, tail }\n-        | Expr::TryBlock { id, statements, tail } => {\n+        Expr::Const(_) => {\n+            // FIXME: This is broken.\n+        }\n+        Expr::Unsafe { id, statements, tail } | Expr::Async { id, statements, tail } => {\n             let mut scope = scopes.new_block_scope(*scope, *id, None);\n             // Overwrite the old scope for the block expr, so that every block scope can be found\n             // via the block itself (important for blocks that only contain items, no expressions).\n             scopes.set_scope(expr, scope);\n             compute_block_scopes(statements, *tail, body, scopes, &mut scope);\n         }\n-        Expr::For { iterable, pat, body: body_expr, label } => {\n-            compute_expr_scopes(*iterable, body, scopes, scope);\n-            let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n-            scopes.add_pat_bindings(body, scope, *pat);\n-            compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n-        }\n         Expr::While { condition, body: body_expr, label } => {\n             let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n             compute_expr_scopes(*condition, body, scopes, &mut scope);"}, {"sha": "6e77744f21539f6e3d08c9c6149640b37261d14f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/tests/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -148,8 +148,8 @@ fn f() {\n }\n     \"#,\n         expect![[r#\"\n-            BlockId(1) in ModuleId { krate: CrateId(0), block: Some(BlockId(0)), local_id: Idx::<ModuleData>(1) }\n-            BlockId(0) in ModuleId { krate: CrateId(0), block: None, local_id: Idx::<ModuleData>(0) }\n+            BlockId(1) in BlockRelativeModuleId { block: Some(BlockId(0)), local_id: Idx::<ModuleData>(1) }\n+            BlockId(0) in BlockRelativeModuleId { block: None, local_id: Idx::<ModuleData>(0) }\n             crate scope\n         \"#]],\n     );"}, {"sha": "61b2481978e2711f3587328cdeae18021b8e56fa", "filename": "src/tools/rust-analyzer/crates/hir-def/src/builtin_type.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -106,8 +106,14 @@ impl AsName for BuiltinType {\n \n impl fmt::Display for BuiltinType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let type_name = self.as_name();\n-        type_name.fmt(f)\n+        match self {\n+            BuiltinType::Char => f.write_str(\"char\"),\n+            BuiltinType::Bool => f.write_str(\"bool\"),\n+            BuiltinType::Str => f.write_str(\"str\"),\n+            BuiltinType::Int(it) => it.fmt(f),\n+            BuiltinType::Uint(it) => it.fmt(f),\n+            BuiltinType::Float(it) => it.fmt(f),\n+        }\n     }\n }\n "}, {"sha": "bb79e28f2673a0d1e50f9f050d4d70759e1608dc", "filename": "src/tools/rust-analyzer/crates/hir-def/src/child_by_source.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -10,9 +10,9 @@ use syntax::ast::HasDocComments;\n \n use crate::{\n     db::DefDatabase,\n-    dyn_map::DynMap,\n+    dyn_map::{keys, DynMap},\n     item_scope::ItemScope,\n-    keys,\n+    nameres::DefMap,\n     src::{HasChildSource, HasSource},\n     AdtId, AssocItemId, DefWithBodyId, EnumId, EnumVariantId, FieldId, ImplId, Lookup, MacroId,\n     ModuleDefId, ModuleId, TraitId, VariantId,\n@@ -206,7 +206,7 @@ impl ChildBySource for DefWithBodyId {\n         for (_, def_map) in body.blocks(db) {\n             // All block expressions are merged into the same map, because they logically all add\n             // inner items to the containing `DefWithBodyId`.\n-            def_map[def_map.root()].scope.child_by_source_to(db, res, file_id);\n+            def_map[DefMap::ROOT].scope.child_by_source_to(db, res, file_id);\n         }\n     }\n }"}, {"sha": "40e6a4308784c546cedd8ed462fe8bd198541d57", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data.rs", "status": "modified", "additions": 168, "deletions": 78, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,22 +1,28 @@\n //! Contains basic data about various HIR declarations.\n \n-use std::sync::Arc;\n+pub mod adt;\n \n-use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroDefKind};\n+use hir_expand::{\n+    name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefKind,\n+};\n use intern::Interned;\n use smallvec::SmallVec;\n-use syntax::ast;\n+use syntax::{ast, Parse};\n+use triomphe::Arc;\n \n use crate::{\n     attr::Attrs,\n-    body::{Expander, Mark},\n     db::DefDatabase,\n-    item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n+    expander::{Expander, Mark},\n+    item_tree::{\n+        self, AssocItem, FnFlags, ItemTree, ItemTreeId, MacroCall, ModItem, Param, TreeId,\n+    },\n+    macro_call_as_call_id, macro_id_to_def_id,\n     nameres::{\n         attr_resolution::ResolvedAttr,\n         diagnostics::DefDiagnostic,\n         proc_macro::{parse_macro_name_and_helper_attrs, ProcMacroKind},\n-        DefMap,\n+        DefMap, MacroSubNs,\n     },\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n@@ -28,9 +34,8 @@ use crate::{\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FunctionData {\n     pub name: Name,\n-    pub params: Vec<(Option<Name>, Interned<TypeRef>)>,\n+    pub params: Vec<Interned<TypeRef>>,\n     pub ret_type: Interned<TypeRef>,\n-    pub async_ret_type: Option<Interned<TypeRef>>,\n     pub attrs: Attrs,\n     pub visibility: RawVisibility,\n     pub abi: Option<Interned<str>>,\n@@ -43,16 +48,16 @@ impl FunctionData {\n     pub(crate) fn fn_data_query(db: &dyn DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n         let loc = func.lookup(db);\n         let krate = loc.container.module(db).krate;\n-        let crate_graph = db.crate_graph();\n-        let cfg_options = &crate_graph[krate].cfg_options;\n         let item_tree = loc.id.item_tree(db);\n         let func = &item_tree[loc.id.value];\n         let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n-            db.trait_data(trait_id).visibility.clone()\n+            trait_vis(db, trait_id)\n         } else {\n             item_tree[func.visibility].clone()\n         };\n \n+        let crate_graph = db.crate_graph();\n+        let cfg_options = &crate_graph[krate].cfg_options;\n         let enabled_params = func\n             .params\n             .clone()\n@@ -99,12 +104,11 @@ impl FunctionData {\n             params: enabled_params\n                 .clone()\n                 .filter_map(|id| match &item_tree[id] {\n-                    Param::Normal(name, ty) => Some((name.clone(), ty.clone())),\n+                    Param::Normal(ty) => Some(ty.clone()),\n                     Param::Varargs => None,\n                 })\n                 .collect(),\n             ret_type: func.ret_type.clone(),\n-            async_ret_type: func.async_ret_type.clone(),\n             attrs: item_tree.attrs(db, krate, ModItem::from(loc.id.value).into()),\n             visibility,\n             abi: func.abi.clone(),\n@@ -188,7 +192,7 @@ impl TypeAliasData {\n         let item_tree = loc.id.item_tree(db);\n         let typ = &item_tree[loc.id.value];\n         let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n-            db.trait_data(trait_id).visibility.clone()\n+            trait_vis(db, trait_id)\n         } else {\n             item_tree[typ.visibility].clone()\n         };\n@@ -471,7 +475,7 @@ impl ConstData {\n         let item_tree = loc.id.item_tree(db);\n         let konst = &item_tree[loc.id.value];\n         let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n-            db.trait_data(trait_id).visibility.clone()\n+            trait_vis(db, trait_id)\n         } else {\n             item_tree[konst.visibility].clone()\n         };\n@@ -519,7 +523,7 @@ struct AssocItemCollector<'a> {\n     db: &'a dyn DefDatabase,\n     module_id: ModuleId,\n     def_map: Arc<DefMap>,\n-    inactive_diagnostics: Vec<DefDiagnostic>,\n+    diagnostics: Vec<DefDiagnostic>,\n     container: ItemContainerId,\n     expander: Expander,\n \n@@ -542,7 +546,7 @@ impl<'a> AssocItemCollector<'a> {\n             expander: Expander::new(db, file_id, module_id),\n             items: Vec::new(),\n             attr_calls: Vec::new(),\n-            inactive_diagnostics: Vec::new(),\n+            diagnostics: Vec::new(),\n         }\n     }\n \n@@ -556,19 +560,18 @@ impl<'a> AssocItemCollector<'a> {\n         (\n             self.items,\n             if self.attr_calls.is_empty() { None } else { Some(Box::new(self.attr_calls)) },\n-            self.inactive_diagnostics,\n+            self.diagnostics,\n         )\n     }\n \n-    // FIXME: proc-macro diagnostics\n     fn collect(&mut self, item_tree: &ItemTree, tree_id: TreeId, assoc_items: &[AssocItem]) {\n         let container = self.container;\n         self.items.reserve(assoc_items.len());\n \n         'items: for &item in assoc_items {\n             let attrs = item_tree.attrs(self.db, self.module_id.krate, ModItem::from(item).into());\n             if !attrs.is_cfg_enabled(self.expander.cfg_options()) {\n-                self.inactive_diagnostics.push(DefDiagnostic::unconfigured_code(\n+                self.diagnostics.push(DefDiagnostic::unconfigured_code(\n                     self.module_id.local_id,\n                     InFile::new(self.expander.current_file_id(), item.ast_id(item_tree).upcast()),\n                     attrs.cfg().unwrap(),\n@@ -582,84 +585,164 @@ impl<'a> AssocItemCollector<'a> {\n                     AstId::new(self.expander.current_file_id(), item.ast_id(item_tree).upcast());\n                 let ast_id_with_path = AstIdWithPath { path: (*attr.path).clone(), ast_id };\n \n-                if let Ok(ResolvedAttr::Macro(call_id)) = self.def_map.resolve_attr_macro(\n+                match self.def_map.resolve_attr_macro(\n                     self.db,\n                     self.module_id.local_id,\n                     ast_id_with_path,\n                     attr,\n                 ) {\n-                    self.attr_calls.push((ast_id, call_id));\n-                    // If proc attribute macro expansion is disabled, skip expanding it here\n-                    if !self.db.enable_proc_attr_macros() {\n-                        continue 'attrs;\n-                    }\n-                    let loc = self.db.lookup_intern_macro_call(call_id);\n-                    if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n-                        // If there's no expander for the proc macro (e.g. the\n-                        // proc macro is ignored, or building the proc macro\n-                        // crate failed), skip expansion like we would if it was\n-                        // disabled. This is analogous to the handling in\n-                        // `DefCollector::collect_macros`.\n-                        if exp.is_dummy() {\n+                    Ok(ResolvedAttr::Macro(call_id)) => {\n+                        self.attr_calls.push((ast_id, call_id));\n+                        // If proc attribute macro expansion is disabled, skip expanding it here\n+                        if !self.db.expand_proc_attr_macros() {\n                             continue 'attrs;\n                         }\n-                    }\n-                    match self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id) {\n-                        ExpandResult { value: Some((mark, _)), .. } => {\n-                            self.collect_macro_items(mark);\n-                            continue 'items;\n+                        let loc = self.db.lookup_intern_macro_call(call_id);\n+                        if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n+                            // If there's no expander for the proc macro (e.g. the\n+                            // proc macro is ignored, or building the proc macro\n+                            // crate failed), skip expansion like we would if it was\n+                            // disabled. This is analogous to the handling in\n+                            // `DefCollector::collect_macros`.\n+                            if exp.is_dummy() {\n+                                continue 'attrs;\n+                            }\n                         }\n-                        ExpandResult { .. } => {}\n+\n+                        let res =\n+                            self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id);\n+                        self.collect_macro_items(res, &|| loc.kind.clone());\n+                        continue 'items;\n+                    }\n+                    Ok(_) => (),\n+                    Err(_) => {\n+                        self.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n+                            self.module_id.local_id,\n+                            MacroCallKind::Attr {\n+                                ast_id,\n+                                attr_args: Arc::new((tt::Subtree::empty(), Default::default())),\n+                                invoc_attr_index: attr.id,\n+                            },\n+                            attr.path().clone(),\n+                        ));\n                     }\n                 }\n             }\n \n-            match item {\n-                AssocItem::Function(id) => {\n-                    let item = &item_tree[id];\n+            self.collect_item(item_tree, tree_id, container, item);\n+        }\n+    }\n \n-                    let def =\n-                        FunctionLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n-                    self.items.push((item.name.clone(), def.into()));\n-                }\n-                AssocItem::Const(id) => {\n-                    let item = &item_tree[id];\n-\n-                    let name = match item.name.clone() {\n-                        Some(name) => name,\n-                        None => continue,\n-                    };\n-                    let def =\n-                        ConstLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n-                    self.items.push((name, def.into()));\n-                }\n-                AssocItem::TypeAlias(id) => {\n-                    let item = &item_tree[id];\n+    fn collect_item(\n+        &mut self,\n+        item_tree: &ItemTree,\n+        tree_id: TreeId,\n+        container: ItemContainerId,\n+        item: AssocItem,\n+    ) {\n+        match item {\n+            AssocItem::Function(id) => {\n+                let item = &item_tree[id];\n \n-                    let def = TypeAliasLoc { container, id: ItemTreeId::new(tree_id, id) }\n-                        .intern(self.db);\n-                    self.items.push((item.name.clone(), def.into()));\n-                }\n-                AssocItem::MacroCall(call) => {\n-                    if let Some(root) = self.db.parse_or_expand(self.expander.current_file_id()) {\n-                        let call = &item_tree[call];\n-\n-                        let ast_id_map = self.db.ast_id_map(self.expander.current_file_id());\n-                        let call = ast_id_map.get(call.ast_id).to_node(&root);\n-                        let _cx =\n-                            stdx::panic_context::enter(format!(\"collect_items MacroCall: {call}\"));\n-                        let res = self.expander.enter_expand::<ast::MacroItems>(self.db, call);\n-\n-                        if let Ok(ExpandResult { value: Some((mark, _)), .. }) = res {\n-                            self.collect_macro_items(mark);\n-                        }\n+                let def =\n+                    FunctionLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n+                self.items.push((item.name.clone(), def.into()));\n+            }\n+            AssocItem::Const(id) => {\n+                let item = &item_tree[id];\n+                let Some(name) = item.name.clone() else { return };\n+                let def = ConstLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n+                self.items.push((name, def.into()));\n+            }\n+            AssocItem::TypeAlias(id) => {\n+                let item = &item_tree[id];\n+\n+                let def =\n+                    TypeAliasLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n+                self.items.push((item.name.clone(), def.into()));\n+            }\n+            AssocItem::MacroCall(call) => {\n+                let file_id = self.expander.current_file_id();\n+                let MacroCall { ast_id, expand_to, ref path } = item_tree[call];\n+                let module = self.expander.module.local_id;\n+\n+                let resolver = |path| {\n+                    self.def_map\n+                        .resolve_path(\n+                            self.db,\n+                            module,\n+                            &path,\n+                            crate::item_scope::BuiltinShadowMode::Other,\n+                            Some(MacroSubNs::Bang),\n+                        )\n+                        .0\n+                        .take_macros()\n+                        .map(|it| macro_id_to_def_id(self.db, it))\n+                };\n+                match macro_call_as_call_id(\n+                    self.db.upcast(),\n+                    &AstIdWithPath::new(file_id, ast_id, Clone::clone(path)),\n+                    expand_to,\n+                    self.expander.module.krate(),\n+                    resolver,\n+                ) {\n+                    Ok(Some(call_id)) => {\n+                        let res =\n+                            self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id);\n+                        self.collect_macro_items(res, &|| hir_expand::MacroCallKind::FnLike {\n+                            ast_id: InFile::new(file_id, ast_id),\n+                            expand_to: hir_expand::ExpandTo::Items,\n+                        });\n+                    }\n+                    Ok(None) => (),\n+                    Err(_) => {\n+                        self.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n+                            self.module_id.local_id,\n+                            MacroCallKind::FnLike {\n+                                ast_id: InFile::new(file_id, ast_id),\n+                                expand_to,\n+                            },\n+                            Clone::clone(path),\n+                        ));\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn collect_macro_items(&mut self, mark: Mark) {\n+    fn collect_macro_items(\n+        &mut self,\n+        ExpandResult { value, err }: ExpandResult<Option<(Mark, Parse<ast::MacroItems>)>>,\n+        error_call_kind: &dyn Fn() -> hir_expand::MacroCallKind,\n+    ) {\n+        let Some((mark, parse)) = value else { return };\n+\n+        if let Some(err) = err {\n+            let diag = match err {\n+                // why is this reported here?\n+                hir_expand::ExpandError::UnresolvedProcMacro(krate) => {\n+                    DefDiagnostic::unresolved_proc_macro(\n+                        self.module_id.local_id,\n+                        error_call_kind(),\n+                        krate,\n+                    )\n+                }\n+                _ => DefDiagnostic::macro_error(\n+                    self.module_id.local_id,\n+                    error_call_kind(),\n+                    err.to_string(),\n+                ),\n+            };\n+            self.diagnostics.push(diag);\n+        }\n+        if let errors @ [_, ..] = parse.errors() {\n+            self.diagnostics.push(DefDiagnostic::macro_expansion_parse_error(\n+                self.module_id.local_id,\n+                error_call_kind(),\n+                errors.into(),\n+            ));\n+        }\n+\n         let tree_id = item_tree::TreeId::new(self.expander.current_file_id(), None);\n         let item_tree = tree_id.item_tree(self.db);\n         let iter: SmallVec<[_; 2]> =\n@@ -670,3 +753,10 @@ impl<'a> AssocItemCollector<'a> {\n         self.expander.exit(self.db, mark);\n     }\n }\n+\n+fn trait_vis(db: &dyn DefDatabase, trait_id: TraitId) -> RawVisibility {\n+    let ItemLoc { id: tree_id, .. } = trait_id.lookup(db);\n+    let item_tree = tree_id.item_tree(db);\n+    let tr_def = &item_tree[tree_id.value];\n+    item_tree[tr_def.visibility].clone()\n+}"}, {"sha": "6db5abccc9210097e353488bb7d333479fdf682c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data/adt.rs", "status": "renamed", "additions": 55, "deletions": 18, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata%2Fadt.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,8 +1,7 @@\n //! Defines hir-level representation of structs, enums and unions\n \n-use std::sync::Arc;\n-\n use base_db::CrateId;\n+use bitflags::bitflags;\n use cfg::CfgOptions;\n use either::Either;\n \n@@ -12,15 +11,17 @@ use hir_expand::{\n };\n use intern::Interned;\n use la_arena::{Arena, ArenaMap};\n-use rustc_abi::{Integer, IntegerType};\n+use rustc_abi::{Align, Integer, IntegerType, ReprFlags, ReprOptions};\n use syntax::ast::{self, HasName, HasVisibility};\n+use triomphe::Arc;\n \n use crate::{\n-    body::{CfgExpander, LowerCtx},\n     builtin_type::{BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n+    expander::CfgExpander,\n     item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n-    layout::{Align, ReprFlags, ReprOptions},\n+    lang_item::LangItem,\n+    lower::LowerCtx,\n     nameres::diagnostics::DefDiagnostic,\n     src::HasChildSource,\n     src::HasSource,\n@@ -39,8 +40,27 @@ pub struct StructData {\n     pub variant_data: Arc<VariantData>,\n     pub repr: Option<ReprOptions>,\n     pub visibility: RawVisibility,\n-    pub rustc_has_incoherent_inherent_impls: bool,\n-    pub fundamental: bool,\n+    pub flags: StructFlags,\n+}\n+\n+bitflags! {\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+    pub struct StructFlags: u8 {\n+        const NO_FLAGS         = 0;\n+        /// Indicates whether the struct is `PhantomData`.\n+        const IS_PHANTOM_DATA  = 1 << 2;\n+        /// Indicates whether the struct has a `#[fundamental]` attribute.\n+        const IS_FUNDAMENTAL   = 1 << 3;\n+        // FIXME: should this be a flag?\n+        /// Indicates whether the struct has a `#[rustc_has_incoherent_inherent_impls]` attribute.\n+        const IS_RUSTC_HAS_INCOHERENT_INHERENT_IMPL      = 1 << 4;\n+        /// Indicates whether this struct is `Box`.\n+        const IS_BOX           = 1 << 5;\n+        /// Indicates whether this struct is `ManuallyDrop`.\n+        const IS_MANUALLY_DROP = 1 << 6;\n+        /// Indicates whether this struct is `UnsafeCell`.\n+        const IS_UNSAFE_CELL   = 1 << 7;\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -174,10 +194,25 @@ impl StructData {\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n+\n         let attrs = item_tree.attrs(db, loc.container.krate, ModItem::from(loc.id.value).into());\n-        let rustc_has_incoherent_inherent_impls =\n-            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n-        let fundamental = attrs.by_key(\"fundamental\").exists();\n+\n+        let mut flags = StructFlags::NO_FLAGS;\n+        if attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists() {\n+            flags |= StructFlags::IS_RUSTC_HAS_INCOHERENT_INHERENT_IMPL;\n+        }\n+        if attrs.by_key(\"fundamental\").exists() {\n+            flags |= StructFlags::IS_FUNDAMENTAL;\n+        }\n+        if let Some(lang) = attrs.lang_item() {\n+            match lang {\n+                LangItem::PhantomData => flags |= StructFlags::IS_PHANTOM_DATA,\n+                LangItem::OwnedBox => flags |= StructFlags::IS_BOX,\n+                LangItem::ManuallyDrop => flags |= StructFlags::IS_MANUALLY_DROP,\n+                LangItem::UnsafeCell => flags |= StructFlags::IS_UNSAFE_CELL,\n+                _ => (),\n+            }\n+        }\n \n         let strukt = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -196,8 +231,7 @@ impl StructData {\n                 variant_data: Arc::new(variant_data),\n                 repr,\n                 visibility: item_tree[strukt.visibility].clone(),\n-                rustc_has_incoherent_inherent_impls,\n-                fundamental,\n+                flags,\n             }),\n             diagnostics.into(),\n         )\n@@ -218,9 +252,13 @@ impl StructData {\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n         let attrs = item_tree.attrs(db, loc.container.krate, ModItem::from(loc.id.value).into());\n-        let rustc_has_incoherent_inherent_impls =\n-            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n-        let fundamental = attrs.by_key(\"fundamental\").exists();\n+        let mut flags = StructFlags::NO_FLAGS;\n+        if attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists() {\n+            flags |= StructFlags::IS_RUSTC_HAS_INCOHERENT_INHERENT_IMPL;\n+        }\n+        if attrs.by_key(\"fundamental\").exists() {\n+            flags |= StructFlags::IS_FUNDAMENTAL;\n+        }\n \n         let union = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -239,8 +277,7 @@ impl StructData {\n                 variant_data: Arc::new(variant_data),\n                 repr,\n                 visibility: item_tree[union.visibility].clone(),\n-                rustc_has_incoherent_inherent_impls,\n-                fundamental,\n+                flags,\n             }),\n             diagnostics.into(),\n         )\n@@ -436,7 +473,7 @@ fn lower_struct(\n     trace: &mut Trace<FieldData, Either<ast::TupleField, ast::RecordField>>,\n     ast: &InFile<ast::StructKind>,\n ) -> StructKind {\n-    let ctx = LowerCtx::new(db, ast.file_id);\n+    let ctx = LowerCtx::new(db, &expander.hygiene(), ast.file_id);\n \n     match &ast.value {\n         ast::StructKind::Tuple(fl) => {", "previous_filename": "src/tools/rust-analyzer/crates/hir-def/src/adt.rs"}, {"sha": "6d18e3f56cabc63215f52441a953eff1ccffda4a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/db.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,32 +1,32 @@\n //! Defines database & queries for name resolution.\n-use std::sync::Arc;\n-\n use base_db::{salsa, CrateId, SourceDatabase, Upcast};\n use either::Either;\n use hir_expand::{db::ExpandDatabase, HirFileId};\n use intern::Interned;\n use la_arena::ArenaMap;\n use syntax::{ast, AstPtr};\n+use triomphe::Arc;\n \n use crate::{\n-    adt::{EnumData, StructData},\n     attr::{Attrs, AttrsWithOwner},\n     body::{scope::ExprScopes, Body, BodySourceMap},\n     data::{\n+        adt::{EnumData, StructData},\n         ConstData, FunctionData, ImplData, Macro2Data, MacroRulesData, ProcMacroData, StaticData,\n         TraitAliasData, TraitData, TypeAliasData,\n     },\n     generics::GenericParams,\n+    hir::ExprId,\n     import_map::ImportMap,\n     item_tree::{AttrOwner, ItemTree},\n     lang_item::{LangItem, LangItemTarget, LangItems},\n     nameres::{diagnostics::DefDiagnostic, DefMap},\n     visibility::{self, Visibility},\n-    AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, ExternBlockId,\n-    ExternBlockLoc, FunctionId, FunctionLoc, GenericDefId, ImplId, ImplLoc, LocalEnumVariantId,\n-    LocalFieldId, Macro2Id, Macro2Loc, MacroRulesId, MacroRulesLoc, ProcMacroId, ProcMacroLoc,\n-    StaticId, StaticLoc, StructId, StructLoc, TraitAliasId, TraitAliasLoc, TraitId, TraitLoc,\n-    TypeAliasId, TypeAliasLoc, UnionId, UnionLoc, VariantId,\n+    AnonymousConstId, AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId,\n+    EnumLoc, ExternBlockId, ExternBlockLoc, FunctionId, FunctionLoc, GenericDefId, ImplId, ImplLoc,\n+    LocalEnumVariantId, LocalFieldId, Macro2Id, Macro2Loc, MacroRulesId, MacroRulesLoc,\n+    ProcMacroId, ProcMacroLoc, StaticId, StaticLoc, StructId, StructLoc, TraitAliasId,\n+    TraitAliasLoc, TraitId, TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc, VariantId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n@@ -61,12 +61,14 @@ pub trait InternDatabase: SourceDatabase {\n     fn intern_proc_macro(&self, loc: ProcMacroLoc) -> ProcMacroId;\n     #[salsa::interned]\n     fn intern_macro_rules(&self, loc: MacroRulesLoc) -> MacroRulesId;\n+    #[salsa::interned]\n+    fn intern_anonymous_const(&self, id: (DefWithBodyId, ExprId)) -> AnonymousConstId;\n }\n \n #[salsa::query_group(DefDatabaseStorage)]\n pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDatabase> {\n     #[salsa::input]\n-    fn enable_proc_attr_macros(&self) -> bool;\n+    fn expand_proc_attr_macros(&self) -> bool;\n \n     #[salsa::invoke(ItemTree::file_item_tree_query)]\n     fn file_item_tree(&self, file_id: HirFileId) -> Arc<ItemTree>;\n@@ -94,7 +96,9 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n     /// The `block_def_map` for block 0 would return `None`, while `block_def_map` of block 1 would\n     /// return a `DefMap` containing `inner`.\n     #[salsa::invoke(DefMap::block_def_map_query)]\n-    fn block_def_map(&self, block: BlockId) -> Option<Arc<DefMap>>;\n+    fn block_def_map(&self, block: BlockId) -> Arc<DefMap>;\n+\n+    // region:data\n \n     #[salsa::invoke(StructData::struct_data_query)]\n     fn struct_data(&self, id: StructId) -> Arc<StructData>;\n@@ -151,6 +155,8 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n     #[salsa::invoke(ProcMacroData::proc_macro_data_query)]\n     fn proc_macro_data(&self, makro: ProcMacroId) -> Arc<ProcMacroData>;\n \n+    // endregion:data\n+\n     #[salsa::invoke(Body::body_with_source_map_query)]\n     fn body_with_source_map(&self, def: DefWithBodyId) -> (Arc<Body>, Arc<BodySourceMap>);\n \n@@ -163,6 +169,8 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n     #[salsa::invoke(GenericParams::generic_params_query)]\n     fn generic_params(&self, def: GenericDefId) -> Interned<GenericParams>;\n \n+    // region:attrs\n+\n     #[salsa::invoke(Attrs::variants_attrs_query)]\n     fn variants_attrs(&self, def: EnumId) -> Arc<ArenaMap<LocalEnumVariantId, Attrs>>;\n \n@@ -182,17 +190,22 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n     ) -> Arc<ArenaMap<LocalFieldId, Either<AstPtr<ast::TupleField>, AstPtr<ast::RecordField>>>>;\n \n     #[salsa::invoke(AttrsWithOwner::attrs_query)]\n-    fn attrs(&self, def: AttrDefId) -> AttrsWithOwner;\n+    fn attrs(&self, def: AttrDefId) -> Attrs;\n \n-    #[salsa::invoke(LangItems::crate_lang_items_query)]\n-    fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n+    #[salsa::transparent]\n+    #[salsa::invoke(AttrsWithOwner::attrs_with_owner)]\n+    fn attrs_with_owner(&self, def: AttrDefId) -> AttrsWithOwner;\n+\n+    // endregion:attrs\n \n     #[salsa::invoke(LangItems::lang_item_query)]\n     fn lang_item(&self, start_crate: CrateId, item: LangItem) -> Option<LangItemTarget>;\n \n     #[salsa::invoke(ImportMap::import_map_query)]\n     fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;\n \n+    // region:visibilities\n+\n     #[salsa::invoke(visibility::field_visibilities_query)]\n     fn field_visibilities(&self, var: VariantId) -> Arc<ArenaMap<LocalFieldId, Visibility>>;\n \n@@ -203,9 +216,17 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n     #[salsa::invoke(visibility::const_visibility_query)]\n     fn const_visibility(&self, def: ConstId) -> Visibility;\n \n+    // endregion:visibilities\n+\n+    #[salsa::invoke(LangItems::crate_lang_items_query)]\n+    fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n+\n     #[salsa::transparent]\n     fn crate_limits(&self, crate_id: CrateId) -> CrateLimits;\n \n+    #[salsa::transparent]\n+    fn recursion_limit(&self, crate_id: CrateId) -> u32;\n+\n     fn crate_supports_no_std(&self, crate_id: CrateId) -> bool;\n }\n \n@@ -228,6 +249,10 @@ fn crate_limits(db: &dyn DefDatabase, crate_id: CrateId) -> CrateLimits {\n     }\n }\n \n+fn recursion_limit(db: &dyn DefDatabase, crate_id: CrateId) -> u32 {\n+    db.crate_limits(crate_id).recursion_limit\n+}\n+\n fn crate_supports_no_std(db: &dyn DefDatabase, crate_id: CrateId) -> bool {\n     let file = db.crate_graph()[crate_id].root_file_id;\n     let item_tree = db.file_item_tree(file.into());"}, {"sha": "63138aa6ad78fa179e6df61f79aa935995553be2", "filename": "src/tools/rust-analyzer/crates/hir-def/src/dyn_map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdyn_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdyn_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdyn_map.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -21,6 +21,8 @@\n //!\n //! This is a work of fiction. Any similarities to Kotlin's `BindingContext` are\n //! a coincidence.\n+pub mod keys;\n+\n use std::{\n     hash::Hash,\n     marker::PhantomData,"}, {"sha": "f30be6b64e3ded45ee26afb15fd74eb12d1811b8", "filename": "src/tools/rust-analyzer/crates/hir-def/src/dyn_map/keys.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdyn_map%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdyn_map%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdyn_map%2Fkeys.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "previous_filename": "src/tools/rust-analyzer/crates/hir-def/src/keys.rs"}, {"sha": "34ed1e72f2001cd1c51afca4c864cbc3283779bf", "filename": "src/tools/rust-analyzer/crates/hir-def/src/expander.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpander.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -0,0 +1,211 @@\n+//! Macro expansion utilities.\n+\n+use base_db::CrateId;\n+use cfg::CfgOptions;\n+use drop_bomb::DropBomb;\n+use hir_expand::{\n+    attrs::RawAttrs, hygiene::Hygiene, mod_path::ModPath, ExpandError, ExpandResult, HirFileId,\n+    InFile, MacroCallId, UnresolvedMacro,\n+};\n+use limit::Limit;\n+use syntax::{ast, Parse, SyntaxNode};\n+\n+use crate::{\n+    attr::Attrs, db::DefDatabase, lower::LowerCtx, macro_id_to_def_id, path::Path, AsMacroCall,\n+    MacroId, ModuleId,\n+};\n+\n+/// A subset of Expander that only deals with cfg attributes. We only need it to\n+/// avoid cyclic queries in crate def map during enum processing.\n+#[derive(Debug)]\n+pub(crate) struct CfgExpander {\n+    cfg_options: CfgOptions,\n+    hygiene: Hygiene,\n+    krate: CrateId,\n+}\n+\n+#[derive(Debug)]\n+pub struct Expander {\n+    cfg_expander: CfgExpander,\n+    pub(crate) current_file_id: HirFileId,\n+    pub(crate) module: ModuleId,\n+    /// `recursion_depth == usize::MAX` indicates that the recursion limit has been reached.\n+    recursion_depth: u32,\n+    recursion_limit: Limit,\n+}\n+\n+impl CfgExpander {\n+    pub(crate) fn new(\n+        db: &dyn DefDatabase,\n+        current_file_id: HirFileId,\n+        krate: CrateId,\n+    ) -> CfgExpander {\n+        let hygiene = Hygiene::new(db.upcast(), current_file_id);\n+        let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n+        CfgExpander { cfg_options, hygiene, krate }\n+    }\n+\n+    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n+        Attrs::filter(db, self.krate, RawAttrs::new(db.upcast(), owner, &self.hygiene))\n+    }\n+\n+    pub(crate) fn is_cfg_enabled(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> bool {\n+        let attrs = self.parse_attrs(db, owner);\n+        attrs.is_cfg_enabled(&self.cfg_options)\n+    }\n+\n+    pub(crate) fn hygiene(&self) -> &Hygiene {\n+        &self.hygiene\n+    }\n+}\n+\n+impl Expander {\n+    pub fn new(db: &dyn DefDatabase, current_file_id: HirFileId, module: ModuleId) -> Expander {\n+        let cfg_expander = CfgExpander::new(db, current_file_id, module.krate);\n+        let recursion_limit = db.recursion_limit(module.krate);\n+        #[cfg(not(test))]\n+        let recursion_limit = Limit::new(recursion_limit as usize);\n+        // Without this, `body::tests::your_stack_belongs_to_me` stack-overflows in debug\n+        #[cfg(test)]\n+        let recursion_limit = Limit::new(std::cmp::min(32, recursion_limit as usize));\n+        Expander { cfg_expander, current_file_id, module, recursion_depth: 0, recursion_limit }\n+    }\n+\n+    pub fn enter_expand<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        macro_call: ast::MacroCall,\n+        resolver: impl Fn(ModPath) -> Option<MacroId>,\n+    ) -> Result<ExpandResult<Option<(Mark, Parse<T>)>>, UnresolvedMacro> {\n+        // FIXME: within_limit should support this, instead of us having to extract the error\n+        let mut unresolved_macro_err = None;\n+\n+        let result = self.within_limit(db, |this| {\n+            let macro_call = InFile::new(this.current_file_id, &macro_call);\n+            match macro_call.as_call_id_with_errors(db.upcast(), this.module.krate(), |path| {\n+                resolver(path).map(|it| macro_id_to_def_id(db, it))\n+            }) {\n+                Ok(call_id) => call_id,\n+                Err(resolve_err) => {\n+                    unresolved_macro_err = Some(resolve_err);\n+                    ExpandResult { value: None, err: None }\n+                }\n+            }\n+        });\n+\n+        if let Some(err) = unresolved_macro_err {\n+            Err(err)\n+        } else {\n+            Ok(result)\n+        }\n+    }\n+\n+    pub fn enter_expand_id<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        call_id: MacroCallId,\n+    ) -> ExpandResult<Option<(Mark, Parse<T>)>> {\n+        self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))\n+    }\n+\n+    fn enter_expand_inner(\n+        db: &dyn DefDatabase,\n+        call_id: MacroCallId,\n+        error: Option<ExpandError>,\n+    ) -> ExpandResult<Option<InFile<Parse<SyntaxNode>>>> {\n+        let file_id = call_id.as_file();\n+        let ExpandResult { value, err } = db.parse_or_expand_with_err(file_id);\n+\n+        ExpandResult { value: Some(InFile::new(file_id, value)), err: error.or(err) }\n+    }\n+\n+    pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n+        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n+        self.current_file_id = mark.file_id;\n+        if self.recursion_depth == u32::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. Reset the\n+            // depth only when we get out of the tree.\n+            if !self.current_file_id.is_macro() {\n+                self.recursion_depth = 0;\n+            }\n+        } else {\n+            self.recursion_depth -= 1;\n+        }\n+        mark.bomb.defuse();\n+    }\n+\n+    pub fn ctx<'a>(&self, db: &'a dyn DefDatabase) -> LowerCtx<'a> {\n+        LowerCtx::new(db, &self.cfg_expander.hygiene, self.current_file_id)\n+    }\n+\n+    pub(crate) fn to_source<T>(&self, value: T) -> InFile<T> {\n+        InFile { file_id: self.current_file_id, value }\n+    }\n+\n+    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n+        self.cfg_expander.parse_attrs(db, owner)\n+    }\n+\n+    pub(crate) fn cfg_options(&self) -> &CfgOptions {\n+        &self.cfg_expander.cfg_options\n+    }\n+\n+    pub fn current_file_id(&self) -> HirFileId {\n+        self.current_file_id\n+    }\n+\n+    pub(crate) fn parse_path(&mut self, db: &dyn DefDatabase, path: ast::Path) -> Option<Path> {\n+        let ctx = LowerCtx::with_hygiene(db, &self.cfg_expander.hygiene);\n+        Path::from_src(path, &ctx)\n+    }\n+\n+    fn within_limit<F, T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        op: F,\n+    ) -> ExpandResult<Option<(Mark, Parse<T>)>>\n+    where\n+        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,\n+    {\n+        if self.recursion_depth == u32::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. We should\n+            // stop expanding other macro calls in this tree, or else this may result in\n+            // exponential number of macro expansions, leading to a hang.\n+            //\n+            // The overflow error should have been reported when it occurred (see the next branch),\n+            // so don't return overflow error here to avoid diagnostics duplication.\n+            cov_mark::hit!(overflow_but_not_me);\n+            return ExpandResult::only_err(ExpandError::RecursionOverflowPoisoned);\n+        } else if self.recursion_limit.check(self.recursion_depth as usize + 1).is_err() {\n+            self.recursion_depth = u32::MAX;\n+            cov_mark::hit!(your_stack_belongs_to_me);\n+            return ExpandResult::only_err(ExpandError::Other(\n+                \"reached recursion limit during macro expansion\".into(),\n+            ));\n+        }\n+\n+        let ExpandResult { value, err } = op(self);\n+        let Some(call_id) = value else {\n+            return ExpandResult { value: None, err };\n+        };\n+\n+        Self::enter_expand_inner(db, call_id, err).map(|value| {\n+            value.and_then(|InFile { file_id, value }| {\n+                let parse = value.cast::<T>()?;\n+\n+                self.recursion_depth += 1;\n+                self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n+                let old_file_id = std::mem::replace(&mut self.current_file_id, file_id);\n+                let mark =\n+                    Mark { file_id: old_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n+                Some((mark, parse))\n+            })\n+        })\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Mark {\n+    file_id: HirFileId,\n+    bomb: DropBomb,\n+}"}, {"sha": "e8cc2eab4617ef5ac1d7d10c54abc27c62d8cf79", "filename": "src/tools/rust-analyzer/crates/hir-def/src/find_path.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -42,7 +42,7 @@ const MAX_PATH_LEN: usize = 15;\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum PrefixKind {\n     /// Causes paths to always start with either `self`, `super`, `crate` or a crate-name.\n-    /// This is the same as plain, just that paths will start with `self` iprepended f the path\n+    /// This is the same as plain, just that paths will start with `self` prepended if the path\n     /// starts with an identifier that is not a crate.\n     BySelf,\n     /// Causes paths to ignore imports in the local module.\n@@ -81,7 +81,7 @@ fn find_path_inner(\n     }\n \n     let def_map = from.def_map(db);\n-    let crate_root = def_map.crate_root(db);\n+    let crate_root = def_map.crate_root();\n     // - if the item is a module, jump straight to module search\n     if let ItemInNs::Types(ModuleDefId::ModuleId(module_id)) = item {\n         let mut visited_modules = FxHashSet::default();\n@@ -183,7 +183,7 @@ fn find_path_for_module(\n \n     // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n     let root_def_map = crate_root.def_map(db);\n-    for (name, &def_id) in root_def_map.extern_prelude() {\n+    for (name, def_id) in root_def_map.extern_prelude() {\n         if module_id == def_id {\n             let name = scope_name.unwrap_or_else(|| name.clone());\n \n@@ -454,7 +454,7 @@ fn find_local_import_locations(\n         worklist.push(ancestor);\n     }\n \n-    let def_map = def_map.crate_root(db).def_map(db);\n+    let def_map = def_map.crate_root().def_map(db);\n \n     let mut seen: FxHashSet<_> = FxHashSet::default();\n \n@@ -543,6 +543,7 @@ mod tests {\n                 module.local_id,\n                 &mod_path,\n                 crate::item_scope::BuiltinShadowMode::Module,\n+                None,\n             )\n             .0\n             .take_types()"}, {"sha": "f19c3f028f42f7c41fe7f412cf23c894bfaa418a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/generics.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -12,16 +12,17 @@ use hir_expand::{\n use intern::Interned;\n use la_arena::{Arena, ArenaMap, Idx};\n use once_cell::unsync::Lazy;\n-use std::ops::DerefMut;\n use stdx::impl_from;\n use syntax::ast::{self, HasGenericParams, HasName, HasTypeBounds};\n+use triomphe::Arc;\n \n use crate::{\n-    body::{Expander, LowerCtx},\n     child_by_source::ChildBySource,\n     db::DefDatabase,\n-    dyn_map::DynMap,\n-    keys,\n+    dyn_map::{keys, DynMap},\n+    expander::Expander,\n+    lower::LowerCtx,\n+    nameres::{DefMap, MacroSubNs},\n     src::{HasChildSource, HasSource},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n     AdtId, ConstParamId, GenericDefId, HasModule, LifetimeParamId, LocalLifetimeParamId,\n@@ -153,7 +154,6 @@ impl GenericParams {\n         def: GenericDefId,\n     ) -> Interned<GenericParams> {\n         let _p = profile::span(\"generic_params_query\");\n-\n         macro_rules! id_to_generics {\n             ($id:ident) => {{\n                 let id = $id.lookup(db).id;\n@@ -176,8 +176,10 @@ impl GenericParams {\n \n                 // Don't create an `Expander` nor call `loc.source(db)` if not needed since this\n                 // causes a reparse after the `ItemTree` has been created.\n-                let mut expander = Lazy::new(|| Expander::new(db, loc.source(db).file_id, module));\n-                for (_, param) in &func_data.params {\n+                let mut expander = Lazy::new(|| {\n+                    (module.def_map(db), Expander::new(db, loc.source(db).file_id, module))\n+                });\n+                for param in &func_data.params {\n                     generic_params.fill_implicit_impl_trait_args(db, &mut expander, param);\n                 }\n \n@@ -329,7 +331,7 @@ impl GenericParams {\n     pub(crate) fn fill_implicit_impl_trait_args(\n         &mut self,\n         db: &dyn DefDatabase,\n-        expander: &mut impl DerefMut<Target = Expander>,\n+        exp: &mut Lazy<(Arc<DefMap>, Expander), impl FnOnce() -> (Arc<DefMap>, Expander)>,\n         type_ref: &TypeRef,\n     ) {\n         type_ref.walk(&mut |type_ref| {\n@@ -349,14 +351,28 @@ impl GenericParams {\n             }\n             if let TypeRef::Macro(mc) = type_ref {\n                 let macro_call = mc.to_node(db.upcast());\n-                match expander.enter_expand::<ast::Type>(db, macro_call) {\n-                    Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n-                        let ctx = LowerCtx::new(db, expander.current_file_id());\n-                        let type_ref = TypeRef::from_ast(&ctx, expanded);\n-                        self.fill_implicit_impl_trait_args(db, expander, &type_ref);\n-                        expander.exit(db, mark);\n-                    }\n-                    _ => {}\n+                let (def_map, expander) = &mut **exp;\n+\n+                let module = expander.module.local_id;\n+                let resolver = |path| {\n+                    def_map\n+                        .resolve_path(\n+                            db,\n+                            module,\n+                            &path,\n+                            crate::item_scope::BuiltinShadowMode::Other,\n+                            Some(MacroSubNs::Bang),\n+                        )\n+                        .0\n+                        .take_macros()\n+                };\n+                if let Ok(ExpandResult { value: Some((mark, expanded)), .. }) =\n+                    expander.enter_expand(db, macro_call, resolver)\n+                {\n+                    let ctx = expander.ctx(db);\n+                    let type_ref = TypeRef::from_ast(&ctx, expanded.tree());\n+                    self.fill_implicit_impl_trait_args(db, &mut *exp, &type_ref);\n+                    exp.1.exit(db, mark);\n                 }\n             }\n         });"}, {"sha": "4ad8a7aa8eb12a0c52f78adcf934c486bae1a532", "filename": "src/tools/rust-analyzer/crates/hir-def/src/hir.rs", "status": "renamed", "additions": 112, "deletions": 36, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fhir.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -12,26 +12,29 @@\n //!\n //! See also a neighboring `body` module.\n \n+pub mod type_ref;\n+\n use std::fmt;\n \n use hir_expand::name::Name;\n use intern::Interned;\n use la_arena::{Idx, RawIdx};\n use smallvec::SmallVec;\n+use syntax::ast;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n-    BlockId,\n+    AnonymousConstId, BlockId,\n };\n \n pub use syntax::ast::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp};\n \n-pub type ExprId = Idx<Expr>;\n-\n pub type BindingId = Idx<Binding>;\n \n+pub type ExprId = Idx<Expr>;\n+\n /// FIXME: this is a hacky function which should be removed\n pub(crate) fn dummy_expr_id() -> ExprId {\n     ExprId::from_raw(RawIdx::from(u32::MAX))\n@@ -82,6 +85,7 @@ impl fmt::Display for FloatTypeWrapper {\n pub enum Literal {\n     String(Box<str>),\n     ByteString(Box<[u8]>),\n+    CString(Box<str>),\n     Char(char),\n     Bool(bool),\n     Int(i128, Option<BuiltinInt>),\n@@ -92,6 +96,66 @@ pub enum Literal {\n     Float(FloatTypeWrapper, Option<BuiltinFloat>),\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+/// Used in range patterns.\n+pub enum LiteralOrConst {\n+    Literal(Literal),\n+    Const(Path),\n+}\n+\n+impl Literal {\n+    pub fn negate(self) -> Option<Self> {\n+        if let Literal::Int(i, k) = self {\n+            Some(Literal::Int(-i, k))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl From<ast::LiteralKind> for Literal {\n+    fn from(ast_lit_kind: ast::LiteralKind) -> Self {\n+        use ast::LiteralKind;\n+        match ast_lit_kind {\n+            // FIXME: these should have actual values filled in, but unsure on perf impact\n+            LiteralKind::IntNumber(lit) => {\n+                if let builtin @ Some(_) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n+                    Literal::Float(\n+                        FloatTypeWrapper::new(lit.float_value().unwrap_or(Default::default())),\n+                        builtin,\n+                    )\n+                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinUint::from_suffix) {\n+                    Literal::Uint(lit.value().unwrap_or(0), builtin)\n+                } else {\n+                    let builtin = lit.suffix().and_then(BuiltinInt::from_suffix);\n+                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n+                }\n+            }\n+            LiteralKind::FloatNumber(lit) => {\n+                let ty = lit.suffix().and_then(BuiltinFloat::from_suffix);\n+                Literal::Float(FloatTypeWrapper::new(lit.value().unwrap_or(Default::default())), ty)\n+            }\n+            LiteralKind::ByteString(bs) => {\n+                let text = bs.value().map(Box::from).unwrap_or_else(Default::default);\n+                Literal::ByteString(text)\n+            }\n+            LiteralKind::String(s) => {\n+                let text = s.value().map(Box::from).unwrap_or_else(Default::default);\n+                Literal::String(text)\n+            }\n+            LiteralKind::CString(s) => {\n+                let text = s.value().map(Box::from).unwrap_or_else(Default::default);\n+                Literal::CString(text)\n+            }\n+            LiteralKind::Byte(b) => {\n+                Literal::Uint(b.value().unwrap_or_default() as u128, Some(BuiltinUint::U8))\n+            }\n+            LiteralKind::Char(c) => Literal::Char(c.value().unwrap_or_default()),\n+            LiteralKind::Bool(val) => Literal::Bool(val),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Expr {\n     /// This is produced if the syntax tree does not have a required expression piece.\n@@ -107,28 +171,19 @@ pub enum Expr {\n         expr: ExprId,\n     },\n     Block {\n-        id: BlockId,\n+        id: Option<BlockId>,\n         statements: Box<[Statement]>,\n         tail: Option<ExprId>,\n         label: Option<LabelId>,\n     },\n-    TryBlock {\n-        id: BlockId,\n-        statements: Box<[Statement]>,\n-        tail: Option<ExprId>,\n-    },\n     Async {\n-        id: BlockId,\n-        statements: Box<[Statement]>,\n-        tail: Option<ExprId>,\n-    },\n-    Const {\n-        id: BlockId,\n+        id: Option<BlockId>,\n         statements: Box<[Statement]>,\n         tail: Option<ExprId>,\n     },\n+    Const(AnonymousConstId),\n     Unsafe {\n-        id: BlockId,\n+        id: Option<BlockId>,\n         statements: Box<[Statement]>,\n         tail: Option<ExprId>,\n     },\n@@ -141,12 +196,6 @@ pub enum Expr {\n         body: ExprId,\n         label: Option<LabelId>,\n     },\n-    For {\n-        iterable: ExprId,\n-        pat: PatId,\n-        body: ExprId,\n-        label: Option<LabelId>,\n-    },\n     Call {\n         callee: ExprId,\n         args: Box<[ExprId]>,\n@@ -163,11 +212,11 @@ pub enum Expr {\n         arms: Box<[MatchArm]>,\n     },\n     Continue {\n-        label: Option<Name>,\n+        label: Option<LabelId>,\n     },\n     Break {\n         expr: Option<ExprId>,\n-        label: Option<Name>,\n+        label: Option<LabelId>,\n     },\n     Return {\n         expr: Option<ExprId>,\n@@ -192,9 +241,6 @@ pub enum Expr {\n     Await {\n         expr: ExprId,\n     },\n-    Try {\n-        expr: ExprId,\n-    },\n     Cast {\n         expr: ExprId,\n         type_ref: Interned<TypeRef>,\n@@ -231,6 +277,7 @@ pub enum Expr {\n         ret_type: Option<Interned<TypeRef>>,\n         body: ExprId,\n         closure_kind: ClosureKind,\n+        capture_by: CaptureBy,\n     },\n     Tuple {\n         exprs: Box<[ExprId]>,\n@@ -248,6 +295,14 @@ pub enum ClosureKind {\n     Async,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum CaptureBy {\n+    /// `move |x| y + x`.\n+    Value,\n+    /// `move` keyword was not specified.\n+    Ref,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Movability {\n     Static,\n@@ -302,11 +357,10 @@ impl Expr {\n             Expr::Let { expr, .. } => {\n                 f(*expr);\n             }\n+            Expr::Const(_) => (),\n             Expr::Block { statements, tail, .. }\n-            | Expr::TryBlock { statements, tail, .. }\n             | Expr::Unsafe { statements, tail, .. }\n-            | Expr::Async { statements, tail, .. }\n-            | Expr::Const { statements, tail, .. } => {\n+            | Expr::Async { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n                         Statement::Let { initializer, else_branch, .. } => {\n@@ -329,10 +383,6 @@ impl Expr {\n                 f(*condition);\n                 f(*body);\n             }\n-            Expr::For { iterable, body, .. } => {\n-                f(*iterable);\n-                f(*body);\n-            }\n             Expr::Call { callee, args, .. } => {\n                 f(*callee);\n                 args.iter().copied().for_each(f);\n@@ -383,7 +433,6 @@ impl Expr {\n             }\n             Expr::Field { expr, .. }\n             | Expr::Await { expr }\n-            | Expr::Try { expr }\n             | Expr::Cast { expr, .. }\n             | Expr::Ref { expr, .. }\n             | Expr::UnaryOp { expr, .. }\n@@ -437,11 +486,38 @@ impl BindingAnnotation {\n     }\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum BindingProblems {\n+    /// https://doc.rust-lang.org/stable/error_codes/E0416.html\n+    BoundMoreThanOnce,\n+    /// https://doc.rust-lang.org/stable/error_codes/E0409.html\n+    BoundInconsistently,\n+    /// https://doc.rust-lang.org/stable/error_codes/E0408.html\n+    NotBoundAcrossAll,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Binding {\n     pub name: Name,\n     pub mode: BindingAnnotation,\n     pub definitions: SmallVec<[PatId; 1]>,\n+    /// Id of the closure/generator that owns this binding. If it is owned by the\n+    /// top level expression, this field would be `None`.\n+    pub owner: Option<ExprId>,\n+    pub problems: Option<BindingProblems>,\n+}\n+\n+impl Binding {\n+    pub fn is_upvar(&self, relative_to: ExprId) -> bool {\n+        match self.owner {\n+            Some(x) => {\n+                // We assign expression ids in a way that outer closures will receive\n+                // a lower id\n+                x.into_raw() < relative_to.into_raw()\n+            }\n+            None => true,\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -458,7 +534,7 @@ pub enum Pat {\n     Tuple { args: Box<[PatId]>, ellipsis: Option<usize> },\n     Or(Box<[PatId]>),\n     Record { path: Option<Box<Path>>, args: Box<[RecordFieldPat]>, ellipsis: bool },\n-    Range { start: ExprId, end: ExprId },\n+    Range { start: Option<Box<LiteralOrConst>>, end: Option<Box<LiteralOrConst>> },\n     Slice { prefix: Box<[PatId]>, slice: Option<PatId>, suffix: Box<[PatId]> },\n     Path(Box<Path>),\n     Lit(ExprId),", "previous_filename": "src/tools/rust-analyzer/crates/hir-def/src/expr.rs"}, {"sha": "0573c9a6f8af411d64f5ae7dcf4ee874a0b890a4", "filename": "src/tools/rust-analyzer/crates/hir-def/src/hir/type_ref.rs", "status": "renamed", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,19 +1,21 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n \n+use core::fmt;\n use std::fmt::Write;\n \n use hir_expand::{\n+    db::ExpandDatabase,\n     name::{AsName, Name},\n     AstId,\n };\n use intern::Interned;\n use syntax::ast::{self, HasName};\n \n use crate::{\n-    body::LowerCtx,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n-    expr::Literal,\n+    hir::Literal,\n+    lower::LowerCtx,\n     path::Path,\n };\n \n@@ -383,15 +385,6 @@ pub enum ConstRefOrPath {\n     Path(Name),\n }\n \n-impl std::fmt::Display for ConstRefOrPath {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            ConstRefOrPath::Scalar(s) => s.fmt(f),\n-            ConstRefOrPath::Path(n) => n.fmt(f),\n-        }\n-    }\n-}\n-\n impl ConstRefOrPath {\n     pub(crate) fn from_expr_opt(expr: Option<ast::Expr>) -> Self {\n         match expr {\n@@ -400,6 +393,19 @@ impl ConstRefOrPath {\n         }\n     }\n \n+    pub fn display<'a>(&'a self, db: &'a dyn ExpandDatabase) -> impl fmt::Display + 'a {\n+        struct Display<'a>(&'a dyn ExpandDatabase, &'a ConstRefOrPath);\n+        impl fmt::Display for Display<'_> {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                match self.1 {\n+                    ConstRefOrPath::Scalar(s) => s.fmt(f),\n+                    ConstRefOrPath::Path(n) => n.display(self.0).fmt(f),\n+                }\n+            }\n+        }\n+        Display(db, self)\n+    }\n+\n     // FIXME: as per the comments on `TypeRef::Array`, this evaluation should not happen at this\n     // parse stage.\n     fn from_expr(expr: ast::Expr) -> Self {", "previous_filename": "src/tools/rust-analyzer/crates/hir-def/src/type_ref.rs"}, {"sha": "48532655e04b1ff76aed4337f13856773d656133", "filename": "src/tools/rust-analyzer/crates/hir-def/src/import_map.rs", "status": "modified", "additions": 68, "deletions": 30, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fimport_map.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,17 +1,18 @@\n //! A map of all publicly exported items in a crate.\n \n-use std::{fmt, hash::BuildHasherDefault, sync::Arc};\n+use std::{fmt, hash::BuildHasherDefault};\n \n use base_db::CrateId;\n use fst::{self, Streamer};\n use hir_expand::name::Name;\n use indexmap::{map::Entry, IndexMap};\n use itertools::Itertools;\n use rustc_hash::{FxHashSet, FxHasher};\n+use triomphe::Arc;\n \n use crate::{\n-    db::DefDatabase, item_scope::ItemInNs, visibility::Visibility, AssocItemId, ModuleDefId,\n-    ModuleId, TraitId,\n+    db::DefDatabase, item_scope::ItemInNs, nameres::DefMap, visibility::Visibility, AssocItemId,\n+    ModuleDefId, ModuleId, TraitId,\n };\n \n type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n@@ -32,13 +33,23 @@ pub struct ImportPath {\n     pub segments: Vec<Name>,\n }\n \n-impl fmt::Display for ImportPath {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(&self.segments.iter().format(\"::\"), f)\n+impl ImportPath {\n+    pub fn display<'a>(&'a self, db: &'a dyn DefDatabase) -> impl fmt::Display + 'a {\n+        struct Display<'a> {\n+            db: &'a dyn DefDatabase,\n+            path: &'a ImportPath,\n+        }\n+        impl fmt::Display for Display<'_> {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt::Display::fmt(\n+                    &self.path.segments.iter().map(|it| it.display(self.db.upcast())).format(\"::\"),\n+                    f,\n+                )\n+            }\n+        }\n+        Display { db, path: self }\n     }\n-}\n \n-impl ImportPath {\n     fn len(&self) -> usize {\n         self.segments.len()\n     }\n@@ -75,7 +86,7 @@ impl ImportMap {\n         let mut importables = import_map\n             .map\n             .iter()\n-            .map(|(item, info)| (item, fst_path(&info.path)))\n+            .map(|(item, info)| (item, fst_path(db, &info.path)))\n             .collect::<Vec<_>>();\n         importables.sort_by(|(_, fst_path), (_, fst_path2)| fst_path.cmp(fst_path2));\n \n@@ -112,6 +123,25 @@ impl ImportMap {\n         self.map.get(&item)\n     }\n \n+    #[cfg(test)]\n+    fn fmt_for_test(&self, db: &dyn DefDatabase) -> String {\n+        let mut importable_paths: Vec<_> = self\n+            .map\n+            .iter()\n+            .map(|(item, info)| {\n+                let ns = match item {\n+                    ItemInNs::Types(_) => \"t\",\n+                    ItemInNs::Values(_) => \"v\",\n+                    ItemInNs::Macros(_) => \"m\",\n+                };\n+                format!(\"- {} ({ns})\", info.path.display(db))\n+            })\n+            .collect();\n+\n+        importable_paths.sort();\n+        importable_paths.join(\"\\n\")\n+    }\n+\n     fn collect_trait_assoc_items(\n         &mut self,\n         db: &dyn DefDatabase,\n@@ -153,7 +183,7 @@ fn collect_import_map(db: &dyn DefDatabase, krate: CrateId) -> ImportMap {\n \n     // We look only into modules that are public(ly reexported), starting with the crate root.\n     let empty = ImportPath { segments: vec![] };\n-    let root = def_map.module_id(def_map.root());\n+    let root = def_map.module_id(DefMap::ROOT);\n     let mut worklist = vec![(root, empty)];\n     while let Some((module, mod_path)) = worklist.pop() {\n         let ext_def_map;\n@@ -233,13 +263,10 @@ impl fmt::Debug for ImportMap {\n         let mut importable_paths: Vec<_> = self\n             .map\n             .iter()\n-            .map(|(item, info)| {\n-                let ns = match item {\n-                    ItemInNs::Types(_) => \"t\",\n-                    ItemInNs::Values(_) => \"v\",\n-                    ItemInNs::Macros(_) => \"m\",\n-                };\n-                format!(\"- {} ({ns})\", info.path)\n+            .map(|(item, _)| match item {\n+                ItemInNs::Types(it) => format!(\"- {it:?} (t)\",),\n+                ItemInNs::Values(it) => format!(\"- {it:?} (v)\",),\n+                ItemInNs::Macros(it) => format!(\"- {it:?} (m)\",),\n             })\n             .collect();\n \n@@ -248,9 +275,9 @@ impl fmt::Debug for ImportMap {\n     }\n }\n \n-fn fst_path(path: &ImportPath) -> String {\n+fn fst_path(db: &dyn DefDatabase, path: &ImportPath) -> String {\n     let _p = profile::span(\"fst_path\");\n-    let mut s = path.to_string();\n+    let mut s = path.display(db).to_string();\n     s.make_ascii_lowercase();\n     s\n }\n@@ -343,7 +370,12 @@ impl Query {\n         self\n     }\n \n-    fn import_matches(&self, import: &ImportInfo, enforce_lowercase: bool) -> bool {\n+    fn import_matches(\n+        &self,\n+        db: &dyn DefDatabase,\n+        import: &ImportInfo,\n+        enforce_lowercase: bool,\n+    ) -> bool {\n         let _p = profile::span(\"import_map::Query::import_matches\");\n         if import.is_trait_assoc_item {\n             if self.exclude_import_kinds.contains(&ImportKind::AssociatedItem) {\n@@ -354,9 +386,9 @@ impl Query {\n         }\n \n         let mut input = if import.is_trait_assoc_item || self.name_only {\n-            import.path.segments.last().unwrap().to_string()\n+            import.path.segments.last().unwrap().display(db.upcast()).to_string()\n         } else {\n-            import.path.to_string()\n+            import.path.display(db).to_string()\n         };\n         if enforce_lowercase || !self.case_sensitive {\n             input.make_ascii_lowercase();\n@@ -421,25 +453,27 @@ pub fn search_dependencies(\n         let importables = &import_map.importables[indexed_value.value as usize..];\n \n         let common_importable_data = &import_map.map[&importables[0]];\n-        if !query.import_matches(common_importable_data, true) {\n+        if !query.import_matches(db, common_importable_data, true) {\n             continue;\n         }\n \n         // Path shared by the importable items in this group.\n-        let common_importables_path_fst = fst_path(&common_importable_data.path);\n+        let common_importables_path_fst = fst_path(db, &common_importable_data.path);\n         // Add the items from this `ModPath` group. Those are all subsequent items in\n         // `importables` whose paths match `path`.\n         let iter = importables\n             .iter()\n             .copied()\n-            .take_while(|item| common_importables_path_fst == fst_path(&import_map.map[item].path))\n+            .take_while(|item| {\n+                common_importables_path_fst == fst_path(db, &import_map.map[item].path)\n+            })\n             .filter(|&item| match item_import_kind(item) {\n                 Some(import_kind) => !query.exclude_import_kinds.contains(&import_kind),\n                 None => true,\n             })\n             .filter(|item| {\n                 !query.case_sensitive // we've already checked the common importables path case-insensitively\n-                        || query.import_matches(&import_map.map[item], false)\n+                        || query.import_matches(db, &import_map.map[item], false)\n             });\n         res.extend(iter);\n \n@@ -472,7 +506,7 @@ mod tests {\n     use base_db::{fixture::WithFixture, SourceDatabase, Upcast};\n     use expect_test::{expect, Expect};\n \n-    use crate::{test_db::TestDB, ItemContainerId, Lookup};\n+    use crate::{db::DefDatabase, test_db::TestDB, ItemContainerId, Lookup};\n \n     use super::*;\n \n@@ -496,7 +530,7 @@ mod tests {\n                 let (path, mark) = match assoc_item_path(&db, &dependency_imports, dependency) {\n                     Some(assoc_item_path) => (assoc_item_path, \"a\"),\n                     None => (\n-                        dependency_imports.path_of(dependency)?.to_string(),\n+                        dependency_imports.path_of(dependency)?.display(&db).to_string(),\n                         match dependency {\n                             ItemInNs::Types(ModuleDefId::FunctionId(_))\n                             | ItemInNs::Values(ModuleDefId::FunctionId(_)) => \"f\",\n@@ -547,7 +581,11 @@ mod tests {\n                         None\n                     }\n                 })?;\n-            return Some(format!(\"{}::{assoc_item_name}\", dependency_imports.path_of(trait_)?));\n+            return Some(format!(\n+                \"{}::{}\",\n+                dependency_imports.path_of(trait_)?.display(db),\n+                assoc_item_name.display(db.upcast())\n+            ));\n         }\n         None\n     }\n@@ -587,7 +625,7 @@ mod tests {\n \n                 let map = db.import_map(krate);\n \n-                Some(format!(\"{name}:\\n{map:?}\\n\"))\n+                Some(format!(\"{name}:\\n{}\\n\", map.fmt_for_test(db.upcast())))\n             })\n             .sorted()\n             .collect::<String>();"}, {"sha": "3ed321d189d3652a66c92a5a49620bb4e116dc9c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -4,7 +4,7 @@\n use std::collections::hash_map::Entry;\n \n use base_db::CrateId;\n-use hir_expand::{attrs::AttrId, name::Name, AstId, MacroCallId};\n+use hir_expand::{attrs::AttrId, db::ExpandDatabase, name::Name, AstId, MacroCallId};\n use itertools::Itertools;\n use once_cell::sync::Lazy;\n use profile::Count;\n@@ -358,12 +358,16 @@ impl ItemScope {\n         }\n     }\n \n-    pub(crate) fn dump(&self, buf: &mut String) {\n+    pub(crate) fn dump(&self, db: &dyn ExpandDatabase, buf: &mut String) {\n         let mut entries: Vec<_> = self.resolutions().collect();\n         entries.sort_by_key(|(name, _)| name.clone());\n \n         for (name, def) in entries {\n-            format_to!(buf, \"{}:\", name.map_or(\"_\".to_string(), |name| name.to_string()));\n+            format_to!(\n+                buf,\n+                \"{}:\",\n+                name.map_or(\"_\".to_string(), |name| name.display(db).to_string())\n+            );\n \n             if def.types.is_some() {\n                 buf.push_str(\" t\");"}, {"sha": "590ed64af5d802e95f67dc8221edbd4117d82449", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -40,7 +40,6 @@ use std::{\n     hash::{Hash, Hasher},\n     marker::PhantomData,\n     ops::Index,\n-    sync::Arc,\n };\n \n use ast::{AstNode, HasName, StructKind};\n@@ -60,6 +59,7 @@ use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use stdx::never;\n use syntax::{ast, match_ast, SyntaxKind};\n+use triomphe::Arc;\n \n use crate::{\n     attr::Attrs,\n@@ -101,16 +101,14 @@ pub struct ItemTree {\n     top_level: SmallVec<[ModItem; 1]>,\n     attrs: FxHashMap<AttrOwner, RawAttrs>,\n \n+    // FIXME: Remove this indirection, an item tree is almost always non-empty?\n     data: Option<Box<ItemTreeData>>,\n }\n \n impl ItemTree {\n     pub(crate) fn file_item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {\n         let _p = profile::span(\"file_item_tree_query\").detail(|| format!(\"{file_id:?}\"));\n-        let syntax = match db.parse_or_expand(file_id) {\n-            Some(node) => node,\n-            None => return Default::default(),\n-        };\n+        let syntax = db.parse_or_expand(file_id);\n         if never!(syntax.kind() == SyntaxKind::ERROR, \"{:?} from {:?} {}\", file_id, syntax, syntax)\n         {\n             // FIXME: not 100% sure why these crop up, but return an empty tree to avoid a panic\n@@ -169,8 +167,8 @@ impl ItemTree {\n         Attrs::filter(db, krate, self.raw_attrs(of).clone())\n     }\n \n-    pub fn pretty_print(&self) -> String {\n-        pretty::print_item_tree(self)\n+    pub fn pretty_print(&self, db: &dyn DefDatabase) -> String {\n+        pretty::print_item_tree(db.upcast(), self)\n     }\n \n     fn data(&self) -> &ItemTreeData {\n@@ -600,19 +598,18 @@ pub struct Function {\n     pub abi: Option<Interned<str>>,\n     pub params: IdxRange<Param>,\n     pub ret_type: Interned<TypeRef>,\n-    pub async_ret_type: Option<Interned<TypeRef>>,\n     pub ast_id: FileAstId<ast::Fn>,\n     pub(crate) flags: FnFlags,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Param {\n-    Normal(Option<Name>, Interned<TypeRef>),\n+    Normal(Interned<TypeRef>),\n     Varargs,\n }\n \n bitflags::bitflags! {\n-    #[derive(Default)]\n+    #[derive(Debug, Clone, Copy, Eq, PartialEq, Default)]\n     pub(crate) struct FnFlags: u8 {\n         const HAS_SELF_PARAM = 1 << 0;\n         const HAS_BODY = 1 << 1;"}, {"sha": "46633667ed3e2f9a720eb3f4c8dd7c0383c59ac6", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,6 +1,6 @@\n //! AST -> `ItemTree` lowering code.\n \n-use std::{collections::hash_map::Entry, sync::Arc};\n+use std::collections::hash_map::Entry;\n \n use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, HirFileId};\n use syntax::ast::{self, HasModuleItem, HasTypeBounds};\n@@ -20,7 +20,7 @@ pub(super) struct Ctx<'a> {\n     db: &'a dyn DefDatabase,\n     tree: ItemTree,\n     source_ast_id_map: Arc<AstIdMap>,\n-    body_ctx: crate::body::LowerCtx<'a>,\n+    body_ctx: crate::lower::LowerCtx<'a>,\n }\n \n impl<'a> Ctx<'a> {\n@@ -29,7 +29,7 @@ impl<'a> Ctx<'a> {\n             db,\n             tree: ItemTree::default(),\n             source_ast_id_map: db.ast_id_map(file),\n-            body_ctx: crate::body::LowerCtx::new(db, file),\n+            body_ctx: crate::lower::LowerCtx::with_file_id(db, file),\n         }\n     }\n \n@@ -293,7 +293,7 @@ impl<'a> Ctx<'a> {\n                     }\n                 };\n                 let ty = Interned::new(self_type);\n-                let idx = self.data().params.alloc(Param::Normal(None, ty));\n+                let idx = self.data().params.alloc(Param::Normal(ty));\n                 self.add_attrs(\n                     idx.into(),\n                     RawAttrs::new(self.db.upcast(), &self_param, self.hygiene()),\n@@ -306,19 +306,7 @@ impl<'a> Ctx<'a> {\n                     None => {\n                         let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ty());\n                         let ty = Interned::new(type_ref);\n-                        let mut pat = param.pat();\n-                        // FIXME: This really shouldn't be here, in fact FunctionData/ItemTree's function shouldn't know about\n-                        // pattern names at all\n-                        let name = 'name: loop {\n-                            match pat {\n-                                Some(ast::Pat::RefPat(ref_pat)) => pat = ref_pat.pat(),\n-                                Some(ast::Pat::IdentPat(ident)) => {\n-                                    break 'name ident.name().map(|it| it.as_name())\n-                                }\n-                                _ => break 'name None,\n-                            }\n-                        };\n-                        self.data().params.alloc(Param::Normal(name, ty))\n+                        self.data().params.alloc(Param::Normal(ty))\n                     }\n                 };\n                 self.add_attrs(idx.into(), RawAttrs::new(self.db.upcast(), &param, self.hygiene()));\n@@ -336,13 +324,12 @@ impl<'a> Ctx<'a> {\n             None => TypeRef::unit(),\n         };\n \n-        let (ret_type, async_ret_type) = if func.async_token().is_some() {\n-            let async_ret_type = ret_type.clone();\n+        let ret_type = if func.async_token().is_some() {\n             let future_impl = desugar_future_path(ret_type);\n             let ty_bound = Interned::new(TypeBound::Path(future_impl, TraitBoundModifier::None));\n-            (TypeRef::ImplTrait(vec![ty_bound]), Some(async_ret_type))\n+            TypeRef::ImplTrait(vec![ty_bound])\n         } else {\n-            (ret_type, None)\n+            ret_type\n         };\n \n         let abi = func.abi().map(lower_abi);\n@@ -376,7 +363,6 @@ impl<'a> Ctx<'a> {\n             abi,\n             params,\n             ret_type: Interned::new(ret_type),\n-            async_ret_type: async_ret_type.map(Interned::new),\n             ast_id,\n             flags,\n         };"}, {"sha": "e873316a578c074fd9dbe9006c538542a56d2368", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -2,6 +2,8 @@\n \n use std::fmt::{self, Write};\n \n+use hir_expand::db::ExpandDatabase;\n+\n use crate::{\n     generics::{TypeOrConstParamData, WherePredicate, WherePredicateTypeTarget},\n     pretty::{print_path, print_type_bounds, print_type_ref},\n@@ -10,8 +12,8 @@ use crate::{\n \n use super::*;\n \n-pub(super) fn print_item_tree(tree: &ItemTree) -> String {\n-    let mut p = Printer { tree, buf: String::new(), indent_level: 0, needs_indent: true };\n+pub(super) fn print_item_tree(db: &dyn ExpandDatabase, tree: &ItemTree) -> String {\n+    let mut p = Printer { db, tree, buf: String::new(), indent_level: 0, needs_indent: true };\n \n     if let Some(attrs) = tree.attrs.get(&AttrOwner::TopLevel) {\n         p.print_attrs(attrs, true);\n@@ -43,6 +45,7 @@ macro_rules! wln {\n }\n \n struct Printer<'a> {\n+    db: &'a dyn ExpandDatabase,\n     tree: &'a ItemTree,\n     buf: String,\n     indent_level: usize,\n@@ -88,7 +91,7 @@ impl<'a> Printer<'a> {\n                 self,\n                 \"#{}[{}{}]\",\n                 inner,\n-                attr.path,\n+                attr.path.display(self.db),\n                 attr.input.as_ref().map(|it| it.to_string()).unwrap_or_default(),\n             );\n         }\n@@ -102,7 +105,7 @@ impl<'a> Printer<'a> {\n \n     fn print_visibility(&mut self, vis: RawVisibilityId) {\n         match &self.tree[vis] {\n-            RawVisibility::Module(path) => w!(self, \"pub({}) \", path),\n+            RawVisibility::Module(path) => w!(self, \"pub({}) \", path.display(self.db)),\n             RawVisibility::Public => w!(self, \"pub \"),\n         };\n     }\n@@ -117,7 +120,7 @@ impl<'a> Printer<'a> {\n                         let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n-                        w!(this, \"{}: \", name);\n+                        w!(this, \"{}: \", name.display(self.db));\n                         this.print_type_ref(type_ref);\n                         wln!(this, \",\");\n                     }\n@@ -131,7 +134,7 @@ impl<'a> Printer<'a> {\n                         let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n-                        w!(this, \"{}: \", name);\n+                        w!(this, \"{}: \", name.display(self.db));\n                         this.print_type_ref(type_ref);\n                         wln!(this, \",\");\n                     }\n@@ -164,20 +167,20 @@ impl<'a> Printer<'a> {\n     fn print_use_tree(&mut self, use_tree: &UseTree) {\n         match &use_tree.kind {\n             UseTreeKind::Single { path, alias } => {\n-                w!(self, \"{}\", path);\n+                w!(self, \"{}\", path.display(self.db));\n                 if let Some(alias) = alias {\n                     w!(self, \" as {}\", alias);\n                 }\n             }\n             UseTreeKind::Glob { path } => {\n                 if let Some(path) = path {\n-                    w!(self, \"{}::\", path);\n+                    w!(self, \"{}::\", path.display(self.db));\n                 }\n                 w!(self, \"*\");\n             }\n             UseTreeKind::Prefixed { prefix, list } => {\n                 if let Some(prefix) = prefix {\n-                    w!(self, \"{}::\", prefix);\n+                    w!(self, \"{}::\", prefix.display(self.db));\n                 }\n                 w!(self, \"{{\");\n                 for (i, tree) in list.iter().enumerate() {\n@@ -205,7 +208,7 @@ impl<'a> Printer<'a> {\n             ModItem::ExternCrate(it) => {\n                 let ExternCrate { name, alias, visibility, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"extern crate {}\", name);\n+                w!(self, \"extern crate {}\", name.display(self.db));\n                 if let Some(alias) = alias {\n                     w!(self, \" as {}\", alias);\n                 }\n@@ -233,7 +236,6 @@ impl<'a> Printer<'a> {\n                     abi,\n                     params,\n                     ret_type,\n-                    async_ret_type: _,\n                     ast_id: _,\n                     flags,\n                 } = &self.tree[it];\n@@ -253,26 +255,20 @@ impl<'a> Printer<'a> {\n                 if let Some(abi) = abi {\n                     w!(self, \"extern \\\"{}\\\" \", abi);\n                 }\n-                w!(self, \"fn {}\", name);\n+                w!(self, \"fn {}\", name.display(self.db));\n                 self.print_generic_params(explicit_generic_params);\n                 w!(self, \"(\");\n                 if !params.is_empty() {\n                     self.indented(|this| {\n-                        for (i, param) in params.clone().enumerate() {\n+                        for param in params.clone() {\n                             this.print_attrs_of(param);\n                             match &this.tree[param] {\n-                                Param::Normal(name, ty) => {\n-                                    match name {\n-                                        Some(name) => w!(this, \"{}: \", name),\n-                                        None => w!(this, \"_: \"),\n+                                Param::Normal(ty) => {\n+                                    if flags.contains(FnFlags::HAS_SELF_PARAM) {\n+                                        w!(this, \"self: \");\n                                     }\n                                     this.print_type_ref(ty);\n-                                    w!(this, \",\");\n-                                    if flags.contains(FnFlags::HAS_SELF_PARAM) && i == 0 {\n-                                        wln!(this, \"  // self\");\n-                                    } else {\n-                                        wln!(this);\n-                                    }\n+                                    wln!(this, \",\");\n                                 }\n                                 Param::Varargs => {\n                                     wln!(this, \"...\");\n@@ -293,7 +289,7 @@ impl<'a> Printer<'a> {\n             ModItem::Struct(it) => {\n                 let Struct { visibility, name, fields, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"struct {}\", name);\n+                w!(self, \"struct {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 self.print_fields_and_where_clause(fields, generic_params);\n                 if matches!(fields, Fields::Record(_)) {\n@@ -305,7 +301,7 @@ impl<'a> Printer<'a> {\n             ModItem::Union(it) => {\n                 let Union { name, visibility, fields, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"union {}\", name);\n+                w!(self, \"union {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 self.print_fields_and_where_clause(fields, generic_params);\n                 if matches!(fields, Fields::Record(_)) {\n@@ -317,14 +313,14 @@ impl<'a> Printer<'a> {\n             ModItem::Enum(it) => {\n                 let Enum { name, visibility, variants, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"enum {}\", name);\n+                w!(self, \"enum {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for variant in variants.clone() {\n                         let Variant { name, fields, ast_id: _ } = &this.tree[variant];\n                         this.print_attrs_of(variant);\n-                        w!(this, \"{}\", name);\n+                        w!(this, \"{}\", name.display(self.db));\n                         this.print_fields(fields);\n                         wln!(this, \",\");\n                     }\n@@ -336,7 +332,7 @@ impl<'a> Printer<'a> {\n                 self.print_visibility(*visibility);\n                 w!(self, \"const \");\n                 match name {\n-                    Some(name) => w!(self, \"{}\", name),\n+                    Some(name) => w!(self, \"{}\", name.display(self.db)),\n                     None => w!(self, \"_\"),\n                 }\n                 w!(self, \": \");\n@@ -350,7 +346,7 @@ impl<'a> Printer<'a> {\n                 if *mutable {\n                     w!(self, \"mut \");\n                 }\n-                w!(self, \"{}: \", name);\n+                w!(self, \"{}: \", name.display(self.db));\n                 self.print_type_ref(type_ref);\n                 w!(self, \" = _;\");\n                 wln!(self);\n@@ -372,7 +368,7 @@ impl<'a> Printer<'a> {\n                 if *is_auto {\n                     w!(self, \"auto \");\n                 }\n-                w!(self, \"trait {}\", name);\n+                w!(self, \"trait {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n@@ -385,7 +381,7 @@ impl<'a> Printer<'a> {\n             ModItem::TraitAlias(it) => {\n                 let TraitAlias { name, visibility, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"trait {}\", name);\n+                w!(self, \"trait {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 w!(self, \" = \");\n                 self.print_where_clause(generic_params);\n@@ -418,7 +414,7 @@ impl<'a> Printer<'a> {\n                 let TypeAlias { name, visibility, bounds, type_ref, generic_params, ast_id: _ } =\n                     &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"type {}\", name);\n+                w!(self, \"type {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 if !bounds.is_empty() {\n                     w!(self, \": \");\n@@ -435,7 +431,7 @@ impl<'a> Printer<'a> {\n             ModItem::Mod(it) => {\n                 let Mod { name, visibility, kind, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"mod {}\", name);\n+                w!(self, \"mod {}\", name.display(self.db));\n                 match kind {\n                     ModKind::Inline { items } => {\n                         w!(self, \" {{\");\n@@ -453,32 +449,32 @@ impl<'a> Printer<'a> {\n             }\n             ModItem::MacroCall(it) => {\n                 let MacroCall { path, ast_id: _, expand_to: _ } = &self.tree[it];\n-                wln!(self, \"{}!(...);\", path);\n+                wln!(self, \"{}!(...);\", path.display(self.db));\n             }\n             ModItem::MacroRules(it) => {\n                 let MacroRules { name, ast_id: _ } = &self.tree[it];\n-                wln!(self, \"macro_rules! {} {{ ... }}\", name);\n+                wln!(self, \"macro_rules! {} {{ ... }}\", name.display(self.db));\n             }\n             ModItem::MacroDef(it) => {\n                 let MacroDef { name, visibility, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                wln!(self, \"macro {} {{ ... }}\", name);\n+                wln!(self, \"macro {} {{ ... }}\", name.display(self.db));\n             }\n         }\n \n         self.blank();\n     }\n \n     fn print_type_ref(&mut self, type_ref: &TypeRef) {\n-        print_type_ref(type_ref, self).unwrap();\n+        print_type_ref(self.db, type_ref, self).unwrap();\n     }\n \n     fn print_type_bounds(&mut self, bounds: &[Interned<TypeBound>]) {\n-        print_type_bounds(bounds, self).unwrap();\n+        print_type_bounds(self.db, bounds, self).unwrap();\n     }\n \n     fn print_path(&mut self, path: &Path) {\n-        print_path(path, self).unwrap();\n+        print_path(self.db, path, self).unwrap();\n     }\n \n     fn print_generic_params(&mut self, params: &GenericParams) {\n@@ -493,7 +489,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \", \");\n             }\n             first = false;\n-            w!(self, \"{}\", lt.name);\n+            w!(self, \"{}\", lt.name.display(self.db));\n         }\n         for (idx, x) in params.type_or_consts.iter() {\n             if !first {\n@@ -502,11 +498,11 @@ impl<'a> Printer<'a> {\n             first = false;\n             match x {\n                 TypeOrConstParamData::TypeParamData(ty) => match &ty.name {\n-                    Some(name) => w!(self, \"{}\", name),\n+                    Some(name) => w!(self, \"{}\", name.display(self.db)),\n                     None => w!(self, \"_anon_{}\", idx.into_raw()),\n                 },\n                 TypeOrConstParamData::ConstParamData(konst) => {\n-                    w!(self, \"const {}: \", konst.name);\n+                    w!(self, \"const {}: \", konst.name.display(self.db));\n                     self.print_type_ref(&konst.ty);\n                 }\n             }\n@@ -538,7 +534,12 @@ impl<'a> Printer<'a> {\n                 let (target, bound) = match pred {\n                     WherePredicate::TypeBound { target, bound } => (target, bound),\n                     WherePredicate::Lifetime { target, bound } => {\n-                        wln!(this, \"{}: {},\", target.name, bound.name);\n+                        wln!(\n+                            this,\n+                            \"{}: {},\",\n+                            target.name.display(self.db),\n+                            bound.name.display(self.db)\n+                        );\n                         continue;\n                     }\n                     WherePredicate::ForLifetime { lifetimes, target, bound } => {\n@@ -547,7 +548,7 @@ impl<'a> Printer<'a> {\n                             if i != 0 {\n                                 w!(this, \", \");\n                             }\n-                            w!(this, \"{}\", lt);\n+                            w!(this, \"{}\", lt.display(self.db));\n                         }\n                         w!(this, \"> \");\n                         (target, bound)\n@@ -558,7 +559,7 @@ impl<'a> Printer<'a> {\n                     WherePredicateTypeTarget::TypeRef(ty) => this.print_type_ref(ty),\n                     WherePredicateTypeTarget::TypeOrConstParam(id) => {\n                         match &params.type_or_consts[*id].name() {\n-                            Some(name) => w!(this, \"{}\", name),\n+                            Some(name) => w!(this, \"{}\", name.display(self.db)),\n                             None => w!(this, \"_anon_{}\", id.into_raw()),\n                         }\n                     }"}, {"sha": "5ded4b6b273ae54fadfdc4b6edffea9d6c5052fa", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -6,7 +6,7 @@ use crate::{db::DefDatabase, test_db::TestDB};\n fn check(ra_fixture: &str, expect: Expect) {\n     let (db, file_id) = TestDB::with_single_file(ra_fixture);\n     let item_tree = db.file_item_tree(file_id.into());\n-    let pretty = item_tree.pretty_print();\n+    let pretty = item_tree.pretty_print(&db);\n     expect.assert_eq(&pretty);\n }\n \n@@ -165,7 +165,7 @@ trait Tr: SuperTrait + 'lifetime {\n     fn method(&self);\n }\n         \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             pub static mut ST: () = _;\n \n             pub(self) const _: Anon = _;\n@@ -174,8 +174,8 @@ trait Tr: SuperTrait + 'lifetime {\n             #[inner_attr_in_fn]\n             pub(self) fn f(\n                 #[attr]\n-                arg: u8,\n-                _: (),\n+                u8,\n+                (),\n             ) -> () { ... }\n \n             pub(self) trait Tr<Self>\n@@ -186,10 +186,10 @@ trait Tr: SuperTrait + 'lifetime {\n                 pub(self) type Assoc: AssocBound = Default;\n \n                 pub(self) fn method(\n-                    _: &Self,  // self\n+                    self: &Self,\n                 ) -> ();\n             }\n-        \"##]],\n+        \"#]],\n     );\n }\n \n@@ -336,7 +336,7 @@ trait Tr<'a, T: 'a>: Super where Self: for<'a> Tr<'a, T> {}\n                 T: 'b\n             {\n                 pub(self) fn f<G>(\n-                    arg: impl Copy,\n+                    impl Copy,\n                 ) -> impl Copy\n                 where\n                     G: 'a { ... }"}, {"sha": "0e9ac58fbaaad8fbbd258683261e22f208d16f3f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/lang_item.rs", "status": "modified", "additions": 157, "deletions": 136, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -2,14 +2,13 @@\n //!\n //! This attribute to tell the compiler about semi built-in std library\n //! features, such as Fn family of traits.\n-use std::sync::Arc;\n-\n use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n+use triomphe::Arc;\n \n use crate::{\n-    db::DefDatabase, AdtId, AssocItemId, AttrDefId, CrateId, EnumId, EnumVariantId, FunctionId,\n-    ImplId, ModuleDefId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n+    db::DefDatabase, path::Path, AdtId, AssocItemId, AttrDefId, CrateId, EnumId, EnumVariantId,\n+    FunctionId, ImplId, ModuleDefId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -200,7 +199,7 @@ pub enum GenericRequirement {\n \n macro_rules! language_item_table {\n     (\n-        $( $(#[$attr:meta])* $variant:ident, $name:ident, $method:ident, $target:expr, $generics:expr; )*\n+        $( $(#[$attr:meta])* $variant:ident, $module:ident :: $name:ident, $method:ident, $target:expr, $generics:expr; )*\n     ) => {\n \n         /// A representation of all the valid language items in Rust.\n@@ -220,11 +219,6 @@ macro_rules! language_item_table {\n                 }\n             }\n \n-            /// Opposite of [`LangItem::name`]\n-            pub fn from_name(name: &hir_expand::name::Name) -> Option<Self> {\n-                Self::from_str(name.as_str()?)\n-            }\n-\n             /// Opposite of [`LangItem::name`]\n             pub fn from_str(name: &str) -> Option<Self> {\n                 match name {\n@@ -236,84 +230,100 @@ macro_rules! language_item_table {\n     }\n }\n \n+impl LangItem {\n+    /// Opposite of [`LangItem::name`]\n+    pub fn from_name(name: &hir_expand::name::Name) -> Option<Self> {\n+        Self::from_str(name.as_str()?)\n+    }\n+\n+    pub fn path(&self, db: &dyn DefDatabase, start_crate: CrateId) -> Option<Path> {\n+        let t = db.lang_item(start_crate, *self)?;\n+        Some(Path::LangItem(t))\n+    }\n+}\n+\n language_item_table! {\n //  Variant name,            Name,                     Getter method name,         Target                  Generic requirements;\n-    Sized,                   sized,               sized_trait,                Target::Trait,          GenericRequirement::Exact(0);\n-    Unsize,                  unsize,              unsize_trait,               Target::Trait,          GenericRequirement::Minimum(1);\n+    Sized,                   sym::sized,               sized_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    Unsize,                  sym::unsize,              unsize_trait,               Target::Trait,          GenericRequirement::Minimum(1);\n     /// Trait injected by `#[derive(PartialEq)]`, (i.e. \"Partial EQ\").\n-    StructuralPeq,           structural_peq,      structural_peq_trait,       Target::Trait,          GenericRequirement::None;\n+    StructuralPeq,           sym::structural_peq,      structural_peq_trait,       Target::Trait,          GenericRequirement::None;\n     /// Trait injected by `#[derive(Eq)]`, (i.e. \"Total EQ\"; no, I will not apologize).\n-    StructuralTeq,           structural_teq,      structural_teq_trait,       Target::Trait,          GenericRequirement::None;\n-    Copy,                    copy,                copy_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n-    Clone,                   clone,               clone_trait,                Target::Trait,          GenericRequirement::None;\n-    Sync,                    sync,                sync_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n-    DiscriminantKind,        discriminant_kind,   discriminant_kind_trait,    Target::Trait,          GenericRequirement::None;\n+    StructuralTeq,           sym::structural_teq,      structural_teq_trait,       Target::Trait,          GenericRequirement::None;\n+    Copy,                    sym::copy,                copy_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n+    Clone,                   sym::clone,               clone_trait,                Target::Trait,          GenericRequirement::None;\n+    Sync,                    sym::sync,                sync_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n+    DiscriminantKind,        sym::discriminant_kind,   discriminant_kind_trait,    Target::Trait,          GenericRequirement::None;\n     /// The associated item of the [`DiscriminantKind`] trait.\n-    Discriminant,            discriminant_type,   discriminant_type,          Target::AssocTy,        GenericRequirement::None;\n+    Discriminant,            sym::discriminant_type,   discriminant_type,          Target::AssocTy,        GenericRequirement::None;\n+\n+    PointeeTrait,            sym::pointee_trait,       pointee_trait,              Target::Trait,          GenericRequirement::None;\n+    Metadata,                sym::metadata_type,       metadata_type,              Target::AssocTy,        GenericRequirement::None;\n+    DynMetadata,             sym::dyn_metadata,        dyn_metadata,               Target::Struct,         GenericRequirement::None;\n \n-    PointeeTrait,            pointee_trait,       pointee_trait,              Target::Trait,          GenericRequirement::None;\n-    Metadata,                metadata_type,       metadata_type,              Target::AssocTy,        GenericRequirement::None;\n-    DynMetadata,             dyn_metadata,        dyn_metadata,               Target::Struct,         GenericRequirement::None;\n+    Freeze,                  sym::freeze,              freeze_trait,               Target::Trait,          GenericRequirement::Exact(0);\n \n-    Freeze,                  freeze,              freeze_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+    FnPtrTrait,              sym::fn_ptr_trait,        fn_ptr_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+    FnPtrAddr,               sym::fn_ptr_addr,         fn_ptr_addr,                Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n-    Drop,                    drop,                drop_trait,                 Target::Trait,          GenericRequirement::None;\n-    Destruct,                destruct,            destruct_trait,             Target::Trait,          GenericRequirement::None;\n+    Drop,                    sym::drop,                drop_trait,                 Target::Trait,          GenericRequirement::None;\n+    Destruct,                sym::destruct,            destruct_trait,             Target::Trait,          GenericRequirement::None;\n \n-    CoerceUnsized,           coerce_unsized,      coerce_unsized_trait,       Target::Trait,          GenericRequirement::Minimum(1);\n-    DispatchFromDyn,         dispatch_from_dyn,   dispatch_from_dyn_trait,    Target::Trait,          GenericRequirement::Minimum(1);\n+    CoerceUnsized,           sym::coerce_unsized,      coerce_unsized_trait,       Target::Trait,          GenericRequirement::Minimum(1);\n+    DispatchFromDyn,         sym::dispatch_from_dyn,   dispatch_from_dyn_trait,    Target::Trait,          GenericRequirement::Minimum(1);\n \n     // language items relating to transmutability\n-    TransmuteOpts,           transmute_opts,      transmute_opts,             Target::Struct,         GenericRequirement::Exact(0);\n-    TransmuteTrait,          transmute_trait,     transmute_trait,            Target::Trait,          GenericRequirement::Exact(3);\n-\n-    Add,                     add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Sub,                     sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Mul,                     mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Div,                     div,                 div_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Rem,                     rem,                 rem_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Neg,                     neg,                 neg_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n-    Not,                     not,                 not_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n-    BitXor,                  bitxor,              bitxor_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    BitAnd,                  bitand,              bitand_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    BitOr,                   bitor,               bitor_trait,                Target::Trait,          GenericRequirement::Exact(1);\n-    Shl,                     shl,                 shl_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Shr,                     shr,                 shr_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    AddAssign,               add_assign,          add_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    SubAssign,               sub_assign,          sub_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    MulAssign,               mul_assign,          mul_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    DivAssign,               div_assign,          div_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    RemAssign,               rem_assign,          rem_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    BitXorAssign,            bitxor_assign,       bitxor_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n-    BitAndAssign,            bitand_assign,       bitand_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n-    BitOrAssign,             bitor_assign,        bitor_assign_trait,         Target::Trait,          GenericRequirement::Exact(1);\n-    ShlAssign,               shl_assign,          shl_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    ShrAssign,               shr_assign,          shr_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    Index,                   index,               index_trait,                Target::Trait,          GenericRequirement::Exact(1);\n-    IndexMut,                index_mut,           index_mut_trait,            Target::Trait,          GenericRequirement::Exact(1);\n-\n-    UnsafeCell,              unsafe_cell,         unsafe_cell_type,           Target::Struct,         GenericRequirement::None;\n-    VaList,                  va_list,             va_list,                    Target::Struct,         GenericRequirement::None;\n-\n-    Deref,                   deref,               deref_trait,                Target::Trait,          GenericRequirement::Exact(0);\n-    DerefMut,                deref_mut,           deref_mut_trait,            Target::Trait,          GenericRequirement::Exact(0);\n-    DerefTarget,             deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n-    Receiver,                receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n-\n-    Fn,                      fn,                  fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    FnMut,                   fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    FnOnce,                  fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n-\n-    FnOnceOutput,            fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n-\n-    Future,                  future_trait,        future_trait,               Target::Trait,          GenericRequirement::Exact(0);\n-    GeneratorState,          generator_state,     gen_state,                  Target::Enum,           GenericRequirement::None;\n-    Generator,               generator,           gen_trait,                  Target::Trait,          GenericRequirement::Minimum(1);\n-    Unpin,                   unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n-    Pin,                     pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n-\n-    PartialEq,               eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    PartialOrd,              partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+    TransmuteOpts,           sym::transmute_opts,      transmute_opts,             Target::Struct,         GenericRequirement::Exact(0);\n+    TransmuteTrait,          sym::transmute_trait,     transmute_trait,            Target::Trait,          GenericRequirement::Exact(3);\n+\n+    Add,                     sym::add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Sub,                     sym::sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Mul,                     sym::mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Div,                     sym::div,                 div_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Rem,                     sym::rem,                 rem_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Neg,                     sym::neg,                 neg_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    Not,                     sym::not,                 not_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    BitXor,                  sym::bitxor,              bitxor_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitAnd,                  sym::bitand,              bitand_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitOr,                   sym::bitor,               bitor_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    Shl,                     sym::shl,                 shl_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Shr,                     sym::shr,                 shr_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    AddAssign,               sym::add_assign,          add_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    SubAssign,               sym::sub_assign,          sub_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    MulAssign,               sym::mul_assign,          mul_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    DivAssign,               sym::div_assign,          div_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    RemAssign,               sym::rem_assign,          rem_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    BitXorAssign,            sym::bitxor_assign,       bitxor_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitAndAssign,            sym::bitand_assign,       bitand_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitOrAssign,             sym::bitor_assign,        bitor_assign_trait,         Target::Trait,          GenericRequirement::Exact(1);\n+    ShlAssign,               sym::shl_assign,          shl_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    ShrAssign,               sym::shr_assign,          shr_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    Index,                   sym::index,               index_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    IndexMut,                sym::index_mut,           index_mut_trait,            Target::Trait,          GenericRequirement::Exact(1);\n+\n+    UnsafeCell,              sym::unsafe_cell,         unsafe_cell_type,           Target::Struct,         GenericRequirement::None;\n+    VaList,                  sym::va_list,             va_list,                    Target::Struct,         GenericRequirement::None;\n+\n+    Deref,                   sym::deref,               deref_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    DerefMut,                sym::deref_mut,           deref_mut_trait,            Target::Trait,          GenericRequirement::Exact(0);\n+    DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n+    Receiver,                sym::receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n+\n+    Fn,                      kw::fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    FnMut,                   sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    FnOnce,                  sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n+\n+    FnOnceOutput,            sym::fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n+\n+    Future,                  sym::future_trait,        future_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+    GeneratorState,          sym::generator_state,     gen_state,                  Target::Enum,           GenericRequirement::None;\n+    Generator,               sym::generator,           gen_trait,                  Target::Trait,          GenericRequirement::Minimum(1);\n+    Unpin,                   sym::unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n+    Pin,                     sym::pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n+\n+    PartialEq,               sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    PartialOrd,              sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+    CVoid,                   sym::c_void,              c_void,                     Target::Enum,           GenericRequirement::None;\n \n     // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n     // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays.\n@@ -322,92 +332,103 @@ language_item_table! {\n     // in the sense that a crate is not required to have it defined to use it, but a final product\n     // is required to define it somewhere. Additionally, there are restrictions on crates that use\n     // a weak lang item, but do not have it defined.\n-    Panic,                   panic,               panic_fn,                   Target::Fn,             GenericRequirement::Exact(0);\n-    PanicNounwind,           panic_nounwind,      panic_nounwind,             Target::Fn,             GenericRequirement::Exact(0);\n-    PanicFmt,                panic_fmt,           panic_fmt,                  Target::Fn,             GenericRequirement::None;\n-    PanicDisplay,            panic_display,       panic_display,              Target::Fn,             GenericRequirement::None;\n-    ConstPanicFmt,           const_panic_fmt,     const_panic_fmt,            Target::Fn,             GenericRequirement::None;\n-    PanicBoundsCheck,        panic_bounds_check,  panic_bounds_check_fn,      Target::Fn,             GenericRequirement::Exact(0);\n-    PanicInfo,               panic_info,          panic_info,                 Target::Struct,         GenericRequirement::None;\n-    PanicLocation,           panic_location,      panic_location,             Target::Struct,         GenericRequirement::None;\n-    PanicImpl,               panic_impl,          panic_impl,                 Target::Fn,             GenericRequirement::None;\n-    PanicCannotUnwind,       panic_cannot_unwind, panic_cannot_unwind,        Target::Fn,             GenericRequirement::Exact(0);\n+    Panic,                   sym::panic,               panic_fn,                   Target::Fn,             GenericRequirement::Exact(0);\n+    PanicNounwind,           sym::panic_nounwind,      panic_nounwind,             Target::Fn,             GenericRequirement::Exact(0);\n+    PanicFmt,                sym::panic_fmt,           panic_fmt,                  Target::Fn,             GenericRequirement::None;\n+    PanicDisplay,            sym::panic_display,       panic_display,              Target::Fn,             GenericRequirement::None;\n+    ConstPanicFmt,           sym::const_panic_fmt,     const_panic_fmt,            Target::Fn,             GenericRequirement::None;\n+    PanicBoundsCheck,        sym::panic_bounds_check,  panic_bounds_check_fn,      Target::Fn,             GenericRequirement::Exact(0);\n+    PanicMisalignedPointerDereference,        sym::panic_misaligned_pointer_dereference,  panic_misaligned_pointer_dereference_fn,      Target::Fn,             GenericRequirement::Exact(0);\n+    PanicInfo,               sym::panic_info,          panic_info,                 Target::Struct,         GenericRequirement::None;\n+    PanicLocation,           sym::panic_location,      panic_location,             Target::Struct,         GenericRequirement::None;\n+    PanicImpl,               sym::panic_impl,          panic_impl,                 Target::Fn,             GenericRequirement::None;\n+    PanicCannotUnwind,       sym::panic_cannot_unwind, panic_cannot_unwind,        Target::Fn,             GenericRequirement::Exact(0);\n     /// libstd panic entry point. Necessary for const eval to be able to catch it\n-    BeginPanic,              begin_panic,         begin_panic_fn,             Target::Fn,             GenericRequirement::None;\n+    BeginPanic,              sym::begin_panic,         begin_panic_fn,             Target::Fn,             GenericRequirement::None;\n \n-    ExchangeMalloc,          exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n-    BoxFree,                 box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n-    DropInPlace,             drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n-    AllocLayout,             alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n+    // Lang items needed for `format_args!()`.\n+    FormatAlignment,         sym::format_alignment,    format_alignment,           Target::Enum,           GenericRequirement::None;\n+    FormatArgument,          sym::format_argument,     format_argument,            Target::Struct,         GenericRequirement::None;\n+    FormatArguments,         sym::format_arguments,    format_arguments,           Target::Struct,         GenericRequirement::None;\n+    FormatCount,             sym::format_count,        format_count,               Target::Enum,           GenericRequirement::None;\n+    FormatPlaceholder,       sym::format_placeholder,  format_placeholder,         Target::Struct,         GenericRequirement::None;\n+    FormatUnsafeArg,         sym::format_unsafe_arg,   format_unsafe_arg,          Target::Struct,         GenericRequirement::None;\n \n-    Start,                   start,               start_fn,                   Target::Fn,             GenericRequirement::Exact(1);\n+    ExchangeMalloc,          sym::exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n+    BoxFree,                 sym::box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n+    DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n+    AllocLayout,             sym::alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n \n-    EhPersonality,           eh_personality,      eh_personality,             Target::Fn,             GenericRequirement::None;\n-    EhCatchTypeinfo,         eh_catch_typeinfo,   eh_catch_typeinfo,          Target::Static,         GenericRequirement::None;\n+    Start,                   sym::start,               start_fn,                   Target::Fn,             GenericRequirement::Exact(1);\n \n-    OwnedBox,                owned_box,           owned_box,                  Target::Struct,         GenericRequirement::Minimum(1);\n+    EhPersonality,           sym::eh_personality,      eh_personality,             Target::Fn,             GenericRequirement::None;\n+    EhCatchTypeinfo,         sym::eh_catch_typeinfo,   eh_catch_typeinfo,          Target::Static,         GenericRequirement::None;\n \n-    PhantomData,             phantom_data,        phantom_data,               Target::Struct,         GenericRequirement::Exact(1);\n+    OwnedBox,                sym::owned_box,           owned_box,                  Target::Struct,         GenericRequirement::Minimum(1);\n \n-    ManuallyDrop,            manually_drop,       manually_drop,              Target::Struct,         GenericRequirement::None;\n+    PhantomData,             sym::phantom_data,        phantom_data,               Target::Struct,         GenericRequirement::Exact(1);\n \n-    MaybeUninit,             maybe_uninit,        maybe_uninit,               Target::Union,          GenericRequirement::None;\n+    ManuallyDrop,            sym::manually_drop,       manually_drop,              Target::Struct,         GenericRequirement::None;\n+\n+    MaybeUninit,             sym::maybe_uninit,        maybe_uninit,               Target::Union,          GenericRequirement::None;\n \n     /// Align offset for stride != 1; must not panic.\n-    AlignOffset,             align_offset,        align_offset_fn,            Target::Fn,             GenericRequirement::None;\n+    AlignOffset,             sym::align_offset,        align_offset_fn,            Target::Fn,             GenericRequirement::None;\n \n-    Termination,             termination,         termination,                Target::Trait,          GenericRequirement::None;\n+    Termination,             sym::termination,         termination,                Target::Trait,          GenericRequirement::None;\n \n-    Try,                     Try,                 try_trait,                  Target::Trait,          GenericRequirement::None;\n+    Try,                     sym::Try,                 try_trait,                  Target::Trait,          GenericRequirement::None;\n \n-    Tuple,                   tuple_trait,         tuple_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    Tuple,                   sym::tuple_trait,         tuple_trait,                Target::Trait,          GenericRequirement::Exact(0);\n \n-    SliceLen,                slice_len_fn,        slice_len_fn,               Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+    SliceLen,                sym::slice_len_fn,        slice_len_fn,               Target::Method(MethodKind::Inherent), GenericRequirement::None;\n \n     // Language items from AST lowering\n-    TryTraitFromResidual,    from_residual,       from_residual_fn,           Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n-    TryTraitFromOutput,      from_output,         from_output_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n-    TryTraitBranch,          branch,              branch_fn,                  Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n-    TryTraitFromYeet,        from_yeet,           from_yeet_fn,               Target::Fn,             GenericRequirement::None;\n+    TryTraitFromResidual,    sym::from_residual,       from_residual_fn,           Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitFromOutput,      sym::from_output,         from_output_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitBranch,          sym::branch,              branch_fn,                  Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitFromYeet,        sym::from_yeet,           from_yeet_fn,               Target::Fn,             GenericRequirement::None;\n+\n+    PointerLike,             sym::pointer_like,        pointer_like,               Target::Trait,          GenericRequirement::Exact(0);\n \n-    PointerSized,            pointer_sized,       pointer_sized,              Target::Trait,          GenericRequirement::Exact(0);\n+    ConstParamTy,            sym::const_param_ty,      const_param_ty_trait,       Target::Trait,          GenericRequirement::Exact(0);\n \n-    Poll,                    Poll,                poll,                       Target::Enum,           GenericRequirement::None;\n-    PollReady,               Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;\n-    PollPending,             Pending,             poll_pending_variant,       Target::Variant,        GenericRequirement::None;\n+    Poll,                    sym::Poll,                poll,                       Target::Enum,           GenericRequirement::None;\n+    PollReady,               sym::Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;\n+    PollPending,             sym::Pending,             poll_pending_variant,       Target::Variant,        GenericRequirement::None;\n \n     // FIXME(swatinem): the following lang items are used for async lowering and\n     // should become obsolete eventually.\n-    ResumeTy,                ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n-    GetContext,              get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n-\n-    Context,                 Context,             context,                    Target::Struct,         GenericRequirement::None;\n-    FuturePoll,              poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    ResumeTy,                sym::ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n+    GetContext,              sym::get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n-    FromFrom,                from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n+    FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n-    OptionSome,              Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n-    OptionNone,              None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n+    Option,                  sym::Option,              option_type,                Target::Enum,           GenericRequirement::None;\n+    OptionSome,              sym::Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n+    OptionNone,              sym::None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n \n-    ResultOk,                Ok,                  result_ok_variant,          Target::Variant,        GenericRequirement::None;\n-    ResultErr,               Err,                 result_err_variant,         Target::Variant,        GenericRequirement::None;\n+    ResultOk,                sym::Ok,                  result_ok_variant,          Target::Variant,        GenericRequirement::None;\n+    ResultErr,               sym::Err,                 result_err_variant,         Target::Variant,        GenericRequirement::None;\n \n-    ControlFlowContinue,     Continue,            cf_continue_variant,        Target::Variant,        GenericRequirement::None;\n-    ControlFlowBreak,        Break,               cf_break_variant,           Target::Variant,        GenericRequirement::None;\n+    ControlFlowContinue,     sym::Continue,            cf_continue_variant,        Target::Variant,        GenericRequirement::None;\n+    ControlFlowBreak,        sym::Break,               cf_break_variant,           Target::Variant,        GenericRequirement::None;\n \n-    IntoFutureIntoFuture,    into_future,         into_future_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n-    IntoIterIntoIter,        into_iter,           into_iter_fn,               Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n-    IteratorNext,            next,                next_fn,                    Target::Method(MethodKind::Trait { body: false}), GenericRequirement::None;\n+    IntoFutureIntoFuture,    sym::into_future,         into_future_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    IntoIterIntoIter,        sym::into_iter,           into_iter_fn,               Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    IteratorNext,            sym::next,                next_fn,                    Target::Method(MethodKind::Trait { body: false}), GenericRequirement::None;\n \n-    PinNewUnchecked,         new_unchecked,       new_unchecked_fn,           Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+    PinNewUnchecked,         sym::new_unchecked,       new_unchecked_fn,           Target::Method(MethodKind::Inherent), GenericRequirement::None;\n \n-    RangeFrom,               RangeFrom,           range_from_struct,          Target::Struct,         GenericRequirement::None;\n-    RangeFull,               RangeFull,           range_full_struct,          Target::Struct,         GenericRequirement::None;\n-    RangeInclusiveStruct,    RangeInclusive,      range_inclusive_struct,     Target::Struct,         GenericRequirement::None;\n-    RangeInclusiveNew,       range_inclusive_new, range_inclusive_new_method, Target::Method(MethodKind::Inherent), GenericRequirement::None;\n-    Range,                   Range,               range_struct,               Target::Struct,         GenericRequirement::None;\n-    RangeToInclusive,        RangeToInclusive,    range_to_inclusive_struct,  Target::Struct,         GenericRequirement::None;\n-    RangeTo,                 RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n+    RangeFrom,               sym::RangeFrom,           range_from_struct,          Target::Struct,         GenericRequirement::None;\n+    RangeFull,               sym::RangeFull,           range_full_struct,          Target::Struct,         GenericRequirement::None;\n+    RangeInclusiveStruct,    sym::RangeInclusive,      range_inclusive_struct,     Target::Struct,         GenericRequirement::None;\n+    RangeInclusiveNew,       sym::range_inclusive_new, range_inclusive_new_method, Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+    Range,                   sym::Range,               range_struct,               Target::Struct,         GenericRequirement::None;\n+    RangeToInclusive,        sym::RangeToInclusive,    range_to_inclusive_struct,  Target::Struct,         GenericRequirement::None;\n+    RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n \n-    String,                  String,              string,                     Target::Struct,         GenericRequirement::None;\n+    String,                  sym::String,              string,                     Target::Struct,         GenericRequirement::None;\n+    CStr,                    sym::CStr,                c_str,                      Target::Struct,         GenericRequirement::None;\n }"}, {"sha": "49b1190ad46a3a009e9617c9057a898a11859385", "filename": "src/tools/rust-analyzer/crates/hir-def/src/layout.rs", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/7452822843cf461b56742f0fc648af35889a3070/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7452822843cf461b56742f0fc648af35889a3070/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flayout.rs?ref=7452822843cf461b56742f0fc648af35889a3070", "patch": "@@ -1,97 +0,0 @@\n-//! Definitions needed for computing data layout of types.\n-\n-use std::cmp;\n-\n-use la_arena::{Idx, RawIdx};\n-pub use rustc_abi::{\n-    Abi, AbiAndPrefAlign, AddressSpace, Align, Endian, FieldsShape, Integer, IntegerType,\n-    LayoutCalculator, Niche, Primitive, ReprFlags, ReprOptions, Scalar, Size, StructKind,\n-    TargetDataLayout, TargetDataLayoutErrors, WrappingRange,\n-};\n-\n-use crate::LocalEnumVariantId;\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct RustcEnumVariantIdx(pub LocalEnumVariantId);\n-\n-impl rustc_index::vec::Idx for RustcEnumVariantIdx {\n-    fn new(idx: usize) -> Self {\n-        RustcEnumVariantIdx(Idx::from_raw(RawIdx::from(idx as u32)))\n-    }\n-\n-    fn index(self) -> usize {\n-        u32::from(self.0.into_raw()) as usize\n-    }\n-}\n-\n-pub type Layout = rustc_abi::LayoutS<RustcEnumVariantIdx>;\n-pub type TagEncoding = rustc_abi::TagEncoding<RustcEnumVariantIdx>;\n-pub type Variants = rustc_abi::Variants<RustcEnumVariantIdx>;\n-\n-pub trait IntegerExt {\n-    fn repr_discr(\n-        dl: &TargetDataLayout,\n-        repr: &ReprOptions,\n-        min: i128,\n-        max: i128,\n-    ) -> Result<(Integer, bool), LayoutError>;\n-}\n-\n-impl IntegerExt for Integer {\n-    /// Finds the appropriate Integer type and signedness for the given\n-    /// signed discriminant range and `#[repr]` attribute.\n-    /// N.B.: `u128` values above `i128::MAX` will be treated as signed, but\n-    /// that shouldn't affect anything, other than maybe debuginfo.\n-    fn repr_discr(\n-        dl: &TargetDataLayout,\n-        repr: &ReprOptions,\n-        min: i128,\n-        max: i128,\n-    ) -> Result<(Integer, bool), LayoutError> {\n-        // Theoretically, negative values could be larger in unsigned representation\n-        // than the unsigned representation of the signed minimum. However, if there\n-        // are any negative values, the only valid unsigned representation is u128\n-        // which can fit all i128 values, so the result remains unaffected.\n-        let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u128, max as u128));\n-        let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n-\n-        if let Some(ity) = repr.int {\n-            let discr = Integer::from_attr(dl, ity);\n-            let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n-            if discr < fit {\n-                return Err(LayoutError::UserError(\n-                    \"Integer::repr_discr: `#[repr]` hint too small for \\\n-                      discriminant range of enum \"\n-                        .to_string(),\n-                ));\n-            }\n-            return Ok((discr, ity.is_signed()));\n-        }\n-\n-        let at_least = if repr.c() {\n-            // This is usually I32, however it can be different on some platforms,\n-            // notably hexagon and arm-none/thumb-none\n-            dl.c_enum_min_size\n-        } else {\n-            // repr(Rust) enums try to be as small as possible\n-            Integer::I8\n-        };\n-\n-        // If there are no negative values, we can use the unsigned fit.\n-        Ok(if min >= 0 {\n-            (cmp::max(unsigned_fit, at_least), false)\n-        } else {\n-            (cmp::max(signed_fit, at_least), true)\n-        })\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Clone)]\n-pub enum LayoutError {\n-    UserError(String),\n-    SizeOverflow,\n-    TargetLayoutNotAvailable,\n-    HasPlaceholder,\n-    NotImplemented,\n-    Unknown,\n-}"}, {"sha": "9cd3dfd6f7c96a4766d0a5bc8d9f88b89c958426", "filename": "src/tools/rust-analyzer/crates/hir-def/src/lib.rs", "status": "modified", "additions": 96, "deletions": 58, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -18,24 +18,23 @@ pub mod db;\n \n pub mod attr;\n pub mod path;\n-pub mod type_ref;\n pub mod builtin_type;\n-pub mod builtin_attr;\n pub mod per_ns;\n pub mod item_scope;\n \n+pub mod lower;\n+pub mod expander;\n+\n pub mod dyn_map;\n-pub mod keys;\n \n pub mod item_tree;\n \n-pub mod adt;\n pub mod data;\n pub mod generics;\n pub mod lang_item;\n-pub mod layout;\n \n-pub mod expr;\n+pub mod hir;\n+pub use self::hir::type_ref;\n pub mod body;\n pub mod resolver;\n \n@@ -49,29 +48,34 @@ pub mod visibility;\n pub mod find_path;\n pub mod import_map;\n \n+pub use rustc_abi as layout;\n+use triomphe::Arc;\n+\n #[cfg(test)]\n mod test_db;\n #[cfg(test)]\n mod macro_expansion_tests;\n mod pretty;\n \n-use std::{\n-    hash::{Hash, Hasher},\n-    sync::Arc,\n-};\n+use std::hash::{Hash, Hasher};\n \n-use base_db::{impl_intern_key, salsa, CrateId, ProcMacroKind};\n+use base_db::{\n+    impl_intern_key,\n+    salsa::{self, InternId},\n+    CrateId, ProcMacroKind,\n+};\n use hir_expand::{\n     ast_id_map::FileAstId,\n     attrs::{Attr, AttrId, AttrInput},\n     builtin_attr_macro::BuiltinAttrExpander,\n     builtin_derive_macro::BuiltinDeriveExpander,\n     builtin_fn_macro::{BuiltinFnLikeExpander, EagerExpander},\n-    eager::{expand_eager_macro, ErrorEmitted, ErrorSink},\n+    db::ExpandDatabase,\n+    eager::expand_eager_macro,\n     hygiene::Hygiene,\n     proc_macro::ProcMacroExpander,\n-    AstId, ExpandError, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId,\n-    MacroDefKind, UnresolvedMacro,\n+    AstId, ExpandError, ExpandResult, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind,\n+    MacroDefId, MacroDefKind, UnresolvedMacro,\n };\n use item_tree::ExternBlock;\n use la_arena::Idx;\n@@ -82,8 +86,8 @@ use syntax::ast;\n use ::tt::token_id as tt;\n \n use crate::{\n-    adt::VariantData,\n     builtin_type::BuiltinType,\n+    data::adt::VariantData,\n     item_tree::{\n         Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, MacroDef, MacroRules, ModItem,\n         Static, Struct, Trait, TraitAlias, TypeAlias, Union,\n@@ -104,13 +108,7 @@ pub struct ModuleId {\n impl ModuleId {\n     pub fn def_map(&self, db: &dyn db::DefDatabase) -> Arc<DefMap> {\n         match self.block {\n-            Some(block) => {\n-                db.block_def_map(block).unwrap_or_else(|| {\n-                    // NOTE: This should be unreachable - all `ModuleId`s come from their `DefMap`s,\n-                    // so the `DefMap` here must exist.\n-                    unreachable!(\"no `block_def_map` for `ModuleId` {:?}\", self);\n-                })\n-            }\n+            Some(block) => db.block_def_map(block),\n             None => db.crate_def_map(self.krate),\n         }\n     }\n@@ -236,15 +234,15 @@ pub struct EnumVariantId {\n     pub local_id: LocalEnumVariantId,\n }\n \n-pub type LocalEnumVariantId = Idx<adt::EnumVariantData>;\n+pub type LocalEnumVariantId = Idx<data::adt::EnumVariantData>;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct FieldId {\n     pub parent: VariantId,\n     pub local_id: LocalFieldId,\n }\n \n-pub type LocalFieldId = Idx<adt::FieldData>;\n+pub type LocalFieldId = Idx<data::adt::FieldData>;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ConstId(salsa::InternId);\n@@ -478,6 +476,46 @@ impl_from!(\n     for ModuleDefId\n );\n \n+// FIXME: make this a DefWithBodyId\n+#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n+pub struct AnonymousConstId(InternId);\n+impl_intern_key!(AnonymousConstId);\n+\n+/// A constant, which might appears as a const item, an annonymous const block in expressions\n+/// or patterns, or as a constant in types with const generics.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum GeneralConstId {\n+    ConstId(ConstId),\n+    AnonymousConstId(AnonymousConstId),\n+}\n+\n+impl_from!(ConstId, AnonymousConstId for GeneralConstId);\n+\n+impl GeneralConstId {\n+    pub fn generic_def(self, db: &dyn db::DefDatabase) -> Option<GenericDefId> {\n+        match self {\n+            GeneralConstId::ConstId(x) => Some(x.into()),\n+            GeneralConstId::AnonymousConstId(x) => {\n+                let (parent, _) = db.lookup_intern_anonymous_const(x);\n+                parent.as_generic_def_id()\n+            }\n+        }\n+    }\n+\n+    pub fn name(self, db: &dyn db::DefDatabase) -> String {\n+        match self {\n+            GeneralConstId::ConstId(const_id) => db\n+                .const_data(const_id)\n+                .name\n+                .as_ref()\n+                .and_then(|x| x.as_str())\n+                .unwrap_or(\"_\")\n+                .to_owned(),\n+            GeneralConstId::AnonymousConstId(id) => format!(\"{{anonymous const {id:?}}}\"),\n+        }\n+    }\n+}\n+\n /// The defs which have a body.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum DefWithBodyId {\n@@ -799,52 +837,43 @@ impl AttrDefId {\n pub trait AsMacroCall {\n     fn as_call_id(\n         &self,\n-        db: &dyn db::DefDatabase,\n+        db: &dyn ExpandDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n-        self.as_call_id_with_errors(db, krate, resolver, &mut |_| ()).ok()?.ok()\n+        self.as_call_id_with_errors(db, krate, resolver).ok()?.value\n     }\n \n     fn as_call_id_with_errors(\n         &self,\n-        db: &dyn db::DefDatabase,\n+        db: &dyn ExpandDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-        error_sink: &mut dyn FnMut(ExpandError),\n-    ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro>;\n+    ) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro>;\n }\n \n impl AsMacroCall for InFile<&ast::MacroCall> {\n     fn as_call_id_with_errors(\n         &self,\n-        db: &dyn db::DefDatabase,\n+        db: &dyn ExpandDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-        mut error_sink: &mut dyn FnMut(ExpandError),\n-    ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+    ) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n         let expands_to = hir_expand::ExpandTo::from_call_site(self.value);\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n-        let h = Hygiene::new(db.upcast(), self.file_id);\n-        let path =\n-            self.value.path().and_then(|path| path::ModPath::from_src(db.upcast(), path, &h));\n-\n-        let path = match error_sink\n-            .option(path, || ExpandError::Other(\"malformed macro invocation\".into()))\n-        {\n-            Ok(path) => path,\n-            Err(error) => {\n-                return Ok(Err(error));\n-            }\n+        let h = Hygiene::new(db, self.file_id);\n+        let path = self.value.path().and_then(|path| path::ModPath::from_src(db, path, &h));\n+\n+        let Some(path) = path else {\n+            return Ok(ExpandResult::only_err(ExpandError::Other(\"malformed macro invocation\".into())));\n         };\n \n-        macro_call_as_call_id(\n+        macro_call_as_call_id_(\n             db,\n             &AstIdWithPath::new(ast_id.file_id, ast_id.value, path),\n             expands_to,\n             krate,\n             resolver,\n-            error_sink,\n         )\n     }\n }\n@@ -863,26 +892,37 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n }\n \n fn macro_call_as_call_id(\n-    db: &dyn db::DefDatabase,\n+    db: &dyn ExpandDatabase,\n+    call: &AstIdWithPath<ast::MacroCall>,\n+    expand_to: ExpandTo,\n+    krate: CrateId,\n+    resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+) -> Result<Option<MacroCallId>, UnresolvedMacro> {\n+    macro_call_as_call_id_(db, call, expand_to, krate, resolver).map(|res| res.value)\n+}\n+\n+fn macro_call_as_call_id_(\n+    db: &dyn ExpandDatabase,\n     call: &AstIdWithPath<ast::MacroCall>,\n     expand_to: ExpandTo,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-    error_sink: &mut dyn FnMut(ExpandError),\n-) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n     let def =\n         resolver(call.path.clone()).ok_or_else(|| UnresolvedMacro { path: call.path.clone() })?;\n \n     let res = if let MacroDefKind::BuiltInEager(..) = def.kind {\n-        let macro_call = InFile::new(call.ast_id.file_id, call.ast_id.to_node(db.upcast()));\n-\n-        expand_eager_macro(db.upcast(), krate, macro_call, def, &resolver, error_sink)?\n+        let macro_call = InFile::new(call.ast_id.file_id, call.ast_id.to_node(db));\n+        expand_eager_macro(db, krate, macro_call, def, &resolver)?\n     } else {\n-        Ok(def.as_lazy_macro(\n-            db.upcast(),\n-            krate,\n-            MacroCallKind::FnLike { ast_id: call.ast_id, expand_to },\n-        ))\n+        ExpandResult {\n+            value: Some(def.as_lazy_macro(\n+                db,\n+                krate,\n+                MacroCallKind::FnLike { ast_id: call.ast_id, expand_to },\n+            )),\n+            err: None,\n+        }\n     };\n     Ok(res)\n }\n@@ -986,7 +1026,6 @@ fn attr_macro_as_call_id(\n     macro_attr: &Attr,\n     krate: CrateId,\n     def: MacroDefId,\n-    is_derive: bool,\n ) -> MacroCallId {\n     let arg = match macro_attr.input.as_deref() {\n         Some(AttrInput::TokenTree(tt, map)) => (\n@@ -1007,7 +1046,6 @@ fn attr_macro_as_call_id(\n             ast_id: item_attr.ast_id,\n             attr_args: Arc::new(arg),\n             invoc_attr_index: macro_attr.id,\n-            is_derive,\n         },\n     )\n }"}, {"sha": "af623fd0e5d4dd405029b58e646f636dda926257", "filename": "src/tools/rust-analyzer/crates/hir-def/src/lower.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flower.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -0,0 +1,45 @@\n+//! Context for lowering paths.\n+use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, AstId, HirFileId, InFile};\n+use once_cell::unsync::OnceCell;\n+use syntax::ast;\n+use triomphe::Arc;\n+\n+use crate::{db::DefDatabase, path::Path};\n+\n+pub struct LowerCtx<'a> {\n+    pub db: &'a dyn DefDatabase,\n+    hygiene: Hygiene,\n+    ast_id_map: Option<(HirFileId, OnceCell<Arc<AstIdMap>>)>,\n+}\n+\n+impl<'a> LowerCtx<'a> {\n+    pub fn new(db: &'a dyn DefDatabase, hygiene: &Hygiene, file_id: HirFileId) -> Self {\n+        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: Some((file_id, OnceCell::new())) }\n+    }\n+\n+    pub fn with_file_id(db: &'a dyn DefDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx {\n+            db,\n+            hygiene: Hygiene::new(db.upcast(), file_id),\n+            ast_id_map: Some((file_id, OnceCell::new())),\n+        }\n+    }\n+\n+    pub fn with_hygiene(db: &'a dyn DefDatabase, hygiene: &Hygiene) -> Self {\n+        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: None }\n+    }\n+\n+    pub(crate) fn hygiene(&self) -> &Hygiene {\n+        &self.hygiene\n+    }\n+\n+    pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n+        Path::from_src(ast, self)\n+    }\n+\n+    pub(crate) fn ast_id<N: syntax::AstNode>(&self, item: &N) -> Option<AstId<N>> {\n+        let &(file_id, ref ast_id_map) = self.ast_id_map.as_ref()?;\n+        let ast_id_map = ast_id_map.get_or_init(|| self.db.ast_id_map(file_id));\n+        Some(InFile::new(file_id, ast_id_map.ast_id(item)))\n+    }\n+}"}, {"sha": "80474bc154d08f52abcd9c5446f76331f6c39d71", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/builtin_derive_macro.rs", "status": "modified", "additions": 292, "deletions": 8, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -16,7 +16,7 @@ struct Foo;\n #[derive(Copy)]\n struct Foo;\n \n-impl < > core::marker::Copy for Foo< > {}\"#]],\n+impl < > core::marker::Copy for Foo< > where {}\"#]],\n     );\n }\n \n@@ -41,7 +41,7 @@ macro Copy {}\n #[derive(Copy)]\n struct Foo;\n \n-impl < > crate ::marker::Copy for Foo< > {}\"#]],\n+impl < > crate ::marker::Copy for Foo< > where {}\"#]],\n     );\n }\n \n@@ -57,7 +57,7 @@ struct Foo<A, B>;\n #[derive(Copy)]\n struct Foo<A, B>;\n \n-impl <T0: core::marker::Copy, T1: core::marker::Copy, > core::marker::Copy for Foo<T0, T1, > {}\"#]],\n+impl <A: core::marker::Copy, B: core::marker::Copy, > core::marker::Copy for Foo<A, B, > where {}\"#]],\n     );\n }\n \n@@ -74,7 +74,7 @@ struct Foo<A, B, 'a, 'b>;\n #[derive(Copy)]\n struct Foo<A, B, 'a, 'b>;\n \n-impl <T0: core::marker::Copy, T1: core::marker::Copy, > core::marker::Copy for Foo<T0, T1, > {}\"#]],\n+impl <A: core::marker::Copy, B: core::marker::Copy, > core::marker::Copy for Foo<A, B, > where {}\"#]],\n     );\n }\n \n@@ -84,13 +84,33 @@ fn test_clone_expand() {\n         r#\"\n //- minicore: derive, clone\n #[derive(Clone)]\n-struct Foo<A, B>;\n+enum Command<A, B> {\n+    Move { x: A, y: B },\n+    Do(&'static str),\n+    Jump,\n+}\n \"#,\n         expect![[r#\"\n #[derive(Clone)]\n-struct Foo<A, B>;\n+enum Command<A, B> {\n+    Move { x: A, y: B },\n+    Do(&'static str),\n+    Jump,\n+}\n \n-impl <T0: core::clone::Clone, T1: core::clone::Clone, > core::clone::Clone for Foo<T0, T1, > {}\"#]],\n+impl <A: core::clone::Clone, B: core::clone::Clone, > core::clone::Clone for Command<A, B, > where {\n+    fn clone(&self ) -> Self {\n+        match self {\n+            Command::Move {\n+                x: x, y: y,\n+            }\n+            =>Command::Move {\n+                x: x.clone(), y: y.clone(),\n+            }\n+            , Command::Do(f0, )=>Command::Do(f0.clone(), ), Command::Jump=>Command::Jump,\n+        }\n+    }\n+}\"#]],\n     );\n }\n \n@@ -106,6 +126,270 @@ struct Foo<const X: usize, T>(u32);\n #[derive(Clone)]\n struct Foo<const X: usize, T>(u32);\n \n-impl <const T0: usize, T1: core::clone::Clone, > core::clone::Clone for Foo<T0, T1, > {}\"#]],\n+impl <const X: usize, T: core::clone::Clone, > core::clone::Clone for Foo<X, T, > where {\n+    fn clone(&self ) -> Self {\n+        match self {\n+            Foo(f0, )=>Foo(f0.clone(), ),\n+        }\n+    }\n+}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_default_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, default\n+#[derive(Default)]\n+struct Foo {\n+    field1: i32,\n+    field2: (),\n+}\n+#[derive(Default)]\n+enum Bar {\n+    Foo(u8),\n+    #[default]\n+    Bar,\n+}\n+\"#,\n+        expect![[r#\"\n+#[derive(Default)]\n+struct Foo {\n+    field1: i32,\n+    field2: (),\n+}\n+#[derive(Default)]\n+enum Bar {\n+    Foo(u8),\n+    #[default]\n+    Bar,\n+}\n+\n+impl < > core::default::Default for Foo< > where {\n+    fn default() -> Self {\n+        Foo {\n+            field1: core::default::Default::default(), field2: core::default::Default::default(),\n+        }\n+    }\n+}\n+impl < > core::default::Default for Bar< > where {\n+    fn default() -> Self {\n+        Bar::Bar\n+    }\n+}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_partial_eq_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, eq\n+#[derive(PartialEq, Eq)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\"#,\n+        expect![[r#\"\n+#[derive(PartialEq, Eq)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\n+impl < > core::cmp::PartialEq for Command< > where {\n+    fn eq(&self , other: &Self ) -> bool {\n+        match (self , other) {\n+            (Command::Move {\n+                x: x_self, y: y_self,\n+            }\n+            , Command::Move {\n+                x: x_other, y: y_other,\n+            }\n+            )=>x_self.eq(x_other) && y_self.eq(y_other), (Command::Do(f0_self, ), Command::Do(f0_other, ))=>f0_self.eq(f0_other), (Command::Jump, Command::Jump)=>true , _unused=>false\n+        }\n+    }\n+}\n+impl < > core::cmp::Eq for Command< > where {}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_partial_ord_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, ord\n+#[derive(PartialOrd, Ord)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\"#,\n+        expect![[r#\"\n+#[derive(PartialOrd, Ord)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\n+impl < > core::cmp::PartialOrd for Command< > where {\n+    fn partial_cmp(&self , other: &Self ) -> core::option::Option::Option<core::cmp::Ordering> {\n+        match core::intrinsics::discriminant_value(self ).partial_cmp(&core::intrinsics::discriminant_value(other)) {\n+            core::option::Option::Some(core::cmp::Ordering::Equal)=> {\n+                match (self , other) {\n+                    (Command::Move {\n+                        x: x_self, y: y_self,\n+                    }\n+                    , Command::Move {\n+                        x: x_other, y: y_other,\n+                    }\n+                    )=>match x_self.partial_cmp(&x_other) {\n+                        core::option::Option::Some(core::cmp::Ordering::Equal)=> {\n+                            match y_self.partial_cmp(&y_other) {\n+                                core::option::Option::Some(core::cmp::Ordering::Equal)=> {\n+                                    core::option::Option::Some(core::cmp::Ordering::Equal)\n+                                }\n+                                c=>return c,\n+                            }\n+                        }\n+                        c=>return c,\n+                    }\n+                    , (Command::Do(f0_self, ), Command::Do(f0_other, ))=>match f0_self.partial_cmp(&f0_other) {\n+                        core::option::Option::Some(core::cmp::Ordering::Equal)=> {\n+                            core::option::Option::Some(core::cmp::Ordering::Equal)\n+                        }\n+                        c=>return c,\n+                    }\n+                    , (Command::Jump, Command::Jump)=>core::option::Option::Some(core::cmp::Ordering::Equal), _unused=>core::option::Option::Some(core::cmp::Ordering::Equal)\n+                }\n+            }\n+            c=>return c,\n+        }\n+    }\n+}\n+impl < > core::cmp::Ord for Command< > where {\n+    fn cmp(&self , other: &Self ) -> core::cmp::Ordering {\n+        match core::intrinsics::discriminant_value(self ).cmp(&core::intrinsics::discriminant_value(other)) {\n+            core::cmp::Ordering::Equal=> {\n+                match (self , other) {\n+                    (Command::Move {\n+                        x: x_self, y: y_self,\n+                    }\n+                    , Command::Move {\n+                        x: x_other, y: y_other,\n+                    }\n+                    )=>match x_self.cmp(&x_other) {\n+                        core::cmp::Ordering::Equal=> {\n+                            match y_self.cmp(&y_other) {\n+                                core::cmp::Ordering::Equal=> {\n+                                    core::cmp::Ordering::Equal\n+                                }\n+                                c=>return c,\n+                            }\n+                        }\n+                        c=>return c,\n+                    }\n+                    , (Command::Do(f0_self, ), Command::Do(f0_other, ))=>match f0_self.cmp(&f0_other) {\n+                        core::cmp::Ordering::Equal=> {\n+                            core::cmp::Ordering::Equal\n+                        }\n+                        c=>return c,\n+                    }\n+                    , (Command::Jump, Command::Jump)=>core::cmp::Ordering::Equal, _unused=>core::cmp::Ordering::Equal\n+                }\n+            }\n+            c=>return c,\n+        }\n+    }\n+}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_hash_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, hash\n+use core::hash::Hash;\n+\n+#[derive(Hash)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\"#,\n+        expect![[r#\"\n+use core::hash::Hash;\n+\n+#[derive(Hash)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\n+impl < > core::hash::Hash for Command< > where {\n+    fn hash<H: core::hash::Hasher>(&self , state: &mut H) {\n+        core::mem::discriminant(self ).hash(state);\n+        match self {\n+            Command::Move {\n+                x: x, y: y,\n+            }\n+            => {\n+                x.hash(state);\n+                y.hash(state);\n+            }\n+            , Command::Do(f0, )=> {\n+                f0.hash(state);\n+            }\n+            , Command::Jump=> {}\n+            ,\n+        }\n+    }\n+}\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_debug_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, fmt\n+use core::fmt::Debug;\n+\n+#[derive(Debug)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\"#,\n+        expect![[r#\"\n+use core::fmt::Debug;\n+\n+#[derive(Debug)]\n+enum Command {\n+    Move { x: i32, y: i32 },\n+    Do(&'static str),\n+    Jump,\n+}\n+\n+impl < > core::fmt::Debug for Command< > where {\n+    fn fmt(&self , f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        match self {\n+            Command::Move {\n+                x: x, y: y,\n+            }\n+            =>f.debug_struct(\"Move\").field(\"x\", &x).field(\"y\", &y).finish(), Command::Do(f0, )=>f.debug_tuple(\"Do\").field(&f0).finish(), Command::Jump=>f.write_str(\"Jump\"),\n+        }\n+    }\n+}\"#]],\n     );\n }"}, {"sha": "977f300636f5e3d816599d6b923d2c3de9b3b640", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 84, "deletions": 17, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -13,12 +13,12 @@ macro_rules! column {() => {}}\n \n fn main() { column!(); }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! column {() => {}}\n \n-fn main() { 0; }\n-\"##]],\n+fn main() { 0 as u32; }\n+\"#]],\n     );\n }\n \n@@ -31,12 +31,12 @@ macro_rules! line {() => {}}\n \n fn main() { line!() }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! line {() => {}}\n \n-fn main() { 0 }\n-\"##]],\n+fn main() { 0 as u32 }\n+\"#]],\n     );\n }\n \n@@ -97,7 +97,7 @@ fn main() { option_env!(\"TEST_ENV_VAR\"); }\n #[rustc_builtin_macro]\n macro_rules! option_env {() => {}}\n \n-fn main() { $crate::option::Option::None:: < &str>; }\n+fn main() { ::core::option::Option::None:: < &str>; }\n \"#]],\n     );\n }\n@@ -193,17 +193,17 @@ fn main() {\n     format_args!(\"{} {:?}\", arg1(a, b, c), arg2);\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n     ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n }\n \n fn main() {\n-    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::Argument::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::Argument::new(&(arg2), $crate::fmt::Display::fmt), ]);\n+    ::core::fmt::Arguments::new_v1(&[\"\", \" \", ], &[::core::fmt::Argument::new(&(arg1(a, b, c)), ::core::fmt::Display::fmt), ::core::fmt::Argument::new(&(arg2), ::core::fmt::Debug::fmt), ]);\n }\n-\"#]],\n+\"##]],\n     );\n }\n \n@@ -221,17 +221,84 @@ fn main() {\n     format_args!(\"{} {:?}\", a::<A,B>(), b);\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n     ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n }\n \n fn main() {\n-    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::Argument::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::Argument::new(&(b), $crate::fmt::Display::fmt), ]);\n+    ::core::fmt::Arguments::new_v1(&[\"\", \" \", ], &[::core::fmt::Argument::new(&(a::<A, B>()), ::core::fmt::Display::fmt), ::core::fmt::Argument::new(&(b), ::core::fmt::Debug::fmt), ]);\n }\n-\"#]],\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_format_args_expand_with_raw_strings() {\n+    check(\n+        r##\"\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    format_args!(\n+        r#\"{},mismatch,\"{}\",\"{}\"\"#,\n+        location_csv_pat(db, &analysis, vfs, &sm, pat_id),\n+        mismatch.expected.display(db),\n+        mismatch.actual.display(db)\n+    );\n+}\n+\"##,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    ::core::fmt::Arguments::new_v1(&[r#\"\"#, r#\",mismatch,\"\"#, r#\"\",\"\"#, r#\"\"\"#, ], &[::core::fmt::Argument::new(&(location_csv_pat(db, &analysis, vfs, &sm, pat_id)), ::core::fmt::Display::fmt), ::core::fmt::Argument::new(&(mismatch.expected.display(db)), ::core::fmt::Display::fmt), ::core::fmt::Argument::new(&(mismatch.actual.display(db)), ::core::fmt::Display::fmt), ]);\n+}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_format_args_expand_eager() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! concat {}\n+\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    format_args!(concat!(\"xxx{}y\", \"{:?}zzz\"), 2, b);\n+}\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! concat {}\n+\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    ::core::fmt::Arguments::new_v1(&[\"xxx\", \"y\", \"zzz\", ], &[::core::fmt::Argument::new(&(2), ::core::fmt::Display::fmt), ::core::fmt::Argument::new(&(b), ::core::fmt::Debug::fmt), ]);\n+}\n+\"##]],\n     );\n }\n \n@@ -250,7 +317,7 @@ fn main() {\n         format_args!/*+errors*/(\"{} {:?}\", a.);\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n@@ -259,10 +326,10 @@ macro_rules! format_args {\n \n fn main() {\n     let _ =\n-        /* parse error: expected field name or number */\n-$crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::Argument::new(&(a.), $crate::fmt::Display::fmt), ]);\n+        /* error: no rule matches input tokens *//* parse error: expected field name or number */\n+::core::fmt::Arguments::new_v1(&[\"\", \" \", ], &[::core::fmt::Argument::new(&(a.), ::core::fmt::Display::fmt), ::core::fmt::Argument::new(&(), ::core::fmt::Debug::fmt), ]);\n }\n-\"#]],\n+\"##]],\n     );\n }\n "}, {"sha": "553ffe3d0b88bfdea40fb21eaf4d96aa6cc225c1", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 40, "deletions": 91, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -4,6 +4,7 @@\n mod tt_conversion;\n mod matching;\n mod meta_syntax;\n+mod metavar_expr;\n mod regression;\n \n use expect_test::expect;\n@@ -98,7 +99,7 @@ fn#19 main#20(#21)#21 {#22\n     );\n }\n #[test]\n-fn float_field_acces_macro_input() {\n+fn float_field_access_macro_input() {\n     check(\n         r#\"\n macro_rules! foo {\n@@ -922,7 +923,7 @@ macro_rules! m {\n \n fn bar() -> &'a Baz<u8> {}\n \n-fn bar() -> extern \"Rust\"fn() -> Ret {}\n+fn bar() -> extern \"Rust\" fn() -> Ret {}\n \"#]],\n     );\n }\n@@ -1293,19 +1294,53 @@ ok!();\n }\n \n #[test]\n-fn test_vertical_bar_with_pat() {\n+fn test_vertical_bar_with_pat_param() {\n     check(\n         r#\"\n-macro_rules! m { (|$pat:pat| ) => { ok!(); } }\n+macro_rules! m { (|$pat:pat_param| ) => { ok!(); } }\n m! { |x| }\n  \"#,\n         expect![[r#\"\n-macro_rules! m { (|$pat:pat| ) => { ok!(); } }\n+macro_rules! m { (|$pat:pat_param| ) => { ok!(); } }\n ok!();\n  \"#]],\n     );\n }\n \n+#[test]\n+fn test_new_std_matches() {\n+    check(\n+        r#\"\n+macro_rules! matches {\n+    ($expression:expr, $pattern:pat $(if $guard:expr)? $(,)?) => {\n+        match $expression {\n+            $pattern $(if $guard)? => true,\n+            _ => false\n+        }\n+    };\n+}\n+fn main() {\n+    matches!(0, 0 | 1 if true);\n+}\n+ \"#,\n+        expect![[r#\"\n+macro_rules! matches {\n+    ($expression:expr, $pattern:pat $(if $guard:expr)? $(,)?) => {\n+        match $expression {\n+            $pattern $(if $guard)? => true,\n+            _ => false\n+        }\n+    };\n+}\n+fn main() {\n+    match 0 {\n+        0|1 if true =>true , _=>false\n+    };\n+}\n+ \"#]],\n+    );\n+}\n+\n #[test]\n fn test_dollar_crate_lhs_is_not_meta() {\n     check(\n@@ -1580,92 +1615,6 @@ struct Foo;\n     )\n }\n \n-#[test]\n-fn test_dollar_dollar() {\n-    check(\n-        r#\"\n-macro_rules! register_struct { ($Struct:ident) => {\n-    macro_rules! register_methods { ($$($method:ident),*) => {\n-        macro_rules! implement_methods { ($$$$($$val:expr),*) => {\n-            struct $Struct;\n-            impl $Struct { $$(fn $method() -> &'static [u32] { &[$$$$($$$$val),*] })*}\n-        }}\n-    }}\n-}}\n-\n-register_struct!(Foo);\n-register_methods!(alpha, beta);\n-implement_methods!(1, 2, 3);\n-\"#,\n-        expect![[r#\"\n-macro_rules! register_struct { ($Struct:ident) => {\n-    macro_rules! register_methods { ($$($method:ident),*) => {\n-        macro_rules! implement_methods { ($$$$($$val:expr),*) => {\n-            struct $Struct;\n-            impl $Struct { $$(fn $method() -> &'static [u32] { &[$$$$($$$$val),*] })*}\n-        }}\n-    }}\n-}}\n-\n-macro_rules !register_methods {\n-    ($($method: ident), *) = > {\n-        macro_rules!implement_methods {\n-            ($$($val: expr), *) = > {\n-                struct Foo;\n-                impl Foo {\n-                    $(fn $method()-> &'static[u32] {\n-                        &[$$($$val), *]\n-                    }\n-                    )*\n-                }\n-            }\n-        }\n-    }\n-}\n-macro_rules !implement_methods {\n-    ($($val: expr), *) = > {\n-        struct Foo;\n-        impl Foo {\n-            fn alpha()-> &'static[u32] {\n-                &[$($val), *]\n-            }\n-            fn beta()-> &'static[u32] {\n-                &[$($val), *]\n-            }\n-        }\n-    }\n-}\n-struct Foo;\n-impl Foo {\n-    fn alpha() -> &'static[u32] {\n-        &[1, 2, 3]\n-    }\n-    fn beta() -> &'static[u32] {\n-        &[1, 2, 3]\n-    }\n-}\n-\"#]],\n-    )\n-}\n-\n-#[test]\n-fn test_metavar_exprs() {\n-    check(\n-        r#\"\n-macro_rules! m {\n-    ( $( $t:tt )* ) => ( $( ${ignore(t)} -${index()} )-* );\n-}\n-const _: i32 = m!(a b c);\n-    \"#,\n-        expect![[r#\"\n-macro_rules! m {\n-    ( $( $t:tt )* ) => ( $( ${ignore(t)} -${index()} )-* );\n-}\n-const _: i32 = -0--1--2;\n-    \"#]],\n-    );\n-}\n-\n #[test]\n fn test_punct_without_space() {\n     // Puncts are \"glued\" greedily."}, {"sha": "0909d8c835443e00fe721d1e090e4c7e0082166b", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/matching.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -33,7 +33,7 @@ m!(&k\");\n \"#,\n         expect![[r#\"\n macro_rules! m { ($i:literal) => {}; }\n-/* error: Failed to lower macro args to token tree */\"#]],\n+/* error: invalid token tree */\"#]],\n     );\n }\n \n@@ -73,7 +73,7 @@ fn main() {\n macro_rules! asi { ($($stmt:stmt)*) => ($($stmt)*); }\n \n fn main() {\n-    let a = 2let b = 5drop(b-a)println!(\"{}\", a+b)\n+    let a = 2 let b = 5 drop(b-a)println!(\"{}\", a+b)\n }\n \"#]],\n     )\n@@ -106,7 +106,6 @@ stringify!(;\n \n #[test]\n fn range_patterns() {\n-    // FIXME: rustc thinks there are three patterns here, not one.\n     check(\n         r#\"\n macro_rules! m {\n@@ -118,7 +117,7 @@ m!(.. .. ..);\n macro_rules! m {\n     ($($p:pat)*) => (stringify!($($p |)*);)\n }\n-stringify!(.. .. .. |);\n+stringify!(.. | .. | .. |);\n \"#]],\n     );\n }"}, {"sha": "967b5ad36babffcada722d76c0664e80dbdcd9c7", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/metavar_expr.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmetavar_expr.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -0,0 +1,311 @@\n+//! Tests for RFC 3086 metavariable expressions.\n+\n+use expect_test::expect;\n+\n+use crate::macro_expansion_tests::check;\n+\n+#[test]\n+fn test_dollar_dollar() {\n+    check(\n+        r#\"\n+macro_rules! register_struct { ($Struct:ident) => {\n+    macro_rules! register_methods { ($$($method:ident),*) => {\n+        macro_rules! implement_methods { ($$$$($$val:expr),*) => {\n+            struct $Struct;\n+            impl $Struct { $$(fn $method() -> &'static [u32] { &[$$$$($$$$val),*] })*}\n+        }}\n+    }}\n+}}\n+\n+register_struct!(Foo);\n+register_methods!(alpha, beta);\n+implement_methods!(1, 2, 3);\n+\"#,\n+        expect![[r#\"\n+macro_rules! register_struct { ($Struct:ident) => {\n+    macro_rules! register_methods { ($$($method:ident),*) => {\n+        macro_rules! implement_methods { ($$$$($$val:expr),*) => {\n+            struct $Struct;\n+            impl $Struct { $$(fn $method() -> &'static [u32] { &[$$$$($$$$val),*] })*}\n+        }}\n+    }}\n+}}\n+\n+macro_rules !register_methods {\n+    ($($method: ident), *) = > {\n+        macro_rules!implement_methods {\n+            ($$($val: expr), *) = > {\n+                struct Foo;\n+                impl Foo {\n+                    $(fn $method()-> &'static[u32] {\n+                        &[$$($$val), *]\n+                    }\n+                    )*\n+                }\n+            }\n+        }\n+    }\n+}\n+macro_rules !implement_methods {\n+    ($($val: expr), *) = > {\n+        struct Foo;\n+        impl Foo {\n+            fn alpha()-> &'static[u32] {\n+                &[$($val), *]\n+            }\n+            fn beta()-> &'static[u32] {\n+                &[$($val), *]\n+            }\n+        }\n+    }\n+}\n+struct Foo;\n+impl Foo {\n+    fn alpha() -> &'static[u32] {\n+        &[1, 2, 3]\n+    }\n+    fn beta() -> &'static[u32] {\n+        &[1, 2, 3]\n+    }\n+}\n+\"#]],\n+    )\n+}\n+\n+#[test]\n+fn test_metavar_exprs() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ( $( $t:tt )* ) => ( $( ${ignore(t)} -${index()} )-* );\n+}\n+const _: i32 = m!(a b c);\n+    \"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ( $( $t:tt )* ) => ( $( ${ignore(t)} -${index()} )-* );\n+}\n+const _: i32 = -0--1--2;\n+    \"#]],\n+    );\n+}\n+\n+#[test]\n+fn count_basic() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($($t:ident),*) => {\n+        ${count(t)}\n+    }\n+}\n+\n+fn test() {\n+    m!();\n+    m!(a);\n+    m!(a, a);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($($t:ident),*) => {\n+        ${count(t)}\n+    }\n+}\n+\n+fn test() {\n+    0;\n+    1;\n+    2;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn count_with_depth() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($( $( $($t:ident)* ),* );*) => {\n+        $(\n+            {\n+                let depth_none = ${count(t)};\n+                let depth_zero = ${count(t, 0)};\n+                let depth_one = ${count(t, 1)};\n+            }\n+        )*\n+    }\n+}\n+\n+fn bar() {\n+    foo!(\n+        a a a, a, a a;\n+        a a a\n+    )\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($( $( $($t:ident)* ),* );*) => {\n+        $(\n+            {\n+                let depth_none = ${count(t)};\n+                let depth_zero = ${count(t, 0)};\n+                let depth_one = ${count(t, 1)};\n+            }\n+        )*\n+    }\n+}\n+\n+fn bar() {\n+     {\n+        let depth_none = 6;\n+        let depth_zero = 3;\n+        let depth_one = 6;\n+    } {\n+        let depth_none = 3;\n+        let depth_zero = 1;\n+        let depth_one = 3;\n+    }\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn count_depth_out_of_bounds() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($($t:ident)*) => { ${count(t, 1)} };\n+    ($( $( $l:literal )* );*) => { $(${count(l, 1)};)* }\n+}\n+macro_rules! bar {\n+    ($($t:ident)*) => { ${count(t, 1024)} };\n+    ($( $( $l:literal )* );*) => { $(${count(l, 8192)};)* }\n+}\n+\n+fn test() {\n+    foo!(a b);\n+    foo!(1 2; 3);\n+    bar!(a b);\n+    bar!(1 2; 3);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($($t:ident)*) => { ${count(t, 1)} };\n+    ($( $( $l:literal )* );*) => { $(${count(l, 1)};)* }\n+}\n+macro_rules! bar {\n+    ($($t:ident)*) => { ${count(t, 1024)} };\n+    ($( $( $l:literal )* );*) => { $(${count(l, 8192)};)* }\n+}\n+\n+fn test() {\n+    /* error: ${count} out of bounds */;\n+    /* error: ${count} out of bounds */;\n+    /* error: ${count} out of bounds */;\n+    /* error: ${count} out of bounds */;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn misplaced_count() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($($t:ident)*) => { $(${count(t)})* };\n+    ($l:literal) => { ${count(l)} }\n+}\n+\n+fn test() {\n+    foo!(a b c);\n+    foo!(1);\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($($t:ident)*) => { $(${count(t)})* };\n+    ($l:literal) => { ${count(l)} }\n+}\n+\n+fn test() {\n+    /* error: ${count} misplaced */;\n+    /* error: ${count} misplaced */;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn malformed_count() {\n+    check(\n+        r#\"\n+macro_rules! too_many_args {\n+    ($($t:ident)*) => { ${count(t, 1, leftover)} }\n+}\n+macro_rules! depth_suffixed {\n+    ($($t:ident)*) => { ${count(t, 0usize)} }\n+}\n+macro_rules! depth_too_large {\n+    ($($t:ident)*) => { ${count(t, 18446744073709551616)} }\n+}\n+\n+fn test() {\n+    too_many_args!();\n+    depth_suffixed!();\n+    depth_too_large!();\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! too_many_args {\n+    ($($t:ident)*) => { ${count(t, 1, leftover)} }\n+}\n+macro_rules! depth_suffixed {\n+    ($($t:ident)*) => { ${count(t, 0usize)} }\n+}\n+macro_rules! depth_too_large {\n+    ($($t:ident)*) => { ${count(t, 18446744073709551616)} }\n+}\n+\n+fn test() {\n+    /* error: invalid macro definition: invalid metavariable expression */;\n+    /* error: invalid macro definition: invalid metavariable expression */;\n+    /* error: invalid macro definition: invalid metavariable expression */;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn count_interaction_with_empty_binding() {\n+    // FIXME: Should this error? rustc currently accepts it.\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($($t:ident),*) => {\n+        ${count(t, 100)}\n+    }\n+}\n+\n+fn test() {\n+    m!();\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($($t:ident),*) => {\n+        ${count(t, 100)}\n+    }\n+}\n+\n+fn test() {\n+    0;\n+}\n+\"#]],\n+    );\n+}"}, {"sha": "d8e4a4dcc7c2b231501963e35434a2656690964a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/regression.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -297,55 +297,55 @@ macro_rules! impl_fn_for_zst  {\n \n #[derive(Clone)] struct CharEscapeDebugContinue;\n impl Fn<(char, )> for CharEscapeDebugContinue {\n-    #[inline] extern \"rust-call\"fn call(&self , (c, ): (char, )) -> char::EscapeDebug { {\n+    #[inline] extern \"rust-call\" fn call(&self , (c, ): (char, )) -> char::EscapeDebug { {\n             c.escape_debug_ext(false )\n         }\n     }\n }\n impl FnMut<(char, )> for CharEscapeDebugContinue {\n-    #[inline] extern \"rust-call\"fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeDebug {\n+    #[inline] extern \"rust-call\" fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeDebug {\n         Fn::call(&*self , (c, ))\n     }\n }\n impl FnOnce<(char, )> for CharEscapeDebugContinue {\n     type Output = char::EscapeDebug;\n-    #[inline] extern \"rust-call\"fn call_once(self , (c, ): (char, )) -> char::EscapeDebug {\n+    #[inline] extern \"rust-call\" fn call_once(self , (c, ): (char, )) -> char::EscapeDebug {\n         Fn::call(&self , (c, ))\n     }\n }\n #[derive(Clone)] struct CharEscapeUnicode;\n impl Fn<(char, )> for CharEscapeUnicode {\n-    #[inline] extern \"rust-call\"fn call(&self , (c, ): (char, )) -> char::EscapeUnicode { {\n+    #[inline] extern \"rust-call\" fn call(&self , (c, ): (char, )) -> char::EscapeUnicode { {\n             c.escape_unicode()\n         }\n     }\n }\n impl FnMut<(char, )> for CharEscapeUnicode {\n-    #[inline] extern \"rust-call\"fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeUnicode {\n+    #[inline] extern \"rust-call\" fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeUnicode {\n         Fn::call(&*self , (c, ))\n     }\n }\n impl FnOnce<(char, )> for CharEscapeUnicode {\n     type Output = char::EscapeUnicode;\n-    #[inline] extern \"rust-call\"fn call_once(self , (c, ): (char, )) -> char::EscapeUnicode {\n+    #[inline] extern \"rust-call\" fn call_once(self , (c, ): (char, )) -> char::EscapeUnicode {\n         Fn::call(&self , (c, ))\n     }\n }\n #[derive(Clone)] struct CharEscapeDefault;\n impl Fn<(char, )> for CharEscapeDefault {\n-    #[inline] extern \"rust-call\"fn call(&self , (c, ): (char, )) -> char::EscapeDefault { {\n+    #[inline] extern \"rust-call\" fn call(&self , (c, ): (char, )) -> char::EscapeDefault { {\n             c.escape_default()\n         }\n     }\n }\n impl FnMut<(char, )> for CharEscapeDefault {\n-    #[inline] extern \"rust-call\"fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeDefault {\n+    #[inline] extern \"rust-call\" fn call_mut(&mut self , (c, ): (char, )) -> char::EscapeDefault {\n         Fn::call(&*self , (c, ))\n     }\n }\n impl FnOnce<(char, )> for CharEscapeDefault {\n     type Output = char::EscapeDefault;\n-    #[inline] extern \"rust-call\"fn call_once(self , (c, ): (char, )) -> char::EscapeDefault {\n+    #[inline] extern \"rust-call\" fn call_once(self , (c, ): (char, )) -> char::EscapeDefault {\n         Fn::call(&self , (c, ))\n     }\n }\n@@ -833,7 +833,7 @@ macro_rules! rgb_color {\n /* parse error: expected SEMICOLON */\n /* parse error: expected expression, item or let statement */\n pub fn new() {\n-    let _ = 0as u32<<(8+8);\n+    let _ = 0 as u32<<(8+8);\n }\n // MACRO_ITEMS@0..31\n //   FN@0..31"}, {"sha": "ae56934f632f135a9108ffc724d37fb229cee390", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/tt_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -98,7 +98,7 @@ macro_rules! m1 { ($x:ident) => { ($x } }\n macro_rules! m2 { ($x:ident) => {} }\n \n /* error: invalid macro definition: expected subtree */\n-/* error: Failed to lower macro args to token tree */\n+/* error: invalid token tree */\n \"#]],\n     )\n }"}, {"sha": "4a62696df0810a354ce69a47d32919a4da4a80d8", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mod.rs", "status": "renamed", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -14,7 +14,7 @@ mod builtin_fn_macro;\n mod builtin_derive_macro;\n mod proc_macros;\n \n-use std::{iter, ops::Range, sync::Arc};\n+use std::{iter, ops::Range, sync};\n \n use ::mbe::TokenMap;\n use base_db::{fixture::WithFixture, ProcMacro, SourceDatabase};\n@@ -33,8 +33,13 @@ use syntax::{\n use tt::token_id::{Subtree, TokenId};\n \n use crate::{\n-    db::DefDatabase, macro_id_to_def_id, nameres::ModuleSource, resolver::HasResolver,\n-    src::HasSource, test_db::TestDB, AdtId, AsMacroCall, Lookup, ModuleDefId,\n+    db::DefDatabase,\n+    macro_id_to_def_id,\n+    nameres::{DefMap, MacroSubNs, ModuleSource},\n+    resolver::HasResolver,\n+    src::HasSource,\n+    test_db::TestDB,\n+    AdtId, AsMacroCall, Lookup, ModuleDefId,\n };\n \n #[track_caller]\n@@ -50,13 +55,13 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n         ProcMacro {\n             name: \"identity_when_valid\".into(),\n             kind: base_db::ProcMacroKind::Attr,\n-            expander: Arc::new(IdentityWhenValidProcMacroExpander),\n+            expander: sync::Arc::new(IdentityWhenValidProcMacroExpander),\n         },\n     )];\n     let db = TestDB::with_files_extra_proc_macros(ra_fixture, extra_proc_macros);\n     let krate = db.crate_graph().iter().next().unwrap();\n     let def_map = db.crate_def_map(krate);\n-    let local_id = def_map.root();\n+    let local_id = DefMap::ROOT;\n     let module = def_map.module_id(local_id);\n     let resolver = module.resolver(&db);\n     let source = def_map[local_id].definition_source(&db);\n@@ -125,21 +130,17 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n \n     for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n         let macro_call = InFile::new(source.file_id, &macro_call);\n-        let mut error = None;\n-        let macro_call_id = macro_call\n-            .as_call_id_with_errors(\n-                &db,\n-                krate,\n-                |path| {\n-                    resolver.resolve_path_as_macro(&db, &path).map(|it| macro_id_to_def_id(&db, it))\n-                },\n-                &mut |err| error = Some(err),\n-            )\n-            .unwrap()\n+        let res = macro_call\n+            .as_call_id_with_errors(&db, krate, |path| {\n+                resolver\n+                    .resolve_path_as_macro(&db, &path, Some(MacroSubNs::Bang))\n+                    .map(|it| macro_id_to_def_id(&db, it))\n+            })\n             .unwrap();\n+        let macro_call_id = res.value.unwrap();\n         let macro_file = MacroFile { macro_call_id };\n         let mut expansion_result = db.parse_macro_expansion(macro_file);\n-        expansion_result.err = expansion_result.err.or(error);\n+        expansion_result.err = expansion_result.err.or(res.err);\n         expansions.push((macro_call.value.clone(), expansion_result, db.macro_arg(macro_call_id)));\n     }\n \n@@ -157,34 +158,33 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n         if let Some(err) = exp.err {\n             format_to!(expn_text, \"/* error: {} */\", err);\n         }\n-        if let Some((parse, token_map)) = exp.value {\n-            if expect_errors {\n-                assert!(!parse.errors().is_empty(), \"no parse errors in expansion\");\n-                for e in parse.errors() {\n-                    format_to!(expn_text, \"/* parse error: {} */\\n\", e);\n-                }\n-            } else {\n-                assert!(\n-                    parse.errors().is_empty(),\n-                    \"parse errors in expansion: \\n{:#?}\",\n-                    parse.errors()\n-                );\n+        let (parse, token_map) = exp.value;\n+        if expect_errors {\n+            assert!(!parse.errors().is_empty(), \"no parse errors in expansion\");\n+            for e in parse.errors() {\n+                format_to!(expn_text, \"/* parse error: {} */\\n\", e);\n             }\n-            let pp = pretty_print_macro_expansion(\n-                parse.syntax_node(),\n-                show_token_ids.then_some(&*token_map),\n+        } else {\n+            assert!(\n+                parse.errors().is_empty(),\n+                \"parse errors in expansion: \\n{:#?}\",\n+                parse.errors()\n             );\n-            let indent = IndentLevel::from_node(call.syntax());\n-            let pp = reindent(indent, pp);\n-            format_to!(expn_text, \"{}\", pp);\n+        }\n+        let pp = pretty_print_macro_expansion(\n+            parse.syntax_node(),\n+            show_token_ids.then_some(&*token_map),\n+        );\n+        let indent = IndentLevel::from_node(call.syntax());\n+        let pp = reindent(indent, pp);\n+        format_to!(expn_text, \"{}\", pp);\n \n-            if tree {\n-                let tree = format!(\"{:#?}\", parse.syntax_node())\n-                    .split_inclusive('\\n')\n-                    .map(|line| format!(\"// {line}\"))\n-                    .collect::<String>();\n-                format_to!(expn_text, \"\\n{}\", tree)\n-            }\n+        if tree {\n+            let tree = format!(\"{:#?}\", parse.syntax_node())\n+                .split_inclusive('\\n')\n+                .map(|line| format!(\"// {line}\"))\n+                .collect::<String>();\n+            format_to!(expn_text, \"\\n{}\", tree)\n         }\n         let range = call.syntax().text_range();\n         let range: Range<usize> = range.into();\n@@ -287,6 +287,7 @@ fn pretty_print_macro_expansion(expn: SyntaxNode, map: Option<&TokenMap>) -> Str\n         let curr_kind = token.kind();\n         let space = match (prev_kind, curr_kind) {\n             _ if prev_kind.is_trivia() || curr_kind.is_trivia() => \"\",\n+            _ if prev_kind.is_literal() && !curr_kind.is_punct() => \" \",\n             (T!['{'], T!['}']) => \"\",\n             (T![=], _) | (_, T![=]) => \" \",\n             (_, T!['{']) => \" \",", "previous_filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests.rs"}, {"sha": "9b520bc3030f021f0e8d7365590c3199db17e58e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres.rs", "status": "modified", "additions": 195, "deletions": 80, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -57,16 +57,17 @@ mod path_resolution;\n #[cfg(test)]\n mod tests;\n \n-use std::{cmp::Ord, ops::Deref, sync::Arc};\n+use std::{cmp::Ord, ops::Deref};\n \n-use base_db::{CrateId, Edition, FileId};\n+use base_db::{CrateId, Edition, FileId, ProcMacroKind};\n use hir_expand::{name::Name, InFile, MacroCallId, MacroDefId};\n use itertools::Itertools;\n use la_arena::Arena;\n use profile::Count;\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::format_to;\n use syntax::{ast, SmolStr};\n+use triomphe::Arc;\n \n use crate::{\n     db::DefDatabase,\n@@ -76,7 +77,8 @@ use crate::{\n     path::ModPath,\n     per_ns::PerNs,\n     visibility::Visibility,\n-    AstId, BlockId, BlockLoc, FunctionId, LocalModuleId, MacroId, ModuleId, ProcMacroId,\n+    AstId, BlockId, BlockLoc, FunctionId, LocalModuleId, Lookup, MacroExpander, MacroId, ModuleId,\n+    ProcMacroId,\n };\n \n /// Contains the results of (early) name resolution.\n@@ -92,7 +94,6 @@ use crate::{\n pub struct DefMap {\n     _c: Count<Self>,\n     block: Option<BlockInfo>,\n-    root: LocalModuleId,\n     modules: Arena<ModuleData>,\n     krate: CrateId,\n     /// The prelude module for this crate. This either comes from an import\n@@ -102,17 +103,29 @@ pub struct DefMap {\n     /// but that attribute is nightly and when used in a block, it affects resolution globally\n     /// so we aren't handling this correctly anyways).\n     prelude: Option<ModuleId>,\n-    /// The extern prelude is only populated for non-block DefMaps\n+    /// `macro_use` prelude that contains macros from `#[macro_use]`'d external crates. Note that\n+    /// this contains all kinds of macro, not just `macro_rules!` macro.\n+    macro_use_prelude: FxHashMap<Name, MacroId>,\n+\n+    /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n+    /// attributes.\n+    derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<(Name, MacroId, MacroCallId)>>,\n+\n+    diagnostics: Vec<DefDiagnostic>,\n+\n+    data: Arc<DefMapCrateData>,\n+}\n+\n+/// Data that belongs to a crate which is shared between a crate's def map and all its block def maps.\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+struct DefMapCrateData {\n     extern_prelude: FxHashMap<Name, ModuleId>,\n \n     /// Side table for resolving derive helpers.\n     exported_derives: FxHashMap<MacroDefId, Box<[Name]>>,\n     fn_proc_macro_mapping: FxHashMap<FunctionId, ProcMacroId>,\n     /// The error that occurred when failing to load the proc-macro dll.\n     proc_macro_loading_error: Option<Box<str>>,\n-    /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n-    /// attributes.\n-    derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<(Name, MacroId, MacroCallId)>>,\n \n     /// Custom attributes registered with `#![register_attr]`.\n     registered_attrs: Vec<SmolStr>,\n@@ -122,10 +135,36 @@ pub struct DefMap {\n     unstable_features: FxHashSet<SmolStr>,\n     /// #[rustc_coherence_is_core]\n     rustc_coherence_is_core: bool,\n+    no_core: bool,\n+    no_std: bool,\n \n     edition: Edition,\n     recursion_limit: Option<u32>,\n-    diagnostics: Vec<DefDiagnostic>,\n+}\n+\n+impl DefMapCrateData {\n+    fn shrink_to_fit(&mut self) {\n+        let Self {\n+            extern_prelude,\n+            exported_derives,\n+            fn_proc_macro_mapping,\n+            registered_attrs,\n+            registered_tools,\n+            unstable_features,\n+            proc_macro_loading_error: _,\n+            rustc_coherence_is_core: _,\n+            no_core: _,\n+            no_std: _,\n+            edition: _,\n+            recursion_limit: _,\n+        } = self;\n+        extern_prelude.shrink_to_fit();\n+        exported_derives.shrink_to_fit();\n+        fn_proc_macro_mapping.shrink_to_fit();\n+        registered_attrs.shrink_to_fit();\n+        registered_tools.shrink_to_fit();\n+        unstable_features.shrink_to_fit();\n+    }\n }\n \n /// For `DefMap`s computed for a block expression, this stores its location in the parent map.\n@@ -134,7 +173,23 @@ struct BlockInfo {\n     /// The `BlockId` this `DefMap` was created from.\n     block: BlockId,\n     /// The containing module.\n-    parent: ModuleId,\n+    parent: BlockRelativeModuleId,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+struct BlockRelativeModuleId {\n+    block: Option<BlockId>,\n+    local_id: LocalModuleId,\n+}\n+\n+impl BlockRelativeModuleId {\n+    fn def_map(self, db: &dyn DefDatabase, krate: CrateId) -> Arc<DefMap> {\n+        self.into_module(krate).def_map(db)\n+    }\n+\n+    fn into_module(self, krate: CrateId) -> ModuleId {\n+        ModuleId { krate, block: self.block, local_id: self.local_id }\n+    }\n }\n \n impl std::ops::Index<LocalModuleId> for DefMap {\n@@ -224,6 +279,8 @@ pub struct ModuleData {\n }\n \n impl DefMap {\n+    pub const ROOT: LocalModuleId = LocalModuleId::from_raw(la_arena::RawIdx::from_u32(0));\n+\n     pub(crate) fn crate_def_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<DefMap> {\n         let _p = profile::span(\"crate_def_map_query\").detail(|| {\n             db.crate_graph()[krate].display_name.as_deref().unwrap_or_default().to_string()\n@@ -243,17 +300,10 @@ impl DefMap {\n         Arc::new(def_map)\n     }\n \n-    pub(crate) fn block_def_map_query(\n-        db: &dyn DefDatabase,\n-        block_id: BlockId,\n-    ) -> Option<Arc<DefMap>> {\n+    pub(crate) fn block_def_map_query(db: &dyn DefDatabase, block_id: BlockId) -> Arc<DefMap> {\n         let block: BlockLoc = db.lookup_intern_block(block_id);\n \n         let tree_id = TreeId::new(block.ast_id.file_id, Some(block_id));\n-        let item_tree = tree_id.item_tree(db);\n-        if item_tree.top_level_items().is_empty() {\n-            return None;\n-        }\n \n         let parent_map = block.module.def_map(db);\n         let krate = block.module.krate;\n@@ -265,36 +315,48 @@ impl DefMap {\n         let module_data =\n             ModuleData::new(ModuleOrigin::BlockExpr { block: block.ast_id }, visibility);\n \n-        let mut def_map = DefMap::empty(krate, parent_map.edition, module_data);\n-        def_map.block = Some(BlockInfo { block: block_id, parent: block.module });\n+        let mut def_map = DefMap::empty(krate, parent_map.data.edition, module_data);\n+        def_map.data = parent_map.data.clone();\n+        def_map.block = Some(BlockInfo {\n+            block: block_id,\n+            parent: BlockRelativeModuleId {\n+                block: block.module.block,\n+                local_id: block.module.local_id,\n+            },\n+        });\n \n         let def_map = collector::collect_defs(db, def_map, tree_id);\n-        Some(Arc::new(def_map))\n+        Arc::new(def_map)\n     }\n \n     fn empty(krate: CrateId, edition: Edition, module_data: ModuleData) -> DefMap {\n         let mut modules: Arena<ModuleData> = Arena::default();\n         let root = modules.alloc(module_data);\n+        assert_eq!(root, Self::ROOT);\n \n         DefMap {\n             _c: Count::new(),\n             block: None,\n+            modules,\n             krate,\n-            edition,\n-            recursion_limit: None,\n-            extern_prelude: FxHashMap::default(),\n-            exported_derives: FxHashMap::default(),\n-            fn_proc_macro_mapping: FxHashMap::default(),\n-            proc_macro_loading_error: None,\n-            derive_helpers_in_scope: FxHashMap::default(),\n             prelude: None,\n-            root,\n-            modules,\n-            registered_attrs: Vec::new(),\n-            registered_tools: Vec::new(),\n-            unstable_features: FxHashSet::default(),\n+            macro_use_prelude: FxHashMap::default(),\n+            derive_helpers_in_scope: FxHashMap::default(),\n             diagnostics: Vec::new(),\n-            rustc_coherence_is_core: false,\n+            data: Arc::new(DefMapCrateData {\n+                extern_prelude: FxHashMap::default(),\n+                exported_derives: FxHashMap::default(),\n+                fn_proc_macro_mapping: FxHashMap::default(),\n+                proc_macro_loading_error: None,\n+                registered_attrs: Vec::new(),\n+                registered_tools: Vec::new(),\n+                unstable_features: FxHashSet::default(),\n+                rustc_coherence_is_core: false,\n+                no_core: false,\n+                no_std: false,\n+                edition,\n+                recursion_limit: None,\n+            }),\n         }\n     }\n \n@@ -317,31 +379,31 @@ impl DefMap {\n     }\n \n     pub fn registered_tools(&self) -> &[SmolStr] {\n-        &self.registered_tools\n+        &self.data.registered_tools\n     }\n \n     pub fn registered_attrs(&self) -> &[SmolStr] {\n-        &self.registered_attrs\n+        &self.data.registered_attrs\n     }\n \n     pub fn is_unstable_feature_enabled(&self, feature: &str) -> bool {\n-        self.unstable_features.contains(feature)\n+        self.data.unstable_features.contains(feature)\n     }\n \n     pub fn is_rustc_coherence_is_core(&self) -> bool {\n-        self.rustc_coherence_is_core\n+        self.data.rustc_coherence_is_core\n     }\n \n-    pub fn root(&self) -> LocalModuleId {\n-        self.root\n+    pub fn is_no_std(&self) -> bool {\n+        self.data.no_std || self.data.no_core\n     }\n \n     pub fn fn_as_proc_macro(&self, id: FunctionId) -> Option<ProcMacroId> {\n-        self.fn_proc_macro_mapping.get(&id).copied()\n+        self.data.fn_proc_macro_mapping.get(&id).copied()\n     }\n \n     pub fn proc_macro_loading_error(&self) -> Option<&str> {\n-        self.proc_macro_loading_error.as_deref()\n+        self.data.proc_macro_loading_error.as_deref()\n     }\n \n     pub fn krate(&self) -> CrateId {\n@@ -356,20 +418,21 @@ impl DefMap {\n         self.prelude\n     }\n \n-    pub(crate) fn extern_prelude(&self) -> impl Iterator<Item = (&Name, &ModuleId)> + '_ {\n-        self.extern_prelude.iter()\n+    pub(crate) fn extern_prelude(&self) -> impl Iterator<Item = (&Name, ModuleId)> + '_ {\n+        self.data.extern_prelude.iter().map(|(name, def)| (name, *def))\n+    }\n+\n+    pub(crate) fn macro_use_prelude(&self) -> impl Iterator<Item = (&Name, MacroId)> + '_ {\n+        self.macro_use_prelude.iter().map(|(name, def)| (name, *def))\n     }\n \n     pub fn module_id(&self, local_id: LocalModuleId) -> ModuleId {\n         let block = self.block.map(|b| b.block);\n         ModuleId { krate: self.krate, local_id, block }\n     }\n \n-    pub(crate) fn crate_root(&self, db: &dyn DefDatabase) -> ModuleId {\n-        self.with_ancestor_maps(db, self.root, &mut |def_map, _module| {\n-            if def_map.block.is_none() { Some(def_map.module_id(def_map.root)) } else { None }\n-        })\n-        .expect(\"DefMap chain without root\")\n+    pub(crate) fn crate_root(&self) -> ModuleId {\n+        ModuleId { krate: self.krate, block: None, local_id: DefMap::ROOT }\n     }\n \n     pub(crate) fn resolve_path(\n@@ -378,9 +441,16 @@ impl DefMap {\n         original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> (PerNs, Option<usize>) {\n-        let res =\n-            self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path, shadow);\n+        let res = self.resolve_path_fp_with_macro(\n+            db,\n+            ResolveMode::Other,\n+            original_module,\n+            path,\n+            shadow,\n+            expected_macro_subns,\n+        );\n         (res.resolved_def, res.segment_index)\n     }\n \n@@ -397,6 +467,7 @@ impl DefMap {\n             original_module,\n             path,\n             shadow,\n+            None, // Currently this function isn't used for macro resolution.\n         );\n         (res.resolved_def, res.segment_index)\n     }\n@@ -416,7 +487,7 @@ impl DefMap {\n         }\n         let mut block = self.block;\n         while let Some(block_info) = block {\n-            let parent = block_info.parent.def_map(db);\n+            let parent = block_info.parent.def_map(db, self.krate);\n             if let Some(it) = f(&parent, block_info.parent.local_id) {\n                 return Some(it);\n             }\n@@ -429,15 +500,22 @@ impl DefMap {\n     /// If this `DefMap` is for a block expression, returns the module containing the block (which\n     /// might again be a block, or a module inside a block).\n     pub fn parent(&self) -> Option<ModuleId> {\n-        Some(self.block?.parent)\n+        let BlockRelativeModuleId { block, local_id } = self.block?.parent;\n+        Some(ModuleId { krate: self.krate, block, local_id })\n     }\n \n     /// Returns the module containing `local_mod`, either the parent `mod`, or the module (or block) containing\n     /// the block, if `self` corresponds to a block expression.\n     pub fn containing_module(&self, local_mod: LocalModuleId) -> Option<ModuleId> {\n         match self[local_mod].parent {\n             Some(parent) => Some(self.module_id(parent)),\n-            None => self.block.map(|block| block.parent),\n+            None => {\n+                self.block.map(\n+                    |BlockInfo { parent: BlockRelativeModuleId { block, local_id }, .. }| {\n+                        ModuleId { krate: self.krate, block, local_id }\n+                    },\n+                )\n+            }\n         }\n     }\n \n@@ -448,25 +526,31 @@ impl DefMap {\n         let mut arc;\n         let mut current_map = self;\n         while let Some(block) = current_map.block {\n-            go(&mut buf, current_map, \"block scope\", current_map.root);\n+            go(&mut buf, db, current_map, \"block scope\", Self::ROOT);\n             buf.push('\\n');\n-            arc = block.parent.def_map(db);\n+            arc = block.parent.def_map(db, self.krate);\n             current_map = &arc;\n         }\n-        go(&mut buf, current_map, \"crate\", current_map.root);\n+        go(&mut buf, db, current_map, \"crate\", Self::ROOT);\n         return buf;\n \n-        fn go(buf: &mut String, map: &DefMap, path: &str, module: LocalModuleId) {\n+        fn go(\n+            buf: &mut String,\n+            db: &dyn DefDatabase,\n+            map: &DefMap,\n+            path: &str,\n+            module: LocalModuleId,\n+        ) {\n             format_to!(buf, \"{}\\n\", path);\n \n-            map.modules[module].scope.dump(buf);\n+            map.modules[module].scope.dump(db.upcast(), buf);\n \n             for (name, child) in\n                 map.modules[module].children.iter().sorted_by(|a, b| Ord::cmp(&a.0, &b.0))\n             {\n-                let path = format!(\"{path}::{name}\");\n+                let path = format!(\"{path}::{}\", name.display(db.upcast()));\n                 buf.push('\\n');\n-                go(buf, map, &path, *child);\n+                go(buf, db, map, &path, *child);\n             }\n         }\n     }\n@@ -477,7 +561,7 @@ impl DefMap {\n         let mut current_map = self;\n         while let Some(block) = current_map.block {\n             format_to!(buf, \"{:?} in {:?}\\n\", block.block, block.parent);\n-            arc = block.parent.def_map(db);\n+            arc = block.parent.def_map(db, self.krate);\n             current_map = &arc;\n         }\n \n@@ -489,34 +573,20 @@ impl DefMap {\n         // Exhaustive match to require handling new fields.\n         let Self {\n             _c: _,\n-            exported_derives,\n-            extern_prelude,\n+            macro_use_prelude,\n             diagnostics,\n             modules,\n-            registered_attrs,\n-            registered_tools,\n-            fn_proc_macro_mapping,\n             derive_helpers_in_scope,\n-            unstable_features,\n-            proc_macro_loading_error: _,\n             block: _,\n-            edition: _,\n-            recursion_limit: _,\n             krate: _,\n             prelude: _,\n-            root: _,\n-            rustc_coherence_is_core: _,\n+            data: _,\n         } = self;\n \n-        extern_prelude.shrink_to_fit();\n-        exported_derives.shrink_to_fit();\n+        macro_use_prelude.shrink_to_fit();\n         diagnostics.shrink_to_fit();\n         modules.shrink_to_fit();\n-        registered_attrs.shrink_to_fit();\n-        registered_tools.shrink_to_fit();\n-        fn_proc_macro_mapping.shrink_to_fit();\n         derive_helpers_in_scope.shrink_to_fit();\n-        unstable_features.shrink_to_fit();\n         for (_, module) in modules.iter_mut() {\n             module.children.shrink_to_fit();\n             module.scope.shrink_to_fit();\n@@ -529,7 +599,7 @@ impl DefMap {\n     }\n \n     pub fn recursion_limit(&self) -> Option<u32> {\n-        self.recursion_limit\n+        self.data.recursion_limit\n     }\n }\n \n@@ -564,3 +634,48 @@ pub enum ModuleSource {\n     Module(ast::Module),\n     BlockExpr(ast::BlockExpr),\n }\n+\n+/// See `sub_namespace_match()`.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum MacroSubNs {\n+    /// Function-like macros, suffixed with `!`.\n+    Bang,\n+    /// Macros inside attributes, i.e. attribute macros and derive macros.\n+    Attr,\n+}\n+\n+impl MacroSubNs {\n+    fn from_id(db: &dyn DefDatabase, macro_id: MacroId) -> Self {\n+        let expander = match macro_id {\n+            MacroId::Macro2Id(it) => it.lookup(db).expander,\n+            MacroId::MacroRulesId(it) => it.lookup(db).expander,\n+            MacroId::ProcMacroId(it) => {\n+                return match it.lookup(db).kind {\n+                    ProcMacroKind::CustomDerive | ProcMacroKind::Attr => Self::Attr,\n+                    ProcMacroKind::FuncLike => Self::Bang,\n+                };\n+            }\n+        };\n+\n+        // Eager macros aren't *guaranteed* to be bang macros, but they *are* all bang macros currently.\n+        match expander {\n+            MacroExpander::Declarative\n+            | MacroExpander::BuiltIn(_)\n+            | MacroExpander::BuiltInEager(_) => Self::Bang,\n+            MacroExpander::BuiltInAttr(_) | MacroExpander::BuiltInDerive(_) => Self::Attr,\n+        }\n+    }\n+}\n+\n+/// Quoted from [rustc]:\n+/// Macro namespace is separated into two sub-namespaces, one for bang macros and\n+/// one for attribute-like macros (attributes, derives).\n+/// We ignore resolutions from one sub-namespace when searching names in scope for another.\n+///\n+/// [rustc]: https://github.com/rust-lang/rust/blob/1.69.0/compiler/rustc_resolve/src/macros.rs#L75\n+fn sub_namespace_match(candidate: Option<MacroSubNs>, expected: Option<MacroSubNs>) -> bool {\n+    match (candidate, expected) {\n+        (Some(candidate), Some(expected)) => candidate == expected,\n+        _ => true,\n+    }\n+}"}, {"sha": "a7abf445918aa4147965f1039b7a873f7823ac94", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -4,7 +4,8 @@ use hir_expand::{attrs::Attr, MacroCallId};\n use syntax::{ast, SmolStr};\n \n use crate::{\n-    attr_macro_as_call_id, builtin_attr,\n+    attr::builtin::{find_builtin_attr_idx, TOOL_MODULES},\n+    attr_macro_as_call_id,\n     db::DefDatabase,\n     item_scope::BuiltinShadowMode,\n     macro_id_to_def_id,\n@@ -13,7 +14,7 @@ use crate::{\n     AstIdWithPath, LocalModuleId, UnresolvedMacro,\n };\n \n-use super::DefMap;\n+use super::{DefMap, MacroSubNs};\n \n pub enum ResolvedAttr {\n     /// Attribute resolved to an attribute macro.\n@@ -42,9 +43,12 @@ impl DefMap {\n             original_module,\n             &ast_id.path,\n             BuiltinShadowMode::Module,\n+            Some(MacroSubNs::Attr),\n         );\n         let def = match resolved_res.resolved_def.take_macros() {\n             Some(def) => {\n+                // `MacroSubNs` is just a hint, so the path may still resolve to a custom derive\n+                // macro, or even function-like macro when the path is qualified.\n                 if def.is_attribute(db) {\n                     def\n                 } else {\n@@ -60,7 +64,6 @@ impl DefMap {\n             attr,\n             self.krate,\n             macro_id_to_def_id(db, def),\n-            false,\n         )))\n     }\n \n@@ -75,20 +78,16 @@ impl DefMap {\n             let name = name.to_smol_str();\n             let pred = |n: &_| *n == name;\n \n-            let registered = self.registered_tools.iter().map(SmolStr::as_str);\n-            let is_tool = builtin_attr::TOOL_MODULES.iter().copied().chain(registered).any(pred);\n+            let registered = self.data.registered_tools.iter().map(SmolStr::as_str);\n+            let is_tool = TOOL_MODULES.iter().copied().chain(registered).any(pred);\n             // FIXME: tool modules can be shadowed by actual modules\n             if is_tool {\n                 return true;\n             }\n \n             if segments.len() == 1 {\n-                let registered = self.registered_attrs.iter().map(SmolStr::as_str);\n-                let is_inert = builtin_attr::INERT_ATTRIBUTES\n-                    .iter()\n-                    .map(|it| it.name)\n-                    .chain(registered)\n-                    .any(pred);\n+                let mut registered = self.data.registered_attrs.iter().map(SmolStr::as_str);\n+                let is_inert = find_builtin_attr_idx(&name).is_some() || registered.any(pred);\n                 return is_inert;\n             }\n         }"}, {"sha": "06542b4b1e99960c472fd7e053a50f1332af35d4", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 339, "deletions": 270, "changes": 609, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -5,7 +5,7 @@\n \n use std::{iter, mem};\n \n-use base_db::{CrateId, Edition, FileId};\n+use base_db::{CrateId, Dependency, Edition, FileId};\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_expand::{\n@@ -14,17 +14,19 @@ use hir_expand::{\n     builtin_attr_macro::find_builtin_attr,\n     builtin_derive_macro::find_builtin_derive,\n     builtin_fn_macro::find_builtin_macro,\n+    hygiene::Hygiene,\n     name::{name, AsName, Name},\n     proc_macro::ProcMacroExpander,\n-    ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId,\n-    MacroDefKind,\n+    ExpandResult, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroCallLoc,\n+    MacroDefId, MacroDefKind,\n };\n use itertools::{izip, Itertools};\n use la_arena::Idx;\n use limit::Limit;\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::always;\n use syntax::{ast, SmolStr};\n+use triomphe::Arc;\n \n use crate::{\n     attr::Attrs,\n@@ -33,16 +35,17 @@ use crate::{\n     derive_macro_as_call_id,\n     item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n-        self, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, ItemTreeNode, MacroCall,\n-        MacroDef, MacroRules, Mod, ModItem, ModKind, TreeId,\n+        self, ExternCrate, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, ItemTreeNode,\n+        MacroCall, MacroDef, MacroRules, Mod, ModItem, ModKind, TreeId,\n     },\n     macro_call_as_call_id, macro_id_to_def_id,\n     nameres::{\n         diagnostics::DefDiagnostic,\n         mod_resolution::ModDir,\n         path_resolution::ReachedFixedPoint,\n         proc_macro::{parse_macro_name_and_helper_attrs, ProcMacroDef, ProcMacroKind},\n-        BuiltinShadowMode, DefMap, ModuleData, ModuleOrigin, ResolveMode,\n+        sub_namespace_match, BuiltinShadowMode, DefMap, MacroSubNs, ModuleData, ModuleOrigin,\n+        ResolveMode,\n     },\n     path::{ImportAlias, ModPath, PathKind},\n     per_ns::PerNs,\n@@ -59,44 +62,41 @@ static GLOB_RECURSION_LIMIT: Limit = Limit::new(100);\n static EXPANSION_DEPTH_LIMIT: Limit = Limit::new(128);\n static FIXED_POINT_LIMIT: Limit = Limit::new(8192);\n \n-pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: TreeId) -> DefMap {\n+pub(super) fn collect_defs(db: &dyn DefDatabase, def_map: DefMap, tree_id: TreeId) -> DefMap {\n     let crate_graph = db.crate_graph();\n \n     let mut deps = FxHashMap::default();\n     // populate external prelude and dependency list\n     let krate = &crate_graph[def_map.krate];\n     for dep in &krate.dependencies {\n         tracing::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.crate_id);\n-        let dep_def_map = db.crate_def_map(dep.crate_id);\n-        let dep_root = dep_def_map.module_id(dep_def_map.root);\n \n-        deps.insert(dep.as_name(), dep_root);\n-\n-        if dep.is_prelude() && !tree_id.is_block() {\n-            def_map.extern_prelude.insert(dep.as_name(), dep_root);\n-        }\n+        deps.insert(dep.as_name(), dep.clone());\n     }\n \n     let cfg_options = &krate.cfg_options;\n-    let proc_macros = match &krate.proc_macro {\n-        Ok(proc_macros) => {\n-            proc_macros\n-                .iter()\n-                .enumerate()\n-                .map(|(idx, it)| {\n-                    // FIXME: a hacky way to create a Name from string.\n-                    let name =\n-                        tt::Ident { text: it.name.clone(), span: tt::TokenId::unspecified() };\n-                    (name.as_name(), ProcMacroExpander::new(base_db::ProcMacroId(idx as u32)))\n-                })\n-                .collect()\n-        }\n-        Err(e) => {\n-            def_map.proc_macro_loading_error = Some(e.clone().into_boxed_str());\n-            Vec::new()\n+\n+    let is_proc_macro = krate.is_proc_macro;\n+    let proc_macros = if is_proc_macro {\n+        match db.proc_macros().get(&def_map.krate) {\n+            Some(Ok(proc_macros)) => {\n+                Ok(proc_macros\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(idx, it)| {\n+                        // FIXME: a hacky way to create a Name from string.\n+                        let name =\n+                            tt::Ident { text: it.name.clone(), span: tt::TokenId::unspecified() };\n+                        (name.as_name(), ProcMacroExpander::new(base_db::ProcMacroId(idx as u32)))\n+                    })\n+                    .collect())\n+            }\n+            Some(Err(e)) => Err(e.clone().into_boxed_str()),\n+            None => Err(\"No proc-macros present for crate\".to_owned().into_boxed_str()),\n         }\n+    } else {\n+        Ok(vec![])\n     };\n-    let is_proc_macro = krate.is_proc_macro;\n \n     let mut collector = DefCollector {\n         db,\n@@ -112,6 +112,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n         from_glob_import: Default::default(),\n         skip_attrs: Default::default(),\n         is_proc_macro,\n+        hygienes: FxHashMap::default(),\n     };\n     if tree_id.is_block() {\n         collector.seed_with_inner(tree_id);\n@@ -238,7 +239,7 @@ enum MacroDirectiveKind {\n struct DefCollector<'a> {\n     db: &'a dyn DefDatabase,\n     def_map: DefMap,\n-    deps: FxHashMap<Name, ModuleId>,\n+    deps: FxHashMap<Name, Dependency>,\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, Visibility)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     indeterminate_imports: Vec<ImportDirective>,\n@@ -249,7 +250,7 @@ struct DefCollector<'a> {\n     /// built by the build system, and is the list of proc. macros we can actually expand. It is\n     /// empty when proc. macro support is disabled (in which case we still do name resolution for\n     /// them).\n-    proc_macros: Vec<(Name, ProcMacroExpander)>,\n+    proc_macros: Result<Vec<(Name, ProcMacroExpander)>, Box<str>>,\n     is_proc_macro: bool,\n     from_glob_import: PerNsGlobImports,\n     /// If we fail to resolve an attribute on a `ModItem`, we fall back to ignoring the attribute.\n@@ -259,6 +260,12 @@ struct DefCollector<'a> {\n     /// This also stores the attributes to skip when we resolve derive helpers and non-macro\n     /// non-builtin attributes in general.\n     skip_attrs: FxHashMap<InFile<ModItem>, AttrId>,\n+    /// `Hygiene` cache, because `Hygiene` construction is expensive.\n+    ///\n+    /// Almost all paths should have been lowered to `ModPath` during `ItemTree` construction.\n+    /// However, `DefCollector` still needs to lower paths in attributes, in particular those in\n+    /// derive meta item list.\n+    hygienes: FxHashMap<HirFileId, Hygiene>,\n }\n \n impl DefCollector<'_> {\n@@ -267,86 +274,117 @@ impl DefCollector<'_> {\n \n         let file_id = self.db.crate_graph()[self.def_map.krate].root_file_id;\n         let item_tree = self.db.file_item_tree(file_id.into());\n-        let module_id = self.def_map.root;\n+        let module_id = DefMap::ROOT;\n \n         let attrs = item_tree.top_level_attrs(self.db, self.def_map.krate);\n-        if attrs.cfg().map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false)) {\n-            self.inject_prelude(&attrs);\n-\n-            // Process other crate-level attributes.\n-            for attr in &*attrs {\n-                let attr_name = match attr.path.as_ident() {\n-                    Some(name) => name,\n-                    None => continue,\n-                };\n+        let crate_data = Arc::get_mut(&mut self.def_map.data).unwrap();\n \n-                if *attr_name == hir_expand::name![recursion_limit] {\n-                    if let Some(limit) = attr.string_value() {\n-                        if let Ok(limit) = limit.parse() {\n-                            self.def_map.recursion_limit = Some(limit);\n-                        }\n-                    }\n-                    continue;\n+        if let Err(e) = &self.proc_macros {\n+            crate_data.proc_macro_loading_error = Some(e.clone());\n+        }\n+\n+        for (name, dep) in &self.deps {\n+            if dep.is_prelude() {\n+                crate_data.extern_prelude.insert(\n+                    name.clone(),\n+                    ModuleId { krate: dep.crate_id, block: None, local_id: DefMap::ROOT },\n+                );\n+            }\n+        }\n+\n+        // Process other crate-level attributes.\n+        for attr in &*attrs {\n+            if let Some(cfg) = attr.cfg() {\n+                if self.cfg_options.check(&cfg) == Some(false) {\n+                    return;\n                 }\n+            }\n+            let attr_name = match attr.path.as_ident() {\n+                Some(name) => name,\n+                None => continue,\n+            };\n \n-                if *attr_name == hir_expand::name![crate_type] {\n-                    if let Some(\"proc-macro\") = attr.string_value().map(SmolStr::as_str) {\n-                        self.is_proc_macro = true;\n+            if *attr_name == hir_expand::name![recursion_limit] {\n+                if let Some(limit) = attr.string_value() {\n+                    if let Ok(limit) = limit.parse() {\n+                        crate_data.recursion_limit = Some(limit);\n                     }\n-                    continue;\n                 }\n+                continue;\n+            }\n \n-                if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n-                    self.def_map.rustc_coherence_is_core = true;\n-                    continue;\n+            if *attr_name == hir_expand::name![crate_type] {\n+                if let Some(\"proc-macro\") = attr.string_value().map(SmolStr::as_str) {\n+                    self.is_proc_macro = true;\n                 }\n+                continue;\n+            }\n \n-                if *attr_name == hir_expand::name![feature] {\n-                    let features =\n-                        attr.parse_path_comma_token_tree().into_iter().flatten().filter_map(\n-                            |feat| match feat.segments() {\n-                                [name] => Some(name.to_smol_str()),\n-                                _ => None,\n-                            },\n-                        );\n-                    self.def_map.unstable_features.extend(features);\n-                }\n+            if *attr_name == hir_expand::name![no_core] {\n+                crate_data.no_core = true;\n+                continue;\n+            }\n \n-                let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n-                    || *attr_name == hir_expand::name![register_tool];\n-                if !attr_is_register_like {\n-                    continue;\n-                }\n+            if *attr_name == hir_expand::name![no_std] {\n+                crate_data.no_std = true;\n+                continue;\n+            }\n \n-                let registered_name = match attr.single_ident_value() {\n-                    Some(ident) => ident.as_name(),\n-                    _ => continue,\n-                };\n+            if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n+                crate_data.rustc_coherence_is_core = true;\n+                continue;\n+            }\n \n-                if *attr_name == hir_expand::name![register_attr] {\n-                    self.def_map.registered_attrs.push(registered_name.to_smol_str());\n-                    cov_mark::hit!(register_attr);\n-                } else {\n-                    self.def_map.registered_tools.push(registered_name.to_smol_str());\n-                    cov_mark::hit!(register_tool);\n-                }\n+            if *attr_name == hir_expand::name![feature] {\n+                let hygiene = &Hygiene::new_unhygienic();\n+                let features = attr\n+                    .parse_path_comma_token_tree(self.db.upcast(), hygiene)\n+                    .into_iter()\n+                    .flatten()\n+                    .filter_map(|feat| match feat.segments() {\n+                        [name] => Some(name.to_smol_str()),\n+                        _ => None,\n+                    });\n+                crate_data.unstable_features.extend(features);\n             }\n \n-            ModCollector {\n-                def_collector: self,\n-                macro_depth: 0,\n-                module_id,\n-                tree_id: TreeId::new(file_id.into(), None),\n-                item_tree: &item_tree,\n-                mod_dir: ModDir::root(),\n+            let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n+                || *attr_name == hir_expand::name![register_tool];\n+            if !attr_is_register_like {\n+                continue;\n+            }\n+\n+            let registered_name = match attr.single_ident_value() {\n+                Some(ident) => ident.as_name(),\n+                _ => continue,\n+            };\n+\n+            if *attr_name == hir_expand::name![register_attr] {\n+                crate_data.registered_attrs.push(registered_name.to_smol_str());\n+                cov_mark::hit!(register_attr);\n+            } else {\n+                crate_data.registered_tools.push(registered_name.to_smol_str());\n+                cov_mark::hit!(register_tool);\n             }\n-            .collect_in_top_module(item_tree.top_level_items());\n         }\n+\n+        crate_data.shrink_to_fit();\n+        self.inject_prelude();\n+\n+        ModCollector {\n+            def_collector: self,\n+            macro_depth: 0,\n+            module_id,\n+            tree_id: TreeId::new(file_id.into(), None),\n+            item_tree: &item_tree,\n+            mod_dir: ModDir::root(),\n+        }\n+        .collect_in_top_module(item_tree.top_level_items());\n     }\n \n     fn seed_with_inner(&mut self, tree_id: TreeId) {\n         let item_tree = tree_id.item_tree(self.db);\n-        let module_id = self.def_map.root;\n+        let module_id = DefMap::ROOT;\n \n         let is_cfg_enabled = item_tree\n             .top_level_attrs(self.db, self.def_map.krate)\n@@ -428,7 +466,7 @@ impl DefCollector<'_> {\n             // Additionally, while the proc macro entry points must be `pub`, they are not publicly\n             // exported in type/value namespace. This function reduces the visibility of all items\n             // in the crate root that aren't proc macros.\n-            let root = self.def_map.root;\n+            let root = DefMap::ROOT;\n             let module_id = self.def_map.module_id(root);\n             let root = &mut self.def_map.modules[root];\n             root.scope.censor_non_proc_macros(module_id);\n@@ -456,12 +494,8 @@ impl DefCollector<'_> {\n                         directive.module_id,\n                         MacroCallKind::Attr {\n                             ast_id: ast_id.ast_id,\n-                            attr_args: std::sync::Arc::new((\n-                                tt::Subtree::empty(),\n-                                Default::default(),\n-                            )),\n+                            attr_args: Arc::new((tt::Subtree::empty(), Default::default())),\n                             invoc_attr_index: attr.id,\n-                            is_derive: false,\n                         },\n                         attr.path().clone(),\n                     ));\n@@ -495,15 +529,15 @@ impl DefCollector<'_> {\n         }\n     }\n \n-    fn inject_prelude(&mut self, crate_attrs: &Attrs) {\n+    fn inject_prelude(&mut self) {\n         // See compiler/rustc_builtin_macros/src/standard_library_imports.rs\n \n-        if crate_attrs.by_key(\"no_core\").exists() {\n+        if self.def_map.data.no_core {\n             // libcore does not get a prelude.\n             return;\n         }\n \n-        let krate = if crate_attrs.by_key(\"no_std\").exists() {\n+        let krate = if self.def_map.data.no_std {\n             name![core]\n         } else {\n             let std = name![std];\n@@ -516,43 +550,31 @@ impl DefCollector<'_> {\n             }\n         };\n \n-        let edition = match self.def_map.edition {\n+        let edition = match self.def_map.data.edition {\n             Edition::Edition2015 => name![rust_2015],\n             Edition::Edition2018 => name![rust_2018],\n             Edition::Edition2021 => name![rust_2021],\n         };\n \n-        let path_kind = match self.def_map.edition {\n+        let path_kind = match self.def_map.data.edition {\n             Edition::Edition2015 => PathKind::Plain,\n             _ => PathKind::Abs,\n         };\n-        let path =\n-            ModPath::from_segments(path_kind, [krate.clone(), name![prelude], edition].into_iter());\n-        // Fall back to the older `std::prelude::v1` for compatibility with Rust <1.52.0\n-        // FIXME remove this fallback\n-        let fallback_path =\n-            ModPath::from_segments(path_kind, [krate, name![prelude], name![v1]].into_iter());\n-\n-        for path in &[path, fallback_path] {\n-            let (per_ns, _) = self.def_map.resolve_path(\n-                self.db,\n-                self.def_map.root,\n-                path,\n-                BuiltinShadowMode::Other,\n-            );\n+        let path = ModPath::from_segments(path_kind, [krate, name![prelude], edition]);\n \n-            match per_ns.types {\n-                Some((ModuleDefId::ModuleId(m), _)) => {\n-                    self.def_map.prelude = Some(m);\n-                    break;\n-                }\n-                types => {\n-                    tracing::debug!(\n-                        \"could not resolve prelude path `{}` to module (resolved to {:?})\",\n-                        path,\n-                        types\n-                    );\n-                }\n+        let (per_ns, _) =\n+            self.def_map.resolve_path(self.db, DefMap::ROOT, &path, BuiltinShadowMode::Other, None);\n+\n+        match per_ns.types {\n+            Some((ModuleDefId::ModuleId(m), _)) => {\n+                self.def_map.prelude = Some(m);\n+            }\n+            types => {\n+                tracing::debug!(\n+                    \"could not resolve prelude path `{}` to module (resolved to {:?})\",\n+                    path.display(self.db.upcast()),\n+                    types\n+                );\n             }\n         }\n     }\n@@ -578,23 +600,29 @@ impl DefCollector<'_> {\n         def: ProcMacroDef,\n         id: ItemTreeId<item_tree::Function>,\n         fn_id: FunctionId,\n-        module_id: ModuleId,\n     ) {\n+        if self.def_map.block.is_some() {\n+            return;\n+        }\n+        let crate_root = self.def_map.module_id(DefMap::ROOT);\n+\n         let kind = def.kind.to_basedb_kind();\n-        let (expander, kind) = match self.proc_macros.iter().find(|(n, _)| n == &def.name) {\n-            Some(&(_, expander)) => (expander, kind),\n-            None => (ProcMacroExpander::dummy(), kind),\n-        };\n+        let (expander, kind) =\n+            match self.proc_macros.as_ref().map(|it| it.iter().find(|(n, _)| n == &def.name)) {\n+                Ok(Some(&(_, expander))) => (expander, kind),\n+                _ => (ProcMacroExpander::dummy(), kind),\n+            };\n \n         let proc_macro_id =\n-            ProcMacroLoc { container: module_id, id, expander, kind }.intern(self.db);\n+            ProcMacroLoc { container: crate_root, id, expander, kind }.intern(self.db);\n         self.define_proc_macro(def.name.clone(), proc_macro_id);\n+        let crate_data = Arc::get_mut(&mut self.def_map.data).unwrap();\n         if let ProcMacroKind::CustomDerive { helpers } = def.kind {\n-            self.def_map\n+            crate_data\n                 .exported_derives\n                 .insert(macro_id_to_def_id(self.db, proc_macro_id.into()), helpers);\n         }\n-        self.def_map.fn_proc_macro_mapping.insert(fn_id, proc_macro_id);\n+        crate_data.fn_proc_macro_mapping.insert(fn_id, proc_macro_id);\n     }\n \n     /// Define a macro with `macro_rules`.\n@@ -636,7 +664,7 @@ impl DefCollector<'_> {\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            let module_id = self.def_map.root;\n+            let module_id = DefMap::ROOT;\n             self.def_map.modules[module_id].scope.declare(macro_.into());\n             self.update(\n                 module_id,\n@@ -687,7 +715,7 @@ impl DefCollector<'_> {\n     /// A proc macro is similar to normal macro scope, but it would not visible in legacy textual scoped.\n     /// And unconditionally exported.\n     fn define_proc_macro(&mut self, name: Name, macro_: ProcMacroId) {\n-        let module_id = self.def_map.root;\n+        let module_id = DefMap::ROOT;\n         self.def_map.modules[module_id].scope.declare(macro_.into());\n         self.update(\n             module_id,\n@@ -697,39 +725,28 @@ impl DefCollector<'_> {\n         );\n     }\n \n-    /// Import macros from `#[macro_use] extern crate`.\n-    fn import_macros_from_extern_crate(\n-        &mut self,\n-        current_module_id: LocalModuleId,\n-        extern_crate: &item_tree::ExternCrate,\n-    ) {\n-        tracing::debug!(\n-            \"importing macros from extern crate: {:?} ({:?})\",\n-            extern_crate,\n-            self.def_map.edition,\n-        );\n-\n-        if let Some(m) = self.resolve_extern_crate(&extern_crate.name) {\n-            if m == self.def_map.module_id(current_module_id) {\n-                cov_mark::hit!(ignore_macro_use_extern_crate_self);\n-                return;\n-            }\n-\n-            cov_mark::hit!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(current_module_id, m.krate);\n-        }\n-    }\n-\n-    /// Import all exported macros from another crate\n+    /// Import exported macros from another crate. `names`, if `Some(_)`, specifies the name of\n+    /// macros to be imported. Otherwise this method imports all exported macros.\n     ///\n     /// Exported macros are just all macros in the root module scope.\n     /// Note that it contains not only all `#[macro_export]` macros, but also all aliases\n     /// created by `use` in the root module, ignoring the visibility of `use`.\n-    fn import_all_macros_exported(&mut self, current_module_id: LocalModuleId, krate: CrateId) {\n+    fn import_macros_from_extern_crate(&mut self, krate: CrateId, names: Option<Vec<Name>>) {\n         let def_map = self.db.crate_def_map(krate);\n-        for (name, def) in def_map[def_map.root].scope.macros() {\n-            // `#[macro_use]` brings macros into legacy scope. Yes, even non-`macro_rules!` macros.\n-            self.define_legacy_macro(current_module_id, name.clone(), def);\n+        // `#[macro_use]` brings macros into macro_use prelude. Yes, even non-`macro_rules!`\n+        // macros.\n+        let root_scope = &def_map[DefMap::ROOT].scope;\n+        if let Some(names) = names {\n+            for name in names {\n+                // FIXME: Report diagnostic on 404.\n+                if let Some(def) = root_scope.get(&name).take_macros() {\n+                    self.def_map.macro_use_prelude.insert(name, def);\n+                }\n+            }\n+        } else {\n+            for (name, def) in root_scope.macros() {\n+                self.def_map.macro_use_prelude.insert(name.clone(), def);\n+            }\n         }\n     }\n \n@@ -762,8 +779,9 @@ impl DefCollector<'_> {\n     }\n \n     fn resolve_import(&self, module_id: LocalModuleId, import: &Import) -> PartialResolvedImport {\n-        let _p = profile::span(\"resolve_import\").detail(|| format!(\"{}\", import.path));\n-        tracing::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n+        let _p = profile::span(\"resolve_import\")\n+            .detail(|| format!(\"{}\", import.path.display(self.db.upcast())));\n+        tracing::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.data.edition);\n         if import.is_extern_crate {\n             let name = import\n                 .path\n@@ -785,6 +803,7 @@ impl DefCollector<'_> {\n                 module_id,\n                 &import.path,\n                 BuiltinShadowMode::Module,\n+                None, // An import may resolve to any kind of macro.\n             );\n \n             let def = res.resolved_def;\n@@ -815,16 +834,13 @@ impl DefCollector<'_> {\n     fn resolve_extern_crate(&self, name: &Name) -> Option<ModuleId> {\n         if *name == name!(self) {\n             cov_mark::hit!(extern_crate_self_as);\n-            let root = match self.def_map.block {\n-                Some(_) => {\n-                    let def_map = self.def_map.crate_root(self.db).def_map(self.db);\n-                    def_map.module_id(def_map.root())\n-                }\n-                None => self.def_map.module_id(self.def_map.root()),\n-            };\n-            Some(root)\n+            Some(self.def_map.crate_root())\n         } else {\n-            self.deps.get(name).copied()\n+            self.deps.get(name).map(|dep| ModuleId {\n+                krate: dep.crate_id,\n+                block: None,\n+                local_id: DefMap::ROOT,\n+            })\n         }\n     }\n \n@@ -863,11 +879,14 @@ impl DefCollector<'_> {\n                 // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n                 if import.is_extern_crate\n                     && self.def_map.block.is_none()\n-                    && module_id == self.def_map.root\n+                    && module_id == DefMap::ROOT\n                 {\n                     if let (Some(ModuleDefId::ModuleId(def)), Some(name)) = (def.take_types(), name)\n                     {\n-                        self.def_map.extern_prelude.insert(name.clone(), def);\n+                        Arc::get_mut(&mut self.def_map.data)\n+                            .unwrap()\n+                            .extern_prelude\n+                            .insert(name.clone(), def);\n                     }\n                 }\n \n@@ -1082,14 +1101,22 @@ impl DefCollector<'_> {\n             resolved.push((directive.module_id, directive.depth, directive.container, call_id));\n         };\n         let mut res = ReachedFixedPoint::Yes;\n+        // Retain unresolved macros after this round of resolution.\n         macros.retain(|directive| {\n+            let subns = match &directive.kind {\n+                MacroDirectiveKind::FnLike { .. } => MacroSubNs::Bang,\n+                MacroDirectiveKind::Attr { .. } | MacroDirectiveKind::Derive { .. } => {\n+                    MacroSubNs::Attr\n+                }\n+            };\n             let resolver = |path| {\n                 let resolved_res = self.def_map.resolve_path_fp_with_macro(\n                     self.db,\n                     ResolveMode::Other,\n                     directive.module_id,\n                     &path,\n                     BuiltinShadowMode::Module,\n+                    Some(subns),\n                 );\n                 resolved_res\n                     .resolved_def\n@@ -1101,15 +1128,15 @@ impl DefCollector<'_> {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n                     let call_id = macro_call_as_call_id(\n-                        self.db,\n+                        self.db.upcast(),\n                         ast_id,\n                         *expand_to,\n                         self.def_map.krate,\n                         resolver_def_id,\n-                        &mut |_err| (),\n                     );\n-                    if let Ok(Ok(call_id)) = call_id {\n+                    if let Ok(Some(call_id)) = call_id {\n                         push_resolved(directive, call_id);\n+\n                         res = ReachedFixedPoint::No;\n                         return false;\n                     }\n@@ -1134,7 +1161,7 @@ impl DefCollector<'_> {\n                         // Record its helper attributes.\n                         if def_id.krate != self.def_map.krate {\n                             let def_map = self.db.crate_def_map(def_id.krate);\n-                            if let Some(helpers) = def_map.exported_derives.get(&def_id) {\n+                            if let Some(helpers) = def_map.data.exported_derives.get(&def_id) {\n                                 self.def_map\n                                     .derive_helpers_in_scope\n                                     .entry(ast_id.ast_id.map(|it| it.upcast()))\n@@ -1214,7 +1241,19 @@ impl DefCollector<'_> {\n                         };\n                         let ast_id = ast_id.with_value(ast_adt_id);\n \n-                        match attr.parse_path_comma_token_tree() {\n+                        let extend_unhygenic;\n+                        let hygiene = if file_id.is_macro() {\n+                            self.hygienes\n+                                .entry(file_id)\n+                                .or_insert_with(|| Hygiene::new(self.db.upcast(), file_id))\n+                        } else {\n+                            // Avoid heap allocation (`Hygiene` embraces `Arc`) and hash map entry\n+                            // when we're in an oridinary (non-macro) file.\n+                            extend_unhygenic = Hygiene::new_unhygienic();\n+                            &extend_unhygenic\n+                        };\n+\n+                        match attr.parse_path_comma_token_tree(self.db.upcast(), hygiene) {\n                             Some(derive_macros) => {\n                                 let mut len = 0;\n                                 for (idx, path) in derive_macros.enumerate() {\n@@ -1241,7 +1280,6 @@ impl DefCollector<'_> {\n                                     attr,\n                                     self.def_map.krate,\n                                     def,\n-                                    true,\n                                 );\n                                 self.def_map.modules[directive.module_id]\n                                     .scope\n@@ -1261,18 +1299,12 @@ impl DefCollector<'_> {\n                     }\n \n                     // Not resolved to a derive helper or the derive attribute, so try to treat as a normal attribute.\n-                    let call_id = attr_macro_as_call_id(\n-                        self.db,\n-                        file_ast_id,\n-                        attr,\n-                        self.def_map.krate,\n-                        def,\n-                        false,\n-                    );\n+                    let call_id =\n+                        attr_macro_as_call_id(self.db, file_ast_id, attr, self.def_map.krate, def);\n                     let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n \n                     // If proc attribute macro expansion is disabled, skip expanding it here\n-                    if !self.db.enable_proc_attr_macros() {\n+                    if !self.db.expand_proc_attr_macros() {\n                         self.def_map.diagnostics.push(DefDiagnostic::unresolved_proc_macro(\n                             directive.module_id,\n                             loc.kind,\n@@ -1345,25 +1377,31 @@ impl DefCollector<'_> {\n         let file_id = macro_call_id.as_file();\n \n         // First, fetch the raw expansion result for purposes of error reporting. This goes through\n-        // `macro_expand_error` to avoid depending on the full expansion result (to improve\n+        // `parse_macro_expansion_error` to avoid depending on the full expansion result (to improve\n         // incrementality).\n-        let loc: MacroCallLoc = self.db.lookup_intern_macro_call(macro_call_id);\n-        let err = self.db.macro_expand_error(macro_call_id);\n+        let ExpandResult { value, err } = self.db.parse_macro_expansion_error(macro_call_id);\n         if let Some(err) = err {\n+            let loc: MacroCallLoc = self.db.lookup_intern_macro_call(macro_call_id);\n             let diag = match err {\n+                // why is this reported here?\n                 hir_expand::ExpandError::UnresolvedProcMacro(krate) => {\n                     always!(krate == loc.def.krate);\n-                    // Missing proc macros are non-fatal, so they are handled specially.\n                     DefDiagnostic::unresolved_proc_macro(module_id, loc.kind.clone(), loc.def.krate)\n                 }\n-                _ => DefDiagnostic::macro_error(module_id, loc.kind, err.to_string()),\n+                _ => DefDiagnostic::macro_error(module_id, loc.kind.clone(), err.to_string()),\n             };\n \n             self.def_map.diagnostics.push(diag);\n         }\n+        if let errors @ [_, ..] = &*value {\n+            let loc: MacroCallLoc = self.db.lookup_intern_macro_call(macro_call_id);\n+            let diag = DefDiagnostic::macro_expansion_parse_error(module_id, loc.kind, &errors);\n+            self.def_map.diagnostics.push(diag);\n+        }\n \n         // Then, fetch and process the item tree. This will reuse the expansion result from above.\n         let item_tree = self.db.file_item_tree(file_id);\n+\n         let mod_dir = self.mod_dirs[&module_id].clone();\n         ModCollector {\n             def_collector: &mut *self,\n@@ -1384,8 +1422,9 @@ impl DefCollector<'_> {\n         for directive in &self.unresolved_macros {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n+                    // FIXME: we shouldn't need to re-resolve the macro here just to get the unresolved error!\n                     let macro_call_as_call_id = macro_call_as_call_id(\n-                        self.db,\n+                        self.db.upcast(),\n                         ast_id,\n                         *expand_to,\n                         self.def_map.krate,\n@@ -1396,13 +1435,13 @@ impl DefCollector<'_> {\n                                 directive.module_id,\n                                 &path,\n                                 BuiltinShadowMode::Module,\n+                                Some(MacroSubNs::Bang),\n                             );\n                             resolved_res\n                                 .resolved_def\n                                 .take_macros()\n                                 .map(|it| macro_id_to_def_id(self.db, it))\n                         },\n-                        &mut |_| (),\n                     );\n                     if let Err(UnresolvedMacro { path }) = macro_call_as_call_id {\n                         self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n@@ -1489,35 +1528,30 @@ impl ModCollector<'_, '_> {\n \n     fn collect(&mut self, items: &[ModItem], container: ItemContainerId) {\n         let krate = self.def_collector.def_map.krate;\n+        let is_crate_root = self.module_id == DefMap::ROOT;\n \n         // Note: don't assert that inserted value is fresh: it's simply not true\n         // for macros.\n         self.def_collector.mod_dirs.insert(self.module_id, self.mod_dir.clone());\n \n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n-            if prelude_module.krate != krate {\n+            if prelude_module.krate != krate && is_crate_root {\n                 cov_mark::hit!(prelude_is_macro_use);\n-                self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n+                self.def_collector.import_macros_from_extern_crate(prelude_module.krate, None);\n             }\n         }\n \n         // This should be processed eagerly instead of deferred to resolving.\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n-        for &item in items {\n-            let attrs = self.item_tree.attrs(self.def_collector.db, krate, item.into());\n-            if attrs.cfg().map_or(true, |cfg| self.is_cfg_enabled(&cfg)) {\n+        //\n+        // If we're not at the crate root, `macro_use`d extern crates are an error so let's just\n+        // ignore them.\n+        if is_crate_root {\n+            for &item in items {\n                 if let ModItem::ExternCrate(id) = item {\n-                    let import = &self.item_tree[id];\n-                    let attrs = self.item_tree.attrs(\n-                        self.def_collector.db,\n-                        krate,\n-                        ModItem::from(id).into(),\n-                    );\n-                    if attrs.by_key(\"macro_use\").exists() {\n-                        self.def_collector.import_macros_from_extern_crate(self.module_id, import);\n-                    }\n+                    self.process_macro_use_extern_crate(id);\n                 }\n             }\n         }\n@@ -1610,14 +1644,12 @@ impl ModCollector<'_, '_> {\n                         FunctionLoc { container, id: ItemTreeId::new(self.tree_id, id) }.intern(db);\n \n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n-                    if self.def_collector.is_proc_macro && self.module_id == def_map.root {\n+                    if self.def_collector.is_proc_macro && self.module_id == DefMap::ROOT {\n                         if let Some(proc_macro) = attrs.parse_proc_macro_decl(&it.name) {\n-                            let crate_root = def_map.module_id(def_map.root);\n                             self.def_collector.export_proc_macro(\n                                 proc_macro,\n                                 ItemTreeId::new(self.tree_id, id),\n                                 fn_id,\n-                                crate_root,\n                             );\n                         }\n                     }\n@@ -1744,6 +1776,52 @@ impl ModCollector<'_, '_> {\n         }\n     }\n \n+    fn process_macro_use_extern_crate(&mut self, extern_crate: FileItemTreeId<ExternCrate>) {\n+        let db = self.def_collector.db;\n+        let attrs = self.item_tree.attrs(\n+            db,\n+            self.def_collector.def_map.krate,\n+            ModItem::from(extern_crate).into(),\n+        );\n+        if let Some(cfg) = attrs.cfg() {\n+            if !self.is_cfg_enabled(&cfg) {\n+                return;\n+            }\n+        }\n+\n+        let target_crate =\n+            match self.def_collector.resolve_extern_crate(&self.item_tree[extern_crate].name) {\n+                Some(m) => {\n+                    if m == self.def_collector.def_map.module_id(self.module_id) {\n+                        cov_mark::hit!(ignore_macro_use_extern_crate_self);\n+                        return;\n+                    }\n+                    m.krate\n+                }\n+                None => return,\n+            };\n+\n+        cov_mark::hit!(macro_rules_from_other_crates_are_visible_with_macro_use);\n+\n+        let mut single_imports = Vec::new();\n+        let hygiene = Hygiene::new_unhygienic();\n+        for attr in attrs.by_key(\"macro_use\").attrs() {\n+            let Some(paths) = attr.parse_path_comma_token_tree(db.upcast(), &hygiene) else {\n+                // `#[macro_use]` (without any paths) found, forget collected names and just import\n+                // all visible macros.\n+                self.def_collector.import_macros_from_extern_crate(target_crate, None);\n+                return;\n+            };\n+            for path in paths {\n+                if let Some(name) = path.as_ident() {\n+                    single_imports.push(name.clone());\n+                }\n+            }\n+        }\n+\n+        self.def_collector.import_macros_from_extern_crate(target_crate, Some(single_imports));\n+    }\n+\n     fn collect_module(&mut self, module_id: FileItemTreeId<Mod>, attrs: &Attrs) {\n         let path_attr = attrs.by_key(\"path\").string_value();\n         let is_macro_use = attrs.by_key(\"macro_use\").exists();\n@@ -1844,7 +1922,6 @@ impl ModCollector<'_, '_> {\n         let vis = def_map\n             .resolve_visibility(self.def_collector.db, self.module_id, visibility, false)\n             .unwrap_or(Visibility::Public);\n-        let modules = &mut def_map.modules;\n         let origin = match definition {\n             None => ModuleOrigin::Inline {\n                 definition: declaration,\n@@ -1858,6 +1935,7 @@ impl ModCollector<'_, '_> {\n             },\n         };\n \n+        let modules = &mut def_map.modules;\n         let res = modules.alloc(ModuleData::new(origin, vis));\n         modules[res].parent = Some(self.module_id);\n         for (name, mac) in modules[self.module_id].scope.collect_legacy_macros() {\n@@ -1919,7 +1997,10 @@ impl ModCollector<'_, '_> {\n             if self.def_collector.def_map.is_builtin_or_registered_attr(&attr.path) {\n                 continue;\n             }\n-            tracing::debug!(\"non-builtin attribute {}\", attr.path);\n+            tracing::debug!(\n+                \"non-builtin attribute {}\",\n+                attr.path.display(self.def_collector.db.upcast())\n+            );\n \n             let ast_id = AstIdWithPath::new(\n                 self.file_id(),\n@@ -2053,8 +2134,8 @@ impl ModCollector<'_, '_> {\n                         stdx::always!(\n                             name == mac.name,\n                             \"built-in macro {} has #[rustc_builtin_macro] which declares different name {}\",\n-                            mac.name,\n-                            name\n+                            mac.name.display(self.def_collector.db.upcast()),\n+                            name.display(self.def_collector.db.upcast())\n                         );\n                         helpers_opt = Some(helpers);\n                     }\n@@ -2089,73 +2170,60 @@ impl ModCollector<'_, '_> {\n             &self.item_tree[mac.visibility],\n         );\n         if let Some(helpers) = helpers_opt {\n-            self.def_collector\n-                .def_map\n-                .exported_derives\n-                .insert(macro_id_to_def_id(self.def_collector.db, macro_id.into()), helpers);\n+            if self.def_collector.def_map.block.is_none() {\n+                Arc::get_mut(&mut self.def_collector.def_map.data)\n+                    .unwrap()\n+                    .exported_derives\n+                    .insert(macro_id_to_def_id(self.def_collector.db, macro_id.into()), helpers);\n+            }\n         }\n     }\n \n     fn collect_macro_call(&mut self, mac: &MacroCall, container: ItemContainerId) {\n         let ast_id = AstIdWithPath::new(self.file_id(), mac.ast_id, ModPath::clone(&mac.path));\n+        let db = self.def_collector.db;\n+\n+        // FIXME: Immediately expanding in \"Case 1\" is insufficient since \"Case 2\" may also define\n+        // new legacy macros that create textual scopes. We need a way to resolve names in textual\n+        // scopes without eager expansion.\n \n-        // Case 1: try to resolve in legacy scope and expand macro_rules\n-        let mut error = None;\n-        match macro_call_as_call_id(\n-            self.def_collector.db,\n+        // Case 1: try to resolve macro calls with single-segment name and expand macro_rules\n+        if let Ok(res) = macro_call_as_call_id(\n+            db.upcast(),\n             &ast_id,\n             mac.expand_to,\n             self.def_collector.def_map.krate,\n             |path| {\n                 path.as_ident().and_then(|name| {\n-                    self.def_collector.def_map.with_ancestor_maps(\n-                        self.def_collector.db,\n-                        self.module_id,\n-                        &mut |map, module| {\n-                            map[module]\n-                                .scope\n-                                .get_legacy_macro(name)\n-                                .and_then(|it| it.last())\n-                                .map(|&it| macro_id_to_def_id(self.def_collector.db, it))\n-                        },\n-                    )\n+                    let def_map = &self.def_collector.def_map;\n+                    def_map\n+                        .with_ancestor_maps(db, self.module_id, &mut |map, module| {\n+                            map[module].scope.get_legacy_macro(name)?.last().copied()\n+                        })\n+                        .or_else(|| def_map[self.module_id].scope.get(name).take_macros())\n+                        .or_else(|| def_map.macro_use_prelude.get(name).copied())\n+                        .filter(|&id| {\n+                            sub_namespace_match(\n+                                Some(MacroSubNs::from_id(db, id)),\n+                                Some(MacroSubNs::Bang),\n+                            )\n+                        })\n+                        .map(|it| macro_id_to_def_id(self.def_collector.db, it))\n                 })\n             },\n-            &mut |err| {\n-                error.get_or_insert(err);\n-            },\n         ) {\n-            Ok(Ok(macro_call_id)) => {\n-                // Legacy macros need to be expanded immediately, so that any macros they produce\n-                // are in scope.\n+            // Legacy macros need to be expanded immediately, so that any macros they produce\n+            // are in scope.\n+            if let Some(val) = res {\n                 self.def_collector.collect_macro_expansion(\n                     self.module_id,\n-                    macro_call_id,\n+                    val,\n                     self.macro_depth + 1,\n                     container,\n                 );\n-\n-                if let Some(err) = error {\n-                    self.def_collector.def_map.diagnostics.push(DefDiagnostic::macro_error(\n-                        self.module_id,\n-                        MacroCallKind::FnLike { ast_id: ast_id.ast_id, expand_to: mac.expand_to },\n-                        err.to_string(),\n-                    ));\n-                }\n-\n-                return;\n             }\n-            Ok(Err(_)) => {\n-                // Built-in macro failed eager expansion.\n \n-                self.def_collector.def_map.diagnostics.push(DefDiagnostic::macro_error(\n-                    self.module_id,\n-                    MacroCallKind::FnLike { ast_id: ast_id.ast_id, expand_to: mac.expand_to },\n-                    error.unwrap().to_string(),\n-                ));\n-                return;\n-            }\n-            Err(UnresolvedMacro { .. }) => (),\n+            return;\n         }\n \n         // Case 2: resolve in module scope, expand during name resolution.\n@@ -2215,10 +2283,11 @@ mod tests {\n             unresolved_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n             cfg_options: &CfgOptions::default(),\n-            proc_macros: Default::default(),\n+            proc_macros: Ok(vec![]),\n             from_glob_import: Default::default(),\n             skip_attrs: Default::default(),\n             is_proc_macro: false,\n+            hygienes: FxHashMap::default(),\n         };\n         collector.seed_with_top_level();\n         collector.collect();"}, {"sha": "18b424255cd6bc3fbe0fd5cc92414d0db0e59664", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -4,7 +4,10 @@ use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use hir_expand::{attrs::AttrId, MacroCallKind};\n use la_arena::Idx;\n-use syntax::ast::{self, AnyHasAttrs};\n+use syntax::{\n+    ast::{self, AnyHasAttrs},\n+    SyntaxError,\n+};\n \n use crate::{\n     item_tree::{self, ItemTreeId},\n@@ -29,11 +32,15 @@ pub enum DefDiagnosticKind {\n \n     MacroError { ast: MacroCallKind, message: String },\n \n+    MacroExpansionParseError { ast: MacroCallKind, errors: Box<[SyntaxError]> },\n+\n     UnimplementedBuiltinMacro { ast: AstId<ast::Macro> },\n \n     InvalidDeriveTarget { ast: AstId<ast::Item>, id: usize },\n \n     MalformedDerive { ast: AstId<ast::Adt>, id: usize },\n+\n+    MacroDefError { ast: AstId<ast::Macro>, message: String },\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -81,23 +88,39 @@ impl DefDiagnostic {\n         Self { in_module: container, kind: DefDiagnosticKind::UnconfiguredCode { ast, cfg, opts } }\n     }\n \n-    pub(super) fn unresolved_proc_macro(\n+    // FIXME: Whats the difference between this and unresolved_macro_call\n+    pub(crate) fn unresolved_proc_macro(\n         container: LocalModuleId,\n         ast: MacroCallKind,\n         krate: CrateId,\n     ) -> Self {\n         Self { in_module: container, kind: DefDiagnosticKind::UnresolvedProcMacro { ast, krate } }\n     }\n \n-    pub(super) fn macro_error(\n+    pub(crate) fn macro_error(\n         container: LocalModuleId,\n         ast: MacroCallKind,\n         message: String,\n     ) -> Self {\n         Self { in_module: container, kind: DefDiagnosticKind::MacroError { ast, message } }\n     }\n \n-    pub(super) fn unresolved_macro_call(\n+    pub(crate) fn macro_expansion_parse_error(\n+        container: LocalModuleId,\n+        ast: MacroCallKind,\n+        errors: &[SyntaxError],\n+    ) -> Self {\n+        Self {\n+            in_module: container,\n+            kind: DefDiagnosticKind::MacroExpansionParseError {\n+                ast,\n+                errors: errors.to_vec().into_boxed_slice(),\n+            },\n+        }\n+    }\n+\n+    // FIXME: Whats the difference between this and unresolved_proc_macro\n+    pub(crate) fn unresolved_macro_call(\n         container: LocalModuleId,\n         ast: MacroCallKind,\n         path: ModPath,"}, {"sha": "2dcc2c30fe1698792b15deecb94b1119e2ba34e3", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -74,12 +74,20 @@ impl ModDir {\n                 candidate_files.push(self.dir_path.join_attr(attr_path, self.root_non_dir_owner))\n             }\n             None if file_id.is_include_macro(db.upcast()) => {\n-                candidate_files.push(format!(\"{name}.rs\"));\n-                candidate_files.push(format!(\"{name}/mod.rs\"));\n+                candidate_files.push(format!(\"{}.rs\", name.display(db.upcast())));\n+                candidate_files.push(format!(\"{}/mod.rs\", name.display(db.upcast())));\n             }\n             None => {\n-                candidate_files.push(format!(\"{}{name}.rs\", self.dir_path.0));\n-                candidate_files.push(format!(\"{}{name}/mod.rs\", self.dir_path.0));\n+                candidate_files.push(format!(\n+                    \"{}{}.rs\",\n+                    self.dir_path.0,\n+                    name.display(db.upcast())\n+                ));\n+                candidate_files.push(format!(\n+                    \"{}{}/mod.rs\",\n+                    self.dir_path.0,\n+                    name.display(db.upcast())\n+                ));\n             }\n         };\n \n@@ -91,7 +99,7 @@ impl ModDir {\n                 let (dir_path, root_non_dir_owner) = if is_mod_rs || attr_path.is_some() {\n                     (DirPath::empty(), false)\n                 } else {\n-                    (DirPath::new(format!(\"{name}/\")), true)\n+                    (DirPath::new(format!(\"{}/\", name.display(db.upcast()))), true)\n                 };\n                 if let Some(mod_dir) = self.child(dir_path, root_non_dir_owner) {\n                     return Ok((file_id, is_mod_rs, mod_dir));"}, {"sha": "5f6163175a7268120097fcf81ba870b4f217d4a9", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 97, "deletions": 44, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -16,11 +16,11 @@ use hir_expand::name::Name;\n use crate::{\n     db::DefDatabase,\n     item_scope::BUILTIN_SCOPE,\n-    nameres::{BuiltinShadowMode, DefMap},\n+    nameres::{sub_namespace_match, BuiltinShadowMode, DefMap, MacroSubNs},\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n-    AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n+    AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -58,18 +58,22 @@ impl ResolvePathResult {\n     }\n }\n \n-impl DefMap {\n-    pub(super) fn resolve_name_in_extern_prelude(\n-        &self,\n+impl PerNs {\n+    pub(super) fn filter_macro(\n+        mut self,\n         db: &dyn DefDatabase,\n-        name: &Name,\n-    ) -> Option<ModuleId> {\n-        match self.block {\n-            Some(_) => self.crate_root(db).def_map(db).extern_prelude.get(name).copied(),\n-            None => self.extern_prelude.get(name).copied(),\n-        }\n+        expected: Option<MacroSubNs>,\n+    ) -> Self {\n+        self.macros = self.macros.filter(|&(id, _)| {\n+            let this = MacroSubNs::from_id(db, id);\n+            sub_namespace_match(Some(this), expected)\n+        });\n+\n+        self\n     }\n+}\n \n+impl DefMap {\n     pub(crate) fn resolve_visibility(\n         &self,\n         db: &dyn DefDatabase,\n@@ -83,7 +87,7 @@ impl DefMap {\n         let mut vis = match visibility {\n             RawVisibility::Module(path) => {\n                 let (result, remaining) =\n-                    self.resolve_path(db, original_module, path, BuiltinShadowMode::Module);\n+                    self.resolve_path(db, original_module, path, BuiltinShadowMode::Module, None);\n                 if remaining.is_some() {\n                     return None;\n                 }\n@@ -106,7 +110,7 @@ impl DefMap {\n             // ...unless we're resolving visibility for an associated item in an impl.\n             if self.block_id() != m.block && !within_impl {\n                 cov_mark::hit!(adjust_vis_in_block_def_map);\n-                vis = Visibility::Module(self.module_id(self.root()));\n+                vis = Visibility::Module(self.module_id(Self::ROOT));\n                 tracing::debug!(\"visibility {:?} points outside DefMap, adjusting to {:?}\", m, vis);\n             }\n         }\n@@ -124,6 +128,9 @@ impl DefMap {\n         mut original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n+        // Pass `MacroSubNs` if we know we're resolving macro names and which kind of macro we're\n+        // resolving them to. Pass `None` otherwise, e.g. when we're resolving import paths.\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> ResolvePathResult {\n         let mut result = ResolvePathResult::empty(ReachedFixedPoint::No);\n \n@@ -136,6 +143,7 @@ impl DefMap {\n                 original_module,\n                 path,\n                 shadow,\n+                expected_macro_subns,\n             );\n \n             // Merge `new` into `result`.\n@@ -154,7 +162,7 @@ impl DefMap {\n             match &current_map.block {\n                 Some(block) => {\n                     original_module = block.parent.local_id;\n-                    arc = block.parent.def_map(db);\n+                    arc = block.parent.def_map(db, current_map.krate);\n                     current_map = &*arc;\n                 }\n                 None => return result,\n@@ -169,33 +177,37 @@ impl DefMap {\n         original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> ResolvePathResult {\n         let graph = db.crate_graph();\n         let _cx = stdx::panic_context::enter(format!(\n-            \"DefMap {:?} crate_name={:?} block={:?} path={path}\",\n-            self.krate, graph[self.krate].display_name, self.block\n+            \"DefMap {:?} crate_name={:?} block={:?} path={}\",\n+            self.krate,\n+            graph[self.krate].display_name,\n+            self.block,\n+            path.display(db.upcast())\n         ));\n \n         let mut segments = path.segments().iter().enumerate();\n         let mut curr_per_ns: PerNs = match path.kind {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n                     cov_mark::hit!(macro_dollar_crate_self);\n-                    PerNs::types(self.crate_root(db).into(), Visibility::Public)\n+                    PerNs::types(self.crate_root().into(), Visibility::Public)\n                 } else {\n                     let def_map = db.crate_def_map(krate);\n-                    let module = def_map.module_id(def_map.root);\n+                    let module = def_map.module_id(Self::ROOT);\n                     cov_mark::hit!(macro_dollar_crate_other);\n                     PerNs::types(module.into(), Visibility::Public)\n                 }\n             }\n-            PathKind::Crate => PerNs::types(self.crate_root(db).into(), Visibility::Public),\n+            PathKind::Crate => PerNs::types(self.crate_root().into(), Visibility::Public),\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n             // FIXME there must be a nicer way to write this condition\n             PathKind::Plain | PathKind::Abs\n-                if self.edition == Edition::Edition2015\n+                if self.data.edition == Edition::Edition2015\n                     && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n             {\n                 let (_, segment) = match segments.next() {\n@@ -220,7 +232,13 @@ impl DefMap {\n                     if path.segments().len() == 1 { shadow } else { BuiltinShadowMode::Module };\n \n                 tracing::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, segment, prefer_module)\n+                self.resolve_name_in_module(\n+                    db,\n+                    original_module,\n+                    segment,\n+                    prefer_module,\n+                    expected_macro_subns,\n+                )\n             }\n             PathKind::Super(lvl) => {\n                 let mut module = original_module;\n@@ -236,16 +254,20 @@ impl DefMap {\n                                 );\n                                 tracing::debug!(\n                                     \"`super` path: {} -> {} in parent map\",\n-                                    path,\n-                                    new_path\n-                                );\n-                                return block.parent.def_map(db).resolve_path_fp_with_macro(\n-                                    db,\n-                                    mode,\n-                                    block.parent.local_id,\n-                                    &new_path,\n-                                    shadow,\n+                                    path.display(db.upcast()),\n+                                    new_path.display(db.upcast())\n                                 );\n+                                return block\n+                                    .parent\n+                                    .def_map(db, self.krate)\n+                                    .resolve_path_fp_with_macro(\n+                                        db,\n+                                        mode,\n+                                        block.parent.local_id,\n+                                        &new_path,\n+                                        shadow,\n+                                        expected_macro_subns,\n+                                    );\n                             }\n                             None => {\n                                 tracing::debug!(\"super path in root module\");\n@@ -271,7 +293,7 @@ impl DefMap {\n                     Some((_, segment)) => segment,\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n-                if let Some(&def) = self.extern_prelude.get(segment) {\n+                if let Some(&def) = self.data.extern_prelude.get(segment) {\n                     tracing::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n                     PerNs::types(def.into(), Visibility::Public)\n                 } else {\n@@ -303,7 +325,12 @@ impl DefMap {\n                         );\n                         tracing::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = module.def_map(db);\n-                        let (def, s) = defp_map.resolve_path(db, module.local_id, &path, shadow);\n+                        // Macro sub-namespaces only matter when resolving single-segment paths\n+                        // because `macro_use` and other preludes should be taken into account. At\n+                        // this point, we know we're resolving a multi-segment path so macro kind\n+                        // expectation is discarded.\n+                        let (def, s) =\n+                            defp_map.resolve_path(db, module.local_id, &path, shadow, None);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n@@ -331,11 +358,11 @@ impl DefMap {\n                         Some(local_id) => {\n                             let variant = EnumVariantId { parent: e, local_id };\n                             match &*enum_data.variants[local_id].variant_data {\n-                                crate::adt::VariantData::Record(_) => {\n+                                crate::data::adt::VariantData::Record(_) => {\n                                     PerNs::types(variant.into(), Visibility::Public)\n                                 }\n-                                crate::adt::VariantData::Tuple(_)\n-                                | crate::adt::VariantData::Unit => {\n+                                crate::data::adt::VariantData::Tuple(_)\n+                                | crate::data::adt::VariantData::Unit => {\n                                     PerNs::both(variant.into(), variant.into(), Visibility::Public)\n                                 }\n                             }\n@@ -381,19 +408,24 @@ impl DefMap {\n         module: LocalModuleId,\n         name: &Name,\n         shadow: BuiltinShadowMode,\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> PerNs {\n         // Resolve in:\n         //  - legacy scope of macro\n         //  - current module / scope\n-        //  - extern prelude\n+        //  - extern prelude / macro_use prelude\n         //  - std prelude\n         let from_legacy_macro = self[module]\n             .scope\n             .get_legacy_macro(name)\n             // FIXME: shadowing\n             .and_then(|it| it.last())\n-            .map_or_else(PerNs::none, |&m| PerNs::macros(m, Visibility::Public));\n-        let from_scope = self[module].scope.get(name);\n+            .copied()\n+            .filter(|&id| {\n+                sub_namespace_match(Some(MacroSubNs::from_id(db, id)), expected_macro_subns)\n+            })\n+            .map_or_else(PerNs::none, |m| PerNs::macros(m, Visibility::Public));\n+        let from_scope = self[module].scope.get(name).filter_macro(db, expected_macro_subns);\n         let from_builtin = match self.block {\n             Some(_) => {\n                 // Only resolve to builtins in the root `DefMap`.\n@@ -410,13 +442,27 @@ impl DefMap {\n         };\n \n         let extern_prelude = || {\n-            self.extern_prelude\n+            if self.block.is_some() {\n+                // Don't resolve extern prelude in block `DefMap`s.\n+                return PerNs::none();\n+            }\n+            self.data\n+                .extern_prelude\n                 .get(name)\n                 .map_or(PerNs::none(), |&it| PerNs::types(it.into(), Visibility::Public))\n         };\n+        let macro_use_prelude = || {\n+            self.macro_use_prelude\n+                .get(name)\n+                .map_or(PerNs::none(), |&it| PerNs::macros(it.into(), Visibility::Public))\n+        };\n         let prelude = || self.resolve_in_prelude(db, name);\n \n-        from_legacy_macro.or(from_scope_or_builtin).or_else(extern_prelude).or_else(prelude)\n+        from_legacy_macro\n+            .or(from_scope_or_builtin)\n+            .or_else(extern_prelude)\n+            .or_else(macro_use_prelude)\n+            .or_else(prelude)\n     }\n \n     fn resolve_name_in_crate_root_or_extern_prelude(\n@@ -426,13 +472,20 @@ impl DefMap {\n     ) -> PerNs {\n         let from_crate_root = match self.block {\n             Some(_) => {\n-                let def_map = self.crate_root(db).def_map(db);\n-                def_map[def_map.root].scope.get(name)\n+                let def_map = self.crate_root().def_map(db);\n+                def_map[Self::ROOT].scope.get(name)\n             }\n-            None => self[self.root].scope.get(name),\n+            None => self[Self::ROOT].scope.get(name),\n         };\n         let from_extern_prelude = || {\n-            self.resolve_name_in_extern_prelude(db, name)\n+            if self.block.is_some() {\n+                // Don't resolve extern prelude in block `DefMap`s.\n+                return PerNs::none();\n+            }\n+            self.data\n+                .extern_prelude\n+                .get(name)\n+                .copied()\n                 .map_or(PerNs::none(), |it| PerNs::types(it.into(), Visibility::Public))\n         };\n "}, {"sha": "751b7beaac1538a089e3715da344f440c493cd5f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -52,7 +52,7 @@ impl Attrs {\n }\n \n // This fn is intended for `#[proc_macro_derive(..)]` and `#[rustc_builtin_macro(..)]`, which have\n-// the same strucuture.\n+// the same structure.\n #[rustfmt::skip]\n pub(crate) fn parse_macro_name_and_helper_attrs(tt: &[TokenTree]) -> Option<(Name, Box<[Name]>)> {\n     match tt {"}, {"sha": "dd7c3c36306238a21cbf024bb38a38762ac068c8", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -4,10 +4,9 @@ mod macros;\n mod mod_resolution;\n mod primitives;\n \n-use std::sync::Arc;\n-\n use base_db::{fixture::WithFixture, SourceDatabase};\n use expect_test::{expect, Expect};\n+use triomphe::Arc;\n \n use crate::{db::DefDatabase, test_db::TestDB};\n "}, {"sha": "4931c36bbca92d0eab71ac71ce91b3f30f5fbd99", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,8 +1,7 @@\n-use std::sync::Arc;\n-\n use base_db::SourceDatabaseExt;\n+use triomphe::Arc;\n \n-use crate::{AdtId, ModuleDefId};\n+use crate::{db::DefDatabase, AdtId, ModuleDefId};\n \n use super::*;\n \n@@ -15,7 +14,7 @@ fn check_def_map_is_not_recomputed(ra_fixture_initial: &str, ra_fixture_change:\n         });\n         assert!(format!(\"{events:?}\").contains(\"crate_def_map\"), \"{events:#?}\")\n     }\n-    db.set_file_text(pos.file_id, Arc::new(ra_fixture_change.to_string()));\n+    db.set_file_text(pos.file_id, Arc::from(ra_fixture_change));\n \n     {\n         let events = db.log_executed(|| {\n@@ -96,7 +95,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         });\n         assert!(format!(\"{events:?}\").contains(\"crate_def_map\"), \"{events:#?}\")\n     }\n-    db.set_file_text(pos.file_id, Arc::new(\"m!(Y);\".to_string()));\n+    db.set_file_text(pos.file_id, Arc::from(\"m!(Y);\"));\n \n     {\n         let events = db.log_executed(|| {\n@@ -109,7 +108,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n }\n \n #[test]\n-fn typing_inside_a_function_should_not_invalidate_expansions() {\n+fn typing_inside_a_function_should_not_invalidate_item_expansions() {\n     let (mut db, pos) = TestDB::with_position(\n         r#\"\n //- /lib.rs\n@@ -140,7 +139,7 @@ m!(Z);\n         let n_recalculated_item_trees = events.iter().filter(|it| it.contains(\"item_tree\")).count();\n         assert_eq!(n_recalculated_item_trees, 6);\n         let n_reparsed_macros =\n-            events.iter().filter(|it| it.contains(\"parse_macro_expansion\")).count();\n+            events.iter().filter(|it| it.contains(\"parse_macro_expansion(\")).count();\n         assert_eq!(n_reparsed_macros, 3);\n     }\n \n@@ -150,7 +149,7 @@ fn quux() { 92 }\n m!(Y);\n m!(Z);\n \"#;\n-    db.set_file_text(pos.file_id, Arc::new(new_text.to_string()));\n+    db.set_file_text(pos.file_id, Arc::from(new_text));\n \n     {\n         let events = db.log_executed(|| {\n@@ -161,7 +160,7 @@ m!(Z);\n         let n_recalculated_item_trees = events.iter().filter(|it| it.contains(\"item_tree\")).count();\n         assert_eq!(n_recalculated_item_trees, 1);\n         let n_reparsed_macros =\n-            events.iter().filter(|it| it.contains(\"parse_macro_expansion\")).count();\n+            events.iter().filter(|it| it.contains(\"parse_macro_expansion(\")).count();\n         assert_eq!(n_reparsed_macros, 0);\n     }\n }"}, {"sha": "f4cca8d68d0ac71ac3ddf7d7f21209b2be6c9367", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 241, "deletions": 15, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -259,6 +259,72 @@ mod priv_mod {\n     );\n }\n \n+#[test]\n+fn macro_use_filter() {\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:empty,multiple,all\n+#[macro_use()]\n+extern crate empty;\n+\n+foo_not_imported!();\n+\n+#[macro_use(bar1)]\n+#[macro_use()]\n+#[macro_use(bar2, bar3)]\n+extern crate multiple;\n+\n+bar1!();\n+bar2!();\n+bar3!();\n+bar_not_imported!();\n+\n+#[macro_use(baz1)]\n+#[macro_use]\n+#[macro_use(baz2)]\n+extern crate all;\n+\n+baz1!();\n+baz2!();\n+baz3!();\n+\n+//- /empty.rs crate:empty\n+#[macro_export]\n+macro_rules! foo_not_imported { () => { struct NotOkFoo; } }\n+\n+//- /multiple.rs crate:multiple\n+#[macro_export]\n+macro_rules! bar1 { () => { struct OkBar1; } }\n+#[macro_export]\n+macro_rules! bar2 { () => { struct OkBar2; } }\n+#[macro_export]\n+macro_rules! bar3 { () => { struct OkBar3; } }\n+#[macro_export]\n+macro_rules! bar_not_imported { () => { struct NotOkBar; } }\n+\n+//- /all.rs crate:all\n+#[macro_export]\n+macro_rules! baz1 { () => { struct OkBaz1; } }\n+#[macro_export]\n+macro_rules! baz2 { () => { struct OkBaz2; } }\n+#[macro_export]\n+macro_rules! baz3 { () => { struct OkBaz3; } }\n+\"#,\n+        expect![[r#\"\n+            crate\n+            OkBar1: t v\n+            OkBar2: t v\n+            OkBar3: t v\n+            OkBaz1: t v\n+            OkBaz2: t v\n+            OkBaz3: t v\n+            all: t\n+            empty: t\n+            multiple: t\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn prelude_is_macro_use() {\n     cov_mark::check!(prelude_is_macro_use);\n@@ -664,6 +730,29 @@ pub struct bar;\n     );\n }\n \n+#[test]\n+fn macro_dollar_crate_is_correct_in_derive_meta() {\n+    let map = compute_crate_def_map(\n+        r#\"\n+//- minicore: derive, clone\n+//- /main.rs crate:main deps:lib\n+lib::foo!();\n+\n+//- /lib.rs crate:lib\n+#[macro_export]\n+macro_rules! foo {\n+    () => {\n+        #[derive($crate::Clone)]\n+        struct S;\n+    }\n+}\n+\n+pub use core::clone::Clone;\n+\"#,\n+    );\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 1);\n+}\n+\n #[test]\n fn expand_derive() {\n     let map = compute_crate_def_map(\n@@ -683,7 +772,7 @@ pub macro Copy {}\n pub macro Clone {}\n \"#,\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 2);\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 2);\n }\n \n #[test]\n@@ -726,7 +815,7 @@ pub macro derive($item:item) {}\n pub macro Clone {}\n \"#,\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 1);\n }\n \n #[test]\n@@ -991,7 +1080,7 @@ macro_rules! mbe {\n \n #[test]\n fn collects_derive_helpers() {\n-    let def_map = compute_crate_def_map(\n+    let db = TestDB::with_files(\n         r#\"\n #![crate_type=\"proc-macro\"]\n struct TokenStream;\n@@ -1002,11 +1091,13 @@ pub fn derive_macro_2(_item: TokenStream) -> TokenStream {\n }\n \"#,\n     );\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let def_map = db.crate_def_map(krate);\n \n-    assert_eq!(def_map.exported_derives.len(), 1);\n-    match def_map.exported_derives.values().next() {\n+    assert_eq!(def_map.data.exported_derives.len(), 1);\n+    match def_map.data.exported_derives.values().next() {\n         Some(helpers) => match &**helpers {\n-            [attr] => assert_eq!(attr.to_string(), \"helper_attr\"),\n+            [attr] => assert_eq!(attr.display(&db).to_string(), \"helper_attr\"),\n             _ => unreachable!(),\n         },\n         _ => unreachable!(),\n@@ -1169,7 +1260,7 @@ struct A;\n \n #[test]\n fn macro_use_imports_all_macro_types() {\n-    let def_map = compute_crate_def_map(\n+    let db = TestDB::with_files(\n         r#\"\n //- /main.rs crate:main deps:lib\n #[macro_use]\n@@ -1192,18 +1283,153 @@ struct TokenStream;\n fn proc_attr(a: TokenStream, b: TokenStream) -> TokenStream { a }\n     \"#,\n     );\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let def_map = db.crate_def_map(krate);\n+\n+    let root_module = &def_map[DefMap::ROOT].scope;\n+    assert!(\n+        root_module.legacy_macros().count() == 0,\n+        \"`#[macro_use]` shouldn't bring macros into textual macro scope\",\n+    );\n \n-    let root = &def_map[def_map.root()].scope;\n-    let actual = root\n-        .legacy_macros()\n-        .sorted_by(|a, b| std::cmp::Ord::cmp(&a.0, &b.0))\n-        .map(|(name, _)| format!(\"{name}\\n\"))\n-        .collect::<String>();\n+    let actual = def_map\n+        .macro_use_prelude\n+        .iter()\n+        .map(|(name, _)| name.display(&db).to_string())\n+        .sorted()\n+        .join(\"\\n\");\n \n     expect![[r#\"\n         legacy\n         macro20\n-        proc_attr\n-    \"#]]\n+        proc_attr\"#]]\n     .assert_eq(&actual);\n }\n+\n+#[test]\n+fn non_prelude_macros_take_precedence_over_macro_use_prelude() {\n+    check(\n+        r#\"\n+//- /lib.rs edition:2021 crate:lib deps:dep,core\n+#[macro_use]\n+extern crate dep;\n+\n+macro foo() { struct Ok; }\n+macro bar() { fn ok() {} }\n+\n+foo!();\n+bar!();\n+\n+//- /dep.rs crate:dep\n+#[macro_export]\n+macro_rules! foo {\n+    () => { struct NotOk; }\n+}\n+\n+//- /core.rs crate:core\n+pub mod prelude {\n+    pub mod rust_2021 {\n+        #[macro_export]\n+        macro_rules! bar {\n+            () => { fn not_ok() {} }\n+        }\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            crate\n+            Ok: t v\n+            bar: m\n+            dep: t\n+            foo: m\n+            ok: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macro_use_prelude_is_eagerly_expanded() {\n+    // See FIXME in `ModCollector::collect_macro_call()`.\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:lib\n+#[macro_use]\n+extern crate lib;\n+mk_foo!();\n+mod a {\n+    foo!();\n+}\n+//- /lib.rs crate:lib\n+#[macro_export]\n+macro_rules! mk_foo {\n+    () => {\n+        macro_rules! foo {\n+            () => { struct Ok; }\n+        }\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+        crate\n+        a: t\n+        lib: t\n+\n+        crate::a\n+        Ok: t v\n+    \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macro_sub_namespace() {\n+    let map = compute_crate_def_map(\n+        r#\"\n+//- minicore: derive, clone\n+macro_rules! Clone { () => {} }\n+macro_rules! derive { () => {} }\n+\n+#[derive(Clone)]\n+struct S;\n+    \"#,\n+    );\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 1);\n+}\n+\n+#[test]\n+fn macro_sub_namespace2() {\n+    check(\n+        r#\"\n+//- /main.rs edition:2021 crate:main deps:proc,core\n+use proc::{foo, bar};\n+\n+foo!();\n+bar!();\n+\n+//- /proc.rs crate:proc\n+#![crate_type=\"proc-macro\"]\n+#[proc_macro_derive(foo)]\n+pub fn foo() {}\n+#[proc_macro_attribute]\n+pub fn bar() {}\n+\n+//- /core.rs crate:core\n+pub mod prelude {\n+    pub mod rust_2021 {\n+        pub macro foo() {\n+            struct Ok;\n+        }\n+        pub macro bar() {\n+            fn ok() {}\n+        }\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+            crate\n+            Ok: t v\n+            bar: m\n+            foo: m\n+            ok: v\n+        \"#]],\n+    );\n+}"}, {"sha": "81bc0ff91e3a7643528a0190393c3b8527366960", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -887,7 +887,7 @@ mod module;\n //- /module.rs\n #![cfg(NEVER)]\n \n-struct AlsoShoulntAppear;\n+struct AlsoShouldNotAppear;\n         \"#,\n         expect![[r#\"\n             crate"}, {"sha": "b9b8082549718cbca6417be87961447fef8e7c7e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path.rs", "status": "modified", "additions": 60, "deletions": 29, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -7,15 +7,14 @@ use std::{\n };\n \n use crate::{\n-    body::LowerCtx,\n-    type_ref::{ConstRefOrPath, LifetimeRef},\n+    lang_item::LangItemTarget,\n+    lower::LowerCtx,\n+    type_ref::{ConstRefOrPath, LifetimeRef, TypeBound, TypeRef},\n };\n use hir_expand::name::Name;\n use intern::Interned;\n use syntax::ast;\n \n-use crate::type_ref::{TypeBound, TypeRef};\n-\n pub use hir_expand::mod_path::{path, ModPath, PathKind};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -36,13 +35,19 @@ impl Display for ImportAlias {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Path {\n-    /// Type based path like `<T>::foo`.\n-    /// Note that paths like `<Type as Trait>::foo` are desugared to `Trait::<Self=Type>::foo`.\n-    type_anchor: Option<Interned<TypeRef>>,\n-    mod_path: Interned<ModPath>,\n-    /// Invariant: the same len as `self.mod_path.segments` or `None` if all segments are `None`.\n-    generic_args: Option<Box<[Option<Interned<GenericArgs>>]>>,\n+pub enum Path {\n+    /// A normal path\n+    Normal {\n+        /// Type based path like `<T>::foo`.\n+        /// Note that paths like `<Type as Trait>::foo` are desugared to `Trait::<Self=Type>::foo`.\n+        type_anchor: Option<Interned<TypeRef>>,\n+        mod_path: Interned<ModPath>,\n+        /// Invariant: the same len as `self.mod_path.segments` or `None` if all segments are `None`.\n+        generic_args: Option<Box<[Option<Interned<GenericArgs>>]>>,\n+    },\n+    /// A link to a lang item. It is used in desugaring of things like `x?`. We can show these\n+    /// links via a normal path since they might be private and not accessible in the usage place.\n+    LangItem(LangItemTarget),\n }\n \n /// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n@@ -102,51 +107,77 @@ impl Path {\n     ) -> Path {\n         let generic_args = generic_args.into();\n         assert_eq!(path.len(), generic_args.len());\n-        Path { type_anchor: None, mod_path: Interned::new(path), generic_args: Some(generic_args) }\n+        Path::Normal {\n+            type_anchor: None,\n+            mod_path: Interned::new(path),\n+            generic_args: Some(generic_args),\n+        }\n+    }\n+\n+    /// Converts a known mod path to `Path`.\n+    pub fn from_known_path_with_no_generic(path: ModPath) -> Path {\n+        Path::Normal { type_anchor: None, mod_path: Interned::new(path), generic_args: None }\n     }\n \n     pub fn kind(&self) -> &PathKind {\n-        &self.mod_path.kind\n+        match self {\n+            Path::Normal { mod_path, .. } => &mod_path.kind,\n+            Path::LangItem(_) => &PathKind::Abs,\n+        }\n     }\n \n     pub fn type_anchor(&self) -> Option<&TypeRef> {\n-        self.type_anchor.as_deref()\n+        match self {\n+            Path::Normal { type_anchor, .. } => type_anchor.as_deref(),\n+            Path::LangItem(_) => None,\n+        }\n     }\n \n     pub fn segments(&self) -> PathSegments<'_> {\n-        let s = PathSegments {\n-            segments: self.mod_path.segments(),\n-            generic_args: self.generic_args.as_deref(),\n+        let Path::Normal { mod_path, generic_args, .. } = self else {\n+            return PathSegments {\n+                segments: &[],\n+                generic_args: None,\n+            };\n         };\n+        let s =\n+            PathSegments { segments: mod_path.segments(), generic_args: generic_args.as_deref() };\n         if let Some(generic_args) = s.generic_args {\n             assert_eq!(s.segments.len(), generic_args.len());\n         }\n         s\n     }\n \n-    pub fn mod_path(&self) -> &ModPath {\n-        &self.mod_path\n+    pub fn mod_path(&self) -> Option<&ModPath> {\n+        match self {\n+            Path::Normal { mod_path, .. } => Some(&mod_path),\n+            Path::LangItem(_) => None,\n+        }\n     }\n \n     pub fn qualifier(&self) -> Option<Path> {\n-        if self.mod_path.is_ident() {\n+        let Path::Normal { mod_path, generic_args, type_anchor } = self else {\n+            return None;\n+        };\n+        if mod_path.is_ident() {\n             return None;\n         }\n-        let res = Path {\n-            type_anchor: self.type_anchor.clone(),\n+        let res = Path::Normal {\n+            type_anchor: type_anchor.clone(),\n             mod_path: Interned::new(ModPath::from_segments(\n-                self.mod_path.kind,\n-                self.mod_path.segments()[..self.mod_path.segments().len() - 1].iter().cloned(),\n+                mod_path.kind,\n+                mod_path.segments()[..mod_path.segments().len() - 1].iter().cloned(),\n             )),\n-            generic_args: self.generic_args.as_ref().map(|it| it[..it.len() - 1].to_vec().into()),\n+            generic_args: generic_args.as_ref().map(|it| it[..it.len() - 1].to_vec().into()),\n         };\n         Some(res)\n     }\n \n     pub fn is_self_type(&self) -> bool {\n-        self.type_anchor.is_none()\n-            && self.generic_args.as_deref().is_none()\n-            && self.mod_path.is_Self()\n+        let Path::Normal { mod_path, generic_args, type_anchor } = self else {\n+            return false;\n+        };\n+        type_anchor.is_none() && generic_args.as_deref().is_none() && mod_path.is_Self()\n     }\n }\n \n@@ -222,7 +253,7 @@ impl GenericArgs {\n \n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n-        Path {\n+        Path::Normal {\n             type_anchor: None,\n             mod_path: Interned::new(ModPath::from_segments(PathKind::Plain, iter::once(name))),\n             generic_args: None,"}, {"sha": "26d2706175ca986f0802f44cdaeaa80cf3dc3a4a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -2,17 +2,15 @@\n \n use std::iter;\n \n-use crate::type_ref::ConstRefOrPath;\n+use crate::{lower::LowerCtx, type_ref::ConstRefOrPath};\n \n use either::Either;\n use hir_expand::name::{name, AsName};\n use intern::Interned;\n use syntax::ast::{self, AstNode, HasTypeBounds};\n \n-use super::AssociatedTypeBinding;\n use crate::{\n-    body::LowerCtx,\n-    path::{GenericArg, GenericArgs, ModPath, Path, PathKind},\n+    path::{AssociatedTypeBinding, GenericArg, GenericArgs, ModPath, Path, PathKind},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n };\n \n@@ -75,8 +73,11 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n                     }\n                     // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                     Some(trait_ref) => {\n-                        let Path { mod_path, generic_args: path_generic_args, .. } =\n-                            Path::from_src(trait_ref.path()?, ctx)?;\n+                        let Path::Normal { mod_path, generic_args: path_generic_args, .. } =\n+                            Path::from_src(trait_ref.path()?, ctx)? else\n+                        {\n+                            return None;\n+                        };\n                         let num_segments = mod_path.segments().len();\n                         kind = mod_path.kind;\n \n@@ -157,7 +158,7 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n     }\n \n     let mod_path = Interned::new(ModPath::from_segments(kind, segments));\n-    return Some(Path {\n+    return Some(Path::Normal {\n         type_anchor,\n         mod_path,\n         generic_args: if generic_args.is_empty() { None } else { Some(generic_args.into()) },\n@@ -188,6 +189,10 @@ pub(super) fn lower_generic_args(\n                 args.push(GenericArg::Type(type_ref));\n             }\n             ast::GenericArg::AssocTypeArg(assoc_type_arg) => {\n+                if assoc_type_arg.param_list().is_some() {\n+                    // We currently ignore associated return type bounds.\n+                    continue;\n+                }\n                 if let Some(name_ref) = assoc_type_arg.name_ref() {\n                     let name = name_ref.as_name();\n                     let args = assoc_type_arg"}, {"sha": "0aead6f37f73f4406022d0d6ab2392c38fa69517", "filename": "src/tools/rust-analyzer/crates/hir-def/src/pretty.rs", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt::{self, Write};\n \n-use hir_expand::mod_path::PathKind;\n+use hir_expand::{db::ExpandDatabase, mod_path::PathKind};\n use intern::Interned;\n use itertools::Itertools;\n \n@@ -11,11 +11,14 @@ use crate::{\n     type_ref::{Mutability, TraitBoundModifier, TypeBound, TypeRef},\n };\n \n-pub(crate) fn print_path(path: &Path, buf: &mut dyn Write) -> fmt::Result {\n+pub(crate) fn print_path(db: &dyn ExpandDatabase, path: &Path, buf: &mut dyn Write) -> fmt::Result {\n+    if let Path::LangItem(x) = path {\n+        return write!(buf, \"$lang_item::{x:?}\");\n+    }\n     match path.type_anchor() {\n         Some(anchor) => {\n             write!(buf, \"<\")?;\n-            print_type_ref(anchor, buf)?;\n+            print_type_ref(db, anchor, buf)?;\n             write!(buf, \">::\")?;\n         }\n         None => match path.kind() {\n@@ -41,10 +44,10 @@ pub(crate) fn print_path(path: &Path, buf: &mut dyn Write) -> fmt::Result {\n             write!(buf, \"::\")?;\n         }\n \n-        write!(buf, \"{}\", segment.name)?;\n+        write!(buf, \"{}\", segment.name.display(db))?;\n         if let Some(generics) = segment.args_and_bindings {\n             write!(buf, \"::<\")?;\n-            print_generic_args(generics, buf)?;\n+            print_generic_args(db, generics, buf)?;\n \n             write!(buf, \">\")?;\n         }\n@@ -53,12 +56,16 @@ pub(crate) fn print_path(path: &Path, buf: &mut dyn Write) -> fmt::Result {\n     Ok(())\n }\n \n-pub(crate) fn print_generic_args(generics: &GenericArgs, buf: &mut dyn Write) -> fmt::Result {\n+pub(crate) fn print_generic_args(\n+    db: &dyn ExpandDatabase,\n+    generics: &GenericArgs,\n+    buf: &mut dyn Write,\n+) -> fmt::Result {\n     let mut first = true;\n     let args = if generics.has_self_type {\n         let (self_ty, args) = generics.args.split_first().unwrap();\n         write!(buf, \"Self=\")?;\n-        print_generic_arg(self_ty, buf)?;\n+        print_generic_arg(db, self_ty, buf)?;\n         first = false;\n         args\n     } else {\n@@ -69,35 +76,43 @@ pub(crate) fn print_generic_args(generics: &GenericArgs, buf: &mut dyn Write) ->\n             write!(buf, \", \")?;\n         }\n         first = false;\n-        print_generic_arg(arg, buf)?;\n+        print_generic_arg(db, arg, buf)?;\n     }\n     for binding in generics.bindings.iter() {\n         if !first {\n             write!(buf, \", \")?;\n         }\n         first = false;\n-        write!(buf, \"{}\", binding.name)?;\n+        write!(buf, \"{}\", binding.name.display(db))?;\n         if !binding.bounds.is_empty() {\n             write!(buf, \": \")?;\n-            print_type_bounds(&binding.bounds, buf)?;\n+            print_type_bounds(db, &binding.bounds, buf)?;\n         }\n         if let Some(ty) = &binding.type_ref {\n             write!(buf, \" = \")?;\n-            print_type_ref(ty, buf)?;\n+            print_type_ref(db, ty, buf)?;\n         }\n     }\n     Ok(())\n }\n \n-pub(crate) fn print_generic_arg(arg: &GenericArg, buf: &mut dyn Write) -> fmt::Result {\n+pub(crate) fn print_generic_arg(\n+    db: &dyn ExpandDatabase,\n+    arg: &GenericArg,\n+    buf: &mut dyn Write,\n+) -> fmt::Result {\n     match arg {\n-        GenericArg::Type(ty) => print_type_ref(ty, buf),\n-        GenericArg::Const(c) => write!(buf, \"{c}\"),\n-        GenericArg::Lifetime(lt) => write!(buf, \"{}\", lt.name),\n+        GenericArg::Type(ty) => print_type_ref(db, ty, buf),\n+        GenericArg::Const(c) => write!(buf, \"{}\", c.display(db)),\n+        GenericArg::Lifetime(lt) => write!(buf, \"{}\", lt.name.display(db)),\n     }\n }\n \n-pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Result {\n+pub(crate) fn print_type_ref(\n+    db: &dyn ExpandDatabase,\n+    type_ref: &TypeRef,\n+    buf: &mut dyn Write,\n+) -> fmt::Result {\n     // FIXME: deduplicate with `HirDisplay` impl\n     match type_ref {\n         TypeRef::Never => write!(buf, \"!\")?,\n@@ -108,18 +123,18 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n                 if i != 0 {\n                     write!(buf, \", \")?;\n                 }\n-                print_type_ref(field, buf)?;\n+                print_type_ref(db, field, buf)?;\n             }\n             write!(buf, \")\")?;\n         }\n-        TypeRef::Path(path) => print_path(path, buf)?,\n+        TypeRef::Path(path) => print_path(db, path, buf)?,\n         TypeRef::RawPtr(pointee, mtbl) => {\n             let mtbl = match mtbl {\n                 Mutability::Shared => \"*const\",\n                 Mutability::Mut => \"*mut\",\n             };\n             write!(buf, \"{mtbl} \")?;\n-            print_type_ref(pointee, buf)?;\n+            print_type_ref(db, pointee, buf)?;\n         }\n         TypeRef::Reference(pointee, lt, mtbl) => {\n             let mtbl = match mtbl {\n@@ -128,19 +143,19 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n             };\n             write!(buf, \"&\")?;\n             if let Some(lt) = lt {\n-                write!(buf, \"{} \", lt.name)?;\n+                write!(buf, \"{} \", lt.name.display(db))?;\n             }\n             write!(buf, \"{mtbl}\")?;\n-            print_type_ref(pointee, buf)?;\n+            print_type_ref(db, pointee, buf)?;\n         }\n         TypeRef::Array(elem, len) => {\n             write!(buf, \"[\")?;\n-            print_type_ref(elem, buf)?;\n-            write!(buf, \"; {len}]\")?;\n+            print_type_ref(db, elem, buf)?;\n+            write!(buf, \"; {}]\", len.display(db))?;\n         }\n         TypeRef::Slice(elem) => {\n             write!(buf, \"[\")?;\n-            print_type_ref(elem, buf)?;\n+            print_type_ref(db, elem, buf)?;\n             write!(buf, \"]\")?;\n         }\n         TypeRef::Fn(args_and_ret, varargs, is_unsafe) => {\n@@ -154,7 +169,7 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n                 if i != 0 {\n                     write!(buf, \", \")?;\n                 }\n-                print_type_ref(typeref, buf)?;\n+                print_type_ref(db, typeref, buf)?;\n             }\n             if *varargs {\n                 if !args.is_empty() {\n@@ -163,26 +178,27 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n                 write!(buf, \"...\")?;\n             }\n             write!(buf, \") -> \")?;\n-            print_type_ref(return_type, buf)?;\n+            print_type_ref(db, return_type, buf)?;\n         }\n         TypeRef::Macro(_ast_id) => {\n             write!(buf, \"<macro>\")?;\n         }\n         TypeRef::Error => write!(buf, \"{{unknown}}\")?,\n         TypeRef::ImplTrait(bounds) => {\n             write!(buf, \"impl \")?;\n-            print_type_bounds(bounds, buf)?;\n+            print_type_bounds(db, bounds, buf)?;\n         }\n         TypeRef::DynTrait(bounds) => {\n             write!(buf, \"dyn \")?;\n-            print_type_bounds(bounds, buf)?;\n+            print_type_bounds(db, bounds, buf)?;\n         }\n     }\n \n     Ok(())\n }\n \n pub(crate) fn print_type_bounds(\n+    db: &dyn ExpandDatabase,\n     bounds: &[Interned<TypeBound>],\n     buf: &mut dyn Write,\n ) -> fmt::Result {\n@@ -197,13 +213,13 @@ pub(crate) fn print_type_bounds(\n                     TraitBoundModifier::None => (),\n                     TraitBoundModifier::Maybe => write!(buf, \"?\")?,\n                 }\n-                print_path(path, buf)?;\n+                print_path(db, path, buf)?;\n             }\n             TypeBound::ForLifetime(lifetimes, path) => {\n-                write!(buf, \"for<{}> \", lifetimes.iter().format(\", \"))?;\n-                print_path(path, buf)?;\n+                write!(buf, \"for<{}> \", lifetimes.iter().map(|it| it.display(db)).format(\", \"))?;\n+                print_path(db, path, buf)?;\n             }\n-            TypeBound::Lifetime(lt) => write!(buf, \"{}\", lt.name)?,\n+            TypeBound::Lifetime(lt) => write!(buf, \"{}\", lt.name.display(db))?,\n             TypeBound::Error => write!(buf, \"{{unknown}}\")?,\n         }\n     }"}, {"sha": "06f5b2526a459a1c701efdd3abc7e4a7b16eb31f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/resolver.rs", "status": "modified", "additions": 83, "deletions": 31, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,22 +1,24 @@\n //! Name resolution fa\u00e7ade.\n-use std::{fmt, hash::BuildHasherDefault, sync::Arc};\n+use std::{fmt, hash::BuildHasherDefault};\n \n use base_db::CrateId;\n use hir_expand::name::{name, Name};\n use indexmap::IndexMap;\n use intern::Interned;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n+use triomphe::Arc;\n \n use crate::{\n     body::scope::{ExprScopes, ScopeId},\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n-    expr::{BindingId, ExprId, LabelId},\n     generics::{GenericParams, TypeOrConstParamData},\n+    hir::{BindingId, ExprId, LabelId},\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n-    nameres::DefMap,\n-    path::{ModPath, PathKind},\n+    lang_item::LangItemTarget,\n+    nameres::{DefMap, MacroSubNs},\n+    path::{ModPath, Path, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n     AdtId, AssocItemId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId,\n@@ -78,7 +80,7 @@ enum Scope {\n     ExprScope(ExprScope),\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum TypeNs {\n     SelfType(ImplId),\n     GenericParam(TypeParamId),\n@@ -153,7 +155,8 @@ impl Resolver {\n         path: &ModPath,\n     ) -> Option<PerNs> {\n         let (item_map, module) = self.item_scope();\n-        let (module_res, idx) = item_map.resolve_path(db, module, path, BuiltinShadowMode::Module);\n+        let (module_res, idx) =\n+            item_map.resolve_path(db, module, path, BuiltinShadowMode::Module, None);\n         match module_res.take_types()? {\n             ModuleDefId::TraitId(it) => {\n                 let idx = idx?;\n@@ -176,8 +179,27 @@ impl Resolver {\n     pub fn resolve_path_in_type_ns(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<(TypeNs, Option<usize>)> {\n+        let path = match path {\n+            Path::Normal { mod_path, .. } => mod_path,\n+            Path::LangItem(l) => {\n+                return Some((\n+                    match *l {\n+                        LangItemTarget::Union(x) => TypeNs::AdtId(x.into()),\n+                        LangItemTarget::TypeAlias(x) => TypeNs::TypeAliasId(x),\n+                        LangItemTarget::Struct(x) => TypeNs::AdtId(x.into()),\n+                        LangItemTarget::EnumVariant(x) => TypeNs::EnumVariantId(x),\n+                        LangItemTarget::EnumId(x) => TypeNs::AdtId(x.into()),\n+                        LangItemTarget::Trait(x) => TypeNs::TraitId(x),\n+                        LangItemTarget::Function(_)\n+                        | LangItemTarget::ImplDef(_)\n+                        | LangItemTarget::Static(_) => return None,\n+                    },\n+                    None,\n+                ))\n+            }\n+        };\n         let first_name = path.segments().first()?;\n         let skip_to_mod = path.kind != PathKind::Plain;\n         if skip_to_mod {\n@@ -217,7 +239,7 @@ impl Resolver {\n     pub fn resolve_path_in_type_ns_fully(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<TypeNs> {\n         let (res, unresolved) = self.resolve_path_in_type_ns(db, path)?;\n         if unresolved.is_some() {\n@@ -245,8 +267,24 @@ impl Resolver {\n     pub fn resolve_path_in_value_ns(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<ResolveValueResult> {\n+        let path = match path {\n+            Path::Normal { mod_path, .. } => mod_path,\n+            Path::LangItem(l) => {\n+                return Some(ResolveValueResult::ValueNs(match *l {\n+                    LangItemTarget::Function(x) => ValueNs::FunctionId(x),\n+                    LangItemTarget::Static(x) => ValueNs::StaticId(x),\n+                    LangItemTarget::Struct(x) => ValueNs::StructId(x),\n+                    LangItemTarget::EnumVariant(x) => ValueNs::EnumVariantId(x),\n+                    LangItemTarget::Union(_)\n+                    | LangItemTarget::ImplDef(_)\n+                    | LangItemTarget::TypeAlias(_)\n+                    | LangItemTarget::Trait(_)\n+                    | LangItemTarget::EnumId(_) => return None,\n+                }))\n+            }\n+        };\n         let n_segments = path.segments().len();\n         let tmp = name![self];\n         let first_name = if path.is_self() { &tmp } else { path.segments().first()? };\n@@ -340,17 +378,25 @@ impl Resolver {\n     pub fn resolve_path_in_value_ns_fully(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n             ResolveValueResult::ValueNs(it) => Some(it),\n             ResolveValueResult::Partial(..) => None,\n         }\n     }\n \n-    pub fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n+    pub fn resolve_path_as_macro(\n+        &self,\n+        db: &dyn DefDatabase,\n+        path: &ModPath,\n+        expected_macro_kind: Option<MacroSubNs>,\n+    ) -> Option<MacroId> {\n         let (item_map, module) = self.item_scope();\n-        item_map.resolve_path(db, module, path, BuiltinShadowMode::Other).0.take_macros()\n+        item_map\n+            .resolve_path(db, module, path, BuiltinShadowMode::Other, expected_macro_kind)\n+            .0\n+            .take_macros()\n     }\n \n     /// Returns a set of names available in the current scope.\n@@ -415,7 +461,10 @@ impl Resolver {\n                 res.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(mac)));\n             })\n         });\n-        def_map.extern_prelude().for_each(|(name, &def)| {\n+        def_map.macro_use_prelude().for_each(|(name, def)| {\n+            res.add(name, ScopeDef::ModuleDef(def.into()));\n+        });\n+        def_map.extern_prelude().for_each(|(name, def)| {\n             res.add(name, ScopeDef::ModuleDef(ModuleDefId::ModuleId(def)));\n         });\n         BUILTIN_SCOPE.iter().for_each(|(name, &def)| {\n@@ -441,7 +490,7 @@ impl Resolver {\n                 &Scope::ImplDefScope(impl_) => {\n                     if let Some(target_trait) = &db.impl_data(impl_).target_trait {\n                         if let Some(TypeNs::TraitId(trait_)) =\n-                            self.resolve_path_in_type_ns_fully(db, target_trait.path.mod_path())\n+                            self.resolve_path_in_type_ns_fully(db, &target_trait.path)\n                         {\n                             traits.insert(trait_);\n                         }\n@@ -536,15 +585,13 @@ impl Resolver {\n                 scope_id,\n             }));\n             if let Some(block) = expr_scopes.block(scope_id) {\n-                if let Some(def_map) = db.block_def_map(block) {\n-                    let root = def_map.root();\n-                    resolver\n-                        .scopes\n-                        .push(Scope::BlockScope(ModuleItemMap { def_map, module_id: root }));\n-                    // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n-                    // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n-                    // innermost module scope instead?\n-                }\n+                let def_map = db.block_def_map(block);\n+                resolver\n+                    .scopes\n+                    .push(Scope::BlockScope(ModuleItemMap { def_map, module_id: DefMap::ROOT }));\n+                // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n+                // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n+                // innermost module scope instead?\n             }\n         }\n \n@@ -592,7 +639,8 @@ impl Resolver {\n         shadow: BuiltinShadowMode,\n     ) -> PerNs {\n         let (item_map, module) = self.item_scope();\n-        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow);\n+        // This method resolves `path` just like import paths, so no expected macro subns is given.\n+        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow, None);\n         if segment_index.is_some() {\n             return PerNs::none();\n         }\n@@ -705,13 +753,11 @@ fn resolver_for_scope_(\n \n     for scope in scope_chain.into_iter().rev() {\n         if let Some(block) = scopes.block(scope) {\n-            if let Some(def_map) = db.block_def_map(block) {\n-                let root = def_map.root();\n-                r = r.push_block_scope(def_map, root);\n-                // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n-                // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n-                // innermost module scope instead?\n-            }\n+            let def_map = db.block_def_map(block);\n+            r = r.push_block_scope(def_map, DefMap::ROOT);\n+            // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n+            // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n+            // innermost module scope instead?\n         }\n \n         r = r.push_expr_scope(owner, Arc::clone(&scopes), scope);\n@@ -1000,6 +1046,12 @@ impl HasResolver for GenericDefId {\n     }\n }\n \n+impl HasResolver for EnumVariantId {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n+        self.parent.resolver(db)\n+    }\n+}\n+\n impl HasResolver for VariantId {\n     fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         match self {"}, {"sha": "6047f770d4d3082d4c368bbea154d8078c741718", "filename": "src/tools/rust-analyzer/crates/hir-def/src/src.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fsrc.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -20,7 +20,7 @@ impl<N: ItemTreeNode> HasSource for AssocItemLoc<N> {\n     fn source(&self, db: &dyn DefDatabase) -> InFile<N::Source> {\n         let tree = self.id.item_tree(db);\n         let ast_id_map = db.ast_id_map(self.id.file_id());\n-        let root = db.parse_or_expand(self.id.file_id()).unwrap();\n+        let root = db.parse_or_expand(self.id.file_id());\n         let node = &tree[self.id.value];\n \n         InFile::new(self.id.file_id(), ast_id_map.get(node.ast_id()).to_node(&root))\n@@ -33,7 +33,7 @@ impl<N: ItemTreeNode> HasSource for ItemLoc<N> {\n     fn source(&self, db: &dyn DefDatabase) -> InFile<N::Source> {\n         let tree = self.id.item_tree(db);\n         let ast_id_map = db.ast_id_map(self.id.file_id());\n-        let root = db.parse_or_expand(self.id.file_id()).unwrap();\n+        let root = db.parse_or_expand(self.id.file_id());\n         let node = &tree[self.id.value];\n \n         InFile::new(self.id.file_id(), ast_id_map.get(node.ast_id()).to_node(&root))\n@@ -46,7 +46,7 @@ impl HasSource for Macro2Loc {\n     fn source(&self, db: &dyn DefDatabase) -> InFile<Self::Value> {\n         let tree = self.id.item_tree(db);\n         let ast_id_map = db.ast_id_map(self.id.file_id());\n-        let root = db.parse_or_expand(self.id.file_id()).unwrap();\n+        let root = db.parse_or_expand(self.id.file_id());\n         let node = &tree[self.id.value];\n \n         InFile::new(self.id.file_id(), ast_id_map.get(node.ast_id()).to_node(&root))\n@@ -59,7 +59,7 @@ impl HasSource for MacroRulesLoc {\n     fn source(&self, db: &dyn DefDatabase) -> InFile<Self::Value> {\n         let tree = self.id.item_tree(db);\n         let ast_id_map = db.ast_id_map(self.id.file_id());\n-        let root = db.parse_or_expand(self.id.file_id()).unwrap();\n+        let root = db.parse_or_expand(self.id.file_id());\n         let node = &tree[self.id.value];\n \n         InFile::new(self.id.file_id(), ast_id_map.get(node.ast_id()).to_node(&root))\n@@ -72,7 +72,7 @@ impl HasSource for ProcMacroLoc {\n     fn source(&self, db: &dyn DefDatabase) -> InFile<Self::Value> {\n         let tree = self.id.item_tree(db);\n         let ast_id_map = db.ast_id_map(self.id.file_id());\n-        let root = db.parse_or_expand(self.id.file_id()).unwrap();\n+        let root = db.parse_or_expand(self.id.file_id());\n         let node = &tree[self.id.value];\n \n         InFile::new(self.id.file_id(), ast_id_map.get(node.ast_id()).to_node(&root))"}, {"sha": "a6befc8a81a81bd59e1c8641b755ee46bba4ce23", "filename": "src/tools/rust-analyzer/crates/hir-def/src/test_db.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,17 +1,16 @@\n //! Database used for testing `hir_def`.\n \n-use std::{\n-    fmt, panic,\n-    sync::{Arc, Mutex},\n-};\n+use std::{fmt, panic, sync::Mutex};\n \n use base_db::{\n-    salsa, AnchoredPath, CrateId, FileId, FileLoader, FileLoaderDelegate, FilePosition,\n-    SourceDatabase, Upcast,\n+    salsa::{self, Durability},\n+    AnchoredPath, CrateId, FileId, FileLoader, FileLoaderDelegate, FilePosition, SourceDatabase,\n+    Upcast,\n };\n use hir_expand::{db::ExpandDatabase, InFile};\n-use stdx::hash::NoHashHashSet;\n+use rustc_hash::FxHashSet;\n use syntax::{algo, ast, AstNode};\n+use triomphe::Arc;\n \n use crate::{\n     db::DefDatabase,\n@@ -35,7 +34,7 @@ pub(crate) struct TestDB {\n impl Default for TestDB {\n     fn default() -> Self {\n         let mut this = Self { storage: Default::default(), events: Default::default() };\n-        this.set_enable_proc_attr_macros(true);\n+        this.set_expand_proc_attr_macros_with_durability(true, Durability::HIGH);\n         this\n     }\n }\n@@ -70,13 +69,13 @@ impl fmt::Debug for TestDB {\n impl panic::RefUnwindSafe for TestDB {}\n \n impl FileLoader for TestDB {\n-    fn file_text(&self, file_id: FileId) -> Arc<String> {\n+    fn file_text(&self, file_id: FileId) -> Arc<str> {\n         FileLoaderDelegate(self).file_text(file_id)\n     }\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         FileLoaderDelegate(self).resolve_path(path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n }\n@@ -111,7 +110,7 @@ impl TestDB {\n                 }\n                 _ => {\n                     // FIXME: handle `mod` inside block expression\n-                    return def_map.module_id(def_map.root());\n+                    return def_map.module_id(DefMap::ROOT);\n                 }\n             }\n         }\n@@ -120,7 +119,7 @@ impl TestDB {\n     /// Finds the smallest/innermost module in `def_map` containing `position`.\n     fn mod_at_position(&self, def_map: &DefMap, position: FilePosition) -> LocalModuleId {\n         let mut size = None;\n-        let mut res = def_map.root();\n+        let mut res = DefMap::ROOT;\n         for (module, data) in def_map.modules() {\n             let src = data.definition_source(self);\n             if src.file_id != position.file_id.into() {\n@@ -209,13 +208,11 @@ impl TestDB {\n             });\n \n         for scope in scope_iter {\n-            let containing_blocks =\n+            let mut containing_blocks =\n                 scopes.scope_chain(Some(scope)).filter_map(|scope| scopes.block(scope));\n \n-            for block in containing_blocks {\n-                if let Some(def_map) = self.block_def_map(block) {\n-                    return Some(def_map);\n-                }\n+            if let Some(block) = containing_blocks.next().map(|block| self.block_def_map(block)) {\n+                return Some(block);\n             }\n         }\n "}, {"sha": "30f48de61f2e86bbe51292586240e551b710787c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/visibility.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,10 +1,11 @@\n //! Defines hir-level representation of visibility (e.g. `pub` and `pub(crate)`).\n \n-use std::{iter, sync::Arc};\n+use std::iter;\n \n use hir_expand::{hygiene::Hygiene, InFile};\n use la_arena::ArenaMap;\n use syntax::ast;\n+use triomphe::Arc;\n \n use crate::{\n     db::DefDatabase,"}, {"sha": "40d8659f25bad5458f9225692f7840faba631484", "filename": "src/tools/rust-analyzer/crates/hir-expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -22,6 +22,7 @@ hashbrown = { version = \"0.12.1\", features = [\n     \"inline-more\",\n ], default-features = false }\n smallvec.workspace = true\n+triomphe.workspace = true\n \n # local deps\n stdx.workspace = true"}, {"sha": "400442de94b981b334dd0b135b545caca8eb10eb", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/ast_id_map.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fast_id_map.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -115,6 +115,7 @@ impl AstIdMap {\n                 }\n             }\n         }\n+        res.arena.shrink_to_fit();\n         res\n     }\n \n@@ -123,6 +124,10 @@ impl AstIdMap {\n         FileAstId { raw, _ty: PhantomData }\n     }\n \n+    pub fn get<N: AstNode>(&self, id: FileAstId<N>) -> AstPtr<N> {\n+        AstPtr::try_from_raw(self.arena[id.raw].clone()).unwrap()\n+    }\n+\n     fn erased_ast_id(&self, item: &SyntaxNode) -> ErasedFileAstId {\n         let ptr = SyntaxNodePtr::new(item);\n         let hash = hash_ptr(&ptr);\n@@ -136,10 +141,6 @@ impl AstIdMap {\n         }\n     }\n \n-    pub fn get<N: AstNode>(&self, id: FileAstId<N>) -> AstPtr<N> {\n-        AstPtr::try_from_raw(self.arena[id.raw].clone()).unwrap()\n-    }\n-\n     fn alloc(&mut self, item: &SyntaxNode) -> ErasedFileAstId {\n         self.arena.alloc(SyntaxNodePtr::new(item))\n     }"}, {"sha": "0c369a18bb9cc29f5cd18e43dc68b5597d1a0ae5", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/attrs.rs", "status": "modified", "additions": 85, "deletions": 56, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,5 +1,5 @@\n //! A higher level attributes based on TokenTree, with also some shortcuts.\n-use std::{fmt, ops, sync::Arc};\n+use std::{fmt, ops};\n \n use base_db::CrateId;\n use cfg::CfgExpr;\n@@ -8,19 +8,20 @@ use intern::Interned;\n use mbe::{syntax_node_to_token_tree, DelimiterKind, Punct};\n use smallvec::{smallvec, SmallVec};\n use syntax::{ast, match_ast, AstNode, SmolStr, SyntaxNode};\n+use triomphe::Arc;\n \n use crate::{\n     db::ExpandDatabase,\n     hygiene::Hygiene,\n-    mod_path::{ModPath, PathKind},\n-    name::AsName,\n+    mod_path::ModPath,\n     tt::{self, Subtree},\n     InFile,\n };\n \n /// Syntactical attributes, without filtering of `cfg_attr`s.\n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct RawAttrs {\n+    // FIXME: Make this a ThinArc\n     entries: Option<Arc<[Attr]>>,\n }\n \n@@ -50,7 +51,9 @@ impl RawAttrs {\n                     path: Interned::new(ModPath::from(crate::name!(doc))),\n                 }),\n             })\n-            .collect::<Arc<_>>();\n+            .collect::<Vec<_>>();\n+        // FIXME: use `Arc::from_iter` when it becomes available\n+        let entries: Arc<[Attr]> = Arc::from(entries);\n \n         Self { entries: if entries.is_empty() { None } else { Some(entries) } }\n     }\n@@ -68,7 +71,7 @@ impl RawAttrs {\n             (Some(a), Some(b)) => {\n                 let last_ast_index = a.last().map_or(0, |it| it.id.ast_index() + 1) as u32;\n                 Self {\n-                    entries: Some(\n+                    entries: Some(Arc::from(\n                         a.iter()\n                             .cloned()\n                             .chain(b.iter().map(|it| {\n@@ -78,8 +81,9 @@ impl RawAttrs {\n                                         << AttrId::AST_INDEX_BITS;\n                                 it\n                             }))\n-                            .collect(),\n-                    ),\n+                            // FIXME: use `Arc::from_iter` when it becomes available\n+                            .collect::<Vec<_>>(),\n+                    )),\n                 }\n             }\n         }\n@@ -96,48 +100,51 @@ impl RawAttrs {\n         }\n \n         let crate_graph = db.crate_graph();\n-        let new_attrs = self\n-            .iter()\n-            .flat_map(|attr| -> SmallVec<[_; 1]> {\n-                let is_cfg_attr =\n-                    attr.path.as_ident().map_or(false, |name| *name == crate::name![cfg_attr]);\n-                if !is_cfg_attr {\n-                    return smallvec![attr.clone()];\n-                }\n-\n-                let subtree = match attr.token_tree_value() {\n-                    Some(it) => it,\n-                    _ => return smallvec![attr.clone()],\n-                };\n-\n-                let (cfg, parts) = match parse_cfg_attr_input(subtree) {\n-                    Some(it) => it,\n-                    None => return smallvec![attr.clone()],\n-                };\n-                let index = attr.id;\n-                let attrs =\n-                    parts.enumerate().take(1 << AttrId::CFG_ATTR_BITS).filter_map(|(idx, attr)| {\n-                        let tree = Subtree {\n-                            delimiter: tt::Delimiter::unspecified(),\n-                            token_trees: attr.to_vec(),\n-                        };\n-                        // FIXME hygiene\n-                        let hygiene = Hygiene::new_unhygienic();\n-                        Attr::from_tt(db, &tree, &hygiene, index.with_cfg_attr(idx))\n-                    });\n-\n-                let cfg_options = &crate_graph[krate].cfg_options;\n-                let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n-                let cfg = CfgExpr::parse(&cfg);\n-                if cfg_options.check(&cfg) == Some(false) {\n-                    smallvec![]\n-                } else {\n-                    cov_mark::hit!(cfg_attr_active);\n-\n-                    attrs.collect()\n-                }\n-            })\n-            .collect();\n+        let new_attrs = Arc::from(\n+            self.iter()\n+                .flat_map(|attr| -> SmallVec<[_; 1]> {\n+                    let is_cfg_attr =\n+                        attr.path.as_ident().map_or(false, |name| *name == crate::name![cfg_attr]);\n+                    if !is_cfg_attr {\n+                        return smallvec![attr.clone()];\n+                    }\n+\n+                    let subtree = match attr.token_tree_value() {\n+                        Some(it) => it,\n+                        _ => return smallvec![attr.clone()],\n+                    };\n+\n+                    let (cfg, parts) = match parse_cfg_attr_input(subtree) {\n+                        Some(it) => it,\n+                        None => return smallvec![attr.clone()],\n+                    };\n+                    let index = attr.id;\n+                    let attrs = parts.enumerate().take(1 << AttrId::CFG_ATTR_BITS).filter_map(\n+                        |(idx, attr)| {\n+                            let tree = Subtree {\n+                                delimiter: tt::Delimiter::unspecified(),\n+                                token_trees: attr.to_vec(),\n+                            };\n+                            // FIXME hygiene\n+                            let hygiene = Hygiene::new_unhygienic();\n+                            Attr::from_tt(db, &tree, &hygiene, index.with_cfg_attr(idx))\n+                        },\n+                    );\n+\n+                    let cfg_options = &crate_graph[krate].cfg_options;\n+                    let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n+                    let cfg = CfgExpr::parse(&cfg);\n+                    if cfg_options.check(&cfg) == Some(false) {\n+                        smallvec![]\n+                    } else {\n+                        cov_mark::hit!(cfg_attr_active);\n+\n+                        attrs.collect()\n+                    }\n+                })\n+                // FIXME: use `Arc::from_iter` when it becomes available\n+                .collect::<Vec<_>>(),\n+        );\n \n         RawAttrs { entries: Some(new_attrs) }\n     }\n@@ -266,7 +273,11 @@ impl Attr {\n     }\n \n     /// Parses this attribute as a token tree consisting of comma separated paths.\n-    pub fn parse_path_comma_token_tree(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n+    pub fn parse_path_comma_token_tree<'a>(\n+        &'a self,\n+        db: &'a dyn ExpandDatabase,\n+        hygiene: &'a Hygiene,\n+    ) -> Option<impl Iterator<Item = ModPath> + 'a> {\n         let args = self.token_tree_value()?;\n \n         if args.delimiter.kind != DelimiterKind::Parenthesis {\n@@ -275,19 +286,37 @@ impl Attr {\n         let paths = args\n             .token_trees\n             .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))))\n-            .filter_map(|tts| {\n+            .filter_map(move |tts| {\n                 if tts.is_empty() {\n                     return None;\n                 }\n-                let segments = tts.iter().filter_map(|tt| match tt {\n-                    tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n-                    _ => None,\n-                });\n-                Some(ModPath::from_segments(PathKind::Plain, segments))\n+                // FIXME: This is necessarily a hack. It'd be nice if we could avoid allocation here.\n+                let subtree = tt::Subtree {\n+                    delimiter: tt::Delimiter::unspecified(),\n+                    token_trees: tts.into_iter().cloned().collect(),\n+                };\n+                let (parse, _) =\n+                    mbe::token_tree_to_syntax_node(&subtree, mbe::TopEntryPoint::MetaItem);\n+                let meta = ast::Meta::cast(parse.syntax_node())?;\n+                // Only simple paths are allowed.\n+                if meta.eq_token().is_some() || meta.expr().is_some() || meta.token_tree().is_some()\n+                {\n+                    return None;\n+                }\n+                let path = meta.path()?;\n+                ModPath::from_src(db, path, hygiene)\n             });\n \n         Some(paths)\n     }\n+\n+    pub fn cfg(&self) -> Option<CfgExpr> {\n+        if *self.path.as_ident()? == crate::name![cfg] {\n+            self.token_tree_value().map(CfgExpr::parse)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n pub fn collect_attrs("}, {"sha": "80695bc065621e54c1b6b23e395b38a67c250e04", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -96,7 +96,7 @@ fn derive_attr_expand(\n ) -> ExpandResult<tt::Subtree> {\n     let loc = db.lookup_intern_macro_call(id);\n     let derives = match &loc.kind {\n-        MacroCallKind::Attr { attr_args, is_derive: true, .. } => &attr_args.0,\n+        MacroCallKind::Attr { attr_args, .. } if loc.def.is_attribute_derive() => &attr_args.0,\n         _ => return ExpandResult::ok(tt::Subtree::empty()),\n     };\n     pseudo_derive_attr_expansion(tt, derives)"}, {"sha": "54706943ac4fde2a33f5f189ca283da371dc5167", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 641, "deletions": 40, "changes": 681, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,11 +1,19 @@\n //! Builtin derives.\n \n+use ::tt::Ident;\n use base_db::{CrateOrigin, LangCrateOrigin};\n+use itertools::izip;\n+use mbe::TokenMap;\n+use std::collections::HashSet;\n+use stdx::never;\n use tracing::debug;\n \n use crate::tt::{self, TokenId};\n use syntax::{\n-    ast::{self, AstNode, HasGenericParams, HasModuleItem, HasName},\n+    ast::{\n+        self, AstNode, FieldList, HasAttrs, HasGenericParams, HasModuleItem, HasName,\n+        HasTypeBounds, PathType,\n+    },\n     match_ast,\n };\n \n@@ -58,10 +66,129 @@ pub fn find_builtin_derive(ident: &name::Name) -> Option<BuiltinDeriveExpander>\n     BuiltinDeriveExpander::find_by_name(ident)\n }\n \n+enum VariantShape {\n+    Struct(Vec<tt::Ident>),\n+    Tuple(usize),\n+    Unit,\n+}\n+\n+fn tuple_field_iterator(n: usize) -> impl Iterator<Item = tt::Ident> {\n+    (0..n).map(|x| Ident::new(format!(\"f{x}\"), tt::TokenId::unspecified()))\n+}\n+\n+impl VariantShape {\n+    fn as_pattern(&self, path: tt::Subtree) -> tt::Subtree {\n+        self.as_pattern_map(path, |x| quote!(#x))\n+    }\n+\n+    fn field_names(&self) -> Vec<tt::Ident> {\n+        match self {\n+            VariantShape::Struct(s) => s.clone(),\n+            VariantShape::Tuple(n) => tuple_field_iterator(*n).collect(),\n+            VariantShape::Unit => vec![],\n+        }\n+    }\n+\n+    fn as_pattern_map(\n+        &self,\n+        path: tt::Subtree,\n+        field_map: impl Fn(&tt::Ident) -> tt::Subtree,\n+    ) -> tt::Subtree {\n+        match self {\n+            VariantShape::Struct(fields) => {\n+                let fields = fields.iter().map(|x| {\n+                    let mapped = field_map(x);\n+                    quote! { #x : #mapped , }\n+                });\n+                quote! {\n+                    #path { ##fields }\n+                }\n+            }\n+            &VariantShape::Tuple(n) => {\n+                let fields = tuple_field_iterator(n).map(|x| {\n+                    let mapped = field_map(&x);\n+                    quote! {\n+                        #mapped ,\n+                    }\n+                });\n+                quote! {\n+                    #path ( ##fields )\n+                }\n+            }\n+            VariantShape::Unit => path,\n+        }\n+    }\n+\n+    fn from(value: Option<FieldList>, token_map: &TokenMap) -> Result<Self, ExpandError> {\n+        let r = match value {\n+            None => VariantShape::Unit,\n+            Some(FieldList::RecordFieldList(x)) => VariantShape::Struct(\n+                x.fields()\n+                    .map(|x| x.name())\n+                    .map(|x| name_to_token(token_map, x))\n+                    .collect::<Result<_, _>>()?,\n+            ),\n+            Some(FieldList::TupleFieldList(x)) => VariantShape::Tuple(x.fields().count()),\n+        };\n+        Ok(r)\n+    }\n+}\n+\n+enum AdtShape {\n+    Struct(VariantShape),\n+    Enum { variants: Vec<(tt::Ident, VariantShape)>, default_variant: Option<usize> },\n+    Union,\n+}\n+\n+impl AdtShape {\n+    fn as_pattern(&self, name: &tt::Ident) -> Vec<tt::Subtree> {\n+        self.as_pattern_map(name, |x| quote!(#x))\n+    }\n+\n+    fn field_names(&self) -> Vec<Vec<tt::Ident>> {\n+        match self {\n+            AdtShape::Struct(s) => {\n+                vec![s.field_names()]\n+            }\n+            AdtShape::Enum { variants, .. } => {\n+                variants.iter().map(|(_, fields)| fields.field_names()).collect()\n+            }\n+            AdtShape::Union => {\n+                never!(\"using fields of union in derive is always wrong\");\n+                vec![]\n+            }\n+        }\n+    }\n+\n+    fn as_pattern_map(\n+        &self,\n+        name: &tt::Ident,\n+        field_map: impl Fn(&tt::Ident) -> tt::Subtree,\n+    ) -> Vec<tt::Subtree> {\n+        match self {\n+            AdtShape::Struct(s) => {\n+                vec![s.as_pattern_map(quote! { #name }, field_map)]\n+            }\n+            AdtShape::Enum { variants, .. } => variants\n+                .iter()\n+                .map(|(v, fields)| fields.as_pattern_map(quote! { #name :: #v }, &field_map))\n+                .collect(),\n+            AdtShape::Union => {\n+                never!(\"pattern matching on union is always wrong\");\n+                vec![quote! { un }]\n+            }\n+        }\n+    }\n+}\n+\n struct BasicAdtInfo {\n     name: tt::Ident,\n-    /// `Some(ty)` if it's a const param of type `ty`, `None` if it's a type param.\n-    param_types: Vec<Option<tt::Subtree>>,\n+    shape: AdtShape,\n+    /// first field is the name, and\n+    /// second field is `Some(ty)` if it's a const param of type `ty`, `None` if it's a type param.\n+    /// third fields is where bounds, if any\n+    param_types: Vec<(tt::Subtree, Option<tt::Subtree>, Option<tt::Subtree>)>,\n+    associated_types: Vec<tt::Subtree>,\n }\n \n fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n@@ -75,57 +202,160 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n         ExpandError::Other(\"no item found\".into())\n     })?;\n     let node = item.syntax();\n-    let (name, params) = match_ast! {\n+    let (name, params, shape) = match_ast! {\n         match node {\n-            ast::Struct(it) => (it.name(), it.generic_param_list()),\n-            ast::Enum(it) => (it.name(), it.generic_param_list()),\n-            ast::Union(it) => (it.name(), it.generic_param_list()),\n+            ast::Struct(it) => (it.name(), it.generic_param_list(), AdtShape::Struct(VariantShape::from(it.field_list(), &token_map)?)),\n+            ast::Enum(it) => {\n+                let default_variant = it.variant_list().into_iter().flat_map(|x| x.variants()).position(|x| x.attrs().any(|x| x.simple_name() == Some(\"default\".into())));\n+                (\n+                    it.name(),\n+                    it.generic_param_list(),\n+                    AdtShape::Enum {\n+                        default_variant,\n+                        variants: it.variant_list()\n+                            .into_iter()\n+                            .flat_map(|x| x.variants())\n+                            .map(|x| Ok((name_to_token(&token_map,x.name())?, VariantShape::from(x.field_list(), &token_map)?))).collect::<Result<_, ExpandError>>()?\n+                    }\n+                )\n+            },\n+            ast::Union(it) => (it.name(), it.generic_param_list(), AdtShape::Union),\n             _ => {\n                 debug!(\"unexpected node is {:?}\", node);\n                 return Err(ExpandError::Other(\"expected struct, enum or union\".into()))\n             },\n         }\n     };\n-    let name = name.ok_or_else(|| {\n-        debug!(\"parsed item has no name\");\n-        ExpandError::Other(\"missing name\".into())\n-    })?;\n-    let name_token_id =\n-        token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n-    let name_token = tt::Ident { span: name_token_id, text: name.text().into() };\n+    let mut param_type_set: HashSet<String> = HashSet::new();\n     let param_types = params\n         .into_iter()\n         .flat_map(|param_list| param_list.type_or_const_params())\n         .map(|param| {\n-            if let ast::TypeOrConstParam::Const(param) = param {\n+            let name = {\n+                let this = param.name();\n+                match this {\n+                    Some(x) => {\n+                        param_type_set.insert(x.to_string());\n+                        mbe::syntax_node_to_token_tree(x.syntax()).0\n+                    }\n+                    None => tt::Subtree::empty(),\n+                }\n+            };\n+            let bounds = match &param {\n+                ast::TypeOrConstParam::Type(x) => {\n+                    x.type_bound_list().map(|x| mbe::syntax_node_to_token_tree(x.syntax()).0)\n+                }\n+                ast::TypeOrConstParam::Const(_) => None,\n+            };\n+            let ty = if let ast::TypeOrConstParam::Const(param) = param {\n                 let ty = param\n                     .ty()\n                     .map(|ty| mbe::syntax_node_to_token_tree(ty.syntax()).0)\n                     .unwrap_or_else(tt::Subtree::empty);\n                 Some(ty)\n             } else {\n                 None\n-            }\n+            };\n+            (name, ty, bounds)\n         })\n         .collect();\n-    Ok(BasicAdtInfo { name: name_token, param_types })\n+    let is_associated_type = |p: &PathType| {\n+        if let Some(p) = p.path() {\n+            if let Some(parent) = p.qualifier() {\n+                if let Some(x) = parent.segment() {\n+                    if let Some(x) = x.path_type() {\n+                        if let Some(x) = x.path() {\n+                            if let Some(pname) = x.as_single_name_ref() {\n+                                if param_type_set.contains(&pname.to_string()) {\n+                                    // <T as Trait>::Assoc\n+                                    return true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if let Some(pname) = parent.as_single_name_ref() {\n+                    if param_type_set.contains(&pname.to_string()) {\n+                        // T::Assoc\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    };\n+    let associated_types = node\n+        .descendants()\n+        .filter_map(PathType::cast)\n+        .filter(is_associated_type)\n+        .map(|x| mbe::syntax_node_to_token_tree(x.syntax()).0)\n+        .collect::<Vec<_>>();\n+    let name_token = name_to_token(&token_map, name)?;\n+    Ok(BasicAdtInfo { name: name_token, shape, param_types, associated_types })\n+}\n+\n+fn name_to_token(token_map: &TokenMap, name: Option<ast::Name>) -> Result<tt::Ident, ExpandError> {\n+    let name = name.ok_or_else(|| {\n+        debug!(\"parsed item has no name\");\n+        ExpandError::Other(\"missing name\".into())\n+    })?;\n+    let name_token_id =\n+        token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n+    let name_token = tt::Ident { span: name_token_id, text: name.text().into() };\n+    Ok(name_token)\n }\n \n-fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResult<tt::Subtree> {\n+/// Given that we are deriving a trait `DerivedTrait` for a type like:\n+///\n+/// ```ignore (only-for-syntax-highlight)\n+/// struct Struct<'a, ..., 'z, A, B: DeclaredTrait, C, ..., Z> where C: WhereTrait {\n+///     a: A,\n+///     b: B::Item,\n+///     b1: <B as DeclaredTrait>::Item,\n+///     c1: <C as WhereTrait>::Item,\n+///     c2: Option<<C as WhereTrait>::Item>,\n+///     ...\n+/// }\n+/// ```\n+///\n+/// create an impl like:\n+///\n+/// ```ignore (only-for-syntax-highlight)\n+/// impl<'a, ..., 'z, A, B: DeclaredTrait, C, ... Z> where\n+///     C:                       WhereTrait,\n+///     A: DerivedTrait + B1 + ... + BN,\n+///     B: DerivedTrait + B1 + ... + BN,\n+///     C: DerivedTrait + B1 + ... + BN,\n+///     B::Item:                 DerivedTrait + B1 + ... + BN,\n+///     <C as WhereTrait>::Item: DerivedTrait + B1 + ... + BN,\n+///     ...\n+/// {\n+///     ...\n+/// }\n+/// ```\n+///\n+/// where B1, ..., BN are the bounds given by `bounds_paths`.'. Z is a phantom type, and\n+/// therefore does not get bound by the derived trait.\n+fn expand_simple_derive(\n+    tt: &tt::Subtree,\n+    trait_path: tt::Subtree,\n+    trait_body: impl FnOnce(&BasicAdtInfo) -> tt::Subtree,\n+) -> ExpandResult<tt::Subtree> {\n     let info = match parse_adt(tt) {\n         Ok(info) => info,\n-        Err(e) => return ExpandResult::with_err(tt::Subtree::empty(), e),\n+        Err(e) => return ExpandResult::new(tt::Subtree::empty(), e),\n     };\n+    let trait_body = trait_body(&info);\n+    let mut where_block = vec![];\n     let (params, args): (Vec<_>, Vec<_>) = info\n         .param_types\n         .into_iter()\n-        .enumerate()\n-        .map(|(idx, param_ty)| {\n-            let ident = tt::Leaf::Ident(tt::Ident {\n-                span: tt::TokenId::unspecified(),\n-                text: format!(\"T{idx}\").into(),\n-            });\n+        .map(|(ident, param_ty, bound)| {\n             let ident_ = ident.clone();\n+            if let Some(b) = bound {\n+                let ident = ident.clone();\n+                where_block.push(quote! { #ident : #b , });\n+            }\n             if let Some(ty) = param_ty {\n                 (quote! { const #ident : #ty , }, quote! { #ident_ , })\n             } else {\n@@ -134,9 +364,16 @@ fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResu\n             }\n         })\n         .unzip();\n+\n+    where_block.extend(info.associated_types.iter().map(|x| {\n+        let x = x.clone();\n+        let bound = trait_path.clone();\n+        quote! { #x : #bound , }\n+    }));\n+\n     let name = info.name;\n     let expanded = quote! {\n-        impl < ##params > #trait_path for #name < ##args > {}\n+        impl < ##params > #trait_path for #name < ##args > where ##where_block { #trait_body }\n     };\n     ExpandResult::ok(expanded)\n }\n@@ -163,7 +400,7 @@ fn copy_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::marker::Copy })\n+    expand_simple_derive(tt, quote! { #krate::marker::Copy }, |_| quote! {})\n }\n \n fn clone_expand(\n@@ -172,34 +409,230 @@ fn clone_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::clone::Clone })\n+    expand_simple_derive(tt, quote! { #krate::clone::Clone }, |adt| {\n+        if matches!(adt.shape, AdtShape::Union) {\n+            let star = tt::Punct {\n+                char: '*',\n+                spacing: ::tt::Spacing::Alone,\n+                span: tt::TokenId::unspecified(),\n+            };\n+            return quote! {\n+                fn clone(&self) -> Self {\n+                    #star self\n+                }\n+            };\n+        }\n+        if matches!(&adt.shape, AdtShape::Enum { variants, .. } if variants.is_empty()) {\n+            let star = tt::Punct {\n+                char: '*',\n+                spacing: ::tt::Spacing::Alone,\n+                span: tt::TokenId::unspecified(),\n+            };\n+            return quote! {\n+                fn clone(&self) -> Self {\n+                    match #star self {}\n+                }\n+            };\n+        }\n+        let name = &adt.name;\n+        let patterns = adt.shape.as_pattern(name);\n+        let exprs = adt.shape.as_pattern_map(name, |x| quote! { #x .clone() });\n+        let arms = patterns.into_iter().zip(exprs.into_iter()).map(|(pat, expr)| {\n+            let fat_arrow = fat_arrow();\n+            quote! {\n+                #pat #fat_arrow #expr,\n+            }\n+        });\n+\n+        quote! {\n+            fn clone(&self) -> Self {\n+                match self {\n+                    ##arms\n+                }\n+            }\n+        }\n+    })\n+}\n+\n+/// This function exists since `quote! { => }` doesn't work.\n+fn fat_arrow() -> ::tt::Subtree<TokenId> {\n+    let eq =\n+        tt::Punct { char: '=', spacing: ::tt::Spacing::Joint, span: tt::TokenId::unspecified() };\n+    quote! { #eq> }\n+}\n+\n+/// This function exists since `quote! { && }` doesn't work.\n+fn and_and() -> ::tt::Subtree<TokenId> {\n+    let and =\n+        tt::Punct { char: '&', spacing: ::tt::Spacing::Joint, span: tt::TokenId::unspecified() };\n+    quote! { #and& }\n }\n \n fn default_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::default::Default })\n+    let krate = &find_builtin_crate(db, id);\n+    expand_simple_derive(tt, quote! { #krate::default::Default }, |adt| {\n+        let body = match &adt.shape {\n+            AdtShape::Struct(fields) => {\n+                let name = &adt.name;\n+                fields\n+                    .as_pattern_map(quote!(#name), |_| quote!(#krate::default::Default::default()))\n+            }\n+            AdtShape::Enum { default_variant, variants } => {\n+                if let Some(d) = default_variant {\n+                    let (name, fields) = &variants[*d];\n+                    let adt_name = &adt.name;\n+                    fields.as_pattern_map(\n+                        quote!(#adt_name :: #name),\n+                        |_| quote!(#krate::default::Default::default()),\n+                    )\n+                } else {\n+                    // FIXME: Return expand error here\n+                    quote!()\n+                }\n+            }\n+            AdtShape::Union => {\n+                // FIXME: Return expand error here\n+                quote!()\n+            }\n+        };\n+        quote! {\n+            fn default() -> Self {\n+                #body\n+            }\n+        }\n+    })\n }\n \n fn debug_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::fmt::Debug })\n+    let krate = &find_builtin_crate(db, id);\n+    expand_simple_derive(tt, quote! { #krate::fmt::Debug }, |adt| {\n+        let for_variant = |name: String, v: &VariantShape| match v {\n+            VariantShape::Struct(fields) => {\n+                let for_fields = fields.iter().map(|x| {\n+                    let x_string = x.to_string();\n+                    quote! {\n+                        .field(#x_string, & #x)\n+                    }\n+                });\n+                quote! {\n+                    f.debug_struct(#name) ##for_fields .finish()\n+                }\n+            }\n+            VariantShape::Tuple(n) => {\n+                let for_fields = tuple_field_iterator(*n).map(|x| {\n+                    quote! {\n+                        .field( & #x)\n+                    }\n+                });\n+                quote! {\n+                    f.debug_tuple(#name) ##for_fields .finish()\n+                }\n+            }\n+            VariantShape::Unit => quote! {\n+                f.write_str(#name)\n+            },\n+        };\n+        if matches!(&adt.shape, AdtShape::Enum { variants, .. } if variants.is_empty()) {\n+            let star = tt::Punct {\n+                char: '*',\n+                spacing: ::tt::Spacing::Alone,\n+                span: tt::TokenId::unspecified(),\n+            };\n+            return quote! {\n+                fn fmt(&self, f: &mut #krate::fmt::Formatter) -> #krate::fmt::Result {\n+                    match #star self {}\n+                }\n+            };\n+        }\n+        let arms = match &adt.shape {\n+            AdtShape::Struct(fields) => {\n+                let fat_arrow = fat_arrow();\n+                let name = &adt.name;\n+                let pat = fields.as_pattern(quote!(#name));\n+                let expr = for_variant(name.to_string(), fields);\n+                vec![quote! { #pat #fat_arrow #expr }]\n+            }\n+            AdtShape::Enum { variants, .. } => variants\n+                .iter()\n+                .map(|(name, v)| {\n+                    let fat_arrow = fat_arrow();\n+                    let adt_name = &adt.name;\n+                    let pat = v.as_pattern(quote!(#adt_name :: #name));\n+                    let expr = for_variant(name.to_string(), v);\n+                    quote! {\n+                        #pat #fat_arrow #expr ,\n+                    }\n+                })\n+                .collect(),\n+            AdtShape::Union => {\n+                // FIXME: Return expand error here\n+                vec![]\n+            }\n+        };\n+        quote! {\n+            fn fmt(&self, f: &mut #krate::fmt::Formatter) -> #krate::fmt::Result {\n+                match self {\n+                    ##arms\n+                }\n+            }\n+        }\n+    })\n }\n \n fn hash_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::hash::Hash })\n+    let krate = &find_builtin_crate(db, id);\n+    expand_simple_derive(tt, quote! { #krate::hash::Hash }, |adt| {\n+        if matches!(adt.shape, AdtShape::Union) {\n+            // FIXME: Return expand error here\n+            return quote! {};\n+        }\n+        if matches!(&adt.shape, AdtShape::Enum { variants, .. } if variants.is_empty()) {\n+            let star = tt::Punct {\n+                char: '*',\n+                spacing: ::tt::Spacing::Alone,\n+                span: tt::TokenId::unspecified(),\n+            };\n+            return quote! {\n+                fn hash<H: #krate::hash::Hasher>(&self, state: &mut H) {\n+                    match #star self {}\n+                }\n+            };\n+        }\n+        let arms = adt.shape.as_pattern(&adt.name).into_iter().zip(adt.shape.field_names()).map(\n+            |(pat, names)| {\n+                let expr = {\n+                    let it = names.iter().map(|x| quote! { #x . hash(state); });\n+                    quote! { {\n+                        ##it\n+                    } }\n+                };\n+                let fat_arrow = fat_arrow();\n+                quote! {\n+                    #pat #fat_arrow #expr ,\n+                }\n+            },\n+        );\n+        quote! {\n+            fn hash<H: #krate::hash::Hasher>(&self, state: &mut H) {\n+                #krate::mem::discriminant(self).hash(state);\n+                match self {\n+                    ##arms\n+                }\n+            }\n+        }\n+    })\n }\n \n fn eq_expand(\n@@ -208,7 +641,7 @@ fn eq_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::cmp::Eq })\n+    expand_simple_derive(tt, quote! { #krate::cmp::Eq }, |_| quote! {})\n }\n \n fn partial_eq_expand(\n@@ -217,23 +650,191 @@ fn partial_eq_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::cmp::PartialEq })\n+    expand_simple_derive(tt, quote! { #krate::cmp::PartialEq }, |adt| {\n+        if matches!(adt.shape, AdtShape::Union) {\n+            // FIXME: Return expand error here\n+            return quote! {};\n+        }\n+        let name = &adt.name;\n+\n+        let (self_patterns, other_patterns) = self_and_other_patterns(adt, name);\n+        let arms = izip!(self_patterns, other_patterns, adt.shape.field_names()).map(\n+            |(pat1, pat2, names)| {\n+                let fat_arrow = fat_arrow();\n+                let body = match &*names {\n+                    [] => {\n+                        quote!(true)\n+                    }\n+                    [first, rest @ ..] => {\n+                        let rest = rest.iter().map(|x| {\n+                            let t1 = Ident::new(format!(\"{}_self\", x.text), x.span);\n+                            let t2 = Ident::new(format!(\"{}_other\", x.text), x.span);\n+                            let and_and = and_and();\n+                            quote!(#and_and #t1 .eq( #t2 ))\n+                        });\n+                        let first = {\n+                            let t1 = Ident::new(format!(\"{}_self\", first.text), first.span);\n+                            let t2 = Ident::new(format!(\"{}_other\", first.text), first.span);\n+                            quote!(#t1 .eq( #t2 ))\n+                        };\n+                        quote!(#first ##rest)\n+                    }\n+                };\n+                quote! { ( #pat1 , #pat2 ) #fat_arrow #body , }\n+            },\n+        );\n+\n+        let fat_arrow = fat_arrow();\n+        quote! {\n+            fn eq(&self, other: &Self) -> bool {\n+                match (self, other) {\n+                    ##arms\n+                    _unused #fat_arrow false\n+                }\n+            }\n+        }\n+    })\n+}\n+\n+fn self_and_other_patterns(\n+    adt: &BasicAdtInfo,\n+    name: &tt::Ident,\n+) -> (Vec<tt::Subtree>, Vec<tt::Subtree>) {\n+    let self_patterns = adt.shape.as_pattern_map(name, |x| {\n+        let t = Ident::new(format!(\"{}_self\", x.text), x.span);\n+        quote!(#t)\n+    });\n+    let other_patterns = adt.shape.as_pattern_map(name, |x| {\n+        let t = Ident::new(format!(\"{}_other\", x.text), x.span);\n+        quote!(#t)\n+    });\n+    (self_patterns, other_patterns)\n }\n \n fn ord_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::cmp::Ord })\n+    let krate = &find_builtin_crate(db, id);\n+    expand_simple_derive(tt, quote! { #krate::cmp::Ord }, |adt| {\n+        fn compare(\n+            krate: &tt::TokenTree,\n+            left: tt::Subtree,\n+            right: tt::Subtree,\n+            rest: tt::Subtree,\n+        ) -> tt::Subtree {\n+            let fat_arrow1 = fat_arrow();\n+            let fat_arrow2 = fat_arrow();\n+            quote! {\n+                match #left.cmp(&#right) {\n+                    #krate::cmp::Ordering::Equal #fat_arrow1 {\n+                        #rest\n+                    }\n+                    c #fat_arrow2 return c,\n+                }\n+            }\n+        }\n+        if matches!(adt.shape, AdtShape::Union) {\n+            // FIXME: Return expand error here\n+            return quote!();\n+        }\n+        let left = quote!(#krate::intrinsics::discriminant_value(self));\n+        let right = quote!(#krate::intrinsics::discriminant_value(other));\n+\n+        let (self_patterns, other_patterns) = self_and_other_patterns(adt, &adt.name);\n+        let arms = izip!(self_patterns, other_patterns, adt.shape.field_names()).map(\n+            |(pat1, pat2, fields)| {\n+                let mut body = quote!(#krate::cmp::Ordering::Equal);\n+                for f in fields.into_iter().rev() {\n+                    let t1 = Ident::new(format!(\"{}_self\", f.text), f.span);\n+                    let t2 = Ident::new(format!(\"{}_other\", f.text), f.span);\n+                    body = compare(krate, quote!(#t1), quote!(#t2), body);\n+                }\n+                let fat_arrow = fat_arrow();\n+                quote! { ( #pat1 , #pat2 ) #fat_arrow #body , }\n+            },\n+        );\n+        let fat_arrow = fat_arrow();\n+        let body = compare(\n+            krate,\n+            left,\n+            right,\n+            quote! {\n+                match (self, other) {\n+                    ##arms\n+                    _unused #fat_arrow #krate::cmp::Ordering::Equal\n+                }\n+            },\n+        );\n+        quote! {\n+            fn cmp(&self, other: &Self) -> #krate::cmp::Ordering {\n+                #body\n+            }\n+        }\n+    })\n }\n \n fn partial_ord_expand(\n     db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = find_builtin_crate(db, id);\n-    expand_simple_derive(tt, quote! { #krate::cmp::PartialOrd })\n+    let krate = &find_builtin_crate(db, id);\n+    expand_simple_derive(tt, quote! { #krate::cmp::PartialOrd }, |adt| {\n+        fn compare(\n+            krate: &tt::TokenTree,\n+            left: tt::Subtree,\n+            right: tt::Subtree,\n+            rest: tt::Subtree,\n+        ) -> tt::Subtree {\n+            let fat_arrow1 = fat_arrow();\n+            let fat_arrow2 = fat_arrow();\n+            quote! {\n+                match #left.partial_cmp(&#right) {\n+                    #krate::option::Option::Some(#krate::cmp::Ordering::Equal) #fat_arrow1 {\n+                        #rest\n+                    }\n+                    c #fat_arrow2 return c,\n+                }\n+            }\n+        }\n+        if matches!(adt.shape, AdtShape::Union) {\n+            // FIXME: Return expand error here\n+            return quote!();\n+        }\n+        let left = quote!(#krate::intrinsics::discriminant_value(self));\n+        let right = quote!(#krate::intrinsics::discriminant_value(other));\n+\n+        let (self_patterns, other_patterns) = self_and_other_patterns(adt, &adt.name);\n+        let arms = izip!(self_patterns, other_patterns, adt.shape.field_names()).map(\n+            |(pat1, pat2, fields)| {\n+                let mut body = quote!(#krate::option::Option::Some(#krate::cmp::Ordering::Equal));\n+                for f in fields.into_iter().rev() {\n+                    let t1 = Ident::new(format!(\"{}_self\", f.text), f.span);\n+                    let t2 = Ident::new(format!(\"{}_other\", f.text), f.span);\n+                    body = compare(krate, quote!(#t1), quote!(#t2), body);\n+                }\n+                let fat_arrow = fat_arrow();\n+                quote! { ( #pat1 , #pat2 ) #fat_arrow #body , }\n+            },\n+        );\n+        let fat_arrow = fat_arrow();\n+        let body = compare(\n+            krate,\n+            left,\n+            right,\n+            quote! {\n+                match (self, other) {\n+                    ##arms\n+                    _unused #fat_arrow #krate::option::Option::Some(#krate::cmp::Ordering::Equal)\n+                }\n+            },\n+        );\n+        quote! {\n+            fn partial_cmp(&self, other: &Self) -> #krate::option::Option::Option<#krate::cmp::Ordering> {\n+                #body\n+            }\n+        }\n+    })\n }"}, {"sha": "c7643bd0a18eb51311f0854153c67b9f7139949a", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 174, "deletions": 46, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,9 +1,13 @@\n //! Builtin macro\n \n+use std::mem;\n+\n+use ::tt::Ident;\n use base_db::{AnchoredPath, Edition, FileId};\n use cfg::CfgExpr;\n use either::Either;\n-use mbe::{parse_exprs_with_sep, parse_to_token_tree};\n+use mbe::{parse_exprs_with_sep, parse_to_token_tree, TokenMap};\n+use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, AstToken},\n     SmolStr,\n@@ -67,7 +71,7 @@ macro_rules! register_builtin {\n pub struct ExpandedEager {\n     pub(crate) subtree: tt::Subtree,\n     /// The included file ID of the include macro.\n-    pub(crate) included_file: Option<FileId>,\n+    pub(crate) included_file: Option<(FileId, TokenMap)>,\n }\n \n impl ExpandedEager {\n@@ -90,11 +94,6 @@ register_builtin! {\n     (module_path, ModulePath) => module_path_expand,\n     (assert, Assert) => assert_expand,\n     (stringify, Stringify) => stringify_expand,\n-    (format_args, FormatArgs) => format_args_expand,\n-    (const_format_args, ConstFormatArgs) => format_args_expand,\n-    // format_args_nl only differs in that it adds a newline in the end,\n-    // so we use the same stub expansion for now\n-    (format_args_nl, FormatArgsNl) => format_args_expand,\n     (llvm_asm, LlvmAsm) => asm_expand,\n     (asm, Asm) => asm_expand,\n     (global_asm, GlobalAsm) => global_asm_expand,\n@@ -106,6 +105,9 @@ register_builtin! {\n     (trace_macros, TraceMacros) => trace_macros_expand,\n \n     EAGER:\n+    (format_args, FormatArgs) => format_args_expand,\n+    (const_format_args, ConstFormatArgs) => format_args_expand,\n+    (format_args_nl, FormatArgsNl) => format_args_nl_expand,\n     (compile_error, CompileError) => compile_error_expand,\n     (concat, Concat) => concat_expand,\n     (concat_idents, ConcatIdents) => concat_idents_expand,\n@@ -135,9 +137,8 @@ fn line_expand(\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // dummy implementation for type-checking purposes\n-    let line_num = 0;\n     let expanded = quote! {\n-        #line_num\n+        0 as u32\n     };\n \n     ExpandResult::ok(expanded)\n@@ -179,9 +180,8 @@ fn column_expand(\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // dummy implementation for type-checking purposes\n-    let col_num = 0;\n     let expanded = quote! {\n-        #col_num\n+        0 as u32\n     };\n \n     ExpandResult::ok(expanded)\n@@ -234,45 +234,173 @@ fn file_expand(\n }\n \n fn format_args_expand(\n+    db: &dyn ExpandDatabase,\n+    id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<ExpandedEager> {\n+    format_args_expand_general(db, id, tt, \"\")\n+        .map(|x| ExpandedEager { subtree: x, included_file: None })\n+}\n+\n+fn format_args_nl_expand(\n+    db: &dyn ExpandDatabase,\n+    id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<ExpandedEager> {\n+    format_args_expand_general(db, id, tt, \"\\\\n\")\n+        .map(|x| ExpandedEager { subtree: x, included_file: None })\n+}\n+\n+fn format_args_expand_general(\n     _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n+    end_string: &str,\n ) -> ExpandResult<tt::Subtree> {\n-    // We expand `format_args!(\"\", a1, a2)` to\n-    // ```\n-    // $crate::fmt::Arguments::new_v1(&[], &[\n-    //   $crate::fmt::Argument::new(&arg1,$crate::fmt::Display::fmt),\n-    //   $crate::fmt::Argument::new(&arg2,$crate::fmt::Display::fmt),\n-    // ])\n-    // ```,\n-    // which is still not really correct, but close enough for now\n-    let mut args = parse_exprs_with_sep(tt, ',');\n+    let args = parse_exprs_with_sep(tt, ',');\n+\n+    let expand_error =\n+        ExpandResult::new(tt::Subtree::empty(), mbe::ExpandError::NoMatchingRule.into());\n \n     if args.is_empty() {\n-        return ExpandResult::with_err(\n-            tt::Subtree::empty(),\n-            mbe::ExpandError::NoMatchingRule.into(),\n-        );\n+        return expand_error;\n     }\n-    for arg in &mut args {\n+    let mut key_args = FxHashMap::default();\n+    let mut args = args.into_iter().filter_map(|mut arg| {\n         // Remove `key =`.\n         if matches!(arg.token_trees.get(1), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=')\n         {\n             // but not with `==`\n-            if !matches!(arg.token_trees.get(2), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=' )\n+            if !matches!(arg.token_trees.get(2), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=')\n             {\n-                arg.token_trees.drain(..2);\n+                let key = arg.token_trees.drain(..2).next().unwrap();\n+                key_args.insert(key.to_string(), arg);\n+                return None;\n             }\n         }\n+        Some(arg)\n+    }).collect::<Vec<_>>().into_iter();\n+    // ^^^^^^^ we need this collect, to enforce the side effect of the filter_map closure (building the `key_args`)\n+    let format_subtree = args.next().unwrap();\n+    let format_string = (|| {\n+        let token_tree = format_subtree.token_trees.get(0)?;\n+        match token_tree {\n+            tt::TokenTree::Leaf(l) => match l {\n+                tt::Leaf::Literal(l) => {\n+                    if let Some(mut text) = l.text.strip_prefix('r') {\n+                        let mut raw_sharps = String::new();\n+                        while let Some(t) = text.strip_prefix('#') {\n+                            text = t;\n+                            raw_sharps.push('#');\n+                        }\n+                        text =\n+                            text.strip_suffix(&raw_sharps)?.strip_prefix('\"')?.strip_suffix('\"')?;\n+                        Some((text, l.span, Some(raw_sharps)))\n+                    } else {\n+                        let text = l.text.strip_prefix('\"')?.strip_suffix('\"')?;\n+                        let span = l.span;\n+                        Some((text, span, None))\n+                    }\n+                }\n+                _ => None,\n+            },\n+            tt::TokenTree::Subtree(_) => None,\n+        }\n+    })();\n+    let Some((format_string, _format_string_span, raw_sharps)) = format_string else {\n+        return expand_error;\n+    };\n+    let mut format_iter = format_string.chars().peekable();\n+    let mut parts = vec![];\n+    let mut last_part = String::new();\n+    let mut arg_tts = vec![];\n+    let mut err = None;\n+    while let Some(c) = format_iter.next() {\n+        // Parsing the format string. See https://doc.rust-lang.org/std/fmt/index.html#syntax for the grammar and more info\n+        match c {\n+            '{' => {\n+                if format_iter.peek() == Some(&'{') {\n+                    format_iter.next();\n+                    last_part.push('{');\n+                    continue;\n+                }\n+                let mut argument = String::new();\n+                while ![Some(&'}'), Some(&':')].contains(&format_iter.peek()) {\n+                    argument.push(match format_iter.next() {\n+                        Some(c) => c,\n+                        None => return expand_error,\n+                    });\n+                }\n+                let format_spec = match format_iter.next().unwrap() {\n+                    '}' => \"\".to_owned(),\n+                    ':' => {\n+                        let mut s = String::new();\n+                        while let Some(c) = format_iter.next() {\n+                            if c == '}' {\n+                                break;\n+                            }\n+                            s.push(c);\n+                        }\n+                        s\n+                    }\n+                    _ => unreachable!(),\n+                };\n+                parts.push(mem::take(&mut last_part));\n+                let arg_tree = if argument.is_empty() {\n+                    match args.next() {\n+                        Some(x) => x,\n+                        None => {\n+                            err = Some(mbe::ExpandError::NoMatchingRule.into());\n+                            tt::Subtree::empty()\n+                        }\n+                    }\n+                } else if let Some(tree) = key_args.get(&argument) {\n+                    tree.clone()\n+                } else {\n+                    // FIXME: we should pick the related substring of the `_format_string_span` as the span. You\n+                    // can use `.char_indices()` instead of `.char()` for `format_iter` to find the substring interval.\n+                    let ident = Ident::new(argument, tt::TokenId::unspecified());\n+                    quote!(#ident)\n+                };\n+                let formatter = match &*format_spec {\n+                    \"?\" => quote!(::core::fmt::Debug::fmt),\n+                    \"\" => quote!(::core::fmt::Display::fmt),\n+                    _ => {\n+                        // FIXME: implement the rest and return expand error here\n+                        quote!(::core::fmt::Display::fmt)\n+                    }\n+                };\n+                arg_tts.push(quote! { ::core::fmt::Argument::new(&(#arg_tree), #formatter), });\n+            }\n+            '}' => {\n+                if format_iter.peek() == Some(&'}') {\n+                    format_iter.next();\n+                    last_part.push('}');\n+                } else {\n+                    return expand_error;\n+                }\n+            }\n+            _ => last_part.push(c),\n+        }\n+    }\n+    last_part += end_string;\n+    if !last_part.is_empty() {\n+        parts.push(last_part);\n     }\n-    let _format_string = args.remove(0);\n-    let arg_tts = args.into_iter().flat_map(|arg| {\n-        quote! { #DOLLAR_CRATE::fmt::Argument::new(&(#arg), #DOLLAR_CRATE::fmt::Display::fmt), }\n-    }.token_trees);\n+    let part_tts = parts.into_iter().map(|x| {\n+        let text = if let Some(raw) = &raw_sharps {\n+            format!(\"r{raw}\\\"{}\\\"{raw}\", x).into()\n+        } else {\n+            format!(\"\\\"{}\\\"\", x).into()\n+        };\n+        let l = tt::Literal { span: tt::TokenId::unspecified(), text };\n+        quote!(#l ,)\n+    });\n+    let arg_tts = arg_tts.into_iter().flat_map(|arg| arg.token_trees);\n     let expanded = quote! {\n-        #DOLLAR_CRATE::fmt::Arguments::new_v1(&[], &[##arg_tts])\n+        ::core::fmt::Arguments::new_v1(&[##part_tts], &[##arg_tts])\n     };\n-    ExpandResult::ok(expanded)\n+    ExpandResult { value: expanded, err }\n }\n \n fn asm_expand(\n@@ -566,16 +694,16 @@ fn include_expand(\n         let path = parse_string(tt)?;\n         let file_id = relative_file(db, arg_id, &path, false)?;\n \n-        let subtree =\n-            parse_to_token_tree(&db.file_text(file_id)).ok_or(mbe::ExpandError::ConversionError)?.0;\n-        Ok((subtree, file_id))\n+        let (subtree, map) =\n+            parse_to_token_tree(&db.file_text(file_id)).ok_or(mbe::ExpandError::ConversionError)?;\n+        Ok((subtree, map, file_id))\n     })();\n \n     match res {\n-        Ok((subtree, file_id)) => {\n-            ExpandResult::ok(ExpandedEager { subtree, included_file: Some(file_id) })\n+        Ok((subtree, map, file_id)) => {\n+            ExpandResult::ok(ExpandedEager { subtree, included_file: Some((file_id, map)) })\n         }\n-        Err(e) => ExpandResult::with_err(\n+        Err(e) => ExpandResult::new(\n             ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n             e,\n         ),\n@@ -588,7 +716,7 @@ fn include_bytes_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n     if let Err(e) = parse_string(tt) {\n-        return ExpandResult::with_err(\n+        return ExpandResult::new(\n             ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n             e,\n         );\n@@ -613,7 +741,7 @@ fn include_str_expand(\n     let path = match parse_string(tt) {\n         Ok(it) => it,\n         Err(e) => {\n-            return ExpandResult::with_err(\n+            return ExpandResult::new(\n                 ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n                 e,\n             )\n@@ -650,7 +778,7 @@ fn env_expand(\n     let key = match parse_string(tt) {\n         Ok(it) => it,\n         Err(e) => {\n-            return ExpandResult::with_err(\n+            return ExpandResult::new(\n                 ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n                 e,\n             )\n@@ -686,16 +814,16 @@ fn option_env_expand(\n     let key = match parse_string(tt) {\n         Ok(it) => it,\n         Err(e) => {\n-            return ExpandResult::with_err(\n+            return ExpandResult::new(\n                 ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n                 e,\n             )\n         }\n     };\n-\n+    // FIXME: Use `DOLLAR_CRATE` when that works in eager macros.\n     let expanded = match get_env_inner(db, arg_id, &key) {\n-        None => quote! { #DOLLAR_CRATE::option::Option::None::<&str> },\n-        Some(s) => quote! { #DOLLAR_CRATE::option::Option::Some(#s) },\n+        None => quote! { ::core::option::Option::None::<&str> },\n+        Some(s) => quote! { ::core::option::Option::Some(#s) },\n     };\n \n     ExpandResult::ok(ExpandedEager::new(expanded))"}, {"sha": "965dfa824d8f9041a808b1826b7b8886400d2b67", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/db.rs", "status": "modified", "additions": 139, "deletions": 103, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,22 +1,22 @@\n //! Defines database & queries for macro expansion.\n \n-use std::sync::Arc;\n-\n-use base_db::{salsa, SourceDatabase};\n+use base_db::{salsa, Edition, SourceDatabase};\n use either::Either;\n use limit::Limit;\n use mbe::syntax_node_to_token_tree;\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, HasAttrs, HasDocComments},\n-    AstNode, GreenNode, Parse, SyntaxNode, SyntaxToken, T,\n+    AstNode, GreenNode, Parse, SyntaxError, SyntaxNode, SyntaxToken, T,\n };\n+use triomphe::Arc;\n \n use crate::{\n-    ast_id_map::AstIdMap, builtin_attr_macro::pseudo_derive_attr_expansion, fixup,\n-    hygiene::HygieneFrame, tt, BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n-    ExpandError, ExpandResult, ExpandTo, HirFileId, HirFileIdRepr, MacroCallId, MacroCallKind,\n-    MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n+    ast_id_map::AstIdMap, builtin_attr_macro::pseudo_derive_attr_expansion,\n+    builtin_fn_macro::EagerExpander, fixup, hygiene::HygieneFrame, tt, BuiltinAttrExpander,\n+    BuiltinDeriveExpander, BuiltinFnLikeExpander, ExpandError, ExpandResult, ExpandTo, HirFileId,\n+    HirFileIdRepr, MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile,\n+    ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -33,6 +33,8 @@ pub enum TokenExpander {\n     DeclarativeMacro { mac: mbe::DeclarativeMacro, def_site_token_map: mbe::TokenMap },\n     /// Stuff like `line!` and `file!`.\n     Builtin(BuiltinFnLikeExpander),\n+    /// Built-in eagerly expanded fn-like macros (`include!`, `concat!`, etc.)\n+    BuiltinEager(EagerExpander),\n     /// `global_allocator` and such.\n     BuiltinAttr(BuiltinAttrExpander),\n     /// `derive(Copy)` and such.\n@@ -51,6 +53,9 @@ impl TokenExpander {\n         match self {\n             TokenExpander::DeclarativeMacro { mac, .. } => mac.expand(tt).map_err(Into::into),\n             TokenExpander::Builtin(it) => it.expand(db, id, tt).map_err(Into::into),\n+            TokenExpander::BuiltinEager(it) => {\n+                it.expand(db, id, tt).map_err(Into::into).map(|res| res.subtree)\n+            }\n             TokenExpander::BuiltinAttr(it) => it.expand(db, id, tt),\n             TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt),\n             TokenExpander::ProcMacro(_) => {\n@@ -66,6 +71,7 @@ impl TokenExpander {\n         match self {\n             TokenExpander::DeclarativeMacro { mac, .. } => mac.map_id_down(id),\n             TokenExpander::Builtin(..)\n+            | TokenExpander::BuiltinEager(..)\n             | TokenExpander::BuiltinAttr(..)\n             | TokenExpander::BuiltinDerive(..)\n             | TokenExpander::ProcMacro(..) => id,\n@@ -76,6 +82,7 @@ impl TokenExpander {\n         match self {\n             TokenExpander::DeclarativeMacro { mac, .. } => mac.map_id_up(id),\n             TokenExpander::Builtin(..)\n+            | TokenExpander::BuiltinEager(..)\n             | TokenExpander::BuiltinAttr(..)\n             | TokenExpander::BuiltinDerive(..)\n             | TokenExpander::ProcMacro(..) => (id, mbe::Origin::Call),\n@@ -90,12 +97,15 @@ pub trait ExpandDatabase: SourceDatabase {\n     /// Main public API -- parses a hir file, not caring whether it's a real\n     /// file or a macro expansion.\n     #[salsa::transparent]\n-    fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode>;\n+    fn parse_or_expand(&self, file_id: HirFileId) -> SyntaxNode;\n+    #[salsa::transparent]\n+    fn parse_or_expand_with_err(&self, file_id: HirFileId) -> ExpandResult<Parse<SyntaxNode>>;\n     /// Implementation for the macro case.\n+    // This query is LRU cached\n     fn parse_macro_expansion(\n         &self,\n         macro_file: MacroFile,\n-    ) -> ExpandResult<Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>>;\n+    ) -> ExpandResult<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>;\n \n     /// Macro ids. That's probably the tricksiest bit in rust-analyzer, and the\n     /// reason why we use salsa at all.\n@@ -119,15 +129,19 @@ pub trait ExpandDatabase: SourceDatabase {\n     /// just fetches procedural ones.\n     fn macro_def(&self, id: MacroDefId) -> Result<Arc<TokenExpander>, mbe::ParseError>;\n \n-    /// Expand macro call to a token tree. This query is LRUed (we keep 128 or so results in memory)\n-    fn macro_expand(&self, macro_call: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>>;\n+    /// Expand macro call to a token tree.\n+    // This query is LRU cached\n+    fn macro_expand(&self, macro_call: MacroCallId) -> ExpandResult<Arc<tt::Subtree>>;\n     /// Special case of the previous query for procedural macros. We can't LRU\n     /// proc macros, since they are not deterministic in general, and\n-    /// non-determinism breaks salsa in a very, very, very bad way. @edwin0cheng\n-    /// heroically debugged this once!\n+    /// non-determinism breaks salsa in a very, very, very bad way.\n+    /// @edwin0cheng heroically debugged this once!\n     fn expand_proc_macro(&self, call: MacroCallId) -> ExpandResult<tt::Subtree>;\n-    /// Firewall query that returns the error from the `macro_expand` query.\n-    fn macro_expand_error(&self, macro_call: MacroCallId) -> Option<ExpandError>;\n+    /// Firewall query that returns the errors from the `parse_macro_expansion` query.\n+    fn parse_macro_expansion_error(\n+        &self,\n+        macro_call: MacroCallId,\n+    ) -> ExpandResult<Box<[SyntaxError]>>;\n \n     fn hygiene_frame(&self, file_id: HirFileId) -> Arc<HygieneFrame>;\n }\n@@ -159,8 +173,8 @@ pub fn expand_speculative(\n     );\n \n     let (attr_arg, token_id) = match loc.kind {\n-        MacroCallKind::Attr { invoc_attr_index, is_derive, .. } => {\n-            let attr = if is_derive {\n+        MacroCallKind::Attr { invoc_attr_index, .. } => {\n+            let attr = if loc.def.is_attribute_derive() {\n                 // for pseudo-derive expansion we actually pass the attribute itself only\n                 ast::Attr::cast(speculative_args.clone())\n             } else {\n@@ -236,53 +250,61 @@ pub fn expand_speculative(\n }\n \n fn ast_id_map(db: &dyn ExpandDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n-    let map = db.parse_or_expand(file_id).map(|it| AstIdMap::from_source(&it)).unwrap_or_default();\n-    Arc::new(map)\n+    Arc::new(AstIdMap::from_source(&db.parse_or_expand(file_id)))\n }\n \n-fn parse_or_expand(db: &dyn ExpandDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n+fn parse_or_expand(db: &dyn ExpandDatabase, file_id: HirFileId) -> SyntaxNode {\n     match file_id.repr() {\n-        HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n+        HirFileIdRepr::FileId(file_id) => db.parse(file_id).tree().syntax().clone(),\n         HirFileIdRepr::MacroFile(macro_file) => {\n-            // FIXME: Note how we convert from `Parse` to `SyntaxNode` here,\n-            // forgetting about parse errors.\n-            db.parse_macro_expansion(macro_file).value.map(|(it, _)| it.syntax_node())\n+            db.parse_macro_expansion(macro_file).value.0.syntax_node()\n+        }\n+    }\n+}\n+\n+fn parse_or_expand_with_err(\n+    db: &dyn ExpandDatabase,\n+    file_id: HirFileId,\n+) -> ExpandResult<Parse<SyntaxNode>> {\n+    match file_id.repr() {\n+        HirFileIdRepr::FileId(file_id) => ExpandResult::ok(db.parse(file_id).to_syntax()),\n+        HirFileIdRepr::MacroFile(macro_file) => {\n+            db.parse_macro_expansion(macro_file).map(|(it, _)| it)\n         }\n     }\n }\n \n fn parse_macro_expansion(\n     db: &dyn ExpandDatabase,\n     macro_file: MacroFile,\n-) -> ExpandResult<Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>> {\n+) -> ExpandResult<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)> {\n     let _p = profile::span(\"parse_macro_expansion\");\n-    let mbe::ValueResult { value, err } = db.macro_expand(macro_file.macro_call_id);\n+    let mbe::ValueResult { value: tt, err } = db.macro_expand(macro_file.macro_call_id);\n \n     if let Some(err) = &err {\n-        // Note:\n-        // The final goal we would like to make all parse_macro success,\n-        // such that the following log will not call anyway.\n-        let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-        let node = loc.kind.to_node(db);\n-\n-        // collect parent information for warning log\n-        let parents =\n-            std::iter::successors(loc.kind.file_id().call_node(db), |it| it.file_id.call_node(db))\n-                .map(|n| format!(\"{:#}\", n.value))\n-                .collect::<Vec<_>>()\n-                .join(\"\\n\");\n-\n-        tracing::debug!(\n-            \"fail on macro_parse: (reason: {:?} macro_call: {:#}) parents: {}\",\n-            err,\n-            node.value,\n-            parents\n-        );\n+        if tracing::enabled!(tracing::Level::DEBUG) {\n+            // Note:\n+            // The final goal we would like to make all parse_macro success,\n+            // such that the following log will not call anyway.\n+            let loc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n+            let node = loc.to_node(db);\n+\n+            // collect parent information for warning log\n+            let parents = std::iter::successors(loc.kind.file_id().call_node(db), |it| {\n+                it.file_id.call_node(db)\n+            })\n+            .map(|n| format!(\"{:#}\", n.value))\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+\n+            tracing::debug!(\n+                \"fail on macro_parse: (reason: {:?} macro_call: {:#}) parents: {}\",\n+                err,\n+                node.value,\n+                parents\n+            );\n+        }\n     }\n-    let tt = match value {\n-        Some(tt) => tt,\n-        None => return ExpandResult { value: None, err },\n-    };\n \n     let expand_to = macro_expand_to(db, macro_file.macro_call_id);\n \n@@ -291,7 +313,7 @@ fn parse_macro_expansion(\n \n     let (parse, rev_token_map) = token_tree_to_syntax_node(&tt, expand_to);\n \n-    ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err }\n+    ExpandResult { value: (parse, Arc::new(rev_token_map)), err }\n }\n \n fn macro_arg(\n@@ -339,7 +361,7 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n                     .map(|it| it.syntax().clone())\n                     .collect()\n             }\n-            MacroCallKind::Attr { is_derive: true, .. } => return None,\n+            MacroCallKind::Attr { .. } if loc.def.is_attribute_derive() => return None,\n             MacroCallKind::Attr { invoc_attr_index, .. } => {\n                 cov_mark::hit!(attribute_macro_attr_censoring);\n                 ast::Item::cast(node.clone())?\n@@ -385,21 +407,22 @@ fn macro_def(\n ) -> Result<Arc<TokenExpander>, mbe::ParseError> {\n     match id.kind {\n         MacroDefKind::Declarative(ast_id) => {\n+            let is_2021 = db.crate_graph()[id.krate].edition >= Edition::Edition2021;\n             let (mac, def_site_token_map) = match ast_id.to_node(db) {\n                 ast::Macro::MacroRules(macro_rules) => {\n                     let arg = macro_rules\n                         .token_tree()\n                         .ok_or_else(|| mbe::ParseError::Expected(\"expected a token tree\".into()))?;\n                     let (tt, def_site_token_map) = mbe::syntax_node_to_token_tree(arg.syntax());\n-                    let mac = mbe::DeclarativeMacro::parse_macro_rules(&tt)?;\n+                    let mac = mbe::DeclarativeMacro::parse_macro_rules(&tt, is_2021)?;\n                     (mac, def_site_token_map)\n                 }\n                 ast::Macro::MacroDef(macro_def) => {\n                     let arg = macro_def\n                         .body()\n                         .ok_or_else(|| mbe::ParseError::Expected(\"expected a token tree\".into()))?;\n                     let (tt, def_site_token_map) = mbe::syntax_node_to_token_tree(arg.syntax());\n-                    let mac = mbe::DeclarativeMacro::parse_macro2(&tt)?;\n+                    let mac = mbe::DeclarativeMacro::parse_macro2(&tt, is_2021)?;\n                     (mac, def_site_token_map)\n                 }\n             };\n@@ -412,82 +435,96 @@ fn macro_def(\n         MacroDefKind::BuiltInDerive(expander, _) => {\n             Ok(Arc::new(TokenExpander::BuiltinDerive(expander)))\n         }\n-        MacroDefKind::BuiltInEager(..) => {\n-            // FIXME: Return a random error here just to make the types align.\n-            // This obviously should do something real instead.\n-            Err(mbe::ParseError::UnexpectedToken(\"unexpected eager macro\".into()))\n+        MacroDefKind::BuiltInEager(expander, ..) => {\n+            Ok(Arc::new(TokenExpander::BuiltinEager(expander)))\n         }\n         MacroDefKind::ProcMacro(expander, ..) => Ok(Arc::new(TokenExpander::ProcMacro(expander))),\n     }\n }\n \n-fn macro_expand(\n-    db: &dyn ExpandDatabase,\n-    id: MacroCallId,\n-) -> ExpandResult<Option<Arc<tt::Subtree>>> {\n+fn macro_expand(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandResult<Arc<tt::Subtree>> {\n     let _p = profile::span(\"macro_expand\");\n-    let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n+    let loc = db.lookup_intern_macro_call(id);\n     if let Some(eager) = &loc.eager {\n-        return ExpandResult {\n-            value: Some(eager.arg_or_expansion.clone()),\n-            // FIXME: There could be errors here!\n-            err: None,\n-        };\n+        return ExpandResult { value: eager.arg_or_expansion.clone(), err: eager.error.clone() };\n     }\n \n-    let macro_arg = match db.macro_arg(id) {\n-        Some(it) => it,\n-        None => {\n-            return ExpandResult::only_err(ExpandError::Other(\n-                \"Failed to lower macro args to token tree\".into(),\n-            ))\n-        }\n-    };\n-\n     let expander = match db.macro_def(loc.def) {\n         Ok(it) => it,\n         // FIXME: This is weird -- we effectively report macro *definition*\n         // errors lazily, when we try to expand the macro. Instead, they should\n-        // be reported at the definition site (when we construct a def map).\n+        // be reported at the definition site when we construct a def map.\n+        // (Note we do report them also at the definition site in the late diagnostic pass)\n         Err(err) => {\n-            return ExpandResult::only_err(ExpandError::Other(\n-                format!(\"invalid macro definition: {err}\").into(),\n-            ))\n+            return ExpandResult {\n+                value: Arc::new(tt::Subtree {\n+                    delimiter: tt::Delimiter::UNSPECIFIED,\n+                    token_trees: vec![],\n+                }),\n+                err: Some(ExpandError::Other(format!(\"invalid macro definition: {err}\").into())),\n+            }\n         }\n     };\n+    let Some(macro_arg) = db.macro_arg(id) else {\n+        return ExpandResult {\n+            value: Arc::new(\n+                tt::Subtree {\n+                    delimiter: tt::Delimiter::UNSPECIFIED,\n+                    token_trees: Vec::new(),\n+                },\n+            ),\n+            err: Some(ExpandError::Other(\n+                \"invalid token tree\"\n+                .into(),\n+            )),\n+        };\n+    };\n     let ExpandResult { value: mut tt, err } = expander.expand(db, id, &macro_arg.0);\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if TOKEN_LIMIT.check(count).is_err() {\n-        return ExpandResult::only_err(ExpandError::Other(\n-            format!(\n-                \"macro invocation exceeds token limit: produced {} tokens, limit is {}\",\n-                count,\n-                TOKEN_LIMIT.inner(),\n-            )\n-            .into(),\n-        ));\n+        return ExpandResult {\n+            value: Arc::new(tt::Subtree {\n+                delimiter: tt::Delimiter::UNSPECIFIED,\n+                token_trees: vec![],\n+            }),\n+            err: Some(ExpandError::Other(\n+                format!(\n+                    \"macro invocation exceeds token limit: produced {} tokens, limit is {}\",\n+                    count,\n+                    TOKEN_LIMIT.inner(),\n+                )\n+                .into(),\n+            )),\n+        };\n     }\n \n     fixup::reverse_fixups(&mut tt, &macro_arg.1, &macro_arg.2);\n \n-    ExpandResult { value: Some(Arc::new(tt)), err }\n+    ExpandResult { value: Arc::new(tt), err }\n }\n \n-fn macro_expand_error(db: &dyn ExpandDatabase, macro_call: MacroCallId) -> Option<ExpandError> {\n-    db.macro_expand(macro_call).err\n+fn parse_macro_expansion_error(\n+    db: &dyn ExpandDatabase,\n+    macro_call_id: MacroCallId,\n+) -> ExpandResult<Box<[SyntaxError]>> {\n+    db.parse_macro_expansion(MacroFile { macro_call_id })\n+        .map(|it| it.0.errors().to_vec().into_boxed_slice())\n }\n \n fn expand_proc_macro(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandResult<tt::Subtree> {\n-    let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n-    let macro_arg = match db.macro_arg(id) {\n-        Some(it) => it,\n-        None => {\n-            return ExpandResult::with_err(\n-                tt::Subtree::empty(),\n-                ExpandError::Other(\"No arguments for proc-macro\".into()),\n-            )\n-        }\n+    let loc = db.lookup_intern_macro_call(id);\n+    let Some(macro_arg) = db.macro_arg(id) else {\n+        return ExpandResult {\n+            value: tt::Subtree {\n+                delimiter: tt::Delimiter::UNSPECIFIED,\n+                token_trees: Vec::new(),\n+            },\n+            err: Some(ExpandError::Other(\n+                \"invalid token tree\"\n+                .into(),\n+            )),\n+        };\n     };\n \n     let expander = match loc.def.kind {\n@@ -512,8 +549,7 @@ fn hygiene_frame(db: &dyn ExpandDatabase, file_id: HirFileId) -> Arc<HygieneFram\n }\n \n fn macro_expand_to(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandTo {\n-    let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n-    loc.kind.expand_to()\n+    db.lookup_intern_macro_call(id).expand_to()\n }\n \n fn token_tree_to_syntax_node("}, {"sha": "59a92ff0ab61253eddb5dfccedebe6483142356b", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/eager.rs", "status": "modified", "additions": 69, "deletions": 133, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -18,10 +18,9 @@\n //!\n //!\n //! See the full discussion : <https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/Eager.20expansion.20of.20built-in.20macros>\n-use std::sync::Arc;\n-\n use base_db::CrateId;\n-use syntax::{ted, SyntaxNode};\n+use syntax::{ted, Parse, SyntaxNode};\n+use triomphe::Arc;\n \n use crate::{\n     ast::{self, AstNode},\n@@ -32,77 +31,16 @@ use crate::{\n     MacroCallLoc, MacroDefId, MacroDefKind, UnresolvedMacro,\n };\n \n-#[derive(Debug)]\n-pub struct ErrorEmitted {\n-    _private: (),\n-}\n-\n-pub trait ErrorSink {\n-    fn emit(&mut self, err: ExpandError);\n-\n-    fn option<T>(\n-        &mut self,\n-        opt: Option<T>,\n-        error: impl FnOnce() -> ExpandError,\n-    ) -> Result<T, ErrorEmitted> {\n-        match opt {\n-            Some(it) => Ok(it),\n-            None => {\n-                self.emit(error());\n-                Err(ErrorEmitted { _private: () })\n-            }\n-        }\n-    }\n-\n-    fn option_with<T>(\n-        &mut self,\n-        opt: impl FnOnce() -> Option<T>,\n-        error: impl FnOnce() -> ExpandError,\n-    ) -> Result<T, ErrorEmitted> {\n-        self.option(opt(), error)\n-    }\n-\n-    fn result<T>(&mut self, res: Result<T, ExpandError>) -> Result<T, ErrorEmitted> {\n-        match res {\n-            Ok(it) => Ok(it),\n-            Err(e) => {\n-                self.emit(e);\n-                Err(ErrorEmitted { _private: () })\n-            }\n-        }\n-    }\n-\n-    fn expand_result_option<T>(&mut self, res: ExpandResult<Option<T>>) -> Result<T, ErrorEmitted> {\n-        match (res.value, res.err) {\n-            (None, Some(err)) => {\n-                self.emit(err);\n-                Err(ErrorEmitted { _private: () })\n-            }\n-            (Some(value), opt_err) => {\n-                if let Some(err) = opt_err {\n-                    self.emit(err);\n-                }\n-                Ok(value)\n-            }\n-            (None, None) => unreachable!(\"`ExpandResult` without value or error\"),\n-        }\n-    }\n-}\n-\n-impl ErrorSink for &'_ mut dyn FnMut(ExpandError) {\n-    fn emit(&mut self, err: ExpandError) {\n-        self(err);\n-    }\n-}\n-\n pub fn expand_eager_macro(\n     db: &dyn ExpandDatabase,\n     krate: CrateId,\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n     resolver: &dyn Fn(ModPath) -> Option<MacroDefId>,\n-    diagnostic_sink: &mut dyn FnMut(ExpandError),\n-) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n+    let MacroDefKind::BuiltInEager(eager, _) = def.kind else {\n+        panic!(\"called `expand_eager_macro` on non-eager macro def {def:?}\")\n+    };\n     let hygiene = Hygiene::new(db, macro_call.file_id);\n     let parsed_args = macro_call\n         .value\n@@ -115,68 +53,62 @@ pub fn expand_eager_macro(\n     let expand_to = ExpandTo::from_call_site(&macro_call.value);\n \n     // Note:\n-    // When `lazy_expand` is called, its *parent* file must be already exists.\n-    // Here we store an eager macro id for the argument expanded subtree here\n+    // When `lazy_expand` is called, its *parent* file must already exist.\n+    // Here we store an eager macro id for the argument expanded subtree\n     // for that purpose.\n     let arg_id = db.intern_macro_call(MacroCallLoc {\n         def,\n         krate,\n-        eager: Some(EagerCallInfo {\n+        eager: Some(Box::new(EagerCallInfo {\n             arg_or_expansion: Arc::new(parsed_args.clone()),\n             included_file: None,\n-        }),\n+            error: None,\n+        })),\n         kind: MacroCallKind::FnLike { ast_id: call_id, expand_to: ExpandTo::Expr },\n     });\n \n     let parsed_args = mbe::token_tree_to_syntax_node(&parsed_args, mbe::TopEntryPoint::Expr).0;\n-    let result = match eager_macro_recur(\n+    let ExpandResult { value, mut err } = eager_macro_recur(\n         db,\n         &hygiene,\n         InFile::new(arg_id.as_file(), parsed_args.syntax_node()),\n         krate,\n         resolver,\n-        diagnostic_sink,\n-    ) {\n-        Ok(Ok(it)) => it,\n-        Ok(Err(err)) => return Ok(Err(err)),\n-        Err(err) => return Err(err),\n+    )?;\n+    let Some(value ) = value else {\n+        return Ok(ExpandResult { value: None, err })\n+    };\n+    let subtree = {\n+        let mut subtree = mbe::syntax_node_to_token_tree(&value).0;\n+        subtree.delimiter = crate::tt::Delimiter::unspecified();\n+        subtree\n     };\n-    let subtree = to_subtree(&result);\n-\n-    if let MacroDefKind::BuiltInEager(eager, _) = def.kind {\n-        let res = eager.expand(db, arg_id, &subtree);\n-        if let Some(err) = res.err {\n-            diagnostic_sink(err);\n-        }\n-\n-        let loc = MacroCallLoc {\n-            def,\n-            krate,\n-            eager: Some(EagerCallInfo {\n-                arg_or_expansion: Arc::new(res.value.subtree),\n-                included_file: res.value.included_file,\n-            }),\n-            kind: MacroCallKind::FnLike { ast_id: call_id, expand_to },\n-        };\n \n-        Ok(Ok(db.intern_macro_call(loc)))\n-    } else {\n-        panic!(\"called `expand_eager_macro` on non-eager macro def {def:?}\");\n+    let res = eager.expand(db, arg_id, &subtree);\n+    if err.is_none() {\n+        err = res.err;\n     }\n-}\n \n-fn to_subtree(node: &SyntaxNode) -> crate::tt::Subtree {\n-    let mut subtree = mbe::syntax_node_to_token_tree(node).0;\n-    subtree.delimiter = crate::tt::Delimiter::unspecified();\n-    subtree\n+    let loc = MacroCallLoc {\n+        def,\n+        krate,\n+        eager: Some(Box::new(EagerCallInfo {\n+            arg_or_expansion: Arc::new(res.value.subtree),\n+            included_file: res.value.included_file,\n+            error: err.clone(),\n+        })),\n+        kind: MacroCallKind::FnLike { ast_id: call_id, expand_to },\n+    };\n+\n+    Ok(ExpandResult { value: Some(db.intern_macro_call(loc)), err })\n }\n \n fn lazy_expand(\n     db: &dyn ExpandDatabase,\n     def: &MacroDefId,\n     macro_call: InFile<ast::MacroCall>,\n     krate: CrateId,\n-) -> ExpandResult<Option<InFile<SyntaxNode>>> {\n+) -> ExpandResult<InFile<Parse<SyntaxNode>>> {\n     let ast_id = db.ast_id_map(macro_call.file_id).ast_id(&macro_call.value);\n \n     let expand_to = ExpandTo::from_call_site(&macro_call.value);\n@@ -186,10 +118,8 @@ fn lazy_expand(\n         MacroCallKind::FnLike { ast_id: macro_call.with_value(ast_id), expand_to },\n     );\n \n-    let err = db.macro_expand_error(id);\n-    let value = db.parse_or_expand(id.as_file()).map(|node| InFile::new(id.as_file(), node));\n-\n-    ExpandResult { value, err }\n+    let file_id = id.as_file();\n+    db.parse_or_expand_with_err(file_id).map(|parse| InFile::new(file_id, parse))\n }\n \n fn eager_macro_recur(\n@@ -198,69 +128,75 @@ fn eager_macro_recur(\n     curr: InFile<SyntaxNode>,\n     krate: CrateId,\n     macro_resolver: &dyn Fn(ModPath) -> Option<MacroDefId>,\n-    mut diagnostic_sink: &mut dyn FnMut(ExpandError),\n-) -> Result<Result<SyntaxNode, ErrorEmitted>, UnresolvedMacro> {\n+) -> Result<ExpandResult<Option<SyntaxNode>>, UnresolvedMacro> {\n     let original = curr.value.clone_for_update();\n \n     let children = original.descendants().filter_map(ast::MacroCall::cast);\n     let mut replacements = Vec::new();\n \n+    // Note: We only report a single error inside of eager expansions\n+    let mut error = None;\n+\n     // Collect replacement\n     for child in children {\n         let def = match child.path().and_then(|path| ModPath::from_src(db, path, hygiene)) {\n             Some(path) => macro_resolver(path.clone()).ok_or(UnresolvedMacro { path })?,\n             None => {\n-                diagnostic_sink(ExpandError::Other(\"malformed macro invocation\".into()));\n+                error = Some(ExpandError::Other(\"malformed macro invocation\".into()));\n                 continue;\n             }\n         };\n-        let insert = match def.kind {\n+        let ExpandResult { value, err } = match def.kind {\n             MacroDefKind::BuiltInEager(..) => {\n                 let id = match expand_eager_macro(\n                     db,\n                     krate,\n                     curr.with_value(child.clone()),\n                     def,\n                     macro_resolver,\n-                    diagnostic_sink,\n                 ) {\n-                    Ok(Ok(it)) => it,\n-                    Ok(Err(err)) => return Ok(Err(err)),\n+                    Ok(it) => it,\n                     Err(err) => return Err(err),\n                 };\n-                db.parse_or_expand(id.as_file())\n-                    .expect(\"successful macro expansion should be parseable\")\n-                    .clone_for_update()\n+                id.map(|call| {\n+                    call.map(|call| db.parse_or_expand(call.as_file()).clone_for_update())\n+                })\n             }\n             MacroDefKind::Declarative(_)\n             | MacroDefKind::BuiltIn(..)\n             | MacroDefKind::BuiltInAttr(..)\n             | MacroDefKind::BuiltInDerive(..)\n             | MacroDefKind::ProcMacro(..) => {\n-                let res = lazy_expand(db, &def, curr.with_value(child.clone()), krate);\n-                let val = match diagnostic_sink.expand_result_option(res) {\n-                    Ok(it) => it,\n-                    Err(err) => return Ok(Err(err)),\n-                };\n+                let ExpandResult { value, err } =\n+                    lazy_expand(db, &def, curr.with_value(child.clone()), krate);\n \n                 // replace macro inside\n-                let hygiene = Hygiene::new(db, val.file_id);\n-                match eager_macro_recur(db, &hygiene, val, krate, macro_resolver, diagnostic_sink) {\n-                    Ok(Ok(it)) => it,\n-                    Ok(Err(err)) => return Ok(Err(err)),\n-                    Err(err) => return Err(err),\n-                }\n+                let hygiene = Hygiene::new(db, value.file_id);\n+                let ExpandResult { value, err: error } = eager_macro_recur(\n+                    db,\n+                    &hygiene,\n+                    // FIXME: We discard parse errors here\n+                    value.map(|it| it.syntax_node()),\n+                    krate,\n+                    macro_resolver,\n+                )?;\n+                let err = if err.is_none() { error } else { err };\n+                ExpandResult { value, err }\n             }\n         };\n-\n+        if err.is_some() {\n+            error = err;\n+        }\n         // check if the whole original syntax is replaced\n         if child.syntax() == &original {\n-            return Ok(Ok(insert));\n+            return Ok(ExpandResult { value, err: error });\n         }\n \n-        replacements.push((child, insert));\n+        if let Some(insert) = value {\n+            replacements.push((child, insert));\n+        }\n     }\n \n     replacements.into_iter().rev().for_each(|(old, new)| ted::replace(old.syntax(), new));\n-    Ok(Ok(original))\n+    Ok(ExpandResult { value: Some(original), err: error })\n }"}, {"sha": "00796e7c0dbb02351967826256098143606a0a8a", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -14,7 +14,7 @@ use tt::token_id::Subtree;\n /// The result of calculating fixes for a syntax node -- a bunch of changes\n /// (appending to and replacing nodes), the information that is needed to\n /// reverse those changes afterwards, and a token map.\n-#[derive(Debug)]\n+#[derive(Debug, Default)]\n pub(crate) struct SyntaxFixups {\n     pub(crate) append: FxHashMap<SyntaxElement, Vec<SyntheticToken>>,\n     pub(crate) replace: FxHashMap<SyntaxElement, Vec<SyntheticToken>>,\n@@ -24,7 +24,7 @@ pub(crate) struct SyntaxFixups {\n }\n \n /// This is the information needed to reverse the fixups.\n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, Default, PartialEq, Eq)]\n pub struct SyntaxFixupUndoInfo {\n     original: Vec<Subtree>,\n }"}, {"sha": "10f8fe9cec428f108f2e4cc001a437bfb62d635f", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/hygiene.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -2,8 +2,6 @@\n //!\n //! Specifically, `ast` + `Hygiene` allows you to create a `Name`. Note that, at\n //! this moment, this is horribly incomplete and handles only `$crate`.\n-use std::sync::Arc;\n-\n use base_db::CrateId;\n use db::TokenExpander;\n use either::Either;\n@@ -12,6 +10,7 @@ use syntax::{\n     ast::{self, HasDocComments},\n     AstNode, SyntaxKind, SyntaxNode, TextRange, TextSize,\n };\n+use triomphe::Arc;\n \n use crate::{\n     db::{self, ExpandDatabase},\n@@ -200,8 +199,14 @@ fn make_hygiene_info(\n     });\n \n     let macro_def = db.macro_def(loc.def).ok()?;\n-    let (_, exp_map) = db.parse_macro_expansion(macro_file).value?;\n-    let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n+    let (_, exp_map) = db.parse_macro_expansion(macro_file).value;\n+    let macro_arg = db.macro_arg(macro_file.macro_call_id).unwrap_or_else(|| {\n+        Arc::new((\n+            tt::Subtree { delimiter: tt::Delimiter::UNSPECIFIED, token_trees: Vec::new() },\n+            Default::default(),\n+            Default::default(),\n+        ))\n+    });\n \n     Some(HygieneInfo {\n         file: macro_file,"}, {"sha": "c8373778d32b0766d07962a452a9e7537f8d12a0", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "modified", "additions": 97, "deletions": 67, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -20,11 +20,13 @@ pub mod mod_path;\n pub mod attrs;\n mod fixup;\n \n+use mbe::TokenMap;\n pub use mbe::{Origin, ValueResult};\n \n use ::tt::token_id as tt;\n+use triomphe::Arc;\n \n-use std::{fmt, hash::Hash, iter, sync::Arc};\n+use std::{fmt, hash::Hash, iter};\n \n use base_db::{\n     impl_intern_key,\n@@ -51,11 +53,11 @@ use crate::{\n \n pub type ExpandResult<T> = ValueResult<T, ExpandError>;\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, PartialEq, Eq, Clone, Hash)]\n pub enum ExpandError {\n     UnresolvedProcMacro(CrateId),\n     Mbe(mbe::ExpandError),\n-    RecursionOverflowPosioned,\n+    RecursionOverflowPoisoned,\n     Other(Box<str>),\n }\n \n@@ -70,7 +72,7 @@ impl fmt::Display for ExpandError {\n         match self {\n             ExpandError::UnresolvedProcMacro(_) => f.write_str(\"unresolved proc-macro\"),\n             ExpandError::Mbe(it) => it.fmt(f),\n-            ExpandError::RecursionOverflowPosioned => {\n+            ExpandError::RecursionOverflowPoisoned => {\n                 f.write_str(\"overflow expanding the original macro\")\n             }\n             ExpandError::Other(it) => f.write_str(it),\n@@ -113,7 +115,7 @@ impl_intern_key!(MacroCallId);\n pub struct MacroCallLoc {\n     pub def: MacroDefId,\n     pub(crate) krate: CrateId,\n-    eager: Option<EagerCallInfo>,\n+    eager: Option<Box<EagerCallInfo>>,\n     pub kind: MacroCallKind,\n }\n \n@@ -139,7 +141,8 @@ pub enum MacroDefKind {\n struct EagerCallInfo {\n     /// NOTE: This can be *either* the expansion result, *or* the argument to the eager macro!\n     arg_or_expansion: Arc<tt::Subtree>,\n-    included_file: Option<FileId>,\n+    included_file: Option<(FileId, TokenMap)>,\n+    error: Option<ExpandError>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -166,8 +169,6 @@ pub enum MacroCallKind {\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n         invoc_attr_index: AttrId,\n-        /// Whether this attribute is the `#[derive]` attribute.\n-        is_derive: bool,\n     },\n }\n \n@@ -205,8 +206,8 @@ impl HirFileId {\n                 HirFileIdRepr::FileId(id) => break id,\n                 HirFileIdRepr::MacroFile(MacroFile { macro_call_id }) => {\n                     let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_call_id);\n-                    file_id = match loc.eager {\n-                        Some(EagerCallInfo { included_file: Some(file), .. }) => file.into(),\n+                    file_id = match loc.eager.as_deref() {\n+                        Some(&EagerCallInfo { included_file: Some((file, _)), .. }) => file.into(),\n                         _ => loc.kind.file_id(),\n                     };\n                 }\n@@ -230,18 +231,17 @@ impl HirFileId {\n     pub fn call_node(self, db: &dyn db::ExpandDatabase) -> Option<InFile<SyntaxNode>> {\n         let macro_file = self.macro_file()?;\n         let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-        Some(loc.kind.to_node(db))\n+        Some(loc.to_node(db))\n     }\n \n     /// If this is a macro call, returns the syntax node of the very first macro call this file resides in.\n     pub fn original_call_node(self, db: &dyn db::ExpandDatabase) -> Option<(FileId, SyntaxNode)> {\n-        let mut call =\n-            db.lookup_intern_macro_call(self.macro_file()?.macro_call_id).kind.to_node(db);\n+        let mut call = db.lookup_intern_macro_call(self.macro_file()?.macro_call_id).to_node(db);\n         loop {\n             match call.file_id.repr() {\n                 HirFileIdRepr::FileId(file_id) => break Some((file_id, call.value)),\n                 HirFileIdRepr::MacroFile(MacroFile { macro_call_id }) => {\n-                    call = db.lookup_intern_macro_call(macro_call_id).kind.to_node(db);\n+                    call = db.lookup_intern_macro_call(macro_call_id).to_node(db);\n                 }\n             }\n         }\n@@ -255,8 +255,14 @@ impl HirFileId {\n         let arg_tt = loc.kind.arg(db)?;\n \n         let macro_def = db.macro_def(loc.def).ok()?;\n-        let (parse, exp_map) = db.parse_macro_expansion(macro_file).value?;\n-        let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n+        let (parse, exp_map) = db.parse_macro_expansion(macro_file).value;\n+        let macro_arg = db.macro_arg(macro_file.macro_call_id).unwrap_or_else(|| {\n+            Arc::new((\n+                tt::Subtree { delimiter: tt::Delimiter::UNSPECIFIED, token_trees: Vec::new() },\n+                Default::default(),\n+                Default::default(),\n+            ))\n+        });\n \n         let def = loc.def.ast_id().left().and_then(|id| {\n             let def_tt = match id.to_node(db) {\n@@ -298,7 +304,7 @@ impl HirFileId {\n         let macro_file = self.macro_file()?;\n         let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n         let attr = match loc.def.kind {\n-            MacroDefKind::BuiltInDerive(..) => loc.kind.to_node(db),\n+            MacroDefKind::BuiltInDerive(..) => loc.to_node(db),\n             _ => return None,\n         };\n         Some(attr.with_value(ast::Attr::cast(attr.value.clone())?))\n@@ -319,7 +325,7 @@ impl HirFileId {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-                matches!(loc.eager, Some(EagerCallInfo { included_file: Some(_), .. }))\n+                matches!(loc.eager.as_deref(), Some(EagerCallInfo { included_file: Some(..), .. }))\n             }\n             _ => false,\n         }\n@@ -342,7 +348,7 @@ impl HirFileId {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-                matches!(loc.kind, MacroCallKind::Attr { is_derive: true, .. })\n+                loc.def.is_attribute_derive()\n             }\n             None => false,\n         }\n@@ -413,22 +419,15 @@ impl MacroDefId {\n             MacroDefKind::BuiltInAttr(..) | MacroDefKind::ProcMacro(_, ProcMacroKind::Attr, _)\n         )\n     }\n-}\n-\n-// FIXME: attribute indices do not account for nested `cfg_attr`\n \n-impl MacroCallKind {\n-    /// Returns the file containing the macro invocation.\n-    fn file_id(&self) -> HirFileId {\n-        match *self {\n-            MacroCallKind::FnLike { ast_id: InFile { file_id, .. }, .. }\n-            | MacroCallKind::Derive { ast_id: InFile { file_id, .. }, .. }\n-            | MacroCallKind::Attr { ast_id: InFile { file_id, .. }, .. } => file_id,\n-        }\n+    pub fn is_attribute_derive(&self) -> bool {\n+        matches!(self.kind, MacroDefKind::BuiltInAttr(expander, ..) if expander.is_derive())\n     }\n+}\n \n+impl MacroCallLoc {\n     pub fn to_node(&self, db: &dyn db::ExpandDatabase) -> InFile<SyntaxNode> {\n-        match self {\n+        match self.kind {\n             MacroCallKind::FnLike { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())\n             }\n@@ -444,23 +443,49 @@ impl MacroCallKind {\n                         .unwrap_or_else(|| it.syntax().clone())\n                 })\n             }\n-            MacroCallKind::Attr { ast_id, is_derive: true, invoc_attr_index, .. } => {\n-                // FIXME: handle `cfg_attr`\n-                ast_id.with_value(ast_id.to_node(db)).map(|it| {\n-                    it.doc_comments_and_attrs()\n-                        .nth(invoc_attr_index.ast_index())\n-                        .and_then(|it| match it {\n-                            Either::Left(attr) => Some(attr.syntax().clone()),\n-                            Either::Right(_) => None,\n-                        })\n-                        .unwrap_or_else(|| it.syntax().clone())\n-                })\n+            MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n+                if self.def.is_attribute_derive() {\n+                    // FIXME: handle `cfg_attr`\n+                    ast_id.with_value(ast_id.to_node(db)).map(|it| {\n+                        it.doc_comments_and_attrs()\n+                            .nth(invoc_attr_index.ast_index())\n+                            .and_then(|it| match it {\n+                                Either::Left(attr) => Some(attr.syntax().clone()),\n+                                Either::Right(_) => None,\n+                            })\n+                            .unwrap_or_else(|| it.syntax().clone())\n+                    })\n+                } else {\n+                    ast_id.with_value(ast_id.to_node(db).syntax().clone())\n+                }\n             }\n-            MacroCallKind::Attr { ast_id, .. } => {\n-                ast_id.with_value(ast_id.to_node(db).syntax().clone())\n+        }\n+    }\n+\n+    fn expand_to(&self) -> ExpandTo {\n+        match self.kind {\n+            MacroCallKind::FnLike { expand_to, .. } => expand_to,\n+            MacroCallKind::Derive { .. } => ExpandTo::Items,\n+            MacroCallKind::Attr { .. } if self.def.is_attribute_derive() => ExpandTo::Statements,\n+            MacroCallKind::Attr { .. } => {\n+                // is this always correct?\n+                ExpandTo::Items\n             }\n         }\n     }\n+}\n+\n+// FIXME: attribute indices do not account for nested `cfg_attr`\n+\n+impl MacroCallKind {\n+    /// Returns the file containing the macro invocation.\n+    fn file_id(&self) -> HirFileId {\n+        match *self {\n+            MacroCallKind::FnLike { ast_id: InFile { file_id, .. }, .. }\n+            | MacroCallKind::Derive { ast_id: InFile { file_id, .. }, .. }\n+            | MacroCallKind::Attr { ast_id: InFile { file_id, .. }, .. } => file_id,\n+        }\n+    }\n \n     /// Returns the original file range that best describes the location of this macro call.\n     ///\n@@ -538,15 +563,6 @@ impl MacroCallKind {\n             MacroCallKind::Attr { ast_id, .. } => Some(ast_id.to_node(db).syntax().clone()),\n         }\n     }\n-\n-    fn expand_to(&self) -> ExpandTo {\n-        match self {\n-            MacroCallKind::FnLike { expand_to, .. } => *expand_to,\n-            MacroCallKind::Derive { .. } => ExpandTo::Items,\n-            MacroCallKind::Attr { is_derive: true, .. } => ExpandTo::Statements,\n-            MacroCallKind::Attr { .. } => ExpandTo::Items, // is this always correct?\n-        }\n-    }\n }\n \n impl MacroCallId {\n@@ -610,7 +626,7 @@ impl ExpansionInfo {\n \n             let token_range = token.value.text_range();\n             match &loc.kind {\n-                MacroCallKind::Attr { attr_args, invoc_attr_index, is_derive, .. } => {\n+                MacroCallKind::Attr { attr_args, invoc_attr_index, .. } => {\n                     // FIXME: handle `cfg_attr`\n                     let attr = item\n                         .doc_comments_and_attrs()\n@@ -626,7 +642,8 @@ impl ExpansionInfo {\n                                 token.value.text_range().checked_sub(attr_input_start)?;\n                             // shift by the item's tree's max id\n                             let token_id = attr_args.1.token_by_range(relative_range)?;\n-                            let token_id = if *is_derive {\n+\n+                            let token_id = if loc.def.is_attribute_derive() {\n                                 // we do not shift for `#[derive]`, as we only need to downmap the derive attribute tokens\n                                 token_id\n                             } else {\n@@ -677,20 +694,31 @@ impl ExpansionInfo {\n         let call_id = self.expanded.file_id.macro_file()?.macro_call_id;\n         let loc = db.lookup_intern_macro_call(call_id);\n \n+        if let Some((file, map)) = loc.eager.and_then(|e| e.included_file) {\n+            // Special case: map tokens from `include!` expansions to the included file\n+            let range = map.first_range_by_token(token_id, token.value.kind())?;\n+            let source = db.parse(file);\n+\n+            let token = source.syntax_node().covering_element(range).into_token()?;\n+\n+            return Some((InFile::new(file.into(), token), Origin::Call));\n+        }\n+\n         // Attributes are a bit special for us, they have two inputs, the input tokentree and the annotated item.\n         let (token_map, tt) = match &loc.kind {\n-            MacroCallKind::Attr { attr_args, is_derive: true, .. } => {\n-                (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n-            }\n             MacroCallKind::Attr { attr_args, .. } => {\n-                // try unshifting the the token id, if unshifting fails, the token resides in the non-item attribute input\n-                // note that the `TokenExpander::map_id_up` earlier only unshifts for declarative macros, so we don't double unshift with this\n-                match self.macro_arg_shift.unshift(token_id) {\n-                    Some(unshifted) => {\n-                        token_id = unshifted;\n-                        (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+                if loc.def.is_attribute_derive() {\n+                    (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+                } else {\n+                    // try unshifting the token id, if unshifting fails, the token resides in the non-item attribute input\n+                    // note that the `TokenExpander::map_id_up` earlier only unshifts for declarative macros, so we don't double unshift with this\n+                    match self.macro_arg_shift.unshift(token_id) {\n+                        Some(unshifted) => {\n+                            token_id = unshifted;\n+                            (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+                        }\n+                        None => (&self.macro_arg.1, self.arg.clone()),\n                     }\n-                    None => (&self.macro_arg.1, self.arg.clone()),\n                 }\n             }\n             _ => match origin {\n@@ -718,7 +746,7 @@ pub type AstId<N> = InFile<FileAstId<N>>;\n \n impl<N: AstNode> AstId<N> {\n     pub fn to_node(&self, db: &dyn db::ExpandDatabase) -> N {\n-        let root = db.parse_or_expand(self.file_id).unwrap();\n+        let root = db.parse_or_expand(self.file_id);\n         db.ast_id_map(self.file_id).get(self.value).to_node(&root)\n     }\n }\n@@ -754,7 +782,7 @@ impl<T> InFile<T> {\n     }\n \n     pub fn file_syntax(&self, db: &dyn db::ExpandDatabase) -> SyntaxNode {\n-        db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n+        db.parse_or_expand(self.file_id)\n     }\n }\n \n@@ -950,6 +978,7 @@ fn ascend_node_border_tokens(\n     let first_token = |node: &SyntaxNode| skip_trivia_token(node.first_token()?, Direction::Next);\n     let last_token = |node: &SyntaxNode| skip_trivia_token(node.last_token()?, Direction::Prev);\n \n+    // FIXME: Once the token map rewrite is done, this shouldnt need to rely on syntax nodes and tokens anymore\n     let first = first_token(node)?;\n     let last = last_token(node)?;\n     let first = ascend_call_token(db, &expansion, InFile::new(file_id, first))?;\n@@ -977,6 +1006,7 @@ impl<N: AstNode> InFile<N> {\n         self.value.syntax().descendants().filter_map(T::cast).map(move |n| self.with_value(n))\n     }\n \n+    // FIXME: this should return `Option<InFileNotHirFile<N>>`\n     pub fn original_ast_node(self, db: &dyn db::ExpandDatabase) -> Option<InFile<N>> {\n         // This kind of upmapping can only be achieved in attribute expanded files,\n         // as we don't have node inputs otherwise and therefore can't find an `N` node in the input"}, {"sha": "47a8ab7de77f94da97801b8f0f9a4518b42a4000", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,7 +1,7 @@\n //! A lowering for `use`-paths (more generally, paths without angle-bracketed segments).\n \n use std::{\n-    fmt::{self, Display},\n+    fmt::{self, Display as _},\n     iter,\n };\n \n@@ -24,6 +24,12 @@ pub struct ModPath {\n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct UnescapedModPath<'a>(&'a ModPath);\n \n+impl<'a> UnescapedModPath<'a> {\n+    pub fn display(&'a self, db: &'a dyn crate::db::ExpandDatabase) -> impl fmt::Display + 'a {\n+        UnescapedDisplay { db, path: self }\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum PathKind {\n     Plain,\n@@ -110,52 +116,30 @@ impl ModPath {\n         UnescapedModPath(self)\n     }\n \n-    fn _fmt(&self, f: &mut fmt::Formatter<'_>, escaped: bool) -> fmt::Result {\n-        let mut first_segment = true;\n-        let mut add_segment = |s| -> fmt::Result {\n-            if !first_segment {\n-                f.write_str(\"::\")?;\n-            }\n-            first_segment = false;\n-            f.write_str(s)?;\n-            Ok(())\n-        };\n-        match self.kind {\n-            PathKind::Plain => {}\n-            PathKind::Super(0) => add_segment(\"self\")?,\n-            PathKind::Super(n) => {\n-                for _ in 0..n {\n-                    add_segment(\"super\")?;\n-                }\n-            }\n-            PathKind::Crate => add_segment(\"crate\")?,\n-            PathKind::Abs => add_segment(\"\")?,\n-            PathKind::DollarCrate(_) => add_segment(\"$crate\")?,\n-        }\n-        for segment in &self.segments {\n-            if !first_segment {\n-                f.write_str(\"::\")?;\n-            }\n-            first_segment = false;\n-            if escaped {\n-                segment.fmt(f)?\n-            } else {\n-                segment.unescaped().fmt(f)?\n-            };\n-        }\n-        Ok(())\n+    pub fn display<'a>(&'a self, db: &'a dyn crate::db::ExpandDatabase) -> impl fmt::Display + 'a {\n+        Display { db, path: self }\n     }\n }\n \n-impl Display for ModPath {\n+struct Display<'a> {\n+    db: &'a dyn ExpandDatabase,\n+    path: &'a ModPath,\n+}\n+\n+impl<'a> fmt::Display for Display<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self._fmt(f, true)\n+        display_fmt_path(self.db, self.path, f, true)\n     }\n }\n \n-impl<'a> Display for UnescapedModPath<'a> {\n+struct UnescapedDisplay<'a> {\n+    db: &'a dyn ExpandDatabase,\n+    path: &'a UnescapedModPath<'a>,\n+}\n+\n+impl<'a> fmt::Display for UnescapedDisplay<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0._fmt(f, false)\n+        display_fmt_path(self.db, self.path.0, f, false)\n     }\n }\n \n@@ -164,6 +148,46 @@ impl From<Name> for ModPath {\n         ModPath::from_segments(PathKind::Plain, iter::once(name))\n     }\n }\n+fn display_fmt_path(\n+    db: &dyn ExpandDatabase,\n+    path: &ModPath,\n+    f: &mut fmt::Formatter<'_>,\n+    escaped: bool,\n+) -> fmt::Result {\n+    let mut first_segment = true;\n+    let mut add_segment = |s| -> fmt::Result {\n+        if !first_segment {\n+            f.write_str(\"::\")?;\n+        }\n+        first_segment = false;\n+        f.write_str(s)?;\n+        Ok(())\n+    };\n+    match path.kind {\n+        PathKind::Plain => {}\n+        PathKind::Super(0) => add_segment(\"self\")?,\n+        PathKind::Super(n) => {\n+            for _ in 0..n {\n+                add_segment(\"super\")?;\n+            }\n+        }\n+        PathKind::Crate => add_segment(\"crate\")?,\n+        PathKind::Abs => add_segment(\"\")?,\n+        PathKind::DollarCrate(_) => add_segment(\"$crate\")?,\n+    }\n+    for segment in &path.segments {\n+        if !first_segment {\n+            f.write_str(\"::\")?;\n+        }\n+        first_segment = false;\n+        if escaped {\n+            segment.display(db).fmt(f)?;\n+        } else {\n+            segment.unescaped().display(db).fmt(f)?;\n+        }\n+    }\n+    Ok(())\n+}\n \n fn convert_path(\n     db: &dyn ExpandDatabase,"}, {"sha": "f8dbb842775c33a8773bdc1be47a1a8ac1d26601", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/name.rs", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -24,27 +24,6 @@ enum Repr {\n     TupleField(usize),\n }\n \n-impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.0 {\n-            Repr::Text(text) => fmt::Display::fmt(&text, f),\n-            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n-        }\n-    }\n-}\n-\n-impl<'a> fmt::Display for UnescapedName<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.0 .0 {\n-            Repr::Text(text) => {\n-                let text = text.strip_prefix(\"r#\").unwrap_or(text);\n-                fmt::Display::fmt(&text, f)\n-            }\n-            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n-        }\n-    }\n-}\n-\n impl<'a> UnescapedName<'a> {\n     /// Returns the textual representation of this name as a [`SmolStr`]. Prefer using this over\n     /// [`ToString::to_string`] if possible as this conversion is cheaper in the general case.\n@@ -60,6 +39,11 @@ impl<'a> UnescapedName<'a> {\n             Repr::TupleField(it) => SmolStr::new(it.to_string()),\n         }\n     }\n+\n+    pub fn display(&'a self, db: &dyn crate::db::ExpandDatabase) -> impl fmt::Display + 'a {\n+        _ = db;\n+        UnescapedDisplay { name: self }\n+    }\n }\n \n impl Name {\n@@ -78,7 +62,7 @@ impl Name {\n         Self::new_text(lt.text().into())\n     }\n \n-    /// Shortcut to create inline plain text name\n+    /// Shortcut to create inline plain text name. Panics if `text.len() > 22`\n     const fn new_inline(text: &str) -> Name {\n         Name::new_text(SmolStr::new_inline(text))\n     }\n@@ -112,6 +96,17 @@ impl Name {\n         Name::new_inline(\"[missing name]\")\n     }\n \n+    /// Generates a new name which is only equal to itself, by incrementing a counter. Due\n+    /// its implementation, it should not be used in things that salsa considers, like\n+    /// type names or field names, and it should be only used in names of local variables\n+    /// and labels and similar things.\n+    pub fn generate_new_name() -> Name {\n+        use std::sync::atomic::{AtomicUsize, Ordering};\n+        static CNT: AtomicUsize = AtomicUsize::new(0);\n+        let c = CNT.fetch_add(1, Ordering::Relaxed);\n+        Name::new_text(format!(\"<ra@gennew>{c}\").into())\n+    }\n+\n     /// Returns the tuple index this name represents if it is a tuple field.\n     pub fn as_tuple_index(&self) -> Option<usize> {\n         match self.0 {\n@@ -156,6 +151,40 @@ impl Name {\n             Repr::TupleField(_) => false,\n         }\n     }\n+\n+    pub fn display<'a>(&'a self, db: &dyn crate::db::ExpandDatabase) -> impl fmt::Display + 'a {\n+        _ = db;\n+        Display { name: self }\n+    }\n+}\n+\n+struct Display<'a> {\n+    name: &'a Name,\n+}\n+\n+impl<'a> fmt::Display for Display<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match &self.name.0 {\n+            Repr::Text(text) => fmt::Display::fmt(&text, f),\n+            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n+        }\n+    }\n+}\n+\n+struct UnescapedDisplay<'a> {\n+    name: &'a UnescapedName<'a>,\n+}\n+\n+impl<'a> fmt::Display for UnescapedDisplay<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match &self.name.0 .0 {\n+            Repr::Text(text) => {\n+                let text = text.strip_prefix(\"r#\").unwrap_or(text);\n+                fmt::Display::fmt(&text, f)\n+            }\n+            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n+        }\n+    }\n }\n \n pub trait AsName {\n@@ -337,18 +366,24 @@ pub mod known {\n         crate_type,\n         derive,\n         global_allocator,\n+        no_core,\n+        no_std,\n         test,\n         test_case,\n         recursion_limit,\n         feature,\n         // known methods of lang items\n         call_once,\n+        call_mut,\n+        call,\n         eq,\n         ne,\n         ge,\n         gt,\n         le,\n         lt,\n+        // known fields of lang items\n+        pieces,\n         // lang items\n         add_assign,\n         add,\n@@ -363,6 +398,7 @@ pub mod known {\n         deref,\n         div_assign,\n         div,\n+        drop,\n         fn_mut,\n         fn_once,\n         future_trait,"}, {"sha": "c9539210abf657cf7bd55a6be2a8b65c281e186a", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/proc_macro.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -7,20 +7,23 @@ use crate::{db::ExpandDatabase, tt, ExpandError, ExpandResult};\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n-    proc_macro_id: Option<ProcMacroId>,\n+    proc_macro_id: ProcMacroId,\n }\n \n+const DUMMY_ID: u32 = !0;\n+\n impl ProcMacroExpander {\n     pub fn new(proc_macro_id: ProcMacroId) -> Self {\n-        Self { proc_macro_id: Some(proc_macro_id) }\n+        assert_ne!(proc_macro_id.0, DUMMY_ID);\n+        Self { proc_macro_id }\n     }\n \n     pub fn dummy() -> Self {\n-        Self { proc_macro_id: None }\n+        Self { proc_macro_id: ProcMacroId(DUMMY_ID) }\n     }\n \n     pub fn is_dummy(&self) -> bool {\n-        self.proc_macro_id.is_none()\n+        self.proc_macro_id.0 == DUMMY_ID\n     }\n \n     pub fn expand(\n@@ -32,33 +35,37 @@ impl ProcMacroExpander {\n         attr_arg: Option<&tt::Subtree>,\n     ) -> ExpandResult<tt::Subtree> {\n         match self.proc_macro_id {\n-            Some(id) => {\n-                let krate_graph = db.crate_graph();\n-                let proc_macros = match &krate_graph[def_crate].proc_macro {\n-                    Ok(proc_macros) => proc_macros,\n-                    Err(_) => {\n+            ProcMacroId(DUMMY_ID) => {\n+                ExpandResult::new(tt::Subtree::empty(), ExpandError::UnresolvedProcMacro(def_crate))\n+            }\n+            ProcMacroId(id) => {\n+                let proc_macros = db.proc_macros();\n+                let proc_macros = match proc_macros.get(&def_crate) {\n+                    Some(Ok(proc_macros)) => proc_macros,\n+                    Some(Err(_)) | None => {\n                         never!(\"Non-dummy expander even though there are no proc macros\");\n-                        return ExpandResult::with_err(\n+                        return ExpandResult::new(\n                             tt::Subtree::empty(),\n                             ExpandError::Other(\"Internal error\".into()),\n                         );\n                     }\n                 };\n-                let proc_macro = match proc_macros.get(id.0 as usize) {\n+                let proc_macro = match proc_macros.get(id as usize) {\n                     Some(proc_macro) => proc_macro,\n                     None => {\n                         never!(\n                             \"Proc macro index out of bounds: the length is {} but the index is {}\",\n                             proc_macros.len(),\n-                            id.0\n+                            id\n                         );\n-                        return ExpandResult::with_err(\n+                        return ExpandResult::new(\n                             tt::Subtree::empty(),\n                             ExpandError::Other(\"Internal error\".into()),\n                         );\n                     }\n                 };\n \n+                let krate_graph = db.crate_graph();\n                 // Proc macros have access to the environment variables of the invoking crate.\n                 let env = &krate_graph[calling_crate].env;\n                 match proc_macro.expander.expand(tt, attr_arg, env) {\n@@ -74,17 +81,12 @@ impl ProcMacroExpander {\n                             }\n                         }\n                         ProcMacroExpansionError::System(text)\n-                        | ProcMacroExpansionError::Panic(text) => ExpandResult::with_err(\n-                            tt::Subtree::empty(),\n-                            ExpandError::Other(text.into()),\n-                        ),\n+                        | ProcMacroExpansionError::Panic(text) => {\n+                            ExpandResult::new(tt::Subtree::empty(), ExpandError::Other(text.into()))\n+                        }\n                     },\n                 }\n             }\n-            None => ExpandResult::with_err(\n-                tt::Subtree::empty(),\n-                ExpandError::UnresolvedProcMacro(def_crate),\n-            ),\n         }\n     }\n }"}, {"sha": "ab3809abc7a26a390eb73a8a81eccec124abe312", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/quote.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -162,6 +162,12 @@ impl ToTokenTree for crate::tt::TokenTree {\n     }\n }\n \n+impl ToTokenTree for &crate::tt::TokenTree {\n+    fn to_token(self) -> crate::tt::TokenTree {\n+        self.clone()\n+    }\n+}\n+\n impl ToTokenTree for crate::tt::Subtree {\n     fn to_token(self) -> crate::tt::TokenTree {\n         self.into()"}, {"sha": "6ca0dbb850399b8dfe1428d6819e4109a69616fb", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -15,7 +15,7 @@ doctest = false\n cov-mark = \"2.0.0-pre.1\"\n itertools = \"0.10.5\"\n arrayvec = \"0.7.2\"\n-bitflags = \"1.3.2\"\n+bitflags = \"2.1.0\"\n smallvec.workspace = true\n ena = \"0.14.0\"\n either = \"1.7.0\"\n@@ -28,6 +28,8 @@ chalk-recursive = { version = \"0.89.0\", default-features = false }\n chalk-derive = \"0.89.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.17.0\"\n+triomphe.workspace = true\n+nohash-hasher.workspace = true\n typed-arena = \"2.0.1\"\n rustc_index = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_index\", default-features = false }\n "}, {"sha": "f5b3f176b12e5a4fb50a44c57d6d3ecae32a78bf", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -3,12 +3,11 @@\n //! reference to a type with the field `bar`. This is an approximation of the\n //! logic in rustc (which lives in rustc_hir_analysis/check/autoderef.rs).\n \n-use std::sync::Arc;\n-\n use chalk_ir::cast::Cast;\n use hir_def::lang_item::LangItem;\n use hir_expand::name::name;\n use limit::Limit;\n+use triomphe::Arc;\n \n use crate::{\n     db::HirDatabase, infer::unify::InferenceTable, Canonical, Goal, Interner, ProjectionTyExt,\n@@ -23,6 +22,21 @@ pub(crate) enum AutoderefKind {\n     Overloaded,\n }\n \n+pub fn autoderef(\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    ty: Canonical<Ty>,\n+) -> impl Iterator<Item = Canonical<Ty>> + '_ {\n+    let mut table = InferenceTable::new(db, env);\n+    let ty = table.instantiate_canonical(ty);\n+    let mut autoderef = Autoderef::new(&mut table, ty);\n+    let mut v = Vec::new();\n+    while let Some((ty, _steps)) = autoderef.next() {\n+        v.push(autoderef.table.canonicalize(ty).value);\n+    }\n+    v.into_iter()\n+}\n+\n #[derive(Debug)]\n pub(crate) struct Autoderef<'a, 'db> {\n     pub(crate) table: &'a mut InferenceTable<'db>,\n@@ -76,49 +90,43 @@ pub(crate) fn autoderef_step(\n     table: &mut InferenceTable<'_>,\n     ty: Ty,\n ) -> Option<(AutoderefKind, Ty)> {\n-    if let Some(derefed) = builtin_deref(&ty) {\n+    if let Some(derefed) = builtin_deref(table, &ty, false) {\n         Some((AutoderefKind::Builtin, table.resolve_ty_shallow(derefed)))\n     } else {\n         Some((AutoderefKind::Overloaded, deref_by_trait(table, ty)?))\n     }\n }\n \n-// FIXME: replace uses of this with Autoderef above\n-pub fn autoderef(\n-    db: &dyn HirDatabase,\n-    env: Arc<TraitEnvironment>,\n-    ty: Canonical<Ty>,\n-) -> impl Iterator<Item = Canonical<Ty>> + '_ {\n-    let mut table = InferenceTable::new(db, env);\n-    let ty = table.instantiate_canonical(ty);\n-    let mut autoderef = Autoderef::new(&mut table, ty);\n-    let mut v = Vec::new();\n-    while let Some((ty, _steps)) = autoderef.next() {\n-        v.push(autoderef.table.canonicalize(ty).value);\n-    }\n-    v.into_iter()\n-}\n-\n-pub(crate) fn deref(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n-    let _p = profile::span(\"deref\");\n-    autoderef_step(table, ty).map(|(_, ty)| ty)\n-}\n-\n-fn builtin_deref(ty: &Ty) -> Option<&Ty> {\n+pub(crate) fn builtin_deref<'ty>(\n+    table: &mut InferenceTable<'_>,\n+    ty: &'ty Ty,\n+    explicit: bool,\n+) -> Option<&'ty Ty> {\n     match ty.kind(Interner) {\n-        TyKind::Ref(.., ty) | TyKind::Raw(.., ty) => Some(ty),\n+        TyKind::Ref(.., ty) => Some(ty),\n+        // FIXME: Maybe accept this but diagnose if its not explicit?\n+        TyKind::Raw(.., ty) if explicit => Some(ty),\n+        &TyKind::Adt(chalk_ir::AdtId(adt), ref substs) => {\n+            if crate::lang_items::is_box(table.db, adt) {\n+                substs.at(Interner, 0).ty(Interner)\n+            } else {\n+                None\n+            }\n+        }\n         _ => None,\n     }\n }\n \n-fn deref_by_trait(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n+pub(crate) fn deref_by_trait(\n+    table @ &mut InferenceTable { db, .. }: &mut InferenceTable<'_>,\n+    ty: Ty,\n+) -> Option<Ty> {\n     let _p = profile::span(\"deref_by_trait\");\n     if table.resolve_ty_shallow(&ty).inference_var(Interner).is_some() {\n         // don't try to deref unknown variables\n         return None;\n     }\n \n-    let db = table.db;\n     let deref_trait =\n         db.lang_item(table.trait_env.krate, LangItem::Deref).and_then(|l| l.as_trait())?;\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;"}, {"sha": "eec57ba3f80f15c88b9b343c66782e803e2a2792", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/builder.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -18,7 +18,6 @@ use crate::{\n     consteval::unknown_const_as_generic, db::HirDatabase, infer::unify::InferenceTable, primitive,\n     to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, BoundVar, CallableSig,\n     GenericArg, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt, TyKind,\n-    ValueTyDefId,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -195,6 +194,19 @@ impl TyBuilder<()> {\n         params.placeholder_subst(db)\n     }\n \n+    pub fn unknown_subst(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substitution {\n+        let params = generics(db.upcast(), def.into());\n+        Substitution::from_iter(\n+            Interner,\n+            params.iter_id().map(|id| match id {\n+                either::Either::Left(_) => TyKind::Error.intern(Interner).cast(Interner),\n+                either::Either::Right(id) => {\n+                    unknown_const_as_generic(db.const_param_ty(id)).cast(Interner)\n+                }\n+            }),\n+        )\n+    }\n+\n     pub fn subst_for_def(\n         db: &dyn HirDatabase,\n         def: impl Into<GenericDefId>,\n@@ -233,6 +245,25 @@ impl TyBuilder<()> {\n         TyBuilder::new((), params, parent_subst)\n     }\n \n+    pub fn subst_for_closure(\n+        db: &dyn HirDatabase,\n+        parent: DefWithBodyId,\n+        sig_ty: Ty,\n+    ) -> Substitution {\n+        let sig_ty = sig_ty.cast(Interner);\n+        let self_subst = iter::once(&sig_ty);\n+        let Some(parent) = parent.as_generic_def_id() else {\n+            return Substitution::from_iter(Interner, self_subst);\n+        };\n+        Substitution::from_iter(\n+            Interner,\n+            self_subst\n+                .chain(generics(db.upcast(), parent).placeholder_subst(db).iter(Interner))\n+                .cloned()\n+                .collect::<Vec<_>>(),\n+        )\n+    }\n+\n     pub fn build(self) -> Substitution {\n         let ((), subst) = self.build_internal();\n         subst\n@@ -362,21 +393,4 @@ impl TyBuilder<Binders<Ty>> {\n     pub fn impl_self_ty(db: &dyn HirDatabase, def: hir_def::ImplId) -> TyBuilder<Binders<Ty>> {\n         TyBuilder::subst_for_def(db, def, None).with_data(db.impl_self_ty(def))\n     }\n-\n-    pub fn value_ty(\n-        db: &dyn HirDatabase,\n-        def: ValueTyDefId,\n-        parent_subst: Option<Substitution>,\n-    ) -> TyBuilder<Binders<Ty>> {\n-        let poly_value_ty = db.value_ty(def);\n-        let id = match def.to_generic_def_id() {\n-            Some(id) => id,\n-            None => {\n-                // static items\n-                assert!(parent_subst.is_none());\n-                return TyBuilder::new_empty(poly_value_ty);\n-            }\n-        };\n-        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_value_ty)\n-    }\n }"}, {"sha": "ac962c9e3e1f07602f1250f61d8e32f8d5d09a20", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 85, "deletions": 60, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,18 +1,18 @@\n //! The implementation of `RustIrDatabase` for Chalk, which provides information\n //! about the code that Chalk needs.\n-use std::sync::Arc;\n+use core::ops;\n+use std::{iter, sync::Arc};\n \n-use cov_mark::hit;\n use tracing::debug;\n \n use chalk_ir::{cast::Cast, fold::shift::Shift, CanonicalVarKinds};\n use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n use base_db::CrateId;\n use hir_def::{\n-    expr::Movability,\n+    hir::Movability,\n     lang_item::{lang_attr, LangItem, LangItemTarget},\n-    AssocItemId, GenericDefId, HasModule, ItemContainerId, Lookup, ModuleId, TypeAliasId,\n+    AssocItemId, BlockId, GenericDefId, HasModule, ItemContainerId, Lookup, TypeAliasId,\n };\n use hir_expand::name::name;\n \n@@ -25,7 +25,7 @@ use crate::{\n     method_resolution::{TraitImpls, TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::ChalkContext,\n-    utils::generics,\n+    utils::{generics, ClosureSubst},\n     wrap_empty_binders, AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId,\n     Interner, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Substitution, TraitRef,\n     TraitRefExt, Ty, TyBuilder, TyExt, TyKind, WhereClause,\n@@ -108,17 +108,6 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             _ => self_ty_fp.as_ref().map(std::slice::from_ref).unwrap_or(&[]),\n         };\n \n-        fn local_impls(db: &dyn HirDatabase, module: ModuleId) -> Option<Arc<TraitImpls>> {\n-            let block = module.containing_block()?;\n-            hit!(block_local_impls);\n-            db.trait_impls_in_block(block)\n-        }\n-\n-        // Note: Since we're using impls_for_trait, only impls where the trait\n-        // can be resolved should ever reach Chalk. impl_datum relies on that\n-        // and will panic if the trait can't be resolved.\n-        let in_deps = self.db.trait_impls_in_deps(self.krate);\n-        let in_self = self.db.trait_impls_in_crate(self.krate);\n         let trait_module = trait_.module(self.db.upcast());\n         let type_module = match self_ty_fp {\n             Some(TyFingerprint::Adt(adt_id)) => Some(adt_id.module(self.db.upcast())),\n@@ -128,33 +117,62 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             Some(TyFingerprint::Dyn(trait_id)) => Some(trait_id.module(self.db.upcast())),\n             _ => None,\n         };\n-        let impl_maps = [\n-            Some(in_deps),\n-            Some(in_self),\n-            local_impls(self.db, trait_module),\n-            type_module.and_then(|m| local_impls(self.db, m)),\n-        ];\n \n-        let id_to_chalk = |id: hir_def::ImplId| id.to_chalk(self.db);\n+        let mut def_blocks =\n+            [trait_module.containing_block(), type_module.and_then(|it| it.containing_block())];\n \n-        let result: Vec<_> = if fps.is_empty() {\n-            debug!(\"Unrestricted search for {:?} impls...\", trait_);\n-            impl_maps\n-                .iter()\n-                .filter_map(|o| o.as_ref())\n-                .flat_map(|impls| impls.for_trait(trait_).map(id_to_chalk))\n-                .collect()\n-        } else {\n-            impl_maps\n-                .iter()\n-                .filter_map(|o| o.as_ref())\n-                .flat_map(|impls| {\n-                    fps.iter().flat_map(move |fp| {\n-                        impls.for_trait_and_self_ty(trait_, *fp).map(id_to_chalk)\n-                    })\n-                })\n-                .collect()\n-        };\n+        // Note: Since we're using impls_for_trait, only impls where the trait\n+        // can be resolved should ever reach Chalk. impl_datum relies on that\n+        // and will panic if the trait can't be resolved.\n+        let in_deps = self.db.trait_impls_in_deps(self.krate);\n+        let in_self = self.db.trait_impls_in_crate(self.krate);\n+\n+        let block_impls = iter::successors(self.block, |&block_id| {\n+            cov_mark::hit!(block_local_impls);\n+            self.db.block_def_map(block_id).parent().and_then(|module| module.containing_block())\n+        })\n+        .inspect(|&block_id| {\n+            // make sure we don't search the same block twice\n+            def_blocks.iter_mut().for_each(|block| {\n+                if *block == Some(block_id) {\n+                    *block = None;\n+                }\n+            });\n+        })\n+        .map(|block_id| self.db.trait_impls_in_block(block_id));\n+\n+        let id_to_chalk = |id: hir_def::ImplId| id.to_chalk(self.db);\n+        let mut result = vec![];\n+        match fps {\n+            [] => {\n+                debug!(\"Unrestricted search for {:?} impls...\", trait_);\n+                let mut f = |impls: &TraitImpls| {\n+                    result.extend(impls.for_trait(trait_).map(id_to_chalk));\n+                };\n+                f(&in_self);\n+                in_deps.iter().map(ops::Deref::deref).for_each(&mut f);\n+                block_impls.for_each(|it| f(&it));\n+                def_blocks\n+                    .into_iter()\n+                    .flatten()\n+                    .for_each(|it| f(&self.db.trait_impls_in_block(it)));\n+            }\n+            fps => {\n+                let mut f =\n+                    |impls: &TraitImpls| {\n+                        result.extend(fps.iter().flat_map(|fp| {\n+                            impls.for_trait_and_self_ty(trait_, *fp).map(id_to_chalk)\n+                        }));\n+                    };\n+                f(&in_self);\n+                in_deps.iter().map(ops::Deref::deref).for_each(&mut f);\n+                block_impls.for_each(|it| f(&it));\n+                def_blocks\n+                    .into_iter()\n+                    .flatten()\n+                    .for_each(|it| f(&self.db.trait_impls_in_block(it)));\n+            }\n+        }\n \n         debug!(\"impls_for_trait returned {} impls\", result.len());\n         result\n@@ -193,7 +211,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         &self,\n         environment: &chalk_ir::Environment<Interner>,\n     ) -> chalk_ir::ProgramClauses<Interner> {\n-        self.db.program_clauses_for_chalk_env(self.krate, environment.clone())\n+        self.db.program_clauses_for_chalk_env(self.krate, self.block, environment.clone())\n     }\n \n     fn opaque_ty_data(&self, id: chalk_ir::OpaqueTyId<Interner>) -> Arc<OpaqueTyDatum> {\n@@ -321,7 +339,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<rust_ir::FnDefInputsAndOutputDatum<Interner>> {\n-        let sig_ty = substs.at(Interner, 0).assert_ty_ref(Interner).clone();\n+        let sig_ty = ClosureSubst(substs).sig_ty();\n         let sig = &sig_ty.callable_sig(self.db).expect(\"first closure param should be fn ptr\");\n         let io = rust_ir::FnDefInputsAndOutputDatum {\n             argument_types: sig.params().to_vec(),\n@@ -347,13 +365,19 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n \n     fn trait_name(&self, trait_id: chalk_ir::TraitId<Interner>) -> String {\n         let id = from_chalk_trait_id(trait_id);\n-        self.db.trait_data(id).name.to_string()\n+        self.db.trait_data(id).name.display(self.db.upcast()).to_string()\n     }\n     fn adt_name(&self, chalk_ir::AdtId(adt_id): AdtId) -> String {\n         match adt_id {\n-            hir_def::AdtId::StructId(id) => self.db.struct_data(id).name.to_string(),\n-            hir_def::AdtId::EnumId(id) => self.db.enum_data(id).name.to_string(),\n-            hir_def::AdtId::UnionId(id) => self.db.union_data(id).name.to_string(),\n+            hir_def::AdtId::StructId(id) => {\n+                self.db.struct_data(id).name.display(self.db.upcast()).to_string()\n+            }\n+            hir_def::AdtId::EnumId(id) => {\n+                self.db.enum_data(id).name.display(self.db.upcast()).to_string()\n+            }\n+            hir_def::AdtId::UnionId(id) => {\n+                self.db.union_data(id).name.display(self.db.upcast()).to_string()\n+            }\n         }\n     }\n     fn adt_size_align(&self, _id: chalk_ir::AdtId<Interner>) -> Arc<rust_ir::AdtSizeAlign> {\n@@ -362,7 +386,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n     fn assoc_type_name(&self, assoc_ty_id: chalk_ir::AssocTypeId<Interner>) -> String {\n         let id = self.db.associated_ty_data(assoc_ty_id).name;\n-        self.db.type_alias_data(id).name.to_string()\n+        self.db.type_alias_data(id).name.display(self.db.upcast()).to_string()\n     }\n     fn opaque_type_name(&self, opaque_ty_id: chalk_ir::OpaqueTyId<Interner>) -> String {\n         format!(\"Opaque_{}\", opaque_ty_id.0)\n@@ -373,7 +397,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn generator_datum(\n         &self,\n         id: chalk_ir::GeneratorId<Interner>,\n-    ) -> std::sync::Arc<chalk_solve::rust_ir::GeneratorDatum<Interner>> {\n+    ) -> Arc<chalk_solve::rust_ir::GeneratorDatum<Interner>> {\n         let (parent, expr) = self.db.lookup_intern_generator(id.into());\n \n         // We fill substitution with unknown type, because we only need to know whether the generic\n@@ -398,8 +422,8 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         let input_output = crate::make_type_and_const_binders(it, input_output);\n \n         let movability = match self.db.body(parent)[expr] {\n-            hir_def::expr::Expr::Closure {\n-                closure_kind: hir_def::expr::ClosureKind::Generator(movability),\n+            hir_def::hir::Expr::Closure {\n+                closure_kind: hir_def::hir::ClosureKind::Generator(movability),\n                 ..\n             } => movability,\n             _ => unreachable!(\"non generator expression interned as generator\"),\n@@ -414,7 +438,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn generator_witness_datum(\n         &self,\n         id: chalk_ir::GeneratorId<Interner>,\n-    ) -> std::sync::Arc<chalk_solve::rust_ir::GeneratorWitnessDatum<Interner>> {\n+    ) -> Arc<chalk_solve::rust_ir::GeneratorWitnessDatum<Interner>> {\n         // FIXME: calculate inner types\n         let inner_types =\n             rust_ir::GeneratorWitnessExistential { types: wrap_empty_binders(vec![]) };\n@@ -435,7 +459,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n }\n \n-impl<'a> chalk_ir::UnificationDatabase<Interner> for &'a dyn HirDatabase {\n+impl chalk_ir::UnificationDatabase<Interner> for &dyn HirDatabase {\n     fn fn_def_variance(\n         &self,\n         fn_def_id: chalk_ir::FnDefId<Interner>,\n@@ -451,9 +475,10 @@ impl<'a> chalk_ir::UnificationDatabase<Interner> for &'a dyn HirDatabase {\n pub(crate) fn program_clauses_for_chalk_env_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n+    block: Option<BlockId>,\n     environment: chalk_ir::Environment<Interner>,\n ) -> chalk_ir::ProgramClauses<Interner> {\n-    chalk_solve::program_clauses_for_env(&ChalkContext { db, krate }, &environment)\n+    chalk_solve::program_clauses_for_env(&ChalkContext { db, krate, block }, &environment)\n }\n \n pub(crate) fn associated_ty_data_query(\n@@ -786,17 +811,17 @@ pub(crate) fn adt_variance_query(\n     )\n }\n \n+/// Returns instantiated predicates.\n pub(super) fn convert_where_clauses(\n     db: &dyn HirDatabase,\n     def: GenericDefId,\n     substs: &Substitution,\n ) -> Vec<chalk_ir::QuantifiedWhereClause<Interner>> {\n-    let generic_predicates = db.generic_predicates(def);\n-    let mut result = Vec::with_capacity(generic_predicates.len());\n-    for pred in generic_predicates.iter() {\n-        result.push(pred.clone().substitute(Interner, substs));\n-    }\n-    result\n+    db.generic_predicates(def)\n+        .iter()\n+        .cloned()\n+        .map(|pred| pred.substitute(Interner, substs))\n+        .collect()\n }\n \n pub(super) fn generic_predicate_to_inline_bound("}, {"sha": "a8071591adac99e11e1fa1d9dc1e05d40506dbf3", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,24 +1,28 @@\n //! Various extensions traits for Chalk types.\n \n-use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, TyVariableKind, UintTy};\n+use chalk_ir::{cast::Cast, FloatTy, IntTy, Mutability, Scalar, TyVariableKind, UintTy};\n use hir_def::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType, BuiltinUint},\n     generics::TypeOrConstParamData,\n     lang_item::LangItem,\n     type_ref::Rawness,\n-    FunctionId, GenericDefId, HasModule, ItemContainerId, Lookup, TraitId,\n+    DefWithBodyId, FunctionId, GenericDefId, HasModule, ItemContainerId, Lookup, TraitId,\n };\n \n use crate::{\n-    db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n-    from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n-    CallableDefId, CallableSig, DynTy, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n+    db::HirDatabase,\n+    from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id, from_placeholder_idx,\n+    to_chalk_trait_id,\n+    utils::{generics, ClosureSubst},\n+    AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Canonical, CanonicalVarKinds,\n+    ClosureId, DynTy, FnPointer, ImplTraitId, InEnvironment, Interner, Lifetime, ProjectionTy,\n     QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags, WhereClause,\n };\n \n pub trait TyExt {\n     fn is_unit(&self) -> bool;\n     fn is_integral(&self) -> bool;\n+    fn is_scalar(&self) -> bool;\n     fn is_floating_point(&self) -> bool;\n     fn is_never(&self) -> bool;\n     fn is_unknown(&self) -> bool;\n@@ -28,8 +32,10 @@ pub trait TyExt {\n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)>;\n     fn as_builtin(&self) -> Option<BuiltinType>;\n     fn as_tuple(&self) -> Option<&Substitution>;\n+    fn as_closure(&self) -> Option<ClosureId>;\n     fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId>;\n     fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)>;\n+    fn as_raw_ptr(&self) -> Option<(&Ty, Mutability)>;\n     fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)>;\n     fn as_generic_def(&self, db: &dyn HirDatabase) -> Option<GenericDefId>;\n \n@@ -44,6 +50,7 @@ pub trait TyExt {\n \n     fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<QuantifiedWhereClause>>;\n     fn associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<TraitId>;\n+    fn is_copy(self, db: &dyn HirDatabase, owner: DefWithBodyId) -> bool;\n \n     /// FIXME: Get rid of this, it's not a good abstraction\n     fn equals_ctor(&self, other: &Ty) -> bool;\n@@ -62,6 +69,10 @@ impl TyExt for Ty {\n         )\n     }\n \n+    fn is_scalar(&self) -> bool {\n+        matches!(self.kind(Interner), TyKind::Scalar(_))\n+    }\n+\n     fn is_floating_point(&self) -> bool {\n         matches!(\n             self.kind(Interner),\n@@ -128,19 +139,34 @@ impl TyExt for Ty {\n         }\n     }\n \n+    fn as_closure(&self) -> Option<ClosureId> {\n+        match self.kind(Interner) {\n+            TyKind::Closure(id, _) => Some(*id),\n+            _ => None,\n+        }\n+    }\n+\n     fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId> {\n         match self.callable_def(db) {\n             Some(CallableDefId::FunctionId(func)) => Some(func),\n             Some(CallableDefId::StructId(_) | CallableDefId::EnumVariantId(_)) | None => None,\n         }\n     }\n+\n     fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)> {\n         match self.kind(Interner) {\n             TyKind::Ref(mutability, lifetime, ty) => Some((ty, lifetime.clone(), *mutability)),\n             _ => None,\n         }\n     }\n \n+    fn as_raw_ptr(&self) -> Option<(&Ty, Mutability)> {\n+        match self.kind(Interner) {\n+            TyKind::Raw(mutability, ty) => Some((ty, *mutability)),\n+            _ => None,\n+        }\n+    }\n+\n     fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)> {\n         match self.kind(Interner) {\n             TyKind::Ref(mutability, _, ty) => Some((ty, Rawness::Ref, *mutability)),\n@@ -176,10 +202,7 @@ impl TyExt for Ty {\n                 let sig = db.callable_item_signature(callable_def);\n                 Some(sig.substitute(Interner, parameters))\n             }\n-            TyKind::Closure(.., substs) => {\n-                let sig_param = substs.at(Interner, 0).assert_ty_ref(Interner);\n-                sig_param.callable_sig(db)\n-            }\n+            TyKind::Closure(.., substs) => ClosureSubst(substs).sig_ty().callable_sig(db),\n             _ => None,\n         }\n     }\n@@ -318,6 +341,20 @@ impl TyExt for Ty {\n         }\n     }\n \n+    fn is_copy(self, db: &dyn HirDatabase, owner: DefWithBodyId) -> bool {\n+        let crate_id = owner.module(db.upcast()).krate();\n+        let Some(copy_trait) = db.lang_item(crate_id, LangItem::Copy).and_then(|x| x.as_trait()) else {\n+            return false;\n+        };\n+        let trait_ref = TyBuilder::trait_ref(db, copy_trait).push(self).build();\n+        let env = db.trait_environment_for_body(owner);\n+        let goal = Canonical {\n+            value: InEnvironment::new(&env.env, trait_ref.cast(Interner)),\n+            binders: CanonicalVarKinds::empty(Interner),\n+        };\n+        db.trait_solve(crate_id, None, goal).is_some()\n+    }\n+\n     fn equals_ctor(&self, other: &Ty) -> bool {\n         match (self.kind(Interner), other.kind(Interner)) {\n             (TyKind::Adt(adt, ..), TyKind::Adt(adt2, ..)) => adt == adt2,"}, {"sha": "40b63b17b5aa4805e6d3a9f9107d153407fa096a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 75, "deletions": 22, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -3,19 +3,20 @@\n use base_db::CrateId;\n use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData};\n use hir_def::{\n-    expr::Expr,\n-    path::ModPath,\n+    hir::Expr,\n+    path::Path,\n     resolver::{Resolver, ValueNs},\n     type_ref::ConstRef,\n-    ConstId, EnumVariantId,\n+    EnumVariantId, GeneralConstId, StaticId,\n };\n use la_arena::{Idx, RawIdx};\n use stdx::never;\n+use triomphe::Arc;\n \n use crate::{\n-    db::HirDatabase, infer::InferenceContext, layout::layout_of_ty, lower::ParamLoweringMode,\n-    to_placeholder_idx, utils::Generics, Const, ConstData, ConstScalar, ConstValue, GenericArg,\n-    Interner, MemoryMap, Ty, TyBuilder,\n+    db::HirDatabase, infer::InferenceContext, lower::ParamLoweringMode,\n+    mir::monomorphize_mir_body_bad, to_placeholder_idx, utils::Generics, Const, ConstData,\n+    ConstScalar, ConstValue, GenericArg, Interner, MemoryMap, Substitution, Ty, TyBuilder,\n };\n \n use super::mir::{interpret_mir, lower_to_mir, pad16, MirEvalError, MirLowerError};\n@@ -57,7 +58,7 @@ pub enum ConstEvalError {\n impl From<MirLowerError> for ConstEvalError {\n     fn from(value: MirLowerError) -> Self {\n         match value {\n-            MirLowerError::ConstEvalError(e) => *e,\n+            MirLowerError::ConstEvalError(_, e) => *e,\n             _ => ConstEvalError::MirLowerError(value),\n         }\n     }\n@@ -72,10 +73,11 @@ impl From<MirEvalError> for ConstEvalError {\n pub(crate) fn path_to_const(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n-    path: &ModPath,\n+    path: &Path,\n     mode: ParamLoweringMode,\n     args_lazy: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n+    expected_ty: Ty,\n ) -> Option<Const> {\n     match resolver.resolve_path_in_value_ns_fully(db.upcast(), path) {\n         Some(ValueNs::GenericParam(p)) => {\n@@ -89,7 +91,7 @@ pub(crate) fn path_to_const(\n                     Some(x) => ConstValue::BoundVar(BoundVar::new(debruijn, x)),\n                     None => {\n                         never!(\n-                            \"Generic list doesn't contain this param: {:?}, {}, {:?}\",\n+                            \"Generic list doesn't contain this param: {:?}, {:?}, {:?}\",\n                             args,\n                             path,\n                             p\n@@ -100,6 +102,10 @@ pub(crate) fn path_to_const(\n             };\n             Some(ConstData { ty, value }.intern(Interner))\n         }\n+        Some(ValueNs::ConstId(c)) => Some(intern_const_scalar(\n+            ConstScalar::UnevaluatedConst(c.into(), Substitution::empty(Interner)),\n+            expected_ty,\n+        )),\n         _ => None,\n     }\n }\n@@ -124,14 +130,15 @@ pub fn intern_const_scalar(value: ConstScalar, ty: Ty) -> Const {\n \n /// Interns a constant scalar with the given type\n pub fn intern_const_ref(db: &dyn HirDatabase, value: &ConstRef, ty: Ty, krate: CrateId) -> Const {\n+    let layout = db.layout_of_ty(ty.clone(), krate);\n     let bytes = match value {\n         ConstRef::Int(i) => {\n             // FIXME: We should handle failure of layout better.\n-            let size = layout_of_ty(db, &ty, krate).map(|x| x.size.bytes_usize()).unwrap_or(16);\n+            let size = layout.map(|x| x.size.bytes_usize()).unwrap_or(16);\n             ConstScalar::Bytes(i.to_le_bytes()[0..size].to_vec(), MemoryMap::default())\n         }\n         ConstRef::UInt(i) => {\n-            let size = layout_of_ty(db, &ty, krate).map(|x| x.size.bytes_usize()).unwrap_or(16);\n+            let size = layout.map(|x| x.size.bytes_usize()).unwrap_or(16);\n             ConstScalar::Bytes(i.to_le_bytes()[0..size].to_vec(), MemoryMap::default())\n         }\n         ConstRef::Bool(b) => ConstScalar::Bytes(vec![*b as u8], MemoryMap::default()),\n@@ -153,13 +160,17 @@ pub fn usize_const(db: &dyn HirDatabase, value: Option<u128>, krate: CrateId) ->\n     )\n }\n \n-pub fn try_const_usize(c: &Const) -> Option<u128> {\n+pub fn try_const_usize(db: &dyn HirDatabase, c: &Const) -> Option<u128> {\n     match &c.data(Interner).value {\n         chalk_ir::ConstValue::BoundVar(_) => None,\n         chalk_ir::ConstValue::InferenceVar(_) => None,\n         chalk_ir::ConstValue::Placeholder(_) => None,\n         chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n             ConstScalar::Bytes(x, _) => Some(u128::from_le_bytes(pad16(&x, false))),\n+            ConstScalar::UnevaluatedConst(c, subst) => {\n+                let ec = db.const_eval(*c, subst.clone()).ok()?;\n+                try_const_usize(db, &ec)\n+            }\n             _ => None,\n         },\n     }\n@@ -168,7 +179,16 @@ pub fn try_const_usize(c: &Const) -> Option<u128> {\n pub(crate) fn const_eval_recover(\n     _: &dyn HirDatabase,\n     _: &[String],\n-    _: &ConstId,\n+    _: &GeneralConstId,\n+    _: &Substitution,\n+) -> Result<Const, ConstEvalError> {\n+    Err(ConstEvalError::MirLowerError(MirLowerError::Loop))\n+}\n+\n+pub(crate) fn const_eval_static_recover(\n+    _: &dyn HirDatabase,\n+    _: &[String],\n+    _: &StaticId,\n ) -> Result<Const, ConstEvalError> {\n     Err(ConstEvalError::MirLowerError(MirLowerError::Loop))\n }\n@@ -183,11 +203,39 @@ pub(crate) fn const_eval_discriminant_recover(\n \n pub(crate) fn const_eval_query(\n     db: &dyn HirDatabase,\n-    const_id: ConstId,\n+    def: GeneralConstId,\n+    subst: Substitution,\n+) -> Result<Const, ConstEvalError> {\n+    let body = match def {\n+        GeneralConstId::ConstId(c) => {\n+            db.monomorphized_mir_body(c.into(), subst, db.trait_environment(c.into()))?\n+        }\n+        GeneralConstId::AnonymousConstId(c) => {\n+            let (def, root) = db.lookup_intern_anonymous_const(c);\n+            let body = db.body(def);\n+            let infer = db.infer(def);\n+            Arc::new(monomorphize_mir_body_bad(\n+                db,\n+                lower_to_mir(db, def, &body, &infer, root)?,\n+                subst,\n+                db.trait_environment_for_body(def),\n+            )?)\n+        }\n+    };\n+    let c = interpret_mir(db, &body, false).0?;\n+    Ok(c)\n+}\n+\n+pub(crate) fn const_eval_static_query(\n+    db: &dyn HirDatabase,\n+    def: StaticId,\n ) -> Result<Const, ConstEvalError> {\n-    let def = const_id.into();\n-    let body = db.mir_body(def)?;\n-    let c = interpret_mir(db, &body, false)?;\n+    let body = db.monomorphized_mir_body(\n+        def.into(),\n+        Substitution::empty(Interner),\n+        db.trait_environment_for_body(def.into()),\n+    )?;\n+    let c = interpret_mir(db, &body, false).0?;\n     Ok(c)\n }\n \n@@ -209,9 +257,13 @@ pub(crate) fn const_eval_discriminant_variant(\n         };\n         return Ok(value);\n     }\n-    let mir_body = db.mir_body(def)?;\n-    let c = interpret_mir(db, &mir_body, false)?;\n-    let c = try_const_usize(&c).unwrap() as i128;\n+    let mir_body = db.monomorphized_mir_body(\n+        def,\n+        Substitution::empty(Interner),\n+        db.trait_environment_for_body(def),\n+    )?;\n+    let c = interpret_mir(db, &mir_body, false).0?;\n+    let c = try_const_usize(db, &c).unwrap() as i128;\n     Ok(c)\n }\n \n@@ -226,15 +278,16 @@ pub(crate) fn eval_to_const(\n     debruijn: DebruijnIndex,\n ) -> Const {\n     let db = ctx.db;\n+    let infer = ctx.clone().resolve_all();\n     if let Expr::Path(p) = &ctx.body.exprs[expr] {\n         let resolver = &ctx.resolver;\n-        if let Some(c) = path_to_const(db, resolver, p.mod_path(), mode, args, debruijn) {\n+        if let Some(c) = path_to_const(db, resolver, p, mode, args, debruijn, infer[expr].clone()) {\n             return c;\n         }\n     }\n     let infer = ctx.clone().resolve_all();\n     if let Ok(mir_body) = lower_to_mir(ctx.db, ctx.owner, &ctx.body, &infer, expr) {\n-        if let Ok(result) = interpret_mir(db, &mir_body, true) {\n+        if let Ok(result) = interpret_mir(db, &mir_body, true).0 {\n             return result;\n         }\n     }"}, {"sha": "06fff08b7d35b52fa66768a9840b655761c709f4", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 1429, "deletions": 119, "changes": 1548, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,53 +1,85 @@\n-use base_db::fixture::WithFixture;\n+use base_db::{fixture::WithFixture, FileId};\n+use chalk_ir::Substitution;\n use hir_def::db::DefDatabase;\n \n use crate::{\n-    consteval::try_const_usize, db::HirDatabase, test_db::TestDB, Const, ConstScalar, Interner,\n+    consteval::try_const_usize, db::HirDatabase, mir::pad16, test_db::TestDB, Const, ConstScalar,\n+    Interner,\n };\n \n use super::{\n     super::mir::{MirEvalError, MirLowerError},\n     ConstEvalError,\n };\n \n+mod intrinsics;\n+\n fn simplify(e: ConstEvalError) -> ConstEvalError {\n     match e {\n-        ConstEvalError::MirEvalError(MirEvalError::InFunction(_, e)) => {\n+        ConstEvalError::MirEvalError(MirEvalError::InFunction(_, e, _, _)) => {\n             simplify(ConstEvalError::MirEvalError(*e))\n         }\n         _ => e,\n     }\n }\n \n #[track_caller]\n-fn check_fail(ra_fixture: &str, error: ConstEvalError) {\n-    assert_eq!(eval_goal(ra_fixture).map_err(simplify), Err(error));\n+fn check_fail(ra_fixture: &str, error: impl FnOnce(ConstEvalError) -> bool) {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    match eval_goal(&db, file_id) {\n+        Ok(_) => panic!(\"Expected fail, but it succeeded\"),\n+        Err(e) => {\n+            assert!(error(simplify(e.clone())), \"Actual error was: {}\", pretty_print_err(e, db))\n+        }\n+    }\n }\n \n #[track_caller]\n fn check_number(ra_fixture: &str, answer: i128) {\n-    let r = eval_goal(ra_fixture).unwrap();\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let r = match eval_goal(&db, file_id) {\n+        Ok(t) => t,\n+        Err(e) => {\n+            let err = pretty_print_err(e, db);\n+            panic!(\"Error in evaluating goal: {}\", err);\n+        }\n+    };\n     match &r.data(Interner).value {\n         chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n             ConstScalar::Bytes(b, _) => {\n-                assert_eq!(b, &answer.to_le_bytes()[0..b.len()]);\n+                assert_eq!(\n+                    b,\n+                    &answer.to_le_bytes()[0..b.len()],\n+                    \"Bytes differ. In decimal form: actual = {}, expected = {answer}\",\n+                    i128::from_le_bytes(pad16(b, true))\n+                );\n             }\n             x => panic!(\"Expected number but found {:?}\", x),\n         },\n         _ => panic!(\"result of const eval wasn't a concrete const\"),\n     }\n }\n \n-fn eval_goal(ra_fixture: &str) -> Result<Const, ConstEvalError> {\n-    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+fn pretty_print_err(e: ConstEvalError, db: TestDB) -> String {\n+    let mut err = String::new();\n+    let span_formatter = |file, range| format!(\"{:?} {:?}\", file, range);\n+    match e {\n+        ConstEvalError::MirLowerError(e) => e.pretty_print(&mut err, &db, span_formatter),\n+        ConstEvalError::MirEvalError(e) => e.pretty_print(&mut err, &db, span_formatter),\n+    }\n+    .unwrap();\n+    err\n+}\n+\n+fn eval_goal(db: &TestDB, file_id: FileId) -> Result<Const, ConstEvalError> {\n     let module_id = db.module_for_file(file_id);\n-    let def_map = module_id.def_map(&db);\n+    let def_map = module_id.def_map(db);\n     let scope = &def_map[module_id.local_id].scope;\n     let const_id = scope\n         .declarations()\n         .find_map(|x| match x {\n             hir_def::ModuleDefId::ConstId(x) => {\n-                if db.const_data(x).name.as_ref()?.to_string() == \"GOAL\" {\n+                if db.const_data(x).name.as_ref()?.display(db).to_string() == \"GOAL\" {\n                     Some(x)\n                 } else {\n                     None\n@@ -56,7 +88,7 @@ fn eval_goal(ra_fixture: &str) -> Result<Const, ConstEvalError> {\n             _ => None,\n         })\n         .unwrap();\n-    db.const_eval(const_id)\n+    db.const_eval(const_id.into(), Substitution::empty(Interner))\n }\n \n #[test]\n@@ -72,8 +104,98 @@ fn bit_op() {\n     check_number(r#\"const GOAL: u8 = !0 & !(!0 >> 1)\"#, 128);\n     check_number(r#\"const GOAL: i8 = !0 & !(!0 >> 1)\"#, 0);\n     check_number(r#\"const GOAL: i8 = 1 << 7\"#, (1i8 << 7) as i128);\n-    // FIXME: report panic here\n-    check_number(r#\"const GOAL: i8 = 1 << 8\"#, 0);\n+    check_number(r#\"const GOAL: i8 = -1 << 2\"#, (-1i8 << 2) as i128);\n+    check_fail(r#\"const GOAL: i8 = 1 << 8\"#, |e| {\n+        e == ConstEvalError::MirEvalError(MirEvalError::Panic(\"Overflow in Shl\".to_string()))\n+    });\n+}\n+\n+#[test]\n+fn floating_point() {\n+    check_number(\n+        r#\"const GOAL: f64 = 2.0 + 3.0 * 5.5 - 8.;\"#,\n+        i128::from_le_bytes(pad16(&f64::to_le_bytes(10.5), true)),\n+    );\n+    check_number(\n+        r#\"const GOAL: f32 = 2.0 + 3.0 * 5.5 - 8.;\"#,\n+        i128::from_le_bytes(pad16(&f32::to_le_bytes(10.5), true)),\n+    );\n+    check_number(\n+        r#\"const GOAL: f32 = -90.0 + 36.0;\"#,\n+        i128::from_le_bytes(pad16(&f32::to_le_bytes(-54.0), true)),\n+    );\n+}\n+\n+#[test]\n+fn casts() {\n+    check_number(r#\"const GOAL: usize = 12 as *const i32 as usize\"#, 12);\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: i32 = {\n+        let a = [10, 20, 3, 15];\n+        let x: &[i32] = &a;\n+        let y: *const [i32] = x;\n+        let z = y as *const i32;\n+        unsafe { *z }\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: i16 = {\n+        let a = &mut 5;\n+        let z = a as *mut _;\n+        unsafe { *z }\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = {\n+        let a = &[10, 20, 30, 40] as &[i32];\n+        a.len()\n+    };\n+        \"#,\n+        4,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = {\n+        let a = [10, 20, 3, 15];\n+        let x: &[i32] = &a;\n+        let y: *const [i32] = x;\n+        let z = y as *const [u8]; // slice fat pointer cast don't touch metadata\n+        let q = z as *const str;\n+        let p = q as *const [u8];\n+        let w = unsafe { &*z };\n+        w.len()\n+    };\n+        \"#,\n+        4,\n+    );\n+    check_number(r#\"const GOAL: i32 = -12i8 as i32\"#, -12);\n+}\n+\n+#[test]\n+fn raw_pointer_equality() {\n+    check_number(\n+        r#\"\n+        //- minicore: copy, eq\n+        const GOAL: bool = {\n+            let a = 2;\n+            let p1 = a as *const i32;\n+            let p2 = a as *const i32;\n+            p1 == p2\n+        };\n+        \"#,\n+        1,\n+    );\n }\n \n #[test]\n@@ -166,8 +288,7 @@ fn reference_autoderef() {\n \n #[test]\n fn overloaded_deref() {\n-    // FIXME: We should support this.\n-    check_fail(\n+    check_number(\n         r#\"\n     //- minicore: deref_mut\n     struct Foo;\n@@ -185,9 +306,7 @@ fn overloaded_deref() {\n         *y + *x\n     };\n     \"#,\n-        ConstEvalError::MirLowerError(MirLowerError::NotSupported(\n-            \"explicit overloaded deref\".into(),\n-        )),\n+        10,\n     );\n }\n \n@@ -218,6 +337,117 @@ fn overloaded_deref_autoref() {\n     );\n }\n \n+#[test]\n+fn overloaded_index() {\n+    check_number(\n+        r#\"\n+    //- minicore: index\n+    struct Foo;\n+\n+    impl core::ops::Index<usize> for Foo {\n+        type Output = i32;\n+        fn index(&self, index: usize) -> &i32 {\n+            if index == 7 {\n+                &700\n+            } else {\n+                &1000\n+            }\n+        }\n+    }\n+\n+    impl core::ops::IndexMut<usize> for Foo {\n+        fn index_mut(&mut self, index: usize) -> &mut i32 {\n+            if index == 7 {\n+                &mut 7\n+            } else {\n+                &mut 10\n+            }\n+        }\n+    }\n+\n+    const GOAL: i32 = {\n+        (Foo[2]) + (Foo[7]) + (*&Foo[2]) + (*&Foo[7]) + (*&mut Foo[2]) + (*&mut Foo[7])\n+    };\n+    \"#,\n+        3417,\n+    );\n+}\n+\n+#[test]\n+fn overloaded_binop() {\n+    check_number(\n+        r#\"\n+    //- minicore: add\n+    enum Color {\n+        Red,\n+        Green,\n+        Yellow,\n+    }\n+\n+    use Color::*;\n+\n+    impl core::ops::Add for Color {\n+        type Output = Color;\n+        fn add(self, rhs: Color) -> Self::Output {\n+            Yellow\n+        }\n+    }\n+\n+    impl core::ops::AddAssign for Color {\n+        fn add_assign(&mut self, rhs: Color) {\n+            *self = Red;\n+        }\n+    }\n+\n+    const GOAL: bool = {\n+        let x = Red + Green;\n+        let mut y = Green;\n+        y += x;\n+        x == Yellow && y == Red && Red + Green == Yellow && Red + Red == Yellow && Yellow + Green == Yellow\n+    };\n+    \"#,\n+        1,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: add\n+    impl core::ops::Add for usize {\n+        type Output = usize;\n+        fn add(self, rhs: usize) -> Self::Output {\n+            self + rhs\n+        }\n+    }\n+\n+    impl core::ops::AddAssign for usize {\n+        fn add_assign(&mut self, rhs: usize) {\n+            *self += rhs;\n+        }\n+    }\n+\n+    #[lang = \"shl\"]\n+    pub trait Shl<Rhs = Self> {\n+        type Output;\n+\n+        fn shl(self, rhs: Rhs) -> Self::Output;\n+    }\n+\n+    impl Shl<u8> for usize {\n+        type Output = usize;\n+\n+        fn shl(self, rhs: u8) -> Self::Output {\n+            self << rhs\n+        }\n+    }\n+\n+    const GOAL: usize = {\n+        let mut x = 10;\n+        x += 20;\n+        2 + 2 + (x << 1u8)\n+    };\"#,\n+        64,\n+    );\n+}\n+\n #[test]\n fn function_call() {\n     check_number(\n@@ -240,20 +470,6 @@ fn function_call() {\n     );\n }\n \n-#[test]\n-fn intrinsics() {\n-    check_number(\n-        r#\"\n-    extern \"rust-intrinsic\" {\n-        pub fn size_of<T>() -> usize;\n-    }\n-\n-    const GOAL: usize = size_of::<i32>();\n-    \"#,\n-        4,\n-    );\n-}\n-\n #[test]\n fn trait_basic() {\n     check_number(\n@@ -300,6 +516,35 @@ fn trait_method() {\n     );\n }\n \n+#[test]\n+fn trait_method_inside_block() {\n+    check_number(\n+        r#\"\n+trait Twait {\n+    fn a(&self) -> i32;\n+}\n+\n+fn outer() -> impl Twait {\n+    struct Stwuct;\n+\n+    impl Twait for Stwuct {\n+        fn a(&self) -> i32 {\n+            5\n+        }\n+    }\n+    fn f() -> impl Twait {\n+        let s = Stwuct;\n+        s\n+    }\n+    f()\n+}\n+\n+const GOAL: i32 = outer().a();\n+        \"#,\n+        5,\n+    );\n+}\n+\n #[test]\n fn generic_fn() {\n     check_number(\n@@ -355,6 +600,16 @@ fn generic_fn() {\n         \"#,\n         12,\n     );\n+    check_number(\n+        r#\"\n+        const fn y<T>(b: T) -> (T, ) {\n+            let alloc = b;\n+            (alloc, )\n+        }\n+        const GOAL: u8 = y(2).0;\n+        \"#,\n+        2,\n+    );\n     check_number(\n         r#\"\n     //- minicore: coerce_unsized, index, slice\n@@ -483,6 +738,66 @@ fn loops() {\n         \"#,\n         4,\n     );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let mut x = 0;\n+        loop {\n+            x = x + 1;\n+            if x == 5 {\n+                break x + 2;\n+            }\n+        }\n+    };\n+        \"#,\n+        7,\n+    );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        'a: loop {\n+            let x = 'b: loop {\n+                let x = 'c: loop {\n+                    let x = 'd: loop {\n+                        let x = 'e: loop {\n+                            break 'd 1;\n+                        };\n+                        break 2 + x;\n+                    };\n+                    break 3 + x;\n+                };\n+                break 'a 4 + x;\n+            };\n+            break 5 + x;\n+        }\n+    };\n+        \"#,\n+        8,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: add\n+    const GOAL: u8 = {\n+        let mut x = 0;\n+        'a: loop {\n+            'b: loop {\n+                'c: while x < 20 {\n+                    'd: while x < 5 {\n+                        'e: loop {\n+                            x += 1;\n+                            continue 'c;\n+                        };\n+                    };\n+                    x += 1;\n+                };\n+                break 'a;\n+            };\n+        }\n+        x\n+    };\n+        \"#,\n+        20,\n+    );\n }\n \n #[test]\n@@ -522,6 +837,18 @@ fn for_loops() {\n     );\n }\n \n+#[test]\n+fn ranges() {\n+    check_number(\n+        r#\"\n+    //- minicore: range\n+    const GOAL: i32 = (1..2).start + (20..10).end + (100..=200).start + (2000..=1000).end\n+        + (10000..).start + (..100000).end + (..=1000000).end;\n+        \"#,\n+        1111111,\n+    );\n+}\n+\n #[test]\n fn recursion() {\n     check_number(\n@@ -555,6 +882,38 @@ fn structs() {\n         \"#,\n         17,\n     );\n+    check_number(\n+        r#\"\n+        struct Point {\n+            x: i32,\n+            y: i32,\n+        }\n+\n+        const GOAL: i32 = {\n+            let p = Point { x: 5, y: 2 };\n+            let p2 = Point { x: 3, ..p };\n+            p.x * 1000 + p.y * 100 + p2.x * 10 + p2.y\n+        };\n+        \"#,\n+        5232,\n+    );\n+    check_number(\n+        r#\"\n+        struct Point {\n+            x: i32,\n+            y: i32,\n+        }\n+\n+        const GOAL: i32 = {\n+            let p = Point { x: 5, y: 2 };\n+            let Point { x, y } = p;\n+            let Point { x: x2, .. } = p;\n+            let Point { y: y2, .. } = p;\n+            x * 1000 + y * 100 + x2 * 10 + y2\n+        };\n+        \"#,\n+        5252,\n+    );\n }\n \n #[test]\n@@ -599,13 +958,14 @@ fn tuples() {\n     );\n     check_number(\n         r#\"\n-    struct TupleLike(i32, u8, i64, u16);\n-    const GOAL: u8 = {\n+    struct TupleLike(i32, i64, u8, u16);\n+    const GOAL: i64 = {\n         let a = TupleLike(10, 20, 3, 15);\n-        a.1\n+        let TupleLike(b, .., c) = a;\n+        a.1 * 100 + b as i64 + c as i64\n     };\n         \"#,\n-        20,\n+        2025,\n     );\n     check_number(\n         r#\"\n@@ -638,11 +998,17 @@ fn path_pattern_matching() {\n \n     use Season::*;\n \n+    const MY_SEASON: Season = Summer;\n+\n+    impl Season {\n+        const FALL: Season = Fall;\n+    }\n+\n     const fn f(x: Season) -> i32 {\n         match x {\n             Spring => 1,\n-            Summer => 2,\n-            Fall => 3,\n+            MY_SEASON => 2,\n+            Season::FALL => 3,\n             Winter => 4,\n         }\n     }\n@@ -653,42 +1019,137 @@ fn path_pattern_matching() {\n }\n \n #[test]\n-fn pattern_matching_ergonomics() {\n+fn pattern_matching_literal() {\n     check_number(\n         r#\"\n-    const fn f(x: &(u8, u8)) -> u8 {\n+    const fn f(x: i32) -> i32 {\n         match x {\n-            (a, b) => *a + *b\n+            -1 => 1,\n+            1 => 10,\n+            _ => 100,\n         }\n     }\n-    const GOAL: u8 = f(&(2, 3));\n+    const GOAL: i32 = f(-1) + f(1) + f(0) + f(-5);\n         \"#,\n-        5,\n+        211,\n     );\n-}\n-\n-#[test]\n-fn let_else() {\n     check_number(\n         r#\"\n-    const fn f(x: &(u8, u8)) -> u8 {\n-        let (a, b) = x;\n-        *a + *b\n+    const fn f(x: &str) -> i32 {\n+        match x {\n+            \"f\" => 1,\n+            \"foo\" => 10,\n+            \"\" => 100,\n+            \"bar\" => 1000,\n+            _ => 10000,\n+        }\n     }\n-    const GOAL: u8 = f(&(2, 3));\n+    const GOAL: i32 = f(\"f\") + f(\"foo\") * 2 + f(\"\") * 3 + f(\"bar\") * 4;\n         \"#,\n-        5,\n+        4321,\n     );\n+}\n+\n+#[test]\n+fn pattern_matching_range() {\n     check_number(\n         r#\"\n-    enum SingleVariant {\n-        Var(u8, u8),\n+    pub const L: i32 = 6;\n+    mod x {\n+        pub const R: i32 = 100;\n     }\n-    const fn f(x: &&&&&SingleVariant) -> u8 {\n-        let SingleVariant::Var(a, b) = x;\n-        *a + *b\n+    const fn f(x: i32) -> i32 {\n+        match x {\n+            -1..=5 => x * 10,\n+            L..=x::R => x * 100,\n+            _ => x,\n+        }\n     }\n-    const GOAL: u8 = f(&&&&&SingleVariant::Var(2, 3));\n+    const GOAL: i32 = f(-1) + f(2) + f(100) + f(-2) + f(1000);\n+        \"#,\n+        11008,\n+    );\n+}\n+\n+#[test]\n+fn pattern_matching_slice() {\n+    check_number(\n+        r#\"\n+    //- minicore: slice, index, coerce_unsized, copy\n+    const fn f(x: &[usize]) -> usize {\n+        match x {\n+            [a, b @ .., c, d] => *a + b.len() + *c + *d,\n+        }\n+    }\n+    const GOAL: usize = f(&[10, 20, 3, 15, 1000, 60, 16]);\n+        \"#,\n+        10 + 4 + 60 + 16,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: slice, index, coerce_unsized, copy\n+    const fn f(x: &[usize]) -> usize {\n+        match x {\n+            [] => 0,\n+            [a] => *a,\n+            &[a, b] => a + b,\n+            [a, b @ .., c, d] => *a + b.len() + *c + *d,\n+        }\n+    }\n+    const GOAL: usize = f(&[]) + f(&[10]) + f(&[100, 100])\n+        + f(&[1000, 1000, 1000]) + f(&[10000, 57, 34, 46, 10000, 10000]);\n+        \"#,\n+        33213,\n+    );\n+}\n+\n+#[test]\n+fn pattern_matching_ergonomics() {\n+    check_number(\n+        r#\"\n+    const fn f(x: &(u8, u8)) -> u8 {\n+        match x {\n+            (a, b) => *a + *b\n+        }\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let a = &(2, 3);\n+        let &(x, y) = a;\n+        x + y\n+    };\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn let_else() {\n+    check_number(\n+        r#\"\n+    const fn f(x: &(u8, u8)) -> u8 {\n+        let (a, b) = x;\n+        *a + *b\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    enum SingleVariant {\n+        Var(u8, u8),\n+    }\n+    const fn f(x: &&&&&SingleVariant) -> u8 {\n+        let SingleVariant::Var(a, b) = x;\n+        *a + *b\n+    }\n+    const GOAL: u8 = f(&&&&&SingleVariant::Var(2, 3));\n         \"#,\n         5,\n     );\n@@ -748,6 +1209,77 @@ fn function_param_patterns() {\n     );\n }\n \n+#[test]\n+fn match_guards() {\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    fn f(x: Option<i32>) -> i32 {\n+        match x {\n+            y if let Some(42) = y => 42000,\n+            Some(y) => y,\n+            None => 10\n+        }\n+    }\n+    const GOAL: i32 = f(Some(42)) + f(Some(2)) + f(None);\n+        \"#,\n+        42012,\n+    );\n+}\n+\n+#[test]\n+fn result_layout_niche_optimization() {\n+    check_number(\n+        r#\"\n+    //- minicore: option, result\n+    const GOAL: i32 = match Some(2).ok_or(Some(2)) {\n+        Ok(x) => x,\n+        Err(_) => 1000,\n+    };\n+        \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: result\n+    pub enum AlignmentEnum64 {\n+        _Align1Shl0 = 1 << 0,\n+        _Align1Shl1 = 1 << 1,\n+        _Align1Shl2 = 1 << 2,\n+        _Align1Shl3 = 1 << 3,\n+        _Align1Shl4 = 1 << 4,\n+        _Align1Shl5 = 1 << 5,\n+    }\n+    const GOAL: Result<AlignmentEnum64, ()> = {\n+        let align = Err(());\n+        align\n+    };\n+    \"#,\n+        0, // It is 0 since result is niche encoded and 1 is valid for `AlignmentEnum64`\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: result\n+    pub enum AlignmentEnum64 {\n+        _Align1Shl0 = 1 << 0,\n+        _Align1Shl1 = 1 << 1,\n+        _Align1Shl2 = 1 << 2,\n+        _Align1Shl3 = 1 << 3,\n+        _Align1Shl4 = 1 << 4,\n+        _Align1Shl5 = 1 << 5,\n+    }\n+    const GOAL: i32 = {\n+        let align = Ok::<_, ()>(AlignmentEnum64::_Align1Shl0);\n+        match align {\n+            Ok(_) => 2,\n+            Err(_) => 1,\n+        }\n+    };\n+    \"#,\n+        2,\n+    );\n+}\n+\n #[test]\n fn options() {\n     check_number(\n@@ -761,81 +1293,604 @@ fn options() {\n         }\n     };\n         \"#,\n-        4,\n+        4,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    fn f(x: Option<Option<i32>>) -> i32 {\n+        if let Some(y) = x && let Some(z) = y {\n+            z\n+        } else if let Some(y) = x {\n+            1\n+        } else {\n+            0\n+        }\n+    }\n+    const GOAL: i32 = f(Some(Some(10))) + f(Some(None)) + f(None);\n+        \"#,\n+        11,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let x = None;\n+        match x {\n+            Some(y) => 2 * y,\n+            _ => 10,\n+        }\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: Option<&u8> = None;\n+        \"#,\n+        0,\n+    );\n+}\n+\n+#[test]\n+fn from_trait() {\n+    check_number(\n+        r#\"\n+    //- minicore: from\n+    struct E1(i32);\n+    struct E2(i32);\n+\n+    impl From<E1> for E2 {\n+        fn from(E1(x): E1) -> Self {\n+            E2(1000 * x)\n+        }\n+    }\n+    const GOAL: i32 = {\n+        let x: E2 = E1(2).into();\n+        x.0\n+    };\n+    \"#,\n+        2000,\n+    );\n+}\n+\n+#[test]\n+fn builtin_derive_macro() {\n+    check_number(\n+        r#\"\n+    //- minicore: clone, derive, builtin_impls\n+    #[derive(Clone)]\n+    enum Z {\n+        Foo(Y),\n+        Bar,\n+    }\n+    #[derive(Clone)]\n+    struct X(i32, Z, i64)\n+    #[derive(Clone)]\n+    struct Y {\n+        field1: i32,\n+        field2: u8,\n+    }\n+\n+    const GOAL: u8 = {\n+        let x = X(2, Z::Foo(Y { field1: 4, field2: 5 }), 8);\n+        let x = x.clone();\n+        let Z::Foo(t) = x.1;\n+        t.field2\n+    };\n+    \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: default, derive, builtin_impls\n+    #[derive(Default)]\n+    struct X(i32, Y, i64)\n+    #[derive(Default)]\n+    struct Y {\n+        field1: i32,\n+        field2: u8,\n+    }\n+\n+    const GOAL: u8 = {\n+        let x = X::default();\n+        x.1.field2\n+    };\n+    \"#,\n+        0,\n+    );\n+}\n+\n+#[test]\n+fn try_operator() {\n+    check_number(\n+        r#\"\n+    //- minicore: option, try\n+    const fn f(x: Option<i32>, y: Option<i32>) -> Option<i32> {\n+        Some(x? * y?)\n+    }\n+    const fn g(x: Option<i32>, y: Option<i32>) -> i32 {\n+        match f(x, y) {\n+            Some(k) => k,\n+            None => 5,\n+        }\n+    }\n+    const GOAL: i32 = g(Some(10), Some(20)) + g(Some(30), None) + g(None, Some(40)) + g(None, None);\n+        \"#,\n+        215,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: result, try, from\n+    struct E1(i32);\n+    struct E2(i32);\n+\n+    impl From<E1> for E2 {\n+        fn from(E1(x): E1) -> Self {\n+            E2(1000 * x)\n+        }\n+    }\n+\n+    const fn f(x: Result<i32, E1>) -> Result<i32, E2> {\n+        Ok(x? * 10)\n+    }\n+    const fn g(x: Result<i32, E1>) -> i32 {\n+        match f(x) {\n+            Ok(k) => 7 * k,\n+            Err(E2(k)) => 5 * k,\n+        }\n+    }\n+    const GOAL: i32 = g(Ok(2)) + g(Err(E1(3)));\n+        \"#,\n+        15140,\n+    );\n+}\n+\n+#[test]\n+fn try_block() {\n+    check_number(\n+        r#\"\n+    //- minicore: option, try\n+    const fn g(x: Option<i32>, y: Option<i32>) -> i32 {\n+        let r = try { x? * y? };\n+        match r {\n+            Some(k) => k,\n+            None => 5,\n+        }\n+    }\n+    const GOAL: i32 = g(Some(10), Some(20)) + g(Some(30), None) + g(None, Some(40)) + g(None, None);\n+        \"#,\n+        215,\n+    );\n+}\n+\n+#[test]\n+fn closures() {\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let y = 5;\n+        let c = |x| x + y;\n+        c(2)\n+    };\n+        \"#,\n+        7,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let y = 5;\n+        let c = |(a, b): &(i32, i32)| *a + *b + y;\n+        c(&(2, 3))\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let mut y = 5;\n+        let c = |x| {\n+            y = y + x;\n+        };\n+        c(2);\n+        c(3);\n+        y\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let c: fn(i32) -> i32 = |x| 2 * x;\n+        c(2) + c(10)\n+    };\n+        \"#,\n+        24,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    struct X(i32);\n+    impl X {\n+        fn mult(&mut self, n: i32) {\n+            self.0 = self.0 * n\n+        }\n+    }\n+    const GOAL: i32 = {\n+        let x = X(1);\n+        let c = || {\n+            x.mult(2);\n+            || {\n+                x.mult(3);\n+                || {\n+                    || {\n+                        x.mult(4);\n+                        || {\n+                            x.mult(x.0);\n+                            || {\n+                                x.0\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+        let r = c()()()()()();\n+        r + x.0\n+    };\n+        \"#,\n+        24 * 24 * 2,\n+    );\n+}\n+\n+#[test]\n+fn closure_and_impl_fn() {\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    fn closure_wrapper<F: FnOnce() -> i32>(c: F) -> impl FnOnce() -> F {\n+        || c\n+    }\n+\n+    const GOAL: i32 = {\n+        let y = 5;\n+        let c = closure_wrapper(|| y);\n+        c()()\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    fn f<T, F: Fn() -> T>(t: F) -> impl Fn() -> T {\n+        move || t()\n+    }\n+\n+    const GOAL: i32 = f(|| 2)();\n+        \"#,\n+        2,\n+    );\n+}\n+\n+#[test]\n+fn or_pattern() {\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let (a | a) = 2;\n+        a\n+    };\n+        \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const fn f(x: Option<i32>) -> i32 {\n+        let (Some(a) | Some(a)) = x else { return 2; };\n+        a\n+    }\n+    const GOAL: i32 = f(Some(10)) + f(None);\n+        \"#,\n+        12,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const fn f(x: Option<i32>, y: Option<i32>) -> i32 {\n+        match (x, y) {\n+            (Some(x), Some(y)) => x * y,\n+            (Some(a), _) | (_, Some(a)) => a,\n+            _ => 10,\n+        }\n+    }\n+    const GOAL: i32 = f(Some(10), Some(20)) + f(Some(30), None) + f(None, Some(40)) + f(None, None);\n+        \"#,\n+        280,\n+    );\n+}\n+\n+#[test]\n+fn function_pointer_in_constants() {\n+    check_number(\n+        r#\"\n+    struct Foo {\n+        f: fn(u8) -> u8,\n+    }\n+    const FOO: Foo = Foo { f: add2 };\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    const GOAL: u8 = (FOO.f)(3);\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn function_pointer() {\n+    check_number(\n+        r#\"\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    const GOAL: u8 = {\n+        let plus2 = add2;\n+        plus2(3)\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    const GOAL: u8 = {\n+        let plus2: fn(u8) -> u8 = add2;\n+        plus2(3)\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn mult3(x: u8) -> u8 {\n+        x * 3\n+    }\n+    const GOAL: u8 = {\n+        let x = [add2, mult3];\n+        x[0](1) + x[1](5)\n+    };\n+        \"#,\n+        18,\n+    );\n+}\n+\n+#[test]\n+fn enum_variant_as_function() {\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let f = Some;\n+        f(3).unwrap_or(2)\n+    };\n+        \"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let f: fn(u8) -> Option<u8> = Some;\n+        f(3).unwrap_or(2)\n+    };\n+        \"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    enum Foo {\n+        Add2(u8),\n+        Mult3(u8),\n+    }\n+    use Foo::*;\n+    const fn f(x: Foo) -> u8 {\n+        match x {\n+            Add2(x) => x + 2,\n+            Mult3(x) => x * 3,\n+        }\n+    }\n+    const GOAL: u8 = {\n+        let x = [Add2, Mult3];\n+        f(x[0](1)) + f(x[1](5))\n+    };\n+        \"#,\n+        18,\n     );\n+}\n+\n+#[test]\n+fn function_traits() {\n     check_number(\n         r#\"\n-    //- minicore: option\n-    fn f(x: Option<Option<i32>>) -> i32 {\n-        if let Some(y) = x && let Some(z) = y {\n-            z\n-        } else if let Some(y) = x {\n-            1\n-        } else {\n-            0\n-        }\n+    //- minicore: fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n     }\n-    const GOAL: i32 = f(Some(Some(10))) + f(Some(None)) + f(None);\n+    fn call(f: impl Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_mut(mut f: impl FnMut(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_once(f: impl FnOnce(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = call(add2, 3) + call_mut(add2, 3) + call_once(add2, 3);\n         \"#,\n-        11,\n+        15,\n     );\n     check_number(\n         r#\"\n-    //- minicore: option\n+    //- minicore: coerce_unsized, fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: &dyn Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_mut(f: &mut dyn FnMut(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = call(&add2, 3) + call_mut(&mut add2, 3);\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: impl Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_mut(mut f: impl FnMut(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_once(f: impl FnOnce(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n     const GOAL: u8 = {\n-        let x = None;\n-        match x {\n-            Some(y) => 2 * y,\n-            _ => 10,\n-        }\n+        let add2: fn(u8) -> u8 = add2;\n+        call(add2, 3) + call_mut(add2, 3) + call_once(add2, 3)\n     };\n         \"#,\n-        10,\n+        15,\n     );\n     check_number(\n         r#\"\n-    //- minicore: option\n-    const GOAL: Option<&u8> = None;\n+    //- minicore: fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: &&&&&impl Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = call(&&&&&add2, 3);\n         \"#,\n-        0,\n+        5,\n     );\n }\n \n #[test]\n-fn or_pattern() {\n+fn dyn_trait() {\n     check_number(\n         r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    trait Foo {\n+        fn foo(&self) -> u8 { 10 }\n+    }\n+    struct S1;\n+    struct S2;\n+    struct S3;\n+    impl Foo for S1 {\n+        fn foo(&self) -> u8 { 1 }\n+    }\n+    impl Foo for S2 {\n+        fn foo(&self) -> u8 { 2 }\n+    }\n+    impl Foo for S3 {}\n     const GOAL: u8 = {\n-        let (a | a) = 2;\n-        a\n+        let x: &[&dyn Foo] = &[&S1, &S2, &S3];\n+        x[0].foo() + x[1].foo() + x[2].foo()\n     };\n         \"#,\n-        2,\n+        13,\n     );\n     check_number(\n         r#\"\n-    //- minicore: option\n-    const fn f(x: Option<i32>) -> i32 {\n-        let (Some(a) | Some(a)) = x else { return 2; };\n-        a\n+    //- minicore: coerce_unsized, index, slice\n+    trait Foo {\n+        fn foo(&self) -> i32 { 10 }\n     }\n-    const GOAL: i32 = f(Some(10)) + f(None);\n+    trait Bar {\n+        fn bar(&self) -> i32 { 20 }\n+    }\n+\n+    struct S;\n+    impl Foo for S {\n+        fn foo(&self) -> i32 { 200 }\n+    }\n+    impl Bar for dyn Foo {\n+        fn bar(&self) -> i32 { 700 }\n+    }\n+    const GOAL: i32 = {\n+        let x: &dyn Foo = &S;\n+        x.bar() + x.foo()\n+    };\n         \"#,\n-        12,\n+        900,\n     );\n+}\n+\n+#[test]\n+fn boxes() {\n     check_number(\n         r#\"\n-    //- minicore: option\n-    const fn f(x: Option<i32>, y: Option<i32>) -> i32 {\n-        match (x, y) {\n-            (Some(x), Some(y)) => x * y,\n-            (Some(a), _) | (_, Some(a)) => a,\n-            _ => 10,\n-        }\n+//- minicore: coerce_unsized, deref_mut, slice\n+use core::ops::{Deref, DerefMut};\n+use core::{marker::Unsize, ops::CoerceUnsized};\n+\n+#[lang = \"owned_box\"]\n+pub struct Box<T: ?Sized> {\n+    inner: *mut T,\n+}\n+impl<T> Box<T> {\n+    fn new(t: T) -> Self {\n+        #[rustc_box]\n+        Box::new(t)\n     }\n-    const GOAL: i32 = f(Some(10), Some(20)) + f(Some(30), None) + f(None, Some(40)) + f(None, None);\n-        \"#,\n-        280,\n+}\n+\n+impl<T: ?Sized> Deref for Box<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &**self\n+    }\n+}\n+\n+impl<T: ?Sized> DerefMut for Box<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut **self\n+    }\n+}\n+\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n+\n+const GOAL: usize = {\n+    let x = Box::new(5);\n+    let y: Box<[i32]> = Box::new([1, 2, 3]);\n+    *x + y.len()\n+};\n+\"#,\n+        8,\n     );\n }\n \n@@ -867,9 +1922,42 @@ fn array_and_index() {\n     check_number(\n         r#\"\n     //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = {\n+        let a = [1, 2, 3];\n+        let x: &[i32] = &a;\n+        let y = &*x;\n+        y.len()\n+    };\"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n     const GOAL: usize = [1, 2, 3, 4, 5].len();\"#,\n         5,\n     );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: [u16; 5] = [1, 2, 3, 4, 5];\"#,\n+        1 + (2 << 16) + (3 << 32) + (4 << 48) + (5 << 64),\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: [u16; 5] = [12; 5];\"#,\n+        12 + (12 << 16) + (12 << 32) + (12 << 48) + (12 << 64),\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const LEN: usize = 4;\n+    const GOAL: u16 = {\n+        let x = [7; LEN];\n+        x[2]\n+    }\"#,\n+        7,\n+    );\n }\n \n #[test]\n@@ -887,6 +1975,38 @@ fn byte_string() {\n     );\n }\n \n+#[test]\n+fn c_string() {\n+    check_number(\n+        r#\"\n+//- minicore: index, slice\n+#[lang = \"CStr\"]\n+pub struct CStr {\n+    inner: [u8]\n+}\n+const GOAL: u8 = {\n+    let a = c\"hello\";\n+    a.inner[0]\n+};\n+    \"#,\n+        104,\n+    );\n+    check_number(\n+        r#\"\n+//- minicore: index, slice\n+#[lang = \"CStr\"]\n+pub struct CStr {\n+    inner: [u8]\n+}\n+const GOAL: u8 = {\n+    let a = c\"hello\";\n+    a.inner[6]\n+};\n+    \"#,\n+        0,\n+    );\n+}\n+\n #[test]\n fn consts() {\n     check_number(\n@@ -900,6 +2020,37 @@ fn consts() {\n     );\n }\n \n+#[test]\n+fn statics() {\n+    check_number(\n+        r#\"\n+    //- minicore: cell\n+    use core::cell::Cell;\n+    fn f() -> i32 {\n+        static S: Cell<i32> = Cell::new(10);\n+        S.set(S.get() + 1);\n+        S.get()\n+    }\n+    const GOAL: i32 = f() + f() + f();\n+    \"#,\n+        36,\n+    );\n+}\n+\n+#[test]\n+fn extern_weak_statics() {\n+    check_number(\n+        r#\"\n+    extern \"C\" {\n+        #[linkage = \"extern_weak\"]\n+        static __dso_handle: *mut u8;\n+    }\n+    const GOAL: usize = __dso_handle as usize;\n+    \"#,\n+        0,\n+    );\n+}\n+\n #[test]\n fn enums() {\n     check_number(\n@@ -927,14 +2078,14 @@ fn enums() {\n     \"#,\n         0,\n     );\n-    let r = eval_goal(\n+    let (db, file_id) = TestDB::with_single_file(\n         r#\"\n         enum E { A = 1, B }\n         const GOAL: E = E::A;\n         \"#,\n-    )\n-    .unwrap();\n-    assert_eq!(try_const_usize(&r), Some(1));\n+    );\n+    let r = eval_goal(&db, file_id).unwrap();\n+    assert_eq!(try_const_usize(&db, &r), Some(1));\n }\n \n #[test]\n@@ -946,7 +2097,7 @@ fn const_loop() {\n     const F2: i32 = 2 * F1;\n     const GOAL: i32 = F3;\n     \"#,\n-        ConstEvalError::MirLowerError(MirLowerError::Loop),\n+        |e| e == ConstEvalError::MirLowerError(MirLowerError::Loop),\n     );\n }\n \n@@ -962,6 +2113,29 @@ fn const_transfer_memory() {\n     );\n }\n \n+#[test]\n+fn anonymous_const_block() {\n+    check_number(\n+        r#\"\n+    extern \"rust-intrinsic\" {\n+        pub fn size_of<T>() -> usize;\n+    }\n+\n+    const fn f<T>() -> usize {\n+        let r = const { size_of::<T>() };\n+        r\n+    }\n+\n+    const GOAL: usize = {\n+        let x = const { 2 + const { 3 } };\n+        let y = f::<i32>();\n+        x + y\n+    };\n+    \"#,\n+        9,\n+    );\n+}\n+\n #[test]\n fn const_impl_assoc() {\n     check_number(\n@@ -970,9 +2144,9 @@ fn const_impl_assoc() {\n     impl U5 {\n         const VAL: usize = 5;\n     }\n-    const GOAL: usize = U5::VAL;\n+    const GOAL: usize = U5::VAL + <U5>::VAL;\n     \"#,\n-        5,\n+        10,\n     );\n }\n \n@@ -987,27 +2161,104 @@ fn const_generic_subst_fn() {\n     \"#,\n         11,\n     );\n+    check_number(\n+        r#\"\n+    fn f<const N: usize>(x: [i32; N]) -> usize {\n+        N\n+    }\n+\n+    trait ArrayExt {\n+        fn f(self) -> usize;\n+    }\n+\n+    impl<T, const N: usize> ArrayExt for [T; N] {\n+        fn g(self) -> usize {\n+            f(self)\n+        }\n+    }\n+\n+    const GOAL: usize = f([1, 2, 5]);\n+    \"#,\n+        3,\n+    );\n+}\n+\n+#[test]\n+fn layout_of_type_with_associated_type_field_defined_inside_body() {\n+    check_number(\n+        r#\"\n+trait Tr {\n+    type Ty;\n+}\n+\n+struct St<T: Tr>(T::Ty);\n+\n+const GOAL: i64 = {\n+    // if we move `St2` out of body, the test will fail, as we don't see the impl anymore. That\n+    // case will probably be rejected by rustc in some later edition, but we should support this\n+    // case.\n+    struct St2;\n+\n+    impl Tr for St2 {\n+        type Ty = i64;\n+    }\n+\n+    struct Goal(St<St2>);\n+\n+    let x = Goal(St(5));\n+    x.0.0\n+};\n+\"#,\n+        5,\n+    );\n }\n \n #[test]\n fn const_generic_subst_assoc_const_impl() {\n-    // FIXME: this should evaluate to 5\n-    check_fail(\n+    check_number(\n         r#\"\n     struct Adder<const N: usize, const M: usize>;\n     impl<const N: usize, const M: usize> Adder<N, M> {\n         const VAL: usize = N + M;\n     }\n     const GOAL: usize = Adder::<2, 3>::VAL;\n     \"#,\n-        ConstEvalError::MirEvalError(MirEvalError::TypeError(\"missing generic arg\")),\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn associated_types() {\n+    check_number(\n+        r#\"\n+    trait Tr {\n+        type Item;\n+        fn get_item(&self) -> Self::Item;\n+    }\n+\n+    struct X(i32);\n+    struct Y(i32);\n+\n+    impl Tr for X {\n+        type Item = Y;\n+        fn get_item(&self) -> Self::Item {\n+            Y(self.0 + 2)\n+        }\n+    }\n+\n+    fn my_get_item<T: Tr>(x: T) -> <T as Tr>::Item {\n+        x.get_item()\n+    }\n+\n+    const GOAL: i32 = my_get_item(X(3)).0;\n+    \"#,\n+        5,\n     );\n }\n \n #[test]\n fn const_trait_assoc() {\n-    // FIXME: this should evaluate to 0\n-    check_fail(\n+    check_number(\n         r#\"\n     struct U0;\n     trait ToConst {\n@@ -1016,9 +2267,49 @@ fn const_trait_assoc() {\n     impl ToConst for U0 {\n         const VAL: usize = 0;\n     }\n-    const GOAL: usize = U0::VAL;\n+    impl ToConst for i32 {\n+        const VAL: usize = 32;\n+    }\n+    const GOAL: usize = U0::VAL + i32::VAL;\n+    \"#,\n+        32,\n+    );\n+    check_number(\n+        r#\"\n+    struct S<T>(*mut T);\n+\n+    trait MySized: Sized {\n+        const SIZE: S<Self> = S(1 as *mut Self);\n+    }\n+\n+    impl MySized for i32 {\n+        const SIZE: S<i32> = S(10 as *mut i32);\n+    }\n+\n+    impl MySized for i64 {\n+    }\n+\n+    const fn f<T: MySized>() -> usize {\n+        T::SIZE.0 as usize\n+    }\n+\n+    const GOAL: usize = f::<i32>() + f::<i64>() * 2;\n+    \"#,\n+        12,\n+    );\n+}\n+\n+#[test]\n+fn panic_messages() {\n+    check_fail(\n+        r#\"\n+    //- minicore: panic\n+    const GOAL: u8 = {\n+        let x: u16 = 2;\n+        panic!(\"hello\");\n+    };\n     \"#,\n-        ConstEvalError::MirLowerError(MirLowerError::IncompleteExpr),\n+        |e| e == ConstEvalError::MirEvalError(MirEvalError::Panic(\"hello\".to_string())),\n     );\n }\n \n@@ -1028,7 +2319,7 @@ fn exec_limits() {\n         r#\"\n     const GOAL: usize = loop {};\n     \"#,\n-        ConstEvalError::MirEvalError(MirEvalError::ExecutionLimitExceeded),\n+        |e| e == ConstEvalError::MirEvalError(MirEvalError::ExecutionLimitExceeded),\n     );\n     check_fail(\n         r#\"\n@@ -1037,7 +2328,7 @@ fn exec_limits() {\n     }\n     const GOAL: i32 = f(0);\n     \"#,\n-        ConstEvalError::MirEvalError(MirEvalError::StackOverflow),\n+        |e| e == ConstEvalError::MirEvalError(MirEvalError::StackOverflow),\n     );\n     // Reasonable code should still work\n     check_number(\n@@ -1062,14 +2353,33 @@ fn exec_limits() {\n \n #[test]\n fn type_error() {\n-    let e = eval_goal(\n+    check_fail(\n         r#\"\n     const GOAL: u8 = {\n         let x: u16 = 2;\n         let y: (u8, u8) = x;\n         y.0\n     };\n     \"#,\n+        |e| matches!(e, ConstEvalError::MirLowerError(MirLowerError::TypeMismatch(_))),\n+    );\n+}\n+\n+#[test]\n+fn unsized_local() {\n+    check_fail(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const fn x() -> SomeUnknownTypeThatDereferenceToSlice {\n+        SomeUnknownTypeThatDereferenceToSlice\n+    }\n+\n+    const GOAL: u16 = {\n+        let y = x();\n+        let z: &[u16] = &y;\n+        z[1]\n+    };\n+    \"#,\n+        |e| matches!(e, ConstEvalError::MirLowerError(MirLowerError::UnsizedTemporary(_))),\n     );\n-    assert!(matches!(e, Err(ConstEvalError::MirLowerError(MirLowerError::TypeMismatch(_)))));\n }"}, {"sha": "e05d824dbacfc430bf8c933f1b01680101dfce10", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/consteval/tests/intrinsics.rs", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -0,0 +1,377 @@\n+use super::*;\n+\n+#[test]\n+fn size_of() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn size_of<T>() -> usize;\n+        }\n+\n+        const GOAL: usize = size_of::<i32>();\n+        \"#,\n+        4,\n+    );\n+}\n+\n+#[test]\n+fn transmute() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn transmute<T, U>(e: T) -> U;\n+        }\n+\n+        const GOAL: i32 = transmute((1i16, 1i16));\n+        \"#,\n+        0x00010001,\n+    );\n+}\n+\n+#[test]\n+fn const_eval_select() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn const_eval_select<ARG, F, G, RET>(arg: ARG, called_in_const: F, called_at_rt: G) -> RET\n+            where\n+                G: FnOnce<ARG, Output = RET>,\n+                F: FnOnce<ARG, Output = RET>;\n+        }\n+\n+        const fn in_const(x: i32, y: i32) -> i32 {\n+            x + y\n+        }\n+\n+        fn in_rt(x: i32, y: i32) -> i32 {\n+            x + y\n+        }\n+\n+        const GOAL: i32 = const_eval_select((2, 3), in_const, in_rt);\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn wrapping_add() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn wrapping_add<T>(a: T, b: T) -> T;\n+        }\n+\n+        const GOAL: u8 = wrapping_add(10, 250);\n+        \"#,\n+        4,\n+    );\n+}\n+\n+#[test]\n+fn saturating_add() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn saturating_add<T>(a: T, b: T) -> T;\n+        }\n+\n+        const GOAL: u8 = saturating_add(10, 250);\n+        \"#,\n+        255,\n+    );\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn saturating_add<T>(a: T, b: T) -> T;\n+        }\n+\n+        const GOAL: i8 = saturating_add(5, 8);\n+        \"#,\n+        13,\n+    );\n+}\n+\n+#[test]\n+fn allocator() {\n+    check_number(\n+        r#\"\n+        extern \"Rust\" {\n+            #[rustc_allocator]\n+            fn __rust_alloc(size: usize, align: usize) -> *mut u8;\n+            #[rustc_deallocator]\n+            fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+            #[rustc_reallocator]\n+            fn __rust_realloc(ptr: *mut u8, old_size: usize, align: usize, new_size: usize) -> *mut u8;\n+            #[rustc_allocator_zeroed]\n+            fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let ptr = __rust_alloc(4, 1);\n+            let ptr2 = ((ptr as usize) + 1) as *mut u8;\n+            *ptr = 23;\n+            *ptr2 = 32;\n+            let ptr = __rust_realloc(ptr, 4, 1, 8);\n+            let ptr2 = ((ptr as usize) + 1) as *mut u8;\n+            *ptr + *ptr2\n+        };\n+        \"#,\n+        55,\n+    );\n+}\n+\n+#[test]\n+fn overflowing_add() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n+        }\n+\n+        const GOAL: u8 = add_with_overflow(1, 2).0;\n+        \"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n+        }\n+\n+        const GOAL: u8 = add_with_overflow(1, 2).1 as u8;\n+        \"#,\n+        0,\n+    );\n+}\n+\n+#[test]\n+fn needs_drop() {\n+    check_number(\n+        r#\"\n+        //- minicore: copy, sized\n+        extern \"rust-intrinsic\" {\n+            pub fn needs_drop<T: ?Sized>() -> bool;\n+        }\n+        struct X;\n+        const GOAL: bool = !needs_drop::<i32>() && needs_drop::<X>();\n+        \"#,\n+        1,\n+    );\n+}\n+\n+#[test]\n+fn likely() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn likely(b: bool) -> bool;\n+            pub fn unlikely(b: bool) -> bool;\n+        }\n+\n+        const GOAL: bool = likely(true) && unlikely(true) && !likely(false) && !unlikely(false);\n+        \"#,\n+        1,\n+    );\n+}\n+\n+#[test]\n+fn floating_point() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn sqrtf32(x: f32) -> f32;\n+            pub fn powf32(a: f32, x: f32) -> f32;\n+            pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n+        }\n+\n+        const GOAL: f32 = sqrtf32(1.2) + powf32(3.4, 5.6) + fmaf32(-7.8, 1.3, 2.4);\n+        \"#,\n+        i128::from_le_bytes(pad16(\n+            &f32::to_le_bytes(1.2f32.sqrt() + 3.4f32.powf(5.6) + (-7.8f32).mul_add(1.3, 2.4)),\n+            true,\n+        )),\n+    );\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn powif64(a: f64, x: i32) -> f64;\n+            pub fn sinf64(x: f64) -> f64;\n+            pub fn minnumf64(x: f64, y: f64) -> f64;\n+        }\n+\n+        const GOAL: f64 = powif64(1.2, 5) + sinf64(3.4) + minnumf64(-7.8, 1.3);\n+        \"#,\n+        i128::from_le_bytes(pad16(\n+            &f64::to_le_bytes(1.2f64.powi(5) + 3.4f64.sin() + (-7.8f64).min(1.3)),\n+            true,\n+        )),\n+    );\n+}\n+\n+#[test]\n+fn atomic() {\n+    check_number(\n+        r#\"\n+        //- minicore: copy\n+        extern \"rust-intrinsic\" {\n+            pub fn atomic_load_seqcst<T: Copy>(src: *const T) -> T;\n+            pub fn atomic_xchg_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_cxchg_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+            pub fn atomic_cxchgweak_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+            pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n+            pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_xsub_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_and_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_nand_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_or_release<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_xor_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n+        }\n+\n+        fn should_not_reach() {\n+            _ // fails the test if executed\n+        }\n+\n+        const GOAL: i32 = {\n+            let mut x = 5;\n+            atomic_store_release(&mut x, 10);\n+            let mut y = atomic_xchg_acquire(&mut x, 100);\n+            atomic_xadd_acqrel(&mut y, 20);\n+            if (30, true) != atomic_cxchg_release_seqcst(&mut y, 30, 40) {\n+                should_not_reach();\n+            }\n+            if (40, false) != atomic_cxchg_release_seqcst(&mut y, 30, 50) {\n+                should_not_reach();\n+            }\n+            if (40, true) != atomic_cxchgweak_acquire_acquire(&mut y, 40, 30) {\n+                should_not_reach();\n+            }\n+            let mut z = atomic_xsub_seqcst(&mut x, -200);\n+            atomic_xor_seqcst(&mut x, 1024);\n+            atomic_load_seqcst(&x) + z * 3 + atomic_load_seqcst(&y) * 2\n+        };\n+        \"#,\n+        660 + 1024,\n+    );\n+}\n+\n+#[test]\n+fn offset() {\n+    check_number(\n+        r#\"\n+        //- minicore: coerce_unsized, index, slice\n+        extern \"rust-intrinsic\" {\n+            pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let ar: &[(u8, u8, u8)] = &[\n+                (10, 11, 12),\n+                (20, 21, 22),\n+                (30, 31, 32),\n+                (40, 41, 42),\n+                (50, 51, 52),\n+            ];\n+            let ar: *const [(u8, u8, u8)] = ar;\n+            let ar = ar as *const (u8, u8, u8);\n+            let element = *offset(ar, 2);\n+            element.1\n+        };\n+        \"#,\n+        31,\n+    );\n+}\n+\n+#[test]\n+fn arith_offset() {\n+    check_number(\n+        r#\"\n+        //- minicore: coerce_unsized, index, slice\n+        extern \"rust-intrinsic\" {\n+            pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let ar: &[(u8, u8, u8)] = &[\n+                (10, 11, 12),\n+                (20, 21, 22),\n+                (30, 31, 32),\n+                (40, 41, 42),\n+                (50, 51, 52),\n+            ];\n+            let ar: *const [(u8, u8, u8)] = ar;\n+            let ar = ar as *const (u8, u8, u8);\n+            let element = *arith_offset(arith_offset(ar, 102), -100);\n+            element.1\n+        };\n+        \"#,\n+        31,\n+    );\n+}\n+\n+#[test]\n+fn copy_nonoverlapping() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let mut x = 2;\n+            let y = 5;\n+            copy_nonoverlapping(&y, &mut x, 1);\n+            x\n+        };\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn copy() {\n+    check_number(\n+        r#\"\n+        //- minicore: coerce_unsized, index, slice\n+        extern \"rust-intrinsic\" {\n+            pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+        }\n+\n+        const GOAL: i32 = unsafe {\n+            let mut x = [1i32, 2, 3, 4, 5];\n+            let y = (&mut x as *mut _) as *mut i32;\n+            let z = (y as usize + 4) as *const i32;\n+            copy(z, y, 4);\n+            x[0] + x[1] + x[2] + x[3] + x[4]\n+        };\n+        \"#,\n+        19,\n+    );\n+}\n+\n+#[test]\n+fn ctpop() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn ctpop<T: Copy>(x: T) -> T;\n+        }\n+\n+        const GOAL: i64 = ctpop(-29);\n+        \"#,\n+        61,\n+    );\n+}\n+\n+#[test]\n+fn cttz() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn cttz<T: Copy>(x: T) -> T;\n+        }\n+\n+        const GOAL: i64 = cttz(-24);\n+        \"#,\n+        3,\n+    );\n+}"}, {"sha": "ca8a394e360dcde383a386f57b0935d878f7e7c0", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/db.rs", "status": "modified", "additions": 86, "deletions": 28, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,27 +1,27 @@\n //! The home of `HirDatabase`, which is the Salsa database containing all the\n //! type inference-related queries.\n \n-use std::sync::Arc;\n+use std::sync;\n \n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n-    db::DefDatabase,\n-    expr::ExprId,\n-    layout::{Layout, LayoutError, TargetDataLayout},\n-    AdtId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumVariantId, FunctionId, GenericDefId,\n-    ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n+    db::DefDatabase, hir::ExprId, layout::TargetDataLayout, AdtId, BlockId, ConstParamId,\n+    DefWithBodyId, EnumVariantId, FunctionId, GeneralConstId, GenericDefId, ImplId,\n+    LifetimeParamId, LocalFieldId, StaticId, TypeOrConstParamId, VariantId,\n };\n use la_arena::ArenaMap;\n use smallvec::SmallVec;\n+use triomphe::Arc;\n \n use crate::{\n     chalk_db,\n     consteval::ConstEvalError,\n+    layout::{Layout, LayoutError},\n     method_resolution::{InherentImpls, TraitImpls, TyFingerprint},\n     mir::{BorrowckResult, MirBody, MirLowerError},\n-    Binders, CallableDefId, Const, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner,\n-    PolyFnSig, QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId,\n-    ValueTyDefId,\n+    Binders, CallableDefId, ClosureId, Const, FnDefId, GenericArg, ImplTraitId, InferenceResult,\n+    Interner, PolyFnSig, QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty,\n+    TyDefId, ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n@@ -38,8 +38,28 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::cycle(crate::mir::mir_body_recover)]\n     fn mir_body(&self, def: DefWithBodyId) -> Result<Arc<MirBody>, MirLowerError>;\n \n+    #[salsa::invoke(crate::mir::mir_body_for_closure_query)]\n+    fn mir_body_for_closure(&self, def: ClosureId) -> Result<Arc<MirBody>, MirLowerError>;\n+\n+    #[salsa::invoke(crate::mir::monomorphized_mir_body_query)]\n+    #[salsa::cycle(crate::mir::monomorphized_mir_body_recover)]\n+    fn monomorphized_mir_body(\n+        &self,\n+        def: DefWithBodyId,\n+        subst: Substitution,\n+        env: Arc<crate::TraitEnvironment>,\n+    ) -> Result<Arc<MirBody>, MirLowerError>;\n+\n+    #[salsa::invoke(crate::mir::monomorphized_mir_body_for_closure_query)]\n+    fn monomorphized_mir_body_for_closure(\n+        &self,\n+        def: ClosureId,\n+        subst: Substitution,\n+        env: Arc<crate::TraitEnvironment>,\n+    ) -> Result<Arc<MirBody>, MirLowerError>;\n+\n     #[salsa::invoke(crate::mir::borrowck_query)]\n-    fn borrowck(&self, def: DefWithBodyId) -> Result<Arc<BorrowckResult>, MirLowerError>;\n+    fn borrowck(&self, def: DefWithBodyId) -> Result<Arc<[BorrowckResult]>, MirLowerError>;\n \n     #[salsa::invoke(crate::lower::ty_query)]\n     #[salsa::cycle(crate::lower::ty_recover)]\n@@ -57,7 +77,12 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n \n     #[salsa::invoke(crate::consteval::const_eval_query)]\n     #[salsa::cycle(crate::consteval::const_eval_recover)]\n-    fn const_eval(&self, def: ConstId) -> Result<Const, ConstEvalError>;\n+    fn const_eval(&self, def: GeneralConstId, subst: Substitution)\n+        -> Result<Const, ConstEvalError>;\n+\n+    #[salsa::invoke(crate::consteval::const_eval_static_query)]\n+    #[salsa::cycle(crate::consteval::const_eval_static_recover)]\n+    fn const_eval_static(&self, def: StaticId) -> Result<Const, ConstEvalError>;\n \n     #[salsa::invoke(crate::consteval::const_eval_discriminant_variant)]\n     #[salsa::cycle(crate::consteval::const_eval_discriminant_recover)]\n@@ -71,7 +96,16 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n \n     #[salsa::invoke(crate::layout::layout_of_adt_query)]\n     #[salsa::cycle(crate::layout::layout_of_adt_recover)]\n-    fn layout_of_adt(&self, def: AdtId, subst: Substitution) -> Result<Layout, LayoutError>;\n+    fn layout_of_adt(\n+        &self,\n+        def: AdtId,\n+        subst: Substitution,\n+        krate: CrateId,\n+    ) -> Result<Arc<Layout>, LayoutError>;\n+\n+    #[salsa::invoke(crate::layout::layout_of_ty_query)]\n+    #[salsa::cycle(crate::layout::layout_of_ty_recover)]\n+    fn layout_of_ty(&self, ty: Ty, krate: CrateId) -> Result<Arc<Layout>, LayoutError>;\n \n     #[salsa::invoke(crate::layout::target_data_layout_query)]\n     fn target_data_layout(&self, krate: CrateId) -> Option<Arc<TargetDataLayout>>;\n@@ -97,6 +131,10 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::generic_predicates_query)]\n     fn generic_predicates(&self, def: GenericDefId) -> Arc<[Binders<QuantifiedWhereClause>]>;\n \n+    #[salsa::invoke(crate::lower::trait_environment_for_body_query)]\n+    #[salsa::transparent]\n+    fn trait_environment_for_body(&self, def: DefWithBodyId) -> Arc<crate::TraitEnvironment>;\n+\n     #[salsa::invoke(crate::lower::trait_environment_query)]\n     fn trait_environment(&self, def: GenericDefId) -> Arc<crate::TraitEnvironment>;\n \n@@ -108,7 +146,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn inherent_impls_in_crate(&self, krate: CrateId) -> Arc<InherentImpls>;\n \n     #[salsa::invoke(InherentImpls::inherent_impls_in_block_query)]\n-    fn inherent_impls_in_block(&self, block: BlockId) -> Option<Arc<InherentImpls>>;\n+    fn inherent_impls_in_block(&self, block: BlockId) -> Arc<InherentImpls>;\n \n     /// Collects all crates in the dependency graph that have impls for the\n     /// given fingerprint. This is only used for primitive types and types\n@@ -125,10 +163,10 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn trait_impls_in_crate(&self, krate: CrateId) -> Arc<TraitImpls>;\n \n     #[salsa::invoke(TraitImpls::trait_impls_in_block_query)]\n-    fn trait_impls_in_block(&self, krate: BlockId) -> Option<Arc<TraitImpls>>;\n+    fn trait_impls_in_block(&self, block: BlockId) -> Arc<TraitImpls>;\n \n     #[salsa::invoke(TraitImpls::trait_impls_in_deps_query)]\n-    fn trait_impls_in_deps(&self, krate: CrateId) -> Arc<TraitImpls>;\n+    fn trait_impls_in_deps(&self, krate: CrateId) -> Arc<[Arc<TraitImpls>]>;\n \n     // Interned IDs for Chalk integration\n     #[salsa::interned]\n@@ -148,24 +186,34 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn intern_generator(&self, id: (DefWithBodyId, ExprId)) -> InternedGeneratorId;\n \n     #[salsa::invoke(chalk_db::associated_ty_data_query)]\n-    fn associated_ty_data(&self, id: chalk_db::AssocTypeId) -> Arc<chalk_db::AssociatedTyDatum>;\n+    fn associated_ty_data(\n+        &self,\n+        id: chalk_db::AssocTypeId,\n+    ) -> sync::Arc<chalk_db::AssociatedTyDatum>;\n \n     #[salsa::invoke(chalk_db::trait_datum_query)]\n-    fn trait_datum(&self, krate: CrateId, trait_id: chalk_db::TraitId)\n-        -> Arc<chalk_db::TraitDatum>;\n+    fn trait_datum(\n+        &self,\n+        krate: CrateId,\n+        trait_id: chalk_db::TraitId,\n+    ) -> sync::Arc<chalk_db::TraitDatum>;\n \n     #[salsa::invoke(chalk_db::struct_datum_query)]\n     fn struct_datum(\n         &self,\n         krate: CrateId,\n         struct_id: chalk_db::AdtId,\n-    ) -> Arc<chalk_db::StructDatum>;\n+    ) -> sync::Arc<chalk_db::StructDatum>;\n \n     #[salsa::invoke(chalk_db::impl_datum_query)]\n-    fn impl_datum(&self, krate: CrateId, impl_id: chalk_db::ImplId) -> Arc<chalk_db::ImplDatum>;\n+    fn impl_datum(\n+        &self,\n+        krate: CrateId,\n+        impl_id: chalk_db::ImplId,\n+    ) -> sync::Arc<chalk_db::ImplDatum>;\n \n     #[salsa::invoke(chalk_db::fn_def_datum_query)]\n-    fn fn_def_datum(&self, krate: CrateId, fn_def_id: FnDefId) -> Arc<chalk_db::FnDefDatum>;\n+    fn fn_def_datum(&self, krate: CrateId, fn_def_id: FnDefId) -> sync::Arc<chalk_db::FnDefDatum>;\n \n     #[salsa::invoke(chalk_db::fn_def_variance_query)]\n     fn fn_def_variance(&self, fn_def_id: FnDefId) -> chalk_db::Variances;\n@@ -178,7 +226,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n         &self,\n         krate: CrateId,\n         id: chalk_db::AssociatedTyValueId,\n-    ) -> Arc<chalk_db::AssociatedTyValue>;\n+    ) -> sync::Arc<chalk_db::AssociatedTyValue>;\n \n     #[salsa::invoke(crate::traits::normalize_projection_query)]\n     #[salsa::transparent]\n@@ -193,33 +241,42 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn trait_solve(\n         &self,\n         krate: CrateId,\n+        block: Option<BlockId>,\n         goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n     ) -> Option<crate::Solution>;\n \n     #[salsa::invoke(crate::traits::trait_solve_query)]\n     fn trait_solve_query(\n         &self,\n         krate: CrateId,\n+        block: Option<BlockId>,\n         goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n     ) -> Option<crate::Solution>;\n \n     #[salsa::invoke(chalk_db::program_clauses_for_chalk_env_query)]\n     fn program_clauses_for_chalk_env(\n         &self,\n         krate: CrateId,\n+        block: Option<BlockId>,\n         env: chalk_ir::Environment<Interner>,\n     ) -> chalk_ir::ProgramClauses<Interner>;\n }\n \n fn infer_wait(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n     let _p = profile::span(\"infer:wait\").detail(|| match def {\n-        DefWithBodyId::FunctionId(it) => db.function_data(it).name.to_string(),\n-        DefWithBodyId::StaticId(it) => db.static_data(it).name.clone().to_string(),\n-        DefWithBodyId::ConstId(it) => {\n-            db.const_data(it).name.clone().unwrap_or_else(Name::missing).to_string()\n+        DefWithBodyId::FunctionId(it) => db.function_data(it).name.display(db.upcast()).to_string(),\n+        DefWithBodyId::StaticId(it) => {\n+            db.static_data(it).name.clone().display(db.upcast()).to_string()\n         }\n+        DefWithBodyId::ConstId(it) => db\n+            .const_data(it)\n+            .name\n+            .clone()\n+            .unwrap_or_else(Name::missing)\n+            .display(db.upcast())\n+            .to_string(),\n         DefWithBodyId::VariantId(it) => {\n-            db.enum_data(it.parent).variants[it.local_id].name.to_string()\n+            db.enum_data(it.parent).variants[it.local_id].name.display(db.upcast()).to_string()\n         }\n     });\n     db.infer_query(def)\n@@ -228,10 +285,11 @@ fn infer_wait(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult>\n fn trait_solve_wait(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n+    block: Option<BlockId>,\n     goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n ) -> Option<crate::Solution> {\n     let _p = profile::span(\"trait_solve::wait\");\n-    db.trait_solve_query(krate, goal)\n+    db.trait_solve_query(krate, block, goal)\n }\n \n #[test]"}, {"sha": "1233469b947b48cbaf1a009ce58128a44677835f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -16,8 +16,8 @@ use std::fmt;\n \n use base_db::CrateId;\n use hir_def::{\n-    adt::VariantData,\n-    expr::{Pat, PatId},\n+    data::adt::VariantData,\n+    hir::{Pat, PatId},\n     src::HasSource,\n     AdtId, AttrDefId, ConstId, EnumId, FunctionId, ItemContainerId, Lookup, ModuleDefId, StaticId,\n     StructId,\n@@ -223,7 +223,7 @@ impl<'a> DeclValidator<'a> {\n         }\n \n         // Check the function name.\n-        let function_name = data.name.to_string();\n+        let function_name = data.name.display(self.db.upcast()).to_string();\n         let fn_name_replacement = to_lower_snake_case(&function_name).map(|new_name| Replacement {\n             current_name: data.name.clone(),\n             suggested_text: new_name,\n@@ -244,7 +244,9 @@ impl<'a> DeclValidator<'a> {\n                     id,\n                     Replacement {\n                         current_name: bind_name.clone(),\n-                        suggested_text: to_lower_snake_case(&bind_name.to_string())?,\n+                        suggested_text: to_lower_snake_case(\n+                            &bind_name.display(self.db.upcast()).to_string(),\n+                        )?,\n                         expected_case: CaseType::LowerSnakeCase,\n                     },\n                 ))\n@@ -287,7 +289,7 @@ impl<'a> DeclValidator<'a> {\n             ident_type: IdentType::Function,\n             ident: AstPtr::new(&ast_ptr),\n             expected_case: fn_name_replacement.expected_case,\n-            ident_text: fn_name_replacement.current_name.to_string(),\n+            ident_text: fn_name_replacement.current_name.display(self.db.upcast()).to_string(),\n             suggested_text: fn_name_replacement.suggested_text,\n         };\n \n@@ -343,7 +345,10 @@ impl<'a> DeclValidator<'a> {\n                             ident_type,\n                             ident: AstPtr::new(&name_ast),\n                             expected_case: replacement.expected_case,\n-                            ident_text: replacement.current_name.to_string(),\n+                            ident_text: replacement\n+                                .current_name\n+                                .display(self.db.upcast())\n+                                .to_string(),\n                             suggested_text: replacement.suggested_text,\n                         };\n \n@@ -362,7 +367,7 @@ impl<'a> DeclValidator<'a> {\n         let non_snake_case_allowed = self.allowed(struct_id.into(), allow::NON_SNAKE_CASE, false);\n \n         // Check the structure name.\n-        let struct_name = data.name.to_string();\n+        let struct_name = data.name.display(self.db.upcast()).to_string();\n         let struct_name_replacement = if !non_camel_case_allowed {\n             to_camel_case(&struct_name).map(|new_name| Replacement {\n                 current_name: data.name.clone(),\n@@ -379,7 +384,7 @@ impl<'a> DeclValidator<'a> {\n         if !non_snake_case_allowed {\n             if let VariantData::Record(fields) = data.variant_data.as_ref() {\n                 for (_, field) in fields.iter() {\n-                    let field_name = field.name.to_string();\n+                    let field_name = field.name.display(self.db.upcast()).to_string();\n                     if let Some(new_name) = to_lower_snake_case(&field_name) {\n                         let replacement = Replacement {\n                             current_name: field.name.clone(),\n@@ -434,7 +439,7 @@ impl<'a> DeclValidator<'a> {\n                 ident_type: IdentType::Structure,\n                 ident: AstPtr::new(&ast_ptr),\n                 expected_case: replacement.expected_case,\n-                ident_text: replacement.current_name.to_string(),\n+                ident_text: replacement.current_name.display(self.db.upcast()).to_string(),\n                 suggested_text: replacement.suggested_text,\n             };\n \n@@ -479,7 +484,7 @@ impl<'a> DeclValidator<'a> {\n                 ident_type: IdentType::Field,\n                 ident: AstPtr::new(&ast_ptr),\n                 expected_case: field_to_rename.expected_case,\n-                ident_text: field_to_rename.current_name.to_string(),\n+                ident_text: field_to_rename.current_name.display(self.db.upcast()).to_string(),\n                 suggested_text: field_to_rename.suggested_text,\n             };\n \n@@ -496,7 +501,7 @@ impl<'a> DeclValidator<'a> {\n         }\n \n         // Check the enum name.\n-        let enum_name = data.name.to_string();\n+        let enum_name = data.name.display(self.db.upcast()).to_string();\n         let enum_name_replacement = to_camel_case(&enum_name).map(|new_name| Replacement {\n             current_name: data.name.clone(),\n             suggested_text: new_name,\n@@ -510,7 +515,9 @@ impl<'a> DeclValidator<'a> {\n             .filter_map(|(_, variant)| {\n                 Some(Replacement {\n                     current_name: variant.name.clone(),\n-                    suggested_text: to_camel_case(&variant.name.to_string())?,\n+                    suggested_text: to_camel_case(\n+                        &variant.name.display(self.db.upcast()).to_string(),\n+                    )?,\n                     expected_case: CaseType::UpperCamelCase,\n                 })\n             })\n@@ -558,7 +565,7 @@ impl<'a> DeclValidator<'a> {\n                 ident_type: IdentType::Enum,\n                 ident: AstPtr::new(&ast_ptr),\n                 expected_case: replacement.expected_case,\n-                ident_text: replacement.current_name.to_string(),\n+                ident_text: replacement.current_name.display(self.db.upcast()).to_string(),\n                 suggested_text: replacement.suggested_text,\n             };\n \n@@ -603,7 +610,7 @@ impl<'a> DeclValidator<'a> {\n                 ident_type: IdentType::Variant,\n                 ident: AstPtr::new(&ast_ptr),\n                 expected_case: variant_to_rename.expected_case,\n-                ident_text: variant_to_rename.current_name.to_string(),\n+                ident_text: variant_to_rename.current_name.display(self.db.upcast()).to_string(),\n                 suggested_text: variant_to_rename.suggested_text,\n             };\n \n@@ -623,7 +630,7 @@ impl<'a> DeclValidator<'a> {\n             None => return,\n         };\n \n-        let const_name = name.to_string();\n+        let const_name = name.display(self.db.upcast()).to_string();\n         let replacement = if let Some(new_name) = to_upper_snake_case(&const_name) {\n             Replacement {\n                 current_name: name.clone(),\n@@ -648,7 +655,7 @@ impl<'a> DeclValidator<'a> {\n             ident_type: IdentType::Constant,\n             ident: AstPtr::new(&ast_ptr),\n             expected_case: replacement.expected_case,\n-            ident_text: replacement.current_name.to_string(),\n+            ident_text: replacement.current_name.display(self.db.upcast()).to_string(),\n             suggested_text: replacement.suggested_text,\n         };\n \n@@ -668,7 +675,7 @@ impl<'a> DeclValidator<'a> {\n \n         let name = &data.name;\n \n-        let static_name = name.to_string();\n+        let static_name = name.display(self.db.upcast()).to_string();\n         let replacement = if let Some(new_name) = to_upper_snake_case(&static_name) {\n             Replacement {\n                 current_name: name.clone(),\n@@ -693,7 +700,7 @@ impl<'a> DeclValidator<'a> {\n             ident_type: IdentType::StaticVariable,\n             ident: AstPtr::new(&ast_ptr),\n             expected_case: replacement.expected_case,\n-            ident_text: replacement.current_name.to_string(),\n+            ident_text: replacement.current_name.display(self.db.upcast()).to_string(),\n             suggested_text: replacement.suggested_text,\n         };\n "}, {"sha": "ab34dc88d87bc6c7c0bbb815b32a72308532645d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -3,7 +3,6 @@\n //! fields, etc.\n \n use std::fmt;\n-use std::sync::Arc;\n \n use either::Either;\n use hir_def::lang_item::LangItem;\n@@ -12,6 +11,7 @@ use hir_def::{ItemContainerId, Lookup};\n use hir_expand::name;\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n+use triomphe::Arc;\n use typed_arena::Arena;\n \n use crate::{\n@@ -27,7 +27,7 @@ use crate::{\n \n pub(crate) use hir_def::{\n     body::Body,\n-    expr::{Expr, ExprId, MatchArm, Pat, PatId},\n+    hir::{Expr, ExprId, MatchArm, Pat, PatId},\n     LocalFieldId, VariantId,\n };\n \n@@ -207,7 +207,7 @@ impl ExprValidator {\n \n         let report = compute_match_usefulness(&cx, &m_arms, scrut_ty);\n \n-        // FIXME Report unreacheble arms\n+        // FIXME Report unreachable arms\n         // https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200\n \n         let witnesses = report.non_exhaustiveness_witnesses;"}, {"sha": "f8cdeaa5e35493dfc55846352c3c636724bb7723", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,6 +1,6 @@\n //! Validation of matches.\n //!\n-//! This module provides lowering from [hir_def::expr::Pat] to [self::Pat] and match\n+//! This module provides lowering from [hir_def::hir::Pat] to [self::Pat] and match\n //! checking algorithm.\n //!\n //! It is modeled on the rustc module `rustc_mir_build::thir::pattern`.\n@@ -12,7 +12,7 @@ pub(crate) mod usefulness;\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    adt::VariantData, body::Body, expr::PatId, AdtId, EnumVariantId, LocalFieldId, VariantId,\n+    body::Body, data::adt::VariantData, hir::PatId, AdtId, EnumVariantId, LocalFieldId, VariantId,\n };\n use hir_expand::name::Name;\n use stdx::{always, never};\n@@ -125,15 +125,15 @@ impl<'a> PatCtxt<'a> {\n         let variant = self.infer.variant_resolution_for_pat(pat);\n \n         let kind = match self.body[pat] {\n-            hir_def::expr::Pat::Wild => PatKind::Wild,\n+            hir_def::hir::Pat::Wild => PatKind::Wild,\n \n-            hir_def::expr::Pat::Lit(expr) => self.lower_lit(expr),\n+            hir_def::hir::Pat::Lit(expr) => self.lower_lit(expr),\n \n-            hir_def::expr::Pat::Path(ref path) => {\n+            hir_def::hir::Pat::Path(ref path) => {\n                 return self.lower_path(pat, path);\n             }\n \n-            hir_def::expr::Pat::Tuple { ref args, ellipsis } => {\n+            hir_def::hir::Pat::Tuple { ref args, ellipsis } => {\n                 let arity = match *ty.kind(Interner) {\n                     TyKind::Tuple(arity, _) => arity,\n                     _ => {\n@@ -146,13 +146,14 @@ impl<'a> PatCtxt<'a> {\n                 PatKind::Leaf { subpatterns }\n             }\n \n-            hir_def::expr::Pat::Bind { id, subpat, .. } => {\n-                let bm = self.infer.pat_binding_modes[&pat];\n+            hir_def::hir::Pat::Bind { id, subpat, .. } => {\n+                let bm = self.infer.binding_modes[id];\n+                ty = &self.infer[id];\n                 let name = &self.body.bindings[id].name;\n                 match (bm, ty.kind(Interner)) {\n                     (BindingMode::Ref(_), TyKind::Ref(.., rty)) => ty = rty,\n                     (BindingMode::Ref(_), _) => {\n-                        never!(\"`ref {}` has wrong type {:?}\", name, ty);\n+                        never!(\"`ref {}` has wrong type {:?}\", name.display(self.db.upcast()), ty);\n                         self.errors.push(PatternError::UnexpectedType);\n                         return Pat { ty: ty.clone(), kind: PatKind::Wild.into() };\n                     }\n@@ -161,13 +162,13 @@ impl<'a> PatCtxt<'a> {\n                 PatKind::Binding { name: name.clone(), subpattern: self.lower_opt_pattern(subpat) }\n             }\n \n-            hir_def::expr::Pat::TupleStruct { ref args, ellipsis, .. } if variant.is_some() => {\n+            hir_def::hir::Pat::TupleStruct { ref args, ellipsis, .. } if variant.is_some() => {\n                 let expected_len = variant.unwrap().variant_data(self.db.upcast()).fields().len();\n                 let subpatterns = self.lower_tuple_subpats(args, expected_len, ellipsis);\n                 self.lower_variant_or_leaf(pat, ty, subpatterns)\n             }\n \n-            hir_def::expr::Pat::Record { ref args, .. } if variant.is_some() => {\n+            hir_def::hir::Pat::Record { ref args, .. } if variant.is_some() => {\n                 let variant_data = variant.unwrap().variant_data(self.db.upcast());\n                 let subpatterns = args\n                     .iter()\n@@ -187,12 +188,12 @@ impl<'a> PatCtxt<'a> {\n                     }\n                 }\n             }\n-            hir_def::expr::Pat::TupleStruct { .. } | hir_def::expr::Pat::Record { .. } => {\n+            hir_def::hir::Pat::TupleStruct { .. } | hir_def::hir::Pat::Record { .. } => {\n                 self.errors.push(PatternError::UnresolvedVariant);\n                 PatKind::Wild\n             }\n \n-            hir_def::expr::Pat::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n+            hir_def::hir::Pat::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n \n             _ => {\n                 self.errors.push(PatternError::Unimplemented);\n@@ -279,8 +280,8 @@ impl<'a> PatCtxt<'a> {\n         }\n     }\n \n-    fn lower_lit(&mut self, expr: hir_def::expr::ExprId) -> PatKind {\n-        use hir_def::expr::{Expr, Literal::Bool};\n+    fn lower_lit(&mut self, expr: hir_def::hir::ExprId) -> PatKind {\n+        use hir_def::hir::{Expr, Literal::Bool};\n \n         match self.body[expr] {\n             Expr::Literal(Bool(value)) => PatKind::LiteralBool { value },\n@@ -297,7 +298,7 @@ impl HirDisplay for Pat {\n         match &*self.kind {\n             PatKind::Wild => write!(f, \"_\"),\n             PatKind::Binding { name, subpattern } => {\n-                write!(f, \"{name}\")?;\n+                write!(f, \"{}\", name.display(f.db.upcast()))?;\n                 if let Some(subpattern) = subpattern {\n                     write!(f, \" @ \")?;\n                     subpattern.hir_fmt(f)?;\n@@ -318,10 +319,14 @@ impl HirDisplay for Pat {\n                     match variant {\n                         VariantId::EnumVariantId(v) => {\n                             let data = f.db.enum_data(v.parent);\n-                            write!(f, \"{}\", data.variants[v.local_id].name)?;\n+                            write!(f, \"{}\", data.variants[v.local_id].name.display(f.db.upcast()))?;\n+                        }\n+                        VariantId::StructId(s) => {\n+                            write!(f, \"{}\", f.db.struct_data(s).name.display(f.db.upcast()))?\n+                        }\n+                        VariantId::UnionId(u) => {\n+                            write!(f, \"{}\", f.db.union_data(u).name.display(f.db.upcast()))?\n                         }\n-                        VariantId::StructId(s) => write!(f, \"{}\", f.db.struct_data(s).name)?,\n-                        VariantId::UnionId(u) => write!(f, \"{}\", f.db.union_data(u).name)?,\n                     };\n \n                     let variant_data = variant.variant_data(f.db.upcast());\n@@ -335,7 +340,11 @@ impl HirDisplay for Pat {\n                             .map(|p| {\n                                 printed += 1;\n                                 WriteWith(move |f| {\n-                                    write!(f, \"{}: \", rec_fields[p.field].name)?;\n+                                    write!(\n+                                        f,\n+                                        \"{}: \",\n+                                        rec_fields[p.field].name.display(f.db.upcast())\n+                                    )?;\n                                     p.pattern.hir_fmt(f)\n                                 })\n                             });\n@@ -379,7 +388,7 @@ impl HirDisplay for Pat {\n             }\n             PatKind::Deref { subpattern } => {\n                 match self.ty.kind(Interner) {\n-                    TyKind::Adt(adt, _) if is_box(adt.0, f.db) => write!(f, \"box \")?,\n+                    TyKind::Adt(adt, _) if is_box(f.db, adt.0) => write!(f, \"box \")?,\n                     &TyKind::Ref(mutbl, ..) => {\n                         write!(f, \"&{}\", if mutbl == Mutability::Mut { \"mut \" } else { \"\" })?\n                     }"}, {"sha": "a0f6b9368ee01ad1ce3c91cba8d9390a76ab8f77", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -82,7 +82,7 @@ fn expand_or_pat(pat: &Pat) -> Vec<&Pat> {\n     pats\n }\n \n-/// [Constructor] uses this in umimplemented variants.\n+/// [Constructor] uses this in unimplemented variants.\n /// It allows porting match expressions from upstream algorithm without losing semantics.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(super) enum Void {}\n@@ -384,7 +384,7 @@ impl Constructor {\n                 TyKind::Tuple(arity, ..) => arity,\n                 TyKind::Ref(..) => 1,\n                 TyKind::Adt(adt, ..) => {\n-                    if is_box(adt.0, pcx.cx.db) {\n+                    if is_box(pcx.cx.db, adt.0) {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n                         1\n@@ -772,7 +772,7 @@ impl<'p> Fields<'p> {\n \n         (0..fields_len).map(|idx| LocalFieldId::from_raw(idx.into())).filter_map(move |fid| {\n             let ty = field_ty[fid].clone().substitute(Interner, substs);\n-            let ty = normalize(cx.db, cx.body, ty);\n+            let ty = normalize(cx.db, cx.db.trait_environment_for_body(cx.body), ty);\n             let is_visible = matches!(adt, hir_def::AdtId::EnumId(..))\n                 || visibility[fid].is_visible_from(cx.db.upcast(), cx.module);\n             let is_uninhabited = cx.is_uninhabited(&ty);\n@@ -800,7 +800,7 @@ impl<'p> Fields<'p> {\n                 }\n                 TyKind::Ref(.., rty) => Fields::wildcards_from_tys(cx, once(rty.clone())),\n                 &TyKind::Adt(AdtId(adt), ref substs) => {\n-                    if is_box(adt, cx.db) {\n+                    if is_box(cx.db, adt) {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n                         let subst_ty = substs.at(Interner, 0).assert_ty_ref(Interner).clone();\n@@ -905,7 +905,7 @@ impl<'p> DeconstructedPat<'p> {\n                         }\n                         fields = Fields::from_iter(cx, wilds)\n                     }\n-                    TyKind::Adt(adt, substs) if is_box(adt.0, cx.db) => {\n+                    TyKind::Adt(adt, substs) if is_box(cx.db, adt.0) => {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n                         // FIXME(Nadrieril): A `Box` can in theory be matched either with `Box(_,\n@@ -992,7 +992,7 @@ impl<'p> DeconstructedPat<'p> {\n                         })\n                         .collect(),\n                 },\n-                TyKind::Adt(adt, _) if is_box(adt.0, cx.db) => {\n+                TyKind::Adt(adt, _) if is_box(cx.db, adt.0) => {\n                     // Without `box_patterns`, the only legal pattern of type `Box` is `_` (outside\n                     // of `std`). So this branch is only reachable when the feature is enabled and\n                     // the pattern is a box pattern."}, {"sha": "217454499ef6dd7482180f23db531cc430158b07", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -1,4 +1,4 @@\n-//! Pattern untilities.\n+//! Pattern utilities.\n //!\n //! Originates from `rustc_hir::pat_util`\n "}, {"sha": "d737b24ad32bba991b608301508c9b298db08a1d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -755,7 +755,7 @@ pub(crate) enum Reachability {\n     /// The arm is reachable. This additionally carries a set of or-pattern branches that have been\n     /// found to be unreachable despite the overall arm being reachable. Used only in the presence\n     /// of or-patterns, otherwise it stays empty.\n-    // FIXME: store ureachable subpattern IDs\n+    // FIXME: store unreachable subpattern IDs\n     Reachable,\n     /// The arm is unreachable.\n     Unreachable,"}, {"sha": "7c38e6583a75f2b128b89b259b88763980a1c674", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68", "patch": "@@ -3,7 +3,7 @@\n \n use hir_def::{\n     body::Body,\n-    expr::{Expr, ExprId, UnaryOp},\n+    hir::{Expr, ExprId, UnaryOp},\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n     DefWithBodyId,\n };\n@@ -73,7 +73,7 @@ fn walk_unsafe(\n         }\n         Expr::Path(path) => {\n             let resolver = resolver_for_expr(db.upcast(), def, current);\n-            let value_or_partial = resolver.resolve_path_in_value_ns(db.upcast(), path.mod_path());\n+            let value_or_partial = resolver.resolve_path_in_value_ns(db.upcast(), path);\n             if let Some(ResolveValueResult::ValueNs(ValueNs::StaticId(id))) = value_or_partial {\n                 if db.static_data(id).mutable {\n                     unsafe_expr_cb(UnsafeExpr { expr: current, inside_unsafe_block });"}, {"sha": "f90e025c7cc624f06b9b3fd8e15d0625a29a8a64", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/display.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "80f32e96ee63f4b8cb712df1d04e7edb84687e8a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer.rs", "status": "modified", "additions": 334, "deletions": 167, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "23189f383e0e6ff8aff13f819af2011a81e505ad", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 928, "deletions": 4, "changes": 932, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "05a476f632dc25341d72163f526f57050fb5cd2d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "33e98ac86cf6b1f0f6c610c9a91a1c203817c748", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 278, "deletions": 182, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "447834243908a16c41cc4e602478e3f8d014086e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/mutability.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2480f8babac4f9398c4ef961c0e7451387bcea65", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "95a20f983f1b4058d0b4e29a800512b7d7ea18d8", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 91, "deletions": 21, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e33d8f1795e2e0198982ad05c34df73f43722791", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 130, "deletions": 27, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e5038543b68e6ac50a5b1130cb2d664f5b1663a2", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/inhabitedness.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "89f7d9c4f4abc2d0b534eb520da147087258bdf9", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/interner.rs", "status": "modified", "additions": 73, "deletions": 72, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "85ed46b96321a318defaadb7dee237f04163b991", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lang_items.rs", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flang_items.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "35d3407c16c1331688a0025ce137d281a1c96dd2", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout.rs", "status": "modified", "additions": 108, "deletions": 42, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "bd2752a7119ab98712a8385905c3ba6c34dc0faf", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout/adt.rs", "status": "modified", "additions": 82, "deletions": 24, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "04b940afbe8f8fe45d8a913ee51f309e1eb39521", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout/target.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "fca2e09ff0a996be4c8af257384f65d778f0c0ad", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 137, "deletions": 28, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "576e7f3fc619cf7b2518c08682275c5a2ab9916d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout/tests/closure.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "1a4d003bf5e993a48688c06e80267b9cbb456c73", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "modified", "additions": 60, "deletions": 25, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "0c68891fe4932de9478aa04103ac69dc533e88f3", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 132, "deletions": 78, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "6fa3d1351a9167dfe83a4a449d77c40ed6e1dd8c", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 156, "deletions": 147, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2345bab0bb4df4f859cfe5394fd5097b69fa4747", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir.rs", "status": "modified", "additions": 291, "deletions": 52, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "a0ea1cc5ef7d95d3d009d41b69c0a2f381ff43e2", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/borrowck.rs", "status": "modified", "additions": 217, "deletions": 49, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "ce14f6dbad536909f6997e639566906ef28449bc", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 1537, "deletions": 664, "changes": 2201, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "3b9ef03c369f49e680e3522e1eb0c307519c331c", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/eval/shim.rs", "status": "added", "additions": 792, "deletions": 0, "changes": 792, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "ca4268b8fb00c558dfc54d1652e51365e3a27b88", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/eval/tests.rs", "status": "added", "additions": 676, "deletions": 0, "changes": 676, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "aad1a82f2981cbf5081488e3de5ccc36ab863135", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 1077, "deletions": 716, "changes": 1793, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "d2c8d9a089e00060f3e85f8ca4682c2f445eee3f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/lower/as_place.rs", "status": "modified", "additions": 132, "deletions": 31, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "ff43c64a9e60f87510d93b9848d29031f1887458", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/lower/pattern_matching.rs", "status": "added", "additions": 617, "deletions": 0, "changes": 617, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "ce3f7a8e510264aab566ef6068f41bbed19d765f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/monomorphization.rs", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Fmonomorphization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Fmonomorphization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Fmonomorphization.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "58662b01b99b190221a2f9f0fd889e7f17cb9349", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 138, "deletions": 44, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "7d19e0a19169a314d82f94d49c4939d6a2bb2213", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/test_db.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2db04024b7b64bac2040def40eea65c542c3b8c2", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "16e5ef85d09d5b6a1d32f19de271ae0745bc968b", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 105, "deletions": 6, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "bb15ca8c436a22687e20cf0bda73534173ff58d5", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/incremental.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fincremental.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "111ac0b618eb2d32f90e5dc69042ceb62734a911", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "1e57a4ae2968aa5b3548ccc4a072411f07e80624", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 71, "deletions": 3, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "59046c0435a3a5ef95b6f921d9b26b1f600a0269", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/never_type.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "0f5a3e1752cf5f1269d39a5c790dbd3e6be941ad", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "f18c953a7afd2682ab90be68b61dec35a1453e1e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 189, "deletions": 22, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "3ece40486dde87e3c35bea4e14b6a53ce15fd0fe", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 323, "deletions": 27, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "829a6ab189ecc1a4a2cb51aeddde5d2d3770cba6", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 322, "deletions": 61, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "83814ed0ec1f199b91bbb73ee907ecebe800060f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tls.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "f40b7db3a5512e28accba338c0d0703432d49d8c", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/traits.rs", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "681d087ede6eaf9d1e4e8a294e2400b29a86156f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/utils.rs", "status": "modified", "additions": 118, "deletions": 8, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "a20aff93f19b7fb2c027c60b9efbbf488f4b17d5", "filename": "src/tools/rust-analyzer/crates/hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "b817937296d204607493bb4e98463db8e20a4c7e", "filename": "src/tools/rust-analyzer/crates/hir/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fattrs.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e0cde689fed88c1746d91c37d073fb83f9508634", "filename": "src/tools/rust-analyzer/crates/hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "b64d81490bb11e77e5abd61bccef907fa1deeb43", "filename": "src/tools/rust-analyzer/crates/hir/src/diagnostics.rs", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "9a2090ab79a2cf54b11cd2a13b7214860655905a", "filename": "src/tools/rust-analyzer/crates/hir/src/display.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "883e6a29b06a64bc1225210e03e21aae83b2e7f4", "filename": "src/tools/rust-analyzer/crates/hir/src/from_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "5926d8654210de589e8ef6f9d5f0d2454e8d9423", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 559, "deletions": 151, "changes": 710, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2d2b00b147e554078dd79c0a676672c82cfde769", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "c50ffa4f8b70349d6252c0f4a55c32f501d3a4b3", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "1374fa332c6483514d70a758840bf89103cc10fc", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "207e8206c92d5cf0b0ddf50ee169649ca2b74cb2", "filename": "src/tools/rust-analyzer/crates/hir/src/symbols.rs", "status": "modified", "additions": 129, "deletions": 167, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsymbols.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "8bc285614e039cfa5f86c6d93c73bca102e091d6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "6340feda452e14f1545fe70baf88621581d26d72", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 171, "deletions": 6, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "7384390f28b57d9d8b7ee9cdf4f4372fb72334c4", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e5f0201bd527e11a2af90781451bede675e44ae7", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_return_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "7acf2ea0a0de64bf75ff1b9738e4a41afd618d59", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "1af52c592183d4e7f7b403eb2b99c06c5dfca87e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_bool_then.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "db96c8fe40aa585329679309d674c48ab19c1dbc", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "5f7056b9c1c435000e9ee1d19d3df2b6af529cc2", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_let_else_to_match.rs", "status": "modified", "additions": 82, "deletions": 79, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "fc6236a17558c35e02a559ae7d656dce31ad9ade", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_match_to_let_else.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "fe1cb6fce3630de794425904a8258a665da12092", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_named_struct_to_tuple_struct.rs", "status": "modified", "additions": 205, "deletions": 43, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "399f87c8f509dd7d177316e3b4b8f3f670b62825", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_nested_function_to_closure.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_nested_function_to_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_nested_function_to_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_nested_function_to_closure.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "dcb96ab8af44fe26b9816ca5ada1130070c3f3de", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_to_guarded_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "017853a4a2023ceb512b24ac33f702a4ae9eca77", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "ea71d165e6aa68c65a88ab0c2e066de5998be6d2", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "5c435dd9c2960ae852d619d7afa86f461c3b7a88", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2a67909e6371945838fb71b3b6df7edbf72c7f6a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 168, "deletions": 17, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "de37f5f130fca9bdf167cfbb8bb63c9ea6e63829", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_module.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e4f64ccc754e099233e3e6237cbc807a61e65bc3", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "014c23197face98e68e03c32ec31aa835290bde6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "d6c59a9c829503d14a3891d057830d2525e59bb0", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "eccd7675fbaaedead8a053e924819eabc6fb1726", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_constant.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "3667fc375b439551f8e936ec242df90d00954f95", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 112, "deletions": 18, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "81545396175bae58a4c91e6d189286047a5f4078", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "78ac2eb30e59148955799ab5122a656e09f8842a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_derive.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e87132218ea907c3c240d763cc11e21c237a23b6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_documentation_template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "184f523e01bd9b5ddeae6cbfb1fbe1ad17f2370a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "850be21c300ca0f73f36f11c01220678dc8fd4d9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "dd6bbd84afccf03d8126899a76f0cfc29ffce061", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "824255e4f8e32ce666d829c3b3d5787ccf06a767", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "5aa8e56f5626c57e9668926d890a517b58e7a475", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_macro.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_macro.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "b0d35c02d67bac16be2505cc1711a852f25ca6f7", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/introduce_named_generic.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_generic.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "c5aa9755bc0b26c9f9ee36af748695bb2e68c680", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/introduce_named_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "aae9f20d4ea5c3f5c008b74b11e9ffeec7d68d21", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "b6027eac55dee7a5cbb803253bd912ec86c7f7a8", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_const_to_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "917d0b3671e8eec85cf3cb49b70c2885d5cca99b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_from_mod_rs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "166b25c69e188b55334d36ef5b2367464d3171e9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_module_to_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "b73270cd05fb5259658385d6ff2bfefd22e8ad57", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_to_mod_rs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "23153b4c566c8d4301f8480f253c1c369cff40ca", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/promote_local_to_const.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "a5c7fea403d31719b88b89f0ed01848c2a144879", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/pull_assignment_up.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "4bf974a5655af4607a18f215eea0fa61fdd5320f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/qualify_method_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "239149dc411d6c065e0a1c8112748f261bd711ef", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "40ee4771d170760e5bf421ac0bc62d66729f7cf4", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/raw_string.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "ffc32f8049968c55998820beeecf8d3ef2b1e920", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_parentheses.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_parentheses.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "0772b168d49c8e57977748a5d4fc55898148dd49", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_unused_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "02562566977400d0f3fbad36b25d43d483c08bf9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "66669662316fef39e6a2f272599fd44d6b938717", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/reorder_impl_items.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "36ac8c71d81548455f74c5667ec4bae6b4036b6f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e7b62d49bb81418c7c9ec5a1ee32695eb1352517", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_named_generic_with_impl.rs", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_named_generic_with_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_named_generic_with_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_named_generic_with_impl.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "6310981ccce7a34f9bd6449b0b250d05a206975b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_string_with_char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_string_with_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_string_with_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_string_with_char.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2e26f59d030ff6d3da36343f2fe48449fc9ce3b6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_try_expr_with_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "43a97d7d3a551b485ad54aa21676f84bad7456ec", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "3a0121f55fa02b6b89a4d4f01516627833dcf1fc", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/sort_items.rs", "status": "modified", "additions": 105, "deletions": 6, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "939055f148c45af785812af16eda7839ee1735a9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "26f3c192617e14d81a1239e2c9945e3de4225fdb", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unwrap_result_return_type.rs", "status": "modified", "additions": 96, "deletions": 23, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "bd282e53434093629c58b2e225811a65b1c35cec", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "344f2bfcce14adb564169250ed67be089fe7158a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "8a35fd290e686b4bf35e4431714a119143f071d6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "3da90e9052f2f29b80f321b94df3ea152b8e2966", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/sourcegen.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "8f7ea26306c427d0b4d802dbcf78a2b29dc6236f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "f74ebfae02c77423b88f5384d509288af2cd95d7", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils/suggest_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "480cb77b4fd6a8020aa39680b638da3c17e52ca1", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions.rs", "status": "modified", "additions": 99, "deletions": 33, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "466f0b1fb7f9b29d7f2444e602d12236ae4d45c1", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "19bfd294b25cc2a1229a73b6fb55318d8d4c46c0", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "9447bc7db0a79989467dbce50c87c4cda588185e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "6bc6f34ed41b30f27b679bfcb635216d495d051f", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "14f464b7753d7dbf7c8289bcf0469461a386448a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "57a784c45b6142e092ed861ebf2ecfe821bcad85", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "419b86456555989aea06baa1a90bd0af9feecf97", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/env_vars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "9daa6984c3e38ab824704867ced6ec207e836636", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "c717a9cb55b8e8373ad95ff1f937808f155bcdf2", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/extern_abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "39c1b7f7b3fb4846a7bd87a39c054279abebb0db", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 36, "deletions": 48, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "8b38d4f01f6730d04aa252504dba3e9a97abaf72", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/fn_param.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "8e904fd605a8dbc6b5fb301ab4a70c062f3a173a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/format_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "5ea6a49b1ae154587a4427a06d7d5feb81277740", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "7de1bf2dc131fccaa31a5c2b99be4f3135e4bc27", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2c6cbf6146a956cb6c8d67479d97b6098379a62a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/lifetime.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "d3e75c6da4761df4b4ae50bc5518dbbee40fda9c", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/mod_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "40b2c831a5d018b533c1e6699ab717d04de53b49", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2ffe123374471a4a73b53fb725914e5421c10d66", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "cb242e4aa68695dda953bd1fc725af3a20b59e25", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "945c3945bfa39c7e2f8bd00af2624ee18911e6e2", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e9831a5b2a1216c5ee4199cc519ff1e41b8c1f50", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/snippet.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e47054756389bac08a486cf3807b334b5e165e09", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "7a60030e9ef72bdab28ab9c0b4353e085d079954", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e0a959ad0b34058cd311fb479a79e5b513aa02d7", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/vis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "7b145f3c14e32d7618babebe5f5454ee264c9637", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "cc5221cfccbdc35a5b8546efd076220bfc649705", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e850f7bfdf3f90ff0e00199e3f7e57211583806a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/item.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "106d4e1e52f9a2f14d7659cfeb796d01101b8794", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "1953eb4795772a807b226248b2e78e16becca35e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "3c73983c39a2befca4975aeb3d3f0a0092cf65fe", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/const_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "8afce8db5ea86745f2b69e7731b440b3fb71340d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "728d236dff47612b90d74129f45ea349618eaa4b", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "ce7af1d3400e78d9f16af16a662c59d1d49b9396", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/macro_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "d06abc5e91e0bc4dddb70eb0ea65c26aaa977141", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "343ba7e28d8e0bd975b438056d6d82d8e21d4ae2", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/type_alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "93e943dbed98e68ccd7b73b2715c5f9e400ab757", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/union_literal.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "a9a01a3a30f5b9cbc656585968086da41e8ae99b", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/variant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2464e8d5f81751ba668aaa87bd512548ce4921d0", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "be5b7f8a3404e207d5ab04fa5e8a9ef651bf7f6e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 104, "deletions": 7, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "8c038c0fbaa1c93b519549f303dacd96e24c232f", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/flyimport.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2b5b4dd773c878c9b6b7f1af041766e472be80be", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/item_list.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "8af6cce98f6358529d641bcd523448b94687f876", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "789ad66345b12dd3199975ee47b4fb4daeeda127", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/predicate.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2d6234e310c6054595f0a4aa9fa804855c3b19f0", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/proc_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fproc_macros.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "3824720839eb9ebdea5a4bb460419cd9be9299dc", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "8cb1ff4a125f70c66fec059923ef2bab18979ff4", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/type_pos.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "4c74dba526b6f3a371fa73cf926c93e77a3374bf", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/use_tree.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fuse_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fuse_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fuse_tree.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "4e75dc4dba5410ee087b6bf2e3c7b560b03ba001", "filename": "src/tools/rust-analyzer/crates/ide-db/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "8edda432ce398238a04026dd4591d72f4cb040ba", "filename": "src/tools/rust-analyzer/crates/ide-db/src/apply_change.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "7a7328f312d201e948259ebff33fba011d4fd7e8", "filename": "src/tools/rust-analyzer/crates/ide-db/src/assists.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fassists.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "760834bfafc7bef603f14c8e27cb8ac9728ee706", "filename": "src/tools/rust-analyzer/crates/ide-db/src/defs.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "e488300b41caacae21aaccdb5a0d0a10d412c767", "filename": "src/tools/rust-analyzer/crates/ide-db/src/generated/lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fgenerated%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fgenerated%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fgenerated%2Flints.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "eba9d8afc40abf19412f7199080a5cf36f9c9976", "filename": "src/tools/rust-analyzer/crates/ide-db/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fhelpers.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "901d592c69104458fde917d3d86f78bc11192f04", "filename": "src/tools/rust-analyzer/crates/ide-db/src/imports/import_assets.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "46f1353e2e1b0967b95c0daab774fb89b01e59ca", "filename": "src/tools/rust-analyzer/crates/ide-db/src/items_locator.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fitems_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fitems_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fitems_locator.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "ff1a20f03f44cb24a094e3b8bf6b6e025541fa8c", "filename": "src/tools/rust-analyzer/crates/ide-db/src/lib.rs", "status": "modified", "additions": 197, "deletions": 28, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "16814a1e636fa2e51376bd86cafb7ab0d3215927", "filename": "src/tools/rust-analyzer/crates/ide-db/src/line_index.rs", "status": "removed", "additions": 0, "deletions": 314, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/7452822843cf461b56742f0fc648af35889a3070/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7452822843cf461b56742f0fc648af35889a3070/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs?ref=7452822843cf461b56742f0fc648af35889a3070"}, {"sha": "0ee627a44c68ec6af39ca58e2c56be72ba64efad", "filename": "src/tools/rust-analyzer/crates/ide-db/src/path_transform.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fpath_transform.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "52a23b4b8f3d2452244ae7534873d93a1503d7f2", "filename": "src/tools/rust-analyzer/crates/ide-db/src/rename.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Frename.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "73cd5dcaf23fc84a33d5c4fd04af742ada022e1f", "filename": "src/tools/rust-analyzer/crates/ide-db/src/search.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "061fb0f05cfb91964614b7ca57ad7fbe1cba052f", "filename": "src/tools/rust-analyzer/crates/ide-db/src/source_change.rs", "status": "modified", "additions": 116, "deletions": 9, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "b54c43b296b2addc4077405322c312963303ea49", "filename": "src/tools/rust-analyzer/crates/ide-db/src/symbol_index.rs", "status": "modified", "additions": 69, "deletions": 34, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsymbol_index.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "acf0a67de4a126bb354321a0d463d9b9e01fef70", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/format_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "fc230818193dc06b9a1d9a7f892ba62b04ae48e7", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/format_string_exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "0b0fc6693526f32ec1b739a24a24becf91bcd6fb", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/insert_whitespace_into_node.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Finsert_whitespace_into_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Finsert_whitespace_into_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Finsert_whitespace_into_node.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "22ced69d81e4a9157c002b427eeec4fdac982fbf", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "77714efa350409179ee53f541fbb22be3f6b665f", "filename": "src/tools/rust-analyzer/crates/ide-db/src/test_data/test_doc_alias.txt", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftest_data%2Ftest_doc_alias.txt", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftest_data%2Ftest_doc_alias.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftest_data%2Ftest_doc_alias.txt?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "b5adfc13d964404055403ca1c96bf166273d4f7a", "filename": "src/tools/rust-analyzer/crates/ide-db/src/test_data/test_symbol_index_collection.txt", "status": "modified", "additions": 207, "deletions": 31, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftest_data%2Ftest_symbol_index_collection.txt", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftest_data%2Ftest_symbol_index_collection.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftest_data%2Ftest_symbol_index_collection.txt?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "6b49bb2631c19bff46535620f4bdf8c3a7590562", "filename": "src/tools/rust-analyzer/crates/ide-db/src/tests/line_index.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftests%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftests%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftests%2Fline_index.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "9abbc344142912ed3fa086271ec2e4b8c25f2af7", "filename": "src/tools/rust-analyzer/crates/ide-db/src/traits.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Ftraits.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "f96ea29ae2f9d1df722985d87b00dd9e4c5a1fb1", "filename": "src/tools/rust-analyzer/crates/ide-db/src/use_trivial_constructor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fuse_trivial_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fuse_trivial_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fuse_trivial_constructor.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "30576c71fb7c2b9132d8c5ab34b820a5258d1356", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "90279e14536befb7d023f73d466d37c35d2e3b9a", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/incorrect_case.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "7547779a95c72da17fc1f07523f53eaefab95949", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/macro_error.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "60ccc41df01cc0fb4d26969cbc78de9ecd9cff87", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "3f13b97a44734271ec070f02e38f06c238b28c40", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "2026b6fcef537132ea3728cfc4d921965a862931", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_unsafe.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "32e321107e6f377ead44155d0fb9e7fc92887ee6", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/moved_out_of_ref.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmoved_out_of_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmoved_out_of_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmoved_out_of_ref.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}, {"sha": "f61460e317f78be183ca6afc80cd7c0270935257", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 461, "deletions": 13, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f896da247e0ee8f0bef7cd7c54cfbea255b9f68/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=2f896da247e0ee8f0bef7cd7c54cfbea255b9f68"}]}