{"sha": "473709541610bff6642b7abe67b5fbeb2554bdd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MzcwOTU0MTYxMGJmZjY2NDJiN2FiZTY3YjVmYmViMjU1NGJkZDE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-08T03:02:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-08T03:02:35Z"}, "message": "Rollup merge of #65040 - Centril:items-cleanup, r=estebank\n\nsyntax: more cleanups in item and function signature parsing\n\nFollow up to https://github.com/rust-lang/rust/pull/64910.\n\nBest read commit-by-commit.\n\nr? @estebank", "tree": {"sha": "aa543916abf0ae9950c50fedad8b93e88fdb8416", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa543916abf0ae9950c50fedad8b93e88fdb8416"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/473709541610bff6642b7abe67b5fbeb2554bdd1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdm/xLCRBK7hj4Ov3rIwAAdHIIAHqiKUTBdm1MLKCxbfEeGl3v\nGouQQG5yVnSPvDDKDkyICJXaW9WEQc4cPHbdtx5G/A6E/x2AyZj5YRVK/Qs9H5I/\nAABNFwihrz85CQOsSj1mlnmgRY9b1dPAzdcQm8l4638Uu0s3HUmrIxElkdOlN5X+\n5M1oE8rFteKCEcC9xOLuXovzzVkqxgwONwCBdiP87glULuG4Ij9I2oiMq74dsZVS\nvWuk2tRdC9qpvAVDE4sJDk42SNT263RPEkvXf1gLEaXgWuumGar3zRlqAC8fz7yD\nALLW8pLb7YpobP+Q3OOhrWEDid8YJC2PEaWHgbhjMsoxEHrl17nD4u6Nf1ZLGwQ=\n=IIIt\n-----END PGP SIGNATURE-----\n", "payload": "tree aa543916abf0ae9950c50fedad8b93e88fdb8416\nparent 2f0618d8c691904d43d99362b164487aba1f644d\nparent 6b23c22ccad4044476b65fc8f3e32794f1884781\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1570503755 +0200\ncommitter GitHub <noreply@github.com> 1570503755 +0200\n\nRollup merge of #65040 - Centril:items-cleanup, r=estebank\n\nsyntax: more cleanups in item and function signature parsing\n\nFollow up to https://github.com/rust-lang/rust/pull/64910.\n\nBest read commit-by-commit.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/473709541610bff6642b7abe67b5fbeb2554bdd1", "html_url": "https://github.com/rust-lang/rust/commit/473709541610bff6642b7abe67b5fbeb2554bdd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/473709541610bff6642b7abe67b5fbeb2554bdd1/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f0618d8c691904d43d99362b164487aba1f644d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0618d8c691904d43d99362b164487aba1f644d", "html_url": "https://github.com/rust-lang/rust/commit/2f0618d8c691904d43d99362b164487aba1f644d"}, {"sha": "6b23c22ccad4044476b65fc8f3e32794f1884781", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b23c22ccad4044476b65fc8f3e32794f1884781", "html_url": "https://github.com/rust-lang/rust/commit/6b23c22ccad4044476b65fc8f3e32794f1884781"}], "stats": {"total": 427, "additions": 212, "deletions": 215}, "files": [{"sha": "4a457f5a43caa651dd34e0bab0ccf7ffc8dc4b38", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 58, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/473709541610bff6642b7abe67b5fbeb2554bdd1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473709541610bff6642b7abe67b5fbeb2554bdd1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=473709541610bff6642b7abe67b5fbeb2554bdd1", "patch": "@@ -11,7 +11,7 @@ mod stmt;\n mod generics;\n \n use crate::ast::{\n-    self, DUMMY_NODE_ID, AttrStyle, Attribute, BindingMode, CrateSugar, FnDecl, Ident,\n+    self, DUMMY_NODE_ID, AttrStyle, Attribute, BindingMode, CrateSugar, Ident,\n     IsAsync, MacDelimiter, Mutability, Param, StrStyle, SelfKind, TyKind, Visibility,\n     VisibilityKind, Unsafety,\n };\n@@ -56,6 +56,17 @@ crate enum BlockMode {\n     Ignore,\n }\n \n+/// The parsing configuration used to parse a parameter list (see `parse_fn_params`).\n+struct ParamCfg {\n+    /// Is `self` is allowed as the first parameter?\n+    is_self_allowed: bool,\n+    /// Is `...` allowed as the tail of the parameter list?\n+    allow_c_variadic: bool,\n+    /// `is_name_required` decides if, per-parameter,\n+    /// the parameter must have a pattern or just a type.\n+    is_name_required: fn(&token::Token) -> bool,\n+}\n+\n /// Like `maybe_whole_expr`, but for things other than expressions.\n #[macro_export]\n macro_rules! maybe_whole {\n@@ -1094,26 +1105,18 @@ impl<'a> Parser<'a> {\n         res\n     }\n \n-    fn parse_fn_params(\n-        &mut self,\n-        named_params: bool,\n-        allow_c_variadic: bool,\n-    ) -> PResult<'a, Vec<Param>> {\n+    /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n+    fn parse_fn_params(&mut self, mut cfg: ParamCfg) -> PResult<'a, Vec<Param>> {\n         let sp = self.token.span;\n-        let do_not_enforce_named_params_for_c_variadic = |token: &token::Token| {\n-            match token.kind {\n-                token::DotDotDot => false,\n-                _ => named_params,\n-            }\n-        };\n+        let is_trait_item = cfg.is_self_allowed;\n         let mut c_variadic = false;\n+        // Parse the arguments, starting out with `self` being possibly allowed...\n         let (params, _) = self.parse_paren_comma_seq(|p| {\n-            match p.parse_param_general(\n-                false,\n-                false,\n-                allow_c_variadic,\n-                do_not_enforce_named_params_for_c_variadic,\n-            ) {\n+            let param = p.parse_param_general(&cfg, is_trait_item);\n+            // ...now that we've parsed the first argument, `self` is no longer allowed.\n+            cfg.is_self_allowed = false;\n+\n+            match param {\n                 Ok(param) => Ok(\n                     if let TyKind::CVarArgs = param.ty.kind {\n                         c_variadic = true;\n@@ -1144,7 +1147,10 @@ impl<'a> Parser<'a> {\n             }\n         })?;\n \n-        let params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n+        let mut params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n+\n+        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n+        self.deduplicate_recovered_params_names(&mut params);\n \n         if c_variadic && params.len() <= 1 {\n             self.span_err(\n@@ -1156,79 +1162,53 @@ impl<'a> Parser<'a> {\n         Ok(params)\n     }\n \n-    /// Parses the parameter list and result type of a function that may have a `self` parameter.\n-    fn parse_fn_decl_with_self(\n-        &mut self,\n-        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, P<FnDecl>> {\n-        // Parse the arguments, starting out with `self` being allowed...\n-        let mut is_self_allowed = true;\n-        let (mut inputs, _): (Vec<_>, _) = self.parse_paren_comma_seq(|p| {\n-            let res = p.parse_param_general(is_self_allowed, true, false, is_name_required);\n-            // ...but now that we've parsed the first argument, `self` is no longer allowed.\n-            is_self_allowed = false;\n-            res\n-        })?;\n-\n-        // Replace duplicated recovered params with `_` pattern to avoid unecessary errors.\n-        self.deduplicate_recovered_params_names(&mut inputs);\n-\n-        Ok(P(FnDecl {\n-            inputs,\n-            output: self.parse_ret_ty(true)?,\n-        }))\n-    }\n-\n     /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n     /// error.\n     /// This version of parse param doesn't necessarily require identifier names.\n-    fn parse_param_general(\n-        &mut self,\n-        is_self_allowed: bool,\n-        is_trait_item: bool,\n-        allow_c_variadic: bool,\n-        is_name_required: impl Fn(&token::Token) -> bool,\n-    ) -> PResult<'a, Param> {\n+    fn parse_param_general(&mut self, cfg: &ParamCfg, is_trait_item: bool) -> PResult<'a, Param> {\n         let lo = self.token.span;\n         let attrs = self.parse_outer_attributes()?;\n \n         // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n         if let Some(mut param) = self.parse_self_param()? {\n             param.attrs = attrs.into();\n-            return if is_self_allowed {\n+            return if cfg.is_self_allowed {\n                 Ok(param)\n             } else {\n                 self.recover_bad_self_param(param, is_trait_item)\n             };\n         }\n \n-        let is_name_required = is_name_required(&self.token);\n+        let is_name_required = match self.token.kind {\n+            token::DotDotDot => false,\n+            _ => (cfg.is_name_required)(&self.token),\n+        };\n         let (pat, ty) = if is_name_required || self.is_named_param() {\n             debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n \n             let pat = self.parse_fn_param_pat()?;\n             if let Err(mut err) = self.expect(&token::Colon) {\n-                if let Some(ident) = self.parameter_without_type(\n+                return if let Some(ident) = self.parameter_without_type(\n                     &mut err,\n                     pat,\n                     is_name_required,\n-                    is_self_allowed,\n+                    cfg.is_self_allowed,\n                     is_trait_item,\n                 ) {\n                     err.emit();\n-                    return Ok(dummy_arg(ident));\n+                    Ok(dummy_arg(ident))\n                 } else {\n-                    return Err(err);\n-                }\n+                    Err(err)\n+                };\n             }\n \n             self.eat_incorrect_doc_comment_for_param_type();\n-            (pat, self.parse_ty_common(true, true, allow_c_variadic)?)\n+            (pat, self.parse_ty_common(true, true, cfg.allow_c_variadic)?)\n         } else {\n             debug!(\"parse_param_general ident_to_pat\");\n             let parser_snapshot_before_ty = self.clone();\n             self.eat_incorrect_doc_comment_for_param_type();\n-            let mut ty = self.parse_ty_common(true, true, allow_c_variadic);\n+            let mut ty = self.parse_ty_common(true, true, cfg.allow_c_variadic);\n             if ty.is_ok() && self.token != token::Comma &&\n                self.token != token::CloseDelim(token::Paren) {\n                 // This wasn't actually a type, but a pattern looking like a type,"}, {"sha": "3c60c88e2aa5887b2001a173ca7b5356f894cfca", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 152, "deletions": 141, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/473709541610bff6642b7abe67b5fbeb2554bdd1/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473709541610bff6642b7abe67b5fbeb2554bdd1/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=473709541610bff6642b7abe67b5fbeb2554bdd1", "patch": "@@ -1,10 +1,10 @@\n-use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode};\n+use super::{Parser, PResult, PathStyle, SemiColonMode, BlockMode, ParamCfg};\n \n use crate::maybe_whole;\n use crate::ptr::P;\n use crate::ast::{\n     self, DUMMY_NODE_ID, Ident, Attribute, AttrStyle,\n-    Item, ItemKind, ImplItem, TraitItem, TraitItemKind,\n+    Item, ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind,\n     UseTree, UseTreeKind, PathSegment,\n     IsAuto, Constness, IsAsync, Unsafety, Defaultness,\n     Visibility, VisibilityKind, Mutability, FnDecl, FnHeader, MethodSig, Block,\n@@ -98,23 +98,22 @@ impl<'a> Parser<'a> {\n \n         let lo = self.token.span;\n \n-        let visibility = self.parse_visibility(false)?;\n+        let vis = self.parse_visibility(false)?;\n \n         if self.eat_keyword(kw::Use) {\n             // USE ITEM\n             let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n             self.expect(&token::Semi)?;\n \n             let span = lo.to(self.prev_span);\n-            let item =\n-                self.mk_item(span, Ident::invalid(), item_, visibility, attrs);\n+            let item = self.mk_item(span, Ident::invalid(), item_, vis, attrs);\n             return Ok(Some(item));\n         }\n \n         if self.eat_keyword(kw::Extern) {\n             let extern_sp = self.prev_span;\n             if self.eat_keyword(kw::Crate) {\n-                return Ok(Some(self.parse_item_extern_crate(lo, visibility, attrs)?));\n+                return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n             }\n \n             let opt_abi = self.parse_opt_abi()?;\n@@ -128,10 +127,10 @@ impl<'a> Parser<'a> {\n                     constness: respan(fn_span, Constness::NotConst),\n                     abi: opt_abi.unwrap_or(Abi::C),\n                 };\n-                return self.parse_item_fn(lo, visibility, attrs, header);\n+                return self.parse_item_fn(lo, vis, attrs, header);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n                 return Ok(Some(\n-                    self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs, extern_sp)?,\n+                    self.parse_item_foreign_mod(lo, opt_abi, vis, attrs, extern_sp)?,\n                 ));\n             }\n \n@@ -142,16 +141,14 @@ impl<'a> Parser<'a> {\n             self.bump();\n             // STATIC ITEM\n             let m = self.parse_mutability();\n-            let (ident, item_, extra_attrs) = self.parse_item_const(Some(m))?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_const(Some(m))?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.eat_keyword(kw::Const) {\n             let const_span = self.prev_span;\n             if [kw::Fn, kw::Unsafe, kw::Extern].iter().any(|k| self.check_keyword(*k)) {\n                 // CONST FUNCTION ITEM\n-\n                 let unsafety = self.parse_unsafety();\n \n                 if self.check_keyword(kw::Extern) {\n@@ -160,15 +157,15 @@ impl<'a> Parser<'a> {\n                     );\n                 }\n                 let abi = self.parse_extern_abi()?;\n-                self.bump(); // 'fn'\n+                self.bump(); // `fn`\n \n                 let header = FnHeader {\n                     unsafety,\n                     asyncness: respan(const_span, IsAsync::NotAsync),\n                     constness: respan(const_span, Constness::Const),\n                     abi,\n                 };\n-                return self.parse_item_fn(lo, visibility, attrs, header);\n+                return self.parse_item_fn(lo, vis, attrs, header);\n             }\n \n             // CONST ITEM\n@@ -184,10 +181,9 @@ impl<'a> Parser<'a> {\n                     )\n                     .emit();\n             }\n-            let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+\n+            let info = self.parse_item_const(None)?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n \n         // Parses `async unsafe? fn`.\n@@ -212,40 +208,33 @@ impl<'a> Parser<'a> {\n                     constness: respan(fn_span, Constness::NotConst),\n                     abi: Abi::Rust,\n                 };\n-                return self.parse_item_fn(lo, visibility, attrs, header);\n+                return self.parse_item_fn(lo, vis, attrs, header);\n             }\n         }\n+\n         if self.check_keyword(kw::Unsafe) &&\n             self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n         {\n             // UNSAFE TRAIT ITEM\n             self.bump(); // `unsafe`\n-            let is_auto = if self.eat_keyword(kw::Trait) {\n-                IsAuto::No\n-            } else {\n-                self.expect_keyword(kw::Auto)?;\n-                self.expect_keyword(kw::Trait)?;\n-                IsAuto::Yes\n-            };\n-            let (ident, item_, extra_attrs) = self.parse_item_trait(is_auto, Unsafety::Unsafe)?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_trait(Unsafety::Unsafe)?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.check_keyword(kw::Impl) ||\n            self.check_keyword(kw::Unsafe) &&\n                 self.is_keyword_ahead(1, &[kw::Impl]) ||\n            self.check_keyword(kw::Default) &&\n-                self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe]) {\n+                self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe])\n+        {\n             // IMPL ITEM\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n             self.expect_keyword(kw::Impl)?;\n-            let (ident, item_, extra_attrs) = self.parse_item_impl(unsafety, defaultness)?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_impl(unsafety, defaultness)?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.check_keyword(kw::Fn) {\n             // FUNCTION ITEM\n             self.bump();\n@@ -256,10 +245,12 @@ impl<'a> Parser<'a> {\n                 constness: respan(fn_span, Constness::NotConst),\n                 abi: Abi::Rust,\n             };\n-            return self.parse_item_fn(lo, visibility, attrs, header);\n+            return self.parse_item_fn(lo, vis, attrs, header);\n         }\n+\n         if self.check_keyword(kw::Unsafe)\n-            && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n+            && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace))\n+        {\n             // UNSAFE FUNCTION ITEM\n             self.bump(); // `unsafe`\n             // `{` is also expected after `unsafe`; in case of error, include it in the diagnostic.\n@@ -273,15 +264,15 @@ impl<'a> Parser<'a> {\n                 constness: respan(fn_span, Constness::NotConst),\n                 abi,\n             };\n-            return self.parse_item_fn(lo, visibility, attrs, header);\n+            return self.parse_item_fn(lo, vis, attrs, header);\n         }\n+\n         if self.eat_keyword(kw::Mod) {\n             // MODULE ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_mod(&attrs[..])?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_mod(&attrs[..])?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if let Some(type_) = self.eat_type() {\n             let (ident, alias, generics) = type_?;\n             // TYPE ITEM\n@@ -290,54 +281,44 @@ impl<'a> Parser<'a> {\n                 AliasKind::OpaqueTy(bounds) => ItemKind::OpaqueTy(bounds, generics),\n             };\n             let span = lo.to(self.prev_span);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            return Ok(Some(self.mk_item(span, ident, item_, vis, attrs)));\n         }\n+\n         if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_enum()?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.check_keyword(kw::Trait)\n             || (self.check_keyword(kw::Auto)\n                 && self.is_keyword_ahead(1, &[kw::Trait]))\n         {\n-            let is_auto = if self.eat_keyword(kw::Trait) {\n-                IsAuto::No\n-            } else {\n-                self.expect_keyword(kw::Auto)?;\n-                self.expect_keyword(kw::Trait)?;\n-                IsAuto::Yes\n-            };\n             // TRAIT ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_trait(is_auto, Unsafety::Normal)?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_trait(Unsafety::Normal)?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.eat_keyword(kw::Struct) {\n             // STRUCT ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_struct()?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n+\n         if self.is_union_item() {\n             // UNION ITEM\n             self.bump();\n-            let (ident, item_, extra_attrs) = self.parse_item_union()?;\n-            let span = lo.to(self.prev_span);\n-            let attrs = maybe_append(attrs, extra_attrs);\n-            return Ok(Some(self.mk_item(span, ident, item_, visibility, attrs)));\n+            let info = self.parse_item_union()?;\n+            return self.mk_item_with_info(attrs, lo, vis, info);\n         }\n-        if let Some(macro_def) = self.eat_macro_def(&attrs, &visibility, lo)? {\n+\n+        if let Some(macro_def) = self.eat_macro_def(&attrs, &vis, lo)? {\n             return Ok(Some(macro_def));\n         }\n \n         // Verify whether we have encountered a struct or method definition where the user forgot to\n         // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n-        if visibility.node.is_pub() &&\n+        if vis.node.is_pub() &&\n             self.check_ident() &&\n             self.look_ahead(1, |t| *t != token::Not)\n         {\n@@ -428,7 +409,20 @@ impl<'a> Parser<'a> {\n                 return Err(err);\n             }\n         }\n-        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, visibility)\n+        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, vis)\n+    }\n+\n+    fn mk_item_with_info(\n+        &self,\n+        attrs: Vec<Attribute>,\n+        lo: Span,\n+        vis: Visibility,\n+        info: ItemInfo,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let (ident, item, extra_attrs) = info;\n+        let span = lo.to(self.prev_span);\n+        let attrs = maybe_append(attrs, extra_attrs);\n+        Ok(Some(self.mk_item(span, ident, item, vis, attrs)))\n     }\n \n     fn recover_first_param(&mut self) -> &'static str {\n@@ -727,16 +721,7 @@ impl<'a> Parser<'a> {\n             };\n             (name, kind, generics)\n         } else if self.is_const_item() {\n-            // This parses the grammar:\n-            //     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n-            self.expect_keyword(kw::Const)?;\n-            let name = self.parse_ident()?;\n-            self.expect(&token::Colon)?;\n-            let typ = self.parse_ty()?;\n-            self.expect(&token::Eq)?;\n-            let expr = self.parse_expr()?;\n-            self.expect(&token::Semi)?;\n-            (name, ast::ImplItemKind::Const(typ, expr), Generics::default())\n+            self.parse_impl_const()?\n         } else {\n             let (name, inner_attrs, generics, kind) = self.parse_impl_method(&vis, at_end)?;\n             attrs.extend(inner_attrs);\n@@ -785,12 +770,25 @@ impl<'a> Parser<'a> {\n             !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n     }\n \n+    /// This parses the grammar:\n+    ///     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n+    fn parse_impl_const(&mut self) -> PResult<'a, (Ident, ImplItemKind, Generics)> {\n+        self.expect_keyword(kw::Const)?;\n+        let name = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let typ = self.parse_ty()?;\n+        self.expect(&token::Eq)?;\n+        let expr = self.parse_expr()?;\n+        self.expect(&token::Semi)?;\n+        Ok((name, ImplItemKind::Const(typ, expr), Generics::default()))\n+    }\n+\n     /// Parses a method or a macro invocation in a trait impl.\n     fn parse_impl_method(\n         &mut self,\n         vis: &Visibility,\n         at_end: &mut bool\n-    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ast::ImplItemKind)> {\n+    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ImplItemKind)> {\n         // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n         if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n             // method macro\n@@ -807,14 +805,15 @@ impl<'a> Parser<'a> {\n     /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n     fn parse_method_sig(\n         &mut self,\n-        is_name_required: impl Copy + Fn(&token::Token) -> bool,\n+        is_name_required: fn(&token::Token) -> bool,\n     ) -> PResult<'a, (Ident, MethodSig, Generics)> {\n         let header = self.parse_fn_front_matter()?;\n-        let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl_with_self(is_name_required)?;\n-        let sig = MethodSig { header, decl };\n-        generics.where_clause = self.parse_where_clause()?;\n-        Ok((ident, sig, generics))\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: true,\n+            allow_c_variadic: false,\n+            is_name_required,\n+        })?;\n+        Ok((ident, MethodSig { header, decl }, generics))\n     }\n \n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n@@ -849,8 +848,16 @@ impl<'a> Parser<'a> {\n         Ok(FnHeader { constness, unsafety, asyncness, abi })\n     }\n \n-    /// Parses `trait Foo { ... }` or `trait Foo = Bar;`.\n-    fn parse_item_trait(&mut self, is_auto: IsAuto, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n+    /// Parses `auto? trait Foo { ... }` or `trait Foo = Bar;`.\n+    fn parse_item_trait(&mut self, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n+        // Parse optional `auto` prefix.\n+        let is_auto = if self.eat_keyword(kw::Auto) {\n+            IsAuto::Yes\n+        } else {\n+            IsAuto::No\n+        };\n+\n+        self.expect_keyword(kw::Trait)?;\n         let ident = self.parse_ident()?;\n         let mut tps = self.parse_generics()?;\n \n@@ -935,38 +942,28 @@ impl<'a> Parser<'a> {\n         Ok(item)\n     }\n \n-    fn parse_trait_item_(&mut self,\n-                         at_end: &mut bool,\n-                         mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n+    fn parse_trait_item_(\n+        &mut self,\n+        at_end: &mut bool,\n+        mut attrs: Vec<Attribute>,\n+    ) -> PResult<'a, TraitItem> {\n         let lo = self.token.span;\n         self.eat_bad_pub();\n         let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_trait_item_assoc_ty()?\n         } else if self.is_const_item() {\n-            self.expect_keyword(kw::Const)?;\n-            let ident = self.parse_ident()?;\n-            self.expect(&token::Colon)?;\n-            let ty = self.parse_ty()?;\n-            let default = if self.eat(&token::Eq) {\n-                let expr = self.parse_expr()?;\n-                self.expect(&token::Semi)?;\n-                Some(expr)\n-            } else {\n-                self.expect(&token::Semi)?;\n-                None\n-            };\n-            (ident, TraitItemKind::Const(ty, default), Generics::default())\n+            self.parse_trait_item_const()?\n         } else if let Some(mac) = self.parse_assoc_macro_invoc(\"trait\", None, &mut false)? {\n             // trait item macro.\n-            (Ident::invalid(), ast::TraitItemKind::Macro(mac), Generics::default())\n+            (Ident::invalid(), TraitItemKind::Macro(mac), Generics::default())\n         } else {\n             // This is somewhat dubious; We don't want to allow\n             // argument names to be left off if there is a definition...\n             //\n             // We don't allow argument names to be left off in edition 2018.\n             let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n             let body = self.parse_trait_method_body(at_end, &mut attrs)?;\n-            (ident, ast::TraitItemKind::Method(sig, body), generics)\n+            (ident, TraitItemKind::Method(sig, body), generics)\n         };\n \n         Ok(TraitItem {\n@@ -980,6 +977,20 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn parse_trait_item_const(&mut self) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n+        self.expect_keyword(kw::Const)?;\n+        let ident = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+        let default = if self.eat(&token::Eq) {\n+            Some(self.parse_expr()?)\n+        } else {\n+            None\n+        };\n+        self.expect(&token::Semi)?;\n+        Ok((ident, TraitItemKind::Const(ty, default), Generics::default()))\n+    }\n+\n     /// Parse the \"body\" of a method in a trait item definition.\n     /// This can either be `;` when there's no body,\n     /// or e.g. a block when the method is a provided one.\n@@ -1020,8 +1031,7 @@ impl<'a> Parser<'a> {\n     /// Parses the following grammar:\n     ///\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n-    fn parse_trait_item_assoc_ty(&mut self)\n-        -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n+    fn parse_trait_item_assoc_ty(&mut self) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n \n@@ -1067,21 +1077,13 @@ impl<'a> Parser<'a> {\n                 );\n             }\n \n-            if self.eat(&token::BinOp(token::Star)) {\n-                UseTreeKind::Glob\n-            } else {\n-                UseTreeKind::Nested(self.parse_use_tree_list()?)\n-            }\n+            self.parse_use_tree_glob_or_nested()?\n         } else {\n             // `use path::*;` or `use path::{...};` or `use path;` or `use path as bar;`\n             prefix = self.parse_path(PathStyle::Mod)?;\n \n             if self.eat(&token::ModSep) {\n-                if self.eat(&token::BinOp(token::Star)) {\n-                    UseTreeKind::Glob\n-                } else {\n-                    UseTreeKind::Nested(self.parse_use_tree_list()?)\n-                }\n+                self.parse_use_tree_glob_or_nested()?\n             } else {\n                 UseTreeKind::Simple(self.parse_rename()?, DUMMY_NODE_ID, DUMMY_NODE_ID)\n             }\n@@ -1090,6 +1092,15 @@ impl<'a> Parser<'a> {\n         Ok(UseTree { prefix, kind, span: lo.to(self.prev_span) })\n     }\n \n+    /// Parses `*` or `{...}`.\n+    fn parse_use_tree_glob_or_nested(&mut self) -> PResult<'a, UseTreeKind> {\n+        Ok(if self.eat(&token::BinOp(token::Star)) {\n+            UseTreeKind::Glob\n+        } else {\n+            UseTreeKind::Nested(self.parse_use_tree_list()?)\n+        })\n+    }\n+\n     /// Parses a `UseTreeKind::Nested(list)`.\n     ///\n     /// ```\n@@ -1191,38 +1202,34 @@ impl<'a> Parser<'a> {\n         attrs: Vec<Attribute>,\n         header: FnHeader,\n     ) -> PResult<'a, Option<P<Item>>> {\n-        let allow_c_variadic = header.abi == Abi::C && header.unsafety == Unsafety::Unsafe;\n-        let (ident, decl, generics) = self.parse_fn_sig(allow_c_variadic)?;\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: header.abi == Abi::C && header.unsafety == Unsafety::Unsafe,\n+            is_name_required: |_| true,\n+        })?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        let span = lo.to(self.prev_span);\n         let kind = ItemKind::Fn(decl, header, generics, body);\n-        let attrs = maybe_append(attrs, Some(inner_attrs));\n-        Ok(Some(self.mk_item(span, ident, kind, vis, attrs)))\n+        self.mk_item_with_info(attrs, lo, vis, (ident, kind, Some(inner_attrs)))\n     }\n \n     /// Parse the \"signature\", including the identifier, parameters, and generics of a function.\n-    fn parse_fn_sig(\n-        &mut self,\n-        allow_c_variadic: bool,\n-    ) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n-        let (ident, mut generics) = self.parse_fn_header()?;\n-        let decl = self.parse_fn_decl(allow_c_variadic)?;\n+    fn parse_fn_sig(&mut self, cfg: ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n+        let ident = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+        let decl = self.parse_fn_decl(cfg, true)?;\n         generics.where_clause = self.parse_where_clause()?;\n         Ok((ident, decl, generics))\n     }\n \n-    /// Parses the name and optional generic types of a function header.\n-    fn parse_fn_header(&mut self) -> PResult<'a, (Ident, Generics)> {\n-        let id = self.parse_ident()?;\n-        let generics = self.parse_generics()?;\n-        Ok((id, generics))\n-    }\n-\n     /// Parses the parameter list and result type of a function declaration.\n-    fn parse_fn_decl(&mut self, allow_c_variadic: bool) -> PResult<'a, P<FnDecl>> {\n+    pub(super) fn parse_fn_decl(\n+        &mut self,\n+        cfg: ParamCfg,\n+        ret_allow_plus: bool,\n+    ) -> PResult<'a, P<FnDecl>> {\n         Ok(P(FnDecl {\n-            inputs: self.parse_fn_params(true, allow_c_variadic)?,\n-            output: self.parse_ret_ty(true)?,\n+            inputs: self.parse_fn_params(cfg)?,\n+            output: self.parse_ret_ty(ret_allow_plus)?,\n         }))\n     }\n \n@@ -1346,7 +1353,11 @@ impl<'a> Parser<'a> {\n         extern_sp: Span,\n     ) -> PResult<'a, ForeignItem> {\n         self.expect_keyword(kw::Fn)?;\n-        let (ident, decl, generics) = self.parse_fn_sig(true)?;\n+        let (ident, decl, generics) = self.parse_fn_sig(super::ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: true,\n+            is_name_required: |_| true,\n+        })?;\n         let span = lo.to(self.token.span);\n         self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n         Ok(ast::ForeignItem {"}, {"sha": "018b5951e6e2e797a923a9a80738e37255692ad0", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/473709541610bff6642b7abe67b5fbeb2554bdd1/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473709541610bff6642b7abe67b5fbeb2554bdd1/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=473709541610bff6642b7abe67b5fbeb2554bdd1", "patch": "@@ -4,13 +4,11 @@ use crate::{maybe_whole, maybe_recover_from_interpolated_ty_qpath};\n use crate::ptr::P;\n use crate::ast::{self, Ty, TyKind, MutTy, BareFnTy, FunctionRetTy, GenericParam, Lifetime, Ident};\n use crate::ast::{TraitBoundModifier, TraitObjectSyntax, GenericBound, GenericBounds, PolyTraitRef};\n-use crate::ast::{Mutability, AnonConst, FnDecl, Mac};\n+use crate::ast::{Mutability, AnonConst, Mac};\n use crate::parse::token::{self, Token};\n use crate::source_map::Span;\n use crate::symbol::{kw};\n \n-use rustc_target::spec::abi::Abi;\n-\n use errors::{Applicability, pluralise};\n \n /// Returns `true` if `IDENT t` can start a type -- `IDENT::a::b`, `IDENT<u8, u8>`,\n@@ -281,19 +279,14 @@ impl<'a> Parser<'a> {\n         */\n \n         let unsafety = self.parse_unsafety();\n-        let abi = if self.eat_keyword(kw::Extern) {\n-            self.parse_opt_abi()?.unwrap_or(Abi::C)\n-        } else {\n-            Abi::Rust\n-        };\n-\n+        let abi = self.parse_extern_abi()?;\n         self.expect_keyword(kw::Fn)?;\n-        let inputs = self.parse_fn_params(false, true)?;\n-        let ret_ty = self.parse_ret_ty(false)?;\n-        let decl = P(FnDecl {\n-            inputs,\n-            output: ret_ty,\n-        });\n+        let cfg = super::ParamCfg {\n+            is_self_allowed: false,\n+            allow_c_variadic: true,\n+            is_name_required: |_| false,\n+        };\n+        let decl = self.parse_fn_decl(cfg, false)?;\n         Ok(TyKind::BareFn(P(BareFnTy {\n             abi,\n             unsafety,"}, {"sha": "7291732cebe4a3751062346c6920758f349d38c5", "filename": "src/test/ui/parser/issue-33413.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/473709541610bff6642b7abe67b5fbeb2554bdd1/src%2Ftest%2Fui%2Fparser%2Fissue-33413.rs", "raw_url": "https://github.com/rust-lang/rust/raw/473709541610bff6642b7abe67b5fbeb2554bdd1/src%2Ftest%2Fui%2Fparser%2Fissue-33413.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33413.rs?ref=473709541610bff6642b7abe67b5fbeb2554bdd1", "patch": "@@ -3,6 +3,7 @@ struct S;\n impl S {\n     fn f(*, a: u8) -> u8 {}\n     //~^ ERROR expected parameter name, found `*`\n+    //~| ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "7e5c348e36ceac5073e18730a04b066186b5f148", "filename": "src/test/ui/parser/issue-33413.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/473709541610bff6642b7abe67b5fbeb2554bdd1/src%2Ftest%2Fui%2Fparser%2Fissue-33413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/473709541610bff6642b7abe67b5fbeb2554bdd1/src%2Ftest%2Fui%2Fparser%2Fissue-33413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-33413.stderr?ref=473709541610bff6642b7abe67b5fbeb2554bdd1", "patch": "@@ -4,5 +4,17 @@ error: expected parameter name, found `*`\n LL |     fn f(*, a: u8) -> u8 {}\n    |          ^ expected parameter name\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/issue-33413.rs:4:23\n+   |\n+LL |     fn f(*, a: u8) -> u8 {}\n+   |        -              ^^ expected u8, found ()\n+   |        |\n+   |        implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+   = note: expected type `u8`\n+              found type `()`\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}]}