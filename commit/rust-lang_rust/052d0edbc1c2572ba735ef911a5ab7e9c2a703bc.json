{"sha": "052d0edbc1c2572ba735ef911a5ab7e9c2a703bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MmQwZWRiYzFjMjU3MmJhNzM1ZWY5MTFhNWFiN2U5YzJhNzAzYmM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-29T19:46:25Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-12-03T13:41:56Z"}, "message": "rustc: compute FnAbi's for virtual calls through FnAbi::of_instance.", "tree": {"sha": "69fd9047f0ed41e79040271959d202277bcf414d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69fd9047f0ed41e79040271959d202277bcf414d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc", "html_url": "https://github.com/rust-lang/rust/commit/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39e50e2f289a58a46f46044d8e9d296b9e7ac7e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/39e50e2f289a58a46f46044d8e9d296b9e7ac7e6", "html_url": "https://github.com/rust-lang/rust/commit/39e50e2f289a58a46f46044d8e9d296b9e7ac7e6"}], "stats": {"total": 72, "additions": 36, "deletions": 36}, "files": [{"sha": "52f0bb220ad1fcfe3407ccd6d9cb65f596d5a431", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=052d0edbc1c2572ba735ef911a5ab7e9c2a703bc", "patch": "@@ -2347,9 +2347,8 @@ where\n         + HasTyCtxt<'tcx>\n         + HasParamEnv<'tcx>,\n {\n-    fn of_instance(cx: &C, instance: ty::Instance<'tcx>) -> Self;\n     fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+    fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n     fn new_internal(\n         cx: &C,\n         sig: ty::FnSig<'tcx>,\n@@ -2367,25 +2366,22 @@ where\n         + HasTyCtxt<'tcx>\n         + HasParamEnv<'tcx>,\n {\n-    fn of_instance(cx: &C, instance: ty::Instance<'tcx>) -> Self {\n+    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n+        call::FnAbi::new_internal(cx, sig, extra_args, |ty, _| ArgAbi::new(cx.layout_of(ty)))\n+    }\n+\n+    fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n         let sig = instance.fn_sig(cx.tcx());\n         let sig = cx\n             .tcx()\n             .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        call::FnAbi::new(cx, sig, &[])\n-    }\n-\n-    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        call::FnAbi::new_internal(cx, sig, extra_args, |ty, _| ArgAbi::new(cx.layout_of(ty)))\n-    }\n \n-    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        FnAbiExt::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n+        call::FnAbi::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n             let mut layout = cx.layout_of(ty);\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n             // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n             // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n-            if arg_idx == Some(0) {\n+            if let (ty::InstanceDef::Virtual(..), Some(0)) = (&instance.def, arg_idx) {\n                 let fat_pointer_ty = if layout.is_unsized() {\n                     // unsized `self` is passed as a pointer to `self`\n                     // FIXME (mikeyhew) change this to use &own if it is ever added to the language"}, {"sha": "74f4970333c86c4a9ee886f92082b44b0a346b7a", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=052d0edbc1c2572ba735ef911a5ab7e9c2a703bc", "patch": "@@ -40,7 +40,7 @@ pub fn get_fn(\n     let sym = tcx.symbol_name(instance).name.as_str();\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, instance.ty(cx.tcx()), sym);\n \n-    let fn_abi = FnAbi::of_instance(cx, instance);\n+    let fn_abi = FnAbi::of_instance(cx, instance, &[]);\n \n     let llfn = if let Some(llfn) = cx.get_declared_value(&sym) {\n         // Create a fn pointer with the new signature."}, {"sha": "75a4a966694832c1a0a0eae09ad943f85170f223", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=052d0edbc1c2572ba735ef911a5ab7e9c2a703bc", "patch": "@@ -43,7 +43,7 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n \n-        let fn_abi = FnAbi::of_instance(self, instance);\n+        let fn_abi = FnAbi::of_instance(self, instance, &[]);\n         let lldecl = self.declare_fn(symbol_name, &fn_abi);\n         unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n         let attrs = self.tcx.codegen_fn_attrs(instance.def_id());"}, {"sha": "3ef6caec2f2cf82d2e34256a8e194949f936f0ce", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=052d0edbc1c2572ba735ef911a5ab7e9c2a703bc", "patch": "@@ -345,20 +345,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             &args1[..]\n         };\n         let (drop_fn, fn_abi) = match ty.kind {\n+            // FIXME(eddyb) perhaps move some of this logic into\n+            // `Instance::resolve_drop_in_place`?\n             ty::Dynamic(..) => {\n-                let sig = drop_fn.fn_sig(self.cx.tcx());\n-                let sig = self.cx.tcx().normalize_erasing_late_bound_regions(\n-                    ty::ParamEnv::reveal_all(),\n-                    &sig,\n-                );\n-                let fn_abi = FnAbi::new_vtable(&bx, sig, &[]);\n+                let virtual_drop = Instance {\n+                    def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n+                    substs: drop_fn.substs,\n+                };\n+                let fn_abi = FnAbi::of_instance(&bx, virtual_drop, &[]);\n                 let vtable = args[1];\n                 args = &args[..1];\n                 (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_abi), fn_abi)\n             }\n             _ => {\n                 (bx.get_fn_addr(drop_fn),\n-                 FnAbi::of_instance(&bx, drop_fn))\n+                 FnAbi::of_instance(&bx, drop_fn, &[]))\n             }\n         };\n         helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n@@ -439,7 +440,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Obtain the panic entry point.\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n-        let fn_abi = FnAbi::of_instance(&bx, instance);\n+        let fn_abi = FnAbi::of_instance(&bx, instance, &[]);\n         let llfn = bx.get_fn_addr(instance);\n \n         // Codegen the actual panic invoke/call.\n@@ -474,6 +475,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => bug!(\"{} is not callable\", callee.layout.ty),\n         };\n         let def = instance.map(|i| i.def);\n+\n+        if let Some(ty::InstanceDef::DropGlue(_, None)) = def {\n+            // Empty drop glue; a no-op.\n+            let &(_, target) = destination.as_ref().unwrap();\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+            helper.funclet_br(self, &mut bx, target);\n+            return;\n+        }\n+\n+        // FIXME(eddyb) avoid computing this if possible, when `instance` is\n+        // available - right now `sig` is only needed for getting the `abi`\n+        // and figuring out how many extra args were passed to a C-variadic `fn`.\n         let sig = callee.layout.ty.fn_sig(bx.tcx());\n         let sig = bx.tcx().normalize_erasing_late_bound_regions(\n             ty::ParamEnv::reveal_all(),\n@@ -514,18 +527,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             self.monomorphize(&op_ty)\n         }).collect::<Vec<_>>();\n \n-        let fn_abi = match def {\n-            Some(ty::InstanceDef::Virtual(..)) => {\n-                FnAbi::new_vtable(&bx, sig, &extra_args)\n-            }\n-            Some(ty::InstanceDef::DropGlue(_, None)) => {\n-                // Empty drop glue; a no-op.\n-                let &(_, target) = destination.as_ref().unwrap();\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n-                helper.funclet_br(self, &mut bx, target);\n-                return;\n-            }\n-            _ => FnAbi::new(&bx, sig, &extra_args)\n+        let fn_abi = match instance {\n+            Some(instance) => FnAbi::of_instance(&bx, instance, &extra_args),\n+            None => FnAbi::new(&bx, sig, &extra_args)\n         };\n \n         // For normal codegen, this Miri-specific intrinsic is just a NOP.\n@@ -549,7 +553,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let def_id =\n                     common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_abi = FnAbi::of_instance(&bx, instance);\n+                let fn_abi = FnAbi::of_instance(&bx, instance, &[]);\n                 let llfn = bx.get_fn_addr(instance);\n \n                 if let Some((_, target)) = destination.as_ref() {"}, {"sha": "3a157ca24a47092a759c75d8158aa4369f1cfb70", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/052d0edbc1c2572ba735ef911a5ab7e9c2a703bc/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=052d0edbc1c2572ba735ef911a5ab7e9c2a703bc", "patch": "@@ -129,7 +129,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     let mir = cx.tcx().instance_mir(instance.def);\n \n-    let fn_abi = FnAbi::of_instance(cx, instance);\n+    let fn_abi = FnAbi::of_instance(cx, instance, &[]);\n     debug!(\"fn_abi: {:?}\", fn_abi);\n \n     let debug_context = cx.create_function_debug_context(instance, &fn_abi, llfn, &mir);"}]}