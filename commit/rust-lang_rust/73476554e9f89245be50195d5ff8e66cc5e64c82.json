{"sha": "73476554e9f89245be50195d5ff8e66cc5e64c82", "node_id": "C_kwDOAAsO6NoAKDczNDc2NTU0ZTlmODkyNDViZTUwMTk1ZDVmZjhlNjZjYzVlNjRjODI", "commit": {"author": {"name": "nils", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-01-11T16:30:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-11T16:30:54Z"}, "message": "Rollup merge of #106427 - mejrs:translation_errors, r=davidtwco\n\nImprove fluent error messages\n\nThese have been really frustrating me while migrating diagnostics.", "tree": {"sha": "291180ff80c335e8552b10fc87c733f099e0a0c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/291180ff80c335e8552b10fc87c733f099e0a0c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73476554e9f89245be50195d5ff8e66cc5e64c82", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjvuQ+CRBK7hj4Ov3rIwAAtrsIAFo1ascq3XQn7JUyzeubd027\nrz6sP82x+HuhGZ5UWU374GXolmKQzEd6YnFctnltKW4itvIK92T/B0BdPElwErzp\nm5VEFAhZ/sLrnfrEttmuGHaiWZuHBdHl35E4JeVHxFBReVm6xm1ezwyEmfslAdBN\nNd0hZRLxjkcVdthuAxgZMzXFLbCWIk+teV9NfVzDxdJd3JSkN1r9nNyWe6JEbvBY\ni8MSkKePMmXgedZkS5oKWV9GEpoxhWInJDe36f6QpoERSg7mBd89WXBDEq8RTtsn\n4JPpRXPwhpXvO7r/ghAwEyl2lClpg6IwSaCnEERykgiN9w5QYKMK5BSrzNi0P9s=\n=0lGJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 291180ff80c335e8552b10fc87c733f099e0a0c1\nparent 16938915a46c64dd83f02dee85e5b4eba6891076\nparent 4c0c32c895df28b762a61958b21cbe4d68f60238\nauthor nils <48135649+Nilstrieb@users.noreply.github.com> 1673454654 +0100\ncommitter GitHub <noreply@github.com> 1673454654 +0100\n\nRollup merge of #106427 - mejrs:translation_errors, r=davidtwco\n\nImprove fluent error messages\n\nThese have been really frustrating me while migrating diagnostics.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73476554e9f89245be50195d5ff8e66cc5e64c82", "html_url": "https://github.com/rust-lang/rust/commit/73476554e9f89245be50195d5ff8e66cc5e64c82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73476554e9f89245be50195d5ff8e66cc5e64c82/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16938915a46c64dd83f02dee85e5b4eba6891076", "url": "https://api.github.com/repos/rust-lang/rust/commits/16938915a46c64dd83f02dee85e5b4eba6891076", "html_url": "https://github.com/rust-lang/rust/commit/16938915a46c64dd83f02dee85e5b4eba6891076"}, {"sha": "4c0c32c895df28b762a61958b21cbe4d68f60238", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0c32c895df28b762a61958b21cbe4d68f60238", "html_url": "https://github.com/rust-lang/rust/commit/4c0c32c895df28b762a61958b21cbe4d68f60238"}], "stats": {"total": 483, "additions": 404, "deletions": 79}, "files": [{"sha": "7f01df321010bd39682d7378b980e6ea29a0e285", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=73476554e9f89245be50195d5ff8e66cc5e64c82", "patch": "@@ -28,6 +28,7 @@ use rustc_error_messages::{FluentArgs, SpanLabel};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use std::borrow::Cow;\n use std::cmp::{max, min, Reverse};\n+use std::error::Report;\n use std::io::prelude::*;\n use std::io::{self, IsTerminal};\n use std::iter;\n@@ -250,7 +251,7 @@ pub trait Emitter: Translate {\n         let mut primary_span = diag.span.clone();\n         let suggestions = diag.suggestions.as_deref().unwrap_or(&[]);\n         if let Some((sugg, rest)) = suggestions.split_first() {\n-            let msg = self.translate_message(&sugg.msg, fluent_args);\n+            let msg = self.translate_message(&sugg.msg, fluent_args).map_err(Report::new).unwrap();\n             if rest.is_empty() &&\n                // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n@@ -1325,7 +1326,7 @@ impl EmitterWriter {\n         //                very *weird* formats\n         //                see?\n         for (text, style) in msg.iter() {\n-            let text = self.translate_message(text, args);\n+            let text = self.translate_message(text, args).map_err(Report::new).unwrap();\n             let lines = text.split('\\n').collect::<Vec<_>>();\n             if lines.len() > 1 {\n                 for (i, line) in lines.iter().enumerate() {\n@@ -1387,7 +1388,7 @@ impl EmitterWriter {\n                 label_width += 2;\n             }\n             for (text, _) in msg.iter() {\n-                let text = self.translate_message(text, args);\n+                let text = self.translate_message(text, args).map_err(Report::new).unwrap();\n                 // Account for newlines to align output to its label.\n                 for (line, text) in normalize_whitespace(&text).lines().enumerate() {\n                     buffer.append(\n@@ -2301,7 +2302,9 @@ impl FileWithAnnotatedLines {\n                     hi.col_display += 1;\n                 }\n \n-                let label = label.as_ref().map(|m| emitter.translate_message(m, args).to_string());\n+                let label = label.as_ref().map(|m| {\n+                    emitter.translate_message(m, args).map_err(Report::new).unwrap().to_string()\n+                });\n \n                 if lo.line != hi.line {\n                     let ml = MultilineAnnotation {"}, {"sha": "ec0a2fe8cd8d010bf0d1fc5a4c32a88bf15aa32c", "filename": "compiler/rustc_errors/src/error.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ferror.rs?ref=73476554e9f89245be50195d5ff8e66cc5e64c82", "patch": "@@ -0,0 +1,137 @@\n+use rustc_error_messages::{\n+    fluent_bundle::resolver::errors::{ReferenceKind, ResolverError},\n+    FluentArgs, FluentError,\n+};\n+use std::borrow::Cow;\n+use std::error::Error;\n+use std::fmt;\n+\n+#[derive(Debug)]\n+pub enum TranslateError<'args> {\n+    One {\n+        id: &'args Cow<'args, str>,\n+        args: &'args FluentArgs<'args>,\n+        kind: TranslateErrorKind<'args>,\n+    },\n+    Two {\n+        primary: Box<TranslateError<'args>>,\n+        fallback: Box<TranslateError<'args>>,\n+    },\n+}\n+\n+impl<'args> TranslateError<'args> {\n+    pub fn message(id: &'args Cow<'args, str>, args: &'args FluentArgs<'args>) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::MessageMissing }\n+    }\n+    pub fn primary(id: &'args Cow<'args, str>, args: &'args FluentArgs<'args>) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::PrimaryBundleMissing }\n+    }\n+    pub fn attribute(\n+        id: &'args Cow<'args, str>,\n+        args: &'args FluentArgs<'args>,\n+        attr: &'args str,\n+    ) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::AttributeMissing { attr } }\n+    }\n+    pub fn value(id: &'args Cow<'args, str>, args: &'args FluentArgs<'args>) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::ValueMissing }\n+    }\n+\n+    pub fn fluent(\n+        id: &'args Cow<'args, str>,\n+        args: &'args FluentArgs<'args>,\n+        errs: Vec<FluentError>,\n+    ) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::Fluent { errs } }\n+    }\n+\n+    pub fn and(self, fallback: TranslateError<'args>) -> TranslateError<'args> {\n+        Self::Two { primary: Box::new(self), fallback: Box::new(fallback) }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum TranslateErrorKind<'args> {\n+    MessageMissing,\n+    PrimaryBundleMissing,\n+    AttributeMissing { attr: &'args str },\n+    ValueMissing,\n+    Fluent { errs: Vec<FluentError> },\n+}\n+\n+impl fmt::Display for TranslateError<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use TranslateErrorKind::*;\n+\n+        match self {\n+            Self::One { id, args, kind } => {\n+                writeln!(f, \"failed while formatting fluent string `{id}`: \")?;\n+                match kind {\n+                    MessageMissing => writeln!(f, \"message was missing\")?,\n+                    PrimaryBundleMissing => writeln!(f, \"the primary bundle was missing\")?,\n+                    AttributeMissing { attr } => {\n+                        writeln!(f, \"the attribute `{attr}` was missing\")?;\n+                        writeln!(f, \"help: add `.{attr} = <message>`\")?;\n+                    }\n+                    ValueMissing => writeln!(f, \"the value was missing\")?,\n+                    Fluent { errs } => {\n+                        for err in errs {\n+                            match err {\n+                                FluentError::ResolverError(ResolverError::Reference(\n+                                    ReferenceKind::Message { id, .. }\n+                                    | ReferenceKind::Variable { id, .. },\n+                                )) => {\n+                                    if args.iter().any(|(arg_id, _)| arg_id == id) {\n+                                        writeln!(\n+                                            f,\n+                                            \"argument `{id}` exists but was not referenced correctly\"\n+                                        )?;\n+                                        writeln!(f, \"help: try using `{{${id}}}` instead\")?;\n+                                    } else {\n+                                        writeln!(\n+                                            f,\n+                                            \"the fluent string has an argument `{id}` that was not found.\"\n+                                        )?;\n+                                        let vars: Vec<&str> =\n+                                            args.iter().map(|(a, _v)| a).collect();\n+                                        match &*vars {\n+                                            [] => writeln!(f, \"help: no arguments are available\")?,\n+                                            [one] => writeln!(\n+                                                f,\n+                                                \"help: the argument `{one}` is available\"\n+                                            )?,\n+                                            [first, middle @ .., last] => {\n+                                                write!(f, \"help: the arguments `{first}`\")?;\n+                                                for a in middle {\n+                                                    write!(f, \", `{a}`\")?;\n+                                                }\n+                                                writeln!(f, \" and `{last}` are available\")?;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                _ => writeln!(f, \"{err}\")?,\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            // If someone cares about primary bundles, they'll probably notice it's missing\n+            // regardless or will be using `debug_assertions`\n+            // so we skip the arm below this one to avoid confusing the regular user.\n+            Self::Two { primary: box Self::One { kind: PrimaryBundleMissing, .. }, fallback } => {\n+                fmt::Display::fmt(fallback, f)?;\n+            }\n+            Self::Two { primary, fallback } => {\n+                writeln!(\n+                    f,\n+                    \"first, fluent formatting using the primary bundle failed:\\n {primary}\\n \\\n+                    while attempting to recover by using the fallback bundle instead, another error occurred:\\n{fallback}\"\n+                )?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl Error for TranslateError<'_> {}"}, {"sha": "dc38b8725ad1e94ef2d29e94b82a0cd19a8357a2", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=73476554e9f89245be50195d5ff8e66cc5e64c82", "patch": "@@ -24,6 +24,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_error_messages::FluentArgs;\n use rustc_span::hygiene::ExpnData;\n use rustc_span::Span;\n+use std::error::Report;\n use std::io::{self, Write};\n use std::path::Path;\n use std::sync::{Arc, Mutex};\n@@ -321,7 +322,8 @@ impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n         let args = to_fluent_args(diag.args());\n         let sugg = diag.suggestions.iter().flatten().map(|sugg| {\n-            let translated_message = je.translate_message(&sugg.msg, &args);\n+            let translated_message =\n+                je.translate_message(&sugg.msg, &args).map_err(Report::new).unwrap();\n             Diagnostic {\n                 message: translated_message.to_string(),\n                 code: None,\n@@ -411,7 +413,10 @@ impl DiagnosticSpan {\n         Self::from_span_etc(\n             span.span,\n             span.is_primary,\n-            span.label.as_ref().map(|m| je.translate_message(m, args)).map(|m| m.to_string()),\n+            span.label\n+                .as_ref()\n+                .map(|m| je.translate_message(m, args).unwrap())\n+                .map(|m| m.to_string()),\n             suggestion,\n             je,\n         )"}, {"sha": "535812fb0e228f7e413c219293395bdbde4ad7f7", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=73476554e9f89245be50195d5ff8e66cc5e64c82", "patch": "@@ -11,6 +11,10 @@\n #![feature(never_type)]\n #![feature(result_option_inspect)]\n #![feature(rustc_attrs)]\n+#![feature(yeet_expr)]\n+#![feature(try_blocks)]\n+#![feature(box_patterns)]\n+#![feature(error_reporter)]\n #![allow(incomplete_features)]\n \n #[macro_use]\n@@ -41,6 +45,7 @@ use rustc_span::HashStableContext;\n use rustc_span::{Loc, Span};\n \n use std::borrow::Cow;\n+use std::error::Report;\n use std::fmt;\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n@@ -54,11 +59,14 @@ mod diagnostic;\n mod diagnostic_builder;\n mod diagnostic_impls;\n pub mod emitter;\n+pub mod error;\n pub mod json;\n mod lock;\n pub mod registry;\n mod snippet;\n mod styled_buffer;\n+#[cfg(test)]\n+mod tests;\n pub mod translation;\n \n pub use diagnostic_builder::IntoDiagnostic;\n@@ -616,7 +624,14 @@ impl Handler {\n     ) -> SubdiagnosticMessage {\n         let inner = self.inner.borrow();\n         let args = crate::translation::to_fluent_args(args);\n-        SubdiagnosticMessage::Eager(inner.emitter.translate_message(&message, &args).to_string())\n+        SubdiagnosticMessage::Eager(\n+            inner\n+                .emitter\n+                .translate_message(&message, &args)\n+                .map_err(Report::new)\n+                .unwrap()\n+                .to_string(),\n+        )\n     }\n \n     // This is here to not allow mutation of flags;"}, {"sha": "52103e4609770b50f3ae767ffb8ac754c8439059", "filename": "compiler/rustc_errors/src/tests.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftests.rs?ref=73476554e9f89245be50195d5ff8e66cc5e64c82", "patch": "@@ -0,0 +1,188 @@\n+use crate::error::{TranslateError, TranslateErrorKind};\n+use crate::fluent_bundle::*;\n+use crate::translation::Translate;\n+use crate::FluentBundle;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_error_messages::fluent_bundle::resolver::errors::{ReferenceKind, ResolverError};\n+use rustc_error_messages::langid;\n+use rustc_error_messages::DiagnosticMessage;\n+\n+struct Dummy {\n+    bundle: FluentBundle,\n+}\n+\n+impl Translate for Dummy {\n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &FluentBundle {\n+        &self.bundle\n+    }\n+}\n+\n+fn make_dummy(ftl: &'static str) -> Dummy {\n+    let resource = FluentResource::try_new(ftl.into()).expect(\"Failed to parse an FTL string.\");\n+\n+    let langid_en = langid!(\"en-US\");\n+\n+    #[cfg(parallel_compiler)]\n+    let mut bundle = FluentBundle::new_concurrent(vec![langid_en]);\n+\n+    #[cfg(not(parallel_compiler))]\n+    let mut bundle = FluentBundle::new(vec![langid_en]);\n+\n+    bundle.add_resource(resource).expect(\"Failed to add FTL resources to the bundle.\");\n+\n+    Dummy { bundle }\n+}\n+\n+#[test]\n+fn wellformed_fluent() {\n+    let dummy = make_dummy(\"mir_build_borrow_of_moved_value = borrow of moved value\n+    .label = value moved into `{$name}` here\n+    .occurs_because_label = move occurs because `{$name}` has type `{$ty}` which does not implement the `Copy` trait\n+    .value_borrowed_label = value borrowed here after move\n+    .suggestion = borrow this binding in the pattern to avoid moving the value\");\n+\n+    let mut args = FluentArgs::new();\n+    args.set(\"name\", \"Foo\");\n+    args.set(\"ty\", \"std::string::String\");\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"suggestion\".into()),\n+        );\n+\n+        assert_eq!(\n+            dummy.translate_message(&message, &args).unwrap(),\n+            \"borrow this binding in the pattern to avoid moving the value\"\n+        );\n+    }\n+\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"value_borrowed_label\".into()),\n+        );\n+\n+        assert_eq!(\n+            dummy.translate_message(&message, &args).unwrap(),\n+            \"value borrowed here after move\"\n+        );\n+    }\n+\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"occurs_because_label\".into()),\n+        );\n+\n+        assert_eq!(\n+            dummy.translate_message(&message, &args).unwrap(),\n+            \"move occurs because `\\u{2068}Foo\\u{2069}` has type `\\u{2068}std::string::String\\u{2069}` which does not implement the `Copy` trait\"\n+        );\n+\n+        {\n+            let message = DiagnosticMessage::FluentIdentifier(\n+                \"mir_build_borrow_of_moved_value\".into(),\n+                Some(\"label\".into()),\n+            );\n+\n+            assert_eq!(\n+                dummy.translate_message(&message, &args).unwrap(),\n+                \"value moved into `\\u{2068}Foo\\u{2069}` here\"\n+            );\n+        }\n+    }\n+}\n+\n+#[test]\n+fn misformed_fluent() {\n+    let dummy = make_dummy(\"mir_build_borrow_of_moved_value = borrow of moved value\n+    .label = value moved into `{name}` here\n+    .occurs_because_label = move occurs because `{$oops}` has type `{$ty}` which does not implement the `Copy` trait\n+    .suggestion = borrow this binding in the pattern to avoid moving the value\");\n+\n+    let mut args = FluentArgs::new();\n+    args.set(\"name\", \"Foo\");\n+    args.set(\"ty\", \"std::string::String\");\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"value_borrowed_label\".into()),\n+        );\n+\n+        let err = dummy.translate_message(&message, &args).unwrap_err();\n+        assert!(\n+            matches!(\n+                &err,\n+                TranslateError::Two {\n+                    primary: box TranslateError::One {\n+                        kind: TranslateErrorKind::PrimaryBundleMissing,\n+                        ..\n+                    },\n+                    fallback: box TranslateError::One {\n+                        kind: TranslateErrorKind::AttributeMissing { attr: \"value_borrowed_label\" },\n+                        ..\n+                    }\n+                }\n+            ),\n+            \"{err:#?}\"\n+        );\n+        assert_eq!(\n+            format!(\"{err}\"),\n+            \"failed while formatting fluent string `mir_build_borrow_of_moved_value`: \\nthe attribute `value_borrowed_label` was missing\\nhelp: add `.value_borrowed_label = <message>`\\n\"\n+        );\n+    }\n+\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"label\".into()),\n+        );\n+\n+        let err = dummy.translate_message(&message, &args).unwrap_err();\n+        if let TranslateError::Two {\n+            primary: box TranslateError::One { kind: TranslateErrorKind::PrimaryBundleMissing, .. },\n+            fallback: box TranslateError::One { kind: TranslateErrorKind::Fluent { errs }, .. },\n+        } = &err\n+            && let [FluentError::ResolverError(ResolverError::Reference(\n+                ReferenceKind::Message { id, .. }\n+                    | ReferenceKind::Variable { id, .. },\n+            ))] = &**errs\n+            && id == \"name\"\n+        {} else {\n+            panic!(\"{err:#?}\")\n+        };\n+        assert_eq!(\n+            format!(\"{err}\"),\n+            \"failed while formatting fluent string `mir_build_borrow_of_moved_value`: \\nargument `name` exists but was not referenced correctly\\nhelp: try using `{$name}` instead\\n\"\n+        );\n+    }\n+\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"occurs_because_label\".into()),\n+        );\n+\n+        let err = dummy.translate_message(&message, &args).unwrap_err();\n+        if let TranslateError::Two {\n+            primary: box TranslateError::One { kind: TranslateErrorKind::PrimaryBundleMissing, .. },\n+            fallback: box TranslateError::One { kind: TranslateErrorKind::Fluent { errs }, .. },\n+        } = &err\n+            && let [FluentError::ResolverError(ResolverError::Reference(\n+                ReferenceKind::Message { id, .. }\n+                    | ReferenceKind::Variable { id, .. },\n+            ))] = &**errs\n+            && id == \"oops\"\n+        {} else {\n+            panic!(\"{err:#?}\")\n+        };\n+        assert_eq!(\n+            format!(\"{err}\"),\n+            \"failed while formatting fluent string `mir_build_borrow_of_moved_value`: \\nthe fluent string has an argument `oops` that was not found.\\nhelp: the arguments `name` and `ty` are available\\n\"\n+        );\n+    }\n+}"}, {"sha": "addfc9726ca445372aadeeae6f2a64aa0676d05c", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 46, "deletions": 71, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73476554e9f89245be50195d5ff8e66cc5e64c82/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=73476554e9f89245be50195d5ff8e66cc5e64c82", "patch": "@@ -1,11 +1,10 @@\n+use crate::error::TranslateError;\n use crate::snippet::Style;\n use crate::{DiagnosticArg, DiagnosticMessage, FluentBundle};\n use rustc_data_structures::sync::Lrc;\n-use rustc_error_messages::{\n-    fluent_bundle::resolver::errors::{ReferenceKind, ResolverError},\n-    FluentArgs, FluentError,\n-};\n+use rustc_error_messages::FluentArgs;\n use std::borrow::Cow;\n+use std::error::Report;\n \n /// Convert diagnostic arguments (a rustc internal type that exists to implement\n /// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n@@ -46,7 +45,10 @@ pub trait Translate {\n         args: &FluentArgs<'_>,\n     ) -> Cow<'_, str> {\n         Cow::Owned(\n-            messages.iter().map(|(m, _)| self.translate_message(m, args)).collect::<String>(),\n+            messages\n+                .iter()\n+                .map(|(m, _)| self.translate_message(m, args).map_err(Report::new).unwrap())\n+                .collect::<String>(),\n         )\n     }\n \n@@ -55,83 +57,56 @@ pub trait Translate {\n         &'a self,\n         message: &'a DiagnosticMessage,\n         args: &'a FluentArgs<'_>,\n-    ) -> Cow<'_, str> {\n+    ) -> Result<Cow<'_, str>, TranslateError<'_>> {\n         trace!(?message, ?args);\n         let (identifier, attr) = match message {\n             DiagnosticMessage::Str(msg) | DiagnosticMessage::Eager(msg) => {\n-                return Cow::Borrowed(msg);\n+                return Ok(Cow::Borrowed(msg));\n             }\n             DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n         };\n+        let translate_with_bundle =\n+            |bundle: &'a FluentBundle| -> Result<Cow<'_, str>, TranslateError<'_>> {\n+                let message = bundle\n+                    .get_message(identifier)\n+                    .ok_or(TranslateError::message(identifier, args))?;\n+                let value = match attr {\n+                    Some(attr) => message\n+                        .get_attribute(attr)\n+                        .ok_or(TranslateError::attribute(identifier, args, attr))?\n+                        .value(),\n+                    None => message.value().ok_or(TranslateError::value(identifier, args))?,\n+                };\n+                debug!(?message, ?value);\n \n-        let translate_with_bundle = |bundle: &'a FluentBundle| -> Option<(Cow<'_, str>, Vec<_>)> {\n-            let message = bundle.get_message(identifier)?;\n-            let value = match attr {\n-                Some(attr) => message.get_attribute(attr)?.value(),\n-                None => message.value()?,\n+                let mut errs = vec![];\n+                let translated = bundle.format_pattern(value, Some(args), &mut errs);\n+                debug!(?translated, ?errs);\n+                if errs.is_empty() {\n+                    Ok(translated)\n+                } else {\n+                    Err(TranslateError::fluent(identifier, args, errs))\n+                }\n             };\n-            debug!(?message, ?value);\n-\n-            let mut errs = vec![];\n-            let translated = bundle.format_pattern(value, Some(args), &mut errs);\n-            debug!(?translated, ?errs);\n-            Some((translated, errs))\n-        };\n \n-        self.fluent_bundle()\n-            .and_then(|bundle| translate_with_bundle(bundle))\n-            // If `translate_with_bundle` returns `None` with the primary bundle, this is likely\n-            // just that the primary bundle doesn't contain the message being translated, so\n-            // proceed to the fallback bundle.\n-            //\n-            // However, when errors are produced from translation, then that means the translation\n-            // is broken (e.g. `{$foo}` exists in a translation but `foo` isn't provided).\n-            //\n-            // In debug builds, assert so that compiler devs can spot the broken translation and\n-            // fix it..\n-            .inspect(|(_, errs)| {\n-                debug_assert!(\n-                    errs.is_empty(),\n-                    \"identifier: {:?}, attr: {:?}, args: {:?}, errors: {:?}\",\n-                    identifier,\n-                    attr,\n-                    args,\n-                    errs\n-                );\n-            })\n-            // ..otherwise, for end users, an error about this wouldn't be useful or actionable, so\n-            // just hide it and try with the fallback bundle.\n-            .filter(|(_, errs)| errs.is_empty())\n-            .or_else(|| translate_with_bundle(self.fallback_fluent_bundle()))\n-            .map(|(translated, errs)| {\n-                // Always bail out for errors with the fallback bundle.\n+        try {\n+            match self.fluent_bundle().map(|b| translate_with_bundle(b)) {\n+                // The primary bundle was present and translation succeeded\n+                Some(Ok(t)) => t,\n \n-                let mut help_messages = vec![];\n+                // Always yeet out for errors on debug\n+                Some(Err(primary)) if cfg!(debug_assertions) => do yeet primary,\n \n-                if !errs.is_empty() {\n-                    for error in &errs {\n-                        match error {\n-                            FluentError::ResolverError(ResolverError::Reference(\n-                                ReferenceKind::Message { id, .. },\n-                            )) if args.iter().any(|(arg_id, _)| arg_id == id) => {\n-                                help_messages.push(format!(\"Argument `{id}` exists but was not referenced correctly. Try using `{{${id}}}` instead\"));\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n+                // If `translate_with_bundle` returns `Err` with the primary bundle, this is likely\n+                // just that the primary bundle doesn't contain the message being translated or\n+                // something else went wrong) so proceed to the fallback bundle.\n+                Some(Err(primary)) => translate_with_bundle(self.fallback_fluent_bundle())\n+                    .map_err(|fallback| primary.and(fallback))?,\n \n-                    panic!(\n-                        \"Encountered errors while formatting message for `{identifier}`\\n\\\n-                        help: {}\\n\\\n-                        attr: `{attr:?}`\\n\\\n-                        args: `{args:?}`\\n\\\n-                        errors: `{errs:?}`\",\n-                        help_messages.join(\"\\nhelp: \")\n-                    );\n-                }\n-\n-                translated\n-            })\n-            .expect(\"failed to find message in primary or fallback fluent bundles\")\n+                // The primary bundle is missing, proceed to the fallback bundle\n+                None => translate_with_bundle(self.fallback_fluent_bundle())\n+                    .map_err(|fallback| TranslateError::primary(identifier, args).and(fallback))?,\n+            }\n+        }\n     }\n }"}, {"sha": "7158355ffdacc65b06457aa5dc55882ec6967a8e", "filename": "src/librustdoc/passes/lint/check_code_block_syntax.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73476554e9f89245be50195d5ff8e66cc5e64c82/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73476554e9f89245be50195d5ff8e66cc5e64c82/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs?ref=73476554e9f89245be50195d5ff8e66cc5e64c82", "patch": "@@ -156,7 +156,9 @@ impl Emitter for BufferEmitter {\n         let mut buffer = self.buffer.borrow_mut();\n \n         let fluent_args = to_fluent_args(diag.args());\n-        let translated_main_message = self.translate_message(&diag.message[0].0, &fluent_args);\n+        let translated_main_message = self\n+            .translate_message(&diag.message[0].0, &fluent_args)\n+            .unwrap_or_else(|e| panic!(\"{e}\"));\n \n         buffer.messages.push(format!(\"error from rustc: {}\", translated_main_message));\n         if diag.is_error() {"}]}