{"sha": "6e2c49ff0e61e13aa3381eefba7923672a3c085f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMmM0OWZmMGU2MWUxM2FhMzM4MWVlZmJhNzkyMzY3MmEzYzA4NWY=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-06-29T13:43:34Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-07-06T23:41:30Z"}, "message": "Use an aligned dangling pointer in Weak::new, rather than address 1", "tree": {"sha": "23976200fddd5b5b805fc32b469eba53d79823a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23976200fddd5b5b805fc32b469eba53d79823a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e2c49ff0e61e13aa3381eefba7923672a3c085f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2c49ff0e61e13aa3381eefba7923672a3c085f", "html_url": "https://github.com/rust-lang/rust/commit/6e2c49ff0e61e13aa3381eefba7923672a3c085f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e2c49ff0e61e13aa3381eefba7923672a3c085f/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e06c875442e91cc2c597135d1e807a69e73eee26", "url": "https://api.github.com/repos/rust-lang/rust/commits/e06c875442e91cc2c597135d1e807a69e73eee26", "html_url": "https://github.com/rust-lang/rust/commit/e06c875442e91cc2c597135d1e807a69e73eee26"}], "stats": {"total": 50, "additions": 29, "deletions": 21}, "files": [{"sha": "abc0befeb947b61a8c5d64cadb3f4e9559bcd2e0", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6e2c49ff0e61e13aa3381eefba7923672a3c085f/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2c49ff0e61e13aa3381eefba7923672a3c085f/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=6e2c49ff0e61e13aa3381eefba7923672a3c085f", "patch": "@@ -43,9 +43,6 @@ use vec::Vec;\n /// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n-/// A sentinel value that is used for the pointer of `Weak::new()`.\n-const WEAK_EMPTY: usize = 1;\n-\n /// A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n /// Reference Counted'.\n ///\n@@ -239,9 +236,9 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n-    // but it is actually not truly \"non-null\". A `Weak::new()` will set this\n-    // to a sentinel value, instead of needing to allocate some space in the\n-    // heap.\n+    // but it is not necessarily a valid pointer.\n+    // `Weak::new` sets this to a dangling pointer so that it doesn\u2019t need\n+    // to allocate space on the heap.\n     ptr: NonNull<ArcInner<T>>,\n }\n \n@@ -1035,14 +1032,18 @@ impl<T> Weak<T> {\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n-        unsafe {\n-            Weak {\n-                ptr: NonNull::new_unchecked(WEAK_EMPTY as *mut _),\n-            }\n+        Weak {\n+            ptr: NonNull::dangling(),\n         }\n     }\n }\n \n+fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n+    let address = ptr.as_ptr() as *mut () as usize;\n+    let align = align_of_val(unsafe { ptr.as_ref() });\n+    address == align\n+}\n+\n impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Arc`], extending\n     /// the lifetime of the value if successful.\n@@ -1074,11 +1075,7 @@ impl<T: ?Sized> Weak<T> {\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n         // We use a CAS loop to increment the strong count instead of a\n         // fetch_add because once the count hits 0 it must never be above 0.\n-        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n-            return None;\n-        } else {\n-            unsafe { self.ptr.as_ref() }\n-        };\n+        let inner = self.inner()?;\n \n         // Relaxed load because any write of 0 that we can observe\n         // leaves the field in a permanently zero state (so a\n@@ -1109,6 +1106,17 @@ impl<T: ?Sized> Weak<T> {\n             }\n         }\n     }\n+\n+    /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n+    /// i.e. this `Weak` was created by `Weak::new`\n+    #[inline]\n+    fn inner(&self) -> Option<&ArcInner<T>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            Some(unsafe { self.ptr.as_ref() })\n+        }\n+    }\n }\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n@@ -1126,10 +1134,10 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n-        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n-            return Weak { ptr: self.ptr };\n+        let inner = if let Some(inner) = self.inner() {\n+            inner\n         } else {\n-            unsafe { self.ptr.as_ref() }\n+            return Weak { ptr: self.ptr };\n         };\n         // See comments in Arc::clone() for why this is relaxed.  This can use a\n         // fetch_add (ignoring the lock) because the weak count is only locked\n@@ -1204,10 +1212,10 @@ impl<T: ?Sized> Drop for Weak<T> {\n         // weak count can only be locked if there was precisely one weak ref,\n         // meaning that drop could only subsequently run ON that remaining weak\n         // ref, which can only happen after the lock is released.\n-        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n-            return;\n+        let inner = if let Some(inner) = self.inner() {\n+            inner\n         } else {\n-            unsafe { self.ptr.as_ref() }\n+            return\n         };\n \n         if inner.weak.fetch_sub(1, Release) == 1 {"}]}