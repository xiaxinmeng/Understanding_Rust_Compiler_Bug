{"sha": "0bba73c0d156df8f22c64ef4f4c50910fe31cf31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYmE3M2MwZDE1NmRmOGYyMmM2NGVmNGY0YzUwOTEwZmUzMWNmMzE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-11T15:15:22Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-22T23:40:06Z"}, "message": "std::rand: move Weighted to distributions.\n\nA user constructs the WeightedChoice distribution and then samples from\nit, which allows it to use binary search internally.", "tree": {"sha": "3a0b98b2985fdf4b4717aecab31464718d7dc162", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a0b98b2985fdf4b4717aecab31464718d7dc162"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bba73c0d156df8f22c64ef4f4c50910fe31cf31", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bba73c0d156df8f22c64ef4f4c50910fe31cf31", "html_url": "https://github.com/rust-lang/rust/commit/0bba73c0d156df8f22c64ef4f4c50910fe31cf31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bba73c0d156df8f22c64ef4f4c50910fe31cf31/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83aa1abb19ee290655ed03053e26cdb2662242c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/83aa1abb19ee290655ed03053e26cdb2662242c4", "html_url": "https://github.com/rust-lang/rust/commit/83aa1abb19ee290655ed03053e26cdb2662242c4"}], "stats": {"total": 339, "additions": 207, "deletions": 132}, "files": [{"sha": "e7bcf8ce5d3a71d0c0d14e41b6199cc0a1093c3a", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 207, "deletions": 1, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/0bba73c0d156df8f22c64ef4f4c50910fe31cf31/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bba73c0d156df8f22c64ef4f4c50910fe31cf31/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=0bba73c0d156df8f22c64ef4f4c50910fe31cf31", "patch": "@@ -20,8 +20,11 @@ that do not need to record state.\n \n */\n \n+use iter::range;\n+use option::{Some, None};\n use num;\n use rand::{Rng,Rand};\n+use clone::Clone;\n \n pub use self::range::Range;\n \n@@ -61,8 +64,128 @@ impl<Sup: Rand> IndependentSample<Sup> for RandSample<Sup> {\n     }\n }\n \n-mod ziggurat_tables;\n+/// A value with a particular weight for use with `WeightedChoice`.\n+pub struct Weighted<T> {\n+    /// The numerical weight of this item\n+    weight: uint,\n+    /// The actual item which is being weighted\n+    item: T,\n+}\n+\n+/// A distribution that selects from a finite collection of weighted items.\n+///\n+/// Each item has an associated weight that influences how likely it\n+/// is to be chosen: higher weight is more likely.\n+///\n+/// The `Clone` restriction is a limitation of the `Sample` and\n+/// `IndepedentSample` traits. Note that `&T` is (cheaply) `Clone` for\n+/// all `T`, as is `uint`, so one can store references or indices into\n+/// another vector.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{Weighted, WeightedChoice, IndepedentSample};\n+///\n+/// fn main() {\n+///     let wc = WeightedChoice::new(~[Weighted { weight: 2, item: 'a' },\n+///                                    Weighted { weight: 4, item: 'b' },\n+///                                    Weighted { weight: 1, item: 'c' }]);\n+///     let rng = rand::task_rng();\n+///     for _ in range(0, 16) {\n+///          // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n+///          println!(\"{}\", wc.ind_sample(rng));\n+///     }\n+/// }\n+/// ```\n+pub struct WeightedChoice<T> {\n+    priv items: ~[Weighted<T>],\n+    priv weight_range: Range<uint>\n+}\n+\n+impl<T: Clone> WeightedChoice<T> {\n+    /// Create a new `WeightedChoice`.\n+    ///\n+    /// Fails if:\n+    /// - `v` is empty\n+    /// - the total weight is 0\n+    /// - the total weight is larger than a `uint` can contain.\n+    pub fn new(mut items: ~[Weighted<T>]) -> WeightedChoice<T> {\n+        // strictly speaking, this is subsumed by the total weight == 0 case\n+        assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n+\n+        let mut running_total = 0u;\n+\n+        // we convert the list from individual weights to cumulative\n+        // weights so we can binary search. This *could* drop elements\n+        // with weight == 0 as an optimisation.\n+        for item in items.mut_iter() {\n+            running_total = running_total.checked_add(&item.weight)\n+                .expect(\"WeightedChoice::new called with a total weight larger \\\n+                        than a uint can contain\");\n+\n+            item.weight = running_total;\n+        }\n+        assert!(running_total != 0, \"WeightedChoice::new called with a total weight of 0\");\n+\n+        WeightedChoice {\n+            items: items,\n+            // we're likely to be generating numbers in this range\n+            // relatively often, so might as well cache it\n+            weight_range: Range::new(0, running_total)\n+        }\n+    }\n+}\n+\n+impl<T: Clone> Sample<T> for WeightedChoice<T> {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> T { self.ind_sample(rng) }\n+}\n \n+impl<T: Clone> IndependentSample<T> for WeightedChoice<T> {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> T {\n+        // we want to find the first element that has cumulative\n+        // weight > sample_weight, which we do by binary since the\n+        // cumulative weights of self.items are sorted.\n+\n+        // choose a weight in [0, total_weight)\n+        let sample_weight = self.weight_range.ind_sample(rng);\n+\n+        // short circuit when it's the first item\n+        if sample_weight < self.items[0].weight {\n+            return self.items[0].item.clone();\n+        }\n+\n+        let mut idx = 0;\n+        let mut modifier = self.items.len();\n+\n+        // now we know that every possibility has an element to the\n+        // left, so we can just search for the last element that has\n+        // cumulative weight <= sample_weight, then the next one will\n+        // be \"it\". (Note that this greatest element will never be the\n+        // last element of the vector, since sample_weight is chosen\n+        // in [0, total_weight) and the cumulative weight of the last\n+        // one is exactly the total weight.)\n+        while modifier > 1 {\n+            let i = idx + modifier / 2;\n+            if self.items[i].weight <= sample_weight {\n+                // we're small, so look to the right, but allow this\n+                // exact element still.\n+                idx = i;\n+                // we need the `/ 2` to round up otherwise we'll drop\n+                // the trailing elements when `modifier` is odd.\n+                modifier += 1;\n+            } else {\n+                // otherwise we're too big, so go left. (i.e. do\n+                // nothing)\n+            }\n+            modifier /= 2;\n+        }\n+        return self.items[idx + 1].item.clone();\n+    }\n+}\n+\n+mod ziggurat_tables;\n \n /// Sample a random number using the Ziggurat method (specifically the\n /// ZIGNOR variant from Doornik 2005). Most of the arguments are\n@@ -302,6 +425,18 @@ mod tests {\n         }\n     }\n \n+    // 0, 1, 2, 3, ...\n+    struct CountingRng { i: u32 }\n+    impl Rng for CountingRng {\n+        fn next_u32(&mut self) -> u32 {\n+            self.i += 1;\n+            self.i - 1\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            self.next_u32() as u64\n+        }\n+    }\n+\n     #[test]\n     fn test_rand_sample() {\n         let mut rand_sample = RandSample::<ConstRand>;\n@@ -344,6 +479,77 @@ mod tests {\n     fn test_exp_invalid_lambda_neg() {\n         Exp::new(-10.0);\n     }\n+\n+    #[test]\n+    fn test_weighted_choice() {\n+        // this makes assumptions about the internal implementation of\n+        // WeightedChoice, specifically: it doesn't reorder the items,\n+        // it doesn't do weird things to the RNG (so 0 maps to 0, 1 to\n+        // 1, internally; modulo a modulo operation).\n+\n+        macro_rules! t (\n+            ($items:expr, $expected:expr) => {{\n+                let wc = WeightedChoice::new($items);\n+                let expected = $expected;\n+\n+                let mut rng = CountingRng { i: 0 };\n+\n+                for &val in expected.iter() {\n+                    assert_eq!(wc.ind_sample(&mut rng), val)\n+                }\n+            }}\n+        );\n+\n+        t!(~[Weighted { weight: 1, item: 10}], ~[10]);\n+\n+        // skip some\n+        t!(~[Weighted { weight: 0, item: 20},\n+             Weighted { weight: 2, item: 21},\n+             Weighted { weight: 0, item: 22},\n+             Weighted { weight: 1, item: 23}],\n+           ~[21,21, 23]);\n+\n+        // different weights\n+        t!(~[Weighted { weight: 4, item: 30},\n+             Weighted { weight: 3, item: 31}],\n+           ~[30,30,30,30, 31,31,31]);\n+\n+        // check that we're binary searching\n+        // correctly with some vectors of odd\n+        // length.\n+        t!(~[Weighted { weight: 1, item: 40},\n+             Weighted { weight: 1, item: 41},\n+             Weighted { weight: 1, item: 42},\n+             Weighted { weight: 1, item: 43},\n+             Weighted { weight: 1, item: 44}],\n+           ~[40, 41, 42, 43, 44]);\n+        t!(~[Weighted { weight: 1, item: 50},\n+             Weighted { weight: 1, item: 51},\n+             Weighted { weight: 1, item: 52},\n+             Weighted { weight: 1, item: 53},\n+             Weighted { weight: 1, item: 54},\n+             Weighted { weight: 1, item: 55},\n+             Weighted { weight: 1, item: 56}],\n+           ~[50, 51, 52, 53, 54, 55, 56]);\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_weighted_choice_no_items() {\n+        WeightedChoice::<int>::new(~[]);\n+    }\n+    #[test] #[should_fail]\n+    fn test_weighted_choice_zero_weight() {\n+        WeightedChoice::new(~[Weighted { weight: 0, item: 0},\n+                              Weighted { weight: 0, item: 1}]);\n+    }\n+    #[test] #[should_fail]\n+    fn test_weighted_choice_weight_overflows() {\n+        let x = (-1) as uint / 2; // x + x + 2 is the overflow\n+        WeightedChoice::new(~[Weighted { weight: x, item: 0 },\n+                              Weighted { weight: 1, item: 1 },\n+                              Weighted { weight: x, item: 2 },\n+                              Weighted { weight: 1, item: 3 }]);\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "a372eb1f11ad5ab5d3ce14dd555dacf0f98fe6f5", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/0bba73c0d156df8f22c64ef4f4c50910fe31cf31/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bba73c0d156df8f22c64ef4f4c50910fe31cf31/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=0bba73c0d156df8f22c64ef4f4c50910fe31cf31", "patch": "@@ -100,14 +100,6 @@ pub trait Rand {\n     fn rand<R: Rng>(rng: &mut R) -> Self;\n }\n \n-/// A value with a particular weight compared to other values\n-pub struct Weighted<T> {\n-    /// The numerical weight of this item\n-    weight: uint,\n-    /// The actual item which is being weighted\n-    item: T,\n-}\n-\n /// A random number generator\n pub trait Rng {\n     /// Return the next random u32. This rarely needs to be called\n@@ -334,91 +326,6 @@ pub trait Rng {\n         }\n     }\n \n-    /// Choose an item respecting the relative weights, failing if the sum of\n-    /// the weights is 0\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::rand;\n-    /// use std::rand::Rng;\n-    ///\n-    /// fn main() {\n-    ///     let mut rng = rand::rng();\n-    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n-    ///              rand::Weighted {weight: 2, item: 'b'},\n-    ///              rand::Weighted {weight: 2, item: 'c'}];\n-    ///     println!(\"{}\", rng.choose_weighted(x));\n-    /// }\n-    /// ```\n-    fn choose_weighted<T:Clone>(&mut self, v: &[Weighted<T>]) -> T {\n-        self.choose_weighted_option(v).expect(\"Rng.choose_weighted: total weight is 0\")\n-    }\n-\n-    /// Choose Some(item) respecting the relative weights, returning none if\n-    /// the sum of the weights is 0\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::rand;\n-    /// use std::rand::Rng;\n-    ///\n-    /// fn main() {\n-    ///     let mut rng = rand::rng();\n-    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n-    ///              rand::Weighted {weight: 2, item: 'b'},\n-    ///              rand::Weighted {weight: 2, item: 'c'}];\n-    ///     println!(\"{:?}\", rng.choose_weighted_option(x));\n-    /// }\n-    /// ```\n-    fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n-                                       -> Option<T> {\n-        let mut total = 0u;\n-        for item in v.iter() {\n-            total += item.weight;\n-        }\n-        if total == 0u {\n-            return None;\n-        }\n-        let chosen = self.gen_range(0u, total);\n-        let mut so_far = 0u;\n-        for item in v.iter() {\n-            so_far += item.weight;\n-            if so_far > chosen {\n-                return Some(item.item.clone());\n-            }\n-        }\n-        unreachable!();\n-    }\n-\n-    /// Return a vec containing copies of the items, in order, where\n-    /// the weight of the item determines how many copies there are\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::rand;\n-    /// use std::rand::Rng;\n-    ///\n-    /// fn main() {\n-    ///     let mut rng = rand::rng();\n-    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n-    ///              rand::Weighted {weight: 2, item: 'b'},\n-    ///              rand::Weighted {weight: 2, item: 'c'}];\n-    ///     println!(\"{}\", rng.weighted_vec(x));\n-    /// }\n-    /// ```\n-    fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n-        let mut r = ~[];\n-        for item in v.iter() {\n-            for _ in range(0u, item.weight) {\n-                r.push(item.item.clone());\n-            }\n-        }\n-        r\n-    }\n-\n     /// Shuffle a vec\n     ///\n     /// # Example\n@@ -860,44 +767,6 @@ mod test {\n         assert_eq!(r.choose_option(v), Some(&i));\n     }\n \n-    #[test]\n-    fn test_choose_weighted() {\n-        let mut r = rng();\n-        assert!(r.choose_weighted([\n-            Weighted { weight: 1u, item: 42 },\n-        ]) == 42);\n-        assert!(r.choose_weighted([\n-            Weighted { weight: 0u, item: 42 },\n-            Weighted { weight: 1u, item: 43 },\n-        ]) == 43);\n-    }\n-\n-    #[test]\n-    fn test_choose_weighted_option() {\n-        let mut r = rng();\n-        assert!(r.choose_weighted_option([\n-            Weighted { weight: 1u, item: 42 },\n-        ]) == Some(42));\n-        assert!(r.choose_weighted_option([\n-            Weighted { weight: 0u, item: 42 },\n-            Weighted { weight: 1u, item: 43 },\n-        ]) == Some(43));\n-        let v: Option<int> = r.choose_weighted_option([]);\n-        assert!(v.is_none());\n-    }\n-\n-    #[test]\n-    fn test_weighted_vec() {\n-        let mut r = rng();\n-        let empty: ~[int] = ~[];\n-        assert_eq!(r.weighted_vec([]), empty);\n-        assert!(r.weighted_vec([\n-            Weighted { weight: 0u, item: 3u },\n-            Weighted { weight: 1u, item: 2u },\n-            Weighted { weight: 2u, item: 1u },\n-        ]) == ~[2u, 1u, 1u]);\n-    }\n-\n     #[test]\n     fn test_shuffle() {\n         let mut r = rng();"}]}