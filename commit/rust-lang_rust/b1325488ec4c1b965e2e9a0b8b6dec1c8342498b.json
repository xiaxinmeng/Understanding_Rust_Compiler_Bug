{"sha": "b1325488ec4c1b965e2e9a0b8b6dec1c8342498b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMzI1NDg4ZWM0YzFiOTY1ZTJlOWEwYjhiNmRlYzFjODM0MjQ5OGI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-30T21:51:37Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-01-11T22:33:04Z"}, "message": "Use query for importable locations", "tree": {"sha": "9828eaf61113558eecc05bd0823e2f02752a5d23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9828eaf61113558eecc05bd0823e2f02752a5d23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b", "html_url": "https://github.com/rust-lang/rust/commit/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "947eec7b87c4e385176e53acf4577df5fbb566cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/947eec7b87c4e385176e53acf4577df5fbb566cd", "html_url": "https://github.com/rust-lang/rust/commit/947eec7b87c4e385176e53acf4577df5fbb566cd"}], "stats": {"total": 111, "additions": 77, "deletions": 34}, "files": [{"sha": "0c00627b597b9c5640a27dc67a834cf0a9c3854a", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=b1325488ec4c1b965e2e9a0b8b6dec1c8342498b", "patch": "@@ -107,6 +107,13 @@ pub trait DefDatabase: InternDatabase + AstDatabase {\n     // Remove this query completely, in favor of `Attrs::docs` method\n     #[salsa::invoke(Documentation::documentation_query)]\n     fn documentation(&self, def: AttrDefId) -> Option<Documentation>;\n+\n+    #[salsa::invoke(crate::find_path::importable_locations_in_crate_query)]\n+    fn importable_locations_in_crate(\n+        &self,\n+        item: crate::item_scope::ItemInNs,\n+        krate: CrateId,\n+    ) -> Arc<[(ModuleId, hir_expand::name::Name, crate::visibility::Visibility)]>;\n }\n \n fn crate_def_map(db: &impl DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {"}, {"sha": "09f3bf87d0ff5ccb8dbb676596f61963c802c5b8", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 65, "deletions": 29, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=b1325488ec4c1b965e2e9a0b8b6dec1c8342498b", "patch": "@@ -4,12 +4,11 @@ use crate::{\n     db::DefDatabase,\n     item_scope::ItemInNs,\n     path::{ModPath, PathKind},\n-    ModuleId, ModuleDefId,\n+    visibility::Visibility,\n+    CrateId, ModuleDefId, ModuleId,\n };\n use hir_expand::name::Name;\n \n-// TODO performance / memoize\n-\n pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n     // Base cases:\n \n@@ -21,13 +20,23 @@ pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Optio\n     }\n \n     // - if the item is the crate root, return `crate`\n-    if item == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId { krate: from.krate, local_id: def_map.root })) {\n+    if item\n+        == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n+            krate: from.krate,\n+            local_id: def_map.root,\n+        }))\n+    {\n         return Some(ModPath::from_simple_segments(PathKind::Crate, Vec::new()));\n     }\n \n     // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n     if let Some(parent_id) = def_map.modules[from.local_id].parent {\n-        if item == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId { krate: from.krate, local_id: parent_id })) {\n+        if item\n+            == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n+                krate: from.krate,\n+                local_id: parent_id,\n+            }))\n+        {\n             return Some(ModPath::from_simple_segments(PathKind::Super(1), Vec::new()));\n         }\n     }\n@@ -42,7 +51,8 @@ pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Optio\n     // - if the item is in the prelude, return the name from there\n     if let Some(prelude_module) = def_map.prelude {\n         let prelude_def_map = db.crate_def_map(prelude_module.krate);\n-        let prelude_scope: &crate::item_scope::ItemScope = &prelude_def_map.modules[prelude_module.local_id].scope;\n+        let prelude_scope: &crate::item_scope::ItemScope =\n+            &prelude_def_map.modules[prelude_module.local_id].scope;\n         if let Some((name, vis)) = prelude_scope.reverse_get(item) {\n             if vis.is_visible_from(db, from) {\n                 return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n@@ -68,7 +78,8 @@ pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Optio\n     let mut candidate_paths = Vec::new();\n     for (module_id, name) in importable_locations {\n         // TODO prevent infinite loops\n-        let mut path = match find_path(db, ItemInNs::Types(ModuleDefId::ModuleId(module_id)), from) {\n+        let mut path = match find_path(db, ItemInNs::Types(ModuleDefId::ModuleId(module_id)), from)\n+        {\n             None => continue,\n             Some(path) => path,\n         };\n@@ -78,33 +89,58 @@ pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Optio\n     candidate_paths.into_iter().min_by_key(|path| path.segments.len())\n }\n \n-fn find_importable_locations(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Vec<(ModuleId, Name)> {\n+fn find_importable_locations(\n+    db: &impl DefDatabase,\n+    item: ItemInNs,\n+    from: ModuleId,\n+) -> Vec<(ModuleId, Name)> {\n     let crate_graph = db.crate_graph();\n     let mut result = Vec::new();\n-    for krate in Some(from.krate).into_iter().chain(crate_graph.dependencies(from.krate).map(|dep| dep.crate_id)) {\n-        let def_map = db.crate_def_map(krate);\n-        for (local_id, data) in def_map.modules.iter() {\n-            if let Some((name, vis)) = data.scope.reverse_get(item) {\n-                let is_private = if let crate::visibility::Visibility::Module(private_to) = vis {\n-                    private_to.local_id == local_id\n-                } else { false };\n-                let is_original_def = if let Some(module_def_id) = item.as_module_def_id() {\n-                    data.scope.declarations().any(|it| it == module_def_id)\n-                } else { false };\n-                if is_private && !is_original_def {\n-                    // Ignore private imports. these could be used if we are\n-                    // in a submodule of this module, but that's usually not\n-                    // what the user wants; and if this module can import\n-                    // the item and we're a submodule of it, so can we.\n-                    continue;\n-                }\n-                if vis.is_visible_from(db, from) {\n-                    result.push((ModuleId { krate, local_id }, name.clone()));\n-                }\n+    for krate in Some(from.krate)\n+        .into_iter()\n+        .chain(crate_graph.dependencies(from.krate).map(|dep| dep.crate_id))\n+    {\n+        result.extend(\n+            db.importable_locations_in_crate(item, krate)\n+                .iter()\n+                .filter(|(_, _, vis)| vis.is_visible_from(db, from))\n+                .map(|(m, n, _)| (*m, n.clone())),\n+        );\n+    }\n+    result\n+}\n+\n+pub(crate) fn importable_locations_in_crate_query(\n+    db: &impl DefDatabase,\n+    item: ItemInNs,\n+    krate: CrateId,\n+) -> std::sync::Arc<[(ModuleId, Name, Visibility)]> {\n+    let def_map = db.crate_def_map(krate);\n+    let mut result = Vec::new();\n+    for (local_id, data) in def_map.modules.iter() {\n+        if let Some((name, vis)) = data.scope.reverse_get(item) {\n+            let is_private = if let Visibility::Module(private_to) = vis {\n+                private_to.local_id == local_id\n+            } else {\n+                false\n+            };\n+            let is_original_def = if let Some(module_def_id) = item.as_module_def_id() {\n+                data.scope.declarations().any(|it| it == module_def_id)\n+            } else {\n+                false\n+            };\n+            if is_private && !is_original_def {\n+                // Ignore private imports. these could be used if we are\n+                // in a submodule of this module, but that's usually not\n+                // what the user wants; and if this module can import\n+                // the item and we're a submodule of it, so can we.\n+                // Also this keeps the cached data smaller.\n+                continue;\n             }\n+            result.push((ModuleId { krate, local_id }, name.clone(), vis));\n         }\n     }\n-    result\n+    result.into()\n }\n \n #[cfg(test)]"}, {"sha": "87c50b34f8ea3814175114497c091fc4cbb4fd7d", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=b1325488ec4c1b965e2e9a0b8b6dec1c8342498b", "patch": "@@ -183,7 +183,7 @@ impl PerNs {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n pub enum ItemInNs {\n     Types(ModuleDefId),\n     Values(ModuleDefId),\n@@ -195,13 +195,13 @@ impl ItemInNs {\n         match self {\n             ItemInNs::Types(def) => {\n                 per_ns.types.filter(|(other_def, _)| *other_def == def).map(|(_, vis)| vis)\n-            },\n+            }\n             ItemInNs::Values(def) => {\n                 per_ns.values.filter(|(other_def, _)| *other_def == def).map(|(_, vis)| vis)\n-            },\n+            }\n             ItemInNs::Macros(def) => {\n                 per_ns.macros.filter(|(other_def, _)| *other_def == def).map(|(_, vis)| vis)\n-            },\n+            }\n         }\n     }\n "}, {"sha": "1568820e9afac8ef54937c80d59d65da8a672f8f", "filename": "crates/ra_hir_def/src/test_db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1325488ec4c1b965e2e9a0b8b6dec1c8342498b/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs?ref=b1325488ec4c1b965e2e9a0b8b6dec1c8342498b", "patch": "@@ -5,8 +5,8 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n-use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath};\n use crate::db::DefDatabase;\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath};\n \n #[salsa::database(\n     ra_db::SourceDatabaseExtStorage,"}]}