{"sha": "4907dac54cc43d44bd6df87636e545756d110957", "node_id": "C_kwDOAAsO6NoAKDQ5MDdkYWM1NGNjNDNkNDRiZDZkZjg3NjM2ZTU0NTc1NmQxMTA5NTc", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-03-05T15:15:16Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-04-27T20:29:03Z"}, "message": "don't promote large fields to higher alignments if that would affect niche placement", "tree": {"sha": "d6b8fcb18473ec627073db3466f181876eb3877e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6b8fcb18473ec627073db3466f181876eb3877e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4907dac54cc43d44bd6df87636e545756d110957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4907dac54cc43d44bd6df87636e545756d110957", "html_url": "https://github.com/rust-lang/rust/commit/4907dac54cc43d44bd6df87636e545756d110957", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4907dac54cc43d44bd6df87636e545756d110957/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faf2da3e2f04f525784fd4d41375e96a8356f4e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf2da3e2f04f525784fd4d41375e96a8356f4e3", "html_url": "https://github.com/rust-lang/rust/commit/faf2da3e2f04f525784fd4d41375e96a8356f4e3"}], "stats": {"total": 55, "additions": 42, "deletions": 13}, "files": [{"sha": "0b0fea4c5008f780fb19fd631549e7bfa20d423c", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4907dac54cc43d44bd6df87636e545756d110957/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4907dac54cc43d44bd6df87636e545756d110957/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=4907dac54cc43d44bd6df87636e545756d110957", "patch": "@@ -772,19 +772,6 @@ fn univariant(\n     if optimize {\n         let end = if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n         let optimizing = &mut inverse_memory_index.raw[..end];\n-        let effective_field_align = |layout: Layout<'_>| {\n-            if let Some(pack) = pack {\n-                // return the packed alignment in bytes\n-                layout.align().abi.min(pack).bytes()\n-            } else {\n-                // returns log2(effective-align).\n-                // This is ok since `pack` applies to all fields equally.\n-                // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n-                //\n-                // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n-                layout.align().abi.bytes().max(layout.size().bytes()).trailing_zeros() as u64\n-            }\n-        };\n \n         // If `-Z randomize-layout` was enabled for the type definition we can shuffle\n         // the field ordering to try and catch some code making assumptions about layouts\n@@ -801,6 +788,30 @@ fn univariant(\n             }\n             // Otherwise we just leave things alone and actually optimize the type's fields\n         } else {\n+            let max_field_align = fields.iter().map(|f| f.align().abi.bytes()).max().unwrap_or(1);\n+            let any_niche = fields.iter().any(|f| f.largest_niche().is_some());\n+            let effective_field_align = |layout: Layout<'_>| {\n+                if let Some(pack) = pack {\n+                    // return the packed alignment in bytes\n+                    layout.align().abi.min(pack).bytes()\n+                } else {\n+                    // returns log2(effective-align).\n+                    // This is ok since `pack` applies to all fields equally.\n+                    // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n+                    //\n+                    // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n+                    let align = layout.align().abi.bytes();\n+                    let size = layout.size().bytes();\n+                    let size_as_align = align.max(size).trailing_zeros();\n+                    let size_as_align = if any_niche {\n+                        max_field_align.trailing_zeros().min(size_as_align)\n+                    } else {\n+                        size_as_align\n+                    };\n+                    size_as_align as u64\n+                }\n+            };\n+\n             match kind {\n                 StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n                     optimizing.sort_by_key(|&x| {"}, {"sha": "e5c6857a26a8352689ec118f32872c1ad0bc6f3b", "filename": "tests/ui/structs-enums/type-sizes.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4907dac54cc43d44bd6df87636e545756d110957/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4907dac54cc43d44bd6df87636e545756d110957/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs-enums%2Ftype-sizes.rs?ref=4907dac54cc43d44bd6df87636e545756d110957", "patch": "@@ -186,6 +186,18 @@ struct Reorder2 {\n     ary: [u8; 6],\n }\n \n+// We want the niche in the front, which means we can't treat the array as quasi-aligned more than\n+// 4 bytes even though we also want to place it at an 8-aligned offset where possible.\n+// So the ideal layout would look like: (char, u32, [u8; 8], u8)\n+// The current layout algorithm does (char, [u8; 8], u32, u8)\n+#[repr(align(8))]\n+struct ReorderWithNiche {\n+    a: u32,\n+    b: char,\n+    c: u8,\n+    ary: [u8; 8]\n+}\n+\n // standins for std types which we want to be laid out in a reasonable way\n struct RawVecDummy {\n     ptr: NonNull<u8>,\n@@ -298,4 +310,10 @@ pub fn main() {\n     assert!(ptr::from_ref(&b.1).addr() > ptr::from_ref(&b.2).addr());\n \n     assert_eq!(size_of::<Cow<'static, str>>(), size_of::<String>());\n+\n+    let v = ReorderWithNiche {a: 0, b: ' ', c: 0, ary: [0; 8]};\n+    assert!((&v.ary).as_ptr().is_aligned_to(4),\n+            \"here [u8; 8] should group with _at least_ align-4 fields\");\n+    assert_eq!(ptr::from_ref(&v), ptr::from_ref(&v.b).cast(),\n+               \"sort niches to the front where possible\");\n }"}]}