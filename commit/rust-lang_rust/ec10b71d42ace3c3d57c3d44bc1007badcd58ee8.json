{"sha": "ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMTBiNzFkNDJhY2UzYzNkNTdjM2Q0NGJjMTAwN2JhZGNkNThlZTg=", "commit": {"author": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-02-03T02:07:52Z"}, "committer": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-03-14T20:31:26Z"}, "message": "Introduce new fake reads", "tree": {"sha": "39e19afb63aba50b265e76fee4229a3c8c93f2ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39e19afb63aba50b265e76fee4229a3c8c93f2ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "html_url": "https://github.com/rust-lang/rust/commit/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/comments", "author": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9320b121b5b20d2201c9f5ec40fb3c241fcac6f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9320b121b5b20d2201c9f5ec40fb3c241fcac6f0", "html_url": "https://github.com/rust-lang/rust/commit/9320b121b5b20d2201c9f5ec40fb3c241fcac6f0"}], "stats": {"total": 216, "additions": 195, "deletions": 21}, "files": [{"sha": "2d1231d819d389784b73d41731b126e25fcdb8b7", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -430,6 +430,9 @@ pub struct TypeckResults<'tcx> {\n     /// see `MinCaptureInformationMap` for more details.\n     pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n \n+    /// [FIXME] RFC2229 Change to use HashSet instead of Vec\n+    pub closure_fake_reads: FxHashMap<DefId, Vec<HirPlace<'tcx>>>,\n+\n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n     pub generator_interior_types: ty::Binder<Vec<GeneratorInteriorTypeCause<'tcx>>>,\n@@ -464,6 +467,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             concrete_opaque_types: Default::default(),\n             closure_captures: Default::default(),\n             closure_min_captures: Default::default(),\n+            closure_fake_reads: Default::default(),\n             generator_interior_types: ty::Binder::dummy(Default::default()),\n             treat_byte_string_as_slice: Default::default(),\n         }\n@@ -715,6 +719,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             ref concrete_opaque_types,\n             ref closure_captures,\n             ref closure_min_captures,\n+            ref closure_fake_reads,\n             ref generator_interior_types,\n             ref treat_byte_string_as_slice,\n         } = *self;\n@@ -750,6 +755,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             concrete_opaque_types.hash_stable(hcx, hasher);\n             closure_captures.hash_stable(hcx, hasher);\n             closure_min_captures.hash_stable(hcx, hasher);\n+            closure_fake_reads.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);\n             treat_byte_string_as_slice.hash_stable(hcx, hasher);\n         })"}, {"sha": "109a6521128839f05c721bce6046e5272ffff649", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -17,7 +17,7 @@ use rustc_target::abi::VariantIdx;\n use rustc_index::vec::Idx;\n \n /// The \"outermost\" place that holds this value.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n crate enum PlaceBase {\n     /// Denotes the start of a `Place`.\n     Local(Local),\n@@ -67,7 +67,7 @@ crate enum PlaceBase {\n ///\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n crate struct PlaceBuilder<'tcx> {\n     base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n@@ -199,7 +199,7 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n     from_builder: PlaceBuilder<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n-) -> Result<PlaceBuilder<'tcx>, HirId> {\n+) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n     match from_builder.base {\n         PlaceBase::Local(_) => Ok(from_builder),\n         PlaceBase::Upvar { var_hir_id, closure_def_id, closure_kind } => {\n@@ -236,7 +236,7 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n                         var_hir_id, from_builder.projection,\n                     );\n                 }\n-                return Err(var_hir_id);\n+                return Err(upvar_resolved_place_builder);\n             };\n \n             let closure_ty = typeck_results\n@@ -288,7 +288,7 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         if let PlaceBase::Local(local) = self.base {\n             Place { local, projection: tcx.intern_place_elems(&self.projection) }\n         } else {\n-            self.expect_upvars_resolved(tcx, typeck_results).into_place(tcx, typeck_results)\n+            self.try_upvars_resolved(tcx, typeck_results).into_place(tcx, typeck_results)\n         }\n     }\n \n@@ -300,6 +300,17 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n     }\n \n+    fn try_upvars_resolved<'a>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        typeck_results: &'a ty::TypeckResults<'tcx>,\n+    ) -> PlaceBuilder<'tcx> {\n+        match to_upvars_resolved_place_builder(self, tcx, typeck_results) {\n+            Ok(upvars_resolved) => upvars_resolved,\n+            Err(upvars_unresolved) => upvars_unresolved,\n+        }\n+    }\n+\n     crate fn base(&self) -> PlaceBase {\n         self.base\n     }"}, {"sha": "3a8665777b79ee47f408ee0e360dffd80e046b1a", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -8,6 +8,7 @@ use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind;\n+use rustc_middle::mir::Place;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, UpvarSubsts};\n use rustc_span::Span;\n@@ -164,7 +165,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n             }\n-            ExprKind::Closure { closure_id, substs, upvars, movability } => {\n+            ExprKind::Closure { closure_id, substs, upvars, movability, fake_reads } => {\n                 // see (*) above\n                 let operands: Vec<_> = upvars\n                     .into_iter()\n@@ -203,6 +204,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     })\n                     .collect();\n+\n+                if let Some(fake_reads) = fake_reads {\n+                    for thir_place in fake_reads.into_iter() {\n+                        //  = this.hir.mirror(thir_place);\n+                        let mir_place = unpack!(block = this.as_place(block, thir_place));\n+                        // [FIXME] RFC2229 FakeReadCause can be ForLet or ForMatch, need to use the correct one\n+                        this.cfg.push_fake_read(\n+                            block,\n+                            source_info,\n+                            FakeReadCause::ForMatchedPlace,\n+                            mir_place,\n+                        );\n+                    }\n+                }\n+\n                 let result = match substs {\n                     UpvarSubsts::Generator(substs) => {\n                         // We implicitly set the discriminant to 0. See"}, {"sha": "b2e8b2de1bc6a64f0c30010173f77fe94a121789", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -420,7 +420,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => {\n                 debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n-\n                 let place = unpack!(block = this.as_place(block, expr));\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n@@ -437,7 +436,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n \n                 debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n-\n                 let place = unpack!(block = this.as_place(block, expr));\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);"}, {"sha": "25e08efb2e3534c852fcdcc9d3dd8e14309f274c", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -5,6 +5,7 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_index::vec::Idx;\n+use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::mir::interpret::Scalar;\n@@ -452,7 +453,39 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                         .zip(substs.upvar_tys())\n                         .map(|(captured_place, ty)| self.capture_upvar(expr, captured_place, ty)),\n                 );\n-                ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n+\n+                let fake_reads = match self.typeck_results().closure_fake_reads.get(&def_id) {\n+                    Some(vals) => Some(self.arena.alloc_from_iter(vals\n+                        .iter()\n+                        .filter(|val| match val.base {\n+                            HirPlaceBase::Upvar(_) => true,\n+                            _ => false,\n+                        })\n+                        .map(|val| {\n+                            let var_hir_id = match val.base {\n+                                HirPlaceBase::Upvar(upvar_id) => {\n+                                    debug!(\"upvar\");\n+                                    upvar_id.var_path.hir_id\n+                                }\n+                                _ => {\n+                                    bug!(\n+                                        \"Do not know how to get HirId out of Rvalue and StaticItem\"\n+                                    );\n+                                }\n+                            };\n+                            self.fake_read_capture_upvar(expr, val.clone(), var_hir_id)\n+                        })\n+                    )),\n+                    None => None,\n+                };\n+\n+                ExprKind::Closure {\n+                    closure_id: def_id,\n+                    substs,\n+                    upvars,\n+                    movability,\n+                    fake_reads: fake_reads,\n+                }\n             }\n \n             hir::ExprKind::Path(ref qpath) => {\n@@ -1012,6 +1045,49 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         ExprKind::Deref { arg: ref_expr }\n     }\n \n+    fn fake_read_capture_upvar(\n+        &mut self,\n+        closure_expr: &'tcx hir::Expr<'tcx>,\n+        place: HirPlace<'tcx>,\n+        hir_id: hir::HirId,\n+    ) -> Expr<'thir, 'tcx> {\n+        let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n+        let var_ty = place.base_ty;\n+\n+        let mut captured_place_expr = Expr {\n+            temp_lifetime,\n+            ty: var_ty,\n+            span: closure_expr.span,\n+            kind: self.convert_var(hir_id),\n+        };\n+        // [FIXME] RFC2229 Maybe we should introduce an immutable borrow of the fake capture so that we don't\n+        // end up moving this place\n+        for proj in place.projections.iter() {\n+            let kind = match proj.kind {\n+                HirProjectionKind::Deref => {\n+                    ExprKind::Deref { arg: self.arena.alloc(captured_place_expr) }\n+                }\n+                HirProjectionKind::Field(field, ..) => {\n+                    // Variant index will always be 0, because for multi-variant\n+                    // enums, we capture the enum entirely.\n+                    ExprKind::Field {\n+                        lhs: self.arena.alloc(captured_place_expr),\n+                        name: Field::new(field as usize),\n+                    }\n+                }\n+                HirProjectionKind::Index | HirProjectionKind::Subslice => {\n+                    // We don't capture these projections, so we can ignore them here\n+                    continue;\n+                }\n+            };\n+\n+            captured_place_expr =\n+                Expr { temp_lifetime, ty: proj.ty, span: closure_expr.span, kind };\n+        }\n+\n+        captured_place_expr\n+    }\n+\n     fn capture_upvar(\n         &mut self,\n         closure_expr: &'tcx hir::Expr<'tcx>,"}, {"sha": "730c0f4a3df2a102fe48a8e4d7090072e8f37a23", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -281,6 +281,7 @@ pub enum ExprKind<'thir, 'tcx> {\n         substs: UpvarSubsts<'tcx>,\n         upvars: &'thir [Expr<'thir, 'tcx>],\n         movability: Option<hir::Movability>,\n+        fake_reads: Option<&'thir mut [Expr<'thir, 'tcx>]>,\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,"}, {"sha": "74e2ca51039d3188f9b460445b2a28bfd9cfd5a4", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -34,6 +34,7 @@ use super::writeback::Resolver;\n use super::FnCtxt;\n \n use crate::expr_use_visitor as euv;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -145,6 +146,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n             current_origin: None,\n             capture_information: Default::default(),\n+            fake_reads: Default::default(),\n         };\n         euv::ExprUseVisitor::new(\n             &mut delegate,\n@@ -246,6 +248,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let final_tupled_upvars_type = self.tcx.mk_tup(final_upvar_tys.iter());\n         self.demand_suptype(span, substs.tupled_upvars_ty(), final_tupled_upvars_type);\n \n+        let fake_reads = delegate.fake_reads.into_iter().map(|fake_read| fake_read).collect();\n+        self.typeck_results.borrow_mut().closure_fake_reads.insert(closure_def_id, fake_reads);\n+\n         // If we are also inferred the closure kind here,\n         // process any deferred resolutions.\n         let deferred_call_resolutions = self.remove_deferred_call_resolutions(closure_def_id);\n@@ -1148,6 +1153,8 @@ struct InferBorrowKind<'a, 'tcx> {\n     /// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n     /// ```\n     capture_information: InferredCaptureInformation<'tcx>,\n+    // [FIXME] RFC2229 Change Vec to FxHashSet\n+    fake_reads: FxHashSet<Place<'tcx>>, // these need to be fake read.\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n@@ -1409,6 +1416,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n+    fn fake_read(&mut self, place: PlaceWithHirId<'tcx>) {\n+        if let PlaceBase::Upvar(_) = place.place.base {\n+            self.fake_reads.insert(place.place);\n+        }\n+    }\n+\n     fn consume(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,"}, {"sha": "9cccda7768cc33888a8cdf63feb1070b0dea605e", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -4,11 +4,14 @@\n \n use crate::check::FnCtxt;\n \n+use rustc_data_structures::stable_map::FxHashMap;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::InferCtxt;\n+use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -56,6 +59,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         wbcx.visit_body(body);\n         wbcx.visit_min_capture_map();\n+        wbcx.visit_fake_reads_map();\n         wbcx.visit_upvar_capture_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n@@ -363,6 +367,25 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         self.typeck_results.closure_min_captures = min_captures_wb;\n     }\n \n+    fn visit_fake_reads_map(&mut self) {\n+        let mut resolved_closure_fake_reads: FxHashMap<DefId, Vec<HirPlace<'tcx>>> =\n+            Default::default();\n+        for (closure_def_id, fake_reads) in\n+            self.fcx.typeck_results.borrow().closure_fake_reads.iter()\n+        {\n+            let mut resolved_fake_reads = Vec::<HirPlace<'tcx>>::new();\n+            for fake_read in fake_reads.iter() {\n+                let locatable =\n+                    self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n+\n+                let resolved_fake_read = self.resolve(fake_read.clone(), &locatable);\n+                resolved_fake_reads.push(resolved_fake_read);\n+            }\n+            resolved_closure_fake_reads.insert(*closure_def_id, resolved_fake_reads);\n+        }\n+        self.typeck_results.closure_fake_reads = resolved_closure_fake_reads;\n+    }\n+\n     fn visit_upvar_capture_map(&mut self) {\n         for (upvar_id, upvar_capture) in self.fcx.typeck_results.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {"}, {"sha": "45ecf30cd50e3d0b6f43529f0488904ff875a5db", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -10,6 +10,7 @@ pub use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId, Projection};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n+// use rustc_hir::Pat;\n use rustc_hir::PatKind;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n@@ -51,6 +52,9 @@ pub trait Delegate<'tcx> {\n     // The path at `assignee_place` is being assigned to.\n     // `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n+\n+    // [FIXME] RFC2229 This should also affect clippy ref: https://github.com/sexxi-goose/rust/pull/27\n+    fn fake_read(&mut self, place: PlaceWithHirId<'tcx>);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -229,7 +233,24 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n             hir::ExprKind::Match(ref discr, arms, _) => {\n                 let discr_place = return_if_err!(self.mc.cat_expr(&discr));\n-                self.borrow_expr(&discr, ty::ImmBorrow);\n+\n+                // We only want to borrow discr if the pattern contain something other\n+                // than wildcards\n+                let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n+                let mut res = false;\n+                for arm in arms.iter() {\n+                    return_if_err!(mc.cat_pattern(discr_place.clone(), &arm.pat, |_place, pat| {\n+                        if let PatKind::Binding(_, _, _, opt_sub_pat) = pat.kind {\n+                            if let None = opt_sub_pat {\n+                                res = true;\n+                            }\n+                        }\n+                    }));\n+                }\n+\n+                if res {\n+                    self.borrow_expr(&discr, ty::ImmBorrow);\n+                }\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n@@ -537,6 +558,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     fn walk_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n         debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n \n+        self.delegate.fake_read(discr_place.clone());\n+\n         let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, body_owner: _, ref mut delegate } = *self;\n         return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n@@ -599,6 +622,10 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n+        // Over here we walk a closure that is nested inside the current body\n+        // If the current body is a closure, then we also want to report back any fake reads,\n+        // starting off of variables that are captured by our parent as well.\n+\n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n         let upvars = self.tcx().upvars_mentioned(self.body_owner);\n \n@@ -611,6 +638,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         if let Some(min_captures) = self.mc.typeck_results.closure_min_captures.get(&closure_def_id)\n         {\n             for (var_hir_id, min_list) in min_captures.iter() {\n+                // Use this as a reference for if we should promote the fake read\n                 if upvars.map_or(body_owner_is_closure, |upvars| !upvars.contains_key(var_hir_id)) {\n                     // The nested closure might be capturing the current (enclosing) closure's local variables.\n                     // We check if the root variable is ever mentioned within the enclosing closure, if not\n@@ -636,6 +664,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         place.projections.clone(),\n                     );\n \n+                    // [FIXME] RFC2229 We want to created another loop that iterates mc.typeck_results.fake_reads()\n+                    // [FIXME] RFC2229 Add tests for nested closures\n+                    if body_owner_is_closure {\n+                        self.delegate.fake_read(place_with_id.clone());\n+                    }\n+\n                     match capture_info.capture_kind {\n                         ty::UpvarCapture::ByValue(_) => {\n                             let mode = copy_or_move(&self.mc, &place_with_id);"}, {"sha": "2ed0149b9db7d47fa441b71db68dc80e885febc2", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -13,12 +13,8 @@ fn main() {\n     let mut point = SingleVariant::Point(10, -10);\n \n     let c = || {\n-        // FIXME(project-rfc-2229#24): Change this to be a destructure pattern\n-        // once this is fixed, to remove the warning.\n-        if let SingleVariant::Point(ref mut x, _) = point {\n-            //~^ WARNING: irrefutable `if let` pattern\n-            *x += 1;\n-        }\n+        let SingleVariant::Point(ref mut x, _) = point;\n+        *x += 1;\n     };\n \n     let b = c;"}, {"sha": "4863e6e2976d9656789af86f51ef1b2402c96d06", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr?ref=ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "patch": "@@ -21,19 +21,19 @@ LL | |         }\n    = help: consider replacing the `if let` with a `let`\n \n error[E0382]: use of moved value: `c`\n-  --> $DIR/closure-origin-single-variant-diagnostics.rs:25:13\n+  --> $DIR/closure-origin-single-variant-diagnostics.rs:21:13\n    |\n LL |     let b = c;\n    |             - value moved here\n LL |     let a = c;\n    |             ^ value used here after move\n    |\n note: closure cannot be moved more than once as it is not `Copy` due to moving the variable `point.0` out of its environment\n-  --> $DIR/closure-origin-single-variant-diagnostics.rs:18:53\n+  --> $DIR/closure-origin-single-variant-diagnostics.rs:16:50\n    |\n-LL |         if let SingleVariant::Point(ref mut x, _) = point {\n-   |                                                     ^^^^^\n+LL |         let SingleVariant::Point(ref mut x, _) = point;\n+   |                                                  ^^^^^\n \n-error: aborting due to previous error; 2 warnings emitted\n+error: aborting due to previous error; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0382`."}]}