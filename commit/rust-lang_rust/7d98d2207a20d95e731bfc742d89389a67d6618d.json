{"sha": "7d98d2207a20d95e731bfc742d89389a67d6618d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkOThkMjIwN2EyMGQ5NWU3MzFiZmM3NDJkODkzODlhNjdkNjYxOGQ=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-09-27T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-09-27T20:55:43Z"}, "message": "Reopen standard streams when they are closed on Unix\n\nThe syscalls returning a new file descriptors generally use\nlowest-numbered file descriptor not currently opened, without any\nexceptions for those corresponding to the standard streams.\n\nPreviously when any of standard streams has been closed before starting\nthe application, operations on std::io::{stderr,stdin,stdout} objects\nwere likely to operate on other logically unrelated file resources\nopened afterwards.\n\nAvoid the issue by reopening the standard streams when they are closed.", "tree": {"sha": "bbb180c48bcdb048cd38e9ae2ae2a4b6e736da29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbb180c48bcdb048cd38e9ae2ae2a4b6e736da29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d98d2207a20d95e731bfc742d89389a67d6618d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d98d2207a20d95e731bfc742d89389a67d6618d", "html_url": "https://github.com/rust-lang/rust/commit/7d98d2207a20d95e731bfc742d89389a67d6618d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d98d2207a20d95e731bfc742d89389a67d6618d/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4529af972e55f8f85afaada0ee2dd18ab8653637", "url": "https://api.github.com/repos/rust-lang/rust/commits/4529af972e55f8f85afaada0ee2dd18ab8653637", "html_url": "https://github.com/rust-lang/rust/commit/4529af972e55f8f85afaada0ee2dd18ab8653637"}], "stats": {"total": 84, "additions": 82, "deletions": 2}, "files": [{"sha": "b48d2162eca92df57414542aac8aff859a312009", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7d98d2207a20d95e731bfc742d89389a67d6618d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d98d2207a20d95e731bfc742d89389a67d6618d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=7d98d2207a20d95e731bfc742d89389a67d6618d", "patch": "@@ -75,6 +75,13 @@ pub use crate::sys_common::os_str_bytes as os_str;\n \n #[cfg(not(test))]\n pub fn init() {\n+    // The standard streams might be closed on application startup. To prevent\n+    // std::io::{stdin, stdout,stderr} objects from using other unrelated file\n+    // resources opened later, we reopen standards streams when they are closed.\n+    unsafe {\n+        sanitize_standard_fds();\n+    }\n+\n     // By default, some platforms will send a *signal* when an EPIPE error\n     // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n     // handler, causing it to kill the program, which isn't exactly what we\n@@ -86,6 +93,61 @@ pub fn init() {\n         reset_sigpipe();\n     }\n \n+    // In the case when all file descriptors are open, the poll has been\n+    // observed to perform better than fcntl (on GNU/Linux).\n+    #[cfg(not(any(\n+        miri,\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        // The poll on Darwin doesn't set POLLNVAL for closed fds.\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"redox\",\n+    )))]\n+    unsafe fn sanitize_standard_fds() {\n+        use crate::sys::os::errno;\n+        let pfds: &mut [_] = &mut [\n+            libc::pollfd { fd: 0, events: 0, revents: 0 },\n+            libc::pollfd { fd: 1, events: 0, revents: 0 },\n+            libc::pollfd { fd: 2, events: 0, revents: 0 },\n+        ];\n+        while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n+            if errno() == libc::EINTR {\n+                continue;\n+            }\n+            libc::abort();\n+        }\n+        for pfd in pfds {\n+            if pfd.revents & libc::POLLNVAL == 0 {\n+                continue;\n+            }\n+            if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+                // If the stream is closed but we failed to reopen it, abort the\n+                // process. Otherwise we wouldn't preserve the safety of\n+                // operations on the corresponding Rust object Stdin, Stdout, or\n+                // Stderr.\n+                libc::abort();\n+            }\n+        }\n+    }\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"redox\"))]\n+    unsafe fn sanitize_standard_fds() {\n+        use crate::sys::os::errno;\n+        for fd in 0..3 {\n+            if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n+                if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+                    libc::abort();\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(any(\n+        // The standard fds are always available in Miri.\n+        miri,\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\"))]\n+    unsafe fn sanitize_standard_fds() {}\n+\n     #[cfg(not(any(target_os = \"emscripten\", target_os = \"fuchsia\")))]\n     unsafe fn reset_sigpipe() {\n         assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);"}, {"sha": "1b0ad930da6d7f571b51bf8a224659d9c325f173", "filename": "src/test/ui/no-stdio.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d98d2207a20d95e731bfc742d89389a67d6618d/src%2Ftest%2Fui%2Fno-stdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d98d2207a20d95e731bfc742d89389a67d6618d/src%2Ftest%2Fui%2Fno-stdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-stdio.rs?ref=7d98d2207a20d95e731bfc742d89389a67d6618d", "patch": "@@ -36,6 +36,16 @@ unsafe fn without_stdio<R, F: FnOnce() -> R>(f: F) -> R {\n     return r\n }\n \n+#[cfg(unix)]\n+fn assert_fd_is_valid(fd: libc::c_int) {\n+    if unsafe { libc::fcntl(fd, libc::F_GETFD) == -1 } {\n+        panic!(\"file descriptor {} is not valid: {}\", fd, io::Error::last_os_error());\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn assert_fd_is_valid(_fd: libc::c_int) {}\n+\n #[cfg(windows)]\n unsafe fn without_stdio<R, F: FnOnce() -> R>(f: F) -> R {\n     type DWORD = u32;\n@@ -77,10 +87,18 @@ unsafe fn without_stdio<R, F: FnOnce() -> R>(f: F) -> R {\n \n fn main() {\n     if env::args().len() > 1 {\n+        // Writing to stdout & stderr should not panic.\n         println!(\"test\");\n         assert!(io::stdout().write(b\"test\\n\").is_ok());\n         assert!(io::stderr().write(b\"test\\n\").is_ok());\n+\n+        // Stdin should be at EOF.\n         assert_eq!(io::stdin().read(&mut [0; 10]).unwrap(), 0);\n+\n+        // Standard file descriptors should be valid on UNIX:\n+        assert_fd_is_valid(0);\n+        assert_fd_is_valid(1);\n+        assert_fd_is_valid(2);\n         return\n     }\n \n@@ -109,12 +127,12 @@ fn main() {\n                         .stdout(Stdio::null())\n                         .stderr(Stdio::null())\n                         .status().unwrap();\n-    assert!(status.success(), \"{:?} isn't a success\", status);\n+    assert!(status.success(), \"{} isn't a success\", status);\n \n     // Finally, close everything then spawn a child to make sure everything is\n     // *still* ok.\n     let status = unsafe {\n         without_stdio(|| Command::new(&me).arg(\"next\").status())\n     }.unwrap();\n-    assert!(status.success(), \"{:?} isn't a success\", status);\n+    assert!(status.success(), \"{} isn't a success\", status);\n }"}]}