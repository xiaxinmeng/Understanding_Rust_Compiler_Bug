{"sha": "08a1d45818d022095d597919aa0d50ee7be2a0c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YTFkNDU4MThkMDIyMDk1ZDU5NzkxOWFhMGQ1MGVlN2JlMmEwYzY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-06-03T14:51:32Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-07-06T20:50:02Z"}, "message": "Check adjustments and node substs\n\nCleanup checking of inherent static methods and fix checking of inherent associated constants\nAdd more tests", "tree": {"sha": "2e28223d18da10b973c4b4e8ebe78ad8fefef104", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e28223d18da10b973c4b4e8ebe78ad8fefef104"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08a1d45818d022095d597919aa0d50ee7be2a0c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08a1d45818d022095d597919aa0d50ee7be2a0c6", "html_url": "https://github.com/rust-lang/rust/commit/08a1d45818d022095d597919aa0d50ee7be2a0c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08a1d45818d022095d597919aa0d50ee7be2a0c6/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85fb9e0d9103326b353da46b7171d90841f4e940", "url": "https://api.github.com/repos/rust-lang/rust/commits/85fb9e0d9103326b353da46b7171d90841f4e940", "html_url": "https://github.com/rust-lang/rust/commit/85fb9e0d9103326b353da46b7171d90841f4e940"}], "stats": {"total": 149, "additions": 113, "deletions": 36}, "files": [{"sha": "54f693a5a8156fa8a9041186a1509d6263ca6681", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/08a1d45818d022095d597919aa0d50ee7be2a0c6/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a1d45818d022095d597919aa0d50ee7be2a0c6/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=08a1d45818d022095d597919aa0d50ee7be2a0c6", "patch": "@@ -591,12 +591,23 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn check_expr_pat_type(&mut self, id: ast::NodeId, span: Span) -> bool {\n+        self.span = span;\n         if let Some(ty) = self.tables.node_id_to_type_opt(id) {\n-            self.span = span;\n-            ty.visit_with(self)\n-        } else {\n-            false\n+            if ty.visit_with(self) {\n+                return true;\n+            }\n+        }\n+        if self.tables.node_substs(id).visit_with(self) {\n+            return true;\n         }\n+        if let Some(adjustments) = self.tables.adjustments.get(&id) {\n+            for adjustment in adjustments {\n+                if adjustment.target.visit_with(self) {\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n     }\n \n     fn check_item(&mut self, item_id: ast::NodeId) -> &mut Self {\n@@ -660,11 +671,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             }\n             hir::ExprMethodCall(name, ..) => {\n                 // Method calls have to be checked specially.\n-                if let Some(method) = self.tables.method_map.get(&ty::MethodCall::expr(expr.id)) {\n-                    self.span = name.span;\n-                    if method.ty.visit_with(self) || method.substs.visit_with(self) {\n-                        return;\n-                    }\n+                let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                self.span = name.span;\n+                if self.tcx.type_of(def_id).visit_with(self) {\n+                    return;\n                 }\n             }\n             _ => {}\n@@ -673,6 +683,24 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n+    fn visit_qpath(&mut self, qpath: &'tcx hir::QPath, id: ast::NodeId, span: Span) {\n+        // Inherent associated constants don't have self type in substs,\n+        // we have to check it additionally.\n+        if let hir::QPath::TypeRelative(..) = *qpath {\n+            if let Some(def) = self.tables.type_dependent_defs.get(&id).cloned() {\n+                if let Some(assoc_item) = self.tcx.opt_associated_item(def.def_id()) {\n+                    if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n+                        if self.tcx.type_of(impl_def_id).visit_with(self) {\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        intravisit::walk_qpath(self, qpath, id, span);\n+    }\n+\n     // Check types of patterns\n     fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n         if self.check_expr_pat_type(pattern.id, pattern.span) {\n@@ -769,25 +797,11 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                     self.tcx.sess.span_err(self.span, &msg);\n                     return true;\n                 }\n-                if let ty::TyFnDef(..) = ty.sty {\n-                    // Inherent static methods don't have self type in substs,\n-                    // we have to check it additionally.\n-                    let mut impl_def_id = None;\n-                    if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        if let hir::map::NodeImplItem(..) = self.tcx.hir.get(node_id) {\n-                            impl_def_id = Some(self.tcx.hir.get_parent_did(node_id));\n-                        }\n-                    } else if let Some(Def::Method(..)) = self.tcx.describe_def(def_id) {\n-                        let candidate_impl_def_id = self.tcx.parent_def_id(def_id)\n-                                                            .expect(\"no parent for method def_id\");\n-                        // `is_none` means it's an impl, not a trait\n-                        if self.tcx.describe_def(candidate_impl_def_id).is_none() {\n-                            impl_def_id = Some(candidate_impl_def_id)\n-                        }\n-                    }\n-                    if let Some(impl_def_id) = impl_def_id {\n-                        let self_ty = self.tcx.type_of(impl_def_id);\n-                        if self_ty.visit_with(self) {\n+                // Inherent static methods don't have self type in substs,\n+                // we have to check it additionally.\n+                if let Some(assoc_item) = self.tcx.opt_associated_item(def_id) {\n+                    if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n+                        if self.tcx.type_of(impl_def_id).visit_with(self) {\n                             return true;\n                         }\n                     }\n@@ -829,7 +843,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                             self.tcx.sess.span_err(self.span, &msg);\n                             return true;\n                         }\n-                        // Skip `Self` to avoid infinite recursion\n+                        // `Self` here is the same `TyAnon`, so skip it to avoid infinite recursion\n                         for subst in trait_ref.substs.iter().skip(1) {\n                             if subst.visit_with(self) {\n                                 return true;"}, {"sha": "28bf9e08157ecf027d28e34abb071ad121b15031", "filename": "src/test/compile-fail/auxiliary/private-inferred-type.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08a1d45818d022095d597919aa0d50ee7be2a0c6/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a1d45818d022095d597919aa0d50ee7be2a0c6/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fprivate-inferred-type.rs?ref=08a1d45818d022095d597919aa0d50ee7be2a0c6", "patch": "@@ -28,6 +28,9 @@ pub struct Pub<T = Alias>(pub T);\n impl Pub<Priv> {\n     pub fn static_method() {}\n }\n+impl Pub<u8> {\n+    fn priv_metod(&self) {}\n+}\n \n pub macro m() {\n     priv_fn;\n@@ -37,5 +40,5 @@ pub macro m() {\n     <u8 as PubTrait>::method;\n     PrivTupleStruct;\n     PubTupleStruct;\n-    Pub::static_method;\n+    Pub(0u8).priv_metod();\n }"}, {"sha": "438dd5e1933b8322726a694d815e778a2362fcb2", "filename": "src/test/compile-fail/private-inferred-type-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08a1d45818d022095d597919aa0d50ee7be2a0c6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a1d45818d022095d597919aa0d50ee7be2a0c6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs?ref=08a1d45818d022095d597919aa0d50ee7be2a0c6", "patch": "@@ -15,7 +15,7 @@\n // error-pattern:type `fn() {<u8 as ext::PrivTrait>::method}` is private\n // error-pattern:type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct::{{constructor}}}` is pr\n // error-pattern:type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct::{{constructor}}}` is priv\n-// error-pattern:type `ext::Priv` is private\n+// error-pattern:type `fn(&ext::Pub<u8>) {<ext::Pub<u8>>::priv_metod}` is private\n \n #![feature(decl_macro)]\n "}, {"sha": "c00bfe5e57479f24e23d3daa7c38d607f878ed22", "filename": "src/test/compile-fail/private-inferred-type.rs", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/08a1d45818d022095d597919aa0d50ee7be2a0c6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a1d45818d022095d597919aa0d50ee7be2a0c6/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs?ref=08a1d45818d022095d597919aa0d50ee7be2a0c6", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_consts)]\n #![feature(conservative_impl_trait)]\n #![feature(decl_macro)]\n \n@@ -29,7 +30,19 @@ mod m {\n \n     impl Pub<Priv> {\n         pub fn static_method() {}\n+        pub const INHERENT_ASSOC_CONST: u8 = 0;\n     }\n+    impl<T> Pub<T> {\n+        pub fn static_method_generic_self() {}\n+        pub const INHERENT_ASSOC_CONST_GENERIC_SELF: u8 = 0;\n+    }\n+    impl Pub<u8> {\n+        fn priv_metod(&self) {}\n+        pub fn method_with_substs<T>(&self) {}\n+        pub fn method_with_priv_params(&self, _: Priv) {}\n+    }\n+    impl TraitWithAssocConst for Priv {}\n+    impl TraitWithAssocTy for Priv { type AssocTy = u8; }\n \n     pub macro m() {\n         priv_fn; //~ ERROR type `fn() {m::priv_fn}` is private\n@@ -41,28 +54,71 @@ mod m {\n         //~^ ERROR type `fn(u8) -> m::PrivTupleStruct {m::PrivTupleStruct::{{constructor}}}` is priv\n         PubTupleStruct;\n         //~^ ERROR type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct::{{constructor}}}` is privat\n-        Pub::static_method; //~ ERROR type `m::Priv` is private\n+        Pub(0u8).priv_metod();\n+        //~^ ERROR type `fn(&m::Pub<u8>) {<m::Pub<u8>>::priv_metod}` is private\n     }\n \n     trait Trait {}\n     pub trait TraitWithTyParam<T> {}\n-    pub trait TraitWithAssocTy { type X; }\n+    pub trait TraitWithTyParam2<T> { fn pub_method() {} }\n+    pub trait TraitWithAssocTy { type AssocTy; }\n+    pub trait TraitWithAssocConst { const TRAIT_ASSOC_CONST: u8 = 0; }\n     impl Trait for u8 {}\n     impl<T> TraitWithTyParam<T> for u8 {}\n-    impl TraitWithAssocTy for u8 { type X = Priv; }\n+    impl TraitWithTyParam2<Priv> for u8 {}\n+    impl TraitWithAssocTy for u8 { type AssocTy = Priv; }\n \n     pub fn leak_anon1() -> impl Trait + 'static { 0 }\n     pub fn leak_anon2() -> impl TraitWithTyParam<Alias> { 0 }\n-    pub fn leak_anon3() -> impl TraitWithAssocTy<X = Alias> { 0 }\n+    pub fn leak_anon3() -> impl TraitWithAssocTy<AssocTy = Alias> { 0 }\n \n     pub fn leak_dyn1() -> Box<Trait + 'static> { Box::new(0) }\n     pub fn leak_dyn2() -> Box<TraitWithTyParam<Alias>> { Box::new(0) }\n-    pub fn leak_dyn3() -> Box<TraitWithAssocTy<X = Alias>> { Box::new(0) }\n+    pub fn leak_dyn3() -> Box<TraitWithAssocTy<AssocTy = Alias>> { Box::new(0) }\n+}\n+\n+mod adjust {\n+    // Construct a chain of derefs with a private type in the middle\n+    use std::ops::Deref;\n+\n+    pub struct S1;\n+    struct S2;\n+    pub type S2Alias = S2;\n+    pub struct S3;\n+\n+    impl Deref for S1 {\n+        type Target = S2Alias;\n+        fn deref(&self) -> &Self::Target { loop {} }\n+    }\n+    impl Deref for S2 {\n+        type Target = S3;\n+        fn deref(&self) -> &Self::Target { loop {} }\n+    }\n+\n+    impl S3 {\n+        pub fn method_s3(&self) {}\n+    }\n }\n \n fn main() {\n+    let _: m::Alias; //~ ERROR type `m::Priv` is private\n+    let _: <m::Alias as m::TraitWithAssocTy>::AssocTy; // FIXME\n     m::Alias {}; //~ ERROR type `m::Priv` is private\n     m::Pub { 0: m::Alias {} }; //~ ERROR type `m::Priv` is private\n+    m::Pub { 0: loop {} }; // FIXME\n+    m::Pub::static_method; //~ ERROR type `m::Priv` is private\n+    m::Pub::INHERENT_ASSOC_CONST; //~ ERROR type `m::Priv` is private\n+    m::Pub(0u8).method_with_substs::<m::Alias>(); //~ ERROR type `m::Priv` is private\n+    m::Pub(0u8).method_with_priv_params(loop{}); //~ ERROR type `m::Priv` is private\n+    <m::Alias as m::TraitWithAssocConst>::TRAIT_ASSOC_CONST; //~ ERROR type `m::Priv` is private\n+    <m::Pub<m::Alias>>::INHERENT_ASSOC_CONST; //~ ERROR type `m::Priv` is private\n+    <m::Pub<m::Alias>>::INHERENT_ASSOC_CONST_GENERIC_SELF; //~ ERROR type `m::Priv` is private\n+    <m::Pub<m::Alias>>::static_method_generic_self; //~ ERROR type `m::Priv` is private\n+    use m::TraitWithTyParam2;\n+    u8::pub_method; //~ ERROR type `m::Priv` is private\n+\n+    adjust::S1.method_s3(); //~ ERROR type `adjust::S2` is private\n+\n     m::m!();\n \n     m::leak_anon1(); //~ ERROR trait `m::Trait` is private"}, {"sha": "925d692f8ae6bf3fa14ff3d7b9335e62b6142c84", "filename": "src/test/compile-fail/private-type-in-interface.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08a1d45818d022095d597919aa0d50ee7be2a0c6/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a1d45818d022095d597919aa0d50ee7be2a0c6/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs?ref=08a1d45818d022095d597919aa0d50ee7be2a0c6", "patch": "@@ -17,6 +17,9 @@ extern crate private_inferred_type as ext;\n mod m {\n     struct Priv;\n     pub type Alias = Priv;\n+\n+    pub trait Trait { type X; }\n+    impl Trait for Priv { type X = u8; }\n }\n \n fn f(_: m::Alias) {} //~ ERROR type `m::Priv` is private\n@@ -28,6 +31,7 @@ trait Tr1 {}\n impl m::Alias {} //~ ERROR type `m::Priv` is private\n impl Tr1 for ext::Alias {} //~ ERROR type `ext::Priv` is private\n                            //~^ ERROR type `ext::Priv` is private\n+type A = <m::Alias as m::Trait>::X; //~ ERROR type `m::Priv` is private\n \n trait Tr2<T> {}\n impl<T> Tr2<T> for u8 {}"}]}