{"sha": "91857a3c82362c9572d280397001f02d86c416be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxODU3YTNjODIzNjJjOTU3MmQyODAzOTcwMDFmMDJkODZjNDE2YmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-15T04:24:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-15T04:24:16Z"}, "message": "Auto merge of #56540 - oli-obk:less_const_hackery, r=varkor\n\nDon't depend on `Allocation` sizes for pattern length\n\nAnd generally be more explicit about shortcomings of the implementation\n\ncc @RalfJung", "tree": {"sha": "de29dcbdb25f5cd28eeeb0a38e3c77165a0da60d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de29dcbdb25f5cd28eeeb0a38e3c77165a0da60d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91857a3c82362c9572d280397001f02d86c416be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91857a3c82362c9572d280397001f02d86c416be", "html_url": "https://github.com/rust-lang/rust/commit/91857a3c82362c9572d280397001f02d86c416be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91857a3c82362c9572d280397001f02d86c416be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcf920fc2707c3f126a2963a686ed800eeea49e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf920fc2707c3f126a2963a686ed800eeea49e6", "html_url": "https://github.com/rust-lang/rust/commit/bcf920fc2707c3f126a2963a686ed800eeea49e6"}, {"sha": "1c2a29e29a56d449111a1f39beb901983e8b7ebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2a29e29a56d449111a1f39beb901983e8b7ebc", "html_url": "https://github.com/rust-lang/rust/commit/1c2a29e29a56d449111a1f39beb901983e8b7ebc"}], "stats": {"total": 407, "additions": 318, "deletions": 89}, "files": [{"sha": "5cfcc16162ee2bb2426315be0ff18efa3e281d2c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 138, "deletions": 54, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/91857a3c82362c9572d280397001f02d86c416be/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91857a3c82362c9572d280397001f02d86c416be/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=91857a3c82362c9572d280397001f02d86c416be", "patch": "@@ -178,11 +178,11 @@ use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::layout::{Integer, IntegerExt, VariantIdx};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n+use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::ConstValue;\n+use rustc::mir::interpret::{ConstValue, Pointer, Scalar};\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -200,22 +200,72 @@ use std::u128;\n pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n                                 -> &'a Pattern<'tcx>\n {\n-    cx.pattern_arena.alloc(LiteralExpander.fold_pattern(&pat))\n+    cx.pattern_arena.alloc(LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat))\n }\n \n-struct LiteralExpander;\n-impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n+struct LiteralExpander<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n+    /// Derefs `val` and potentially unsizes the value if `crty` is an array and `rty` a slice.\n+    ///\n+    /// `crty` and `rty` can differ because you can use array constants in the presence of slice\n+    /// patterns. So the pattern may end up being a slice, but the constant is an array. We convert\n+    /// the array to a slice in that case.\n+    fn fold_const_value_deref(\n+        &mut self,\n+        val: ConstValue<'tcx>,\n+        // the pattern's pointee type\n+        rty: Ty<'tcx>,\n+        // the constant's pointee type\n+        crty: Ty<'tcx>,\n+    ) -> ConstValue<'tcx> {\n+        match (val, &crty.sty, &rty.sty) {\n+            // the easy case, deref a reference\n+            (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => ConstValue::ByRef(\n+                p.alloc_id,\n+                self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n+                p.offset,\n+            ),\n+            // unsize array to slice if pattern is array but match value or other patterns are slice\n+            (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n+                assert_eq!(t, u);\n+                ConstValue::ScalarPair(\n+                    Scalar::Ptr(p),\n+                    n.val.try_to_scalar().unwrap(),\n+                )\n+            },\n+            // fat pointers stay the same\n+            (ConstValue::ScalarPair(..), _, _) => val,\n+            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;` being used\n+            _ => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> PatternFolder<'tcx> for LiteralExpander<'a, 'tcx> {\n     fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n         match (&pat.ty.sty, &*pat.kind) {\n-            (&ty::Ref(_, rty, _), &PatternKind::Constant { ref value }) => {\n+            (\n+                &ty::Ref(_, rty, _),\n+                &PatternKind::Constant { value: Const {\n+                    val,\n+                    ty: ty::TyS { sty: ty::Ref(_, crty, _), .. },\n+                } },\n+            ) => {\n                 Pattern {\n                     ty: pat.ty,\n                     span: pat.span,\n                     kind: box PatternKind::Deref {\n                         subpattern: Pattern {\n                             ty: rty,\n                             span: pat.span,\n-                            kind: box PatternKind::Constant { value: value.clone() },\n+                            kind: box PatternKind::Constant { value: Const::from_const_value(\n+                                self.tcx,\n+                                self.fold_const_value_deref(*val, rty, crty),\n+                                rty,\n+                            ) },\n                         }\n                     }\n                 }\n@@ -732,15 +782,17 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     for row in patterns {\n         match *row.kind {\n             PatternKind::Constant { value } => {\n-                if let Some(ptr) = value.to_ptr() {\n-                    let is_array_ptr = value.ty\n-                        .builtin_deref(true)\n-                        .and_then(|t| t.ty.builtin_index())\n-                        .map_or(false, |t| t == cx.tcx.types.u8);\n-                    if is_array_ptr {\n-                        let alloc = cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                        max_fixed_len = cmp::max(max_fixed_len, alloc.bytes.len() as u64);\n-                    }\n+                // extract the length of an array/slice from a constant\n+                match (value.val, &value.ty.sty) {\n+                    (_, ty::Array(_, n)) => max_fixed_len = cmp::max(\n+                        max_fixed_len,\n+                        n.unwrap_usize(cx.tcx),\n+                    ),\n+                    (ConstValue::ScalarPair(_, n), ty::Slice(_)) => max_fixed_len = cmp::max(\n+                        max_fixed_len,\n+                        n.to_usize(&cx.tcx).unwrap(),\n+                    ),\n+                    _ => {},\n                 }\n             }\n             PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n@@ -1348,28 +1400,62 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-fn slice_pat_covered_by_constructor<'tcx>(\n+// checks whether a constant is equal to a user-written slice pattern. Only supports byte slices,\n+// meaning all other types will compare unequal and thus equal patterns often do not cause the\n+// second pattern to lint about unreachable match arms.\n+fn slice_pat_covered_by_const<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, '_>,\n     _span: Span,\n-    ctor: &Constructor,\n+    const_val: &ty::Const<'tcx>,\n     prefix: &[Pattern<'tcx>],\n     slice: &Option<Pattern<'tcx>>,\n     suffix: &[Pattern<'tcx>]\n ) -> Result<bool, ErrorReported> {\n-    let data: &[u8] = match *ctor {\n-        ConstantValue(const_val) => {\n-            let val = match const_val.val {\n-                ConstValue::Unevaluated(..) |\n-                ConstValue::ByRef(..) => bug!(\"unexpected ConstValue: {:?}\", const_val),\n-                ConstValue::Scalar(val) | ConstValue::ScalarPair(val, _) => val,\n-            };\n-            if let Ok(ptr) = val.to_ptr() {\n-                tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id).bytes.as_ref()\n-            } else {\n-                bug!(\"unexpected non-ptr ConstantValue\")\n+    let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n+        (ConstValue::ByRef(id, alloc, offset), ty::Array(t, n)) => {\n+            if *t != tcx.types.u8 {\n+                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n+                // any sort of exhaustiveness/unreachable check yet\n+                // This solely means that we don't lint about unreachable patterns, even if some\n+                // are definitely unreachable.\n+                return Ok(false);\n             }\n-        }\n-        _ => bug!()\n+            let ptr = Pointer::new(id, offset);\n+            let n = n.assert_usize(tcx).unwrap();\n+            alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n+        },\n+        // a slice fat pointer to a zero length slice\n+        (ConstValue::ScalarPair(Scalar::Bits { .. }, n), ty::Slice(t)) => {\n+            if *t != tcx.types.u8 {\n+                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n+                // any sort of exhaustiveness/unreachable check yet\n+                // This solely means that we don't lint about unreachable patterns, even if some\n+                // are definitely unreachable.\n+                return Ok(false);\n+            }\n+            assert_eq!(n.to_usize(&tcx).unwrap(), 0);\n+            &[]\n+        },\n+        //\n+        (ConstValue::ScalarPair(Scalar::Ptr(ptr), n), ty::Slice(t)) => {\n+            if *t != tcx.types.u8 {\n+                // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n+                // any sort of exhaustiveness/unreachable check yet\n+                // This solely means that we don't lint about unreachable patterns, even if some\n+                // are definitely unreachable.\n+                return Ok(false);\n+            }\n+            let n = n.to_usize(&tcx).unwrap();\n+            tcx.alloc_map\n+                .lock()\n+                .unwrap_memory(ptr.alloc_id)\n+                .get_bytes(&tcx, ptr, Size::from_bytes(n))\n+                .unwrap()\n+        },\n+        _ => bug!(\n+            \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n+            const_val, prefix, slice, suffix,\n+        ),\n     };\n \n     let pat_len = prefix.len() + suffix.len();\n@@ -1675,22 +1761,23 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     // necessarily point to memory, they are usually just integers. The only time\n                     // they should be pointing to memory is when they are subslices of nonzero\n                     // slices\n-                    let (opt_ptr, n, ty) = match value.ty.builtin_deref(false).unwrap().ty.sty {\n-                        ty::TyKind::Array(t, n) => (value.to_ptr(), n.unwrap_usize(cx.tcx), t),\n-                        ty::TyKind::Slice(t) => {\n-                            match value.val {\n-                                ConstValue::ScalarPair(ptr, n) => (\n-                                    ptr.to_ptr().ok(),\n-                                    n.to_bits(cx.tcx.data_layout.pointer_size).unwrap() as u64,\n-                                    t,\n-                                ),\n-                                _ => span_bug!(\n-                                    pat.span,\n-                                    \"slice pattern constant must be scalar pair but is {:?}\",\n-                                    value,\n-                                ),\n-                            }\n-                        },\n+                    let (opt_ptr, n, ty) = match (value.val, &value.ty.sty) {\n+                        (ConstValue::ByRef(id, alloc, offset), ty::TyKind::Array(t, n)) => (\n+                            Some((\n+                                Pointer::new(id, offset),\n+                                alloc,\n+                            )),\n+                            n.unwrap_usize(cx.tcx),\n+                            t,\n+                        ),\n+                        (ConstValue::ScalarPair(ptr, n), ty::TyKind::Slice(t)) => (\n+                            ptr.to_ptr().ok().map(|ptr| (\n+                                ptr,\n+                                cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                            )),\n+                            n.to_bits(cx.tcx.data_layout.pointer_size).unwrap() as u64,\n+                            t,\n+                        ),\n                         _ => span_bug!(\n                             pat.span,\n                             \"unexpected const-val {:?} with ctor {:?}\",\n@@ -1702,8 +1789,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                         // convert a constant slice/array pattern to a list of patterns.\n                         match (n, opt_ptr) {\n                             (0, _) => Some(SmallVec::new()),\n-                            (_, Some(ptr)) => {\n-                                let alloc = cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+                            (_, Some((ptr, alloc))) => {\n                                 let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n                                 (0..n).map(|i| {\n                                     let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n@@ -1766,10 +1852,8 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                         None\n                     }\n                 }\n-                ConstantValue(..) => {\n-                    match slice_pat_covered_by_constructor(\n-                        cx.tcx, pat.span, constructor, prefix, slice, suffix\n-                            ) {\n+                ConstantValue(cv) => {\n+                    match slice_pat_covered_by_const(cx.tcx, pat.span, cv, prefix, slice, suffix) {\n                         Ok(true) => Some(smallvec![]),\n                         Ok(false) => None,\n                         Err(ErrorReported) => None"}, {"sha": "ddd6a705b04d116a8d1135d91d4342ef19e20552", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/91857a3c82362c9572d280397001f02d86c416be/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91857a3c82362c9572d280397001f02d86c416be/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=91857a3c82362c9572d280397001f02d86c416be", "patch": "@@ -1259,34 +1259,32 @@ pub fn compare_const_vals<'a, 'tcx>(\n         }\n     }\n \n-    if let ty::Ref(_, rty, _) = ty.value.sty {\n-        if let ty::Str = rty.sty {\n-            match (a.val, b.val) {\n-                (\n-                    ConstValue::ScalarPair(\n-                        Scalar::Ptr(ptr_a),\n-                        len_a,\n-                    ),\n-                    ConstValue::ScalarPair(\n-                        Scalar::Ptr(ptr_b),\n-                        len_b,\n-                    ),\n-                ) if ptr_a.offset.bytes() == 0 && ptr_b.offset.bytes() == 0 => {\n-                    if let Ok(len_a) = len_a.to_bits(tcx.data_layout.pointer_size) {\n-                        if let Ok(len_b) = len_b.to_bits(tcx.data_layout.pointer_size) {\n-                            if len_a == len_b {\n-                                let map = tcx.alloc_map.lock();\n-                                let alloc_a = map.unwrap_memory(ptr_a.alloc_id);\n-                                let alloc_b = map.unwrap_memory(ptr_b.alloc_id);\n-                                if alloc_a.bytes.len() as u128 == len_a {\n-                                    return from_bool(alloc_a == alloc_b);\n-                                }\n+    if let ty::Str = ty.value.sty {\n+        match (a.val, b.val) {\n+            (\n+                ConstValue::ScalarPair(\n+                    Scalar::Ptr(ptr_a),\n+                    len_a,\n+                ),\n+                ConstValue::ScalarPair(\n+                    Scalar::Ptr(ptr_b),\n+                    len_b,\n+                ),\n+            ) if ptr_a.offset.bytes() == 0 && ptr_b.offset.bytes() == 0 => {\n+                if let Ok(len_a) = len_a.to_bits(tcx.data_layout.pointer_size) {\n+                    if let Ok(len_b) = len_b.to_bits(tcx.data_layout.pointer_size) {\n+                        if len_a == len_b {\n+                            let map = tcx.alloc_map.lock();\n+                            let alloc_a = map.unwrap_memory(ptr_a.alloc_id);\n+                            let alloc_b = map.unwrap_memory(ptr_b.alloc_id);\n+                            if alloc_a.bytes.len() as u128 == len_a {\n+                                return from_bool(alloc_a == alloc_b);\n                             }\n                         }\n                     }\n                 }\n-                _ => (),\n             }\n+            _ => (),\n         }\n     }\n "}, {"sha": "421f35438302b6d1d927405a9fd1c1242b14d8ae", "filename": "src/test/run-pass/ctfe/references.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Frun-pass%2Fctfe%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Frun-pass%2Fctfe%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Freferences.rs?ref=91857a3c82362c9572d280397001f02d86c416be", "patch": "@@ -28,6 +28,7 @@ fn main() {\n         _ => panic!(\"c\"),\n     }\n \n+    #[allow(unreachable_patterns)]\n     match &43 {\n         &42 => panic!(),\n         BOO => panic!(),"}, {"sha": "6496a2ab69f5c1dafea68750e0fd5731e61bc8dc", "filename": "src/test/ui/pattern/const-pat-ice.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.rs?ref=91857a3c82362c9572d280397001f02d86c416be", "patch": "@@ -0,0 +1,13 @@\n+// failure-status: 101\n+\n+// This is a repro test for an ICE in our pattern handling of constants.\n+\n+const FOO: &&&u32 = &&&42;\n+\n+fn main() {\n+    match unimplemented!() {\n+        &&&42 => {},\n+        FOO => {},\n+        _ => {},\n+    }\n+}"}, {"sha": "6cfef115d08dc0fc0697211e4d56d45e3b92c253", "filename": "src/test/ui/pattern/slice-pattern-const-2.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.rs?ref=91857a3c82362c9572d280397001f02d86c416be", "patch": "@@ -1,24 +1,31 @@\n-// compile-pass\n+#![deny(unreachable_patterns)]\n \n fn main() {\n     let s = &[0x00; 4][..]; //Slice of any value\n     const MAGIC_TEST: &[u32] = &[4, 5, 6, 7]; //Const slice to pattern match with\n     match s {\n         MAGIC_TEST => (),\n         [0x00, 0x00, 0x00, 0x00] => (),\n-        [4, 5, 6, 7] => (), // this should warn\n+        [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [0x00, 0x00, 0x00, 0x00] => (),\n         MAGIC_TEST => (),\n-        [4, 5, 6, 7] => (), // this should warn\n+        [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [0x00, 0x00, 0x00, 0x00] => (),\n         [4, 5, 6, 7] => (),\n-        MAGIC_TEST => (), // this should warn\n+        MAGIC_TEST => (), // FIXME(oli-obk): this should warn, but currently does not\n+        _ => (),\n+    }\n+    const FOO: [u32; 1] = [4];\n+    match [99] {\n+        [0x00] => (),\n+        [4] => (),\n+        FOO => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n }"}, {"sha": "95651ccc401e04579fe87bdf1bf95c6fc255ca97", "filename": "src/test/ui/pattern/slice-pattern-const-2.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-2.stderr?ref=91857a3c82362c9572d280397001f02d86c416be", "patch": "@@ -0,0 +1,26 @@\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-2.rs:9:9\n+   |\n+LL |         [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n+   |         ^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/slice-pattern-const-2.rs:1:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-2.rs:15:9\n+   |\n+LL |         [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n+   |         ^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-2.rs:28:9\n+   |\n+LL |         FOO => (), //~ ERROR unreachable pattern\n+   |         ^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "8805c43ba0283bdabe7f46093ee46b6be341470b", "filename": "src/test/ui/pattern/slice-pattern-const-3.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-3.rs?ref=91857a3c82362c9572d280397001f02d86c416be", "patch": "@@ -1,24 +1,31 @@\n-// compile-pass\n+#![deny(unreachable_patterns)]\n \n fn main() {\n     let s = &[\"0x00\"; 4][..]; //Slice of any value\n     const MAGIC_TEST: &[&str] = &[\"4\", \"5\", \"6\", \"7\"]; //Const slice to pattern match with\n     match s {\n         MAGIC_TEST => (),\n         [\"0x00\", \"0x00\", \"0x00\", \"0x00\"] => (),\n-        [\"4\", \"5\", \"6\", \"7\"] => (), // this should warn\n+        [\"4\", \"5\", \"6\", \"7\"] => (), // FIXME(oli-obk): this should warn, but currently does not\n         _ => (),\n     }\n     match s {\n         [\"0x00\", \"0x00\", \"0x00\", \"0x00\"] => (),\n         MAGIC_TEST => (),\n-        [\"4\", \"5\", \"6\", \"7\"] => (), // this should warn\n+        [\"4\", \"5\", \"6\", \"7\"] => (), // FIXME(oli-obk): this should warn, but currently does not\n         _ => (),\n     }\n     match s {\n         [\"0x00\", \"0x00\", \"0x00\", \"0x00\"] => (),\n         [\"4\", \"5\", \"6\", \"7\"] => (),\n-        MAGIC_TEST => (), // this should warn\n+        MAGIC_TEST => (), // FIXME(oli-obk): this should warn, but currently does not\n+        _ => (),\n+    }\n+    const FOO: [&str; 1] = [\"boo\"];\n+    match [\"baa\"] {\n+        [\"0x00\"] => (),\n+        [\"boo\"] => (),\n+        FOO => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n }"}, {"sha": "531bbbc84d038fb28ba941800749352866654188", "filename": "src/test/ui/pattern/slice-pattern-const-3.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const-3.stderr?ref=91857a3c82362c9572d280397001f02d86c416be", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-3.rs:28:9\n+   |\n+LL |         FOO => (), //~ ERROR unreachable pattern\n+   |         ^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/slice-pattern-const-3.rs:1:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "f0a04513f91fb71d11cc68154225df0c0ed10176", "filename": "src/test/ui/pattern/slice-pattern-const.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const.rs?ref=91857a3c82362c9572d280397001f02d86c416be", "patch": "@@ -1,24 +1,47 @@\n-//compile-pass\n+#![deny(unreachable_patterns)]\n \n fn main() {\n     let s = &[0x00; 4][..]; //Slice of any value\n     const MAGIC_TEST: &[u8] = b\"TEST\"; //Const slice to pattern match with\n     match s {\n         MAGIC_TEST => (),\n         [0x00, 0x00, 0x00, 0x00] => (),\n-        [84, 69, 83, 84] => (), // this should warn\n+        [84, 69, 83, 84] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [0x00, 0x00, 0x00, 0x00] => (),\n         MAGIC_TEST => (),\n-        [84, 69, 83, 84] => (), // this should warn\n+        [84, 69, 83, 84] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [0x00, 0x00, 0x00, 0x00] => (),\n         [84, 69, 83, 84] => (),\n-        MAGIC_TEST => (), // this should warn\n+        MAGIC_TEST => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n+    const FOO: [u8; 1] = [4];\n+    match [99] {\n+        [0x00] => (),\n+        [4] => (),\n+        FOO => (), //~ ERROR unreachable pattern\n+        _ => (),\n+    }\n+    const BAR: &[u8; 1] = &[4];\n+    match &[99] {\n+        [0x00] => (),\n+        [4] => (),\n+        BAR => (), //~ ERROR unreachable pattern\n+        b\"a\" => (),\n+        _ => (),\n+    }\n+\n+    const BOO: &[u8; 0] = &[];\n+    match &[] {\n+        [] => (),\n+        BOO => (), //~ ERROR unreachable pattern\n+        b\"\" => (), //~ ERROR unreachable pattern\n+        _ => (), //~ ERROR unreachable pattern\n+    }\n }"}, {"sha": "412e0158c01c7462415034a0c1a547c9849b86f0", "filename": "src/test/ui/pattern/slice-pattern-const.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91857a3c82362c9572d280397001f02d86c416be/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fslice-pattern-const.stderr?ref=91857a3c82362c9572d280397001f02d86c416be", "patch": "@@ -0,0 +1,56 @@\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const.rs:9:9\n+   |\n+LL |         [84, 69, 83, 84] => (), //~ ERROR unreachable pattern\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/slice-pattern-const.rs:1:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const.rs:15:9\n+   |\n+LL |         [84, 69, 83, 84] => (), //~ ERROR unreachable pattern\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const.rs:21:9\n+   |\n+LL |         MAGIC_TEST => (), //~ ERROR unreachable pattern\n+   |         ^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const.rs:28:9\n+   |\n+LL |         FOO => (), //~ ERROR unreachable pattern\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const.rs:35:9\n+   |\n+LL |         BAR => (), //~ ERROR unreachable pattern\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const.rs:43:9\n+   |\n+LL |         BOO => (), //~ ERROR unreachable pattern\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const.rs:44:9\n+   |\n+LL |         b\"\" => (), //~ ERROR unreachable pattern\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const.rs:45:9\n+   |\n+LL |         _ => (), //~ ERROR unreachable pattern\n+   |         ^\n+\n+error: aborting due to 8 previous errors\n+"}]}