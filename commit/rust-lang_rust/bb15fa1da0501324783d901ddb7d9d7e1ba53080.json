{"sha": "bb15fa1da0501324783d901ddb7d9d7e1ba53080", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMTVmYTFkYTA1MDEzMjQ3ODNkOTAxZGRiN2Q5ZDdlMWJhNTMwODA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-12-31T08:30:23Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-12-31T08:31:55Z"}, "message": "Add fallible Arc APIs (`Arc::try_new_*`)", "tree": {"sha": "f97bd8262c73737d735a9de5071c46f633e7453b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f97bd8262c73737d735a9de5071c46f633e7453b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb15fa1da0501324783d901ddb7d9d7e1ba53080", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb15fa1da0501324783d901ddb7d9d7e1ba53080", "html_url": "https://github.com/rust-lang/rust/commit/bb15fa1da0501324783d901ddb7d9d7e1ba53080", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb15fa1da0501324783d901ddb7d9d7e1ba53080/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "973fa8e30eb2f699db4337624e193d0994666c7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/973fa8e30eb2f699db4337624e193d0994666c7c", "html_url": "https://github.com/rust-lang/rust/commit/973fa8e30eb2f699db4337624e193d0994666c7c"}], "stats": {"total": 122, "additions": 122, "deletions": 0}, "files": [{"sha": "e8c3d1293e7b104413786ba3e57439e815afd086", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/bb15fa1da0501324783d901ddb7d9d7e1ba53080/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb15fa1da0501324783d901ddb7d9d7e1ba53080/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=bb15fa1da0501324783d901ddb7d9d7e1ba53080", "patch": "@@ -478,6 +478,97 @@ impl<T> Arc<T> {\n         unsafe { Pin::new_unchecked(Arc::new(data)) }\n     }\n \n+    /// Constructs a new `Arc<T>`, returning an error if allocation fails.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::try_new(5)?;\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn try_new(data: T) -> Result<Arc<T>, AllocError> {\n+        // Start the weak pointer count as 1 which is the weak pointer that's\n+        // held by all the strong pointers (kinda), see std/rc.rs for more info\n+        let x: Box<_> = Box::try_new(ArcInner {\n+            strong: atomic::AtomicUsize::new(1),\n+            weak: atomic::AtomicUsize::new(1),\n+            data,\n+        })?;\n+        Ok(Self::from_inner(Box::leak(x).into()))\n+    }\n+\n+    /// Constructs a new `Arc` with uninitialized contents, returning an error\n+    /// if allocation fails.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit, allocator_api)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::try_new_uninit()?;\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn try_new_uninit() -> Result<Arc<mem::MaybeUninit<T>>, AllocError> {\n+        unsafe {\n+            Ok(Arc::from_ptr(Arc::try_allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.allocate(layout),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            )?))\n+        }\n+    }\n+\n+    /// Constructs a new `Arc` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes, returning an error if allocation fails.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit, allocator_api)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let zero = Arc::<u32>::try_new_zeroed()?;\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    ///\n+    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn try_new_zeroed() -> Result<Arc<mem::MaybeUninit<T>>, AllocError> {\n+        unsafe {\n+            Ok(Arc::from_ptr(Arc::try_allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.allocate_zeroed(layout),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            )?))\n+        }\n+    }\n     /// Returns the inner value, if the `Arc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`] is returned with the same `Arc` that was\n@@ -1009,6 +1100,37 @@ impl<T: ?Sized> Arc<T> {\n         inner\n     }\n \n+    /// Allocates an `ArcInner<T>` with sufficient space for\n+    /// a possibly-unsized inner value where the value has the layout provided,\n+    /// returning an error if allocation fails.\n+    ///\n+    /// The function `mem_to_arcinner` is called with the data pointer\n+    /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n+    unsafe fn try_allocate_for_layout(\n+        value_layout: Layout,\n+        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n+        mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n+    ) -> Result<*mut ArcInner<T>, AllocError> {\n+        // Calculate layout using the given value layout.\n+        // Previously, layout was calculated on the expression\n+        // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n+        // reference (see #54908).\n+        let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+\n+        let ptr = allocate(layout)?;\n+\n+        // Initialize the ArcInner\n+        let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());\n+        debug_assert_eq!(unsafe { Layout::for_value(&*inner) }, layout);\n+\n+        unsafe {\n+            ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n+            ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n+        }\n+\n+        Ok(inner)\n+    }\n+\n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value."}]}