{"sha": "e3f6e68d633040be0b88a0e11e6645bc506f8655", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZjZlNjhkNjMzMDQwYmUwYjg4YTBlMTFlNjY0NWJjNTA2Zjg2NTU=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-04-30T18:33:25Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-05-15T09:13:32Z"}, "message": "Remove (direct) rustc_llvm dependency from rustc_driver\n\nThis does not actually improve build times, since it still depends\non rustc_trans, but is better layering and fits the multi-backend\nfuture slightly better.", "tree": {"sha": "b9708c93fe8bc5d187fc2a5072c18e61c5fe4f6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9708c93fe8bc5d187fc2a5072c18e61c5fe4f6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3f6e68d633040be0b88a0e11e6645bc506f8655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3f6e68d633040be0b88a0e11e6645bc506f8655", "html_url": "https://github.com/rust-lang/rust/commit/e3f6e68d633040be0b88a0e11e6645bc506f8655", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3f6e68d633040be0b88a0e11e6645bc506f8655/comments", "author": null, "committer": null, "parents": [{"sha": "8e4f3151166d8ddea2d365c589bf4ac7ab6f20c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e4f3151166d8ddea2d365c589bf4ac7ab6f20c9", "html_url": "https://github.com/rust-lang/rust/commit/8e4f3151166d8ddea2d365c589bf4ac7ab6f20c9"}], "stats": {"total": 242, "additions": 139, "deletions": 103}, "files": [{"sha": "05b99b0700797685a736ad964846d5e6d11e6850", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=e3f6e68d633040be0b88a0e11e6645bc506f8655", "patch": "@@ -560,7 +560,6 @@ dependencies = [\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_lint 0.0.0\",\n- \"rustc_llvm 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"rustc_passes 0.0.0\","}, {"sha": "4212fa1f8b12e1488f94e2d34a312931f4a7118f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e3f6e68d633040be0b88a0e11e6645bc506f8655", "patch": "@@ -328,7 +328,7 @@ top_level_options!(\n     }\n );\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PrintRequest {\n     FileNames,\n     Sysroot,"}, {"sha": "2e949f48c175ee7e44c9126d771043367b352e30", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=e3f6e68d633040be0b88a0e11e6645bc506f8655", "patch": "@@ -22,7 +22,6 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_lint = { path = \"../librustc_lint\" }\n-rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_passes = { path = \"../librustc_passes\" }"}, {"sha": "34f636d0b9a12db2225e9c212d5c390b3e9309fc", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e3f6e68d633040be0b88a0e11e6645bc506f8655", "patch": "@@ -56,7 +56,6 @@ extern crate rustc_save_analysis;\n extern crate rustc_trans;\n extern crate rustc_typeck;\n extern crate serialize;\n-extern crate rustc_llvm as llvm;\n #[macro_use]\n extern crate log;\n extern crate syntax;\n@@ -70,7 +69,7 @@ use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n use rustc_trans::back::link;\n-use rustc_trans::back::write::{create_target_machine, RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n+use rustc_trans::back::write::{RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n@@ -182,7 +181,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n \n     if sopts.debugging_opts.debug_llvm {\n-        unsafe { llvm::LLVMRustSetDebug(1); }\n+        rustc_trans::enable_llvm_debug();\n     }\n \n     let descriptions = diagnostics_registry();\n@@ -671,14 +670,6 @@ impl RustcDefaultCalls {\n                         println!(\"{}\", cfg);\n                     }\n                 }\n-                PrintRequest::TargetCPUs => {\n-                    let tm = create_target_machine(sess);\n-                    unsafe { llvm::LLVMRustPrintTargetCPUs(tm); }\n-                }\n-                PrintRequest::TargetFeatures => {\n-                    let tm = create_target_machine(sess);\n-                    unsafe { llvm::LLVMRustPrintTargetFeatures(tm); }\n-                }\n                 PrintRequest::RelocationModels => {\n                     println!(\"Available relocation models:\");\n                     for &(name, _) in RELOC_MODEL_ARGS.iter() {\n@@ -693,6 +684,9 @@ impl RustcDefaultCalls {\n                     }\n                     println!(\"\");\n                 }\n+                PrintRequest::TargetCPUs | PrintRequest::TargetFeatures => {\n+                    rustc_trans::print(*req, sess);\n+                }\n             }\n         }\n         return Compilation::Stop;\n@@ -730,10 +724,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(release_str()));\n-        unsafe {\n-            println!(\"LLVM version: {}.{}\",\n-                     llvm::LLVMRustVersionMajor(), llvm::LLVMRustVersionMinor());\n-        }\n+        rustc_trans::print_version();\n     }\n }\n \n@@ -1026,9 +1017,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n-        unsafe {\n-            ::llvm::LLVMRustPrintPasses();\n-        }\n+        rustc_trans::print_passes();\n         return None;\n     }\n "}, {"sha": "bee61bb398029756511fcc1a2300c1209b9ac618", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=e3f6e68d633040be0b88a0e11e6645bc506f8655", "patch": "@@ -9,46 +9,20 @@\n // except according to those terms.\n \n use syntax::ast;\n-use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n-use rustc_trans::back::write::create_target_machine;\n use syntax::symbol::Symbol;\n-use libc::c_char;\n-\n-// WARNING: the features must be known to LLVM or the feature\n-// detection code will walk past the end of the feature array,\n-// leading to crashes.\n-\n-const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n-\n-const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n-                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n-                                                 \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n-                                                 \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\", \"fma\\0\"];\n-\n-const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n+use rustc_trans;\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n ///\n /// This is performed by checking whether a whitelisted set of\n /// features is available on the target machine, by querying LLVM.\n pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n-    let target_machine = create_target_machine(sess);\n-\n-    let whitelist = match &*sess.target.target.arch {\n-        \"arm\" => ARM_WHITELIST,\n-        \"x86\" | \"x86_64\" => X86_WHITELIST,\n-        \"hexagon\" => HEXAGON_WHITELIST,\n-        _ => &[],\n-    };\n-\n     let tf = Symbol::intern(\"target_feature\");\n-    for feat in whitelist {\n-        assert_eq!(feat.chars().last(), Some('\\0'));\n-        if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.insert((tf, Some(Symbol::intern(&feat[..feat.len() - 1]))));\n-        }\n+\n+    for feat in rustc_trans::target_features(sess) {\n+        cfg.insert((tf, Some(feat)));\n     }\n \n     let requested_features = sess.opts.cg.target_feature.split(',');"}, {"sha": "3ac0d88b90d7b7be0f6894313951a6b6595cf235", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 52, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e3f6e68d633040be0b88a0e11e6645bc506f8655", "patch": "@@ -72,6 +72,7 @@ pub use base::trans_crate;\n pub use back::symbol_names::provide;\n \n pub use metadata::LlvmMetadataLoader;\n+pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n \n pub mod back {\n     pub use rustc::hir::svh;\n@@ -122,6 +123,7 @@ mod debuginfo;\n mod declare;\n mod glue;\n mod intrinsic;\n+mod llvm_util;\n mod machine;\n mod metadata;\n mod meth;\n@@ -178,55 +180,3 @@ pub struct CrateTranslation {\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }\n-\n-use rustc::session::Session;\n-pub fn init(sess: &Session) {\n-    unsafe {\n-        // Before we touch LLVM, make sure that multithreading is enabled.\n-        use std::sync::Once;\n-        static INIT: Once = Once::new();\n-        static mut POISONED: bool = false;\n-        INIT.call_once(|| {\n-            if llvm::LLVMStartMultithreaded() != 1 {\n-                // use an extra bool to make sure that all future usage of LLVM\n-                // cannot proceed despite the Once not running more than once.\n-                POISONED = true;\n-            }\n-\n-            configure_llvm(sess);\n-        });\n-\n-        if POISONED {\n-            bug!(\"couldn't enable multi-threaded LLVM\");\n-        }\n-    }\n-}\n-\n-use std::ffi::CString;\n-use libc::c_int;\n-unsafe fn configure_llvm(sess: &Session) {\n-    let mut llvm_c_strs = Vec::new();\n-    let mut llvm_args = Vec::new();\n-\n-    {\n-        let mut add = |arg: &str| {\n-            let s = CString::new(arg).unwrap();\n-            llvm_args.push(s.as_ptr());\n-            llvm_c_strs.push(s);\n-        };\n-        add(\"rustc\"); // fake program name\n-        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n-        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n-\n-        for arg in &sess.opts.cg.llvm_args {\n-            add(&(*arg));\n-        }\n-    }\n-\n-    llvm::LLVMInitializePasses();\n-\n-    llvm::initialize_available_targets();\n-\n-    llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n-                                 llvm_args.as_ptr());\n-}"}, {"sha": "0f4c6b6408015b49e5d185c3fb1bfe329aab7809", "filename": "src/librustc_trans/llvm_util.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f6e68d633040be0b88a0e11e6645bc506f8655/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=e3f6e68d633040be0b88a0e11e6645bc506f8655", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax_pos::symbol::Symbol;\n+use back::write::create_target_machine;\n+use llvm;\n+use rustc::session::Session;\n+use rustc::session::config::PrintRequest;\n+use libc::{c_int, c_char};\n+use std::ffi::CString;\n+\n+pub fn init(sess: &Session) {\n+    unsafe {\n+        // Before we touch LLVM, make sure that multithreading is enabled.\n+        use std::sync::Once;\n+        static INIT: Once = Once::new();\n+        static mut POISONED: bool = false;\n+        INIT.call_once(|| {\n+            if llvm::LLVMStartMultithreaded() != 1 {\n+                // use an extra bool to make sure that all future usage of LLVM\n+                // cannot proceed despite the Once not running more than once.\n+                POISONED = true;\n+            }\n+\n+            configure_llvm(sess);\n+        });\n+\n+        if POISONED {\n+            bug!(\"couldn't enable multi-threaded LLVM\");\n+        }\n+    }\n+}\n+\n+unsafe fn configure_llvm(sess: &Session) {\n+    let mut llvm_c_strs = Vec::new();\n+    let mut llvm_args = Vec::new();\n+\n+    {\n+        let mut add = |arg: &str| {\n+            let s = CString::new(arg).unwrap();\n+            llvm_args.push(s.as_ptr());\n+            llvm_c_strs.push(s);\n+        };\n+        add(\"rustc\"); // fake program name\n+        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n+        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n+\n+        for arg in &sess.opts.cg.llvm_args {\n+            add(&(*arg));\n+        }\n+    }\n+\n+    llvm::LLVMInitializePasses();\n+\n+    llvm::initialize_available_targets();\n+\n+    llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n+                                 llvm_args.as_ptr());\n+}\n+\n+// WARNING: the features must be known to LLVM or the feature\n+// detection code will walk past the end of the feature array,\n+// leading to crashes.\n+\n+const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n+\n+const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n+                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n+                                                 \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n+                                                 \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\", \"fma\\0\"];\n+\n+const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n+\n+pub fn target_features(sess: &Session) -> Vec<Symbol> {\n+    let target_machine = create_target_machine(sess);\n+\n+    let whitelist = match &*sess.target.target.arch {\n+        \"arm\" => ARM_WHITELIST,\n+        \"x86\" | \"x86_64\" => X86_WHITELIST,\n+        \"hexagon\" => HEXAGON_WHITELIST,\n+        _ => &[],\n+    };\n+\n+    let mut features = Vec::new();\n+    for feat in whitelist {\n+        assert_eq!(feat.chars().last(), Some('\\0'));\n+        if unsafe { llvm::LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n+            features.push(Symbol::intern(&feat[..feat.len() - 1]));\n+        }\n+    }\n+    features\n+}\n+\n+pub fn print_version() {\n+    unsafe {\n+        println!(\"LLVM version: {}.{}\",\n+                 llvm::LLVMRustVersionMajor(), llvm::LLVMRustVersionMinor());\n+    }\n+}\n+\n+pub fn print_passes() {\n+    unsafe { llvm::LLVMRustPrintPasses(); }\n+}\n+\n+pub fn print(req: PrintRequest, sess: &Session) {\n+    let tm = create_target_machine(sess);\n+    unsafe {\n+        match req {\n+            PrintRequest::TargetCPUs => llvm::LLVMRustPrintTargetCPUs(tm),\n+            PrintRequest::TargetFeatures => llvm::LLVMRustPrintTargetFeatures(tm),\n+            _ => bug!(\"rustc_trans can't handle print request: {:?}\", req),\n+        }\n+    }\n+}\n+\n+pub fn enable_llvm_debug() {\n+    unsafe { llvm::LLVMRustSetDebug(1); }\n+}"}]}