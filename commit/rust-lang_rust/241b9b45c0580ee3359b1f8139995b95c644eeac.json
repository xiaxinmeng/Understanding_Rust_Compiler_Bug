{"sha": "241b9b45c0580ee3359b1f8139995b95c644eeac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MWI5YjQ1YzA1ODBlZTMzNTliMWY4MTM5OTk1Yjk1YzY0NGVlYWM=", "commit": {"author": {"name": "MaloJaffre", "email": "jaffre.malo@gmail.com", "date": "2018-08-22T07:06:24Z"}, "committer": {"name": "MaloJaffre", "email": "jaffre.malo@gmail.com", "date": "2018-08-22T08:27:42Z"}, "message": "Revert \"Auto merge of #52553 - Pazzaz:vecdeque-append, r=SimonSapin\"\n\nThis partially reverts commit d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800,\nreversing changes made to 6b1ff19af36f7bbf1974579ec1b9bf2c8ccd595e.\n\nFixes #53529.\nCc: #53564.", "tree": {"sha": "5521c6a4e704ada3ada0e7c586fb9becd1c6d30e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5521c6a4e704ada3ada0e7c586fb9becd1c6d30e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/241b9b45c0580ee3359b1f8139995b95c644eeac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/241b9b45c0580ee3359b1f8139995b95c644eeac", "html_url": "https://github.com/rust-lang/rust/commit/241b9b45c0580ee3359b1f8139995b95c644eeac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/241b9b45c0580ee3359b1f8139995b95c644eeac/comments", "author": {"login": "MaloJaffre", "id": 16278359, "node_id": "MDQ6VXNlcjE2Mjc4MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/16278359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MaloJaffre", "html_url": "https://github.com/MaloJaffre", "followers_url": "https://api.github.com/users/MaloJaffre/followers", "following_url": "https://api.github.com/users/MaloJaffre/following{/other_user}", "gists_url": "https://api.github.com/users/MaloJaffre/gists{/gist_id}", "starred_url": "https://api.github.com/users/MaloJaffre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MaloJaffre/subscriptions", "organizations_url": "https://api.github.com/users/MaloJaffre/orgs", "repos_url": "https://api.github.com/users/MaloJaffre/repos", "events_url": "https://api.github.com/users/MaloJaffre/events{/privacy}", "received_events_url": "https://api.github.com/users/MaloJaffre/received_events", "type": "User", "site_admin": false}, "committer": {"login": "MaloJaffre", "id": 16278359, "node_id": "MDQ6VXNlcjE2Mjc4MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/16278359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MaloJaffre", "html_url": "https://github.com/MaloJaffre", "followers_url": "https://api.github.com/users/MaloJaffre/followers", "following_url": "https://api.github.com/users/MaloJaffre/following{/other_user}", "gists_url": "https://api.github.com/users/MaloJaffre/gists{/gist_id}", "starred_url": "https://api.github.com/users/MaloJaffre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MaloJaffre/subscriptions", "organizations_url": "https://api.github.com/users/MaloJaffre/orgs", "repos_url": "https://api.github.com/users/MaloJaffre/repos", "events_url": "https://api.github.com/users/MaloJaffre/events{/privacy}", "received_events_url": "https://api.github.com/users/MaloJaffre/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "786ccc336dc684cdb00402e84abe4a9bc53857cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/786ccc336dc684cdb00402e84abe4a9bc53857cf", "html_url": "https://github.com/rust-lang/rust/commit/786ccc336dc684cdb00402e84abe4a9bc53857cf"}], "stats": {"total": 161, "additions": 2, "deletions": 159}, "files": [{"sha": "cbc80b70d9775133140975c8ab8ea28dde1fff84", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 159, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/241b9b45c0580ee3359b1f8139995b95c644eeac/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/241b9b45c0580ee3359b1f8139995b95c644eeac/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=241b9b45c0580ee3359b1f8139995b95c644eeac", "patch": "@@ -202,23 +202,6 @@ impl<T> VecDeque<T> {\n                                  len);\n     }\n \n-    /// Returns a pair of slices which contain the contents of the buffer not used by the VecDeque.\n-    #[inline]\n-    unsafe fn unused_as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n-        let head = self.head;\n-        let tail = self.tail;\n-        let buf = self.buffer_as_mut_slice();\n-        if head != tail {\n-            // In buf, head..tail contains the VecDeque and tail..head is unused.\n-            // So calling `ring_slices` with tail and head swapped returns unused slices.\n-            RingSlices::ring_slices(buf, tail, head)\n-        } else {\n-            // Swapping doesn't help when head == tail.\n-            let (before, after) = buf.split_at_mut(head);\n-            (after, before)\n-        }\n-    }\n-\n     /// Copies a potentially wrapping block of memory len long from src to dest.\n     /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n     /// most one continuous overlapping region between src and dest).\n@@ -1851,148 +1834,8 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        // Copies all values from `src_slice` to the start of `dst_slice`.\n-        unsafe fn copy_whole_slice<T>(src_slice: &[T], dst_slice: &mut [T]) {\n-            let len = src_slice.len();\n-            ptr::copy_nonoverlapping(src_slice.as_ptr(), dst_slice[..len].as_mut_ptr(), len);\n-        }\n-\n-        let src_total = other.len();\n-\n-        // Guarantees there is space in `self` for `other`.\n-        self.reserve(src_total);\n-\n-        self.head = {\n-            let original_head = self.head;\n-\n-            // The goal is to copy all values from `other` into `self`. To avoid any\n-            // mismatch, all valid values in `other` are retrieved...\n-            let (src_high, src_low) = other.as_slices();\n-            // and unoccupied parts of self are retrieved.\n-            let (dst_high, dst_low) = unsafe { self.unused_as_mut_slices() };\n-\n-            // Then all that is needed is to copy all values from\n-            // src (src_high and src_low) to dst (dst_high and dst_low).\n-            //\n-            // other [o o o . . . . . o o o o]\n-            //       [5 6 7]         [1 2 3 4]\n-            //       src_low         src_high\n-            //\n-            // self  [. . . . . . o o o o . .]\n-            //       [3 4 5 6 7 .]       [1 2]\n-            //       dst_low             dst_high\n-            //\n-            // Values are not copied one by one but as slices in `copy_whole_slice`.\n-            // What slices are used depends on various properties of src and dst.\n-            // There are 6 cases in total:\n-            //     1. `src` is contiguous and fits in dst_high\n-            //     2. `src` is contiguous and does not fit in dst_high\n-            //     3. `src` is discontiguous and fits in dst_high\n-            //     4. `src` is discontiguous and does not fit in dst_high\n-            //        + src_high is smaller than dst_high\n-            //     5. `src` is discontiguous and does not fit in dst_high\n-            //        + dst_high is smaller than src_high\n-            //     6. `src` is discontiguous and does not fit in dst_high\n-            //        + dst_high is the same size as src_high\n-            let src_contiguous = src_low.is_empty();\n-            let dst_high_fits_src = dst_high.len() >= src_total;\n-            match (src_contiguous, dst_high_fits_src) {\n-                (true, true) => {\n-                    // 1.\n-                    // other [. . . o o o . . . . . .]\n-                    //       []    [1 1 1]\n-                    //\n-                    // self  [. o o o o o . . . . . .]\n-                    //       [.]         [1 1 1 . . .]\n-\n-                    unsafe {\n-                        copy_whole_slice(src_high, dst_high);\n-                    }\n-                    original_head + src_total\n-                }\n-                (true, false) => {\n-                    // 2.\n-                    // other [. . . o o o o o . . . .]\n-                    //       []    [1 1 2 2 2]\n-                    //\n-                    // self  [. . . . . . . o o o . .]\n-                    //       [2 2 2 . . . .]     [1 1]\n-\n-                    let (src_1, src_2) = src_high.split_at(dst_high.len());\n-                    unsafe {\n-                        copy_whole_slice(src_1, dst_high);\n-                        copy_whole_slice(src_2, dst_low);\n-                    }\n-                    src_total - dst_high.len()\n-                }\n-                (false, true) => {\n-                    // 3.\n-                    // other [o o . . . . . . . o o o]\n-                    //       [2 2]             [1 1 1]\n-                    //\n-                    // self  [. o o . . . . . . . . .]\n-                    //       [.]   [1 1 1 2 2 . . . .]\n-\n-                    let (dst_1, dst_2) = dst_high.split_at_mut(src_high.len());\n-                    unsafe {\n-                        copy_whole_slice(src_high, dst_1);\n-                        copy_whole_slice(src_low, dst_2);\n-                    }\n-                    original_head + src_total\n-                }\n-                (false, false) => {\n-                    if src_high.len() < dst_high.len() {\n-                        // 4.\n-                        // other [o o o . . . . . . o o o]\n-                        //       [2 3 3]           [1 1 1]\n-                        //\n-                        // self  [. . . . . . o o . . . .]\n-                        //       [3 3 . . . .]   [1 1 1 2]\n-\n-                        let (dst_1, dst_2) = dst_high.split_at_mut(src_high.len());\n-                        let (src_2, src_3) = src_low.split_at(dst_2.len());\n-                        unsafe {\n-                            copy_whole_slice(src_high, dst_1);\n-                            copy_whole_slice(src_2, dst_2);\n-                            copy_whole_slice(src_3, dst_low);\n-                        }\n-                        src_3.len()\n-                    } else if src_high.len() > dst_high.len() {\n-                        // 5.\n-                        // other [o o o . . . . . o o o o]\n-                        //       [3 3 3]         [1 1 2 2]\n-                        //\n-                        // self  [. . . . . . o o o o . .]\n-                        //       [2 2 3 3 3 .]       [1 1]\n-\n-                        let (src_1, src_2) = src_high.split_at(dst_high.len());\n-                        let (dst_2, dst_3) = dst_low.split_at_mut(src_2.len());\n-                        unsafe {\n-                            copy_whole_slice(src_1, dst_high);\n-                            copy_whole_slice(src_2, dst_2);\n-                            copy_whole_slice(src_low, dst_3);\n-                        }\n-                        dst_2.len() + src_low.len()\n-                    } else {\n-                        // 6.\n-                        // other [o o . . . . . . . o o o]\n-                        //       [2 2]             [1 1 1]\n-                        //\n-                        // self  [. . . . . . . o o . . .]\n-                        //       [2 2 . . . . .]   [1 1 1]\n-\n-                        unsafe {\n-                            copy_whole_slice(src_high, dst_high);\n-                            copy_whole_slice(src_low, dst_low);\n-                        }\n-                        src_low.len()\n-                    }\n-                }\n-            }\n-        };\n-\n-        // Some values now exist in both `other` and `self` but are made inaccessible in `other`.\n-        other.tail = other.head;\n+        // naive impl\n+        self.extend(other.drain(..));\n     }\n \n     /// Retains only the elements specified by the predicate."}]}