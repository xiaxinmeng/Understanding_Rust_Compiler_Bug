{"sha": "873a18e2213a506d4cf6357e5faef0990ec08683", "node_id": "C_kwDOAAsO6NoAKDg3M2ExOGUyMjEzYTUwNmQ0Y2Y2MzU3ZTVmYWVmMDk5MGVjMDg2ODM", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-10-17T20:49:32Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-10-18T22:02:00Z"}, "message": "specialize slice_iter.copied().next_chunk()", "tree": {"sha": "75bfb24a2bd274dea50816f83561b9eb73be0fc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75bfb24a2bd274dea50816f83561b9eb73be0fc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/873a18e2213a506d4cf6357e5faef0990ec08683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/873a18e2213a506d4cf6357e5faef0990ec08683", "html_url": "https://github.com/rust-lang/rust/commit/873a18e2213a506d4cf6357e5faef0990ec08683", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/873a18e2213a506d4cf6357e5faef0990ec08683/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "963d6f757c52dd0693e3c0541d7b027279f8a2db", "url": "https://api.github.com/repos/rust-lang/rust/commits/963d6f757c52dd0693e3c0541d7b027279f8a2db", "html_url": "https://github.com/rust-lang/rust/commit/963d6f757c52dd0693e3c0541d7b027279f8a2db"}], "stats": {"total": 74, "additions": 74, "deletions": 0}, "files": [{"sha": "62d3afb81603dc19d1090a12d818361f201a0a42", "filename": "library/core/src/iter/adapters/copied.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/873a18e2213a506d4cf6357e5faef0990ec08683/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/873a18e2213a506d4cf6357e5faef0990ec08683/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs?ref=873a18e2213a506d4cf6357e5faef0990ec08683", "patch": "@@ -2,7 +2,10 @@ use crate::iter::adapters::{\n     zip::try_get_unchecked, TrustedRandomAccess, TrustedRandomAccessNoCoerce,\n };\n use crate::iter::{FusedIterator, TrustedLen};\n+use crate::mem::MaybeUninit;\n+use crate::mem::SizedTypeProperties;\n use crate::ops::Try;\n+use crate::{array, ptr};\n \n /// An iterator that copies the elements of an underlying iterator.\n ///\n@@ -44,6 +47,15 @@ where\n         self.it.next().copied()\n     }\n \n+    fn next_chunk<const N: usize>(\n+        &mut self,\n+    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>>\n+    where\n+        Self: Sized,\n+    {\n+        <I as SpecNextChunk<'_, N, T>>::spec_next_chunk(&mut self.it)\n+    }\n+\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.it.size_hint()\n     }\n@@ -166,3 +178,65 @@ where\n     T: Copy,\n {\n }\n+\n+trait SpecNextChunk<'a, const N: usize, T: 'a>: Iterator<Item = &'a T>\n+where\n+    T: Copy,\n+{\n+    fn spec_next_chunk(&mut self) -> Result<[T; N], array::IntoIter<T, N>>;\n+}\n+\n+impl<'a, const N: usize, I, T: 'a> SpecNextChunk<'a, N, T> for I\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    default fn spec_next_chunk(&mut self) -> Result<[T; N], array::IntoIter<T, N>> {\n+        array::iter_next_chunk(&mut self.map(|e| *e))\n+    }\n+}\n+\n+impl<'a, const N: usize, T: 'a> SpecNextChunk<'a, N, T> for crate::slice::Iter<'a, T>\n+where\n+    T: Copy,\n+{\n+    fn spec_next_chunk(&mut self) -> Result<[T; N], array::IntoIter<T, N>> {\n+        let mut raw_array = MaybeUninit::uninit_array();\n+\n+        let len = self.len();\n+\n+        if T::IS_ZST {\n+            if len < N {\n+                let _ = self.advance_by(len);\n+                // SAFETY: ZSTs can be conjured ex nihilo; only the amount has to be correct\n+                return Err(unsafe { array::IntoIter::new_unchecked(raw_array, 0..len) });\n+            }\n+\n+            let _ = self.advance_by(N);\n+            // SAFETY: ditto\n+            return Ok(unsafe { MaybeUninit::array_assume_init(raw_array) });\n+        }\n+\n+        if len < N {\n+            // SAFETY: `len` indicates that this many elements are available and we just checked that\n+            // it fits into the array.\n+            unsafe {\n+                ptr::copy_nonoverlapping(\n+                    self.as_ref().as_ptr(),\n+                    raw_array.as_mut_ptr() as *mut T,\n+                    len,\n+                );\n+                let _ = self.advance_by(len);\n+                return Err(array::IntoIter::new_unchecked(raw_array, 0..len));\n+            }\n+        }\n+\n+        // SAFETY: `len` is larger than the array size. Copy a fixed amount here to fully initialize\n+        // the array.\n+        unsafe {\n+            ptr::copy_nonoverlapping(self.as_ref().as_ptr(), raw_array.as_mut_ptr() as *mut T, N);\n+            let _ = self.advance_by(N);\n+            Ok(MaybeUninit::array_assume_init(raw_array))\n+        }\n+    }\n+}"}]}