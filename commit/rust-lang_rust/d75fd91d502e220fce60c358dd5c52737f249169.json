{"sha": "d75fd91d502e220fce60c358dd5c52737f249169", "node_id": "C_kwDOAAsO6NoAKGQ3NWZkOTFkNTAyZTIyMGZjZTYwYzM1OGRkNWM1MjczN2YyNDkxNjk", "commit": {"author": {"name": "Jean CASPAR", "email": "55629512+JeanCASPAR@users.noreply.github.com", "date": "2022-08-17T21:00:33Z"}, "committer": {"name": "Jean CASPAR", "email": "55629512+JeanCASPAR@users.noreply.github.com", "date": "2022-08-22T17:21:39Z"}, "message": "Migrate ast_lowering::ast to SessionDiagnostic", "tree": {"sha": "4310f16e52a1b1649b5d5c8cb6bf304b5ba2de28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4310f16e52a1b1649b5d5c8cb6bf304b5ba2de28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d75fd91d502e220fce60c358dd5c52737f249169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d75fd91d502e220fce60c358dd5c52737f249169", "html_url": "https://github.com/rust-lang/rust/commit/d75fd91d502e220fce60c358dd5c52737f249169", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d75fd91d502e220fce60c358dd5c52737f249169/comments", "author": {"login": "JeanCASPAR", "id": 55629512, "node_id": "MDQ6VXNlcjU1NjI5NTEy", "avatar_url": "https://avatars.githubusercontent.com/u/55629512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeanCASPAR", "html_url": "https://github.com/JeanCASPAR", "followers_url": "https://api.github.com/users/JeanCASPAR/followers", "following_url": "https://api.github.com/users/JeanCASPAR/following{/other_user}", "gists_url": "https://api.github.com/users/JeanCASPAR/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeanCASPAR/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeanCASPAR/subscriptions", "organizations_url": "https://api.github.com/users/JeanCASPAR/orgs", "repos_url": "https://api.github.com/users/JeanCASPAR/repos", "events_url": "https://api.github.com/users/JeanCASPAR/events{/privacy}", "received_events_url": "https://api.github.com/users/JeanCASPAR/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JeanCASPAR", "id": 55629512, "node_id": "MDQ6VXNlcjU1NjI5NTEy", "avatar_url": "https://avatars.githubusercontent.com/u/55629512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeanCASPAR", "html_url": "https://github.com/JeanCASPAR", "followers_url": "https://api.github.com/users/JeanCASPAR/followers", "following_url": "https://api.github.com/users/JeanCASPAR/following{/other_user}", "gists_url": "https://api.github.com/users/JeanCASPAR/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeanCASPAR/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeanCASPAR/subscriptions", "organizations_url": "https://api.github.com/users/JeanCASPAR/orgs", "repos_url": "https://api.github.com/users/JeanCASPAR/repos", "events_url": "https://api.github.com/users/JeanCASPAR/events{/privacy}", "received_events_url": "https://api.github.com/users/JeanCASPAR/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1382d307d32cd6400adf4416fabc80517b0eed2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1382d307d32cd6400adf4416fabc80517b0eed2c", "html_url": "https://github.com/rust-lang/rust/commit/1382d307d32cd6400adf4416fabc80517b0eed2c"}], "stats": {"total": 339, "additions": 239, "deletions": 100}, "files": [{"sha": "d246510e0c1ed33449e82fe59fee700d4a019df5", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 62, "deletions": 99, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/d75fd91d502e220fce60c358dd5c52737f249169/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75fd91d502e220fce60c358dd5c52737f249169/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=d75fd91d502e220fce60c358dd5c52737f249169", "patch": "@@ -1,11 +1,17 @@\n use crate::{ImplTraitContext, ImplTraitPosition, ParamMode, ResolverAstLoweringExt};\n \n+use super::errors::{\n+    AbiSpecifiedMultipleTimes, AttSyntaxOnlyX86, ClobberAbiNotSupported,\n+    InlineAsmUnsupportedTarget, InvalidAbiClobberAbi, InvalidAsmTemplateModifierConst,\n+    InvalidAsmTemplateModifierRegClass, InvalidAsmTemplateModifierRegClassSub,\n+    InvalidAsmTemplateModifierSym, InvalidRegister, InvalidRegisterClass, RegisterClassOnlyClobber,\n+    RegisterConflict,\n+};\n use super::LoweringContext;\n \n use rustc_ast::ptr::P;\n use rustc_ast::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::definitions::DefPathData;\n@@ -26,13 +32,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let asm_arch =\n             if self.tcx.sess.opts.actually_rustdoc { None } else { self.tcx.sess.asm_arch };\n         if asm_arch.is_none() && !self.tcx.sess.opts.actually_rustdoc {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                sp,\n-                E0472,\n-                \"inline assembly is unsupported on this target\"\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(InlineAsmUnsupportedTarget { span: sp });\n         }\n         if let Some(asm_arch) = asm_arch {\n             // Inline assembly is currently only stable for these architectures.\n@@ -59,10 +59,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n             && !self.tcx.sess.opts.actually_rustdoc\n         {\n-            self.tcx\n-                .sess\n-                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n-                .emit();\n+            self.tcx.sess.emit_err(AttSyntaxOnlyX86 { span: sp });\n         }\n         if asm.options.contains(InlineAsmOptions::MAY_UNWIND) && !self.tcx.features().asm_unwind {\n             feature_err(\n@@ -82,51 +79,37 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         // If the abi was already in the list, emit an error\n                         match clobber_abis.get(&abi) {\n                             Some((prev_name, prev_sp)) => {\n-                                let mut err = self.tcx.sess.struct_span_err(\n-                                    *abi_span,\n-                                    &format!(\"`{}` ABI specified multiple times\", prev_name),\n-                                );\n-                                err.span_label(*prev_sp, \"previously specified here\");\n-\n                                 // Multiple different abi names may actually be the same ABI\n                                 // If the specified ABIs are not the same name, alert the user that they resolve to the same ABI\n                                 let source_map = self.tcx.sess.source_map();\n-                                if source_map.span_to_snippet(*prev_sp)\n-                                    != source_map.span_to_snippet(*abi_span)\n-                                {\n-                                    err.note(\"these ABIs are equivalent on the current target\");\n-                                }\n+                                let equivalent = (source_map.span_to_snippet(*prev_sp)\n+                                    != source_map.span_to_snippet(*abi_span))\n+                                .then_some(());\n \n-                                err.emit();\n+                                self.tcx.sess.emit_err(AbiSpecifiedMultipleTimes {\n+                                    abi_span: *abi_span,\n+                                    prev_name: *prev_name,\n+                                    prev_span: *prev_sp,\n+                                    equivalent,\n+                                });\n                             }\n                             None => {\n-                                clobber_abis.insert(abi, (abi_name, *abi_span));\n+                                clobber_abis.insert(abi, (*abi_name, *abi_span));\n                             }\n                         }\n                     }\n                     Err(&[]) => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                *abi_span,\n-                                \"`clobber_abi` is not supported on this target\",\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(ClobberAbiNotSupported { abi_span: *abi_span });\n                     }\n                     Err(supported_abis) => {\n-                        let mut err = self\n-                            .tcx\n-                            .sess\n-                            .struct_span_err(*abi_span, \"invalid ABI for `clobber_abi`\");\n                         let mut abis = format!(\"`{}`\", supported_abis[0]);\n                         for m in &supported_abis[1..] {\n                             let _ = write!(abis, \", `{}`\", m);\n                         }\n-                        err.note(&format!(\n-                            \"the following ABIs are supported on this target: {}\",\n-                            abis\n-                        ));\n-                        err.emit();\n+                        self.tcx.sess.emit_err(InvalidAbiClobberAbi {\n+                            abi_span: *abi_span,\n+                            supported_abis: abis,\n+                        });\n                     }\n                 }\n             }\n@@ -144,8 +127,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     InlineAsmRegOrRegClass::Reg(s) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmReg::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register `{}`: {}\", s, e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n+                                sess.emit_err(InvalidRegister { op_span: *op_sp, s, e });\n                                 asm::InlineAsmReg::Err\n                             })\n                         } else {\n@@ -155,8 +137,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     InlineAsmRegOrRegClass::RegClass(s) => {\n                         asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register class `{}`: {}\", s, e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n+                                sess.emit_err(InvalidRegisterClass { op_span: *op_sp, s, e });\n                                 asm::InlineAsmRegClass::Err\n                             })\n                         } else {\n@@ -282,50 +263,39 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                         let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n                         if !valid_modifiers.contains(&modifier) {\n-                            let mut err = sess.struct_span_err(\n-                                placeholder_span,\n-                                \"invalid asm template modifier for this register class\",\n-                            );\n-                            err.span_label(placeholder_span, \"template modifier\");\n-                            err.span_label(op_sp, \"argument\");\n-                            if !valid_modifiers.is_empty() {\n+                            let sub = if !valid_modifiers.is_empty() {\n                                 let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n                                 for m in &valid_modifiers[1..] {\n                                     let _ = write!(mods, \", `{}`\", m);\n                                 }\n-                                err.note(&format!(\n-                                    \"the `{}` register class supports \\\n-                                     the following template modifiers: {}\",\n-                                    class.name(),\n-                                    mods\n-                                ));\n+                                InvalidAsmTemplateModifierRegClassSub::SupportModifier {\n+                                    class_name: class.name(),\n+                                    modifiers: mods,\n+                                }\n                             } else {\n-                                err.note(&format!(\n-                                    \"the `{}` register class does not support template modifiers\",\n-                                    class.name()\n-                                ));\n-                            }\n-                            err.emit();\n+                                InvalidAsmTemplateModifierRegClassSub::DoesNotSupportModifier {\n+                                    class_name: class.name(),\n+                                }\n+                            };\n+                            sess.emit_err(InvalidAsmTemplateModifierRegClass {\n+                                placeholder_span,\n+                                op_span: op_sp,\n+                                sub,\n+                            });\n                         }\n                     }\n                     hir::InlineAsmOperand::Const { .. } => {\n-                        let mut err = sess.struct_span_err(\n+                        sess.emit_err(InvalidAsmTemplateModifierConst {\n                             placeholder_span,\n-                            \"asm template modifiers are not allowed for `const` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n+                            op_span: op_sp,\n+                        });\n                     }\n                     hir::InlineAsmOperand::SymFn { .. }\n                     | hir::InlineAsmOperand::SymStatic { .. } => {\n-                        let mut err = sess.struct_span_err(\n+                        sess.emit_err(InvalidAsmTemplateModifierSym {\n                             placeholder_span,\n-                            \"asm template modifiers are not allowed for `sym` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n+                            op_span: op_sp,\n+                        });\n                     }\n                 }\n             }\n@@ -346,12 +316,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // require that the operand name an explicit register, not a\n                 // register class.\n                 if reg_class.is_clobber_only(asm_arch.unwrap()) && !op.is_clobber() {\n-                    let msg = format!(\n-                        \"register class `{}` can only be used as a clobber, \\\n-                             not as an input or output\",\n-                        reg_class.name()\n-                    );\n-                    sess.struct_span_err(op_sp, &msg).emit();\n+                    sess.emit_err(RegisterClassOnlyClobber {\n+                        op_span: op_sp,\n+                        reg_class_name: reg_class.name(),\n+                    });\n                     continue;\n                 }\n \n@@ -391,16 +359,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                         unreachable!();\n                                     };\n \n-                                    let msg = format!(\n-                                        \"register `{}` conflicts with register `{}`\",\n-                                        reg.name(),\n-                                        reg2.name()\n-                                    );\n-                                    let mut err = sess.struct_span_err(op_sp, &msg);\n-                                    err.span_label(op_sp, &format!(\"register `{}`\", reg.name()));\n-                                    err.span_label(op_sp2, &format!(\"register `{}`\", reg2.name()));\n-\n-                                    match (op, op2) {\n+                                    let in_out = match (op, op2) {\n                                         (\n                                             hir::InlineAsmOperand::In { .. },\n                                             hir::InlineAsmOperand::Out { late, .. },\n@@ -411,14 +370,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                         ) => {\n                                             assert!(!*late);\n                                             let out_op_sp = if input { op_sp2 } else { op_sp };\n-                                            let msg = \"use `lateout` instead of \\\n-                                                       `out` to avoid conflict\";\n-                                            err.span_help(out_op_sp, msg);\n-                                        }\n-                                        _ => {}\n-                                    }\n+                                            Some(out_op_sp)\n+                                        },\n+                                        _ => None,\n+                                    };\n \n-                                    err.emit();\n+                                    sess.emit_err(RegisterConflict {\n+                                        op_span1: op_sp,\n+                                        op_span2: op_sp2,\n+                                        reg1_name: reg.name(),\n+                                        reg2_name: reg2.name(),\n+                                        in_out\n+                                    });\n                                 }\n                                 Entry::Vacant(v) => {\n                                     if r == reg {"}, {"sha": "24115237bd972d41d0716ecb8e0316e050996ec8", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 123, "deletions": 1, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/d75fd91d502e220fce60c358dd5c52737f249169/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d75fd91d502e220fce60c358dd5c52737f249169/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=d75fd91d502e220fce60c358dd5c52737f249169", "patch": "@@ -1,5 +1,5 @@\n use rustc_errors::{fluent, AddSubdiagnostic, Applicability, Diagnostic};\n-use rustc_macros::SessionDiagnostic;\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n use rustc_span::{Span, Symbol};\n \n #[derive(SessionDiagnostic, Clone, Copy)]\n@@ -148,3 +148,125 @@ pub struct AsyncGeneratorsNotSupported {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[error(ast_lowering::inline_asm_unsupported_target, code = \"E0472\")]\n+pub struct InlineAsmUnsupportedTarget {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[error(ast_lowering::att_syntax_only_x86)]\n+pub struct AttSyntaxOnlyX86 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[error(ast_lowering::abi_specified_multiple_times)]\n+pub struct AbiSpecifiedMultipleTimes {\n+    #[primary_span]\n+    pub abi_span: Span,\n+    pub prev_name: Symbol,\n+    #[label]\n+    pub prev_span: Span,\n+    #[note]\n+    pub equivalent: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[error(ast_lowering::clobber_abi_not_supported)]\n+pub struct ClobberAbiNotSupported {\n+    #[primary_span]\n+    pub abi_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[note]\n+#[error(ast_lowering::invalid_abi_clobber_abi)]\n+pub struct InvalidAbiClobberAbi {\n+    #[primary_span]\n+    pub abi_span: Span,\n+    pub supported_abis: String,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[error(ast_lowering::invalid_register)]\n+pub struct InvalidRegister<'a> {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub s: Symbol,\n+    pub e: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[error(ast_lowering::invalid_register_class)]\n+pub struct InvalidRegisterClass<'a> {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub s: Symbol,\n+    pub e: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(ast_lowering::invalid_asm_template_modifier_reg_class)]\n+pub struct InvalidAsmTemplateModifierRegClass {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+    #[subdiagnostic]\n+    pub sub: InvalidAsmTemplateModifierRegClassSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum InvalidAsmTemplateModifierRegClassSub {\n+    #[note(ast_lowering::support_modifiers)]\n+    SupportModifier { class_name: Symbol, modifiers: String },\n+    #[note(ast_lowering::does_not_support_modifiers)]\n+    DoesNotSupportModifier { class_name: Symbol },\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[error(ast_lowering::invalid_asm_template_modifier_const)]\n+pub struct InvalidAsmTemplateModifierConst {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[error(ast_lowering::invalid_asm_template_modifier_sym)]\n+pub struct InvalidAsmTemplateModifierSym {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[error(ast_lowering::register_class_only_clobber)]\n+pub struct RegisterClassOnlyClobber {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg_class_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[error(ast_lowering::register_conflict)]\n+pub struct RegisterConflict<'a> {\n+    #[primary_span]\n+    #[label(ast_lowering::register1)]\n+    pub op_span1: Span,\n+    #[label(ast_lowering::register2)]\n+    pub op_span2: Span,\n+    pub reg1_name: &'a str,\n+    pub reg2_name: &'a str,\n+    #[help]\n+    pub in_out: Option<Span>,\n+}"}, {"sha": "592e303b53fdd1c4c2d62122c9daeb4acbb4b430", "filename": "compiler/rustc_error_messages/locales/en-US/ast_lowering.ftl", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d75fd91d502e220fce60c358dd5c52737f249169/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d75fd91d502e220fce60c358dd5c52737f249169/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl?ref=d75fd91d502e220fce60c358dd5c52737f249169", "patch": "@@ -49,3 +49,57 @@ ast_lowering_functional_record_update_destructuring_assignment =\n \n ast_lowering_async_generators_not_supported =\n     `async` generators are not yet supported\n+\n+ast_lowering_inline_asm_unsupported_target =\n+    inline assembly is unsupported on this target\n+\n+ast_lowering_att_syntax_only_x86 =\n+    the `att_syntax` option is only supported on x86\n+\n+ast_lowering_abi_specified_multiple_times =\n+    `{$prev_name}` ABI specified multiple times\n+    .label = previously specified here\n+    .note = these ABIs are equivalent on the current target\n+\n+ast_lowering_clobber_abi_not_supported =\n+    `clobber_abi` is not supported on this target\n+\n+ast_lowering_invalid_abi_clobber_abi =\n+    invalid ABI for `clobber_abi`\n+    .note = the following ABIs are supported on this target: {$supported_abis}\n+\n+ast_lowering_invalid_register =\n+    invalid register `{$s}`: {$e}\n+\n+ast_lowering_invalid_register_class =\n+    invalid register class `{$s}`: {$e}\n+\n+ast_lowering_invalid_asm_template_modifier_reg_class =\n+    invalid asm template modifier for this register class\n+\n+ast_lowering_argument = argument\n+\n+ast_lowering_template_modifier = template modifier\n+\n+ast_lowering_support_modifiers =\n+    the `{$class_name}` register class supports the following template modifiers: {$modifiers}\n+\n+ast_lowering_does_not_support_modifiers =\n+    the `{$class_name}` register class does not support template modifiers\n+\n+ast_lowering_invalid_asm_template_modifier_const =\n+    asm template modifiers are not allowed for `const` arguments\n+\n+ast_lowering_invalid_asm_template_modifier_sym =\n+    asm template modifiers are not allowed for `sym` arguments\n+\n+ast_lowering_register_class_only_clobber =\n+    register class `{$reg_class_name}` can only be used as a clobber, not as an input or output\n+\n+ast_lowering_register_conflict =\n+    register `{$reg1_name}` conflicts with register `{$reg2_name}`\n+    .help = use `lateout` instead of `out` to avoid conflict\n+\n+ast_lowering_register1 = register `{$reg1_name}`\n+\n+ast_lowering_register2 = register `{$reg2_name}`"}]}