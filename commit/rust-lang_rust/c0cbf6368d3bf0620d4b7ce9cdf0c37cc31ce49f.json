{"sha": "c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwY2JmNjM2OGQzYmYwNjIwZDRiN2NlOWNkZjBjMzdjYzMxY2U0OWY=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-11-02T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-11-02T00:00:00Z"}, "message": "inliner: Remove redundant loop\n\nNo functional changes intended.", "tree": {"sha": "4a1991eb3152d8226ecd77825c6f25342fb1b0ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a1991eb3152d8226ecd77825c6f25342fb1b0ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f", "html_url": "https://github.com/rust-lang/rust/commit/c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "234099d1d12bef9d6e81a296222fbc272dc51d89", "url": "https://api.github.com/repos/rust-lang/rust/commits/234099d1d12bef9d6e81a296222fbc272dc51d89", "html_url": "https://github.com/rust-lang/rust/commit/234099d1d12bef9d6e81a296222fbc272dc51d89"}], "stats": {"total": 137, "additions": 60, "deletions": 77}, "files": [{"sha": "010a7470ccd38d29166260b7e9814d693ba5e3a2", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 60, "deletions": 77, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f", "patch": "@@ -93,96 +93,79 @@ impl Inliner<'tcx> {\n             return;\n         }\n \n-        let mut local_change;\n         let mut changed = false;\n+        while let Some(callsite) = callsites.pop_front() {\n+            debug!(\"checking whether to inline callsite {:?}\", callsite);\n \n-        loop {\n-            local_change = false;\n-            while let Some(callsite) = callsites.pop_front() {\n-                debug!(\"checking whether to inline callsite {:?}\", callsite);\n-\n-                if let InstanceDef::Item(_) = callsite.callee.def {\n-                    if !self.tcx.is_mir_available(callsite.callee.def_id()) {\n-                        debug!(\n-                            \"checking whether to inline callsite {:?} - MIR unavailable\",\n-                            callsite,\n-                        );\n-                        continue;\n-                    }\n+            if let InstanceDef::Item(_) = callsite.callee.def {\n+                if !self.tcx.is_mir_available(callsite.callee.def_id()) {\n+                    debug!(\"checking whether to inline callsite {:?} - MIR unavailable\", callsite,);\n+                    continue;\n                 }\n+            }\n \n-                let callee_body = if let Some(callee_def_id) = callsite.callee.def_id().as_local() {\n-                    let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n-                    // Avoid a cycle here by only using `instance_mir` only if we have\n-                    // a lower `HirId` than the callee. This ensures that the callee will\n-                    // not inline us. This trick only works without incremental compilation.\n-                    // So don't do it if that is enabled. Also avoid inlining into generators,\n-                    // since their `optimized_mir` is used for layout computation, which can\n-                    // create a cycle, even when no attempt is made to inline the function\n-                    // in the other direction.\n-                    if !self.tcx.dep_graph.is_fully_enabled()\n-                        && self_hir_id < callee_hir_id\n-                        && caller_body.generator_kind.is_none()\n-                    {\n-                        self.tcx.instance_mir(callsite.callee.def)\n-                    } else {\n-                        continue;\n-                    }\n-                } else {\n-                    // This cannot result in a cycle since the callee MIR is from another crate\n-                    // and is already optimized.\n+            let callee_body = if let Some(callee_def_id) = callsite.callee.def_id().as_local() {\n+                let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n+                // Avoid a cycle here by only using `instance_mir` only if we have\n+                // a lower `HirId` than the callee. This ensures that the callee will\n+                // not inline us. This trick only works without incremental compilation.\n+                // So don't do it if that is enabled. Also avoid inlining into generators,\n+                // since their `optimized_mir` is used for layout computation, which can\n+                // create a cycle, even when no attempt is made to inline the function\n+                // in the other direction.\n+                if !self.tcx.dep_graph.is_fully_enabled()\n+                    && self_hir_id < callee_hir_id\n+                    && caller_body.generator_kind.is_none()\n+                {\n                     self.tcx.instance_mir(callsite.callee.def)\n-                };\n-\n-                let callee_body: &Body<'tcx> = &*callee_body;\n-\n-                let callee_body = if self.consider_optimizing(callsite, callee_body) {\n-                    self.tcx.subst_and_normalize_erasing_regions(\n-                        &callsite.callee.substs,\n-                        self.param_env,\n-                        callee_body,\n-                    )\n                 } else {\n                     continue;\n-                };\n+                }\n+            } else {\n+                // This cannot result in a cycle since the callee MIR is from another crate\n+                // and is already optimized.\n+                self.tcx.instance_mir(callsite.callee.def)\n+            };\n \n-                // Copy only unevaluated constants from the callee_body into the caller_body.\n-                // Although we are only pushing `ConstKind::Unevaluated` consts to\n-                // `required_consts`, here we may not only have `ConstKind::Unevaluated`\n-                // because we are calling `subst_and_normalize_erasing_regions`.\n-                caller_body.required_consts.extend(\n-                    callee_body.required_consts.iter().copied().filter(|&constant| {\n-                        matches!(constant.literal.val, ConstKind::Unevaluated(_, _, _))\n-                    }),\n-                );\n+            let callee_body: &Body<'tcx> = &*callee_body;\n \n-                let start = caller_body.basic_blocks().len();\n-                debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n-                if !self.inline_call(callsite, caller_body, callee_body) {\n-                    debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n-                    continue;\n-                }\n-                debug!(\"attempting to inline callsite {:?} - success\", callsite);\n-\n-                // Add callsites from inlined function\n-                for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n-                    if let Some(new_callsite) =\n-                        self.get_valid_function_call(bb, bb_data, caller_body)\n-                    {\n-                        // Don't inline the same function multiple times.\n-                        if callsite.callee != new_callsite.callee {\n-                            callsites.push_back(new_callsite);\n-                        }\n+            let callee_body = if self.consider_optimizing(callsite, callee_body) {\n+                self.tcx.subst_and_normalize_erasing_regions(\n+                    &callsite.callee.substs,\n+                    self.param_env,\n+                    callee_body,\n+                )\n+            } else {\n+                continue;\n+            };\n+\n+            // Copy only unevaluated constants from the callee_body into the caller_body.\n+            // Although we are only pushing `ConstKind::Unevaluated` consts to\n+            // `required_consts`, here we may not only have `ConstKind::Unevaluated`\n+            // because we are calling `subst_and_normalize_erasing_regions`.\n+            caller_body.required_consts.extend(callee_body.required_consts.iter().copied().filter(\n+                |&constant| matches!(constant.literal.val, ConstKind::Unevaluated(_, _, _)),\n+            ));\n+\n+            let start = caller_body.basic_blocks().len();\n+            debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n+            if !self.inline_call(callsite, caller_body, callee_body) {\n+                debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n+                continue;\n+            }\n+            debug!(\"attempting to inline callsite {:?} - success\", callsite);\n+\n+            // Add callsites from inlined function\n+            for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n+                if let Some(new_callsite) = self.get_valid_function_call(bb, bb_data, caller_body) {\n+                    // Don't inline the same function multiple times.\n+                    if callsite.callee != new_callsite.callee {\n+                        callsites.push_back(new_callsite);\n                     }\n                 }\n-\n-                local_change = true;\n-                changed = true;\n             }\n \n-            if !local_change {\n-                break;\n-            }\n+            changed = true;\n         }\n \n         // Simplify if we inlined anything."}]}