{"sha": "52795049e72e7064037f4bc59e8faec9a9ade917", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNzk1MDQ5ZTcyZTcwNjQwMzdmNGJjNTllOGZhZWM5YTlhZGU5MTc=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-05-27T22:37:19Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-05-27T22:37:19Z"}, "message": "Generating names for wrappers, removed extra logging", "tree": {"sha": "879e397d9570bf16e5118cf80e884a4a83c969fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/879e397d9570bf16e5118cf80e884a4a83c969fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52795049e72e7064037f4bc59e8faec9a9ade917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52795049e72e7064037f4bc59e8faec9a9ade917", "html_url": "https://github.com/rust-lang/rust/commit/52795049e72e7064037f4bc59e8faec9a9ade917", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52795049e72e7064037f4bc59e8faec9a9ade917/comments", "author": null, "committer": null, "parents": [{"sha": "8cfc388d40673b21282dcdf656cbff3ac8166eca", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cfc388d40673b21282dcdf656cbff3ac8166eca", "html_url": "https://github.com/rust-lang/rust/commit/8cfc388d40673b21282dcdf656cbff3ac8166eca"}], "stats": {"total": 40, "additions": 5, "deletions": 35}, "files": [{"sha": "5cb1487925373fe6bf882d6344c22af76db237df", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 5, "deletions": 35, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/52795049e72e7064037f4bc59e8faec9a9ade917/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52795049e72e7064037f4bc59e8faec9a9ade917/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=52795049e72e7064037f4bc59e8faec9a9ade917", "patch": "@@ -5925,7 +5925,7 @@ fn trans_spawn(&@block_ctxt cx,\n                                           T_int());\n \n     // Generate the wrapper function\n-    auto wrapper = mk_spawn_wrapper(bcx, tname, func, args_ty);\n+    auto wrapper = mk_spawn_wrapper(bcx, func, args_ty);\n     bcx = wrapper.bcx;\n     auto llfnptr_i = bcx.build.PointerCast(wrapper.val, T_int());\n     // TODO: this next line might be necessary...\n@@ -5944,7 +5944,6 @@ fn trans_spawn(&@block_ctxt cx,\n }\n \n fn mk_spawn_wrapper(&@block_ctxt cx, \n-                    &str tname, \n                     &@ast::expr func, \n                     &ty::t args_ty) -> result {\n     auto llmod = cx.fcx.lcx.ccx.llmod;\n@@ -5956,30 +5955,20 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n                    ty::idx_nil,\n                    0u);\n \n-    log_err #fmt(\"wrapper args type: %s\",\n-                 ty_str(cx.fcx.lcx.ccx.tn, args_ty_tref));\n-    log_err #fmt(\"wrapper fn desired type: %s\",\n-                 ty_str(cx.fcx.lcx.ccx.tn, wrapper_fn_type));\n-\n     // TODO: construct a name based on tname\n-    auto llfndecl = decl_fastcall_fn(llmod, \"spawn_wrap\",\n+    let str wrap_name = mangle_name_by_seq(cx.fcx.lcx.ccx,\n+                                           [\"\"],\n+                                           \"spawn_wrapper\");\n+    auto llfndecl = decl_fastcall_fn(llmod, wrap_name,\n                                      wrapper_fn_type);\n \n-    log_err #fmt(\"spawn wrapper decl type: %s\", \n-                 val_str(cx.fcx.lcx.ccx.tn, llfndecl));\n-\n     auto fcx = new_fn_ctxt(cx.fcx.lcx, cx.sp, llfndecl);\n \n     auto fbcx = new_top_block_ctxt(fcx);\n \n-    log_err #fmt(\"spawn wrapper type: %s\", val_str(fcx.lcx.ccx.tn, \n-                                                  fcx.llfn));\n-\n     // 3u to skip the three implicit args\n     let ValueRef arg = llvm::LLVMGetParam(fcx.llfn, 3u);\n \n-    log_err #fmt(\"arg type: %s\", val_str(fbcx.fcx.lcx.ccx.tn, arg));\n-\n     let vec[ValueRef] child_args = \n         [llvm::LLVMGetParam(fcx.llfn, 0u),\n          llvm::LLVMGetParam(fcx.llfn, 1u),\n@@ -5990,14 +5979,9 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n         case(ty::ty_tup(?elements)) {\n             auto i = 0;\n             for(ty::mt m in elements) {\n-                log_err #fmt(\"GEP arg %d\", i);\n                 auto src = fbcx.build.GEP(arg, [C_int(0), C_int(i)]);\n                 i += 1;\n \n-                log_err #fmt(\"generating load of type %s\",\n-                             val_str(fbcx.fcx.lcx.ccx.tn,\n-                                     src));\n-\n                 auto child_arg = fbcx.build.Load(src);\n \n                 child_args += [child_arg];\n@@ -6009,24 +5993,10 @@ fn mk_spawn_wrapper(&@block_ctxt cx,\n     auto fnptr = trans_lval(fbcx, func).res;\n     fbcx = fnptr.bcx;\n     \n-    log_err \"SPAWN 1\";\n     auto llfnptr = fbcx.build.GEP(fnptr.val,\n                                   [C_int(0), C_int(0)]);\n     auto llfn = fbcx.build.Load(llfnptr);\n     \n-    log_err #fmt(\"Generating call to child function: %s\",\n-                 val_str(fbcx.fcx.lcx.ccx.tn,\n-                         llfn));\n-\n-    auto i = 0;\n-    for(ValueRef v in child_args) {\n-        log_err #fmt(\"Arg %d: %s\",\n-                     i,\n-                     val_str(fbcx.fcx.lcx.ccx.tn,\n-                             v));\n-        i += 1;\n-    }\n-\n     fbcx.build.FastCall(llfn,\n                         child_args);\n     fbcx.build.RetVoid();"}]}