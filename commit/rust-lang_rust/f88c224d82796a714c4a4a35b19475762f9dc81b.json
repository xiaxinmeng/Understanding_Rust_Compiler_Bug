{"sha": "f88c224d82796a714c4a4a35b19475762f9dc81b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OGMyMjRkODI3OTZhNzE0YzRhNGEzNWIxOTQ3NTc2MmY5ZGM4MWI=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-09-09T05:36:30Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-09-09T05:36:30Z"}, "message": "Merge branch 'master' into fix-4514", "tree": {"sha": "60ec1e9874a228dc70c6867b3e45348115db8ded", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60ec1e9874a228dc70c6867b3e45348115db8ded"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f88c224d82796a714c4a4a35b19475762f9dc81b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f88c224d82796a714c4a4a35b19475762f9dc81b", "html_url": "https://github.com/rust-lang/rust/commit/f88c224d82796a714c4a4a35b19475762f9dc81b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f88c224d82796a714c4a4a35b19475762f9dc81b/comments", "author": null, "committer": null, "parents": [{"sha": "9bdfd0683f7e36651cf11da1d63e8d7e326ff117", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bdfd0683f7e36651cf11da1d63e8d7e326ff117", "html_url": "https://github.com/rust-lang/rust/commit/9bdfd0683f7e36651cf11da1d63e8d7e326ff117"}, {"sha": "d4a48edbebd088ac9ca9c4cb51bbc5a5d745b9ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a48edbebd088ac9ca9c4cb51bbc5a5d745b9ca", "html_url": "https://github.com/rust-lang/rust/commit/d4a48edbebd088ac9ca9c4cb51bbc5a5d745b9ca"}], "stats": {"total": 320, "additions": 78, "deletions": 242}, "files": [{"sha": "3e7f3c980fc8ae9aec94d145a2de5acaa2ec7cd7", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 25, "deletions": 131, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/f88c224d82796a714c4a4a35b19475762f9dc81b/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88c224d82796a714c4a4a35b19475762f9dc81b/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=f88c224d82796a714c4a4a35b19475762f9dc81b", "patch": "@@ -1,15 +1,13 @@\n //! calculate cognitive complexity and warn about overly complex functions\n \n-use rustc::cfg::CFG;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n-use rustc::ty;\n use rustc::{declare_tool_lint, impl_lint_pass};\n use syntax::ast::Attribute;\n use syntax::source_map::Span;\n \n-use crate::utils::{is_allowed, match_type, paths, span_help_and_lint, LimitStack};\n+use crate::utils::{match_type, paths, span_help_and_lint, LimitStack};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for methods with high cognitive complexity.\n@@ -46,30 +44,11 @@ impl CognitiveComplexity {\n             return;\n         }\n \n-        let cfg = CFG::new(cx.tcx, body);\n         let expr = &body.value;\n-        let n = cfg.graph.len_nodes() as u64;\n-        let e = cfg.graph.len_edges() as u64;\n-        if e + 2 < n {\n-            // the function has unreachable code, other lints should catch this\n-            return;\n-        }\n-        let cc = e + 2 - n;\n-        let mut helper = CCHelper {\n-            match_arms: 0,\n-            divergence: 0,\n-            short_circuits: 0,\n-            returns: 0,\n-            cx,\n-        };\n+\n+        let mut helper = CCHelper { cc: 1, returns: 0 };\n         helper.visit_expr(expr);\n-        let CCHelper {\n-            match_arms,\n-            divergence,\n-            short_circuits,\n-            returns,\n-            ..\n-        } = helper;\n+        let CCHelper { cc, returns } = helper;\n         let ret_ty = cx.tables.node_type(expr.hir_id);\n         let ret_adjust = if match_type(cx, ret_ty, &paths::RESULT) {\n             returns\n@@ -78,36 +57,23 @@ impl CognitiveComplexity {\n             (returns / 2)\n         };\n \n-        if cc + divergence < match_arms + short_circuits {\n-            report_cc_bug(\n+        let mut rust_cc = cc;\n+        // prevent degenerate cases where unreachable code contains `return` statements\n+        if rust_cc >= ret_adjust {\n+            rust_cc -= ret_adjust;\n+        }\n+        if rust_cc > self.limit.limit() {\n+            span_help_and_lint(\n                 cx,\n-                cc,\n-                match_arms,\n-                divergence,\n-                short_circuits,\n-                ret_adjust,\n+                COGNITIVE_COMPLEXITY,\n                 span,\n-                body.id().hir_id,\n+                &format!(\n+                    \"the function has a cognitive complexity of ({}/{})\",\n+                    rust_cc,\n+                    self.limit.limit()\n+                ),\n+                \"you could split it up into multiple smaller functions\",\n             );\n-        } else {\n-            let mut rust_cc = cc + divergence - match_arms - short_circuits;\n-            // prevent degenerate cases where unreachable code contains `return` statements\n-            if rust_cc >= ret_adjust {\n-                rust_cc -= ret_adjust;\n-            }\n-            if rust_cc > self.limit.limit() {\n-                span_help_and_lint(\n-                    cx,\n-                    COGNITIVE_COMPLEXITY,\n-                    span,\n-                    &format!(\n-                        \"the function has a cognitive complexity of ({}/{})\",\n-                        rust_cc,\n-                        self.limit.limit()\n-                    ),\n-                    \"you could split it up into multiple smaller functions\",\n-                );\n-            }\n         }\n     }\n }\n@@ -136,99 +102,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CognitiveComplexity {\n     }\n }\n \n-struct CCHelper<'a, 'tcx> {\n-    match_arms: u64,\n-    divergence: u64,\n+struct CCHelper {\n+    cc: u64,\n     returns: u64,\n-    short_circuits: u64, // && and ||\n-    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for CCHelper {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n+        walk_expr(self, e);\n         match e.node {\n             ExprKind::Match(_, ref arms, _) => {\n-                walk_expr(self, e);\n                 let arms_n: u64 = arms.iter().map(|arm| arm.pats.len() as u64).sum();\n                 if arms_n > 1 {\n-                    self.match_arms += arms_n - 2;\n-                }\n-            },\n-            ExprKind::Call(ref callee, _) => {\n-                walk_expr(self, e);\n-                let ty = self.cx.tables.node_type(callee.hir_id);\n-                match ty.sty {\n-                    ty::FnDef(..) | ty::FnPtr(_) => {\n-                        let sig = ty.fn_sig(self.cx.tcx);\n-                        if sig.skip_binder().output().sty == ty::Never {\n-                            self.divergence += 1;\n-                        }\n-                    },\n-                    _ => (),\n-                }\n-            },\n-            ExprKind::Closure(.., _) => (),\n-            ExprKind::Binary(op, _, _) => {\n-                walk_expr(self, e);\n-                match op.node {\n-                    BinOpKind::And | BinOpKind::Or => self.short_circuits += 1,\n-                    _ => (),\n+                    self.cc += 1;\n                 }\n+                self.cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;\n             },\n             ExprKind::Ret(_) => self.returns += 1,\n-            _ => walk_expr(self, e),\n+            _ => {},\n         }\n     }\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n }\n-\n-#[cfg(feature = \"debugging\")]\n-#[allow(clippy::too_many_arguments)]\n-fn report_cc_bug(\n-    _: &LateContext<'_, '_>,\n-    cc: u64,\n-    narms: u64,\n-    div: u64,\n-    shorts: u64,\n-    returns: u64,\n-    span: Span,\n-    _: HirId,\n-) {\n-    span_bug!(\n-        span,\n-        \"Clippy encountered a bug calculating cognitive complexity: cc = {}, arms = {}, \\\n-         div = {}, shorts = {}, returns = {}. Please file a bug report.\",\n-        cc,\n-        narms,\n-        div,\n-        shorts,\n-        returns\n-    );\n-}\n-#[cfg(not(feature = \"debugging\"))]\n-#[allow(clippy::too_many_arguments)]\n-fn report_cc_bug(\n-    cx: &LateContext<'_, '_>,\n-    cc: u64,\n-    narms: u64,\n-    div: u64,\n-    shorts: u64,\n-    returns: u64,\n-    span: Span,\n-    id: HirId,\n-) {\n-    if !is_allowed(cx, COGNITIVE_COMPLEXITY, id) {\n-        cx.sess().span_note_without_error(\n-            span,\n-            &format!(\n-                \"Clippy encountered a bug calculating cognitive complexity \\\n-                 (hide this message with `#[allow(cognitive_complexity)]`): \\\n-                 cc = {}, arms = {}, div = {}, shorts = {}, returns = {}. \\\n-                 Please file a bug report.\",\n-                cc, narms, div, shorts, returns\n-            ),\n-        );\n-    }\n-}"}, {"sha": "88bf52b1e8db692857d778f033b77632aff03780", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f88c224d82796a714c4a4a35b19475762f9dc81b/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88c224d82796a714c4a4a35b19475762f9dc81b/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=f88c224d82796a714c4a4a35b19475762f9dc81b", "patch": "@@ -136,6 +136,9 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                     }\n                 }\n             },\n+            // just go through the first pattern, as either all patterns\n+            // bind the same bindings or rustc would have errored much earlier\n+            PatKind::Or(ref pats) => self.visit_pat(&pats[0]),\n             _ => walk_pat(self, pat),\n         }\n     }\n@@ -325,8 +328,6 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n         self.single_char_names.push(vec![]);\n \n         self.apply(|this| {\n-            // just go through the first pattern, as either all patterns\n-            // bind the same bindings or rustc would have errored much earlier\n             SimilarNamesNameVisitor(this).visit_pat(&arm.pat);\n             this.apply(|this| walk_expr(this, &arm.body));\n         });"}, {"sha": "0f7857a45d1454b44807a4d62b23d0e0085ff48e", "filename": "tests/ui/cognitive_complexity.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f88c224d82796a714c4a4a35b19475762f9dc81b/tests%2Fui%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88c224d82796a714c4a4a35b19475762f9dc81b/tests%2Fui%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcognitive_complexity.rs?ref=f88c224d82796a714c4a4a35b19475762f9dc81b", "patch": "@@ -87,7 +87,7 @@ fn main() {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn kaboom() {\n     let n = 0;\n     'a: for i in 0..20 {\n@@ -133,17 +133,19 @@ fn bloo() {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+// Short circuiting operations don't increase the complexity of a function.\n+// Note that the minimum complexity of a function is 1.\n+#[clippy::cognitive_complexity = \"1\"]\n fn lots_of_short_circuits() -> bool {\n     true && false && true && false && true && false && true\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn lots_of_short_circuits2() -> bool {\n     true || false || true || false || true || false || true\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn baa() {\n     let x = || match 99 {\n         0 => 0,\n@@ -161,7 +163,7 @@ fn baa() {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn bar() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -170,7 +172,7 @@ fn bar() {\n }\n \n #[test]\n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n /// Tests are usually complex but simple at the same time. `clippy::cognitive_complexity` used to\n /// give lots of false-positives in tests.\n fn dont_warn_on_tests() {\n@@ -180,7 +182,7 @@ fn dont_warn_on_tests() {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn barr() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -190,7 +192,7 @@ fn barr() {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn barr2() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -206,7 +208,7 @@ fn barr2() {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn barrr() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -216,7 +218,7 @@ fn barrr() {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn barrr2() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -232,7 +234,7 @@ fn barrr2() {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn barrrr() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -242,7 +244,7 @@ fn barrrr() {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn barrrr2() {\n     match 99 {\n         0 => println!(\"hi\"),\n@@ -258,7 +260,7 @@ fn barrrr2() {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn cake() {\n     if 4 == 5 {\n         println!(\"yea\");\n@@ -268,7 +270,7 @@ fn cake() {\n     println!(\"whee\");\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n pub fn read_file(input_path: &str) -> String {\n     use std::fs::File;\n     use std::io::{Read, Write};\n@@ -299,28 +301,28 @@ pub fn read_file(input_path: &str) -> String {\n \n enum Void {}\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn void(void: Void) {\n     if true {\n         match void {}\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn mcarton_sees_all() {\n     panic!(\"meh\");\n     panic!(\"m\u00f6h\");\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn try_() -> Result<i32, &'static str> {\n     match 5 {\n         5 => Ok(5),\n         _ => return Err(\"bla\"),\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn try_again() -> Result<i32, &'static str> {\n     let _ = Ok(42)?;\n     let _ = Ok(43)?;\n@@ -336,7 +338,7 @@ fn try_again() -> Result<i32, &'static str> {\n     }\n }\n \n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn early() -> Result<i32, &'static str> {\n     return Ok(5);\n     return Ok(5);\n@@ -350,7 +352,7 @@ fn early() -> Result<i32, &'static str> {\n }\n \n #[rustfmt::skip]\n-#[clippy::cognitive_complexity = \"0\"]\n+#[clippy::cognitive_complexity = \"1\"]\n fn early_ret() -> i32 {\n     let a = if true { 42 } else { return 0; };\n     let a = if a < 99 { 42 } else { return 0; };"}, {"sha": "1fca4f5bd82e4bb746b511012e514477c60afbe7", "filename": "tests/ui/cognitive_complexity.stderr", "status": "modified", "additions": 28, "deletions": 89, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/f88c224d82796a714c4a4a35b19475762f9dc81b/tests%2Fui%2Fcognitive_complexity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f88c224d82796a714c4a4a35b19475762f9dc81b/tests%2Fui%2Fcognitive_complexity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcognitive_complexity.stderr?ref=f88c224d82796a714c4a4a35b19475762f9dc81b", "patch": "@@ -13,7 +13,7 @@ LL | | }\n    = note: `-D clippy::cognitive-complexity` implied by `-D warnings`\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (7/0)\n+error: the function has a cognitive complexity of (7/1)\n   --> $DIR/cognitive_complexity.rs:91:1\n    |\n LL | / fn kaboom() {\n@@ -27,28 +27,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (1/0)\n-  --> $DIR/cognitive_complexity.rs:137:1\n-   |\n-LL | / fn lots_of_short_circuits() -> bool {\n-LL | |     true && false && true && false && true && false && true\n-LL | | }\n-   | |_^\n-   |\n-   = help: you could split it up into multiple smaller functions\n-\n-error: the function has a cognitive complexity of (1/0)\n-  --> $DIR/cognitive_complexity.rs:142:1\n-   |\n-LL | / fn lots_of_short_circuits2() -> bool {\n-LL | |     true || false || true || false || true || false || true\n-LL | | }\n-   | |_^\n-   |\n-   = help: you could split it up into multiple smaller functions\n-\n-error: the function has a cognitive complexity of (2/0)\n-  --> $DIR/cognitive_complexity.rs:147:1\n+error: the function has a cognitive complexity of (2/1)\n+  --> $DIR/cognitive_complexity.rs:149:1\n    |\n LL | / fn baa() {\n LL | |     let x = || match 99 {\n@@ -61,8 +41,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (2/0)\n-  --> $DIR/cognitive_complexity.rs:148:13\n+error: the function has a cognitive complexity of (2/1)\n+  --> $DIR/cognitive_complexity.rs:150:13\n    |\n LL |       let x = || match 99 {\n    |  _____________^\n@@ -76,8 +56,8 @@ LL | |     };\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (2/0)\n-  --> $DIR/cognitive_complexity.rs:165:1\n+error: the function has a cognitive complexity of (2/1)\n+  --> $DIR/cognitive_complexity.rs:167:1\n    |\n LL | / fn bar() {\n LL | |     match 99 {\n@@ -89,8 +69,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (2/0)\n-  --> $DIR/cognitive_complexity.rs:184:1\n+error: the function has a cognitive complexity of (2/1)\n+  --> $DIR/cognitive_complexity.rs:186:1\n    |\n LL | / fn barr() {\n LL | |     match 99 {\n@@ -103,8 +83,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (3/0)\n-  --> $DIR/cognitive_complexity.rs:194:1\n+error: the function has a cognitive complexity of (3/1)\n+  --> $DIR/cognitive_complexity.rs:196:1\n    |\n LL | / fn barr2() {\n LL | |     match 99 {\n@@ -117,8 +97,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (2/0)\n-  --> $DIR/cognitive_complexity.rs:210:1\n+error: the function has a cognitive complexity of (2/1)\n+  --> $DIR/cognitive_complexity.rs:212:1\n    |\n LL | / fn barrr() {\n LL | |     match 99 {\n@@ -131,8 +111,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (3/0)\n-  --> $DIR/cognitive_complexity.rs:220:1\n+error: the function has a cognitive complexity of (3/1)\n+  --> $DIR/cognitive_complexity.rs:222:1\n    |\n LL | / fn barrr2() {\n LL | |     match 99 {\n@@ -145,8 +125,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (2/0)\n-  --> $DIR/cognitive_complexity.rs:236:1\n+error: the function has a cognitive complexity of (2/1)\n+  --> $DIR/cognitive_complexity.rs:238:1\n    |\n LL | / fn barrrr() {\n LL | |     match 99 {\n@@ -159,8 +139,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (3/0)\n-  --> $DIR/cognitive_complexity.rs:246:1\n+error: the function has a cognitive complexity of (3/1)\n+  --> $DIR/cognitive_complexity.rs:248:1\n    |\n LL | / fn barrrr2() {\n LL | |     match 99 {\n@@ -173,8 +153,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (2/0)\n-  --> $DIR/cognitive_complexity.rs:262:1\n+error: the function has a cognitive complexity of (2/1)\n+  --> $DIR/cognitive_complexity.rs:264:1\n    |\n LL | / fn cake() {\n LL | |     if 4 == 5 {\n@@ -187,8 +167,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (4/0)\n-  --> $DIR/cognitive_complexity.rs:272:1\n+error: the function has a cognitive complexity of (4/1)\n+  --> $DIR/cognitive_complexity.rs:274:1\n    |\n LL | / pub fn read_file(input_path: &str) -> String {\n LL | |     use std::fs::File;\n@@ -201,8 +181,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (1/0)\n-  --> $DIR/cognitive_complexity.rs:303:1\n+error: the function has a cognitive complexity of (2/1)\n+  --> $DIR/cognitive_complexity.rs:305:1\n    |\n LL | / fn void(void: Void) {\n LL | |     if true {\n@@ -213,49 +193,8 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: the function has a cognitive complexity of (1/0)\n-  --> $DIR/cognitive_complexity.rs:316:1\n-   |\n-LL | / fn try_() -> Result<i32, &'static str> {\n-LL | |     match 5 {\n-LL | |         5 => Ok(5),\n-LL | |         _ => return Err(\"bla\"),\n-LL | |     }\n-LL | | }\n-   | |_^\n-   |\n-   = help: you could split it up into multiple smaller functions\n-\n-error: the function has a cognitive complexity of (1/0)\n-  --> $DIR/cognitive_complexity.rs:324:1\n-   |\n-LL | / fn try_again() -> Result<i32, &'static str> {\n-LL | |     let _ = Ok(42)?;\n-LL | |     let _ = Ok(43)?;\n-LL | |     let _ = Ok(44)?;\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n-   |\n-   = help: you could split it up into multiple smaller functions\n-\n-error: the function has a cognitive complexity of (1/0)\n-  --> $DIR/cognitive_complexity.rs:340:1\n-   |\n-LL | / fn early() -> Result<i32, &'static str> {\n-LL | |     return Ok(5);\n-LL | |     return Ok(5);\n-LL | |     return Ok(5);\n-...  |\n-LL | |     return Ok(5);\n-LL | | }\n-   | |_^\n-   |\n-   = help: you could split it up into multiple smaller functions\n-\n-error: the function has a cognitive complexity of (8/0)\n-  --> $DIR/cognitive_complexity.rs:354:1\n+error: the function has a cognitive complexity of (8/1)\n+  --> $DIR/cognitive_complexity.rs:356:1\n    |\n LL | / fn early_ret() -> i32 {\n LL | |     let a = if true { 42 } else { return 0; };\n@@ -268,5 +207,5 @@ LL | | }\n    |\n    = help: you could split it up into multiple smaller functions\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 15 previous errors\n "}]}