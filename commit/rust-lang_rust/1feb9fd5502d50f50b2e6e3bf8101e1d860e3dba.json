{"sha": "1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZWI5ZmQ1NTAyZDUwZjUwYjJlNmUzYmY4MTAxZTFkODYwZTNkYmE=", "commit": {"author": {"name": "Phil Ellison", "email": "phil.j.ellison@gmail.com", "date": "2018-01-14T09:30:08Z"}, "committer": {"name": "Phil Ellison", "email": "phil.j.ellison@gmail.com", "date": "2018-01-14T09:30:08Z"}, "message": "Tidy using if_chain and snippet function. Actually check that the initial fold value is false. Remove some unwraps", "tree": {"sha": "cfc9828b0e688b5226f27233327bbd1e238b7ece", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfc9828b0e688b5226f27233327bbd1e238b7ece"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba", "html_url": "https://github.com/rust-lang/rust/commit/1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba/comments", "author": {"login": "theotherphil", "id": 1974256, "node_id": "MDQ6VXNlcjE5NzQyNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1974256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherphil", "html_url": "https://github.com/theotherphil", "followers_url": "https://api.github.com/users/theotherphil/followers", "following_url": "https://api.github.com/users/theotherphil/following{/other_user}", "gists_url": "https://api.github.com/users/theotherphil/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherphil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherphil/subscriptions", "organizations_url": "https://api.github.com/users/theotherphil/orgs", "repos_url": "https://api.github.com/users/theotherphil/repos", "events_url": "https://api.github.com/users/theotherphil/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherphil/received_events", "type": "User", "site_admin": false}, "committer": {"login": "theotherphil", "id": 1974256, "node_id": "MDQ6VXNlcjE5NzQyNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1974256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherphil", "html_url": "https://github.com/theotherphil", "followers_url": "https://api.github.com/users/theotherphil/followers", "following_url": "https://api.github.com/users/theotherphil/following{/other_user}", "gists_url": "https://api.github.com/users/theotherphil/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherphil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherphil/subscriptions", "organizations_url": "https://api.github.com/users/theotherphil/orgs", "repos_url": "https://api.github.com/users/theotherphil/repos", "events_url": "https://api.github.com/users/theotherphil/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherphil/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed", "html_url": "https://github.com/rust-lang/rust/commit/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed"}], "stats": {"total": 82, "additions": 38, "deletions": 44}, "files": [{"sha": "36e6fb4b1a29a11b6ddd242a0ff45181908dd0f5", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba", "patch": "@@ -1139,53 +1139,42 @@ fn lint_fold_any(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::Expr]) {\n     assert!(fold_args.len() == 3,\n         \"Expected fold_args to have three entries - the receiver, the initial value and the closure\");\n \n-    if let hir::ExprLit(ref lit) = fold_args[1].node {\n-        if let ast::LitKind::Bool(ref b) = lit.node {\n-            let initial_value = b.to_string();\n+    if_chain! {\n+        // Check if the initial value for the fold is the literal `false`\n+        if let hir::ExprLit(ref lit) = fold_args[1].node;\n+        if lit.node == ast::LitKind::Bool(false);\n \n-            if let hir::ExprClosure(_, ref decl, body_id, _, _) = fold_args[2].node {\n-                let closure_body = cx.tcx.hir.body(body_id);\n-                let closure_expr = remove_blocks(&closure_body.value);\n+        // Extract the body of the closure passed to fold\n+        if let hir::ExprClosure(_, _, body_id, _, _) = fold_args[2].node;\n+        let closure_body = cx.tcx.hir.body(body_id);\n+        let closure_expr = remove_blocks(&closure_body.value);\n \n-                let first_arg = &closure_body.arguments[0];\n-                let arg_ident = get_arg_name(&first_arg.pat).unwrap();\n+        // Extract the names of the two arguments to the closure\n+        if let Some(first_arg_ident) = get_arg_name(&closure_body.arguments[0].pat);\n+        if let Some(second_first_arg_ident) = get_arg_name(&closure_body.arguments[1].pat);\n \n-                let second_arg = &closure_body.arguments[1];\n-                let second_arg_ident = get_arg_name(&second_arg.pat).unwrap();\n+        // Check if the closure body is of the form `acc || some_expr(x)`\n+        if let hir::ExprBinary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node;\n+        if bin_op.node == hir::BinOp_::BiOr;\n+        if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = left_expr.node;\n+        if path.segments.len() == 1 && &path.segments[0].name == &first_arg_ident;\n \n-                if let hir::ExprBinary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node {\n-                    if bin_op.node != hir::BinOp_::BiOr {\n-                        return;\n-                    }\n-                    if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = left_expr.node {\n-                        if path.segments.len() == 1 {\n-                            let left_name =  &path.segments[0].name;\n-                            let right_source = cx.sess().codemap().span_to_snippet(right_expr.span).unwrap();\n-\n-                            if left_name == &arg_ident {\n-                                span_lint(\n-                                    cx,\n-                                    FOLD_ANY,\n-                                    expr.span,\n-                                    // TODO: don't suggest .any(|x| f(x)) if we can suggest .any(f)\n-                                    // TODO: these have difference semantics - original code might be deliberately avoiding short-circuiting\n-                                    &format!(\n-                                        \".fold(false, |{f}, {s}| {f} || {r})) is more succinctly expressed as .any(|{s}| {r})\",\n-                                        f = arg_ident,\n-                                        s = second_arg_ident,\n-                                        r = right_source\n-                                    ),\n-                                );\n-                            }\n-                        }\n-                    }\n-                }\n-            } else{\n-                panic!(\"DONOTMERGE: can this happen?\");\n-            }\n+        then {\n+            let right_source = snippet(cx, right_expr.span, \"EXPR\");\n+\n+            span_lint(\n+                cx,\n+                FOLD_ANY,\n+                expr.span,\n+                // TODO: don't suggest .any(|x| f(x)) if we can suggest .any(f)\n+                &format!(\n+                    \".fold(false, |{f}, {s}| {f} || {r})) is more succinctly expressed as .any(|{s}| {r})\",\n+                    f = first_arg_ident,\n+                    s = second_first_arg_ident,\n+                    r = right_source\n+                ),\n+            );\n         }\n-    } else {\n-        return;\n     }\n }\n "}, {"sha": "0dd4ff47fa9097fcafaf75ee68876ebbe5f8c5fa", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba", "patch": "@@ -390,6 +390,11 @@ fn fold_any() {\n     let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n }\n \n+/// Checks implementation of the `FOLD_ANY` lint\n+fn fold_any_ignore_initial_value_of_true() {\n+    let _ = (0..3).fold(true, |acc, x| acc || x > 2);\n+}\n+\n #[allow(similar_names)]\n fn main() {\n     let opt = Some(0);"}, {"sha": "ef24e4a8e22de892c807657ea97447b1b93c5d5f", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=1feb9fd5502d50f50b2e6e3bf8101e1d860e3dba", "patch": "@@ -502,9 +502,9 @@ error: .fold(false, |acc, x| acc || x > 2)) is more succinctly expressed as .any\n     = note: `-D fold-any` implied by `-D warnings`\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-   --> $DIR/methods.rs:396:13\n+   --> $DIR/methods.rs:401:13\n     |\n-396 |     let _ = opt.unwrap();\n+401 |     let _ = opt.unwrap();\n     |             ^^^^^^^^^^^^\n     |\n     = note: `-D option-unwrap-used` implied by `-D warnings`"}]}