{"sha": "2374154ded19a247be0053d71f5bcdd22b95462a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNzQxNTRkZWQxOWEyNDdiZTAwNTNkNzFmNWJjZGQyMmI5NTQ2MmE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-16T22:10:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-16T22:10:17Z"}, "message": "Stop storing char positions in CodeMap", "tree": {"sha": "88864eee16e69562befe699ebdd66af1b5b91bdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88864eee16e69562befe699ebdd66af1b5b91bdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2374154ded19a247be0053d71f5bcdd22b95462a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2374154ded19a247be0053d71f5bcdd22b95462a", "html_url": "https://github.com/rust-lang/rust/commit/2374154ded19a247be0053d71f5bcdd22b95462a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2374154ded19a247be0053d71f5bcdd22b95462a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81d20156cd44358e47e5081635f28ea31c01a757", "url": "https://api.github.com/repos/rust-lang/rust/commits/81d20156cd44358e47e5081635f28ea31c01a757", "html_url": "https://github.com/rust-lang/rust/commit/81d20156cd44358e47e5081635f28ea31c01a757"}], "stats": {"total": 95, "additions": 39, "deletions": 56}, "files": [{"sha": "5e600b489654ad82491a6719a17c21d59fdead17", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2374154ded19a247be0053d71f5bcdd22b95462a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2374154ded19a247be0053d71f5bcdd22b95462a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2374154ded19a247be0053d71f5bcdd22b95462a", "patch": "@@ -195,15 +195,15 @@ pub struct FileMap {\n     name: FileName,\n     substr: FileSubstr,\n     src: @~str,\n-    start_pos: FilePos,\n-    mut lines: ~[FilePos],\n+    start_pos: BytePos,\n+    mut lines: ~[BytePos],\n     multibyte_chars: DVec<MultiByteChar>\n }\n \n pub impl FileMap {\n     static fn new_w_substr(+filename: FileName, +substr: FileSubstr,\n                            src: @~str,\n-                           +start_pos: FilePos)\n+                           +start_pos: BytePos)\n         -> FileMap {\n         return FileMap {\n             name: filename, substr: substr, src: src,\n@@ -214,18 +214,18 @@ pub impl FileMap {\n     }\n \n     static fn new(+filename: FileName, src: @~str,\n-                  +start_pos: FilePos)\n+                  +start_pos: BytePos)\n         -> FileMap {\n         return FileMap::new_w_substr(filename, FssNone, src,\n                                      start_pos);\n     }\n \n-    fn next_line(&self, +pos: FilePos) {\n+    fn next_line(&self, +pos: BytePos) {\n         self.lines.push(pos);\n     }\n \n     pub fn get_line(&self, line: int) -> ~str unsafe {\n-        let begin: BytePos = self.lines[line].byte - self.start_pos.byte;\n+        let begin: BytePos = self.lines[line] - self.start_pos;\n         let begin = begin.to_uint();\n         let end = match str::find_char_from(*self.src, '\\n', begin) {\n             Some(e) => e,\n@@ -266,11 +266,11 @@ pub impl CodeMap {\n         let expected_byte_pos = if self.files.len() == 0 {\n             0\n         } else {\n-            let last_start = self.files.last().start_pos.byte.to_uint();\n+            let last_start = self.files.last().start_pos.to_uint();\n             let last_len = self.files.last().src.len();\n             last_start + last_len\n         };\n-        let actual_byte_pos = filemap.start_pos.byte.to_uint();\n+        let actual_byte_pos = filemap.start_pos.to_uint();\n         debug!(\"codemap: adding filemap: %s\", filemap.name);\n         debug!(\"codemap: expected offset: %u\", expected_byte_pos);\n         debug!(\"codemap: actual offset: %u\", actual_byte_pos);\n@@ -301,7 +301,7 @@ pub impl CodeMap {\n             }\n             FssInternal(sp) => {\n                 self.lookup_char_pos_adj(\n-                    sp.lo + (pos - loc.file.start_pos.byte))\n+                    sp.lo + (pos - loc.file.start_pos))\n             }\n             FssExternal(eloc) => {\n                 {filename: /* FIXME (#2543) */ copy eloc.filename,\n@@ -318,8 +318,8 @@ pub impl CodeMap {\n             FssNone => sp,\n             FssInternal(s) => {\n                 self.adjust_span(span {\n-                    lo: s.lo + (sp.lo - line.fm.start_pos.byte),\n-                    hi: s.lo + (sp.hi - line.fm.start_pos.byte),\n+                    lo: s.lo + (sp.lo - line.fm.start_pos),\n+                    hi: s.lo + (sp.hi - line.fm.start_pos),\n                     expn_info: sp.expn_info\n                 })\n             }\n@@ -374,7 +374,7 @@ priv impl CodeMap {\n         let mut b = len;\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if self.files[m].start_pos.byte > pos {\n+            if self.files[m].start_pos > pos {\n                 b = m;\n             } else {\n                 a = m;\n@@ -397,7 +397,7 @@ priv impl CodeMap {\n         let mut b = vec::len(f.lines);\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if f.lines[m].byte > pos { b = m; } else { a = m; }\n+            if f.lines[m] > pos { b = m; } else { a = m; }\n         }\n         return {fm: f, line: a};\n     }\n@@ -406,7 +406,7 @@ priv impl CodeMap {\n         let {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_local_charpos(pos);\n-        let linebpos = f.lines[a].byte;\n+        let linebpos = f.lines[a];\n         let linechpos = self.bytepos_to_local_charpos(linebpos);\n         debug!(\"codemap: byte pos %? is on the line at byte pos %?\",\n                pos, linebpos);\n@@ -432,7 +432,7 @@ priv impl CodeMap {\n         -> {fm: @FileMap, pos: BytePos} {\n         let idx = self.lookup_filemap_idx(bpos);\n         let fm = self.files[idx];\n-        let offset = bpos - fm.start_pos.byte;\n+        let offset = bpos - fm.start_pos;\n         return {fm: fm, pos: offset};\n     }\n "}, {"sha": "9c8d28680ed2393c44eda10c533d8ac8799c5c94", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2374154ded19a247be0053d71f5bcdd22b95462a/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2374154ded19a247be0053d71f5bcdd22b95462a/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=2374154ded19a247be0053d71f5bcdd22b95462a", "patch": "@@ -29,7 +29,7 @@ type parse_sess = @{\n     span_diagnostic: span_handler,\n     interner: @ident_interner,\n     // must be kept up to date\n-    mut pos: FilePos\n+    mut pos: BytePos\n };\n \n fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n@@ -38,10 +38,8 @@ fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n              mut next_id: 1,\n              span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n              interner: mk_ident_interner(),\n-             mut pos: FilePos {\n-                 ch: CharPos(0u),\n-                 byte: BytePos(0u)\n-             }};\n+             mut pos: BytePos(0)\n+            };\n }\n \n fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n@@ -50,10 +48,8 @@ fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n              mut next_id: 1,\n              span_diagnostic: sh,\n              interner: mk_ident_interner(),\n-             mut pos: FilePos {\n-                 ch: CharPos(0u),\n-                 byte: BytePos(0u)\n-             }};\n+             mut pos: BytePos(0)\n+             };\n }\n \n fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n@@ -219,8 +215,5 @@ fn new_parser_from_tt(sess: parse_sess, cfg: ast::crate_cfg,\n }\n \n fn update_parse_sess_position(sess: &parse_sess, r: &lexer::string_reader) {\n-    sess.pos = FilePos {\n-        ch: r.last_pos.ch,\n-        byte: r.last_pos.byte\n-    };\n+    sess.pos = r.last_pos\n }"}, {"sha": "e3ac3e7dcbbb4dc340633c46ce735c95d9da2b0d", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2374154ded19a247be0053d71f5bcdd22b95462a/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2374154ded19a247be0053d71f5bcdd22b95462a/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=2374154ded19a247be0053d71f5bcdd22b95462a", "patch": "@@ -131,7 +131,7 @@ fn consume_non_eol_whitespace(rdr: string_reader) {\n fn push_blank_line_comment(rdr: string_reader, comments: &mut ~[cmnt]) {\n     debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n-    comments.push({style: blank_line, lines: v, pos: rdr.last_pos.byte});\n+    comments.push({style: blank_line, lines: v, pos: rdr.last_pos});\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n@@ -148,7 +148,7 @@ fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n                                             comments: &mut ~[cmnt]) {\n     debug!(\">>> shebang comment\");\n-    let p = rdr.last_pos.byte;\n+    let p = rdr.last_pos;\n     debug!(\"<<< shebang comment\");\n     comments.push({\n         style: if code_to_the_left { trailing } else { isolated },\n@@ -160,7 +160,7 @@ fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n                                           comments: &mut ~[cmnt]) {\n     debug!(\">>> line comments\");\n-    let p = rdr.last_pos.byte;\n+    let p = rdr.last_pos;\n     let mut lines: ~[~str] = ~[];\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n@@ -209,7 +209,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n                                           comments: &mut ~[cmnt]) {\n     debug!(\">>> block comment\");\n-    let p = rdr.last_pos.byte;\n+    let p = rdr.last_pos;\n     let mut lines: ~[~str] = ~[];\n     let mut col: CharPos = rdr.col;\n     bump(rdr);\n@@ -292,11 +292,7 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n    {cmnts: ~[cmnt], lits: ~[lit]} {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = parse::token::mk_fake_ident_interner();\n-    let filemap = @FileMap::new(path, src,\n-                                FilePos {\n-                                    ch: CharPos(0u),\n-                                    byte: BytePos(0u)\n-                                });\n+    let filemap = @FileMap::new(path, src, BytePos(0));\n     let rdr = lexer::new_low_level_string_reader(\n         span_diagnostic, filemap, itr);\n \n@@ -319,7 +315,7 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         }\n \n \n-        let bstart = rdr.pos.byte;\n+        let bstart = rdr.pos;\n         rdr.next_token();\n         //discard, and look ahead; we're working with internal state\n         let {tok: tok, sp: sp} = rdr.peek();"}, {"sha": "10a74d620a3705f3826fd6ccfc60e3adb79f41fc", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2374154ded19a247be0053d71f5bcdd22b95462a/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2374154ded19a247be0053d71f5bcdd22b95462a/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=2374154ded19a247be0053d71f5bcdd22b95462a", "patch": "@@ -22,9 +22,9 @@ type string_reader = @{\n     span_diagnostic: span_handler,\n     src: @~str,\n     // The absolute offset within the codemap of the next character to read\n-    mut pos: FilePos,\n+    mut pos: BytePos,\n     // The absolute offset within the codemap of the last character read(curr)\n-    mut last_pos: FilePos,\n+    mut last_pos: BytePos,\n     // The column of the next character to read\n     mut col: CharPos,\n     // The last character to be read\n@@ -123,15 +123,15 @@ fn string_advance_token(&&r: string_reader) {\n     if is_eof(r) {\n         r.peek_tok = token::EOF;\n     } else {\n-        let start_bytepos = r.last_pos.byte;\n+        let start_bytepos = r.last_pos;\n         r.peek_tok = next_token_inner(r);\n-        r.peek_span = ast_util::mk_sp(start_bytepos, r.last_pos.byte);\n+        r.peek_span = ast_util::mk_sp(start_bytepos, r.last_pos);\n     };\n \n }\n \n fn byte_offset(rdr: string_reader) -> BytePos {\n-    (rdr.pos.byte - rdr.filemap.start_pos.byte)\n+    (rdr.pos - rdr.filemap.start_pos)\n }\n \n fn get_str_from(rdr: string_reader, start: BytePos) -> ~str unsafe {\n@@ -148,10 +148,7 @@ fn bump(rdr: string_reader) {\n         let last_char = rdr.curr;\n         let next = str::char_range_at(*rdr.src, current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n-        rdr.pos = FilePos {\n-            ch: rdr.pos.ch + CharPos(1u),\n-            byte: rdr.pos.byte + BytePos(byte_offset_diff)\n-        };\n+        rdr.pos = rdr.pos + BytePos(byte_offset_diff);\n         rdr.curr = next.ch;\n         rdr.col += CharPos(1u);\n         if last_char == '\\n' {\n@@ -166,10 +163,7 @@ fn bump(rdr: string_reader) {\n     } else {\n         // XXX: What does this accomplish?\n         if (rdr.curr != -1 as char) {\n-            rdr.pos = FilePos {\n-                ch: rdr.pos.ch + CharPos(1u),\n-                byte: rdr.pos.byte + BytePos(1u)\n-            };\n+            rdr.pos = rdr.pos + BytePos(1u);\n             rdr.col += CharPos(1u);\n             rdr.curr = -1 as char;\n         }\n@@ -238,15 +232,15 @@ fn consume_any_line_comment(rdr: string_reader)\n             bump(rdr);\n             // line comments starting with \"///\" or \"//!\" are doc-comments\n             if rdr.curr == '/' || rdr.curr == '!' {\n-                let start_bpos = rdr.pos.byte - BytePos(2u);\n+                let start_bpos = rdr.pos - BytePos(2u);\n                 let mut acc = ~\"//\";\n                 while rdr.curr != '\\n' && !is_eof(rdr) {\n                     str::push_char(&mut acc, rdr.curr);\n                     bump(rdr);\n                 }\n                 return Some({\n                     tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n-                    sp: ast_util::mk_sp(start_bpos, rdr.pos.byte)\n+                    sp: ast_util::mk_sp(start_bpos, rdr.pos)\n                 });\n             } else {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n@@ -261,7 +255,7 @@ fn consume_any_line_comment(rdr: string_reader)\n         if nextch(rdr) == '!' {\n             let cmap = @CodeMap::new();\n             (*cmap).files.push(rdr.filemap);\n-            let loc = cmap.lookup_char_pos_adj(rdr.last_pos.byte);\n+            let loc = cmap.lookup_char_pos_adj(rdr.last_pos);\n             if loc.line == 1u && loc.col == CharPos(0u) {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);\n@@ -277,7 +271,7 @@ fn consume_block_comment(rdr: string_reader)\n \n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     if rdr.curr == '*' || rdr.curr == '!' {\n-        let start_bpos = rdr.pos.byte - BytePos(2u);\n+        let start_bpos = rdr.pos - BytePos(2u);\n         let mut acc = ~\"/*\";\n         while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n             str::push_char(&mut acc, rdr.curr);\n@@ -291,7 +285,7 @@ fn consume_block_comment(rdr: string_reader)\n             bump(rdr);\n             return Some({\n                 tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n-                sp: ast_util::mk_sp(start_bpos, rdr.pos.byte)\n+                sp: ast_util::mk_sp(start_bpos, rdr.pos)\n             });\n         }\n     } else {"}]}