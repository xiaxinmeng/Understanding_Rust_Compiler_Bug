{"sha": "adc2b10399635b1529d002b4bad21037dff31290", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYzJiMTAzOTk2MzViMTUyOWQwMDJiNGJhZDIxMDM3ZGZmMzEyOTA=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-14T02:01:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-14T02:01:27Z"}, "message": "Rollup merge of #41287 - nikomatsakis:incr-comp-refactor-trans, r=eddyb\n\nMiscellneous refactorings of trans\n\nThis doesn't achieve any particular goal yet, but it's a collection of refactorings with the common goal of turning `SharedCrateContext` etc into stuff that we can use with on-demand and actually expect to hash in a stable fashion for incremental. Not there yet, clearly.\n\nr? @eddyb\ncc @michaelwoerister", "tree": {"sha": "ee82e7a7ac23b12b4ae4004c4b8e8da69b6d7bd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee82e7a7ac23b12b4ae4004c4b8e8da69b6d7bd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adc2b10399635b1529d002b4bad21037dff31290", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adc2b10399635b1529d002b4bad21037dff31290", "html_url": "https://github.com/rust-lang/rust/commit/adc2b10399635b1529d002b4bad21037dff31290", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adc2b10399635b1529d002b4bad21037dff31290/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "017e3e94d0a437e07bd7db427c2338789452337b", "url": "https://api.github.com/repos/rust-lang/rust/commits/017e3e94d0a437e07bd7db427c2338789452337b", "html_url": "https://github.com/rust-lang/rust/commit/017e3e94d0a437e07bd7db427c2338789452337b"}, {"sha": "07fb93e65ad2c371a59e8f671650c5b343ef5487", "url": "https://api.github.com/repos/rust-lang/rust/commits/07fb93e65ad2c371a59e8f671650c5b343ef5487", "html_url": "https://github.com/rust-lang/rust/commit/07fb93e65ad2c371a59e8f671650c5b343ef5487"}], "stats": {"total": 580, "additions": 233, "deletions": 347}, "files": [{"sha": "cbbfeacadb4087a2e8912bb415986d57435ec605", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -53,7 +53,6 @@ pub use self::NativeLibraryKind::*;\n \n #[derive(Clone, Debug)]\n pub struct LinkMeta {\n-    pub crate_name: Symbol,\n     pub crate_hash: Svh,\n }\n "}, {"sha": "adc9aabb8c77a1abf24a93f9807e890cb9d1b020", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -13,7 +13,6 @@ pub use self::code_stats::{SizeKind, TypeSizeInfo, VariantInfo};\n \n use dep_graph::DepGraph;\n use hir::def_id::{CrateNum, DefIndex};\n-use hir::svh::Svh;\n use lint;\n use middle::cstore::CrateStore;\n use middle::dependency_format;\n@@ -402,15 +401,14 @@ impl Session {\n \n     /// Returns the symbol name for the registrar function,\n     /// given the crate Svh and the function DefIndex.\n-    pub fn generate_plugin_registrar_symbol(&self, svh: &Svh, index: DefIndex)\n+    pub fn generate_plugin_registrar_symbol(&self, disambiguator: Symbol, index: DefIndex)\n                                             -> String {\n-        format!(\"__rustc_plugin_registrar__{}_{}\", svh, index.as_usize())\n+        format!(\"__rustc_plugin_registrar__{}_{}\", disambiguator, index.as_usize())\n     }\n \n-    pub fn generate_derive_registrar_symbol(&self,\n-                                            svh: &Svh,\n-                                            index: DefIndex) -> String {\n-        format!(\"__rustc_derive_registrar__{}_{}\", svh, index.as_usize())\n+    pub fn generate_derive_registrar_symbol(&self, disambiguator: Symbol, index: DefIndex)\n+                                            -> String {\n+        format!(\"__rustc_derive_registrar__{}_{}\", disambiguator, index.as_usize())\n     }\n \n     pub fn sysroot<'a>(&'a self) -> &'a Path {"}, {"sha": "6b136d0fa0cbbd425c198fa421f877c2d11367c0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -1140,7 +1140,7 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     time(sess.time_passes(),\n          \"linking\",\n-         || link::link_binary(sess, trans, outputs, &trans.link.crate_name.as_str()));\n+         || link::link_binary(sess, trans, outputs, &trans.crate_name.as_str()));\n }\n \n fn escape_dep_filename(filename: &str) -> String {"}, {"sha": "a8ee999505e2074e2755a593316c05d8acd591ce", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -600,7 +600,7 @@ impl<'a> CrateLoader<'a> {\n             Err(err) => self.sess.span_fatal(span, &err),\n         };\n \n-        let sym = self.sess.generate_derive_registrar_symbol(&root.hash,\n+        let sym = self.sess.generate_derive_registrar_symbol(root.disambiguator,\n                                                              root.macro_derive_registrar.unwrap());\n         let registrar = unsafe {\n             let sym = match lib.symbol(&sym) {\n@@ -654,7 +654,7 @@ impl<'a> CrateLoader<'a> {\n     /// Look for a plugin registrar. Returns library path, crate\n     /// SVH and DefIndex of the registrar function.\n     pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n-                                 -> Option<(PathBuf, Svh, DefIndex)> {\n+                                 -> Option<(PathBuf, Symbol, DefIndex)> {\n         let ekrate = self.read_extension_crate(span, &ExternCrateInfo {\n              name: Symbol::intern(name),\n              ident: Symbol::intern(name),\n@@ -675,7 +675,7 @@ impl<'a> CrateLoader<'a> {\n         let root = ekrate.metadata.get_root();\n         match (ekrate.dylib.as_ref(), root.plugin_registrar_fn) {\n             (Some(dylib), Some(reg)) => {\n-                Some((dylib.to_path_buf(), root.hash, reg))\n+                Some((dylib.to_path_buf(), root.disambiguator, reg))\n             }\n             (None, Some(_)) => {\n                 span_err!(self.sess, span, E0457,"}, {"sha": "3bf22f8a6c82729d70aa48f61f9d0d114f0d6852", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -14,7 +14,7 @@ use schema::*;\n \n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n                             EncodedMetadata, EncodedMetadataHash};\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n@@ -1380,7 +1380,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let link_meta = self.link_meta;\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n         let root = self.lazy(&CrateRoot {\n-            name: link_meta.crate_name,\n+            name: tcx.crate_name(LOCAL_CRATE),\n             triple: tcx.sess.opts.target_triple.clone(),\n             hash: link_meta.crate_hash,\n             disambiguator: tcx.sess.local_crate_disambiguator(),"}, {"sha": "ed49e8a14c8c7b0097825e234b382d52e8f98967", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -100,8 +100,8 @@ impl<'a> PluginLoader<'a> {\n     fn load_plugin(&mut self, span: Span, name: &str, args: Vec<ast::NestedMetaItem>) {\n         let registrar = self.reader.find_plugin_registrar(span, name);\n \n-        if let Some((lib, svh, index)) = registrar {\n-            let symbol = self.sess.generate_plugin_registrar_symbol(&svh, index);\n+        if let Some((lib, disambiguator, index)) = registrar {\n+            let symbol = self.sess.generate_plugin_registrar_symbol(disambiguator, index);\n             let fun = self.dylink_registrar(span, lib, symbol);\n             self.plugins.push(PluginRegistrar {\n                 fun: fun,"}, {"sha": "7468f4ace1b16d760d811f728bd94caafa444925", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -47,7 +47,6 @@ use std::str;\n use flate;\n use syntax::ast;\n use syntax::attr;\n-use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n /// The LLVM module name containing crate-metadata. This includes a `.` on\n@@ -136,11 +135,8 @@ pub fn find_crate_name(sess: Option<&Session>,\n     \"rust_out\".to_string()\n }\n \n-pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap,\n-                       name: &str)\n-                       -> LinkMeta {\n+pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap) -> LinkMeta {\n     let r = LinkMeta {\n-        crate_name: Symbol::intern(name),\n         crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate].to_smaller_hash()),\n     };\n     info!(\"{:?}\", r);"}, {"sha": "5d6717272fdf3d000fdea7c56f5a14815f081cc1", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -15,6 +15,7 @@ use back::symbol_names::symbol_name;\n use util::nodemap::FxHashMap;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::session::config;\n+use rustc::ty::TyCtxt;\n use syntax::attr;\n use trans_item::TransItem;\n \n@@ -64,15 +65,15 @@ impl ExportedSymbols {\n         }\n \n         if let Some(id) = scx.sess().derive_registrar_fn.get() {\n-            let svh = &scx.link_meta().crate_hash;\n             let def_id = scx.tcx().hir.local_def_id(id);\n             let idx = def_id.index;\n-            let registrar = scx.sess().generate_derive_registrar_symbol(svh, idx);\n+            let disambiguator = scx.sess().local_crate_disambiguator();\n+            let registrar = scx.sess().generate_derive_registrar_symbol(disambiguator, idx);\n             local_crate.push((registrar, SymbolExportLevel::C));\n         }\n \n         if scx.sess().crate_types.borrow().contains(&config::CrateTypeDylib) {\n-            local_crate.push((scx.metadata_symbol_name(),\n+            local_crate.push((metadata_symbol_name(scx.tcx()),\n                               SymbolExportLevel::Rust));\n         }\n \n@@ -173,6 +174,12 @@ impl ExportedSymbols {\n     }\n }\n \n+pub fn metadata_symbol_name(tcx: TyCtxt) -> String {\n+    format!(\"rust_metadata_{}_{}\",\n+            tcx.crate_name(LOCAL_CRATE),\n+            tcx.crate_disambiguator(LOCAL_CRATE))\n+}\n+\n pub fn crate_export_threshold(crate_type: config::CrateType)\n                                      -> SymbolExportLevel {\n     match crate_type {"}, {"sha": "8facbd6cc278373299585b0dd64dd5904fcc62f8", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -179,14 +179,14 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n \n     if let Some(id) = node_id {\n         if scx.sess().plugin_registrar_fn.get() == Some(id) {\n-            let svh = &scx.link_meta().crate_hash;\n             let idx = def_id.index;\n-            return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n+            let disambiguator = scx.sess().local_crate_disambiguator();\n+            return scx.sess().generate_plugin_registrar_symbol(disambiguator, idx);\n         }\n         if scx.sess().derive_registrar_fn.get() == Some(id) {\n-            let svh = &scx.link_meta().crate_hash;\n             let idx = def_id.index;\n-            return scx.sess().generate_derive_registrar_symbol(svh, idx);\n+            let disambiguator = scx.sess().local_crate_disambiguator();\n+            return scx.sess().generate_derive_registrar_symbol(disambiguator, idx);\n         }\n     }\n "}, {"sha": "c770bbdb90f72569b46571cb3d18d769d4f395a9", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 151, "deletions": 150, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -32,13 +32,14 @@ use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n use back::symbol_export::{self, ExportedSymbols};\n-use llvm::{Linkage, ValueRef, Vector, get_param};\n+use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n use rustc::hir::def_id::LOCAL_CRATE;\n use middle::lang_items::StartFnLangItem;\n use middle::cstore::EncodedMetadata;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::dep_graph::{AssertDepGraphSafe, DepNode, WorkProduct};\n+use rustc::dep_graph::{AssertDepGraphSafe, DepNode};\n+use rustc::middle::cstore::LinkMeta;\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use session::config::{self, NoDebugInfo};\n@@ -56,7 +57,7 @@ use common::CrateContext;\n use common::{type_is_zero_size, val_ty};\n use common;\n use consts;\n-use context::{SharedCrateContext, CrateContextList};\n+use context::{self, LocalCrateContext, SharedCrateContext, Stats};\n use debuginfo;\n use declare;\n use machine;\n@@ -724,19 +725,24 @@ fn contains_null(s: &str) -> bool {\n     s.bytes().any(|b| b == 0)\n }\n \n-fn write_metadata(cx: &SharedCrateContext,\n-                  exported_symbols: &NodeSet)\n-                  -> EncodedMetadata {\n+fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+                            link_meta: &LinkMeta,\n+                            exported_symbols: &NodeSet)\n+                            -> (ContextRef, ModuleRef, EncodedMetadata) {\n     use flate;\n \n+    let (metadata_llcx, metadata_llmod) = unsafe {\n+        context::create_context_and_module(tcx.sess, \"metadata\")\n+    };\n+\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n     enum MetadataKind {\n         None,\n         Uncompressed,\n         Compressed\n     }\n \n-    let kind = cx.sess().crate_types.borrow().iter().map(|ty| {\n+    let kind = tcx.sess.crate_types.borrow().iter().map(|ty| {\n         match *ty {\n             config::CrateTypeExecutable |\n             config::CrateTypeStaticlib |\n@@ -750,35 +756,35 @@ fn write_metadata(cx: &SharedCrateContext,\n     }).max().unwrap();\n \n     if kind == MetadataKind::None {\n-        return EncodedMetadata {\n+        return (metadata_llcx, metadata_llmod, EncodedMetadata {\n             raw_data: vec![],\n             hashes: vec![],\n-        };\n+        });\n     }\n \n-    let cstore = &cx.tcx().sess.cstore;\n-    let metadata = cstore.encode_metadata(cx.tcx(),\n-                                          cx.link_meta(),\n+    let cstore = &tcx.sess.cstore;\n+    let metadata = cstore.encode_metadata(tcx,\n+                                          &link_meta,\n                                           exported_symbols);\n     if kind == MetadataKind::Uncompressed {\n-        return metadata;\n+        return (metadata_llcx, metadata_llmod, metadata);\n     }\n \n     assert!(kind == MetadataKind::Compressed);\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.extend_from_slice(&flate::deflate_bytes(&metadata.raw_data));\n \n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed);\n-    let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n-    let name = cx.metadata_symbol_name();\n+    let llmeta = C_bytes_in_context(metadata_llcx, &compressed);\n+    let llconst = C_struct_in_context(metadata_llcx, &[llmeta], false);\n+    let name = symbol_export::metadata_symbol_name(tcx);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n-        llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(), buf.as_ptr())\n+        llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst).to_ref(), buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n         let section_name =\n-            cx.tcx().sess.cstore.metadata_section_name(&cx.sess().target.target);\n+            tcx.sess.cstore.metadata_section_name(&tcx.sess.target.target);\n         let name = CString::new(section_name).unwrap();\n         llvm::LLVMSetSection(llglobal, name.as_ptr());\n \n@@ -787,15 +793,16 @@ fn write_metadata(cx: &SharedCrateContext,\n         // metadata doesn't get loaded into memory.\n         let directive = format!(\".section {}\", section_name);\n         let directive = CString::new(directive).unwrap();\n-        llvm::LLVMSetModuleInlineAsm(cx.metadata_llmod(), directive.as_ptr())\n+        llvm::LLVMSetModuleInlineAsm(metadata_llmod, directive.as_ptr())\n     }\n-    return metadata;\n+    return (metadata_llcx, metadata_llmod, metadata);\n }\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n fn internalize_symbols<'a, 'tcx>(sess: &Session,\n-                                 ccxs: &CrateContextList<'a, 'tcx>,\n+                                 scx: &SharedCrateContext<'a, 'tcx>,\n+                                 llvm_modules: &[ModuleLlvm],\n                                  symbol_map: &SymbolMap<'tcx>,\n                                  exported_symbols: &ExportedSymbols) {\n     let export_threshold =\n@@ -810,7 +817,6 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n         .map(|&(ref name, _)| &name[..])\n         .collect::<FxHashSet<&str>>();\n \n-    let scx = ccxs.shared();\n     let tcx = scx.tcx();\n \n     let incr_comp = sess.opts.debugging_opts.incremental.is_some();\n@@ -825,8 +831,8 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n         // incremental compilation, we don't need to collect. See below for more\n         // information.\n         if !incr_comp {\n-            for ccx in ccxs.iter_need_trans() {\n-                for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+            for ll in llvm_modules {\n+                for val in iter_globals(ll.llmod).chain(iter_functions(ll.llmod)) {\n                     let linkage = llvm::LLVMRustGetLinkage(val);\n                     // We only care about external declarations (not definitions)\n                     // and available_externally definitions.\n@@ -862,8 +868,8 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n         // Examine each external definition.  If the definition is not used in\n         // any other compilation unit, and is not reachable from other crates,\n         // then give it internal linkage.\n-        for ccx in ccxs.iter_need_trans() {\n-            for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+        for ll in llvm_modules {\n+            for val in iter_globals(ll.llmod).chain(iter_functions(ll.llmod)) {\n                 let linkage = llvm::LLVMRustGetLinkage(val);\n \n                 let is_externally_visible = (linkage == llvm::Linkage::ExternalLinkage) ||\n@@ -922,33 +928,34 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n // when using MSVC linker.  We do this only for data, as linker can fix up\n // code references on its own.\n // See #26591, #27438\n-fn create_imps(cx: &CrateContextList) {\n+fn create_imps(sess: &Session,\n+               llvm_modules: &[ModuleLlvm]) {\n     // The x86 ABI seems to require that leading underscores are added to symbol\n     // names, so we need an extra underscore on 32-bit. There's also a leading\n     // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n     // underscores added in front).\n-    let prefix = if cx.shared().sess().target.target.target_pointer_width == \"32\" {\n+    let prefix = if sess.target.target.target_pointer_width == \"32\" {\n         \"\\x01__imp__\"\n     } else {\n         \"\\x01__imp_\"\n     };\n     unsafe {\n-        for ccx in cx.iter_need_trans() {\n-            let exported: Vec<_> = iter_globals(ccx.llmod())\n+        for ll in llvm_modules {\n+            let exported: Vec<_> = iter_globals(ll.llmod)\n                                        .filter(|&val| {\n                                            llvm::LLVMRustGetLinkage(val) ==\n                                            llvm::Linkage::ExternalLinkage &&\n                                            llvm::LLVMIsDeclaration(val) == 0\n                                        })\n                                        .collect();\n \n-            let i8p_ty = Type::i8p(&ccx);\n+            let i8p_ty = Type::i8p_llcx(ll.llcx);\n             for val in exported {\n                 let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n                 let mut imp_name = prefix.as_bytes().to_vec();\n                 imp_name.extend(name.to_bytes());\n                 let imp_name = CString::new(imp_name).unwrap();\n-                let imp = llvm::LLVMAddGlobal(ccx.llmod(),\n+                let imp = llvm::LLVMAddGlobal(ll.llmod,\n                                               i8p_ty.to_ref(),\n                                               imp_name.as_ptr() as *const _);\n                 let init = llvm::LLVMConstBitCast(val, i8p_ty.to_ref());\n@@ -1058,28 +1065,28 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // particular items that will be processed.\n     let krate = tcx.hir.krate();\n \n-    let ty::CrateAnalysis { reachable, name, .. } = analysis;\n+    let ty::CrateAnalysis { reachable, .. } = analysis;\n     let exported_symbols = find_exported_symbols(tcx, reachable);\n \n     let check_overflow = tcx.sess.overflow_checks();\n \n-    let link_meta = link::build_link_meta(incremental_hashes_map, &name);\n+    let link_meta = link::build_link_meta(incremental_hashes_map);\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n-                                             link_meta.clone(),\n                                              exported_symbols,\n                                              check_overflow);\n     // Translate the metadata.\n-    let metadata = time(tcx.sess.time_passes(), \"write metadata\", || {\n-        write_metadata(&shared_ccx, shared_ccx.exported_symbols())\n-    });\n+    let (metadata_llcx, metadata_llmod, metadata) =\n+        time(tcx.sess.time_passes(), \"write metadata\", || {\n+            write_metadata(tcx, &link_meta, shared_ccx.exported_symbols())\n+        });\n \n     let metadata_module = ModuleTranslation {\n         name: link::METADATA_MODULE_NAME.to_string(),\n         symbol_name_hash: 0, // we always rebuild metadata, at least for now\n         source: ModuleSource::Translated(ModuleLlvm {\n-            llcx: shared_ccx.metadata_llcx(),\n-            llmod: shared_ccx.metadata_llmod(),\n+            llcx: metadata_llcx,\n+            llmod: metadata_llmod,\n         }),\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n@@ -1090,6 +1097,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let empty_exported_symbols = ExportedSymbols::empty();\n         let linker_info = LinkerInfo::new(&shared_ccx, &empty_exported_symbols);\n         return CrateTranslation {\n+            crate_name: tcx.crate_name(LOCAL_CRATE),\n             modules: vec![],\n             metadata_module: metadata_module,\n             link: link_meta,\n@@ -1107,73 +1115,78 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let symbol_map = Rc::new(symbol_map);\n \n-    let previous_work_products = trans_reuse_previous_work_products(&shared_ccx,\n-                                                                    &codegen_units,\n-                                                                    &symbol_map);\n-\n-    let crate_context_list = CrateContextList::new(&shared_ccx,\n-                                                   codegen_units,\n-                                                   previous_work_products,\n-                                                   symbol_map.clone());\n-    let modules: Vec<_> = crate_context_list.iter_all()\n-        .map(|ccx| {\n-            let source = match ccx.previous_work_product() {\n-                Some(buf) => ModuleSource::Preexisting(buf.clone()),\n-                None => ModuleSource::Translated(ModuleLlvm {\n-                    llcx: ccx.llcx(),\n-                    llmod: ccx.llmod(),\n-                }),\n-            };\n-\n-            ModuleTranslation {\n-                name: String::from(ccx.codegen_unit().name()),\n-                symbol_name_hash: ccx.codegen_unit()\n-                                     .compute_symbol_name_hash(&shared_ccx,\n-                                                               &symbol_map),\n-                source: source,\n-            }\n+    let mut all_stats = Stats::default();\n+    let modules: Vec<ModuleTranslation> = codegen_units\n+        .into_iter()\n+        .map(|cgu| {\n+            let dep_node = cgu.work_product_dep_node();\n+            let (stats, module) =\n+                tcx.dep_graph.with_task(dep_node,\n+                                        AssertDepGraphSafe(&shared_ccx),\n+                                        AssertDepGraphSafe((cgu, symbol_map.clone())),\n+                                        module_translation);\n+            all_stats.extend(stats);\n+            module\n         })\n         .collect();\n \n-    assert_module_sources::assert_module_sources(tcx, &modules);\n+    fn module_translation<'a, 'tcx>(\n+        scx: AssertDepGraphSafe<&SharedCrateContext<'a, 'tcx>>,\n+        args: AssertDepGraphSafe<(CodegenUnit<'tcx>, Rc<SymbolMap<'tcx>>)>)\n+        -> (Stats, ModuleTranslation)\n+    {\n+        // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n+        let AssertDepGraphSafe(scx) = scx;\n+        let AssertDepGraphSafe((cgu, symbol_map)) = args;\n+\n+        let cgu_name = String::from(cgu.name());\n+        let cgu_id = cgu.work_product_id();\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_map);\n+\n+        // Check whether there is a previous work-product we can\n+        // re-use.  Not only must the file exist, and the inputs not\n+        // be dirty, but the hash of the symbols we will generate must\n+        // be the same.\n+        let previous_work_product =\n+            scx.dep_graph().previous_work_product(&cgu_id).and_then(|work_product| {\n+                if work_product.input_hash == symbol_name_hash {\n+                    debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n+                    Some(work_product)\n+                } else {\n+                    if scx.sess().opts.debugging_opts.incremental_info {\n+                        println!(\"incremental: CGU `{}` invalidated because of \\\n+                                  changed partitioning hash.\",\n+                                 cgu.name());\n+                    }\n+                    debug!(\"trans_reuse_previous_work_products: \\\n+                            not reusing {:?} because hash changed to {:?}\",\n+                           work_product, symbol_name_hash);\n+                    None\n+                }\n+            });\n+\n+        if let Some(buf) = previous_work_product {\n+            // Don't need to translate this module.\n+            let module = ModuleTranslation {\n+                name: cgu_name,\n+                symbol_name_hash,\n+                source: ModuleSource::Preexisting(buf.clone())\n+            };\n+            return (Stats::default(), module);\n+        }\n \n-    // Instantiate translation items without filling out definitions yet...\n-    for ccx in crate_context_list.iter_need_trans() {\n-        let dep_node = ccx.codegen_unit().work_product_dep_node();\n-        tcx.dep_graph.with_task(dep_node,\n-                                ccx,\n-                                AssertDepGraphSafe(symbol_map.clone()),\n-                                trans_decl_task);\n-\n-        fn trans_decl_task<'a, 'tcx>(ccx: CrateContext<'a, 'tcx>,\n-                                     symbol_map: AssertDepGraphSafe<Rc<SymbolMap<'tcx>>>) {\n-            // FIXME(#40304): Instead of this, the symbol-map should be an\n-            // on-demand thing that we compute.\n-            let AssertDepGraphSafe(symbol_map) = symbol_map;\n-            let cgu = ccx.codegen_unit();\n-            let trans_items = cgu.items_in_deterministic_order(ccx.tcx(), &symbol_map);\n-            for (trans_item, linkage) in trans_items {\n+        // Instantiate translation items without filling out definitions yet...\n+        let lcx = LocalCrateContext::new(scx, cgu, symbol_map.clone());\n+        let module = {\n+            let ccx = CrateContext::new(scx, &lcx);\n+            let trans_items = ccx.codegen_unit()\n+                                 .items_in_deterministic_order(ccx.tcx(), &symbol_map);\n+            for &(trans_item, linkage) in &trans_items {\n                 trans_item.predefine(&ccx, linkage);\n             }\n-        }\n-    }\n \n-    // ... and now that we have everything pre-defined, fill out those definitions.\n-    for ccx in crate_context_list.iter_need_trans() {\n-        let dep_node = ccx.codegen_unit().work_product_dep_node();\n-        tcx.dep_graph.with_task(dep_node,\n-                                ccx,\n-                                AssertDepGraphSafe(symbol_map.clone()),\n-                                trans_def_task);\n-\n-        fn trans_def_task<'a, 'tcx>(ccx: CrateContext<'a, 'tcx>,\n-                                    symbol_map: AssertDepGraphSafe<Rc<SymbolMap<'tcx>>>) {\n-            // FIXME(#40304): Instead of this, the symbol-map should be an\n-            // on-demand thing that we compute.\n-            let AssertDepGraphSafe(symbol_map) = symbol_map;\n-            let cgu = ccx.codegen_unit();\n-            let trans_items = cgu.items_in_deterministic_order(ccx.tcx(), &symbol_map);\n-            for (trans_item, _) in trans_items {\n+            // ... and now that we have everything pre-defined, fill out those definitions.\n+            for &(trans_item, _) in &trans_items {\n                 trans_item.define(&ccx);\n             }\n \n@@ -1211,26 +1224,38 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if ccx.sess().opts.debuginfo != NoDebugInfo {\n                 debuginfo::finalize(&ccx);\n             }\n-        }\n+\n+            ModuleTranslation {\n+                name: cgu_name,\n+                symbol_name_hash,\n+                source: ModuleSource::Translated(ModuleLlvm {\n+                    llcx: ccx.llcx(),\n+                    llmod: ccx.llmod(),\n+                })\n+            }\n+        };\n+\n+        (lcx.into_stats(), module)\n     }\n \n+    assert_module_sources::assert_module_sources(tcx, &modules);\n+\n     symbol_names_test::report_symbol_names(&shared_ccx);\n \n     if shared_ccx.sess().trans_stats() {\n-        let stats = shared_ccx.stats();\n         println!(\"--- trans stats ---\");\n-        println!(\"n_glues_created: {}\", stats.n_glues_created.get());\n-        println!(\"n_null_glues: {}\", stats.n_null_glues.get());\n-        println!(\"n_real_glues: {}\", stats.n_real_glues.get());\n+        println!(\"n_glues_created: {}\", all_stats.n_glues_created.get());\n+        println!(\"n_null_glues: {}\", all_stats.n_null_glues.get());\n+        println!(\"n_real_glues: {}\", all_stats.n_real_glues.get());\n \n-        println!(\"n_fns: {}\", stats.n_fns.get());\n-        println!(\"n_inlines: {}\", stats.n_inlines.get());\n-        println!(\"n_closures: {}\", stats.n_closures.get());\n+        println!(\"n_fns: {}\", all_stats.n_fns.get());\n+        println!(\"n_inlines: {}\", all_stats.n_inlines.get());\n+        println!(\"n_closures: {}\", all_stats.n_closures.get());\n         println!(\"fn stats:\");\n-        stats.fn_stats.borrow_mut().sort_by(|&(_, insns_a), &(_, insns_b)| {\n+        all_stats.fn_stats.borrow_mut().sort_by(|&(_, insns_a), &(_, insns_b)| {\n             insns_b.cmp(&insns_a)\n         });\n-        for tuple in stats.fn_stats.borrow().iter() {\n+        for tuple in all_stats.fn_stats.borrow().iter() {\n             match *tuple {\n                 (ref name, insns) => {\n                     println!(\"{} insns, {}\", insns, *name);\n@@ -1240,7 +1265,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     if shared_ccx.sess().count_llvm_insns() {\n-        for (k, v) in shared_ccx.stats().llvm_insns.borrow().iter() {\n+        for (k, v) in all_stats.llvm_insns.borrow().iter() {\n             println!(\"{:7} {}\", *v, *k);\n         }\n     }\n@@ -1250,11 +1275,23 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let exported_symbols = ExportedSymbols::compute_from(&shared_ccx,\n                                                          &symbol_map);\n \n+    // Get the list of llvm modules we created. We'll do a few wacky\n+    // transforms on them now.\n+\n+    let llvm_modules: Vec<_> =\n+        modules.iter()\n+               .filter_map(|module| match module.source {\n+                   ModuleSource::Translated(llvm) => Some(llvm),\n+                   _ => None,\n+               })\n+               .collect();\n+\n     // Now that we have all symbols that are exported from the CGUs of this\n     // crate, we can run the `internalize_symbols` pass.\n     time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n         internalize_symbols(sess,\n-                            &crate_context_list,\n+                            &shared_ccx,\n+                            &llvm_modules,\n                             &symbol_map,\n                             &exported_symbols);\n     });\n@@ -1265,7 +1302,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n-        create_imps(&crate_context_list);\n+        create_imps(sess, &llvm_modules);\n     }\n \n     let linker_info = LinkerInfo::new(&shared_ccx, &exported_symbols);\n@@ -1282,6 +1319,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n \n     CrateTranslation {\n+        crate_name: tcx.crate_name(LOCAL_CRATE),\n         modules: modules,\n         metadata_module: metadata_module,\n         link: link_meta,\n@@ -1480,43 +1518,6 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-/// For each CGU, identify if we can reuse an existing object file (or\n-/// maybe other context).\n-fn trans_reuse_previous_work_products(scx: &SharedCrateContext,\n-                                      codegen_units: &[CodegenUnit],\n-                                      symbol_map: &SymbolMap)\n-                                      -> Vec<Option<WorkProduct>> {\n-    debug!(\"trans_reuse_previous_work_products()\");\n-    codegen_units\n-        .iter()\n-        .map(|cgu| {\n-            let id = cgu.work_product_id();\n-\n-            let hash = cgu.compute_symbol_name_hash(scx, symbol_map);\n-\n-            debug!(\"trans_reuse_previous_work_products: id={:?} hash={}\", id, hash);\n-\n-            if let Some(work_product) = scx.dep_graph().previous_work_product(&id) {\n-                if work_product.input_hash == hash {\n-                    debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n-                    return Some(work_product);\n-                } else {\n-                    if scx.sess().opts.debugging_opts.incremental_info {\n-                        println!(\"incremental: CGU `{}` invalidated because of \\\n-                                  changed partitioning hash.\",\n-                                  cgu.name());\n-                    }\n-                    debug!(\"trans_reuse_previous_work_products: \\\n-                            not reusing {:?} because hash changed to {:?}\",\n-                           work_product, hash);\n-                }\n-            }\n-\n-            None\n-        })\n-        .collect()\n-}\n-\n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n                                                      -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();"}, {"sha": "c3770470bfd056536d620c38affa728d11e11aa7", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 40, "deletions": 165, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -10,9 +10,7 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef};\n-use rustc::dep_graph::{DepGraph, DepGraphSafe, DepNode, DepTrackingMap,\n-                       DepTrackingMapConfig, WorkProduct};\n-use middle::cstore::LinkMeta;\n+use rustc::dep_graph::{DepGraph, DepGraphSafe, DepNode, DepTrackingMap, DepTrackingMapConfig};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n@@ -47,6 +45,7 @@ use syntax::symbol::InternedString;\n use syntax_pos::DUMMY_SP;\n use abi::Abi;\n \n+#[derive(Clone, Default)]\n pub struct Stats {\n     pub n_glues_created: Cell<usize>,\n     pub n_null_glues: Cell<usize>,\n@@ -60,19 +59,30 @@ pub struct Stats {\n     pub fn_stats: RefCell<Vec<(String, usize)> >,\n }\n \n+impl Stats {\n+    pub fn extend(&mut self, stats: Stats) {\n+        self.n_glues_created.set(self.n_glues_created.get() + stats.n_glues_created.get());\n+        self.n_null_glues.set(self.n_null_glues.get() + stats.n_null_glues.get());\n+        self.n_real_glues.set(self.n_real_glues.get() + stats.n_real_glues.get());\n+        self.n_fns.set(self.n_fns.get() + stats.n_fns.get());\n+        self.n_inlines.set(self.n_inlines.get() + stats.n_inlines.get());\n+        self.n_closures.set(self.n_closures.get() + stats.n_closures.get());\n+        self.n_llvm_insns.set(self.n_llvm_insns.get() + stats.n_llvm_insns.get());\n+        self.llvm_insns.borrow_mut().extend(\n+            stats.llvm_insns.borrow().iter()\n+                                     .map(|(key, value)| (key.clone(), value.clone())));\n+        self.fn_stats.borrow_mut().append(&mut *stats.fn_stats.borrow_mut());\n+    }\n+}\n+\n /// The shared portion of a `CrateContext`.  There is one `SharedCrateContext`\n /// per crate.  The data here is shared between all compilation units of the\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n pub struct SharedCrateContext<'a, 'tcx: 'a> {\n-    metadata_llmod: ModuleRef,\n-    metadata_llcx: ContextRef,\n-\n     exported_symbols: NodeSet,\n-    link_meta: LinkMeta,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     empty_param_env: ty::ParameterEnvironment<'tcx>,\n-    stats: Stats,\n     check_overflow: bool,\n \n     use_dll_storage_attrs: bool,\n@@ -89,7 +99,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n-    previous_work_product: Option<WorkProduct>,\n+    stats: Stats,\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n     /// Cache instances of monomorphic and polymorphic items\n@@ -214,107 +224,23 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n     }\n }\n \n-/// This list owns a number of LocalCrateContexts and binds them to their common\n-/// SharedCrateContext. This type just exists as a convenience, something to\n-/// pass around all LocalCrateContexts with and get an iterator over them.\n-pub struct CrateContextList<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccxs: Vec<LocalCrateContext<'tcx>>,\n-}\n-\n-impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n-    pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n-               codegen_units: Vec<CodegenUnit<'tcx>>,\n-               previous_work_products: Vec<Option<WorkProduct>>,\n-               symbol_map: Rc<SymbolMap<'tcx>>)\n-               -> CrateContextList<'a, 'tcx> {\n-        CrateContextList {\n-            shared: shared_ccx,\n-            local_ccxs: codegen_units.into_iter().zip(previous_work_products).map(|(cgu, wp)| {\n-                LocalCrateContext::new(shared_ccx, cgu, wp, symbol_map.clone())\n-            }).collect()\n-        }\n-    }\n-\n-    /// Iterate over all crate contexts, whether or not they need\n-    /// translation.  That is, whether or not a `.o` file is available\n-    /// for re-use from a previous incr. comp.).\n-    pub fn iter_all<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n-        CrateContextIterator {\n-            shared: self.shared,\n-            index: 0,\n-            local_ccxs: &self.local_ccxs[..],\n-            filter_to_previous_work_product_unavail: false,\n-        }\n-    }\n-\n-    /// Iterator over all CCX that need translation (cannot reuse results from\n-    /// previous incr. comp.).\n-    pub fn iter_need_trans<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n-        CrateContextIterator {\n-            shared: self.shared,\n-            index: 0,\n-            local_ccxs: &self.local_ccxs[..],\n-            filter_to_previous_work_product_unavail: true,\n-        }\n-    }\n-\n-    pub fn shared(&self) -> &'a SharedCrateContext<'a, 'tcx> {\n-        self.shared\n-    }\n-}\n-\n /// A CrateContext value binds together one LocalCrateContext with the\n /// SharedCrateContext. It exists as a convenience wrapper, so we don't have to\n /// pass around (SharedCrateContext, LocalCrateContext) tuples all over trans.\n pub struct CrateContext<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccxs: &'a [LocalCrateContext<'tcx>],\n-    /// The index of `local` in `local_ccxs`.  This is used in\n-    /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n-    index: usize,\n+    local_ccx: &'a LocalCrateContext<'tcx>,\n }\n \n-impl<'a, 'tcx> DepGraphSafe for CrateContext<'a, 'tcx> {\n-}\n-\n-pub struct CrateContextIterator<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccxs: &'a [LocalCrateContext<'tcx>],\n-    index: usize,\n-\n-    /// if true, only return results where `previous_work_product` is none\n-    filter_to_previous_work_product_unavail: bool,\n+impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n+    pub fn new(shared: &'a SharedCrateContext<'a, 'tcx>,\n+               local_ccx: &'a LocalCrateContext<'tcx>)\n+               -> Self {\n+        CrateContext { shared, local_ccx }\n+    }\n }\n \n-impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n-    type Item = CrateContext<'a, 'tcx>;\n-\n-    fn next(&mut self) -> Option<CrateContext<'a, 'tcx>> {\n-        loop {\n-            if self.index >= self.local_ccxs.len() {\n-                return None;\n-            }\n-\n-            let index = self.index;\n-            self.index += 1;\n-\n-            let ccx = CrateContext {\n-                shared: self.shared,\n-                index: index,\n-                local_ccxs: self.local_ccxs,\n-            };\n-\n-            if\n-                self.filter_to_previous_work_product_unavail &&\n-                ccx.previous_work_product().is_some()\n-            {\n-                continue;\n-            }\n-\n-            return Some(ccx);\n-        }\n-    }\n+impl<'a, 'tcx> DepGraphSafe for CrateContext<'a, 'tcx> {\n }\n \n pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n@@ -347,7 +273,7 @@ pub fn is_pie_binary(sess: &Session) -> bool {\n     !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocMode::PIC\n }\n \n-unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n+pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n     let mod_name = CString::new(mod_name).unwrap();\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n@@ -405,14 +331,9 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-               link_meta: LinkMeta,\n                exported_symbols: NodeSet,\n                check_overflow: bool)\n                -> SharedCrateContext<'b, 'tcx> {\n-        let (metadata_llcx, metadata_llmod) = unsafe {\n-            create_context_and_module(&tcx.sess, \"metadata\")\n-        };\n-\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these\n@@ -459,23 +380,9 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_msvc;\n \n         SharedCrateContext {\n-            metadata_llmod: metadata_llmod,\n-            metadata_llcx: metadata_llcx,\n             exported_symbols: exported_symbols,\n-            link_meta: link_meta,\n             empty_param_env: tcx.empty_parameter_environment(),\n             tcx: tcx,\n-            stats: Stats {\n-                n_glues_created: Cell::new(0),\n-                n_null_glues: Cell::new(0),\n-                n_real_glues: Cell::new(0),\n-                n_fns: Cell::new(0),\n-                n_inlines: Cell::new(0),\n-                n_closures: Cell::new(0),\n-                n_llvm_insns: Cell::new(0),\n-                llvm_insns: RefCell::new(FxHashMap()),\n-                fn_stats: RefCell::new(Vec::new()),\n-            },\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n             translation_items: RefCell::new(FxHashSet()),\n@@ -492,14 +399,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         ty.is_sized(self.tcx, &self.empty_param_env, DUMMY_SP)\n     }\n \n-    pub fn metadata_llmod(&self) -> ModuleRef {\n-        self.metadata_llmod\n-    }\n-\n-    pub fn metadata_llcx(&self) -> ContextRef {\n-        self.metadata_llcx\n-    }\n-\n     pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n         &self.exported_symbols\n     }\n@@ -512,10 +411,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.project_cache\n     }\n \n-    pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n-        &self.link_meta\n-    }\n-\n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }\n@@ -528,31 +423,20 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.tcx.dep_graph\n     }\n \n-    pub fn stats<'a>(&'a self) -> &'a Stats {\n-        &self.stats\n-    }\n-\n     pub fn use_dll_storage_attrs(&self) -> bool {\n         self.use_dll_storage_attrs\n     }\n \n     pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n         &self.translation_items\n     }\n-\n-    pub fn metadata_symbol_name(&self) -> String {\n-        format!(\"rust_metadata_{}_{}\",\n-                self.link_meta().crate_name,\n-                self.link_meta().crate_hash)\n-    }\n }\n \n impl<'tcx> LocalCrateContext<'tcx> {\n-    fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: CodegenUnit<'tcx>,\n-               previous_work_product: Option<WorkProduct>,\n-               symbol_map: Rc<SymbolMap<'tcx>>)\n-           -> LocalCrateContext<'tcx> {\n+    pub fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n+                   codegen_unit: CodegenUnit<'tcx>,\n+                   symbol_map: Rc<SymbolMap<'tcx>>)\n+                   -> LocalCrateContext<'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n             //\n@@ -578,7 +462,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n             let local_ccx = LocalCrateContext {\n                 llmod: llmod,\n                 llcx: llcx,\n-                previous_work_product: previous_work_product,\n+                stats: Stats::default(),\n                 codegen_unit: codegen_unit,\n                 needs_unwind_cleanup_cache: RefCell::new(FxHashMap()),\n                 instances: RefCell::new(FxHashMap()),\n@@ -647,10 +531,13 @@ impl<'tcx> LocalCrateContext<'tcx> {\n         assert!(local_ccxs.len() == 1);\n         CrateContext {\n             shared: shared,\n-            index: 0,\n-            local_ccxs: local_ccxs\n+            local_ccx: &local_ccxs[0]\n         }\n     }\n+\n+    pub fn into_stats(self) -> Stats {\n+        self.stats\n+    }\n }\n \n impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n@@ -659,7 +546,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     fn local(&self) -> &'b LocalCrateContext<'tcx> {\n-        &self.local_ccxs[self.index]\n+        self.local_ccx\n     }\n \n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n@@ -688,10 +575,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().llcx\n     }\n \n-    pub fn previous_work_product(&self) -> Option<&WorkProduct> {\n-        self.local().previous_work_product.as_ref()\n-    }\n-\n     pub fn codegen_unit(&self) -> &CodegenUnit<'tcx> {\n         &self.local().codegen_unit\n     }\n@@ -700,14 +583,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }\n \n-    pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n-        &self.shared.exported_symbols\n-    }\n-\n-    pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n-        &self.shared.link_meta\n-    }\n-\n     pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FxHashMap<Ty<'tcx>, bool>> {\n         &self.local().needs_unwind_cleanup_cache\n     }\n@@ -777,7 +652,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn stats<'a>(&'a self) -> &'a Stats {\n-        &self.shared.stats\n+        &self.local().stats\n     }\n \n     pub fn int_type(&self) -> Type {"}, {"sha": "1f4756a94ea33518b14740dd227ed339e2eb455c", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -26,7 +26,7 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n \n use rustc::hir::def::CtorKind;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n@@ -810,7 +810,7 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n     };\n \n     fn fallback_path(scc: &SharedCrateContext) -> CString {\n-        CString::new(scc.link_meta().crate_name.to_string()).unwrap()\n+        CString::new(scc.tcx().crate_name(LOCAL_CRATE).to_string()).unwrap()\n     }\n }\n "}, {"sha": "0a873767d935997b5601dc2495c263a41955c37e", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -37,7 +37,7 @@ pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    !cx.exported_symbols().contains(&node_id)\n+    !cx.shared().exported_symbols().contains(&node_id)\n }\n \n #[allow(non_snake_case)]"}, {"sha": "abda358bc4f87c8d36d3c05255f3eade1e302b88", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -40,6 +40,7 @@\n #![feature(conservative_impl_trait)]\n \n use rustc::dep_graph::WorkProduct;\n+use syntax_pos::symbol::Symbol;\n \n extern crate flate;\n extern crate libc;\n@@ -165,6 +166,7 @@ unsafe impl Send for ModuleTranslation { }\n unsafe impl Sync for ModuleTranslation { }\n \n pub struct CrateTranslation {\n+    pub crate_name: Symbol,\n     pub modules: Vec<ModuleTranslation>,\n     pub metadata_module: ModuleTranslation,\n     pub link: middle::cstore::LinkMeta,"}, {"sha": "d70afc0cce5a3cbebfa7ff9bc997b53b0b5137c2", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adc2b10399635b1529d002b4bad21037dff31290/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=adc2b10399635b1529d002b4bad21037dff31290", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm;\n-use llvm::{TypeRef, Bool, False, True, TypeKind};\n+use llvm::{ContextRef, TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use context::CrateContext;\n@@ -82,6 +82,10 @@ impl Type {\n         ty!(llvm::LLVMInt8TypeInContext(ccx.llcx()))\n     }\n \n+    pub fn i8_llcx(llcx: ContextRef) -> Type {\n+        ty!(llvm::LLVMInt8TypeInContext(llcx))\n+    }\n+\n     pub fn i16(ccx: &CrateContext) -> Type {\n         ty!(llvm::LLVMInt16TypeInContext(ccx.llcx()))\n     }\n@@ -123,6 +127,10 @@ impl Type {\n         Type::i8(ccx).ptr_to()\n     }\n \n+    pub fn i8p_llcx(llcx: ContextRef) -> Type {\n+        Type::i8_llcx(llcx).ptr_to()\n+    }\n+\n     pub fn int(ccx: &CrateContext) -> Type {\n         match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n             \"16\" => Type::i16(ccx),"}]}