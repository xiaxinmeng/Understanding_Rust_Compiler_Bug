{"sha": "73f3054288ee34b50c1f72404b24fdeb12a38f66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZjMwNTQyODhlZTM0YjUwYzFmNzI0MDRiMjRmZGViMTJhMzhmNjY=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-03-31T05:50:07Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-05T11:02:24Z"}, "message": "Check arithmetic in the MIR\n\nAdd, Sub, Mul, Shl, and Shr are checked using a new Rvalue:\nCheckedBinaryOp, while Div, Rem and Neg are handled with explicit checks\nin the MIR.", "tree": {"sha": "84b5fe92d515da937e4bbfbc5eeee8f90a821980", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84b5fe92d515da937e4bbfbc5eeee8f90a821980"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73f3054288ee34b50c1f72404b24fdeb12a38f66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73f3054288ee34b50c1f72404b24fdeb12a38f66", "html_url": "https://github.com/rust-lang/rust/commit/73f3054288ee34b50c1f72404b24fdeb12a38f66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73f3054288ee34b50c1f72404b24fdeb12a38f66/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f97c411548f2b64f74f2bcb84dcc37075c05e2a0", "html_url": "https://github.com/rust-lang/rust/commit/f97c411548f2b64f74f2bcb84dcc37075c05e2a0"}], "stats": {"total": 437, "additions": 428, "deletions": 9}, "files": [{"sha": "2f16878a94cf9cf83976407620b9b07b8a938ee9", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=73f3054288ee34b50c1f72404b24fdeb12a38f66", "patch": "@@ -787,6 +787,7 @@ pub enum Rvalue<'tcx> {\n     Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n \n     BinaryOp(BinOp, Operand<'tcx>, Operand<'tcx>),\n+    CheckedBinaryOp(BinOp, Operand<'tcx>, Operand<'tcx>),\n \n     UnaryOp(UnOp, Operand<'tcx>),\n \n@@ -880,6 +881,16 @@ pub enum BinOp {\n     Gt,\n }\n \n+impl BinOp {\n+    pub fn is_checkable(self) -> bool {\n+        use self::BinOp::*;\n+        match self {\n+            Add | Sub | Mul | Shl | Shr => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n@@ -898,6 +909,9 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             Len(ref a) => write!(fmt, \"Len({:?})\", a),\n             Cast(ref kind, ref lv, ref ty) => write!(fmt, \"{:?} as {:?} ({:?})\", lv, ty, kind),\n             BinaryOp(ref op, ref a, ref b) => write!(fmt, \"{:?}({:?}, {:?})\", op, a, b),\n+            CheckedBinaryOp(ref op, ref a, ref b) => {\n+                write!(fmt, \"Checked{:?}({:?}, {:?})\", op, a, b)\n+            }\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n             Box(ref t) => write!(fmt, \"Box({:?})\", t),\n             InlineAsm { ref asm, ref outputs, ref inputs } => {"}, {"sha": "d0ac98a79587abf643317dcc1636e7382f9d98a3", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=73f3054288ee34b50c1f72404b24fdeb12a38f66", "patch": "@@ -183,6 +183,13 @@ impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n                 let rhs_ty = self.operand_ty(tcx, rhs);\n                 Some(self.binop_ty(tcx, op, lhs_ty, rhs_ty))\n             }\n+            Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs_ty = self.operand_ty(tcx, lhs);\n+                let rhs_ty = self.operand_ty(tcx, rhs);\n+                let ty = self.binop_ty(tcx, op, lhs_ty, rhs_ty);\n+                let ty = tcx.mk_tup(vec![ty, tcx.types.bool]);\n+                Some(ty)\n+            }\n             Rvalue::UnaryOp(_, ref operand) => {\n                 Some(self.operand_ty(tcx, operand))\n             }"}, {"sha": "2f290c813fdceaeca28cd153d42ed9173fdfafd2", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=73f3054288ee34b50c1f72404b24fdeb12a38f66", "patch": "@@ -461,6 +461,9 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::BinaryOp(_bin_op,\n+                                     ref $($mutability)* lhs,\n+                                     ref $($mutability)* rhs) |\n+                    Rvalue::CheckedBinaryOp(_bin_op,\n                                      ref $($mutability)* lhs,\n                                      ref $($mutability)* rhs) => {\n                         self.visit_operand(lhs);"}, {"sha": "de806eef36f8f1298d3a161a0aadcd1a1df46ec3", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=73f3054288ee34b50c1f72404b24fdeb12a38f66", "patch": "@@ -595,7 +595,8 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                             bb_ctxt.on_operand(SK::Repeat, operand, source),\n                         Rvalue::Cast(ref _kind, ref operand, ref _ty) =>\n                             bb_ctxt.on_operand(SK::Cast, operand, source),\n-                        Rvalue::BinaryOp(ref _binop, ref operand1, ref operand2) => {\n+                        Rvalue::BinaryOp(ref _binop, ref operand1, ref operand2) |\n+                        Rvalue::CheckedBinaryOp(ref _binop, ref operand1, ref operand2) => {\n                             bb_ctxt.on_operand(SK::BinaryOp, operand1, source);\n                             bb_ctxt.on_operand(SK::BinaryOp, operand2, source);\n                         }"}, {"sha": "b5b4a01dcc6410e511257b4f0db718ad1f8fc342", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 194, "deletions": 1, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=73f3054288ee34b50c1f72404b24fdeb12a38f66", "patch": "@@ -10,12 +10,19 @@\n \n //! See docs in build/expr/mod.rs\n \n+use std;\n+\n use rustc_data_structures::fnv::FnvHashMap;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n+use rustc_const_math::{ConstInt, ConstIsize};\n+use rustc::middle::const_val::ConstVal;\n+use rustc::ty;\n use rustc::mir::repr::*;\n+use syntax::ast;\n+use syntax::codemap::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding an rvalue.\n@@ -66,10 +73,34 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Binary { op, lhs, rhs } => {\n                 let lhs = unpack!(block = this.as_operand(block, lhs));\n                 let rhs = unpack!(block = this.as_operand(block, rhs));\n-                block.and(Rvalue::BinaryOp(op, lhs, rhs))\n+                this.build_binary_op(block, op, expr_span, expr.ty,\n+                                     lhs, rhs)\n             }\n             ExprKind::Unary { op, arg } => {\n                 let arg = unpack!(block = this.as_operand(block, arg));\n+                // Check for -MIN on signed integers\n+                if op == UnOp::Neg && this.check_overflow() && expr.ty.is_signed() {\n+                    let bool_ty = this.hir.bool_ty();\n+\n+                    let minval = this.minval_literal(expr_span, expr.ty);\n+                    let is_min = this.temp(bool_ty);\n+\n+                    this.cfg.push_assign(block, scope_id, expr_span, &is_min,\n+                                         Rvalue::BinaryOp(BinOp::Eq, arg.clone(), minval));\n+\n+                    let of_block = this.cfg.start_new_block();\n+                    let ok_block = this.cfg.start_new_block();\n+\n+                    this.cfg.terminate(block, scope_id, expr_span,\n+                                       TerminatorKind::If {\n+                                           cond: Operand::Consume(is_min),\n+                                           targets: (of_block, ok_block)\n+                                       });\n+\n+                    this.panic(of_block, \"attempted to negate with overflow\", expr_span);\n+\n+                    block = ok_block;\n+                }\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n             ExprKind::Box { value, value_extents } => {\n@@ -218,4 +249,166 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    pub fn build_binary_op(&mut self, mut block: BasicBlock, op: BinOp, span: Span, ty: ty::Ty<'tcx>,\n+                           lhs: Operand<'tcx>, rhs: Operand<'tcx>) -> BlockAnd<Rvalue<'tcx>> {\n+        let scope_id = self.innermost_scope_id();\n+        let bool_ty = self.hir.bool_ty();\n+        if self.check_overflow() && op.is_checkable() && ty.is_integral() {\n+            let result_tup = self.hir.tcx().mk_tup(vec![ty, bool_ty]);\n+            let result_value = self.temp(result_tup);\n+\n+            self.cfg.push_assign(block, scope_id, span,\n+                                 &result_value, Rvalue::CheckedBinaryOp(op,\n+                                                                        lhs,\n+                                                                        rhs));\n+            let val_fld = Field::new(0);\n+            let of_fld = Field::new(1);\n+\n+            let val = result_value.clone().field(val_fld, ty);\n+            let of = result_value.field(of_fld, bool_ty);\n+\n+            let success = self.cfg.start_new_block();\n+            let failure = self.cfg.start_new_block();\n+\n+            self.cfg.terminate(block, scope_id, span,\n+                               TerminatorKind::If {\n+                                   cond: Operand::Consume(of),\n+                                   targets: (failure, success)\n+                               });\n+            let msg = if op == BinOp::Shl || op == BinOp::Shr {\n+                \"shift operation overflowed\"\n+            } else {\n+                \"arithmetic operation overflowed\"\n+            };\n+            self.panic(failure, msg, span);\n+            success.and(Rvalue::Use(Operand::Consume(val)))\n+        } else {\n+            if ty.is_integral() && (op == BinOp::Div || op == BinOp::Rem) {\n+                // Checking division and remainder is more complex, since we 1. always check\n+                // and 2. there are two possible failure cases, divide-by-zero and overflow.\n+\n+                let (zero_msg, overflow_msg) = if op == BinOp::Div {\n+                    (\"attempted to divide by zero\",\n+                     \"attempted to divide with overflow\")\n+                } else {\n+                    (\"attempted remainder with a divisor of zero\",\n+                     \"attempted remainder with overflow\")\n+                };\n+\n+                // Check for / 0\n+                let is_zero = self.temp(bool_ty);\n+                let zero = self.zero_literal(span, ty);\n+                self.cfg.push_assign(block, scope_id, span, &is_zero,\n+                                     Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), zero));\n+\n+                let zero_block = self.cfg.start_new_block();\n+                let ok_block   = self.cfg.start_new_block();\n+\n+                self.cfg.terminate(block, scope_id, span,\n+                                   TerminatorKind::If {\n+                                       cond: Operand::Consume(is_zero),\n+                                       targets: (zero_block, ok_block)\n+                                   });\n+\n+                self.panic(zero_block, zero_msg, span);\n+                block = ok_block;\n+\n+                // We only need to check for the overflow in one case:\n+                // MIN / -1, and only for signed values.\n+                if ty.is_signed() {\n+                    let neg_1 = self.neg_1_literal(span, ty);\n+                    let min = self.minval_literal(span, ty);\n+\n+                    let is_neg_1 = self.temp(bool_ty);\n+                    let is_min   = self.temp(bool_ty);\n+                    let of       = self.temp(bool_ty);\n+\n+                    // this does (rhs == -1) & (lhs == MIN). It could short-circuit instead\n+\n+                    self.cfg.push_assign(block, scope_id, span, &is_neg_1,\n+                                         Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), neg_1));\n+                    self.cfg.push_assign(block, scope_id, span, &is_min,\n+                                         Rvalue::BinaryOp(BinOp::Eq, lhs.clone(), min));\n+\n+                    let is_neg_1 = Operand::Consume(is_neg_1);\n+                    let is_min = Operand::Consume(is_min);\n+                    self.cfg.push_assign(block, scope_id, span, &of,\n+                                         Rvalue::BinaryOp(BinOp::BitAnd, is_neg_1, is_min));\n+\n+                    let of_block = self.cfg.start_new_block();\n+                    let ok_block = self.cfg.start_new_block();\n+\n+                    self.cfg.terminate(block, scope_id, span,\n+                                       TerminatorKind::If {\n+                                           cond: Operand::Consume(of),\n+                                           targets: (of_block, ok_block)\n+                                       });\n+\n+                    self.panic(of_block, overflow_msg, span);\n+\n+                    block = ok_block;\n+                }\n+            }\n+\n+            block.and(Rvalue::BinaryOp(op, lhs, rhs))\n+        }\n+    }\n+\n+    // Helper to get a `-1` value of the appropriate type\n+    fn neg_1_literal(&mut self, span: Span, ty: ty::Ty<'tcx>) -> Operand<'tcx> {\n+        let literal = match ty.sty {\n+            ty::TyInt(ity) => {\n+                let val = match ity {\n+                    ast::IntTy::I8  => ConstInt::I8(-1),\n+                    ast::IntTy::I16 => ConstInt::I16(-1),\n+                    ast::IntTy::I32 => ConstInt::I32(-1),\n+                    ast::IntTy::I64 => ConstInt::I64(-1),\n+                    ast::IntTy::Is => {\n+                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let val = ConstIsize::new(-1, int_ty).unwrap();\n+                        ConstInt::Isize(val)\n+                    }\n+                };\n+\n+                Literal::Value { value: ConstVal::Integral(val) }\n+            }\n+            _ => {\n+                span_bug!(span, \"Invalid type for neg_1_literal: `{:?}`\", ty)\n+            }\n+        };\n+\n+        self.literal_operand(span, ty, literal)\n+    }\n+\n+    // Helper to get the minimum value of the appropriate type\n+    fn minval_literal(&mut self, span: Span, ty: ty::Ty<'tcx>) -> Operand<'tcx> {\n+        let literal = match ty.sty {\n+            ty::TyInt(ity) => {\n+                let val = match ity {\n+                    ast::IntTy::I8  => ConstInt::I8(std::i8::MIN),\n+                    ast::IntTy::I16 => ConstInt::I16(std::i16::MIN),\n+                    ast::IntTy::I32 => ConstInt::I32(std::i32::MIN),\n+                    ast::IntTy::I64 => ConstInt::I64(std::i64::MIN),\n+                    ast::IntTy::Is => {\n+                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let min = match int_ty {\n+                            ast::IntTy::I32 => std::i32::MIN as i64,\n+                            ast::IntTy::I64 => std::i64::MIN,\n+                            _ => unreachable!()\n+                        };\n+                        let val = ConstIsize::new(min, int_ty).unwrap();\n+                        ConstInt::Isize(val)\n+                    }\n+                };\n+\n+                Literal::Value { value: ConstVal::Integral(val) }\n+            }\n+            _ => {\n+                span_bug!(span, \"Invalid type for minval_literal: `{:?}`\", ty)\n+            }\n+        };\n+\n+        self.literal_operand(span, ty, literal)\n+    }\n }"}, {"sha": "24369aaff3f5c89c9dc7a2affa215fec29623e02", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=73f3054288ee34b50c1f72404b24fdeb12a38f66", "patch": "@@ -63,17 +63,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // only affects weird things like `x += {x += 1; x}`\n                 // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n \n+                let lhs = this.hir.mirror(lhs);\n+                let lhs_ty = lhs.ty;\n+\n                 // As above, RTL.\n                 let rhs = unpack!(block = this.as_operand(block, rhs));\n                 let lhs = unpack!(block = this.as_lvalue(block, lhs));\n \n                 // we don't have to drop prior contents or anything\n                 // because AssignOp is only legal for Copy types\n                 // (overloaded ops should be desugared into a call).\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs,\n-                                     Rvalue::BinaryOp(op,\n-                                                      Operand::Consume(lhs.clone()),\n-                                                      rhs));\n+                let result = unpack!(block = this.build_binary_op(block, op, expr_span, lhs_ty,\n+                                                  Operand::Consume(lhs.clone()), rhs));\n+                this.cfg.push_assign(block, scope_id, expr_span, &lhs, result);\n \n                 block.unit()\n             }"}, {"sha": "00e89095276312df1e1bf599846ac7f4b44e53a9", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=73f3054288ee34b50c1f72404b24fdeb12a38f66", "patch": "@@ -12,9 +12,14 @@\n //! kind of thing.\n \n use build::Builder;\n-use rustc::ty::Ty;\n+\n+use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n+use rustc::middle::const_val::ConstVal;\n+use rustc::ty::{self, Ty};\n+\n use rustc::mir::repr::*;\n use std::u32;\n+use syntax::ast;\n use syntax::codemap::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -50,6 +55,53 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         Rvalue::Aggregate(AggregateKind::Tuple, vec![])\n     }\n \n+    // Returns a zero literal operand for the appropriate type, works for\n+    // bool, char, integers and floats.\n+    pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n+        let literal = match ty.sty {\n+            ty::TyBool => {\n+                self.hir.false_literal()\n+            }\n+            ty::TyChar => Literal::Value { value: ConstVal::Char('\\0') },\n+            ty::TyUint(ity) => {\n+                let val = match ity {\n+                    ast::UintTy::U8  => ConstInt::U8(0),\n+                    ast::UintTy::U16 => ConstInt::U16(0),\n+                    ast::UintTy::U32 => ConstInt::U32(0),\n+                    ast::UintTy::U64 => ConstInt::U64(0),\n+                    ast::UintTy::Us => {\n+                        let uint_ty = self.hir.tcx().sess.target.uint_type;\n+                        let val = ConstUsize::new(0, uint_ty).unwrap();\n+                        ConstInt::Usize(val)\n+                    }\n+                };\n+\n+                Literal::Value { value: ConstVal::Integral(val) }\n+            }\n+            ty::TyInt(ity) => {\n+                let val = match ity {\n+                    ast::IntTy::I8  => ConstInt::I8(0),\n+                    ast::IntTy::I16 => ConstInt::I16(0),\n+                    ast::IntTy::I32 => ConstInt::I32(0),\n+                    ast::IntTy::I64 => ConstInt::I64(0),\n+                    ast::IntTy::Is => {\n+                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let val = ConstIsize::new(0, int_ty).unwrap();\n+                        ConstInt::Isize(val)\n+                    }\n+                };\n+\n+                Literal::Value { value: ConstVal::Integral(val) }\n+            }\n+            ty::TyFloat(_) => Literal::Value { value: ConstVal::Float(0.0) },\n+            _ => {\n+                span_bug!(span, \"Invalid type for zero_literal: `{:?}`\", ty)\n+            }\n+        };\n+\n+        self.literal_operand(span, ty, literal)\n+    }\n+\n     pub fn push_usize(&mut self,\n                       block: BasicBlock,\n                       scope_id: ScopeId,"}, {"sha": "3faf95331ddab52c6125475ea2acae31aeacf29e", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=73f3054288ee34b50c1f72404b24fdeb12a38f66", "patch": "@@ -378,6 +378,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    pub fn check_overflow(&self) -> bool {\n+        self.hir.tcx().sess.opts.debugging_opts.force_overflow_checks.unwrap_or(\n+            self.hir.tcx().sess.opts.debug_assertions)\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "57fdfb281d2ef51db58da5424a0b0fcd4df5d6cb", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=73f3054288ee34b50c1f72404b24fdeb12a38f66", "patch": "@@ -630,6 +630,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             Rvalue::Use(_) |\n             Rvalue::Repeat(..) |\n             Rvalue::UnaryOp(..) |\n+            Rvalue::CheckedBinaryOp(..) |\n             Rvalue::Cast(CastKind::ReifyFnPointer, _, _) |\n             Rvalue::Cast(CastKind::UnsafeFnPointer, _, _) |\n             Rvalue::Cast(CastKind::Unsize, _, _) => {}"}, {"sha": "cbd39fffce8010c5991556e2102ee84f2c454e44", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 143, "deletions": 2, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f3054288ee34b50c1f72404b24fdeb12a38f66/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=73f3054288ee34b50c1f72404b24fdeb12a38f66", "patch": "@@ -8,15 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n+use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::mir::repr as mir;\n \n use asm;\n use base;\n use callee::Callee;\n-use common::{self, C_uint, BlockAndBuilder, Result};\n+use common::{self, val_ty,\n+             C_null,\n+             C_uint, C_undef, C_u8, BlockAndBuilder, Result};\n use datum::{Datum, Lvalue};\n use debuginfo::DebugLoc;\n use adt;\n@@ -430,6 +432,21 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n                 (bcx, operand)\n             }\n+            mir::Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs = self.trans_operand(&bcx, lhs);\n+                let rhs = self.trans_operand(&bcx, rhs);\n+                let result = self.trans_scalar_checked_binop(&bcx, op,\n+                                                             lhs.immediate(), rhs.immediate(),\n+                                                             lhs.ty);\n+                let val_ty = self.mir.binop_ty(bcx.tcx(), op, lhs.ty, rhs.ty);\n+                let operand_ty = bcx.tcx().mk_tup(vec![val_ty, bcx.tcx().types.bool]);\n+                let operand = OperandRef {\n+                    val: OperandValue::Immediate(result),\n+                    ty: operand_ty\n+                };\n+\n+                (bcx, operand)\n+            }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n                 let operand = self.trans_operand(&bcx, operand);\n@@ -556,6 +573,57 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n         }\n     }\n+\n+    pub fn trans_scalar_checked_binop(&mut self,\n+                                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                      op: mir::BinOp,\n+                                      lhs: ValueRef,\n+                                      rhs: ValueRef,\n+                                      input_ty: Ty<'tcx>) -> ValueRef {\n+        let (val, of) = match op {\n+            // These are checked using intrinsics\n+            mir::BinOp::Add | mir::BinOp::Sub | mir::BinOp::Mul => {\n+                let oop = match op {\n+                    mir::BinOp::Add => OverflowOp::Add,\n+                    mir::BinOp::Sub => OverflowOp::Sub,\n+                    mir::BinOp::Mul => OverflowOp::Mul,\n+                    _ => unreachable!()\n+                };\n+                let intrinsic = get_overflow_intrinsic(oop, bcx, input_ty);\n+                let res = bcx.call(intrinsic, &[lhs, rhs], None);\n+\n+                let val = bcx.extract_value(res, 0);\n+                let of = bcx.extract_value(res, 1);\n+\n+                (val, bcx.zext(of, Type::bool(bcx.ccx())))\n+            }\n+            mir::BinOp::Shl | mir::BinOp::Shr => {\n+                let lhs_llty = val_ty(lhs);\n+                let rhs_llty = val_ty(rhs);\n+                let invert_mask = bcx.with_block(|bcx| {\n+                    common::shift_mask_val(bcx, lhs_llty, rhs_llty, true)\n+                });\n+                let outer_bits = bcx.and(rhs, invert_mask);\n+\n+                let of = bcx.icmp(llvm::IntNE, outer_bits, C_null(rhs_llty));\n+                let val = self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty);\n+\n+                (val, bcx.zext(of, Type::bool(bcx.ccx())))\n+            }\n+            _ => {\n+                // Fall back to regular translation with a constant-false overflow flag\n+                (self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty),\n+                 C_u8(bcx.ccx(), 0))\n+            }\n+        };\n+\n+        let val_ty = val_ty(val);\n+        let res_ty = Type::struct_(bcx.ccx(), &[val_ty, Type::bool(bcx.ccx())], false);\n+\n+        let mut res_val = C_undef(res_ty);\n+        res_val = bcx.insert_value(res_val, val, 0);\n+        bcx.insert_value(res_val, of, 1)\n+    }\n }\n \n pub fn rvalue_creates_operand<'bcx, 'tcx>(_mir: &mir::Mir<'tcx>,\n@@ -566,6 +634,7 @@ pub fn rvalue_creates_operand<'bcx, 'tcx>(_mir: &mir::Mir<'tcx>,\n         mir::Rvalue::Len(..) |\n         mir::Rvalue::Cast(..) | // (*)\n         mir::Rvalue::BinaryOp(..) |\n+        mir::Rvalue::CheckedBinaryOp(..) |\n         mir::Rvalue::UnaryOp(..) |\n         mir::Rvalue::Box(..) |\n         mir::Rvalue::Use(..) =>\n@@ -579,3 +648,75 @@ pub fn rvalue_creates_operand<'bcx, 'tcx>(_mir: &mir::Mir<'tcx>,\n \n     // (*) this is only true if the type is suitable\n }\n+\n+#[derive(Copy, Clone)]\n+enum OverflowOp {\n+    Add, Sub, Mul\n+}\n+\n+fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> ValueRef {\n+    use syntax::ast::IntTy::*;\n+    use syntax::ast::UintTy::*;\n+    use rustc::ty::{TyInt, TyUint};\n+\n+    let tcx = bcx.tcx();\n+\n+    let new_sty = match ty.sty {\n+        TyInt(Is) => match &tcx.sess.target.target.target_pointer_width[..] {\n+            \"32\" => TyInt(I32),\n+            \"64\" => TyInt(I64),\n+            _ => panic!(\"unsupported target word size\")\n+        },\n+        TyUint(Us) => match &tcx.sess.target.target.target_pointer_width[..] {\n+            \"32\" => TyUint(U32),\n+            \"64\" => TyUint(U64),\n+            _ => panic!(\"unsupported target word size\")\n+        },\n+        ref t @ TyUint(_) | ref t @ TyInt(_) => t.clone(),\n+        _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\")\n+    };\n+\n+    let name = match oop {\n+        OverflowOp::Add => match new_sty {\n+            TyInt(I8) => \"llvm.sadd.with.overflow.i8\",\n+            TyInt(I16) => \"llvm.sadd.with.overflow.i16\",\n+            TyInt(I32) => \"llvm.sadd.with.overflow.i32\",\n+            TyInt(I64) => \"llvm.sadd.with.overflow.i64\",\n+\n+            TyUint(U8) => \"llvm.uadd.with.overflow.i8\",\n+            TyUint(U16) => \"llvm.uadd.with.overflow.i16\",\n+            TyUint(U32) => \"llvm.uadd.with.overflow.i32\",\n+            TyUint(U64) => \"llvm.uadd.with.overflow.i64\",\n+\n+            _ => unreachable!(),\n+        },\n+        OverflowOp::Sub => match new_sty {\n+            TyInt(I8) => \"llvm.ssub.with.overflow.i8\",\n+            TyInt(I16) => \"llvm.ssub.with.overflow.i16\",\n+            TyInt(I32) => \"llvm.ssub.with.overflow.i32\",\n+            TyInt(I64) => \"llvm.ssub.with.overflow.i64\",\n+\n+            TyUint(U8) => \"llvm.usub.with.overflow.i8\",\n+            TyUint(U16) => \"llvm.usub.with.overflow.i16\",\n+            TyUint(U32) => \"llvm.usub.with.overflow.i32\",\n+            TyUint(U64) => \"llvm.usub.with.overflow.i64\",\n+\n+            _ => unreachable!(),\n+        },\n+        OverflowOp::Mul => match new_sty {\n+            TyInt(I8) => \"llvm.smul.with.overflow.i8\",\n+            TyInt(I16) => \"llvm.smul.with.overflow.i16\",\n+            TyInt(I32) => \"llvm.smul.with.overflow.i32\",\n+            TyInt(I64) => \"llvm.smul.with.overflow.i64\",\n+\n+            TyUint(U8) => \"llvm.umul.with.overflow.i8\",\n+            TyUint(U16) => \"llvm.umul.with.overflow.i16\",\n+            TyUint(U32) => \"llvm.umul.with.overflow.i32\",\n+            TyUint(U64) => \"llvm.umul.with.overflow.i64\",\n+\n+            _ => unreachable!(),\n+        },\n+    };\n+\n+    bcx.ccx().get_intrinsic(&name)\n+}"}]}