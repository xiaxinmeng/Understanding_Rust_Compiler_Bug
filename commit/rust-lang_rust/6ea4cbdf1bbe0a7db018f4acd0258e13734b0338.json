{"sha": "6ea4cbdf1bbe0a7db018f4acd0258e13734b0338", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYTRjYmRmMWJiZTBhN2RiMDE4ZjRhY2QwMjU4ZTEzNzM0YjAzMzg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-09-14T09:21:18Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-09-14T09:21:18Z"}, "message": "Rustup to rustc 1.39.0-nightly (a6946a817 2019-09-13)", "tree": {"sha": "ef8b995e0c8eac14738cb2c95e14383c919c9b97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef8b995e0c8eac14738cb2c95e14383c919c9b97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ea4cbdf1bbe0a7db018f4acd0258e13734b0338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ea4cbdf1bbe0a7db018f4acd0258e13734b0338", "html_url": "https://github.com/rust-lang/rust/commit/6ea4cbdf1bbe0a7db018f4acd0258e13734b0338", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ea4cbdf1bbe0a7db018f4acd0258e13734b0338/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1558bf94e59e7c5e5bc4e278561e9587af7b729a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1558bf94e59e7c5e5bc4e278561e9587af7b729a", "html_url": "https://github.com/rust-lang/rust/commit/1558bf94e59e7c5e5bc4e278561e9587af7b729a"}], "stats": {"total": 144, "additions": 70, "deletions": 74}, "files": [{"sha": "63b268597fe5c1ef7ddc27f162aa5d0bc6f45182", "filename": "src/analyze.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ea4cbdf1bbe0a7db018f4acd0258e13734b0338/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea4cbdf1bbe0a7db018f4acd0258e13734b0338/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=6ea4cbdf1bbe0a7db018f4acd0258e13734b0338", "patch": "@@ -24,8 +24,10 @@ pub fn analyze(fx: &FunctionCx<'_, '_, impl Backend>) -> HashMap<Local, Flags> {\n     for bb in fx.mir.basic_blocks().iter() {\n         for stmt in bb.statements.iter() {\n             match &stmt.kind {\n-                Assign(_, rval) => match &**rval {\n-                    Rvalue::Ref(_, _, place) => analyze_non_ssa_place(&mut flag_map, place),\n+                Assign(place_and_rval) => match &place_and_rval.1 {\n+                    Rvalue::Ref(_, _, place) => {\n+                        analyze_non_ssa_place(&mut flag_map, place);\n+                    }\n                     _ => {}\n                 },\n                 _ => {}"}, {"sha": "f1840f2012575c0e221a47c4536bedf33106f00d", "filename": "src/base.rs", "status": "modified", "additions": 65, "deletions": 71, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/6ea4cbdf1bbe0a7db018f4acd0258e13734b0338/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea4cbdf1bbe0a7db018f4acd0258e13734b0338/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=6ea4cbdf1bbe0a7db018f4acd0258e13734b0338", "patch": "@@ -267,10 +267,10 @@ fn trans_stmt<'tcx>(\n             let place = trans_place(fx, place);\n             crate::discriminant::codegen_set_discriminant(fx, place, *variant_index);\n         }\n-        StatementKind::Assign(to_place, rval) => {\n-            let lval = trans_place(fx, to_place);\n+        StatementKind::Assign(to_place_and_rval) => {\n+            let lval = trans_place(fx, &to_place_and_rval.0);\n             let dest_layout = lval.layout();\n-            match &**rval {\n+            match &to_place_and_rval.1 {\n                 Rvalue::Use(operand) => {\n                     let val = trans_operand(fx, operand);\n                     lval.write_cvalue(fx, val);\n@@ -506,7 +506,7 @@ fn trans_stmt<'tcx>(\n                             to.write_cvalue(fx, operand);\n                         }\n                     }\n-                    _ => unimpl!(\"shouldn't exist at trans {:?}\", rval),\n+                    _ => unimpl!(\"shouldn't exist at trans {:?}\", to_place_and_rval.1),\n                 },\n             }\n         }\n@@ -606,7 +606,7 @@ pub fn trans_place<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     place: &Place<'tcx>,\n ) -> CPlace<'tcx> {\n-    let base = match &place.base {\n+    let mut cplace = match &place.base {\n         PlaceBase::Local(local) => fx.get_local_place(*local),\n         PlaceBase::Static(static_) => match static_.kind {\n             StaticKind::Static => {\n@@ -619,76 +619,70 @@ pub fn trans_place<'tcx>(\n         },\n     };\n \n-    trans_place_projection(fx, base, &place.projection)\n-}\n-\n-pub fn trans_place_projection<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    base: CPlace<'tcx>,\n-    projection: &Option<Box<Projection<'tcx>>>,\n-) -> CPlace<'tcx> {\n-    let projection = if let Some(projection) = projection {\n-        projection\n-    } else {\n-        return base;\n-    };\n-\n-    let base = trans_place_projection(fx, base, &projection.base);\n-\n-    match projection.elem {\n-        ProjectionElem::Deref => base.place_deref(fx),\n-        ProjectionElem::Field(field, _ty) => base.place_field(fx, field),\n-        ProjectionElem::Index(local) => {\n-            let index = fx.get_local_place(local).to_cvalue(fx).load_scalar(fx);\n-            base.place_index(fx, index)\n-        }\n-        ProjectionElem::ConstantIndex {\n-            offset,\n-            min_length: _,\n-            from_end,\n-        } => {\n-            let index = if !from_end {\n-                fx.bcx.ins().iconst(fx.pointer_type, offset as i64)\n-            } else {\n-                let len = codegen_array_len(fx, base);\n-                fx.bcx.ins().iadd_imm(len, -(offset as i64))\n-            };\n-            base.place_index(fx, index)\n-        }\n-        ProjectionElem::Subslice { from, to } => {\n-            // These indices are generated by slice patterns.\n-            // slice[from:-to] in Python terms.\n-\n-            match base.layout().ty.sty {\n-                ty::Array(elem_ty, len) => {\n-                    let elem_layout = fx.layout_of(elem_ty);\n-                    let ptr = base.to_addr(fx);\n-                    let len = crate::constant::force_eval_const(fx, len)\n-                        .eval_usize(fx.tcx, ParamEnv::reveal_all());\n-                    CPlace::for_addr(\n-                        fx.bcx\n-                            .ins()\n-                            .iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n-                        fx.layout_of(fx.tcx.mk_array(elem_ty, len - from as u64 - to as u64)),\n-                    )\n-                }\n-                ty::Slice(elem_ty) => {\n-                    let elem_layout = fx.layout_of(elem_ty);\n-                    let (ptr, len) = base.to_addr_maybe_unsized(fx);\n-                    let len = len.unwrap();\n-                    CPlace::for_addr_with_extra(\n-                        fx.bcx\n-                            .ins()\n-                            .iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n-                        fx.bcx.ins().iadd_imm(len, -(from as i64 + to as i64)),\n-                        base.layout(),\n-                    )\n+    for elem in &*place.projection {\n+        match *elem {\n+            PlaceElem::Deref => {\n+                cplace = cplace.place_deref(fx);\n+            }\n+            PlaceElem::Field(field, _ty) => {\n+                cplace = cplace.place_field(fx, field);\n+            }\n+            PlaceElem::Index(local) => {\n+                let index = fx.get_local_place(local).to_cvalue(fx).load_scalar(fx);\n+                cplace = cplace.place_index(fx, index);\n+            }\n+            PlaceElem::ConstantIndex {\n+                offset,\n+                min_length: _,\n+                from_end,\n+            } => {\n+                let index = if !from_end {\n+                    fx.bcx.ins().iconst(fx.pointer_type, offset as i64)\n+                } else {\n+                    let len = codegen_array_len(fx, cplace);\n+                    fx.bcx.ins().iadd_imm(len, -(offset as i64))\n+                };\n+                cplace = cplace.place_index(fx, index);\n+            }\n+            PlaceElem::Subslice { from, to } => {\n+                // These indices are generated by slice patterns.\n+                // slice[from:-to] in Python terms.\n+\n+                match cplace.layout().ty.sty {\n+                    ty::Array(elem_ty, len) => {\n+                        let elem_layout = fx.layout_of(elem_ty);\n+                        let ptr = cplace.to_addr(fx);\n+                        let len = crate::constant::force_eval_const(fx, len)\n+                            .eval_usize(fx.tcx, ParamEnv::reveal_all());\n+                        cplace = CPlace::for_addr(\n+                            fx.bcx\n+                                .ins()\n+                                .iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n+                            fx.layout_of(fx.tcx.mk_array(elem_ty, len - from as u64 - to as u64)),\n+                        );\n+                    }\n+                    ty::Slice(elem_ty) => {\n+                        let elem_layout = fx.layout_of(elem_ty);\n+                        let (ptr, len) = cplace.to_addr_maybe_unsized(fx);\n+                        let len = len.unwrap();\n+                        cplace = CPlace::for_addr_with_extra(\n+                            fx.bcx\n+                                .ins()\n+                                .iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n+                            fx.bcx.ins().iadd_imm(len, -(from as i64 + to as i64)),\n+                            cplace.layout(),\n+                        );\n+                    }\n+                    _ => unreachable!(),\n                 }\n-                _ => unreachable!(),\n+            }\n+            PlaceElem::Downcast(_adt_def, variant) => {\n+                cplace = cplace.downcast_variant(fx, variant);\n             }\n         }\n-        ProjectionElem::Downcast(_adt_def, variant) => base.downcast_variant(fx, variant),\n     }\n+\n+    cplace\n }\n \n pub fn trans_operand<'tcx>("}, {"sha": "f064a2c0a3d4ebb29a2c49d1cfd27462cfccf607", "filename": "src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ea4cbdf1bbe0a7db018f4acd0258e13734b0338/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea4cbdf1bbe0a7db018f4acd0258e13734b0338/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=6ea4cbdf1bbe0a7db018f4acd0258e13734b0338", "patch": "@@ -482,7 +482,7 @@ pub fn mir_operand_get_const_val<'tcx>(\n         Operand::Constant(const_) => return Some(force_eval_const(fx, const_.literal)),\n     };\n \n-    assert!(place.projection.is_none());\n+    assert!(place.projection.is_empty());\n     let static_ = match &place.base {\n         PlaceBase::Static(static_) => static_,\n         PlaceBase::Local(_) => return None,"}]}