{"sha": "2c0931e168671d7536b58563dc3664c948a8dcd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMDkzMWUxNjg2NzFkNzUzNmI1ODU2M2RjMzY2NGM5NDhhOGRjZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-08T13:02:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-08T13:02:54Z"}, "message": "Auto merge of #64281 - Centril:rollup-inyqjf8, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #62205 (Add Iterator comparison methods that take a comparison function)\n - #64152 (Use backtrace formatting from the backtrace crate)\n - #64265 (resolve: Mark more erroneous imports as used)\n - #64267 (rustdoc: fix diagnostic with mixed code block styles)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "fbbcf77cf17fbaf2dcbab14dcce6ccd1cf7658da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbbcf77cf17fbaf2dcbab14dcce6ccd1cf7658da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c0931e168671d7536b58563dc3664c948a8dcd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c0931e168671d7536b58563dc3664c948a8dcd3", "html_url": "https://github.com/rust-lang/rust/commit/2c0931e168671d7536b58563dc3664c948a8dcd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c0931e168671d7536b58563dc3664c948a8dcd3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50362372d68eae9b02a351f0fab42962cd0518de", "url": "https://api.github.com/repos/rust-lang/rust/commits/50362372d68eae9b02a351f0fab42962cd0518de", "html_url": "https://github.com/rust-lang/rust/commit/50362372d68eae9b02a351f0fab42962cd0518de"}, {"sha": "832b47aee6a5922bebd052e3261a6f839fba6aee", "url": "https://api.github.com/repos/rust-lang/rust/commits/832b47aee6a5922bebd052e3261a6f839fba6aee", "html_url": "https://github.com/rust-lang/rust/commit/832b47aee6a5922bebd052e3261a6f839fba6aee"}], "stats": {"total": 494, "additions": 323, "deletions": 171}, "files": [{"sha": "328d96023bc1f776410157e2a192fe137fea197b", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -109,9 +109,9 @@ dependencies = [\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.35\"\n+version = \"0.3.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1371048253fa3bac6704bfd6bbfc922ee9bdcee8881330d40f308b81cc5adc55\"\n+checksum = \"5180c5a20655b14a819b652fd2378fa5f1697b6c9ddad3e695c2f9cedf6df4e2\"\n dependencies = [\n  \"backtrace-sys\",\n  \"cfg-if\","}, {"sha": "c09df3f7f22cbd8c650cf85a33a93fe5c77061ff", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 103, "deletions": 6, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -2557,10 +2557,40 @@ pub trait Iterator {\n     /// assert_eq!([1, 2].iter().cmp([1].iter()), Ordering::Greater);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn cmp<I>(mut self, other: I) -> Ordering where\n+    fn cmp<I>(self, other: I) -> Ordering\n+    where\n         I: IntoIterator<Item = Self::Item>,\n         Self::Item: Ord,\n         Self: Sized,\n+    {\n+        self.cmp_by(other, |x, y| x.cmp(&y))\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another with respect to the specified comparison function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let xs = [1, 2, 3, 4];\n+    /// let ys = [1, 4, 9, 16];\n+    ///\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| x.cmp(&y)), Ordering::Less);\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (x * x).cmp(&y)), Ordering::Equal);\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (2 * x).cmp(&y)), Ordering::Greater);\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn cmp_by<I, F>(mut self, other: I, mut cmp: F) -> Ordering\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> Ordering,\n     {\n         let mut other = other.into_iter();\n \n@@ -2579,7 +2609,7 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            match x.cmp(&y) {\n+            match cmp(x, y) {\n                 Ordering::Equal => (),\n                 non_eq => return non_eq,\n             }\n@@ -2601,10 +2631,49 @@ pub trait Iterator {\n     /// assert_eq!([std::f64::NAN].iter().partial_cmp([1.].iter()), None);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn partial_cmp<I>(mut self, other: I) -> Option<Ordering> where\n+    fn partial_cmp<I>(self, other: I) -> Option<Ordering>\n+    where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n+    {\n+        self.partial_cmp_by(other, |x, y| x.partial_cmp(&y))\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another with respect to the specified comparison function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let xs = [1.0, 2.0, 3.0, 4.0];\n+    /// let ys = [1.0, 4.0, 9.0, 16.0];\n+    ///\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| x.partial_cmp(&y)),\n+    ///     Some(Ordering::Less)\n+    /// );\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| (x * x).partial_cmp(&y)),\n+    ///     Some(Ordering::Equal)\n+    /// );\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| (2.0 * x).partial_cmp(&y)),\n+    ///     Some(Ordering::Greater)\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn partial_cmp_by<I, F>(mut self, other: I, mut partial_cmp: F) -> Option<Ordering>\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> Option<Ordering>,\n     {\n         let mut other = other.into_iter();\n \n@@ -2623,7 +2692,7 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            match x.partial_cmp(&y) {\n+            match partial_cmp(x, y) {\n                 Some(Ordering::Equal) => (),\n                 non_eq => return non_eq,\n             }\n@@ -2640,10 +2709,36 @@ pub trait Iterator {\n     /// assert_eq!([1].iter().eq([1, 2].iter()), false);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn eq<I>(mut self, other: I) -> bool where\n+    fn eq<I>(self, other: I) -> bool\n+    where\n         I: IntoIterator,\n         Self::Item: PartialEq<I::Item>,\n         Self: Sized,\n+    {\n+        self.eq_by(other, |x, y| x == y)\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are equal to those of\n+    /// another with respect to the specified equality function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// let xs = [1, 2, 3, 4];\n+    /// let ys = [1, 4, 9, 16];\n+    ///\n+    /// assert!(xs.iter().eq_by(&ys, |&x, &y| x * x == y));\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn eq_by<I, F>(mut self, other: I, mut eq: F) -> bool\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> bool,\n     {\n         let mut other = other.into_iter();\n \n@@ -2658,7 +2753,9 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            if x != y { return false }\n+            if !eq(x, y) {\n+                return false;\n+            }\n         }\n     }\n "}, {"sha": "d7088cf891f77112ac74cf092ee425c9862dd599", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -57,6 +57,62 @@ fn test_multi_iter() {\n     assert!(xs.iter().lt(xs.iter().skip(2)));\n }\n \n+#[test]\n+fn test_cmp_by() {\n+    use core::cmp::Ordering;\n+\n+    let f = |x: i32, y: i32| (x * x).cmp(&y);\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 16].iter().copied();\n+\n+    assert_eq!(xs().cmp_by(ys(), f), Ordering::Less);\n+    assert_eq!(ys().cmp_by(xs(), f), Ordering::Greater);\n+    assert_eq!(xs().cmp_by(xs().map(|x| x * x), f), Ordering::Equal);\n+    assert_eq!(xs().rev().cmp_by(ys().rev(), f), Ordering::Greater);\n+    assert_eq!(xs().cmp_by(ys().rev(), f), Ordering::Less);\n+    assert_eq!(xs().cmp_by(ys().take(2), f), Ordering::Greater);\n+}\n+\n+#[test]\n+fn test_partial_cmp_by() {\n+    use core::cmp::Ordering;\n+    use core::f64;\n+\n+    let f = |x: i32, y: i32| (x * x).partial_cmp(&y);\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 16].iter().copied();\n+\n+    assert_eq!(xs().partial_cmp_by(ys(), f), Some(Ordering::Less));\n+    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n+    assert_eq!(xs().partial_cmp_by(xs().map(|x| x * x), f), Some(Ordering::Equal));\n+    assert_eq!(xs().rev().partial_cmp_by(ys().rev(), f), Some(Ordering::Greater));\n+    assert_eq!(xs().partial_cmp_by(xs().rev(), f), Some(Ordering::Less));\n+    assert_eq!(xs().partial_cmp_by(ys().take(2), f), Some(Ordering::Greater));\n+\n+    let f = |x: f64, y: f64| (x * x).partial_cmp(&y);\n+    let xs = || [1.0, 2.0, 3.0, 4.0].iter().copied();\n+    let ys = || [1.0, 4.0, f64::NAN, 16.0].iter().copied();\n+\n+    assert_eq!(xs().partial_cmp_by(ys(), f), None);\n+    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n+}\n+\n+#[test]\n+fn test_eq_by() {\n+    let f = |x: i32, y: i32| x * x == y;\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 9, 16].iter().copied();\n+\n+    assert!(xs().eq_by(ys(), f));\n+    assert!(!ys().eq_by(xs(), f));\n+    assert!(!xs().eq_by(xs(), f));\n+    assert!(!ys().eq_by(ys(), f));\n+\n+    assert!(!xs().take(3).eq_by(ys(), f));\n+    assert!(!xs().eq_by(ys().take(3), f));\n+    assert!(xs().take(3).eq_by(ys().take(3), f));\n+}\n+\n #[test]\n fn test_counter_from_iter() {\n     let it = (0..).step_by(5).take(10);"}, {"sha": "050195cd2ef51eaca905ce2b05e9f0ae15556393", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -33,6 +33,7 @@\n #![feature(const_fn)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]\n+#![feature(iter_order_by)]\n \n extern crate test;\n "}, {"sha": "132690dcd7df22b6355f317753b0b1329c5baab0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -673,6 +673,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             self.throw_unresolved_import_error(errors.clone(), None);\n         }\n \n+        for import in &self.r.indeterminate_imports {\n+            // Consider erroneous imports used to avoid duplicate diagnostics.\n+            self.r.used_imports.insert((import.id, TypeNS));\n+        }\n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n         if !has_errors {\n@@ -839,6 +843,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                          true, directive.span, directive.crate_lint());\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n         directive.vis.set(orig_vis);\n+        if let PathResult::Failed { .. } | PathResult::NonModule(..) = path_res {\n+            // Consider erroneous imports used to avoid duplicate diagnostics.\n+            self.r.used_imports.insert((directive.id, TypeNS));\n+        }\n         let module = match path_res {\n             PathResult::Module(module) => {\n                 // Consistency checks, analogous to `finalize_macro_resolutions`."}, {"sha": "8bf01d2cc1aac8906a9790ff1dea9f56670683bd", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -931,7 +931,10 @@ crate fn rust_code_blocks(md: &str) -> Vec<RustCodeBlock> {\n                             is_fenced = true;\n                             previous_offset + fence_idx\n                         }\n-                        None => offset,\n+                        None => {\n+                            is_fenced = false;\n+                            offset\n+                        }\n                     };\n                 }\n             }"}, {"sha": "b5cbec7b0fadcd3e3a338d88c36d5bcf98aac908", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -26,7 +26,7 @@ unwind = { path = \"../libunwind\" }\n hashbrown = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n [dependencies.backtrace]\n-version = \"0.3.35\"\n+version = \"0.3.37\"\n default-features = false # don't use coresymbolication on OSX\n features = [\n   \"rustc-dep-of-std\", # enable build support for integrating into libstd"}, {"sha": "db4089c294812d99e43f838e66621fcbf27507b6", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -158,7 +158,7 @@ pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n \n fn default_hook(info: &PanicInfo<'_>) {\n     #[cfg(feature = \"backtrace\")]\n-    use crate::sys_common::backtrace;\n+    use crate::sys_common::{backtrace as backtrace_mod};\n \n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n@@ -167,9 +167,9 @@ fn default_hook(info: &PanicInfo<'_>) {\n         let panics = update_panic_count(0);\n \n         if panics >= 2 {\n-            Some(backtrace::PrintFormat::Full)\n+            Some(backtrace::PrintFmt::Full)\n         } else {\n-            backtrace::log_enabled()\n+            backtrace_mod::log_enabled()\n         }\n     };\n \n@@ -197,7 +197,7 @@ fn default_hook(info: &PanicInfo<'_>) {\n             static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n \n             if let Some(format) = log_backtrace {\n-                let _ = backtrace::print(err, format);\n+                let _ = backtrace_mod::print(err, format);\n             } else if FIRST_PANIC.compare_and_swap(true, false, Ordering::SeqCst) {\n                 let _ = writeln!(err, \"note: run with `RUST_BACKTRACE=1` \\\n                                        environment variable to display a backtrace.\");"}, {"sha": "f434b62aced678075c584e06bb3f62c595305dd3", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 89, "deletions": 146, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -2,23 +2,20 @@\n /// supported platforms.\n \n use crate::env;\n+use crate::fmt;\n use crate::io;\n use crate::io::prelude::*;\n-use crate::mem;\n use crate::path::{self, Path};\n-use crate::ptr;\n use crate::sync::atomic::{self, Ordering};\n use crate::sys::mutex::Mutex;\n \n-use backtrace::{BytesOrWideString, Frame, Symbol};\n-\n-pub const HEX_WIDTH: usize = 2 + 2 * mem::size_of::<usize>();\n+use backtrace::{BacktraceFmt, BytesOrWideString, PrintFmt};\n \n /// Max number of frames to print.\n const MAX_NB_FRAMES: usize = 100;\n \n /// Prints the current backtrace.\n-pub fn print(w: &mut dyn Write, format: PrintFormat) -> io::Result<()> {\n+pub fn print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n     static LOCK: Mutex = Mutex::new();\n \n     // There are issues currently linking libbacktrace into tests, and in\n@@ -39,26 +36,66 @@ pub fn print(w: &mut dyn Write, format: PrintFormat) -> io::Result<()> {\n     }\n }\n \n-fn _print(w: &mut dyn Write, format: PrintFormat) -> io::Result<()> {\n-    writeln!(w, \"stack backtrace:\")?;\n+fn _print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n+    struct DisplayBacktrace {\n+        format: PrintFmt,\n+    }\n+    impl fmt::Display for DisplayBacktrace {\n+        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            _print_fmt(fmt, self.format)\n+        }\n+    }\n+    write!(w, \"{}\", DisplayBacktrace { format })\n+}\n \n-    let mut printer = Printer::new(format, w);\n+fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::Result {\n+    let mut print_path = move |fmt: &mut fmt::Formatter<'_>, bows: BytesOrWideString<'_>| {\n+        output_filename(fmt, bows, print_fmt)\n+    };\n+    let mut bt_fmt = BacktraceFmt::new(fmt, print_fmt, &mut print_path);\n+    bt_fmt.add_context()?;\n+    let mut skipped = false;\n     unsafe {\n+        let mut idx = 0;\n+        let mut res = Ok(());\n         backtrace::trace_unsynchronized(|frame| {\n+            if print_fmt == PrintFmt::Short && idx > MAX_NB_FRAMES {\n+                skipped = true;\n+                return false;\n+            }\n+\n             let mut hit = false;\n+            let mut stop = false;\n             backtrace::resolve_frame_unsynchronized(frame, |symbol| {\n                 hit = true;\n-                printer.output(frame, Some(symbol));\n+                if print_fmt == PrintFmt::Short {\n+                    if let Some(sym) = symbol.name().and_then(|s| s.as_str()) {\n+                        if sym.contains(\"__rust_begin_short_backtrace\") {\n+                            skipped = true;\n+                            stop = true;\n+                            return;\n+                        }\n+                    }\n+                }\n+\n+                res = bt_fmt.frame().symbol(frame, symbol);\n             });\n+            if stop {\n+                return false;\n+            }\n             if !hit {\n-                printer.output(frame, None);\n+                res = bt_fmt.frame().print_raw(frame.ip(), None, None, None);\n             }\n-            !printer.done\n+\n+            idx += 1;\n+            res.is_ok()\n         });\n+        res?;\n     }\n-    if printer.skipped {\n+    bt_fmt.finish()?;\n+    if skipped {\n         writeln!(\n-            w,\n+            fmt,\n             \"note: Some details are omitted, \\\n              run with `RUST_BACKTRACE=full` for a verbose backtrace.\"\n         )?;\n@@ -77,33 +114,24 @@ where\n     f()\n }\n \n-/// Controls how the backtrace should be formatted.\n-#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-pub enum PrintFormat {\n-    /// Show only relevant data from the backtrace.\n-    Short = 2,\n-    /// Show all the frames with absolute path for files.\n-    Full = 3,\n-}\n-\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n-pub fn log_enabled() -> Option<PrintFormat> {\n+pub fn log_enabled() -> Option<PrintFmt> {\n     static ENABLED: atomic::AtomicIsize = atomic::AtomicIsize::new(0);\n     match ENABLED.load(Ordering::SeqCst) {\n         0 => {}\n         1 => return None,\n-        2 => return Some(PrintFormat::Short),\n-        _ => return Some(PrintFormat::Full),\n+        2 => return Some(PrintFmt::Short),\n+        _ => return Some(PrintFmt::Full),\n     }\n \n     let val = env::var_os(\"RUST_BACKTRACE\").and_then(|x| {\n         if &x == \"0\" {\n             None\n         } else if &x == \"full\" {\n-            Some(PrintFormat::Full)\n+            Some(PrintFmt::Full)\n         } else {\n-            Some(PrintFormat::Short)\n+            Some(PrintFmt::Short)\n         }\n     });\n     ENABLED.store(\n@@ -116,130 +144,45 @@ pub fn log_enabled() -> Option<PrintFormat> {\n     val\n }\n \n-struct Printer<'a, 'b> {\n-    format: PrintFormat,\n-    done: bool,\n-    skipped: bool,\n-    idx: usize,\n-    out: &'a mut (dyn Write + 'b),\n-}\n-\n-impl<'a, 'b> Printer<'a, 'b> {\n-    fn new(format: PrintFormat, out: &'a mut (dyn Write + 'b)) -> Printer<'a, 'b> {\n-        Printer { format, done: false, skipped: false, idx: 0, out }\n-    }\n-\n-    /// Prints the symbol of the backtrace frame.\n-    ///\n-    /// These output functions should now be used everywhere to ensure consistency.\n-    /// You may want to also use `output_fileline`.\n-    fn output(&mut self, frame: &Frame, symbol: Option<&Symbol>) {\n-        if self.idx > MAX_NB_FRAMES {\n-            self.done = true;\n-            self.skipped = true;\n-            return;\n-        }\n-        if self._output(frame, symbol).is_err() {\n-            self.done = true;\n-        }\n-        self.idx += 1;\n-    }\n-\n-    fn _output(&mut self, frame: &Frame, symbol: Option<&Symbol>) -> io::Result<()> {\n-        if self.format == PrintFormat::Short {\n-            if let Some(sym) = symbol.and_then(|s| s.name()).and_then(|s| s.as_str()) {\n-                if sym.contains(\"__rust_begin_short_backtrace\") {\n-                    self.skipped = true;\n-                    self.done = true;\n-                    return Ok(());\n-                }\n-            }\n-\n-            // Remove the `17: 0x0 - <unknown>` line.\n-            if self.format == PrintFormat::Short && frame.ip() == ptr::null_mut() {\n-                self.skipped = true;\n-                return Ok(());\n-            }\n-        }\n-\n-        match self.format {\n-            PrintFormat::Full => {\n-                write!(self.out, \"  {:2}: {:2$?} - \", self.idx, frame.ip(), HEX_WIDTH)?\n-            }\n-            PrintFormat::Short => write!(self.out, \"  {:2}: \", self.idx)?,\n-        }\n-\n-        match symbol.and_then(|s| s.name()) {\n-            Some(symbol) => {\n-                match self.format {\n-                    PrintFormat::Full => write!(self.out, \"{}\", symbol)?,\n-                    // Strip the trailing hash if short mode.\n-                    PrintFormat::Short => write!(self.out, \"{:#}\", symbol)?,\n-                }\n-            }\n-            None => self.out.write_all(b\"<unknown>\")?,\n+/// Prints the filename of the backtrace frame.\n+///\n+/// See also `output`.\n+fn output_filename(\n+    fmt: &mut fmt::Formatter<'_>,\n+    bows: BytesOrWideString<'_>,\n+    print_fmt: PrintFmt,\n+) -> fmt::Result {\n+    #[cfg(windows)]\n+    let path_buf;\n+    let file = match bows {\n+        #[cfg(unix)]\n+        BytesOrWideString::Bytes(bytes) => {\n+            use crate::os::unix::prelude::*;\n+            Path::new(crate::ffi::OsStr::from_bytes(bytes))\n         }\n-        self.out.write_all(b\"\\n\")?;\n-        if let Some(sym) = symbol {\n-            self.output_fileline(sym)?;\n+        #[cfg(not(unix))]\n+        BytesOrWideString::Bytes(bytes) => {\n+            Path::new(crate::str::from_utf8(bytes).unwrap_or(\"<unknown>\"))\n         }\n-        Ok(())\n-    }\n-\n-    /// Prints the filename and line number of the backtrace frame.\n-    ///\n-    /// See also `output`.\n-    fn output_fileline(&mut self, symbol: &Symbol) -> io::Result<()> {\n         #[cfg(windows)]\n-        let path_buf;\n-        let file = match symbol.filename_raw() {\n-            #[cfg(unix)]\n-            Some(BytesOrWideString::Bytes(bytes)) => {\n-                use crate::os::unix::prelude::*;\n-                Path::new(crate::ffi::OsStr::from_bytes(bytes))\n-            }\n-            #[cfg(not(unix))]\n-            Some(BytesOrWideString::Bytes(bytes)) => {\n-                Path::new(crate::str::from_utf8(bytes).unwrap_or(\"<unknown>\"))\n-            }\n-            #[cfg(windows)]\n-            Some(BytesOrWideString::Wide(wide)) => {\n-                use crate::os::windows::prelude::*;\n-                path_buf = crate::ffi::OsString::from_wide(wide);\n-                Path::new(&path_buf)\n-            }\n-            #[cfg(not(windows))]\n-            Some(BytesOrWideString::Wide(_wide)) => {\n-                Path::new(\"<unknown>\")\n-            }\n-            None => return Ok(()),\n-        };\n-        let line = match symbol.lineno() {\n-            Some(line) => line,\n-            None => return Ok(()),\n-        };\n-        // prior line: \"  ##: {:2$} - func\"\n-        self.out.write_all(b\"\")?;\n-        match self.format {\n-            PrintFormat::Full => write!(self.out, \"           {:1$}\", \"\", HEX_WIDTH)?,\n-            PrintFormat::Short => write!(self.out, \"           \")?,\n+        BytesOrWideString::Wide(wide) => {\n+            use crate::os::windows::prelude::*;\n+            path_buf = crate::ffi::OsString::from_wide(wide);\n+            Path::new(&path_buf)\n         }\n-\n-        let mut already_printed = false;\n-        if self.format == PrintFormat::Short && file.is_absolute() {\n-            if let Ok(cwd) = env::current_dir() {\n-                if let Ok(stripped) = file.strip_prefix(&cwd) {\n-                    if let Some(s) = stripped.to_str() {\n-                        write!(self.out, \"  at .{}{}:{}\", path::MAIN_SEPARATOR, s, line)?;\n-                        already_printed = true;\n-                    }\n+        #[cfg(not(windows))]\n+        BytesOrWideString::Wide(_wide) => {\n+            Path::new(\"<unknown>\")\n+        }\n+    };\n+    if print_fmt == PrintFmt::Short && file.is_absolute() {\n+        if let Ok(cwd) = env::current_dir() {\n+            if let Ok(stripped) = file.strip_prefix(&cwd) {\n+                if let Some(s) = stripped.to_str() {\n+                    return write!(fmt, \".{}{}\", path::MAIN_SEPARATOR, s);\n                 }\n             }\n         }\n-        if !already_printed {\n-            write!(self.out, \"  at {}:{}\", file.display(), line)?;\n-        }\n-\n-        self.out.write_all(b\"\\n\")\n     }\n+    fmt::Display::fmt(&file.display(), fmt)\n }"}, {"sha": "97a0f4aaec1eba117cd7f1e2ac76744ec9e54ae6", "filename": "src/test/rustdoc-ui/invalid-syntax.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.rs?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -74,3 +74,11 @@ pub fn empty_rust() {}\n ///\n /// ```\n pub fn empty_rust_with_whitespace() {}\n+\n+/// ```\n+/// let x = 1;\n+/// ```\n+///\n+///     \\____/\n+///\n+pub fn indent_after_fenced() {}"}, {"sha": "6f50edae6503408362d0a2b67a7f78319663ddb2", "filename": "src/test/rustdoc-ui/invalid-syntax.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -201,6 +201,24 @@ help: mark blocks that do not contain Rust code as text\n LL | /// ```text\n    |     ^^^^^^^\n \n+error: unknown start of token: \\\n+ --> <doctest>:1:1\n+  |\n+1 | \\____/\n+  | ^\n+\n+warning: could not parse code block as Rust code\n+  --> $DIR/invalid-syntax.rs:82:9\n+   |\n+LL | ///     \\____/\n+   |         ^^^^^^\n+\n+error: unknown start of token: \\\n+ --> <rustdoc-highlighting>:1:1\n+  |\n+1 | \\____/\n+  | ^\n+\n error: unknown start of token: \\\n  --> <rustdoc-highlighting>:1:1\n   |"}, {"sha": "5398dd63c89294873d158ebc25b1de3d1816f092", "filename": "src/test/ui/imports/unresolved-imports-used.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.rs?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -1,12 +1,18 @@\n-// There should be *no* unused import errors.\n+// There should be *one* unused import error.\n #![deny(unused_imports)]\n \n mod qux {\n    fn quz() {}\n+   pub fn quy() {}\n }\n \n-use qux::quz; //~ ERROR function `quz` is private\n-use qux::bar; //~ ERROR unresolved import `qux::bar`\n-use foo::bar; //~ ERROR unresolved import `foo`\n+use qux::quz;  //~ ERROR function `quz` is private\n+use qux::bar;  //~ ERROR unresolved import `qux::bar`\n+use foo::bar;\n+use baz::*;\n+use qux::bar2; //~ ERROR unresolved import `qux::bar2`\n+use foo2::bar2;\n+use baz2::*;\n+use qux::quy;  //~ ERROR unused import\n \n fn main() {}"}, {"sha": "c9342d17a49d7c453d99876663f0d5b18f4172be", "filename": "src/test/ui/imports/unresolved-imports-used.stderr", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c0931e168671d7536b58563dc3664c948a8dcd3/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funresolved-imports-used.stderr?ref=2c0931e168671d7536b58563dc3664c948a8dcd3", "patch": "@@ -1,22 +1,34 @@\n error[E0432]: unresolved import `qux::bar`\n-  --> $DIR/unresolved-imports-used.rs:9:5\n+  --> $DIR/unresolved-imports-used.rs:10:5\n    |\n LL | use qux::bar;\n    |     ^^^^^^^^ no `bar` in `qux`\n \n-error[E0432]: unresolved import `foo`\n-  --> $DIR/unresolved-imports-used.rs:10:5\n+error[E0432]: unresolved import `qux::bar2`\n+  --> $DIR/unresolved-imports-used.rs:13:5\n    |\n-LL | use foo::bar;\n-   |     ^^^ maybe a missing crate `foo`?\n+LL | use qux::bar2;\n+   |     ^^^^^^^^^ no `bar2` in `qux`\n \n error[E0603]: function `quz` is private\n-  --> $DIR/unresolved-imports-used.rs:8:10\n+  --> $DIR/unresolved-imports-used.rs:9:10\n    |\n LL | use qux::quz;\n    |          ^^^\n \n-error: aborting due to 3 previous errors\n+error: unused import: `qux::quy`\n+  --> $DIR/unresolved-imports-used.rs:16:5\n+   |\n+LL | use qux::quy;\n+   |     ^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/unresolved-imports-used.rs:2:9\n+   |\n+LL | #![deny(unused_imports)]\n+   |         ^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0432, E0603.\n For more information about an error, try `rustc --explain E0432`."}]}