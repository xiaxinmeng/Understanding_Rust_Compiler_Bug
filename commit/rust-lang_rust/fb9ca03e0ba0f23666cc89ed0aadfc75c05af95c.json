{"sha": "fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiOWNhMDNlMGJhMGYyMzY2NmNjODllZDBhYWRmYzc1YzA1YWY5NWM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-09T02:52:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-09T02:52:35Z"}, "message": "Rollup merge of #60458 - KodrAus:debug_map_entry, r=alexcrichton\n\nAdd key and value methods to DebugMap\n\nImplementation PR for an active (not approved) RFC: https://github.com/rust-lang/rfcs/pull/2696.\n\nAdd two new methods to `std::fmt::DebugMap` for writing the key and value part of a map entry separately:\n\n```rust\nimpl<'a, 'b: 'a> DebugMap<'a, 'b> {\n    pub fn key(&mut self, key: &dyn Debug) -> &mut Self;\n    pub fn value(&mut self, value: &dyn Debug) -> &mut Self;\n}\n```\n\nI want to do this so that I can write a `serde::Serializer` that forwards to our format builders, so that any `T: Serialize` can also be treated like a `T: Debug`.", "tree": {"sha": "a7e070e0a580f050f7e19174bfb6e0fd13b1a825", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7e070e0a580f050f7e19174bfb6e0fd13b1a825"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdJAFzCRBK7hj4Ov3rIwAAdHIIAC/7tuMhgukpNxhBBnBkmcft\n9Kq+KwLMV42AUjyseRYtsIHyn7rWHD/E15pw2G0Xl+K6EX1ATFwGnrIc6mV+Z4hx\nI8/YOACESF9QG3KzdBoNgT0j489WuTaZKc55GUtERSlhGb3STMomnc958geKRfJf\nMEWy0XlynDtG5Mx4Yluz0RG937JT3c6akAIKThewrkdE5dVqzyy4nfHod/UjBGLG\nZ4mN0snnl5eRGyPykH6DuJTfSfUYTA938BFtP6IWl/Q9fJbD5EzEkBvp14ly/ajq\nNimIPj4DD0op2QP3irT4pgBT6Rl5QEuujlB93Z4kaxIQ4ZC+VoEWdVz8Xj7xlt8=\n=IOUQ\n-----END PGP SIGNATURE-----\n", "payload": "tree a7e070e0a580f050f7e19174bfb6e0fd13b1a825\nparent 09ab31bc64f4ede9f9498440cb4225c173767c1e\nparent 70d630fd5a57d436b6a5064840b69920b10a110c\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562640755 +0200\ncommitter GitHub <noreply@github.com> 1562640755 +0200\n\nRollup merge of #60458 - KodrAus:debug_map_entry, r=alexcrichton\n\nAdd key and value methods to DebugMap\n\nImplementation PR for an active (not approved) RFC: https://github.com/rust-lang/rfcs/pull/2696.\n\nAdd two new methods to `std::fmt::DebugMap` for writing the key and value part of a map entry separately:\n\n```rust\nimpl<'a, 'b: 'a> DebugMap<'a, 'b> {\n    pub fn key(&mut self, key: &dyn Debug) -> &mut Self;\n    pub fn value(&mut self, value: &dyn Debug) -> &mut Self;\n}\n```\n\nI want to do this so that I can write a `serde::Serializer` that forwards to our format builders, so that any `T: Serialize` can also be treated like a `T: Debug`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c", "html_url": "https://github.com/rust-lang/rust/commit/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09ab31bc64f4ede9f9498440cb4225c173767c1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/09ab31bc64f4ede9f9498440cb4225c173767c1e", "html_url": "https://github.com/rust-lang/rust/commit/09ab31bc64f4ede9f9498440cb4225c173767c1e"}, {"sha": "70d630fd5a57d436b6a5064840b69920b10a110c", "url": "https://api.github.com/repos/rust-lang/rust/commits/70d630fd5a57d436b6a5064840b69920b10a110c", "html_url": "https://github.com/rust-lang/rust/commit/70d630fd5a57d436b6a5064840b69920b10a110c"}], "stats": {"total": 263, "additions": 238, "deletions": 25}, "files": [{"sha": "ae839bf2ac32b7d96c419045d2a436554ae6445a", "filename": "src/doc/unstable-book/src/library-features/debug-map-key-value.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md?ref=fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c", "patch": "@@ -0,0 +1,9 @@\n+# `debug_map_key_value`\n+\n+The tracking issue for this feature is: [#62482]\n+\n+[#62482]: https://github.com/rust-lang/rust/issues/62482\n+\n+------------------------\n+\n+Add the methods `key` and `value` to `DebugMap` so that an entry can be formatted across multiple calls without additional buffering."}, {"sha": "cb4e32622ff1f6a169725e06651d918fb02f8cf2", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 143, "deletions": 17, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c", "patch": "@@ -1,37 +1,50 @@\n use crate::fmt;\n \n-struct PadAdapter<'a> {\n-    buf: &'a mut (dyn fmt::Write + 'a),\n+struct PadAdapter<'buf, 'state> {\n+    buf: &'buf mut (dyn fmt::Write + 'buf),\n+    state: &'state mut PadAdapterState,\n+}\n+\n+struct PadAdapterState {\n     on_newline: bool,\n }\n \n-impl<'a> PadAdapter<'a> {\n-    fn wrap<'b, 'c: 'a+'b>(fmt: &'c mut fmt::Formatter<'_>, slot: &'b mut Option<Self>)\n-                        -> fmt::Formatter<'b> {\n+impl Default for PadAdapterState {\n+    fn default() -> Self {\n+        PadAdapterState {\n+            on_newline: true,\n+        }\n+    }\n+}\n+\n+impl<'buf, 'state> PadAdapter<'buf, 'state> {\n+    fn wrap<'slot, 'fmt: 'buf+'slot>(fmt: &'fmt mut fmt::Formatter<'_>,\n+                                     slot: &'slot mut Option<Self>,\n+                                     state: &'state mut PadAdapterState) -> fmt::Formatter<'slot> {\n         fmt.wrap_buf(move |buf| {\n             *slot = Some(PadAdapter {\n                 buf,\n-                on_newline: true,\n+                state,\n             });\n             slot.as_mut().unwrap()\n         })\n     }\n }\n \n-impl fmt::Write for PadAdapter<'_> {\n+impl fmt::Write for PadAdapter<'_, '_> {\n     fn write_str(&mut self, mut s: &str) -> fmt::Result {\n         while !s.is_empty() {\n-            if self.on_newline {\n+            if self.state.on_newline {\n                 self.buf.write_str(\"    \")?;\n             }\n \n             let split = match s.find('\\n') {\n                 Some(pos) => {\n-                    self.on_newline = true;\n+                    self.state.on_newline = true;\n                     pos + 1\n                 }\n                 None => {\n-                    self.on_newline = false;\n+                    self.state.on_newline = false;\n                     s.len()\n                 }\n             };\n@@ -133,7 +146,8 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n                     self.fmt.write_str(\" {\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                 writer.write_str(name)?;\n                 writer.write_str(\": \")?;\n                 value.fmt(&mut writer)?;\n@@ -279,7 +293,8 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n                     self.fmt.write_str(\"(\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                 value.fmt(&mut writer)?;\n                 writer.write_str(\",\\n\")\n             } else {\n@@ -349,7 +364,8 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n                     self.fmt.write_str(\"\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                 entry.fmt(&mut writer)?;\n                 writer.write_str(\",\\n\")\n             } else {\n@@ -676,6 +692,9 @@ pub struct DebugMap<'a, 'b: 'a> {\n     fmt: &'a mut fmt::Formatter<'b>,\n     result: fmt::Result,\n     has_fields: bool,\n+    has_key: bool,\n+    // The state of newlines is tracked between keys and values\n+    state: PadAdapterState,\n }\n \n pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n@@ -684,6 +703,8 @@ pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b\n         fmt,\n         result,\n         has_fields: false,\n+        has_key: false,\n+        state: Default::default(),\n     }\n }\n \n@@ -712,25 +733,123 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entry(&mut self, key: &dyn fmt::Debug, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+        self.key(key).value(value)\n+    }\n+\n+    /// Adds the key part of a new entry to the map output.\n+    ///\n+    /// This method, together with `value`, is an alternative to `entry` that\n+    /// can be used when the complete entry isn't known upfront. Prefer the `entry`\n+    /// method when it's possible to use.\n+    ///\n+    /// # Panics\n+    ///\n+    /// `key` must be called before `value` and each call to `key` must be followed\n+    /// by a corresponding call to `value`. Otherwise this method will panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(debug_map_key_value)]\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(Vec<(String, i32)>);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         fmt.debug_map()\n+    ///            .key(&\"whole\").value(&self.0) // We add the \"whole\" entry.\n+    ///            .finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n+    ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"debug_map_key_value\",\n+               reason = \"recently added\",\n+               issue = \"62482\")]\n+    pub fn key(&mut self, key: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+        assert!(!self.has_key, \"attempted to begin a new map entry \\\n+                                without completing the previous one\");\n+\n         self.result = self.result.and_then(|_| {\n             if self.is_pretty() {\n                 if !self.has_fields {\n                     self.fmt.write_str(\"\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                self.state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut self.state);\n                 key.fmt(&mut writer)?;\n                 writer.write_str(\": \")?;\n-                value.fmt(&mut writer)?;\n-                writer.write_str(\",\\n\")\n             } else {\n                 if self.has_fields {\n                     self.fmt.write_str(\", \")?\n                 }\n                 key.fmt(self.fmt)?;\n                 self.fmt.write_str(\": \")?;\n-                value.fmt(self.fmt)\n             }\n+\n+            self.has_key = true;\n+            Ok(())\n+        });\n+\n+        self\n+    }\n+\n+    /// Adds the value part of a new entry to the map output.\n+    ///\n+    /// This method, together with `key`, is an alternative to `entry` that\n+    /// can be used when the complete entry isn't known upfront. Prefer the `entry`\n+    /// method when it's possible to use.\n+    ///\n+    /// # Panics\n+    ///\n+    /// `key` must be called before `value` and each call to `key` must be followed\n+    /// by a corresponding call to `value`. Otherwise this method will panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(debug_map_key_value)]\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(Vec<(String, i32)>);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         fmt.debug_map()\n+    ///            .key(&\"whole\").value(&self.0) // We add the \"whole\" entry.\n+    ///            .finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n+    ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"debug_map_key_value\",\n+               reason = \"recently added\",\n+               issue = \"62482\")]\n+    pub fn value(&mut self, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+        assert!(self.has_key, \"attempted to format a map value before its key\");\n+\n+        self.result = self.result.and_then(|_| {\n+            if self.is_pretty() {\n+                let mut slot = None;\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut self.state);\n+                value.fmt(&mut writer)?;\n+                writer.write_str(\",\\n\")?;\n+            } else {\n+                value.fmt(self.fmt)?;\n+            }\n+\n+            self.has_key = false;\n+            Ok(())\n         });\n \n         self.has_fields = true;\n@@ -775,6 +894,11 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n \n     /// Finishes output and returns any error encountered.\n     ///\n+    /// # Panics\n+    ///\n+    /// `key` must be called before `value` and each call to `key` must be followed\n+    /// by a corresponding call to `value`. Otherwise this method will panic.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -797,6 +921,8 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn finish(&mut self) -> fmt::Result {\n+        assert!(!self.has_key, \"attempted to finish a map with a partial entry\");\n+\n         self.result.and_then(|_| self.fmt.write_str(\"}\"))\n     }\n "}, {"sha": "200659b91bb4ec696697e0423347c4fbb720cb3c", "filename": "src/libcore/tests/fmt/builders.rs", "status": "modified", "additions": 85, "deletions": 8, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs?ref=fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c", "patch": "@@ -211,29 +211,42 @@ mod debug_map {\n \n     #[test]\n     fn test_single() {\n-        struct Foo;\n+        struct Entry;\n \n-        impl fmt::Debug for Foo {\n+        impl fmt::Debug for Entry {\n             fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 fmt.debug_map()\n                     .entry(&\"bar\", &true)\n                     .finish()\n             }\n         }\n \n-        assert_eq!(\"{\\\"bar\\\": true}\", format!(\"{:?}\", Foo));\n+        struct KeyValue;\n+\n+        impl fmt::Debug for KeyValue {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\").value(&true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(format!(\"{:?}\", Entry), format!(\"{:?}\", KeyValue));\n+        assert_eq!(format!(\"{:#?}\", Entry), format!(\"{:#?}\", KeyValue));\n+\n+        assert_eq!(\"{\\\"bar\\\": true}\", format!(\"{:?}\", Entry));\n         assert_eq!(\n \"{\n     \\\"bar\\\": true,\n }\",\n-                   format!(\"{:#?}\", Foo));\n+                   format!(\"{:#?}\", Entry));\n     }\n \n     #[test]\n     fn test_multiple() {\n-        struct Foo;\n+        struct Entry;\n \n-        impl fmt::Debug for Foo {\n+        impl fmt::Debug for Entry {\n             fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 fmt.debug_map()\n                     .entry(&\"bar\", &true)\n@@ -242,13 +255,27 @@ mod debug_map {\n             }\n         }\n \n-        assert_eq!(\"{\\\"bar\\\": true, 10: 10/20}\", format!(\"{:?}\", Foo));\n+        struct KeyValue;\n+\n+        impl fmt::Debug for KeyValue {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\").value(&true)\n+                    .key(&10).value(&format_args!(\"{}/{}\", 10, 20))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(format!(\"{:?}\", Entry), format!(\"{:?}\", KeyValue));\n+        assert_eq!(format!(\"{:#?}\", Entry), format!(\"{:#?}\", KeyValue));\n+\n+        assert_eq!(\"{\\\"bar\\\": true, 10: 10/20}\", format!(\"{:?}\", Entry));\n         assert_eq!(\n \"{\n     \\\"bar\\\": true,\n     10: 10/20,\n }\",\n-                   format!(\"{:#?}\", Foo));\n+                   format!(\"{:#?}\", Entry));\n     }\n \n     #[test]\n@@ -291,6 +318,56 @@ mod debug_map {\n }\",\n                    format!(\"{:#?}\", Bar));\n     }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_invalid_key_when_entry_is_incomplete() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\")\n+                    .key(&\"invalid\")\n+                    .finish()\n+            }\n+        }\n+\n+        format!(\"{:?}\", Foo);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_invalid_finish_incomplete_entry() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\")\n+                    .finish()\n+            }\n+        }\n+\n+        format!(\"{:?}\", Foo);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_invalid_value_before_key() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .value(&\"invalid\")\n+                    .key(&\"bar\")\n+                    .finish()\n+            }\n+        }\n+\n+        format!(\"{:?}\", Foo);\n+    }\n }\n \n mod debug_set {"}, {"sha": "4b48d1225902b808e3aee7dde9edb2fc2baa844e", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=fb9ca03e0ba0f23666cc89ed0aadfc75c05af95c", "patch": "@@ -3,6 +3,7 @@\n #![feature(cell_update)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n+#![feature(debug_map_key_value)]\n #![feature(dec2flt)]\n #![feature(euclidean_division)]\n #![feature(exact_size_is_empty)]"}]}