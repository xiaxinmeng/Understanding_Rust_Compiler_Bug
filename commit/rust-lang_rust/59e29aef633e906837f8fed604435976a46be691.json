{"sha": "59e29aef633e906837f8fed604435976a46be691", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZTI5YWVmNjMzZTkwNjgzN2Y4ZmVkNjA0NDM1OTc2YTQ2YmU2OTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-28T01:09:44Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-28T01:09:44Z"}, "message": "Move hir to a separate crate", "tree": {"sha": "0e5aa7337c000dd8c6ef3a7fedba68abf7feca8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e5aa7337c000dd8c6ef3a7fedba68abf7feca8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59e29aef633e906837f8fed604435976a46be691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59e29aef633e906837f8fed604435976a46be691", "html_url": "https://github.com/rust-lang/rust/commit/59e29aef633e906837f8fed604435976a46be691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59e29aef633e906837f8fed604435976a46be691/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e4b710af83844f4a7c471c5335c99aaaa25a90c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e4b710af83844f4a7c471c5335c99aaaa25a90c", "html_url": "https://github.com/rust-lang/rust/commit/0e4b710af83844f4a7c471c5335c99aaaa25a90c"}], "stats": {"total": 2634, "additions": 202, "deletions": 2432}, "files": [{"sha": "bacea8dc3efefa74d37f4a9e4154ac6a15d63d19", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -604,11 +604,11 @@ name = \"ra_analysis\"\n version = \"0.1.0\"\n dependencies = [\n  \"fst 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"id-arena 1.0.2 (git+https://github.com/fitzgen/id-arena/?rev=43ecd67)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n  \"ra_editor 0.1.0\",\n+ \"ra_hir 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"rayon 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "fe9765a666811dae1f901c2930bb0996466d1b4d", "filename": "crates/ra_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2FCargo.toml?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -12,8 +12,8 @@ fst = \"0.3.1\"\n salsa = \"0.8.0\"\n rustc-hash = \"1.0\"\n parking_lot = \"0.6.4\"\n-id-arena = { git = \"https://github.com/fitzgen/id-arena/\", rev = \"43ecd67\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_editor = { path = \"../ra_editor\" }\n ra_db = { path = \"../ra_db\" }\n+hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n test_utils = { path = \"../test_utils\" }"}, {"sha": "a752ec0c11b44e8005d11478d62bc28de5071a82", "filename": "crates/ra_analysis/src/arena.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Farena.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -1,66 +0,0 @@\n-//! A simple id-based arena, similar to https://github.com/fitzgen/id-arena.\n-//! We use our own version for more compact id's and to allow inherent impls\n-//! on Ids.\n-\n-use std::{\n-    fmt,\n-    hash::{Hash, Hasher},\n-    marker::PhantomData,\n-};\n-\n-pub(crate) struct Id<T> {\n-    idx: u32,\n-    _ty: PhantomData<fn() -> T>,\n-}\n-\n-impl<T> fmt::Debug for Id<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"Id\").field(&self.idx).finish()\n-    }\n-}\n-impl<T> Copy for Id<T> {}\n-impl<T> Clone for Id<T> {\n-    fn clone(&self) -> Id<T> {\n-        *self\n-    }\n-}\n-\n-impl<T> PartialEq for Id<T> {\n-    fn eq(&self, other: &Id<T>) -> bool {\n-        self.idx == other.idx\n-    }\n-}\n-\n-impl<T> Eq for Id<T> {}\n-\n-impl<T> Hash for Id<T> {\n-    fn hash<H: Hasher>(&self, h: &mut H) {\n-        self.idx.hash(h);\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ArenaBehavior<T> {\n-    _ty: PhantomData<T>,\n-}\n-\n-impl<T> id_arena::ArenaBehavior for ArenaBehavior<T> {\n-    type Id = Id<T>;\n-    fn new_arena_id() -> usize {\n-        0\n-    }\n-    fn new_id(_arena_id: usize, index: usize) -> Id<T> {\n-        Id {\n-            idx: index as u32,\n-            _ty: PhantomData,\n-        }\n-    }\n-    fn index(id: Id<T>) -> usize {\n-        id.idx as usize\n-    }\n-    fn arena_id(_id: Id<T>) -> usize {\n-        0\n-    }\n-}\n-\n-pub(crate) type Arena<T> = id_arena::Arena<T, ArenaBehavior<T>>;"}, {"sha": "e5ba92acdea2fb61531ddfe092e2f8d7a19d93aa", "filename": "crates/ra_analysis/src/completion/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -12,7 +12,6 @@ use rustc_hash::{FxHashMap};\n \n use crate::{\n     db,\n-    hir,\n     Cancelable, FilePosition\n };\n "}, {"sha": "e1a2d52410d99127c4330dd56c69581ee67e4081", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -6,16 +6,16 @@ use ra_syntax::{\n     ast::{self, LoopBodyOwner},\n     SyntaxKind::*,\n };\n-\n-use crate::{\n-    db::RootDatabase,\n-    completion::CompletionItem,\n-    hir::{\n+use     hir::{\n         self,\n         FnScopes,\n         Def,\n         Path,\n-    },\n+};\n+\n+use crate::{\n+    db::RootDatabase,\n+    completion::CompletionItem,\n     Cancelable\n };\n "}, {"sha": "7fc3fe31badfda1aa96e37b5246bcab4253ef371", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -3,9 +3,9 @@ use std::sync::Arc;\n use parking_lot::Mutex;\n use salsa::{self, Database};\n use ra_db::{LocationIntener, BaseDatabase};\n+use hir::{self, DefId, DefLoc, FnId, SourceItemId};\n \n use crate::{\n-    hir::{self, DefId, DefLoc, FnId, SourceItemId},\n     symbol_index,\n };\n "}, {"sha": "c8ae551c5662b75bbeeb30f2d2c108faaf838f0a", "filename": "crates/ra_analysis/src/hir/db.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fdb.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -1,70 +0,0 @@\n-use std::sync::Arc;\n-\n-use ra_syntax::{\n-    SyntaxNode,\n-    ast::FnDefNode,\n-};\n-use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase};\n-\n-use crate::{\n-    FileId,\n-    hir::{\n-        DefLoc, DefId, FnId,\n-        SourceFileItems, SourceItemId,\n-        query_definitions,\n-        function::{FnScopes},\n-        module::{ModuleId, ModuleTree, ModuleSource,\n-        nameres::{ItemMap, InputModuleItems}},\n-    },\n-    Cancelable,\n-};\n-\n-salsa::query_group! {\n-\n-pub(crate) trait HirDatabase: SyntaxDatabase\n-    + AsRef<LocationIntener<DefLoc, DefId>>\n-    + AsRef<LocationIntener<SourceItemId, FnId>>\n-{\n-    fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n-        type FnScopesQuery;\n-        use fn query_definitions::fn_scopes;\n-    }\n-    fn fn_syntax(fn_id: FnId) -> FnDefNode {\n-        type FnSyntaxQuery;\n-        // Don't retain syntax trees in memory\n-        storage dependencies;\n-        use fn query_definitions::fn_syntax;\n-    }\n-\n-    fn file_items(file_id: FileId) -> Arc<SourceFileItems> {\n-        type SourceFileItemsQuery;\n-        storage dependencies;\n-        use fn query_definitions::file_items;\n-    }\n-\n-    fn file_item(source_item_id: SourceItemId) -> SyntaxNode {\n-        type FileItemQuery;\n-        storage dependencies;\n-        use fn query_definitions::file_item;\n-    }\n-\n-    fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<crate::hir::module::imp::Submodule>>> {\n-        type SubmodulesQuery;\n-        use fn query_definitions::submodules;\n-    }\n-\n-    fn input_module_items(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<InputModuleItems>> {\n-        type InputModuleItemsQuery;\n-        use fn query_definitions::input_module_items;\n-    }\n-    fn item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n-        type ItemMapQuery;\n-        use fn query_definitions::item_map;\n-    }\n-    fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n-        type ModuleTreeQuery;\n-        use fn crate::hir::module::imp::module_tree;\n-    }\n-}\n-\n-}"}, {"sha": "a399d2a9e1698dbec0d26df986604756258caa2f", "filename": "crates/ra_analysis/src/hir/function/mod.rs", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fmod.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -1,190 +0,0 @@\n-mod scope;\n-\n-use std::{\n-    cmp::{max, min},\n-    sync::Arc,\n-};\n-\n-use ra_syntax::{\n-    TextRange, TextUnit, SyntaxNodeRef,\n-    ast::{self, AstNode, DocCommentsOwner, NameOwner},\n-};\n-\n-use crate::{\n-    hir::{FnId, HirDatabase, SourceItemId},\n-    FileId,\n-};\n-\n-pub(crate) use self::scope::FnScopes;\n-\n-impl FnId {\n-    pub(crate) fn get(db: &impl HirDatabase, file_id: FileId, fn_def: ast::FnDef) -> FnId {\n-        let file_items = db.file_items(file_id);\n-        let item_id = file_items.id_of(fn_def.syntax());\n-        let item_id = SourceItemId { file_id, item_id };\n-        FnId::from_loc(db, &item_id)\n-    }\n-}\n-\n-pub(crate) struct Function {\n-    fn_id: FnId,\n-}\n-\n-impl Function {\n-    pub(crate) fn guess_from_source(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        fn_def: ast::FnDef,\n-    ) -> Function {\n-        let fn_id = FnId::get(db, file_id, fn_def);\n-        Function { fn_id }\n-    }\n-\n-    pub(crate) fn guess_for_name_ref(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        name_ref: ast::NameRef,\n-    ) -> Option<Function> {\n-        Function::guess_for_node(db, file_id, name_ref.syntax())\n-    }\n-\n-    pub(crate) fn guess_for_bind_pat(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        bind_pat: ast::BindPat,\n-    ) -> Option<Function> {\n-        Function::guess_for_node(db, file_id, bind_pat.syntax())\n-    }\n-\n-    fn guess_for_node(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        node: SyntaxNodeRef,\n-    ) -> Option<Function> {\n-        let fn_def = node.ancestors().find_map(ast::FnDef::cast)?;\n-        let res = Function::guess_from_source(db, file_id, fn_def);\n-        Some(res)\n-    }\n-\n-    pub(crate) fn scope(&self, db: &impl HirDatabase) -> Arc<FnScopes> {\n-        db.fn_scopes(self.fn_id)\n-    }\n-\n-    pub(crate) fn signature_info(&self, db: &impl HirDatabase) -> Option<FnSignatureInfo> {\n-        let syntax = db.fn_syntax(self.fn_id);\n-        FnSignatureInfo::new(syntax.borrowed())\n-    }\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct FnSignatureInfo {\n-    pub name: String,\n-    pub label: String,\n-    pub ret_type: Option<String>,\n-    pub params: Vec<String>,\n-    pub doc: Option<String>,\n-}\n-\n-impl FnSignatureInfo {\n-    fn new(node: ast::FnDef) -> Option<Self> {\n-        let name = node.name()?.text().to_string();\n-\n-        let mut doc = None;\n-\n-        // Strip the body out for the label.\n-        let mut label: String = if let Some(body) = node.body() {\n-            let body_range = body.syntax().range();\n-            let label: String = node\n-                .syntax()\n-                .children()\n-                .filter(|child| !child.range().is_subrange(&body_range))\n-                .map(|node| node.text().to_string())\n-                .collect();\n-            label\n-        } else {\n-            node.syntax().text().to_string()\n-        };\n-\n-        if let Some((comment_range, docs)) = FnSignatureInfo::extract_doc_comments(node) {\n-            let comment_range = comment_range\n-                .checked_sub(node.syntax().range().start())\n-                .unwrap();\n-            let start = comment_range.start().to_usize();\n-            let end = comment_range.end().to_usize();\n-\n-            // Remove the comment from the label\n-            label.replace_range(start..end, \"\");\n-\n-            // Massage markdown\n-            let mut processed_lines = Vec::new();\n-            let mut in_code_block = false;\n-            for line in docs.lines() {\n-                if line.starts_with(\"```\") {\n-                    in_code_block = !in_code_block;\n-                }\n-\n-                let line = if in_code_block && line.starts_with(\"```\") && !line.contains(\"rust\") {\n-                    \"```rust\".into()\n-                } else {\n-                    line.to_string()\n-                };\n-\n-                processed_lines.push(line);\n-            }\n-\n-            if !processed_lines.is_empty() {\n-                doc = Some(processed_lines.join(\"\\n\"));\n-            }\n-        }\n-\n-        let params = FnSignatureInfo::param_list(node);\n-        let ret_type = node.ret_type().map(|r| r.syntax().text().to_string());\n-\n-        Some(FnSignatureInfo {\n-            name,\n-            ret_type,\n-            params,\n-            label: label.trim().to_owned(),\n-            doc,\n-        })\n-    }\n-\n-    fn extract_doc_comments(node: ast::FnDef) -> Option<(TextRange, String)> {\n-        if node.doc_comments().count() == 0 {\n-            return None;\n-        }\n-\n-        let comment_text = node.doc_comment_text();\n-\n-        let (begin, end) = node\n-            .doc_comments()\n-            .map(|comment| comment.syntax().range())\n-            .map(|range| (range.start().to_usize(), range.end().to_usize()))\n-            .fold((std::usize::MAX, std::usize::MIN), |acc, range| {\n-                (min(acc.0, range.0), max(acc.1, range.1))\n-            });\n-\n-        let range = TextRange::from_to(TextUnit::from_usize(begin), TextUnit::from_usize(end));\n-\n-        Some((range, comment_text))\n-    }\n-\n-    fn param_list(node: ast::FnDef) -> Vec<String> {\n-        let mut res = vec![];\n-        if let Some(param_list) = node.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                res.push(self_param.syntax().text().to_string())\n-            }\n-\n-            // Maybe use param.pat here? See if we can just extract the name?\n-            //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n-            res.extend(\n-                param_list\n-                    .params()\n-                    .filter_map(|p| p.pat())\n-                    .map(|pat| pat.syntax().text().to_string()),\n-            );\n-        }\n-        res\n-    }\n-}"}, {"sha": "ed789fede2ec5c9365e15274b8ce20d180a20093", "filename": "crates/ra_analysis/src/hir/function/scope.rs", "status": "removed", "additions": 0, "deletions": 451, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Ffunction%2Fscope.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -1,451 +0,0 @@\n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n-use ra_syntax::{\n-    AstNode, SmolStr, SyntaxNodeRef, TextRange,\n-    algo::generate,\n-    ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n-};\n-use ra_db::LocalSyntaxPtr;\n-\n-use crate::{\n-\n-    arena::{Arena, Id},\n-};\n-\n-pub(crate) type ScopeId = Id<ScopeData>;\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct FnScopes {\n-    pub(crate) self_param: Option<LocalSyntaxPtr>,\n-    scopes: Arena<ScopeData>,\n-    scope_for: FxHashMap<LocalSyntaxPtr, ScopeId>,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct ScopeEntry {\n-    name: SmolStr,\n-    ptr: LocalSyntaxPtr,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ScopeData {\n-    parent: Option<ScopeId>,\n-    entries: Vec<ScopeEntry>,\n-}\n-\n-impl FnScopes {\n-    pub(crate) fn new(fn_def: ast::FnDef) -> FnScopes {\n-        let mut scopes = FnScopes {\n-            self_param: fn_def\n-                .param_list()\n-                .and_then(|it| it.self_param())\n-                .map(|it| LocalSyntaxPtr::new(it.syntax())),\n-            scopes: Arena::default(),\n-            scope_for: FxHashMap::default(),\n-        };\n-        let root = scopes.root_scope();\n-        scopes.add_params_bindings(root, fn_def.param_list());\n-        if let Some(body) = fn_def.body() {\n-            compute_block_scopes(body, &mut scopes, root)\n-        }\n-        scopes\n-    }\n-    pub(crate) fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n-    }\n-    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n-        generate(self.scope_for(node), move |&scope| {\n-            self.scopes[scope].parent\n-        })\n-    }\n-    pub(crate) fn resolve_local_name<'a>(\n-        &'a self,\n-        name_ref: ast::NameRef,\n-    ) -> Option<&'a ScopeEntry> {\n-        let mut shadowed = FxHashSet::default();\n-        let ret = self\n-            .scope_chain(name_ref.syntax())\n-            .flat_map(|scope| self.entries(scope).iter())\n-            .filter(|entry| shadowed.insert(entry.name()))\n-            .filter(|entry| entry.name() == &name_ref.text())\n-            .nth(0);\n-        ret\n-    }\n-\n-    pub fn find_all_refs(&self, pat: ast::BindPat) -> Vec<ReferenceDescriptor> {\n-        let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n-        let name_ptr = LocalSyntaxPtr::new(pat.syntax());\n-        let refs: Vec<_> = fn_def\n-            .syntax()\n-            .descendants()\n-            .filter_map(ast::NameRef::cast)\n-            .filter(|name_ref| match self.resolve_local_name(*name_ref) {\n-                None => false,\n-                Some(entry) => entry.ptr() == name_ptr,\n-            })\n-            .map(|name_ref| ReferenceDescriptor {\n-                name: name_ref.syntax().text().to_string(),\n-                range: name_ref.syntax().range(),\n-            })\n-            .collect();\n-\n-        refs\n-    }\n-\n-    fn root_scope(&mut self) -> ScopeId {\n-        self.scopes.alloc(ScopeData {\n-            parent: None,\n-            entries: vec![],\n-        })\n-    }\n-    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n-        self.scopes.alloc(ScopeData {\n-            parent: Some(parent),\n-            entries: vec![],\n-        })\n-    }\n-    fn add_bindings(&mut self, scope: ScopeId, pat: ast::Pat) {\n-        let entries = pat\n-            .syntax()\n-            .descendants()\n-            .filter_map(ast::BindPat::cast)\n-            .filter_map(ScopeEntry::new);\n-        self.scopes[scope].entries.extend(entries);\n-    }\n-    fn add_params_bindings(&mut self, scope: ScopeId, params: Option<ast::ParamList>) {\n-        params\n-            .into_iter()\n-            .flat_map(|it| it.params())\n-            .filter_map(|it| it.pat())\n-            .for_each(|it| self.add_bindings(scope, it));\n-    }\n-    fn set_scope(&mut self, node: SyntaxNodeRef, scope: ScopeId) {\n-        self.scope_for.insert(LocalSyntaxPtr::new(node), scope);\n-    }\n-    fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n-        node.ancestors()\n-            .map(LocalSyntaxPtr::new)\n-            .filter_map(|it| self.scope_for.get(&it).map(|&scope| scope))\n-            .next()\n-    }\n-}\n-\n-impl ScopeEntry {\n-    fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n-        let name = pat.name()?;\n-        let res = ScopeEntry {\n-            name: name.text(),\n-            ptr: LocalSyntaxPtr::new(pat.syntax()),\n-        };\n-        Some(res)\n-    }\n-    pub(crate) fn name(&self) -> &SmolStr {\n-        &self.name\n-    }\n-    pub(crate) fn ptr(&self) -> LocalSyntaxPtr {\n-        self.ptr\n-    }\n-}\n-\n-fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: ScopeId) {\n-    for stmt in block.statements() {\n-        match stmt {\n-            ast::Stmt::LetStmt(stmt) => {\n-                if let Some(expr) = stmt.initializer() {\n-                    scopes.set_scope(expr.syntax(), scope);\n-                    compute_expr_scopes(expr, scopes, scope);\n-                }\n-                scope = scopes.new_scope(scope);\n-                if let Some(pat) = stmt.pat() {\n-                    scopes.add_bindings(scope, pat);\n-                }\n-            }\n-            ast::Stmt::ExprStmt(expr_stmt) => {\n-                if let Some(expr) = expr_stmt.expr() {\n-                    scopes.set_scope(expr.syntax(), scope);\n-                    compute_expr_scopes(expr, scopes, scope);\n-                }\n-            }\n-        }\n-    }\n-    if let Some(expr) = block.expr() {\n-        scopes.set_scope(expr.syntax(), scope);\n-        compute_expr_scopes(expr, scopes, scope);\n-    }\n-}\n-\n-fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n-    match expr {\n-        ast::Expr::IfExpr(e) => {\n-            let cond_scope = e\n-                .condition()\n-                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n-            if let Some(block) = e.then_branch() {\n-                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n-            }\n-            if let Some(block) = e.else_branch() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::BlockExpr(e) => {\n-            if let Some(block) = e.block() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::LoopExpr(e) => {\n-            if let Some(block) = e.loop_body() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::WhileExpr(e) => {\n-            let cond_scope = e\n-                .condition()\n-                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n-            if let Some(block) = e.loop_body() {\n-                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n-            }\n-        }\n-        ast::Expr::ForExpr(e) => {\n-            if let Some(expr) = e.iterable() {\n-                compute_expr_scopes(expr, scopes, scope);\n-            }\n-            let mut scope = scope;\n-            if let Some(pat) = e.pat() {\n-                scope = scopes.new_scope(scope);\n-                scopes.add_bindings(scope, pat);\n-            }\n-            if let Some(block) = e.loop_body() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::LambdaExpr(e) => {\n-            let scope = scopes.new_scope(scope);\n-            scopes.add_params_bindings(scope, e.param_list());\n-            if let Some(body) = e.body() {\n-                scopes.set_scope(body.syntax(), scope);\n-                compute_expr_scopes(body, scopes, scope);\n-            }\n-        }\n-        ast::Expr::CallExpr(e) => {\n-            compute_call_scopes(e.expr(), e.arg_list(), scopes, scope);\n-        }\n-        ast::Expr::MethodCallExpr(e) => {\n-            compute_call_scopes(e.expr(), e.arg_list(), scopes, scope);\n-        }\n-        ast::Expr::MatchExpr(e) => {\n-            if let Some(expr) = e.expr() {\n-                compute_expr_scopes(expr, scopes, scope);\n-            }\n-            for arm in e.match_arm_list().into_iter().flat_map(|it| it.arms()) {\n-                let scope = scopes.new_scope(scope);\n-                for pat in arm.pats() {\n-                    scopes.add_bindings(scope, pat);\n-                }\n-                if let Some(expr) = arm.expr() {\n-                    compute_expr_scopes(expr, scopes, scope);\n-                }\n-            }\n-        }\n-        _ => expr\n-            .syntax()\n-            .children()\n-            .filter_map(ast::Expr::cast)\n-            .for_each(|expr| compute_expr_scopes(expr, scopes, scope)),\n-    };\n-\n-    fn compute_call_scopes(\n-        receiver: Option<ast::Expr>,\n-        arg_list: Option<ast::ArgList>,\n-        scopes: &mut FnScopes,\n-        scope: ScopeId,\n-    ) {\n-        arg_list\n-            .into_iter()\n-            .flat_map(|it| it.args())\n-            .chain(receiver)\n-            .for_each(|expr| compute_expr_scopes(expr, scopes, scope));\n-    }\n-\n-    fn compute_cond_scopes(\n-        cond: ast::Condition,\n-        scopes: &mut FnScopes,\n-        scope: ScopeId,\n-    ) -> Option<ScopeId> {\n-        if let Some(expr) = cond.expr() {\n-            compute_expr_scopes(expr, scopes, scope);\n-        }\n-        if let Some(pat) = cond.pat() {\n-            let s = scopes.new_scope(scope);\n-            scopes.add_bindings(s, pat);\n-            Some(s)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct ReferenceDescriptor {\n-    pub range: TextRange,\n-    pub name: String,\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_editor::find_node_at_offset;\n-    use ra_syntax::SourceFileNode;\n-    use test_utils::extract_offset;\n-\n-    use super::*;\n-\n-    fn do_check(code: &str, expected: &[&str]) {\n-        let (off, code) = extract_offset(code);\n-        let code = {\n-            let mut buf = String::new();\n-            let off = u32::from(off) as usize;\n-            buf.push_str(&code[..off]);\n-            buf.push_str(\"marker\");\n-            buf.push_str(&code[off..]);\n-            buf\n-        };\n-        let file = SourceFileNode::parse(&code);\n-        let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n-        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let scopes = FnScopes::new(fn_def);\n-        let actual = scopes\n-            .scope_chain(marker.syntax())\n-            .flat_map(|scope| scopes.entries(scope))\n-            .map(|it| it.name())\n-            .collect::<Vec<_>>();\n-        assert_eq!(actual.as_slice(), expected);\n-    }\n-\n-    #[test]\n-    fn test_lambda_scope() {\n-        do_check(\n-            r\"\n-            fn quux(foo: i32) {\n-                let f = |bar, baz: i32| {\n-                    <|>\n-                };\n-            }\",\n-            &[\"bar\", \"baz\", \"foo\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_metod_call_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                z.f(|x| <|> );\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_loop_scope() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                loop {\n-                    let x = ();\n-                    <|>\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_match() {\n-        do_check(\n-            r\"\n-            fn quux() {\n-                match () {\n-                    Some(x) => {\n-                        <|>\n-                    }\n-                };\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_shadow_variable() {\n-        do_check(\n-            r\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\",\n-            &[\"x\"],\n-        );\n-    }\n-\n-    fn do_check_local_name(code: &str, expected_offset: u32) {\n-        let (off, code) = extract_offset(code);\n-        let file = SourceFileNode::parse(&code);\n-        let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n-\n-        let scopes = FnScopes::new(fn_def);\n-\n-        let local_name_entry = scopes.resolve_local_name(name_ref).unwrap();\n-        let local_name = local_name_entry.ptr().resolve(&file);\n-        let expected_name =\n-            find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into()).unwrap();\n-        assert_eq!(local_name.range(), expected_name.syntax().range());\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name() {\n-        do_check_local_name(\n-            r#\"\n-            fn foo(x: i32, y: u32) {\n-                {\n-                    let z = x * 2;\n-                }\n-                {\n-                    let t = x<|> * 3;\n-                }\n-            }\"#,\n-            21,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name_declaration() {\n-        do_check_local_name(\n-            r#\"\n-            fn foo(x: String) {\n-                let x : &str = &x<|>;\n-            }\"#,\n-            21,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_resolve_local_name_shadow() {\n-        do_check_local_name(\n-            r\"\n-        fn foo(x: String) {\n-            let x : &str = &x;\n-            x<|>\n-        }\",\n-            46,\n-        );\n-    }\n-}"}, {"sha": "83131384d576e3f11c2dba7ee6817d9b3aa61e55", "filename": "crates/ra_analysis/src/hir/mod.rs", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmod.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -1,131 +0,0 @@\n-//! HIR (previsouly known as descriptors) provides a high-level OO acess to Rust\n-//! code.\n-//!\n-//! The principal difference between HIR and syntax trees is that HIR is bound\n-//! to a particular crate instance. That is, it has cfg flags and features\n-//! applied. So, there relation between syntax and HIR is many-to-one.\n-\n-pub(crate) mod db;\n-mod query_definitions;\n-mod function;\n-mod module;\n-mod path;\n-\n-use std::ops::Index;\n-\n-use ra_syntax::{SyntaxNodeRef, SyntaxNode};\n-use ra_db::{LocationIntener, SourceRootId};\n-\n-use crate::{\n-    FileId,\n-    hir::db::HirDatabase,\n-    Cancelable,\n-    arena::{Arena, Id},\n-};\n-\n-pub(crate) use self::{\n-    path::{Path, PathKind},\n-    module::{Module, ModuleId, Problem},\n-    function::{Function, FnScopes},\n-};\n-\n-pub use self::function::FnSignatureInfo;\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct FnId(u32);\n-ra_db::impl_numeric_id!(FnId);\n-\n-impl FnId {\n-    pub(crate) fn from_loc(\n-        db: &impl AsRef<LocationIntener<SourceItemId, FnId>>,\n-        loc: &SourceItemId,\n-    ) -> FnId {\n-        db.as_ref().loc2id(loc)\n-    }\n-    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<SourceItemId, FnId>>) -> SourceItemId {\n-        db.as_ref().id2loc(self)\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct DefId(u32);\n-ra_db::impl_numeric_id!(DefId);\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub(crate) enum DefLoc {\n-    Module {\n-        id: ModuleId,\n-        source_root: SourceRootId,\n-    },\n-    Item {\n-        source_item_id: SourceItemId,\n-    },\n-}\n-\n-impl DefId {\n-    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n-        db.as_ref().id2loc(self)\n-    }\n-}\n-\n-impl DefLoc {\n-    pub(crate) fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n-        db.as_ref().loc2id(&self)\n-    }\n-}\n-\n-pub(crate) enum Def {\n-    Module(Module),\n-    Item,\n-}\n-\n-impl DefId {\n-    pub(crate) fn resolve(self, db: &impl HirDatabase) -> Cancelable<Def> {\n-        let loc = self.loc(db);\n-        let res = match loc {\n-            DefLoc::Module { id, source_root } => {\n-                let descr = Module::new(db, source_root, id)?;\n-                Def::Module(descr)\n-            }\n-            DefLoc::Item { .. } => Def::Item,\n-        };\n-        Ok(res)\n-    }\n-}\n-\n-/// Identifier of item within a specific file. This is stable over reparses, so\n-/// it's OK to use it as a salsa key/value.\n-pub(crate) type SourceFileItemId = Id<SyntaxNode>;\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct SourceItemId {\n-    file_id: FileId,\n-    item_id: SourceFileItemId,\n-}\n-\n-/// Maps item's `SyntaxNode`s to `SourceFileItemId` and back.\n-#[derive(Debug, PartialEq, Eq, Default)]\n-pub(crate) struct SourceFileItems {\n-    arena: Arena<SyntaxNode>,\n-}\n-\n-impl SourceFileItems {\n-    fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n-        self.arena.alloc(item)\n-    }\n-    fn id_of(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n-        let (id, _item) = self\n-            .arena\n-            .iter()\n-            .find(|(_id, i)| i.borrowed() == item)\n-            .unwrap();\n-        id\n-    }\n-}\n-\n-impl Index<SourceFileItemId> for SourceFileItems {\n-    type Output = SyntaxNode;\n-    fn index(&self, idx: SourceFileItemId) -> &SyntaxNode {\n-        &self.arena[idx]\n-    }\n-}"}, {"sha": "c8f7ed58d19d8b687e7dd9a7694a8cf7ec1d4630", "filename": "crates/ra_analysis/src/hir/module/imp.rs", "status": "removed", "additions": 0, "deletions": 195, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fimp.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -1,195 +0,0 @@\n-use std::sync::Arc;\n-\n-use ra_syntax::{\n-    ast::{self, NameOwner},\n-    SmolStr,\n-};\n-use relative_path::RelativePathBuf;\n-use rustc_hash::{FxHashMap, FxHashSet};\n-use ra_db::{SourceRoot, SourceRootId, FileResolverImp};\n-\n-use crate::{\n-    hir::HirDatabase,\n-    Cancelable, FileId,\n-};\n-\n-use super::{\n-    LinkData, LinkId, ModuleData, ModuleId, ModuleSource,\n-    ModuleTree, Problem,\n-};\n-\n-#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n-pub(crate) enum Submodule {\n-    Declaration(SmolStr),\n-    Definition(SmolStr, ModuleSource),\n-}\n-\n-impl Submodule {\n-    fn name(&self) -> &SmolStr {\n-        match self {\n-            Submodule::Declaration(name) => name,\n-            Submodule::Definition(name, _) => name,\n-        }\n-    }\n-}\n-\n-pub(crate) fn modules<'a>(\n-    root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n-    root.items()\n-        .filter_map(|item| match item {\n-            ast::ModuleItem::Module(m) => Some(m),\n-            _ => None,\n-        })\n-        .filter_map(|module| {\n-            let name = module.name()?.text();\n-            Some((name, module))\n-        })\n-}\n-\n-pub(crate) fn module_tree(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<Arc<ModuleTree>> {\n-    db.check_canceled()?;\n-    let res = create_module_tree(db, source_root)?;\n-    Ok(Arc::new(res))\n-}\n-\n-fn create_module_tree<'a>(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<ModuleTree> {\n-    let mut tree = ModuleTree::default();\n-\n-    let mut roots = FxHashMap::default();\n-    let mut visited = FxHashSet::default();\n-\n-    let source_root = db.source_root(source_root);\n-    for &file_id in source_root.files.iter() {\n-        let source = ModuleSource::SourceFile(file_id);\n-        if visited.contains(&source) {\n-            continue; // TODO: use explicit crate_roots here\n-        }\n-        assert!(!roots.contains_key(&file_id));\n-        let module_id = build_subtree(\n-            db,\n-            &source_root,\n-            &mut tree,\n-            &mut visited,\n-            &mut roots,\n-            None,\n-            source,\n-        )?;\n-        roots.insert(file_id, module_id);\n-    }\n-    Ok(tree)\n-}\n-\n-fn build_subtree(\n-    db: &impl HirDatabase,\n-    source_root: &SourceRoot,\n-    tree: &mut ModuleTree,\n-    visited: &mut FxHashSet<ModuleSource>,\n-    roots: &mut FxHashMap<FileId, ModuleId>,\n-    parent: Option<LinkId>,\n-    source: ModuleSource,\n-) -> Cancelable<ModuleId> {\n-    visited.insert(source);\n-    let id = tree.push_mod(ModuleData {\n-        source,\n-        parent,\n-        children: Vec::new(),\n-    });\n-    for sub in db.submodules(source)?.iter() {\n-        let link = tree.push_link(LinkData {\n-            name: sub.name().clone(),\n-            owner: id,\n-            points_to: Vec::new(),\n-            problem: None,\n-        });\n-\n-        let (points_to, problem) = match sub {\n-            Submodule::Declaration(name) => {\n-                let (points_to, problem) =\n-                    resolve_submodule(source, &name, &source_root.file_resolver);\n-                let points_to = points_to\n-                    .into_iter()\n-                    .map(|file_id| match roots.remove(&file_id) {\n-                        Some(module_id) => {\n-                            tree.mods[module_id].parent = Some(link);\n-                            Ok(module_id)\n-                        }\n-                        None => build_subtree(\n-                            db,\n-                            source_root,\n-                            tree,\n-                            visited,\n-                            roots,\n-                            Some(link),\n-                            ModuleSource::SourceFile(file_id),\n-                        ),\n-                    })\n-                    .collect::<Cancelable<Vec<_>>>()?;\n-                (points_to, problem)\n-            }\n-            Submodule::Definition(_name, submodule_source) => {\n-                let points_to = build_subtree(\n-                    db,\n-                    source_root,\n-                    tree,\n-                    visited,\n-                    roots,\n-                    Some(link),\n-                    *submodule_source,\n-                )?;\n-                (vec![points_to], None)\n-            }\n-        };\n-\n-        tree.links[link].points_to = points_to;\n-        tree.links[link].problem = problem;\n-    }\n-    Ok(id)\n-}\n-\n-fn resolve_submodule(\n-    source: ModuleSource,\n-    name: &SmolStr,\n-    file_resolver: &FileResolverImp,\n-) -> (Vec<FileId>, Option<Problem>) {\n-    let file_id = match source {\n-        ModuleSource::SourceFile(it) => it,\n-        ModuleSource::Module(..) => {\n-            // TODO\n-            return (Vec::new(), None);\n-        }\n-    };\n-    let mod_name = file_resolver.file_stem(file_id);\n-    let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n-\n-    let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", name));\n-    let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", name));\n-    let points_to: Vec<FileId>;\n-    let problem: Option<Problem>;\n-    if is_dir_owner {\n-        points_to = [&file_mod, &dir_mod]\n-            .iter()\n-            .filter_map(|path| file_resolver.resolve(file_id, path))\n-            .collect();\n-        problem = if points_to.is_empty() {\n-            Some(Problem::UnresolvedModule {\n-                candidate: file_mod,\n-            })\n-        } else {\n-            None\n-        }\n-    } else {\n-        points_to = Vec::new();\n-        problem = Some(Problem::NotDirOwner {\n-            move_to: RelativePathBuf::from(format!(\"../{}/mod.rs\", mod_name)),\n-            candidate: file_mod,\n-        });\n-    }\n-    (points_to, problem)\n-}"}, {"sha": "d2096b01e73ca0d52438616f17f777a9d1443eda", "filename": "crates/ra_analysis/src/hir/module/mod.rs", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fmod.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -1,379 +0,0 @@\n-pub(super) mod imp;\n-pub(super) mod nameres;\n-\n-use std::sync::Arc;\n-\n-use ra_editor::find_node_at_offset;\n-\n-use ra_syntax::{\n-    algo::generate,\n-    ast::{self, AstNode, NameOwner},\n-    SmolStr, SyntaxNode,\n-};\n-use ra_db::SourceRootId;\n-use relative_path::RelativePathBuf;\n-\n-use crate::{\n-    FileId, FilePosition, Cancelable,\n-    hir::{DefLoc, DefId, Path, PathKind, HirDatabase, SourceItemId},\n-    arena::{Arena, Id},\n-};\n-\n-pub(crate) use self::nameres::ModuleScope;\n-\n-/// `Module` is API entry point to get all the information\n-/// about a particular module.\n-#[derive(Debug, Clone)]\n-pub(crate) struct Module {\n-    tree: Arc<ModuleTree>,\n-    source_root_id: SourceRootId,\n-    module_id: ModuleId,\n-}\n-\n-impl Module {\n-    /// Lookup `Module` by `FileId`. Note that this is inherently\n-    /// lossy transformation: in general, a single source might correspond to\n-    /// several modules.\n-    pub fn guess_from_file_id(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-    ) -> Cancelable<Option<Module>> {\n-        Module::guess_from_source(db, file_id, ModuleSource::SourceFile(file_id))\n-    }\n-\n-    /// Lookup `Module` by position in the source code. Note that this\n-    /// is inherently lossy transformation: in general, a single source might\n-    /// correspond to several modules.\n-    pub fn guess_from_position(\n-        db: &impl HirDatabase,\n-        position: FilePosition,\n-    ) -> Cancelable<Option<Module>> {\n-        let file = db.source_file(position.file_id);\n-        let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n-        {\n-            Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id, m),\n-            _ => ModuleSource::SourceFile(position.file_id),\n-        };\n-        Module::guess_from_source(db, position.file_id, module_source)\n-    }\n-\n-    fn guess_from_source(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        module_source: ModuleSource,\n-    ) -> Cancelable<Option<Module>> {\n-        let source_root_id = db.file_source_root(file_id);\n-        let module_tree = db.module_tree(source_root_id)?;\n-\n-        let res = match module_tree.any_module_for_source(module_source) {\n-            None => None,\n-            Some(module_id) => Some(Module {\n-                tree: module_tree,\n-                source_root_id,\n-                module_id,\n-            }),\n-        };\n-        Ok(res)\n-    }\n-\n-    pub(super) fn new(\n-        db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Cancelable<Module> {\n-        let module_tree = db.module_tree(source_root_id)?;\n-        let res = Module {\n-            tree: module_tree,\n-            source_root_id,\n-            module_id,\n-        };\n-        Ok(res)\n-    }\n-\n-    /// Returns `mod foo;` or `mod foo {}` node whihc declared this module.\n-    /// Returns `None` for the root module\n-    pub fn parent_link_source(&self, db: &impl HirDatabase) -> Option<(FileId, ast::ModuleNode)> {\n-        let link = self.module_id.parent_link(&self.tree)?;\n-        let file_id = link.owner(&self.tree).source(&self.tree).file_id();\n-        let src = link.bind_source(&self.tree, db);\n-        Some((file_id, src))\n-    }\n-\n-    pub fn source(&self) -> ModuleSource {\n-        self.module_id.source(&self.tree)\n-    }\n-\n-    /// Parent module. Returns `None` if this is a root module.\n-    pub fn parent(&self) -> Option<Module> {\n-        let parent_id = self.module_id.parent(&self.tree)?;\n-        Some(Module {\n-            module_id: parent_id,\n-            ..self.clone()\n-        })\n-    }\n-\n-    /// The root of the tree this module is part of\n-    pub fn crate_root(&self) -> Module {\n-        let root_id = self.module_id.crate_root(&self.tree);\n-        Module {\n-            module_id: root_id,\n-            ..self.clone()\n-        }\n-    }\n-\n-    /// `name` is `None` for the crate's root module\n-    #[allow(unused)]\n-    pub fn name(&self) -> Option<SmolStr> {\n-        let link = self.module_id.parent_link(&self.tree)?;\n-        Some(link.name(&self.tree))\n-    }\n-\n-    pub fn def_id(&self, db: &impl HirDatabase) -> DefId {\n-        let def_loc = DefLoc::Module {\n-            id: self.module_id,\n-            source_root: self.source_root_id,\n-        };\n-        def_loc.id(db)\n-    }\n-\n-    /// Finds a child module with the specified name.\n-    pub fn child(&self, name: &str) -> Option<Module> {\n-        let child_id = self.module_id.child(&self.tree, name)?;\n-        Some(Module {\n-            module_id: child_id,\n-            ..self.clone()\n-        })\n-    }\n-\n-    /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub(crate) fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n-        let item_map = db.item_map(self.source_root_id)?;\n-        let res = item_map.per_module[&self.module_id].clone();\n-        Ok(res)\n-    }\n-\n-    pub(crate) fn resolve_path(\n-        &self,\n-        db: &impl HirDatabase,\n-        path: Path,\n-    ) -> Cancelable<Option<DefId>> {\n-        let mut curr = match path.kind {\n-            PathKind::Crate => self.crate_root(),\n-            PathKind::Self_ | PathKind::Plain => self.clone(),\n-            PathKind::Super => ctry!(self.parent()),\n-        }\n-        .def_id(db);\n-\n-        let segments = path.segments;\n-        for name in segments.iter() {\n-            let module = match curr.loc(db) {\n-                DefLoc::Module { id, source_root } => Module::new(db, source_root, id)?,\n-                _ => return Ok(None),\n-            };\n-            let scope = module.scope(db)?;\n-            curr = ctry!(ctry!(scope.get(&name)).def_id);\n-        }\n-        Ok(Some(curr))\n-    }\n-\n-    pub fn problems(&self, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n-        self.module_id.problems(&self.tree, db)\n-    }\n-}\n-\n-/// Phisically, rust source is organized as a set of files, but logically it is\n-/// organized as a tree of modules. Usually, a single file corresponds to a\n-/// single module, but it is not nessary the case.\n-///\n-/// Module encapsulate the logic of transitioning from the fuzzy world of files\n-/// (which can have multiple parents) to the precise world of modules (which\n-/// always have one parent).\n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct ModuleTree {\n-    mods: Arena<ModuleData>,\n-    links: Arena<LinkData>,\n-}\n-\n-impl ModuleTree {\n-    pub(in crate::hir) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n-        self.mods.iter().map(|(id, _)| id)\n-    }\n-\n-    fn modules_for_source(&self, source: ModuleSource) -> Vec<ModuleId> {\n-        self.mods\n-            .iter()\n-            .filter(|(_idx, it)| it.source == source)\n-            .map(|(idx, _)| idx)\n-            .collect()\n-    }\n-\n-    fn any_module_for_source(&self, source: ModuleSource) -> Option<ModuleId> {\n-        self.modules_for_source(source).pop()\n-    }\n-}\n-\n-/// `ModuleSource` is the syntax tree element that produced this module:\n-/// either a file, or an inlinde module.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub(crate) enum ModuleSource {\n-    SourceFile(FileId),\n-    Module(SourceItemId),\n-}\n-\n-/// An owned syntax node for a module. Unlike `ModuleSource`,\n-/// this holds onto the AST for the whole file.\n-pub(crate) enum ModuleSourceNode {\n-    SourceFile(ast::SourceFileNode),\n-    Module(ast::ModuleNode),\n-}\n-\n-pub(crate) type ModuleId = Id<ModuleData>;\n-type LinkId = Id<LinkData>;\n-\n-#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Problem {\n-    UnresolvedModule {\n-        candidate: RelativePathBuf,\n-    },\n-    NotDirOwner {\n-        move_to: RelativePathBuf,\n-        candidate: RelativePathBuf,\n-    },\n-}\n-\n-impl ModuleId {\n-    pub(in crate::hir) fn source(self, tree: &ModuleTree) -> ModuleSource {\n-        tree.mods[self].source\n-    }\n-    fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n-        tree.mods[self].parent\n-    }\n-    fn parent(self, tree: &ModuleTree) -> Option<ModuleId> {\n-        let link = self.parent_link(tree)?;\n-        Some(tree.links[link].owner)\n-    }\n-    fn crate_root(self, tree: &ModuleTree) -> ModuleId {\n-        generate(Some(self), move |it| it.parent(tree))\n-            .last()\n-            .unwrap()\n-    }\n-    fn child(self, tree: &ModuleTree, name: &str) -> Option<ModuleId> {\n-        let link = tree.mods[self]\n-            .children\n-            .iter()\n-            .map(|&it| &tree.links[it])\n-            .find(|it| it.name == name)?;\n-        Some(*link.points_to.first()?)\n-    }\n-    fn children<'a>(self, tree: &'a ModuleTree) -> impl Iterator<Item = (SmolStr, ModuleId)> + 'a {\n-        tree.mods[self].children.iter().filter_map(move |&it| {\n-            let link = &tree.links[it];\n-            let module = *link.points_to.first()?;\n-            Some((link.name.clone(), module))\n-        })\n-    }\n-    fn problems(self, tree: &ModuleTree, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n-        tree.mods[self]\n-            .children\n-            .iter()\n-            .filter_map(|&it| {\n-                let p = tree.links[it].problem.clone()?;\n-                let s = it.bind_source(tree, db);\n-                let s = s.borrowed().name().unwrap().syntax().owned();\n-                Some((s, p))\n-            })\n-            .collect()\n-    }\n-}\n-\n-impl LinkId {\n-    fn owner(self, tree: &ModuleTree) -> ModuleId {\n-        tree.links[self].owner\n-    }\n-    fn name(self, tree: &ModuleTree) -> SmolStr {\n-        tree.links[self].name.clone()\n-    }\n-    fn bind_source<'a>(self, tree: &ModuleTree, db: &impl HirDatabase) -> ast::ModuleNode {\n-        let owner = self.owner(tree);\n-        match owner.source(tree).resolve(db) {\n-            ModuleSourceNode::SourceFile(root) => {\n-                let ast = imp::modules(root.borrowed())\n-                    .find(|(name, _)| name == &tree.links[self].name)\n-                    .unwrap()\n-                    .1;\n-                ast.owned()\n-            }\n-            ModuleSourceNode::Module(it) => it,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Hash)]\n-pub(crate) struct ModuleData {\n-    source: ModuleSource,\n-    parent: Option<LinkId>,\n-    children: Vec<LinkId>,\n-}\n-\n-impl ModuleSource {\n-    pub(crate) fn new_inline(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        module: ast::Module,\n-    ) -> ModuleSource {\n-        assert!(!module.has_semi());\n-        let items = db.file_items(file_id);\n-        let item_id = items.id_of(module.syntax());\n-        let id = SourceItemId { file_id, item_id };\n-        ModuleSource::Module(id)\n-    }\n-\n-    pub(crate) fn as_file(self) -> Option<FileId> {\n-        match self {\n-            ModuleSource::SourceFile(f) => Some(f),\n-            ModuleSource::Module(..) => None,\n-        }\n-    }\n-\n-    pub(crate) fn file_id(self) -> FileId {\n-        match self {\n-            ModuleSource::SourceFile(f) => f,\n-            ModuleSource::Module(source_item_id) => source_item_id.file_id,\n-        }\n-    }\n-\n-    pub(crate) fn resolve(self, db: &impl HirDatabase) -> ModuleSourceNode {\n-        match self {\n-            ModuleSource::SourceFile(file_id) => {\n-                let syntax = db.source_file(file_id);\n-                ModuleSourceNode::SourceFile(syntax.ast().owned())\n-            }\n-            ModuleSource::Module(item_id) => {\n-                let syntax = db.file_item(item_id);\n-                let syntax = syntax.borrowed();\n-                let module = ast::Module::cast(syntax).unwrap();\n-                ModuleSourceNode::Module(module.owned())\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Hash, Debug, PartialEq, Eq)]\n-struct LinkData {\n-    owner: ModuleId,\n-    name: SmolStr,\n-    points_to: Vec<ModuleId>,\n-    problem: Option<Problem>,\n-}\n-\n-impl ModuleTree {\n-    fn push_mod(&mut self, data: ModuleData) -> ModuleId {\n-        self.mods.alloc(data)\n-    }\n-    fn push_link(&mut self, data: LinkData) -> LinkId {\n-        let owner = data.owner;\n-        let id = self.links.alloc(data);\n-        self.mods[owner].children.push(id);\n-        id\n-    }\n-}"}, {"sha": "d4ecc010b1c81670704f4812cac92a155480c4be", "filename": "crates/ra_analysis/src/hir/module/nameres.rs", "status": "removed", "additions": 0, "deletions": 446, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fmodule%2Fnameres.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -1,446 +0,0 @@\n-//! Name resolution algorithm. The end result of the algorithm is `ItemMap`: a\n-//! map with maps each module to it's scope: the set of items, visible in the\n-//! module. That is, we only resolve imports here, name resolution of item\n-//! bodies will be done in a separate step.\n-//!\n-//! Like Rustc, we use an interative per-crate algorithm: we start with scopes\n-//! containing only directly defined items, and then iteratively resolve\n-//! imports.\n-//!\n-//! To make this work nicely in the IDE scenarios, we place `InputModuleItems`\n-//! in between raw syntax and name resolution. `InputModuleItems` are computed\n-//! using only the module's syntax, and it is all directly defined items plus\n-//! imports. The plain is to make `InputModuleItems` independent of local\n-//! modifications (that is, typing inside a function shold not change IMIs),\n-//! such that the results of name resolution can be preserved unless the module\n-//! structure itself is modified.\n-use std::{\n-    sync::Arc,\n-};\n-\n-use rustc_hash::FxHashMap;\n-use ra_syntax::{\n-    TextRange,\n-    SmolStr, SyntaxKind::{self, *},\n-    ast::{self, AstNode}\n-};\n-use ra_db::SourceRootId;\n-\n-use crate::{\n-    Cancelable, FileId,\n-    hir::{\n-        DefId, DefLoc,\n-        SourceItemId, SourceFileItemId, SourceFileItems,\n-        Path, PathKind,\n-        HirDatabase,\n-        module::{ModuleId, ModuleTree},\n-    },\n-};\n-\n-/// Item map is the result of the name resolution. Item map contains, for each\n-/// module, the set of visible items.\n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct ItemMap {\n-    pub(crate) per_module: FxHashMap<ModuleId, ModuleScope>,\n-}\n-\n-#[derive(Debug, Default, PartialEq, Eq, Clone)]\n-pub(crate) struct ModuleScope {\n-    items: FxHashMap<SmolStr, Resolution>,\n-}\n-\n-impl ModuleScope {\n-    pub(crate) fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a SmolStr, &Resolution)> + 'a {\n-        self.items.iter()\n-    }\n-    pub(crate) fn get(&self, name: &SmolStr) -> Option<&Resolution> {\n-        self.items.get(name)\n-    }\n-}\n-\n-/// A set of items and imports declared inside a module, without relation to\n-/// other modules.\n-///\n-/// This stands in-between raw syntax and name resolution and alow us to avoid\n-/// recomputing name res: if `InputModuleItems` are the same, we can avoid\n-/// running name resolution.\n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub(crate) struct InputModuleItems {\n-    items: Vec<ModuleItem>,\n-    imports: Vec<Import>,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-struct ModuleItem {\n-    id: SourceFileItemId,\n-    name: SmolStr,\n-    kind: SyntaxKind,\n-    vis: Vis,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-enum Vis {\n-    // Priv,\n-    Other,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-struct Import {\n-    path: Path,\n-    kind: ImportKind,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub(crate) struct NamedImport {\n-    file_item_id: SourceFileItemId,\n-    relative_range: TextRange,\n-}\n-\n-impl NamedImport {\n-    pub(crate) fn range(&self, db: &impl HirDatabase, file_id: FileId) -> TextRange {\n-        let source_item_id = SourceItemId {\n-            file_id,\n-            item_id: self.file_item_id,\n-        };\n-        let syntax = db.file_item(source_item_id);\n-        let offset = syntax.borrowed().range().start();\n-        self.relative_range + offset\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-enum ImportKind {\n-    Glob,\n-    Named(NamedImport),\n-}\n-\n-/// Resolution is basically `DefId` atm, but it should account for stuff like\n-/// multiple namespaces, ambiguity and errors.\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub(crate) struct Resolution {\n-    /// None for unresolved\n-    pub(crate) def_id: Option<DefId>,\n-    /// ident by whitch this is imported into local scope.\n-    pub(crate) import: Option<NamedImport>,\n-}\n-\n-// #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-// enum Namespace {\n-//     Types,\n-//     Values,\n-// }\n-\n-// #[derive(Debug)]\n-// struct PerNs<T> {\n-//     types: Option<T>,\n-//     values: Option<T>,\n-// }\n-\n-impl InputModuleItems {\n-    pub(in crate::hir) fn new<'a>(\n-        file_items: &SourceFileItems,\n-        items: impl Iterator<Item = ast::ModuleItem<'a>>,\n-    ) -> InputModuleItems {\n-        let mut res = InputModuleItems::default();\n-        for item in items {\n-            res.add_item(file_items, item);\n-        }\n-        res\n-    }\n-\n-    fn add_item(&mut self, file_items: &SourceFileItems, item: ast::ModuleItem) -> Option<()> {\n-        match item {\n-            ast::ModuleItem::StructDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::EnumDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::FnDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::TraitDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::TypeDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::ImplItem(_) => {\n-                // impls don't define items\n-            }\n-            ast::ModuleItem::UseItem(it) => self.add_use_item(file_items, it),\n-            ast::ModuleItem::ExternCrateItem(_) => {\n-                // TODO\n-            }\n-            ast::ModuleItem::ConstDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::StaticDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-            ast::ModuleItem::Module(it) => self.items.push(ModuleItem::new(file_items, it)?),\n-        }\n-        Some(())\n-    }\n-\n-    fn add_use_item(&mut self, file_items: &SourceFileItems, item: ast::UseItem) {\n-        let file_item_id = file_items.id_of(item.syntax());\n-        let start_offset = item.syntax().range().start();\n-        Path::expand_use_item(item, |path, range| {\n-            let kind = match range {\n-                None => ImportKind::Glob,\n-                Some(range) => ImportKind::Named(NamedImport {\n-                    file_item_id,\n-                    relative_range: range - start_offset,\n-                }),\n-            };\n-            self.imports.push(Import { kind, path })\n-        })\n-    }\n-}\n-\n-impl ModuleItem {\n-    fn new<'a>(file_items: &SourceFileItems, item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n-        let name = item.name()?.text();\n-        let kind = item.syntax().kind();\n-        let vis = Vis::Other;\n-        let id = file_items.id_of(item.syntax());\n-        let res = ModuleItem {\n-            id,\n-            name,\n-            kind,\n-            vis,\n-        };\n-        Some(res)\n-    }\n-}\n-\n-pub(in crate::hir) struct Resolver<'a, DB> {\n-    pub db: &'a DB,\n-    pub input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n-    pub source_root: SourceRootId,\n-    pub module_tree: Arc<ModuleTree>,\n-    pub result: ItemMap,\n-}\n-\n-impl<'a, DB> Resolver<'a, DB>\n-where\n-    DB: HirDatabase,\n-{\n-    pub(in crate::hir) fn resolve(mut self) -> Cancelable<ItemMap> {\n-        for (&module_id, items) in self.input.iter() {\n-            self.populate_module(module_id, items)\n-        }\n-\n-        for &module_id in self.input.keys() {\n-            self.db.check_canceled()?;\n-            self.resolve_imports(module_id);\n-        }\n-        Ok(self.result)\n-    }\n-\n-    fn populate_module(&mut self, module_id: ModuleId, input: &InputModuleItems) {\n-        let file_id = module_id.source(&self.module_tree).file_id();\n-\n-        let mut module_items = ModuleScope::default();\n-\n-        for import in input.imports.iter() {\n-            if let Some(name) = import.path.segments.iter().last() {\n-                if let ImportKind::Named(import) = import.kind {\n-                    module_items.items.insert(\n-                        name.clone(),\n-                        Resolution {\n-                            def_id: None,\n-                            import: Some(import),\n-                        },\n-                    );\n-                }\n-            }\n-        }\n-\n-        for item in input.items.iter() {\n-            if item.kind == MODULE {\n-                // handle submodules separatelly\n-                continue;\n-            }\n-            let def_loc = DefLoc::Item {\n-                source_item_id: SourceItemId {\n-                    file_id,\n-                    item_id: item.id,\n-                },\n-            };\n-            let def_id = def_loc.id(self.db);\n-            let resolution = Resolution {\n-                def_id: Some(def_id),\n-                import: None,\n-            };\n-            module_items.items.insert(item.name.clone(), resolution);\n-        }\n-\n-        for (name, mod_id) in module_id.children(&self.module_tree) {\n-            let def_loc = DefLoc::Module {\n-                id: mod_id,\n-                source_root: self.source_root,\n-            };\n-            let def_id = def_loc.id(self.db);\n-            let resolution = Resolution {\n-                def_id: Some(def_id),\n-                import: None,\n-            };\n-            module_items.items.insert(name, resolution);\n-        }\n-\n-        self.result.per_module.insert(module_id, module_items);\n-    }\n-\n-    fn resolve_imports(&mut self, module_id: ModuleId) {\n-        for import in self.input[&module_id].imports.iter() {\n-            self.resolve_import(module_id, import);\n-        }\n-    }\n-\n-    fn resolve_import(&mut self, module_id: ModuleId, import: &Import) {\n-        let ptr = match import.kind {\n-            ImportKind::Glob => return,\n-            ImportKind::Named(ptr) => ptr,\n-        };\n-\n-        let mut curr = match import.path.kind {\n-            // TODO: handle extern crates\n-            PathKind::Plain => return,\n-            PathKind::Self_ => module_id,\n-            PathKind::Super => {\n-                match module_id.parent(&self.module_tree) {\n-                    Some(it) => it,\n-                    // TODO: error\n-                    None => return,\n-                }\n-            }\n-            PathKind::Crate => module_id.crate_root(&self.module_tree),\n-        };\n-\n-        for (i, name) in import.path.segments.iter().enumerate() {\n-            let is_last = i == import.path.segments.len() - 1;\n-\n-            let def_id = match self.result.per_module[&curr].items.get(name) {\n-                None => return,\n-                Some(res) => match res.def_id {\n-                    Some(it) => it,\n-                    None => return,\n-                },\n-            };\n-\n-            if !is_last {\n-                curr = match def_id.loc(self.db) {\n-                    DefLoc::Module { id, .. } => id,\n-                    _ => return,\n-                }\n-            } else {\n-                self.update(module_id, |items| {\n-                    let res = Resolution {\n-                        def_id: Some(def_id),\n-                        import: Some(ptr),\n-                    };\n-                    items.items.insert(name.clone(), res);\n-                })\n-            }\n-        }\n-    }\n-\n-    fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {\n-        let module_items = self.result.per_module.get_mut(&module_id).unwrap();\n-        f(module_items)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_db::FilesDatabase;\n-    use crate::{\n-        AnalysisChange,\n-        mock_analysis::{MockAnalysis, analysis_and_position},\n-        hir::{self, HirDatabase},\n-};\n-    use super::*;\n-\n-    fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n-        let (analysis, pos) = analysis_and_position(fixture);\n-        let db = analysis.imp.db;\n-        let source_root = db.file_source_root(pos.file_id);\n-        let descr = hir::Module::guess_from_position(&*db, pos)\n-            .unwrap()\n-            .unwrap();\n-        let module_id = descr.module_id;\n-        (db.item_map(source_root).unwrap(), module_id)\n-    }\n-\n-    #[test]\n-    fn test_item_map() {\n-        let (item_map, module_id) = item_map(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-            <|>\n-\n-            //- /foo/mod.rs\n-            pub mod bar;\n-\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-        \",\n-        );\n-        let name = SmolStr::from(\"Baz\");\n-        let resolution = &item_map.per_module[&module_id].items[&name];\n-        assert!(resolution.def_id.is_some());\n-    }\n-\n-    #[test]\n-    fn typing_inside_a_function_should_not_invalidate_item_map() {\n-        let mock_analysis = MockAnalysis::with_files(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-\n-            fn foo() -> i32 {\n-                1 + 1\n-            }\n-            //- /foo/mod.rs\n-            pub mod bar;\n-\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-        \",\n-        );\n-\n-        let file_id = mock_analysis.id_of(\"/lib.rs\");\n-        let mut host = mock_analysis.analysis_host();\n-\n-        let source_root = host.analysis().imp.db.file_source_root(file_id);\n-\n-        {\n-            let db = host.analysis().imp.db;\n-            let events = db.log_executed(|| {\n-                db.item_map(source_root).unwrap();\n-            });\n-            assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n-        }\n-\n-        let mut change = AnalysisChange::new();\n-\n-        change.change_file(\n-            file_id,\n-            \"\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-\n-            fn foo() -> i32 { 92 }\n-        \"\n-            .to_string(),\n-        );\n-\n-        host.apply_change(change);\n-\n-        {\n-            let db = host.analysis().imp.db;\n-            let events = db.log_executed(|| {\n-                db.item_map(source_root).unwrap();\n-            });\n-            assert!(\n-                !format!(\"{:?}\", events).contains(\"_item_map\"),\n-                \"{:#?}\",\n-                events\n-            )\n-        }\n-    }\n-}"}, {"sha": "8279daf4bf6e0a27a549f57c1d3cbbf0895d35f1", "filename": "crates/ra_analysis/src/hir/path.rs", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fpath.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -1,148 +0,0 @@\n-use ra_syntax::{SmolStr, ast, AstNode, TextRange};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub(crate) struct Path {\n-    pub(crate) kind: PathKind,\n-    pub(crate) segments: Vec<SmolStr>,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub(crate) enum PathKind {\n-    Plain,\n-    Self_,\n-    Super,\n-    Crate,\n-}\n-\n-impl Path {\n-    /// Calls `cb` with all paths, represented by this use item.\n-    pub(crate) fn expand_use_item(item: ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n-        if let Some(tree) = item.use_tree() {\n-            expand_use_tree(None, tree, &mut cb);\n-        }\n-    }\n-\n-    /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    pub(crate) fn from_ast(mut path: ast::Path) -> Option<Path> {\n-        let mut kind = PathKind::Plain;\n-        let mut segments = Vec::new();\n-        loop {\n-            let segment = path.segment()?;\n-            match segment.kind()? {\n-                ast::PathSegmentKind::Name(name) => segments.push(name.text()),\n-                ast::PathSegmentKind::CrateKw => {\n-                    kind = PathKind::Crate;\n-                    break;\n-                }\n-                ast::PathSegmentKind::SelfKw => {\n-                    kind = PathKind::Self_;\n-                    break;\n-                }\n-                ast::PathSegmentKind::SuperKw => {\n-                    kind = PathKind::Super;\n-                    break;\n-                }\n-            }\n-            path = match qualifier(path) {\n-                Some(it) => it,\n-                None => break,\n-            };\n-        }\n-        segments.reverse();\n-        return Some(Path { kind, segments });\n-\n-        fn qualifier(path: ast::Path) -> Option<ast::Path> {\n-            if let Some(q) = path.qualifier() {\n-                return Some(q);\n-            }\n-            // TODO: this bottom up traversal is not too precise.\n-            // Should we handle do a top-down analysiss, recording results?\n-            let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n-            let use_tree = use_tree_list.parent_use_tree();\n-            use_tree.path()\n-        }\n-    }\n-\n-    /// `true` is this path is a single identifier, like `foo`\n-    pub(crate) fn is_ident(&self) -> bool {\n-        self.kind == PathKind::Plain && self.segments.len() == 1\n-    }\n-}\n-\n-fn expand_use_tree(\n-    prefix: Option<Path>,\n-    tree: ast::UseTree,\n-    cb: &mut impl FnMut(Path, Option<TextRange>),\n-) {\n-    if let Some(use_tree_list) = tree.use_tree_list() {\n-        let prefix = match tree.path() {\n-            None => prefix,\n-            Some(path) => match convert_path(prefix, path) {\n-                Some(it) => Some(it),\n-                None => return, // TODO: report errors somewhere\n-            },\n-        };\n-        for tree in use_tree_list.use_trees() {\n-            expand_use_tree(prefix.clone(), tree, cb);\n-        }\n-    } else {\n-        if let Some(ast_path) = tree.path() {\n-            if let Some(path) = convert_path(prefix, ast_path) {\n-                let range = if tree.has_star() {\n-                    None\n-                } else {\n-                    let range = ast_path.segment().unwrap().syntax().range();\n-                    Some(range)\n-                };\n-                cb(path, range)\n-            }\n-        }\n-    }\n-}\n-\n-fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n-    let prefix = if let Some(qual) = path.qualifier() {\n-        Some(convert_path(prefix, qual)?)\n-    } else {\n-        None\n-    };\n-    let segment = path.segment()?;\n-    let res = match segment.kind()? {\n-        ast::PathSegmentKind::Name(name) => {\n-            let mut res = prefix.unwrap_or_else(|| Path {\n-                kind: PathKind::Plain,\n-                segments: Vec::with_capacity(1),\n-            });\n-            res.segments.push(name.text());\n-            res\n-        }\n-        ast::PathSegmentKind::CrateKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path {\n-                kind: PathKind::Crate,\n-                segments: Vec::new(),\n-            }\n-        }\n-        ast::PathSegmentKind::SelfKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path {\n-                kind: PathKind::Self_,\n-                segments: Vec::new(),\n-            }\n-        }\n-        ast::PathSegmentKind::SuperKw => {\n-            if prefix.is_some() {\n-                return None;\n-            }\n-            Path {\n-                kind: PathKind::Super,\n-                segments: Vec::new(),\n-            }\n-        }\n-    };\n-    Some(res)\n-}"}, {"sha": "00237b633a5c589bb51efc72e769bdf9470318f4", "filename": "crates/ra_analysis/src/hir/query_definitions.rs", "status": "removed", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4b710af83844f4a7c471c5335c99aaaa25a90c/crates%2Fra_analysis%2Fsrc%2Fhir%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhir%2Fquery_definitions.rs?ref=0e4b710af83844f4a7c471c5335c99aaaa25a90c", "patch": "@@ -1,157 +0,0 @@\n-use std::{\n-    sync::Arc,\n-    time::Instant,\n-};\n-\n-use rustc_hash::FxHashMap;\n-use ra_syntax::{\n-    AstNode,  SyntaxNode, SmolStr,\n-    ast::{self, FnDef, FnDefNode, NameOwner, ModuleItemOwner}\n-};\n-use ra_db::SourceRootId;\n-\n-use crate::{\n-    FileId, Cancelable,\n-    hir::{\n-        FnId,\n-        SourceFileItems, SourceItemId,\n-        db::HirDatabase,\n-        function::FnScopes,\n-        module::{\n-            ModuleSource, ModuleSourceNode, ModuleId,\n-            imp::Submodule,\n-            nameres::{InputModuleItems, ItemMap, Resolver},\n-        },\n-    },\n-};\n-\n-/// Resolve `FnId` to the corresponding `SyntaxNode`\n-pub(super) fn fn_syntax(db: &impl HirDatabase, fn_id: FnId) -> FnDefNode {\n-    let item_id = fn_id.loc(db);\n-    let syntax = db.file_item(item_id);\n-    FnDef::cast(syntax.borrowed()).unwrap().owned()\n-}\n-\n-pub(super) fn fn_scopes(db: &impl HirDatabase, fn_id: FnId) -> Arc<FnScopes> {\n-    let syntax = db.fn_syntax(fn_id);\n-    let res = FnScopes::new(syntax.borrowed());\n-    Arc::new(res)\n-}\n-\n-pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<SourceFileItems> {\n-    let source_file = db.source_file(file_id);\n-    let source_file = source_file.borrowed();\n-    let mut res = SourceFileItems::default();\n-    source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(ast::ModuleItem::cast)\n-        .map(|it| it.syntax().owned())\n-        .for_each(|it| {\n-            res.alloc(it);\n-        });\n-    Arc::new(res)\n-}\n-\n-pub(super) fn file_item(db: &impl HirDatabase, source_item_id: SourceItemId) -> SyntaxNode {\n-    db.file_items(source_item_id.file_id)[source_item_id.item_id].clone()\n-}\n-\n-pub(crate) fn submodules(\n-    db: &impl HirDatabase,\n-    source: ModuleSource,\n-) -> Cancelable<Arc<Vec<Submodule>>> {\n-    db.check_canceled()?;\n-    let file_id = source.file_id();\n-    let submodules = match source.resolve(db) {\n-        ModuleSourceNode::SourceFile(it) => collect_submodules(db, file_id, it.borrowed()),\n-        ModuleSourceNode::Module(it) => it\n-            .borrowed()\n-            .item_list()\n-            .map(|it| collect_submodules(db, file_id, it))\n-            .unwrap_or_else(Vec::new),\n-    };\n-    return Ok(Arc::new(submodules));\n-\n-    fn collect_submodules<'a>(\n-        db: &impl HirDatabase,\n-        file_id: FileId,\n-        root: impl ast::ModuleItemOwner<'a>,\n-    ) -> Vec<Submodule> {\n-        modules(root)\n-            .map(|(name, m)| {\n-                if m.has_semi() {\n-                    Submodule::Declaration(name)\n-                } else {\n-                    let src = ModuleSource::new_inline(db, file_id, m);\n-                    Submodule::Definition(name, src)\n-                }\n-            })\n-            .collect()\n-    }\n-}\n-\n-pub(crate) fn modules<'a>(\n-    root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n-    root.items()\n-        .filter_map(|item| match item {\n-            ast::ModuleItem::Module(m) => Some(m),\n-            _ => None,\n-        })\n-        .filter_map(|module| {\n-            let name = module.name()?.text();\n-            Some((name, module))\n-        })\n-}\n-\n-pub(super) fn input_module_items(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-    module_id: ModuleId,\n-) -> Cancelable<Arc<InputModuleItems>> {\n-    let module_tree = db.module_tree(source_root)?;\n-    let source = module_id.source(&module_tree);\n-    let file_items = db.file_items(source.file_id());\n-    let res = match source.resolve(db) {\n-        ModuleSourceNode::SourceFile(it) => {\n-            let items = it.borrowed().items();\n-            InputModuleItems::new(&file_items, items)\n-        }\n-        ModuleSourceNode::Module(it) => {\n-            let items = it\n-                .borrowed()\n-                .item_list()\n-                .into_iter()\n-                .flat_map(|it| it.items());\n-            InputModuleItems::new(&file_items, items)\n-        }\n-    };\n-    Ok(Arc::new(res))\n-}\n-\n-pub(super) fn item_map(\n-    db: &impl HirDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<Arc<ItemMap>> {\n-    let start = Instant::now();\n-    let module_tree = db.module_tree(source_root)?;\n-    let input = module_tree\n-        .modules()\n-        .map(|id| {\n-            let items = db.input_module_items(source_root, id)?;\n-            Ok((id, items))\n-        })\n-        .collect::<Cancelable<FxHashMap<_, _>>>()?;\n-    let resolver = Resolver {\n-        db: db,\n-        input: &input,\n-        source_root,\n-        module_tree,\n-        result: ItemMap::default(),\n-    };\n-    let res = resolver.resolve()?;\n-    let elapsed = start.elapsed();\n-    log::info!(\"item_map: {:?}\", elapsed);\n-    Ok(Arc::new(res))\n-}"}, {"sha": "f5cb3550e640b15a393dae997568e7821543648c", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -14,15 +14,15 @@ use ra_db::{FilesDatabase, SourceRoot, SourceRootId, WORKSPACE, SyntaxDatabase,\n use rayon::prelude::*;\n use rustc_hash::FxHashSet;\n use salsa::{Database, ParallelDatabase};\n+use hir::{\n+    self,\n+    FnSignatureInfo,\n+    Problem,\n+};\n \n use crate::{\n     completion::{completions, CompletionItem},\n     db,\n-    hir::{\n-        self,\n-        FnSignatureInfo,\n-        Problem,\n-    },\n     symbol_index::{SymbolIndex, SymbolsDatabase},\n     AnalysisChange, Cancelable, CrateId, Diagnostic, FileId,\n     FileSystemEdit, FilePosition, Query, SourceChange, SourceFileNodeEdit,"}, {"sha": "350a6d627e2f00e309cfc4f2de93e50574826c75", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 119, "deletions": 3, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -9,11 +9,18 @@ extern crate relative_path;\n extern crate rustc_hash;\n extern crate salsa;\n \n-mod arena;\n+macro_rules! ctry {\n+    ($expr:expr) => {\n+        match $expr {\n+            None => return Ok(None),\n+            Some(it) => it,\n+        }\n+    };\n+}\n+\n mod db;\n mod imp;\n mod completion;\n-mod hir;\n mod symbol_index;\n pub mod mock_analysis;\n \n@@ -31,11 +38,11 @@ use crate::{\n \n pub use crate::{\n     completion::CompletionItem,\n-    hir::FnSignatureInfo,\n };\n pub use ra_editor::{\n     FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, Runnable, RunnableKind, StructureNode,\n };\n+pub use hir::FnSignatureInfo;\n \n pub use ra_db::{\n     Canceled, Cancelable, FilePosition,\n@@ -310,3 +317,112 @@ fn analysis_is_send() {\n     fn is_send<T: Send>() {}\n     is_send::<Analysis>();\n }\n+\n+//TODO: move to hir\n+#[cfg(test)]\n+mod hir_namres_tests {\n+    use std::sync::Arc;\n+    use ra_db::FilesDatabase;\n+    use ra_syntax::SmolStr;\n+    use hir::{self, db::HirDatabase};\n+\n+    use crate::{\n+        AnalysisChange,\n+        mock_analysis::{MockAnalysis, analysis_and_position},\n+};\n+\n+    fn item_map(fixture: &str) -> (Arc<hir::ItemMap>, hir::ModuleId) {\n+        let (analysis, pos) = analysis_and_position(fixture);\n+        let db = analysis.imp.db;\n+        let source_root = db.file_source_root(pos.file_id);\n+        let descr = hir::Module::guess_from_position(&*db, pos)\n+            .unwrap()\n+            .unwrap();\n+        let module_id = descr.module_id;\n+        (db.item_map(source_root).unwrap(), module_id)\n+    }\n+\n+    #[test]\n+    fn test_item_map() {\n+        let (item_map, module_id) = item_map(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+            <|>\n+\n+            //- /foo/mod.rs\n+            pub mod bar;\n+\n+            //- /foo/bar.rs\n+            pub struct Baz;\n+        \",\n+        );\n+        let name = SmolStr::from(\"Baz\");\n+        let resolution = &item_map.per_module[&module_id].items[&name];\n+        assert!(resolution.def_id.is_some());\n+    }\n+\n+    #[test]\n+    fn typing_inside_a_function_should_not_invalidate_item_map() {\n+        let mock_analysis = MockAnalysis::with_files(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+\n+            fn foo() -> i32 {\n+                1 + 1\n+            }\n+            //- /foo/mod.rs\n+            pub mod bar;\n+\n+            //- /foo/bar.rs\n+            pub struct Baz;\n+        \",\n+        );\n+\n+        let file_id = mock_analysis.id_of(\"/lib.rs\");\n+        let mut host = mock_analysis.analysis_host();\n+\n+        let source_root = host.analysis().imp.db.file_source_root(file_id);\n+\n+        {\n+            let db = host.analysis().imp.db;\n+            let events = db.log_executed(|| {\n+                db.item_map(source_root).unwrap();\n+            });\n+            assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n+        }\n+\n+        let mut change = AnalysisChange::new();\n+\n+        change.change_file(\n+            file_id,\n+            \"\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+\n+            fn foo() -> i32 { 92 }\n+        \"\n+            .to_string(),\n+        );\n+\n+        host.apply_change(change);\n+\n+        {\n+            let db = host.analysis().imp.db;\n+            let events = db.log_executed(|| {\n+                db.item_map(source_root).unwrap();\n+            });\n+            assert!(\n+                !format!(\"{:?}\", events).contains(\"_item_map\"),\n+                \"{:#?}\",\n+                events\n+            )\n+        }\n+    }\n+}"}, {"sha": "8d67ab1c9ca94d9d615ac93c9ab5d59b3d8e232e", "filename": "crates/ra_hir/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Farena.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -8,7 +8,7 @@ use std::{\n     marker::PhantomData,\n };\n \n-pub(crate) struct Id<T> {\n+pub struct Id<T> {\n     idx: u32,\n     _ty: PhantomData<fn() -> T>,\n }"}, {"sha": "2f01bae6d19a45936a07ce083c8fe0ffddca2e4c", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -10,14 +10,14 @@ use crate::{\n     DefLoc, DefId, FnId,\n     SourceFileItems, SourceItemId,\n     query_definitions,\n-    function::{FnScopes},\n+    FnScopes,\n     module::{ModuleId, ModuleTree, ModuleSource,\n     nameres::{ItemMap, InputModuleItems}},\n };\n \n salsa::query_group! {\n \n-pub(crate) trait HirDatabase: SyntaxDatabase\n+pub trait HirDatabase: SyntaxDatabase\n     + AsRef<LocationIntener<DefLoc, DefId>>\n     + AsRef<LocationIntener<SourceItemId, FnId>>\n {"}, {"sha": "c8af2e54f9716c08a2550b0f4641855f640fc5a6", "filename": "crates/ra_hir/src/function/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -15,23 +15,23 @@ use crate::{\n     FnId, HirDatabase, SourceItemId,\n };\n \n-pub(crate) use self::scope::FnScopes;\n+pub use self::scope::FnScopes;\n \n impl FnId {\n-    pub(crate) fn get(db: &impl HirDatabase, file_id: FileId, fn_def: ast::FnDef) -> FnId {\n+    pub fn get(db: &impl HirDatabase, file_id: FileId, fn_def: ast::FnDef) -> FnId {\n         let file_items = db.file_items(file_id);\n         let item_id = file_items.id_of(fn_def.syntax());\n         let item_id = SourceItemId { file_id, item_id };\n         FnId::from_loc(db, &item_id)\n     }\n }\n \n-pub(crate) struct Function {\n+pub struct Function {\n     fn_id: FnId,\n }\n \n impl Function {\n-    pub(crate) fn guess_from_source(\n+    pub fn guess_from_source(\n         db: &impl HirDatabase,\n         file_id: FileId,\n         fn_def: ast::FnDef,\n@@ -40,15 +40,15 @@ impl Function {\n         Function { fn_id }\n     }\n \n-    pub(crate) fn guess_for_name_ref(\n+    pub fn guess_for_name_ref(\n         db: &impl HirDatabase,\n         file_id: FileId,\n         name_ref: ast::NameRef,\n     ) -> Option<Function> {\n         Function::guess_for_node(db, file_id, name_ref.syntax())\n     }\n \n-    pub(crate) fn guess_for_bind_pat(\n+    pub fn guess_for_bind_pat(\n         db: &impl HirDatabase,\n         file_id: FileId,\n         bind_pat: ast::BindPat,\n@@ -66,11 +66,11 @@ impl Function {\n         Some(res)\n     }\n \n-    pub(crate) fn scope(&self, db: &impl HirDatabase) -> Arc<FnScopes> {\n+    pub fn scope(&self, db: &impl HirDatabase) -> Arc<FnScopes> {\n         db.fn_scopes(self.fn_id)\n     }\n \n-    pub(crate) fn signature_info(&self, db: &impl HirDatabase) -> Option<FnSignatureInfo> {\n+    pub fn signature_info(&self, db: &impl HirDatabase) -> Option<FnSignatureInfo> {\n         let syntax = db.fn_syntax(self.fn_id);\n         FnSignatureInfo::new(syntax.borrowed())\n     }"}, {"sha": "8634532916628dfc5497776c0c42320999eecf95", "filename": "crates/ra_hir/src/function/scope.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -15,7 +15,7 @@ pub(crate) type ScopeId = Id<ScopeData>;\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct FnScopes {\n-    pub(crate) self_param: Option<LocalSyntaxPtr>,\n+    pub self_param: Option<LocalSyntaxPtr>,\n     scopes: Arena<ScopeData>,\n     scope_for: FxHashMap<LocalSyntaxPtr, ScopeId>,\n }\n@@ -27,13 +27,13 @@ pub struct ScopeEntry {\n }\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ScopeData {\n+pub struct ScopeData {\n     parent: Option<ScopeId>,\n     entries: Vec<ScopeEntry>,\n }\n \n impl FnScopes {\n-    pub(crate) fn new(fn_def: ast::FnDef) -> FnScopes {\n+    pub fn new(fn_def: ast::FnDef) -> FnScopes {\n         let mut scopes = FnScopes {\n             self_param: fn_def\n                 .param_list()\n@@ -49,18 +49,15 @@ impl FnScopes {\n         }\n         scopes\n     }\n-    pub(crate) fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n         &self.scopes[scope].entries\n     }\n     pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n         generate(self.scope_for(node), move |&scope| {\n             self.scopes[scope].parent\n         })\n     }\n-    pub(crate) fn resolve_local_name<'a>(\n-        &'a self,\n-        name_ref: ast::NameRef,\n-    ) -> Option<&'a ScopeEntry> {\n+    pub fn resolve_local_name<'a>(&'a self, name_ref: ast::NameRef) -> Option<&'a ScopeEntry> {\n         let mut shadowed = FxHashSet::default();\n         let ret = self\n             .scope_chain(name_ref.syntax())\n@@ -138,10 +135,10 @@ impl ScopeEntry {\n         };\n         Some(res)\n     }\n-    pub(crate) fn name(&self) -> &SmolStr {\n+    pub fn name(&self) -> &SmolStr {\n         &self.name\n     }\n-    pub(crate) fn ptr(&self) -> LocalSyntaxPtr {\n+    pub fn ptr(&self) -> LocalSyntaxPtr {\n         self.ptr\n     }\n }"}, {"sha": "f13f0107e2271eb4dd7efd0dc851ea912aa42170", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -14,7 +14,7 @@ macro_rules! ctry {\n     };\n }\n \n-pub(crate) mod db;\n+pub mod db;\n mod query_definitions;\n mod function;\n mod module;\n@@ -31,36 +31,36 @@ use crate::{\n     arena::{Arena, Id},\n };\n \n-pub(crate) use self::{\n+pub use self::{\n     path::{Path, PathKind},\n-    module::{Module, ModuleId, Problem},\n+    module::{Module, ModuleId, Problem, nameres::ItemMap},\n     function::{Function, FnScopes},\n };\n \n pub use self::function::FnSignatureInfo;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct FnId(u32);\n+pub struct FnId(u32);\n ra_db::impl_numeric_id!(FnId);\n \n impl FnId {\n-    pub(crate) fn from_loc(\n+    pub fn from_loc(\n         db: &impl AsRef<LocationIntener<SourceItemId, FnId>>,\n         loc: &SourceItemId,\n     ) -> FnId {\n         db.as_ref().loc2id(loc)\n     }\n-    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<SourceItemId, FnId>>) -> SourceItemId {\n+    pub fn loc(self, db: &impl AsRef<LocationIntener<SourceItemId, FnId>>) -> SourceItemId {\n         db.as_ref().id2loc(self)\n     }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct DefId(u32);\n+pub struct DefId(u32);\n ra_db::impl_numeric_id!(DefId);\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub(crate) enum DefLoc {\n+pub enum DefLoc {\n     Module {\n         id: ModuleId,\n         source_root: SourceRootId,\n@@ -71,24 +71,24 @@ pub(crate) enum DefLoc {\n }\n \n impl DefId {\n-    pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n+    pub fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n         db.as_ref().id2loc(self)\n     }\n }\n \n impl DefLoc {\n-    pub(crate) fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n+    pub fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n         db.as_ref().loc2id(&self)\n     }\n }\n \n-pub(crate) enum Def {\n+pub enum Def {\n     Module(Module),\n     Item,\n }\n \n impl DefId {\n-    pub(crate) fn resolve(self, db: &impl HirDatabase) -> Cancelable<Def> {\n+    pub fn resolve(self, db: &impl HirDatabase) -> Cancelable<Def> {\n         let loc = self.loc(db);\n         let res = match loc {\n             DefLoc::Module { id, source_root } => {\n@@ -106,22 +106,22 @@ impl DefId {\n pub(crate) type SourceFileItemId = Id<SyntaxNode>;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct SourceItemId {\n+pub struct SourceItemId {\n     file_id: FileId,\n     item_id: SourceFileItemId,\n }\n \n /// Maps item's `SyntaxNode`s to `SourceFileItemId` and back.\n #[derive(Debug, PartialEq, Eq, Default)]\n-pub(crate) struct SourceFileItems {\n+pub struct SourceFileItems {\n     arena: Arena<SyntaxNode>,\n }\n \n impl SourceFileItems {\n     fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n         self.arena.alloc(item)\n     }\n-    fn id_of(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n+    pub fn id_of(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n         let (id, _item) = self\n             .arena\n             .iter()"}, {"sha": "76ea129a76d45a0151539aa4906efeb178b610cf", "filename": "crates/ra_hir/src/module/imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -18,7 +18,7 @@ use super::{\n };\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug)]\n-pub(crate) enum Submodule {\n+pub enum Submodule {\n     Declaration(SmolStr),\n     Definition(SmolStr, ModuleSource),\n }"}, {"sha": "a011fd53eafd194fc27fb7f9f55e37b43ac64c7c", "filename": "crates/ra_hir/src/module/mod.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -18,15 +18,16 @@ use crate::{\n     arena::{Arena, Id},\n };\n \n-pub(crate) use self::nameres::ModuleScope;\n+pub use self::nameres::ModuleScope;\n \n /// `Module` is API entry point to get all the information\n /// about a particular module.\n #[derive(Debug, Clone)]\n-pub(crate) struct Module {\n+pub struct Module {\n     tree: Arc<ModuleTree>,\n     source_root_id: SourceRootId,\n-    module_id: ModuleId,\n+    //TODO: make private\n+    pub module_id: ModuleId,\n }\n \n impl Module {\n@@ -145,17 +146,13 @@ impl Module {\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub(crate) fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+    pub fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n         let item_map = db.item_map(self.source_root_id)?;\n         let res = item_map.per_module[&self.module_id].clone();\n         Ok(res)\n     }\n \n-    pub(crate) fn resolve_path(\n-        &self,\n-        db: &impl HirDatabase,\n-        path: Path,\n-    ) -> Cancelable<Option<DefId>> {\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: Path) -> Cancelable<Option<DefId>> {\n         let mut curr = match path.kind {\n             PathKind::Crate => self.crate_root(),\n             PathKind::Self_ | PathKind::Plain => self.clone(),\n@@ -188,7 +185,7 @@ impl Module {\n /// (which can have multiple parents) to the precise world of modules (which\n /// always have one parent).\n #[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct ModuleTree {\n+pub struct ModuleTree {\n     mods: Arena<ModuleData>,\n     links: Arena<LinkData>,\n }\n@@ -214,19 +211,19 @@ impl ModuleTree {\n /// `ModuleSource` is the syntax tree element that produced this module:\n /// either a file, or an inlinde module.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub(crate) enum ModuleSource {\n+pub enum ModuleSource {\n     SourceFile(FileId),\n     Module(SourceItemId),\n }\n \n /// An owned syntax node for a module. Unlike `ModuleSource`,\n /// this holds onto the AST for the whole file.\n-pub(crate) enum ModuleSourceNode {\n+pub enum ModuleSourceNode {\n     SourceFile(ast::SourceFileNode),\n     Module(ast::ModuleNode),\n }\n \n-pub(crate) type ModuleId = Id<ModuleData>;\n+pub type ModuleId = Id<ModuleData>;\n type LinkId = Id<LinkData>;\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n@@ -308,7 +305,7 @@ impl LinkId {\n }\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n-pub(crate) struct ModuleData {\n+pub struct ModuleData {\n     source: ModuleSource,\n     parent: Option<LinkId>,\n     children: Vec<LinkId>,\n@@ -327,21 +324,21 @@ impl ModuleSource {\n         ModuleSource::Module(id)\n     }\n \n-    pub(crate) fn as_file(self) -> Option<FileId> {\n+    pub fn as_file(self) -> Option<FileId> {\n         match self {\n             ModuleSource::SourceFile(f) => Some(f),\n             ModuleSource::Module(..) => None,\n         }\n     }\n \n-    pub(crate) fn file_id(self) -> FileId {\n+    pub fn file_id(self) -> FileId {\n         match self {\n             ModuleSource::SourceFile(f) => f,\n             ModuleSource::Module(source_item_id) => source_item_id.file_id,\n         }\n     }\n \n-    pub(crate) fn resolve(self, db: &impl HirDatabase) -> ModuleSourceNode {\n+    pub fn resolve(self, db: &impl HirDatabase) -> ModuleSourceNode {\n         match self {\n             ModuleSource::SourceFile(file_id) => {\n                 let syntax = db.source_file(file_id);"}, {"sha": "837a8d5ae594aa83c46426c424e08df3b15f416a", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 14, "deletions": 120, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -38,20 +38,20 @@ use crate::{\n /// Item map is the result of the name resolution. Item map contains, for each\n /// module, the set of visible items.\n #[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct ItemMap {\n-    pub(crate) per_module: FxHashMap<ModuleId, ModuleScope>,\n+pub struct ItemMap {\n+    pub per_module: FxHashMap<ModuleId, ModuleScope>,\n }\n \n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n-pub(crate) struct ModuleScope {\n-    items: FxHashMap<SmolStr, Resolution>,\n+pub struct ModuleScope {\n+    pub items: FxHashMap<SmolStr, Resolution>,\n }\n \n impl ModuleScope {\n-    pub(crate) fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a SmolStr, &Resolution)> + 'a {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a SmolStr, &Resolution)> + 'a {\n         self.items.iter()\n     }\n-    pub(crate) fn get(&self, name: &SmolStr) -> Option<&Resolution> {\n+    pub fn get(&self, name: &SmolStr) -> Option<&Resolution> {\n         self.items.get(name)\n     }\n }\n@@ -63,7 +63,7 @@ impl ModuleScope {\n /// recomputing name res: if `InputModuleItems` are the same, we can avoid\n /// running name resolution.\n #[derive(Debug, Default, PartialEq, Eq)]\n-pub(crate) struct InputModuleItems {\n+pub struct InputModuleItems {\n     items: Vec<ModuleItem>,\n     imports: Vec<Import>,\n }\n@@ -89,13 +89,13 @@ struct Import {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub(crate) struct NamedImport {\n-    file_item_id: SourceFileItemId,\n-    relative_range: TextRange,\n+pub struct NamedImport {\n+    pub file_item_id: SourceFileItemId,\n+    pub relative_range: TextRange,\n }\n \n impl NamedImport {\n-    pub(crate) fn range(&self, db: &impl HirDatabase, file_id: FileId) -> TextRange {\n+    pub fn range(&self, db: &impl HirDatabase, file_id: FileId) -> TextRange {\n         let source_item_id = SourceItemId {\n             file_id,\n             item_id: self.file_item_id,\n@@ -115,11 +115,11 @@ enum ImportKind {\n /// Resolution is basically `DefId` atm, but it should account for stuff like\n /// multiple namespaces, ambiguity and errors.\n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub(crate) struct Resolution {\n+pub struct Resolution {\n     /// None for unresolved\n-    pub(crate) def_id: Option<DefId>,\n+    pub def_id: Option<DefId>,\n     /// ident by whitch this is imported into local scope.\n-    pub(crate) import: Option<NamedImport>,\n+    pub import: Option<NamedImport>,\n }\n \n // #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -336,109 +336,3 @@ where\n         f(module_items)\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_db::FilesDatabase;\n-    use crate::{\n-        AnalysisChange,\n-        mock_analysis::{MockAnalysis, analysis_and_position},\n-        hir::{self, HirDatabase},\n-};\n-    use super::*;\n-\n-    fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n-        let (analysis, pos) = analysis_and_position(fixture);\n-        let db = analysis.imp.db;\n-        let source_root = db.file_source_root(pos.file_id);\n-        let descr = hir::Module::guess_from_position(&*db, pos)\n-            .unwrap()\n-            .unwrap();\n-        let module_id = descr.module_id;\n-        (db.item_map(source_root).unwrap(), module_id)\n-    }\n-\n-    #[test]\n-    fn test_item_map() {\n-        let (item_map, module_id) = item_map(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-            <|>\n-\n-            //- /foo/mod.rs\n-            pub mod bar;\n-\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-        \",\n-        );\n-        let name = SmolStr::from(\"Baz\");\n-        let resolution = &item_map.per_module[&module_id].items[&name];\n-        assert!(resolution.def_id.is_some());\n-    }\n-\n-    #[test]\n-    fn typing_inside_a_function_should_not_invalidate_item_map() {\n-        let mock_analysis = MockAnalysis::with_files(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-\n-            fn foo() -> i32 {\n-                1 + 1\n-            }\n-            //- /foo/mod.rs\n-            pub mod bar;\n-\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-        \",\n-        );\n-\n-        let file_id = mock_analysis.id_of(\"/lib.rs\");\n-        let mut host = mock_analysis.analysis_host();\n-\n-        let source_root = host.analysis().imp.db.file_source_root(file_id);\n-\n-        {\n-            let db = host.analysis().imp.db;\n-            let events = db.log_executed(|| {\n-                db.item_map(source_root).unwrap();\n-            });\n-            assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n-        }\n-\n-        let mut change = AnalysisChange::new();\n-\n-        change.change_file(\n-            file_id,\n-            \"\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-\n-            fn foo() -> i32 { 92 }\n-        \"\n-            .to_string(),\n-        );\n-\n-        host.apply_change(change);\n-\n-        {\n-            let db = host.analysis().imp.db;\n-            let events = db.log_executed(|| {\n-                db.item_map(source_root).unwrap();\n-            });\n-            assert!(\n-                !format!(\"{:?}\", events).contains(\"_item_map\"),\n-                \"{:#?}\",\n-                events\n-            )\n-        }\n-    }\n-}"}, {"sha": "4a2e427cd90b6a91eaee0c6fd2776189bf5651b4", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59e29aef633e906837f8fed604435976a46be691/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=59e29aef633e906837f8fed604435976a46be691", "patch": "@@ -1,13 +1,13 @@\n use ra_syntax::{SmolStr, ast, AstNode, TextRange};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub(crate) struct Path {\n-    pub(crate) kind: PathKind,\n-    pub(crate) segments: Vec<SmolStr>,\n+pub struct Path {\n+    pub kind: PathKind,\n+    pub segments: Vec<SmolStr>,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub(crate) enum PathKind {\n+pub enum PathKind {\n     Plain,\n     Self_,\n     Super,\n@@ -16,14 +16,14 @@ pub(crate) enum PathKind {\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n-    pub(crate) fn expand_use_item(item: ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n+    pub fn expand_use_item(item: ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n         if let Some(tree) = item.use_tree() {\n             expand_use_tree(None, tree, &mut cb);\n         }\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    pub(crate) fn from_ast(mut path: ast::Path) -> Option<Path> {\n+    pub fn from_ast(mut path: ast::Path) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -64,7 +64,7 @@ impl Path {\n     }\n \n     /// `true` is this path is a single identifier, like `foo`\n-    pub(crate) fn is_ident(&self) -> bool {\n+    pub fn is_ident(&self) -> bool {\n         self.kind == PathKind::Plain && self.segments.len() == 1\n     }\n }"}]}