{"sha": "c67c30dba60866770f3babc7a33470a5dfe5ea77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2N2MzMGRiYTYwODY2NzcwZjNiYWJjN2EzMzQ3MGE1ZGZlNWVhNzc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-08T06:55:38Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-21T17:34:00Z"}, "message": "refactor parse_ty_tuple_or_parens", "tree": {"sha": "f661339a836a808d49ea00a1ca8cdd6284fcdc69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f661339a836a808d49ea00a1ca8cdd6284fcdc69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c67c30dba60866770f3babc7a33470a5dfe5ea77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c67c30dba60866770f3babc7a33470a5dfe5ea77", "html_url": "https://github.com/rust-lang/rust/commit/c67c30dba60866770f3babc7a33470a5dfe5ea77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c67c30dba60866770f3babc7a33470a5dfe5ea77/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3ef4a416d162c0a3f18c627d27fdb3676df336c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3ef4a416d162c0a3f18c627d27fdb3676df336c", "html_url": "https://github.com/rust-lang/rust/commit/f3ef4a416d162c0a3f18c627d27fdb3676df336c"}], "stats": {"total": 40, "additions": 16, "deletions": 24}, "files": [{"sha": "716bdf7bb1259fc5276d8ca0485f174123d1aaa2", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c67c30dba60866770f3babc7a33470a5dfe5ea77/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67c30dba60866770f3babc7a33470a5dfe5ea77/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=c67c30dba60866770f3babc7a33470a5dfe5ea77", "patch": "@@ -73,8 +73,8 @@ impl<'a> Parser<'a> {\n \n         let lo = self.token.span;\n         let mut impl_dyn_multi = false;\n-        let kind = if self.eat(&token::OpenDelim(token::Paren)) {\n-            self.parse_ty_tuple_or_parens(allow_plus)?\n+        let kind = if self.check(&token::OpenDelim(token::Paren)) {\n+            self.parse_ty_tuple_or_parens(lo, allow_plus)?\n         } else if self.eat(&token::Not) {\n             // Never type `!`\n             TyKind::Never\n@@ -208,34 +208,26 @@ impl<'a> Parser<'a> {\n     /// Parses either:\n     /// - `(TYPE)`, a parenthesized type.\n     /// - `(TYPE,)`, a tuple with a single field of type TYPE.\n-    fn parse_ty_tuple_or_parens(&mut self, allow_plus: bool) -> PResult<'a, TyKind> {\n-        let lo = self.token.span;\n-        let mut ts = vec![];\n-        let mut last_comma = false;\n-        while self.token != token::CloseDelim(token::Paren) {\n-            ts.push(self.parse_ty()?);\n-            if self.eat(&token::Comma) {\n-                last_comma = true;\n-            } else {\n-                last_comma = false;\n-                break;\n-            }\n-        }\n-        let trailing_plus = self.prev_token_kind == PrevTokenKind::Plus;\n-        self.expect(&token::CloseDelim(token::Paren))?;\n+    fn parse_ty_tuple_or_parens(&mut self, lo: Span, allow_plus: bool) -> PResult<'a, TyKind> {\n+        let mut trailing_plus = false;\n+        let (ts, trailing) = self.parse_paren_comma_seq(|p| {\n+            let ty = p.parse_ty()?;\n+            trailing_plus = p.prev_token_kind == PrevTokenKind::Plus;\n+            Ok(ty)\n+        })?;\n \n-        if ts.len() == 1 && !last_comma {\n+        if ts.len() == 1 && !trailing {\n             let ty = ts.into_iter().nth(0).unwrap().into_inner();\n             let maybe_bounds = allow_plus && self.token.is_like_plus();\n             match ty.kind {\n                 // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n-                TyKind::Path(None, ref path) if maybe_bounds => {\n-                    self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)\n+                TyKind::Path(None, path) if maybe_bounds => {\n+                    self.parse_remaining_bounds(Vec::new(), path, lo, true)\n                 }\n-                TyKind::TraitObject(ref bounds, TraitObjectSyntax::None)\n-                        if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n-                    let path = match bounds[0] {\n-                        GenericBound::Trait(ref pt, ..) => pt.trait_ref.path.clone(),\n+                TyKind::TraitObject(mut bounds, TraitObjectSyntax::None)\n+                if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n+                    let path = match bounds.remove(0) {\n+                        GenericBound::Trait(pt, ..) => pt.trait_ref.path,\n                         GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n                     };\n                     self.parse_remaining_bounds(Vec::new(), path, lo, true)"}]}