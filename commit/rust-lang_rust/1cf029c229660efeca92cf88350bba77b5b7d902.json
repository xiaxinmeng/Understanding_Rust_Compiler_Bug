{"sha": "1cf029c229660efeca92cf88350bba77b5b7d902", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZjAyOWMyMjk2NjBlZmVjYTkyY2Y4ODM1MGJiYTc3YjViN2Q5MDI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-26T19:15:54Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-10-19T01:36:17Z"}, "message": "rustpkg: Make rustpkg tests stop comparing dates\n\nInstead of scrutinizing modification times in rustpkg tests,\nchange output files to be read-only and detect attempts to write\nto them (hack suggested by Jack). This avoids time granularity problems.\n\nAs part of this change, I discovered that some dependencies weren't\ngetting written correctly (involving built executables and library\nfiles), so this patch fixes that too.\n\nThis partly addresses #9441, but one test (test_rebuild_when_needed)\nis still ignored on Linux.", "tree": {"sha": "b1406d88f1c492454c3c9414af36f49e19bb40de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1406d88f1c492454c3c9414af36f49e19bb40de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cf029c229660efeca92cf88350bba77b5b7d902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf029c229660efeca92cf88350bba77b5b7d902", "html_url": "https://github.com/rust-lang/rust/commit/1cf029c229660efeca92cf88350bba77b5b7d902", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cf029c229660efeca92cf88350bba77b5b7d902/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b07d885f3dd1a80ffca113925a949386371ea97", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b07d885f3dd1a80ffca113925a949386371ea97", "html_url": "https://github.com/rust-lang/rust/commit/6b07d885f3dd1a80ffca113925a949386371ea97"}], "stats": {"total": 205, "additions": 160, "deletions": 45}, "files": [{"sha": "a30951890d5928111950a1576cfc31e0a1369e37", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=1cf029c229660efeca92cf88350bba77b5b7d902", "patch": "@@ -219,7 +219,7 @@ impl Logger {\n     }\n \n     pub fn info(&self, i: &str) {\n-        io::println(~\"workcache: \" + i);\n+        info2!(\"workcache: {}\", i);\n     }\n }\n "}, {"sha": "147e838d94c4355c06d4d75ca4db479ebc19c31f", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=1cf029c229660efeca92cf88350bba77b5b7d902", "patch": "@@ -23,6 +23,10 @@ condition! {\n     pub bad_stat: (Path, ~str) -> stat;\n }\n \n+condition! {\n+    pub bad_kind: (~str) -> ();\n+}\n+\n condition! {\n     pub nonexistent_package: (PkgId, ~str) -> Path;\n }"}, {"sha": "696f39a95d78e6bb1a961a73ca1bd73b170a01f4", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=1cf029c229660efeca92cf88350bba77b5b7d902", "patch": "@@ -21,10 +21,11 @@ use source_control::{safe_git_clone, git_clone_url, DirToUse, CheckedOutSources}\n use source_control::make_read_only;\n use path_util::{find_dir_using_rust_path_hack, make_dir_rwx_recursive};\n use path_util::{target_build_dir, versionize};\n-use util::compile_crate;\n+use util::{compile_crate, DepMap};\n use workcache_support;\n use workcache_support::crate_tag;\n use extra::workcache;\n+use extra::treemap::TreeMap;\n \n // An enumeration of the unpacked source of a package workspace.\n // This contains a list of files found in the source workspace.\n@@ -370,6 +371,7 @@ impl PkgSrc {\n \n     fn build_crates(&self,\n                     ctx: &BuildContext,\n+                    deps: &mut DepMap,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n                     what: OutputType) {\n@@ -389,12 +391,14 @@ impl PkgSrc {\n                 let id = self.id.clone();\n                 let sub_dir = self.build_workspace().clone();\n                 let sub_flags = crate.flags.clone();\n+                let sub_deps = deps.clone();\n                 do prep.exec |exec| {\n                     let result = compile_crate(&subcx,\n                                                exec,\n                                                &id,\n                                                &subpath,\n                                                &sub_dir,\n+                                               &mut (sub_deps.clone()),\n                                                sub_flags,\n                                                subcfgs,\n                                                false,\n@@ -428,24 +432,27 @@ impl PkgSrc {\n         }\n     }\n \n-    // It would be better if build returned a Path, but then Path would have to derive\n-    // Encodable.\n     pub fn build(&self,\n                  build_context: &BuildContext,\n-                 cfgs: ~[~str]) {\n+                 // DepMap is a map from str (crate name) to (kind, name) --\n+                 // it tracks discovered dependencies per-crate\n+                 cfgs: ~[~str]) -> DepMap {\n+        let mut deps = TreeMap::new();\n+\n         let libs = self.libs.clone();\n         let mains = self.mains.clone();\n         let tests = self.tests.clone();\n         let benchs = self.benchs.clone();\n         debug2!(\"Building libs in {}, destination = {}\",\n                self.source_workspace.display(), self.build_workspace().display());\n-        self.build_crates(build_context, libs, cfgs, Lib);\n+        self.build_crates(build_context, &mut deps, libs, cfgs, Lib);\n         debug2!(\"Building mains\");\n-        self.build_crates(build_context, mains, cfgs, Main);\n+        self.build_crates(build_context, &mut deps, mains, cfgs, Main);\n         debug2!(\"Building tests\");\n-        self.build_crates(build_context, tests, cfgs, Test);\n+        self.build_crates(build_context, &mut deps, tests, cfgs, Test);\n         debug2!(\"Building benches\");\n-        self.build_crates(build_context, benchs, cfgs, Bench);\n+        self.build_crates(build_context, &mut deps, benchs, cfgs, Bench);\n+        deps\n     }\n \n     /// Return the workspace to put temporary files in. See the comment on `PkgSrc`"}, {"sha": "affd53216659c5c96b4f55e85c43ed7777b8980e", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=1cf029c229660efeca92cf88350bba77b5b7d902", "patch": "@@ -197,7 +197,8 @@ pub trait CtxMethods {\n     fn install(&self, src: PkgSrc, what: &WhatToBuild) -> (~[Path], ~[(~str, ~str)]);\n     /// Returns a list of installed files\n     fn install_no_build(&self,\n-                        source_workspace: &Path,\n+                        build_workspace: &Path,\n+                        build_inputs: &[Path],\n                         target_workspace: &Path,\n                         id: &PkgId) -> ~[~str];\n     fn prefer(&self, _id: &str, _vers: Option<~str>);\n@@ -542,6 +543,7 @@ impl CtxMethods for BuildContext {\n \n         let mut installed_files = ~[];\n         let mut inputs = ~[];\n+        let mut build_inputs = ~[];\n \n         debug2!(\"Installing package source: {}\", pkg_src.to_str());\n \n@@ -554,14 +556,16 @@ impl CtxMethods for BuildContext {\n         debug2!(\"In declare inputs for {}\", id.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n-                let path = pkg_src.start_dir.join(&c.file);\n+                let path = pkg_src.start_dir.join(&c.file).normalize();\n                 debug2!(\"Recording input: {}\", path.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 inputs.push((~\"file\", path.as_str().unwrap().to_owned()));\n+                build_inputs.push(path);\n             }\n         }\n \n         let result = self.install_no_build(pkg_src.build_workspace(),\n+                                           build_inputs,\n                                            &pkg_src.destination_workspace,\n                                            &id).map(|s| Path::new(s.as_slice()));\n         debug2!(\"install: id = {}, about to call discover_outputs, {:?}\",\n@@ -576,6 +580,7 @@ impl CtxMethods for BuildContext {\n     // again, working around lack of Encodable for Path\n     fn install_no_build(&self,\n                         build_workspace: &Path,\n+                        build_inputs: &[Path],\n                         target_workspace: &Path,\n                         id: &PkgId) -> ~[~str] {\n         use conditions::copy_failed::cond;\n@@ -612,9 +617,28 @@ impl CtxMethods for BuildContext {\n             let sublib = maybe_library.clone();\n             let sub_target_ex = target_exec.clone();\n             let sub_target_lib = target_lib.clone();\n-\n+            let sub_build_inputs = build_inputs.to_owned();\n             do prep.exec |exe_thing| {\n                 let mut outputs = ~[];\n+                // Declare all the *inputs* to the declared input too, as inputs\n+                for executable in subex.iter() {\n+                    exe_thing.discover_input(\"binary\",\n+                                             executable.to_str(),\n+                                             workcache_support::digest_only_date(executable));\n+                }\n+                for library in sublib.iter() {\n+                    exe_thing.discover_input(\"binary\",\n+                                             library.to_str(),\n+                                             workcache_support::digest_only_date(library));\n+                }\n+\n+                for transitive_dependency in sub_build_inputs.iter() {\n+                    exe_thing.discover_input(\n+                        \"file\",\n+                        transitive_dependency.to_str(),\n+                        workcache_support::digest_file_with_date(transitive_dependency));\n+                }\n+\n \n                 for exec in subex.iter() {\n                     debug2!(\"Copying: {} -> {}\", exec.display(), sub_target_ex.display());"}, {"sha": "d522bfb15e42dcac0b3b332a3072f1d9dd5319b9", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=1cf029c229660efeca92cf88350bba77b5b7d902", "patch": "@@ -37,7 +37,6 @@ use target::*;\n use package_source::PkgSrc;\n use source_control::{CheckedOutSources, DirToUse, safe_git_clone};\n use exit_codes::{BAD_FLAG_CODE, COPY_FAILED_CODE};\n-use util::datestamp;\n \n fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n     let context = workcache::Context::new(\n@@ -507,6 +506,7 @@ fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n                                                                          os::EXE_SUFFIX))\n }\n \n+#[cfg(target_os = \"linux\")]\n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n     use conditions::bad_path::cond;\n     let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n@@ -515,7 +515,26 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n         if p.extension_str() == Some(\"rs\") {\n             // should be able to do this w/o a process\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            if run::process_output(\"touch\", [p.as_str().unwrap().to_owned()]).status != 0 {\n+            // n.b. Bumps time up by 2 seconds to get around granularity issues\n+            if run::process_output(\"touch\", [~\"-A\", ~\"02\", p.to_str()]).status != 0 {\n+                let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(not(target_os = \"linux\"))]\n+fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n+    use conditions::bad_path::cond;\n+    let pkg_src_dir = workspace.join_many([~\"src\", pkgid.to_str()]);\n+    let contents = os::list_dir_path(&pkg_src_dir);\n+    for p in contents.iter() {\n+        if p.extension_str() == Some(\"rs\") {\n+            // should be able to do this w/o a process\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            // n.b. Bumps time up by 2 seconds to get around granularity issues\n+            if run::process_output(\"touch\", [~\"-A02\",\n+                                             p.as_str().unwrap().to_owned()]).status != 0 {\n                 let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n             }\n         }\n@@ -1033,12 +1052,17 @@ fn no_rebuilding() {\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n-    let date = datestamp(&built_library_in_workspace(&p_id,\n-                                                     workspace).expect(\"no_rebuilding\"));\n+    let foo_lib = lib_output_file_name(workspace, \"foo\");\n+    // Now make `foo` read-only so that subsequent rebuilds of it will fail\n+    assert!(chmod_read_only(&foo_lib));\n+\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n-    let newdate = datestamp(&built_library_in_workspace(&p_id,\n-                                                        workspace).expect(\"no_rebuilding (2)\"));\n-    assert_eq!(date, newdate);\n+\n+    match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n+        Success(*) => (), // ok\n+        Fail(status) if status == 65 => fail2!(\"no_rebuilding failed: it tried to rebuild bar\"),\n+        Fail(_) => fail2!(\"no_rebuilding failed for some other reason\")\n+    }\n }\n \n #[test]\n@@ -1049,55 +1073,55 @@ fn no_rebuilding_dep() {\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     let bar_lib = lib_output_file_name(workspace, \"bar\");\n-    let bar_date_1 = datestamp(&bar_lib);\n-\n     frob_source_file(workspace, &p_id, \"main.rs\");\n-\n     // Now make `bar` read-only so that subsequent rebuilds of it will fail\n     assert!(chmod_read_only(&bar_lib));\n-\n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => (), // ok\n         Fail(status) if status == 65 => fail2!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n         Fail(_) => fail2!(\"no_rebuilding_dep failed for some other reason\")\n     }\n-\n-    let bar_date_2 = datestamp(&bar_lib);\n-    assert_eq!(bar_date_1, bar_date_2);\n }\n \n #[test]\n-#[ignore]\n fn do_rebuild_dep_dates_change() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     let bar_lib_name = lib_output_file_name(workspace, \"bar\");\n-    let bar_date = datestamp(&bar_lib_name);\n-    debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.display(), bar_date);\n     touch_source_file(workspace, &dep_id);\n-    command_line_test([~\"build\", ~\"foo\"], workspace);\n-    let new_bar_date = datestamp(&bar_lib_name);\n-    debug2!(\"Datestamp on {} is {:?}\", bar_lib_name.display(), new_bar_date);\n-    assert!(new_bar_date > bar_date);\n+\n+    // Now make `bar` read-only so that subsequent rebuilds of it will fail\n+    assert!(chmod_read_only(&bar_lib_name));\n+\n+    match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n+        Success(*) => fail2!(\"do_rebuild_dep_dates_change failed: it didn't rebuild bar\"),\n+        Fail(status) if status == 65 => (), // ok\n+        Fail(_) => fail2!(\"do_rebuild_dep_dates_change failed for some other reason\")\n+    }\n }\n \n #[test]\n-#[ignore]\n fn do_rebuild_dep_only_contents_change() {\n     let p_id = PkgId::new(\"foo\");\n     let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n-    let bar_date = datestamp(&lib_output_file_name(workspace, \"bar\"));\n     frob_source_file(workspace, &dep_id, \"lib.rs\");\n+    let bar_lib_name = lib_output_file_name(workspace, \"bar\");\n+\n+    // Now make `bar` read-only so that subsequent rebuilds of it will fail\n+    assert!(chmod_read_only(&bar_lib_name));\n+\n     // should adjust the datestamp\n-    command_line_test([~\"build\", ~\"foo\"], workspace);\n-    let new_bar_date = datestamp(&lib_output_file_name(workspace, \"bar\"));\n-    assert!(new_bar_date > bar_date);\n+    match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n+        Success(*) => fail2!(\"do_rebuild_dep_only_contents_change failed: it didn't rebuild bar\"),\n+        Fail(status) if status == 65 => (), // ok\n+        Fail(_) => fail2!(\"do_rebuild_dep_only_contents_change failed for some other reason\")\n+    }\n }\n \n #[test]\n@@ -2003,7 +2027,7 @@ fn test_rustpkg_test_output() {\n }\n \n #[test]\n-#[ignore(reason = \"See issue #9441\")]\n+#[ignore(reason = \"Issue 9441\")]\n fn test_rebuild_when_needed() {\n     let foo_id = PkgId::new(\"foo\");\n     let foo_workspace = create_local_package(&foo_id);"}, {"sha": "12b4ce2a8811e2b8367965abe3d3d1e629bf387e", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf029c229660efeca92cf88350bba77b5b7d902/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=1cf029c229660efeca92cf88350bba77b5b7d902", "patch": "@@ -30,6 +30,8 @@ use workspace::pkg_parent_workspaces;\n use path_util::{U_RWX, system_library, target_build_dir};\n use path_util::{default_workspace, built_library_in_workspace};\n pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n+pub use target::{Target, Build, Install};\n+use extra::treemap::TreeMap;\n use workcache_support::{digest_file_with_date, digest_only_date};\n \n // It would be nice to have the list of commands in just one place -- for example,\n@@ -166,6 +168,7 @@ pub fn compile_input(context: &BuildContext,\n                      pkg_id: &PkgId,\n                      in_file: &Path,\n                      workspace: &Path,\n+                     deps: &mut DepMap,\n                      flags: &[~str],\n                      cfgs: &[~str],\n                      opt: bool,\n@@ -265,7 +268,7 @@ pub fn compile_input(context: &BuildContext,\n     let mut crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n     crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n \n-    find_and_install_dependencies(context, pkg_id, sess, exec, &crate,\n+    find_and_install_dependencies(context, pkg_id, in_file, sess, exec, &crate, deps,\n                                   |p| {\n                                       debug2!(\"a dependency: {}\", p.display());\n                                       // Pass the directory containing a dependency\n@@ -329,6 +332,7 @@ pub fn compile_input(context: &BuildContext,\n // If crate_opt is present, then finish compilation. If it's None, then\n // call compile_upto and return the crate\n // also, too many arguments\n+// Returns list of discovered dependencies\n pub fn compile_crate_from_input(input: &Path,\n                                 exec: &mut workcache::Exec,\n                                 stop_before: StopBefore,\n@@ -390,29 +394,34 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n pub fn compile_crate(ctxt: &BuildContext,\n                      exec: &mut workcache::Exec,\n                      pkg_id: &PkgId,\n-                     crate: &Path, workspace: &Path,\n-                     flags: &[~str], cfgs: &[~str], opt: bool,\n+                     crate: &Path,\n+                     workspace: &Path,\n+                     deps: &mut DepMap,\n+                     flags: &[~str],\n+                     cfgs: &[~str],\n+                     opt: bool,\n                      what: OutputType) -> Option<Path> {\n     debug2!(\"compile_crate: crate={}, workspace={}\", crate.display(), workspace.display());\n     debug2!(\"compile_crate: short_name = {}, flags =...\", pkg_id.to_str());\n     for fl in flags.iter() {\n         debug2!(\"+++ {}\", *fl);\n     }\n-    compile_input(ctxt, exec, pkg_id, crate, workspace, flags, cfgs, opt, what)\n+    compile_input(ctxt, exec, pkg_id, crate, workspace, deps, flags, cfgs, opt, what)\n }\n \n struct ViewItemVisitor<'self> {\n     context: &'self BuildContext,\n     parent: &'self PkgId,\n+    parent_crate: &'self Path,\n     sess: session::Session,\n     exec: &'self mut workcache::Exec,\n     c: &'self ast::Crate,\n     save: &'self fn(Path),\n+    deps: &'self mut DepMap\n }\n \n impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n     fn visit_view_item(&mut self, vi: &ast::view_item, env: ()) {\n-        debug2!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess\n             ast::view_item_extern_mod(lib_ident, path_opt, _, _) => {\n@@ -432,6 +441,8 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                         // Now we know that this crate has a discovered dependency on\n                         // installed_path\n                         // FIXME (#9639): This needs to handle non-utf8 paths\n+                        add_dep(self.deps, self.parent_crate.to_str(),\n+                                (~\"binary\", installed_path.to_str()));\n                         self.exec.discover_input(\"binary\",\n                                                  installed_path.as_str().unwrap(),\n                                                  digest_only_date(installed_path));\n@@ -465,7 +476,7 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                         // Use the rust_path_hack to search for dependencies iff\n                         // we were already using it\n                                                   self.context.context.use_rust_path_hack,\n-                                                  pkg_id);\n+                                                  pkg_id.clone());\n                         let (outputs_disc, inputs_disc) =\n                             self.context.install(pkg_src, &JustOne(Path::new(lib_crate_filename)));\n                         debug2!(\"Installed {}, returned {:?} dependencies and \\\n@@ -486,14 +497,35 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                             debug2!(\"Installed {} into {}\", dep.display(), dep_dir.display());\n                             (self.save)(dep_dir);\n                         }\n+                        debug2!(\"Installed {}, returned {} dependencies and \\\n+                                {} transitive dependencies\",\n+                                lib_name, outputs_disc.len(), inputs_disc.len());\n+                        // It must have installed *something*...\n+                        assert!(!outputs_disc.is_empty());\n+                        let target_workspace = outputs_disc[0].pop();\n+                        for dep in outputs_disc.iter() {\n+                            debug2!(\"Discovering a binary input: {}\", dep.to_str());\n+                            self.exec.discover_input(\"binary\", dep.to_str(),\n+                                                     digest_only_date(dep));\n+                            add_dep(self.deps,\n+                                    self.parent_crate.to_str(),\n+                                    (~\"binary\", dep.to_str()));\n+                        }\n                         for &(ref what, ref dep) in inputs_disc.iter() {\n                             if *what == ~\"file\" {\n+                                add_dep(self.deps,\n+                                        self.parent_crate.to_str(),\n+                                        (~\"file\", dep.to_str()));\n+\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n                                                          digest_file_with_date(\n                                                              &Path::new(dep.as_slice())));\n                             }\n                                 else if *what == ~\"binary\" {\n+                                add_dep(self.deps,\n+                                        self.parent_crate.to_str(),\n+                                        (~\"binary\", dep.to_str()));\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n                                                          digest_only_date(\n@@ -502,6 +534,10 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                 else {\n                                 fail2!(\"Bad kind: {}\", *what);\n                             }\n+                            // Also, add an additional search path\n+                            debug2!(\"Installed {} into {}\",\n+                                    lib_name, target_workspace.to_str());\n+                            (self.save)(target_workspace.clone());\n                         }\n                     }\n                 }\n@@ -518,18 +554,22 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n /// can't be found.\n pub fn find_and_install_dependencies(context: &BuildContext,\n                                      parent: &PkgId,\n+                                     parent_crate: &Path,\n                                      sess: session::Session,\n                                      exec: &mut workcache::Exec,\n                                      c: &ast::Crate,\n+                                     deps: &mut DepMap,\n                                      save: &fn(Path)) {\n     debug2!(\"In find_and_install_dependencies...\");\n     let mut visitor = ViewItemVisitor {\n         context: context,\n         parent: parent,\n+        parent_crate: parent_crate,\n         sess: sess,\n         exec: exec,\n         c: c,\n         save: save,\n+        deps: deps\n     };\n     visit::walk_crate(&mut visitor, c, ())\n }\n@@ -579,3 +619,19 @@ pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n     debug2!(\"Date = {:?}\", out);\n     out.map(|t| { t as libc::time_t })\n }\n+\n+pub type DepMap = TreeMap<~str, ~[(~str, ~str)]>;\n+\n+/// Records a dependency from `parent` to the kind and value described by `info`,\n+/// in `deps`\n+fn add_dep(deps: &mut DepMap, parent: ~str, info: (~str, ~str)) {\n+    let mut done = false;\n+    let info_clone = info.clone();\n+    match deps.find_mut(&parent) {\n+        None => { }\n+        Some(v) => { done = true; (*v).push(info) }\n+    };\n+    if !done {\n+        deps.insert(parent, ~[info_clone]);\n+    }\n+}"}]}