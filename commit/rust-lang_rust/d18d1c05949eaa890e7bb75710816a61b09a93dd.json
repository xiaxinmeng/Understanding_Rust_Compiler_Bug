{"sha": "d18d1c05949eaa890e7bb75710816a61b09a93dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxOGQxYzA1OTQ5ZWFhODkwZTdiYjc1NzEwODE2YTYxYjA5YTkzZGQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-19T22:19:59Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-20T11:00:50Z"}, "message": "Significantly more glorious marks", "tree": {"sha": "be16530829a82a839a02bef0983bbc520e074579", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be16530829a82a839a02bef0983bbc520e074579"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d18d1c05949eaa890e7bb75710816a61b09a93dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d18d1c05949eaa890e7bb75710816a61b09a93dd", "html_url": "https://github.com/rust-lang/rust/commit/d18d1c05949eaa890e7bb75710816a61b09a93dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d18d1c05949eaa890e7bb75710816a61b09a93dd/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d3fd62f897da50db1b203b86f45b9d2cd272b4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d3fd62f897da50db1b203b86f45b9d2cd272b4d", "html_url": "https://github.com/rust-lang/rust/commit/4d3fd62f897da50db1b203b86f45b9d2cd272b4d"}], "stats": {"total": 94, "additions": 86, "deletions": 8}, "files": [{"sha": "26acf81f284bedf453899dde13478df1e63c8c85", "filename": "crates/ra_assists/src/handlers/add_turbo_fish.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d18d1c05949eaa890e7bb75710816a61b09a93dd/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18d1c05949eaa890e7bb75710816a61b09a93dd/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=d18d1c05949eaa890e7bb75710816a61b09a93dd", "patch": "@@ -1,11 +1,11 @@\n use ra_ide_db::defs::{classify_name_ref, Definition, NameRefClass};\n use ra_syntax::{ast, AstNode, SyntaxKind, T};\n+use test_utils::mark;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n     AssistId,\n };\n-use test_utils::tested_by;\n \n // Assist: add_turbo_fish\n //\n@@ -28,7 +28,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n     let ident = ctx.find_token_at_offset(SyntaxKind::IDENT)?;\n     let next_token = ident.next_token()?;\n     if next_token.kind() == T![::] {\n-        tested_by!(add_turbo_fish_one_fish_is_enough);\n+        mark::hit!(add_turbo_fish_one_fish_is_enough);\n         return None;\n     }\n     let name_ref = ast::NameRef::cast(ident.parent())?;\n@@ -42,7 +42,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n     };\n     let generics = hir::GenericDef::Function(fun).params(ctx.sema.db);\n     if generics.is_empty() {\n-        tested_by!(add_turbo_fish_non_generic);\n+        mark::hit!(add_turbo_fish_non_generic);\n         return None;\n     }\n     acc.add(AssistId(\"add_turbo_fish\"), \"Add `::<>`\", ident.text_range(), |builder| {\n@@ -58,7 +58,7 @@ mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n-    use test_utils::covers;\n+    use test_utils::mark;\n \n     #[test]\n     fn add_turbo_fish_function() {\n@@ -106,7 +106,7 @@ fn main() {\n \n     #[test]\n     fn add_turbo_fish_one_fish_is_enough() {\n-        covers!(add_turbo_fish_one_fish_is_enough);\n+        mark::check!(add_turbo_fish_one_fish_is_enough);\n         check_assist_not_applicable(\n             add_turbo_fish,\n             r#\"\n@@ -120,7 +120,7 @@ fn main() {\n \n     #[test]\n     fn add_turbo_fish_non_generic() {\n-        covers!(add_turbo_fish_non_generic);\n+        mark::check!(add_turbo_fish_non_generic);\n         check_assist_not_applicable(\n             add_turbo_fish,\n             r#\""}, {"sha": "525ec4abc382795e459ca81ef96db31eef2c3791", "filename": "crates/ra_assists/src/marks.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18d1c05949eaa890e7bb75710816a61b09a93dd/crates%2Fra_assists%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18d1c05949eaa890e7bb75710816a61b09a93dd/crates%2Fra_assists%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fmarks.rs?ref=d18d1c05949eaa890e7bb75710816a61b09a93dd", "patch": "@@ -10,6 +10,4 @@ test_utils::marks![\n     test_not_applicable_if_variable_unused\n     change_visibility_field_false_positive\n     test_add_from_impl_already_exists\n-    add_turbo_fish_one_fish_is_enough\n-    add_turbo_fish_non_generic\n ];"}, {"sha": "4e05d464f065203e6ca2a713322cb13318864550", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d18d1c05949eaa890e7bb75710816a61b09a93dd/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18d1c05949eaa890e7bb75710816a61b09a93dd/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=d18d1c05949eaa890e7bb75710816a61b09a93dd", "patch": "@@ -8,6 +8,8 @@\n \n #[macro_use]\n pub mod marks;\n+#[macro_use]\n+pub mod mark;\n \n use std::{\n     fs,"}, {"sha": "7c309a89458994f03207e9a71ced529bcc2eedbf", "filename": "crates/test_utils/src/mark.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d18d1c05949eaa890e7bb75710816a61b09a93dd/crates%2Ftest_utils%2Fsrc%2Fmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18d1c05949eaa890e7bb75710816a61b09a93dd/crates%2Ftest_utils%2Fsrc%2Fmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmark.rs?ref=d18d1c05949eaa890e7bb75710816a61b09a93dd", "patch": "@@ -0,0 +1,78 @@\n+//! This module implements manually tracked test coverage, which is useful for\n+//! quickly finding a test responsible for testing a particular bit of code.\n+//!\n+//! See <https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html>\n+//! for details, but the TL;DR is that you write your test as\n+//!\n+//! ```\n+//! #[test]\n+//! fn test_foo() {\n+//!     mark::check!(test_foo);\n+//! }\n+//! ```\n+//!\n+//! and in the code under test you write\n+//!\n+//! ```\n+//! # use test_utils::mark;\n+//! # fn some_condition() -> bool { true }\n+//! fn foo() {\n+//!     if some_condition() {\n+//!         mark::hit!(test_foo);\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! This module then checks that executing the test indeed covers the specified\n+//! function. This is useful if you come back to the `foo` function ten years\n+//! later and wonder where the test are: now you can grep for `test_foo`.\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+#[macro_export]\n+macro_rules! _hit {\n+    ($ident:ident) => {{\n+        #[cfg(test)]\n+        {\n+            extern \"C\" {\n+                #[no_mangle]\n+                static $ident: std::sync::atomic::AtomicUsize;\n+            }\n+            unsafe {\n+                $ident.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n+            }\n+        }\n+    }};\n+}\n+pub use _hit as hit;\n+\n+#[macro_export]\n+macro_rules! _check {\n+    ($ident:ident) => {\n+        #[no_mangle]\n+        static $ident: std::sync::atomic::AtomicUsize = std::sync::atomic::AtomicUsize::new(0);\n+        let _checker = $crate::mark::MarkChecker::new(&$ident);\n+    };\n+}\n+pub use _check as check;\n+\n+pub struct MarkChecker {\n+    mark: &'static AtomicUsize,\n+    value_on_entry: usize,\n+}\n+\n+impl MarkChecker {\n+    pub fn new(mark: &'static AtomicUsize) -> MarkChecker {\n+        let value_on_entry = mark.load(Ordering::SeqCst);\n+        MarkChecker { mark, value_on_entry }\n+    }\n+}\n+\n+impl Drop for MarkChecker {\n+    fn drop(&mut self) {\n+        if std::thread::panicking() {\n+            return;\n+        }\n+        let value_on_exit = self.mark.load(Ordering::SeqCst);\n+        assert!(value_on_exit > self.value_on_entry, \"mark was not hit\")\n+    }\n+}"}]}