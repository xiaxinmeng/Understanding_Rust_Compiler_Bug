{"sha": "a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "node_id": "C_kwDOAAsO6NoAKGEwZDJkOWYzMTVmZWU3YjRhYjEyNzViMWZlNTUwMGNkNWQ2ZjE0YTE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-06-29T16:04:58Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-04T12:35:20Z"}, "message": "implied bounds byebye nested hir ids", "tree": {"sha": "8c4b0fb9a76685c8133ab4dc28e0922506749a3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c4b0fb9a76685c8133ab4dc28e0922506749a3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "html_url": "https://github.com/rust-lang/rust/commit/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14", "url": "https://api.github.com/repos/rust-lang/rust/commits/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14", "html_url": "https://github.com/rust-lang/rust/commit/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14"}], "stats": {"total": 157, "additions": 28, "deletions": 129}, "files": [{"sha": "b897de7315a02dd2b0c6f14592379d1f6059d4a4", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 10, "deletions": 78, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "patch": "@@ -1,8 +1,6 @@\n use crate::infer::free_regions::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n \n use super::explicit_outlives_bounds;\n@@ -31,9 +29,7 @@ pub struct OutlivesEnvironment<'tcx> {\n     pub param_env: ty::ParamEnv<'tcx>,\n     free_region_map: FreeRegionMap<'tcx>,\n \n-    // Contains, for each body B that we are checking (that is, the fn\n-    // item, but also any nested closures), the set of implied region\n-    // bounds that are in scope in that particular body.\n+    // Contains the implied region bounds in scope for our current body.\n     //\n     // Example:\n     //\n@@ -43,24 +39,15 @@ pub struct OutlivesEnvironment<'tcx> {\n     // } // body B0\n     // ```\n     //\n-    // Here, for body B0, the list would be `[T: 'a]`, because we\n+    // Here, when checking the body B0, the list would be `[T: 'a]`, because we\n     // infer that `T` must outlive `'a` from the implied bounds on the\n     // fn declaration.\n     //\n-    // For the body B1, the list would be `[T: 'a, T: 'b]`, because we\n+    // For the body B1 however, the list would be `[T: 'a, T: 'b]`, because we\n     // also can see that -- within the closure body! -- `T` must\n     // outlive `'b`. This is not necessarily true outside the closure\n     // body, since the closure may never be called.\n-    //\n-    // We collect this map as we descend the tree. We then use the\n-    // results when proving outlives obligations like `T: 'x` later\n-    // (e.g., if `T: 'x` must be proven within the body B1, then we\n-    // know it is true if either `'a: 'x` or `'b: 'x`).\n-    region_bound_pairs_map: FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n-\n-    // Used to compute `region_bound_pairs_map`: contains the set of\n-    // in-scope region-bound pairs thus far.\n-    region_bound_pairs_accum: RegionBoundPairs<'tcx>,\n+    region_bound_pairs: RegionBoundPairs<'tcx>,\n }\n \n /// \"Region-bound pairs\" tracks outlives relations that are known to\n@@ -73,8 +60,7 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n         let mut env = OutlivesEnvironment {\n             param_env,\n             free_region_map: Default::default(),\n-            region_bound_pairs_map: Default::default(),\n-            region_bound_pairs_accum: vec![],\n+            region_bound_pairs: Default::default(),\n         };\n \n         env.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n@@ -87,62 +73,9 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n         &self.free_region_map\n     }\n \n-    /// Borrows current value of the `region_bound_pairs`.\n-    pub fn region_bound_pairs_map(&self) -> &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>> {\n-        &self.region_bound_pairs_map\n-    }\n-\n-    /// This is a hack to support the old-school regionck, which\n-    /// processes region constraints from the main function and the\n-    /// closure together. In that context, when we enter a closure, we\n-    /// want to be able to \"save\" the state of the surrounding a\n-    /// function. We can then add implied bounds and the like from the\n-    /// closure arguments into the environment -- these should only\n-    /// apply in the closure body, so once we exit, we invoke\n-    /// `pop_snapshot_post_typeck_child` to remove them.\n-    ///\n-    /// Example:\n-    ///\n-    /// ```ignore (pseudo-rust)\n-    /// fn foo<T>() {\n-    ///    callback(for<'a> |x: &'a T| {\n-    ///         // ^^^^^^^ not legal syntax, but probably should be\n-    ///         // within this closure body, `T: 'a` holds\n-    ///    })\n-    /// }\n-    /// ```\n-    ///\n-    /// This \"containment\" of closure's effects only works so well. In\n-    /// particular, we (intentionally) leak relationships between free\n-    /// regions that are created by the closure's bounds. The case\n-    /// where this is useful is when you have (e.g.) a closure with a\n-    /// signature like `for<'a, 'b> fn(x: &'a &'b u32)` -- in this\n-    /// case, we want to keep the relationship `'b: 'a` in the\n-    /// free-region-map, so that later if we have to take `LUB('b,\n-    /// 'a)` we can get the result `'b`.\n-    ///\n-    /// I have opted to keep **all modifications** to the\n-    /// free-region-map, however, and not just those that concern free\n-    /// variables bound in the closure. The latter seems more correct,\n-    /// but it is not the existing behavior, and I could not find a\n-    /// case where the existing behavior went wrong. In any case, it\n-    /// seems like it'd be readily fixed if we wanted. There are\n-    /// similar leaks around givens that seem equally suspicious, to\n-    /// be honest. --nmatsakis\n-    pub fn push_snapshot_pre_typeck_child(&self) -> usize {\n-        self.region_bound_pairs_accum.len()\n-    }\n-\n-    /// See `push_snapshot_pre_typeck_child`.\n-    pub fn pop_snapshot_post_typeck_child(&mut self, len: usize) {\n-        self.region_bound_pairs_accum.truncate(len);\n-    }\n-\n-    /// Save the current set of region-bound pairs under the given `body_id`.\n-    pub fn save_implied_bounds(&mut self, body_id: hir::HirId) {\n-        let old =\n-            self.region_bound_pairs_map.insert(body_id, self.region_bound_pairs_accum.clone());\n-        assert!(old.is_none());\n+    /// Borrows current `region_bound_pairs`.\n+    pub fn region_bound_pairs(&self) -> &RegionBoundPairs<'tcx> {\n+        &self.region_bound_pairs\n     }\n \n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n@@ -164,11 +97,10 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n             debug!(\"add_outlives_bounds: outlives_bound={:?}\", outlives_bound);\n             match outlives_bound {\n                 OutlivesBound::RegionSubParam(r_a, param_b) => {\n-                    self.region_bound_pairs_accum.push((r_a, GenericKind::Param(param_b)));\n+                    self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n                 }\n                 OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n-                    self.region_bound_pairs_accum\n-                        .push((r_a, GenericKind::Projection(projection_b)));\n+                    self.region_bound_pairs.push((r_a, GenericKind::Projection(projection_b)));\n                 }\n                 OutlivesBound::RegionSubRegion(r_a, r_b) => {\n                     if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {"}, {"sha": "91d6479c5cd81ede14ef522ae3b439a50ebb18dd", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "patch": "@@ -60,19 +60,17 @@\n //! imply that `'b: 'a`.\n \n use crate::infer::outlives::components::{push_outlives_components, Component};\n+use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::outlives::verify::VerifyBoundCx;\n use crate::infer::{\n     self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, UndoLog, VerifyBound,\n };\n use crate::traits::{ObligationCause, ObligationCauseCode};\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n-\n-use crate::infer::outlives::env::OutlivesEnvironment;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_hir as hir;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n use smallvec::smallvec;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n@@ -145,10 +143,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// - `param_env` is the parameter environment for the enclosing function.\n     /// - `body_id` is the body-id whose region obligations are being\n     ///   processed.\n-    #[instrument(level = \"debug\", skip(self, region_bound_pairs_map))]\n+    #[instrument(level = \"debug\", skip(self, region_bound_pairs))]\n     pub fn process_registered_region_obligations(\n         &self,\n-        region_bound_pairs_map: &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n+        region_bound_pairs: &RegionBoundPairs<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) {\n         assert!(\n@@ -158,24 +156,17 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n         let my_region_obligations = self.take_registered_region_obligations();\n \n-        for (body_id, RegionObligation { sup_type, sub_region, origin }) in my_region_obligations {\n+        for (_body_id, RegionObligation { sup_type, sub_region, origin }) in my_region_obligations {\n             debug!(\n                 \"process_registered_region_obligations: sup_type={:?} sub_region={:?} origin={:?}\",\n                 sup_type, sub_region, origin\n             );\n \n             let sup_type = self.resolve_vars_if_possible(sup_type);\n \n-            if let Some(region_bound_pairs) = region_bound_pairs_map.get(&body_id) {\n-                let outlives =\n-                    &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n-                outlives.type_must_outlive(origin, sup_type, sub_region);\n-            } else {\n-                self.tcx.sess.delay_span_bug(\n-                    origin.span(),\n-                    &format!(\"no region-bound-pairs for {:?}\", body_id),\n-                );\n-            }\n+            let outlives =\n+                &mut TypeOutlives::new(self, self.tcx, &region_bound_pairs, None, param_env);\n+            outlives.type_must_outlive(origin, sup_type, sub_region);\n         }\n     }\n \n@@ -184,7 +175,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         outlives_env: &OutlivesEnvironment<'tcx>,\n     ) {\n         self.process_registered_region_obligations(\n-            outlives_env.region_bound_pairs_map(),\n+            outlives_env.region_bound_pairs(),\n             outlives_env.param_env,\n         );\n "}, {"sha": "49434ec142828d8ae3e35fbe892afb82eb144ce0", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "patch": "@@ -212,15 +212,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n             }\n \n-            let body_id_map: FxHashMap<_, _> = infcx\n-                .inner\n-                .borrow()\n-                .region_obligations()\n-                .iter()\n-                .map(|&(id, _)| (id, vec![]))\n-                .collect();\n-\n-            infcx.process_registered_region_obligations(&body_id_map, full_env);\n+            infcx.process_registered_region_obligations(&Default::default(), full_env);\n \n             let region_data = infcx\n                 .inner"}, {"sha": "ae69f2f7eb3244d5fc82346e488a17908bdfaf65", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "patch": "@@ -16,7 +16,6 @@ use crate::traits::{\n //use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::CRATE_HIR_ID;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::{util, TraitEngine};\n use rustc_middle::traits::specialization_graph::OverlapMode;\n@@ -394,17 +393,9 @@ fn resolve_negative_obligation<'cx, 'tcx>(\n         return false;\n     }\n \n-    let mut outlives_env = OutlivesEnvironment::new(param_env);\n-    // FIXME -- add \"assumed to be well formed\" types into the `outlives_env`\n-\n-    // \"Save\" the accumulated implied bounds into the outlives environment\n-    // (due to the FIXME above, there aren't any, but this step is still needed).\n-    // The \"body id\" is given as `CRATE_HIR_ID`, which is the same body-id used\n-    // by the \"dummy\" causes elsewhere (body-id is only relevant when checking\n-    // function bodies with closures).\n-    outlives_env.save_implied_bounds(CRATE_HIR_ID);\n-\n-    infcx.process_registered_region_obligations(outlives_env.region_bound_pairs_map(), param_env);\n+    // FIXME -- also add \"assumed to be well formed\" types into the `outlives_env`\n+    let outlives_env = OutlivesEnvironment::new(param_env);\n+    infcx.process_registered_region_obligations(outlives_env.region_bound_pairs(), param_env);\n \n     let errors = infcx.resolve_regions(&outlives_env);\n "}, {"sha": "ef74214781e5d614d5e1476bb5457d592d152b9b", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "patch": "@@ -737,8 +737,7 @@ fn check_opaque_meets_bounds<'tcx>(\n             hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n             // Can have different predicates to their defining use\n             hir::OpaqueTyOrigin::TyAlias => {\n-                let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-                outlives_environment.save_implied_bounds(hir_id);\n+                let outlives_environment = OutlivesEnvironment::new(param_env);\n                 infcx.check_region_obligations_and_report_errors(&outlives_environment);\n             }\n         }"}, {"sha": "0a9b6863ef577cf42a7c51bd4671555fef8ae88b", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "patch": "@@ -403,7 +403,6 @@ fn compare_predicate_entailment<'tcx>(\n         // lifetime parameters.\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n         outlives_environment.add_implied_bounds(infcx, wf_tys, impl_m_hir_id);\n-        outlives_environment.save_implied_bounds(impl_m_hir_id);\n         infcx.check_region_obligations_and_report_errors(&outlives_environment);\n \n         Ok(())\n@@ -1159,8 +1158,7 @@ pub(crate) fn compare_const_impl<'tcx>(\n             return;\n         }\n \n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.save_implied_bounds(impl_c_hir_id);\n+        let outlives_environment = OutlivesEnvironment::new(param_env);\n         infcx.resolve_regions_and_report_errors(&outlives_environment);\n     });\n }\n@@ -1279,8 +1277,7 @@ fn compare_type_predicate_entailment<'tcx>(\n \n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.save_implied_bounds(impl_ty_hir_id);\n+        let outlives_environment = OutlivesEnvironment::new(param_env);\n         infcx.check_region_obligations_and_report_errors(&outlives_environment);\n \n         Ok(())\n@@ -1514,7 +1511,6 @@ pub fn check_type_bounds<'tcx>(\n         };\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n         outlives_environment.add_implied_bounds(infcx, implied_bounds, impl_ty_hir_id);\n-        outlives_environment.save_implied_bounds(impl_ty_hir_id);\n         infcx.check_region_obligations_and_report_errors(&outlives_environment);\n \n         Ok(())"}, {"sha": "c76c3a4c7baee14901ffeed19ed7daaf8432d5dd", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=a0d2d9f315fee7b4ab1275b1fe5500cd5d6f14a1", "patch": "@@ -65,7 +65,6 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n \n             let mut outlives_environment = OutlivesEnvironment::new(param_env);\n             outlives_environment.add_implied_bounds(&fcx.infcx, wf_tys, id);\n-            outlives_environment.save_implied_bounds(id);\n             fcx.infcx.check_region_obligations_and_report_errors(&outlives_environment);\n         });\n     }\n@@ -660,8 +659,7 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     tcx.infer_ctxt().enter(|infcx| {\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n         outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id);\n-        outlives_environment.save_implied_bounds(id);\n-        let region_bound_pairs = outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n+        let region_bound_pairs = outlives_environment.region_bound_pairs();\n \n         add_constraints(&infcx, region_bound_pairs);\n "}]}