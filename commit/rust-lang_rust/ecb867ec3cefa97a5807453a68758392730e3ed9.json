{"sha": "ecb867ec3cefa97a5807453a68758392730e3ed9", "node_id": "C_kwDOAAsO6NoAKGVjYjg2N2VjM2NlZmE5N2E1ODA3NDUzYTY4NzU4MzkyNzMwZTNlZDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-07T15:25:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-07T15:25:42Z"}, "message": "Auto merge of #94690 - nnethercote:clarify-Layout-interning, r=fee1-dead\n\nClarify `Layout` interning.\n\n`Layout` is another type that is sometimes interned, sometimes not, and\nwe always use references to refer to it so we can't take any advantage\nof the uniqueness properties for hashing or equality checks.\n\nThis commit renames `Layout` as `LayoutS`, and then introduces a new\n`Layout` that is a newtype around an `Interned<LayoutS>`. It also\ninterns more layouts than before. Previously layouts within layouts\n(via the `variants` field) were never interned, but now they are. Hence\nthe lifetime on the new `Layout` type.\n\nUnlike other interned types, these ones are in `rustc_target` instead of\n`rustc_middle`. This reflects the existing structure of the code, which\ndoes layout-specific stuff in `rustc_target` while `TyAndLayout` is\ngeneric over the `Ty`, allowing the type-specific stuff to occur in\n`rustc_middle`.\n\nThe commit also adds a `HashStable` impl for `Interned`, which was\nneeded. It hashes the contents, unlike the `Hash` impl which hashes the\npointer.\n\nr? `@fee1-dead`", "tree": {"sha": "8b55d487239c18869cf041a34cd2082c7107db95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b55d487239c18869cf041a34cd2082c7107db95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecb867ec3cefa97a5807453a68758392730e3ed9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecb867ec3cefa97a5807453a68758392730e3ed9", "html_url": "https://github.com/rust-lang/rust/commit/ecb867ec3cefa97a5807453a68758392730e3ed9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecb867ec3cefa97a5807453a68758392730e3ed9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3", "html_url": "https://github.com/rust-lang/rust/commit/d137c3a7bd3b180317044f8ccb9a8b4b3bb07db3"}, {"sha": "4f008e06c33e1ef729bce839c0899154e71902b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f008e06c33e1ef729bce839c0899154e71902b0", "html_url": "https://github.com/rust-lang/rust/commit/4f008e06c33e1ef729bce839c0899154e71902b0"}], "stats": {"total": 264, "additions": 177, "deletions": 87}, "files": [{"sha": "37d2679c10d70af2f21316bf404ecbd29eecf4a8", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -82,8 +82,14 @@ pub(super) fn add_local_place_comments<'tcx>(\n         return;\n     }\n     let TyAndLayout { ty, layout } = place.layout();\n-    let rustc_target::abi::Layout { size, align, abi: _, variants: _, fields: _, largest_niche: _ } =\n-        layout;\n+    let rustc_target::abi::LayoutS {\n+        size,\n+        align,\n+        abi: _,\n+        variants: _,\n+        fields: _,\n+        largest_niche: _,\n+    } = layout.0.0;\n \n     let (kind, extra) = match *place.inner() {\n         CPlaceInner::Var(place_local, var) => {"}, {"sha": "6489b96be4b2d037e212ba7b650c7adfab7bd02f", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -1070,7 +1070,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         };\n \n         raw_eq, (v lhs_ref, v rhs_ref) {\n-            let size = fx.layout_of(substs.type_at(0)).layout.size;\n+            let size = fx.layout_of(substs.type_at(0)).layout.size();\n             // FIXME add and use emit_small_memcmp\n             let is_eq_value =\n                 if size == Size::ZERO {"}, {"sha": "ef213f5636907811ad4c0354e1e99153f5dfe287", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -272,20 +272,20 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     use rustc_target::abi::Abi::*;\n                     let tp_ty = substs.type_at(0);\n                     let layout = self.layout_of(tp_ty).layout;\n-                    let _use_integer_compare = match layout.abi {\n+                    let _use_integer_compare = match layout.abi() {\n                         Scalar(_) | ScalarPair(_, _) => true,\n                         Uninhabited | Vector { .. } => false,\n                         Aggregate { .. } => {\n                             // For rusty ABIs, small aggregates are actually passed\n                             // as `RegKind::Integer` (see `FnAbi::adjust_for_abi`),\n                             // so we re-use that same threshold here.\n-                            layout.size <= self.data_layout().pointer_size * 2\n+                            layout.size() <= self.data_layout().pointer_size * 2\n                         }\n                     };\n \n                     let a = args[0].immediate();\n                     let b = args[1].immediate();\n-                    if layout.size.bytes() == 0 {\n+                    if layout.size().bytes() == 0 {\n                         self.const_bool(true)\n                     }\n                     /*else if use_integer_compare {\n@@ -301,7 +301,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         let void_ptr_type = self.context.new_type::<*const ()>();\n                         let a_ptr = self.bitcast(a, void_ptr_type);\n                         let b_ptr = self.bitcast(b, void_ptr_type);\n-                        let n = self.context.new_cast(None, self.const_usize(layout.size.bytes()), self.sizet_type);\n+                        let n = self.context.new_cast(None, self.const_usize(layout.size().bytes()), self.sizet_type);\n                         let builtin = self.context.get_builtin_function(\"memcmp\");\n                         let cmp = self.context.new_call(None, builtin, &[a_ptr, b_ptr, n]);\n                         self.icmp(IntPredicate::IntEQ, cmp, self.const_i32(0))"}, {"sha": "7f804ab5e6347aad8a5e9a4809420c65990b77c5", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -300,34 +300,34 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 use abi::Abi::*;\n                 let tp_ty = substs.type_at(0);\n                 let layout = self.layout_of(tp_ty).layout;\n-                let use_integer_compare = match layout.abi {\n+                let use_integer_compare = match layout.abi() {\n                     Scalar(_) | ScalarPair(_, _) => true,\n                     Uninhabited | Vector { .. } => false,\n                     Aggregate { .. } => {\n                         // For rusty ABIs, small aggregates are actually passed\n                         // as `RegKind::Integer` (see `FnAbi::adjust_for_abi`),\n                         // so we re-use that same threshold here.\n-                        layout.size <= self.data_layout().pointer_size * 2\n+                        layout.size() <= self.data_layout().pointer_size * 2\n                     }\n                 };\n \n                 let a = args[0].immediate();\n                 let b = args[1].immediate();\n-                if layout.size.bytes() == 0 {\n+                if layout.size().bytes() == 0 {\n                     self.const_bool(true)\n                 } else if use_integer_compare {\n-                    let integer_ty = self.type_ix(layout.size.bits());\n+                    let integer_ty = self.type_ix(layout.size().bits());\n                     let ptr_ty = self.type_ptr_to(integer_ty);\n                     let a_ptr = self.bitcast(a, ptr_ty);\n-                    let a_val = self.load(integer_ty, a_ptr, layout.align.abi);\n+                    let a_val = self.load(integer_ty, a_ptr, layout.align().abi);\n                     let b_ptr = self.bitcast(b, ptr_ty);\n-                    let b_val = self.load(integer_ty, b_ptr, layout.align.abi);\n+                    let b_val = self.load(integer_ty, b_ptr, layout.align().abi);\n                     self.icmp(IntPredicate::IntEQ, a_val, b_val)\n                 } else {\n                     let i8p_ty = self.type_i8p();\n                     let a_ptr = self.bitcast(a, i8p_ty);\n                     let b_ptr = self.bitcast(b, i8p_ty);\n-                    let n = self.const_usize(layout.size.bytes());\n+                    let n = self.const_usize(layout.size().bytes());\n                     let cmp = self.call_intrinsic(\"memcmp\", &[a_ptr, b_ptr, n]);\n                     self.icmp(IntPredicate::IntEQ, cmp, self.const_i32(0))\n                 }"}, {"sha": "62a297937d40c66c2856fa5746f67f6123e64cb2", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -427,7 +427,7 @@ fn push_debuginfo_type_name<'tcx>(\n \n             // calculate the range of values for the dataful variant\n             let dataful_discriminant_range =\n-                dataful_variant_layout.largest_niche.unwrap().scalar.valid_range;\n+                dataful_variant_layout.largest_niche().unwrap().scalar.valid_range;\n \n             let min = dataful_discriminant_range.start;\n             let min = tag.value.size(&tcx).truncate(min);"}, {"sha": "7a320b10b60300460fc3efe19811798742efb599", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -1,3 +1,4 @@\n+use crate::stable_hasher::{HashStable, StableHasher};\n use std::cmp::Ordering;\n use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n@@ -98,5 +99,14 @@ impl<'a, T> Hash for Interned<'a, T> {\n     }\n }\n \n+impl<T, CTX> HashStable<CTX> for Interned<'_, T>\n+where\n+    T: HashStable<CTX>,\n+{\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.0.hash_stable(hcx, hasher);\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "b6b73ba45391ea1d3d19e3b999bdbf634b8855e6", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -2861,8 +2861,8 @@ impl ClashingExternDeclarations {\n \n                 let compare_layouts = |a, b| -> Result<bool, LayoutError<'tcx>> {\n                     debug!(\"compare_layouts({:?}, {:?})\", a, b);\n-                    let a_layout = &cx.layout_of(a)?.layout.abi;\n-                    let b_layout = &cx.layout_of(b)?.layout.abi;\n+                    let a_layout = &cx.layout_of(a)?.layout.abi();\n+                    let b_layout = &cx.layout_of(b)?.layout.abi();\n                     debug!(\n                         \"comparing layouts: {:?} == {:?} = {}\",\n                         a_layout,"}, {"sha": "0d5e1e7f5513cc25dce49be4dd462b85cb906d5f", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -1349,7 +1349,7 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n             let (largest, slargest, largest_index) = iter::zip(enum_definition.variants, variants)\n                 .map(|(variant, variant_layout)| {\n                     // Subtract the size of the enum tag.\n-                    let bytes = variant_layout.size.bytes().saturating_sub(tag_size);\n+                    let bytes = variant_layout.size().bytes().saturating_sub(tag_size);\n \n                     debug!(\"- variant `{}` is {} bytes large\", variant.ident, bytes);\n                     bytes"}, {"sha": "f4bc28f4da19914ee396fcb465356c030160e3da", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -392,7 +392,7 @@ impl Collector<'_> {\n                     .layout;\n                 // In both stdcall and fastcall, we always round up the argument size to the\n                 // nearest multiple of 4 bytes.\n-                (layout.size.bytes_usize() + 3) & !3\n+                (layout.size().bytes_usize() + 3) & !3\n             })\n             .sum()\n     }"}, {"sha": "825dc79129d267a2eb7342432c112106c8d85360", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -6,7 +6,7 @@\n macro_rules! arena_types {\n     ($macro:path) => (\n         $macro!([\n-            [] layout: rustc_target::abi::Layout,\n+            [] layout: rustc_target::abi::LayoutS<'tcx>,\n             [] fn_abi: rustc_target::abi::call::FnAbi<'tcx, rustc_middle::ty::Ty<'tcx>>,\n             // AdtDef are interned and compared by address\n             [decode] adt_def: rustc_middle::ty::AdtDef,"}, {"sha": "99dd4ab1bf5fd8e14d620c27f5b441fdfd97a3aa", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -56,7 +56,7 @@ use rustc_span::def_id::{DefPathHash, StableCrateId};\n use rustc_span::source_map::{MultiSpan, SourceMap};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_target::abi::{Layout, TargetDataLayout, VariantIdx};\n+use rustc_target::abi::{Layout, LayoutS, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n \n use rustc_type_ir::TypeFlags;\n@@ -114,7 +114,7 @@ pub struct CtxtInterners<'tcx> {\n     const_: InternedSet<'tcx, ConstS<'tcx>>,\n     const_allocation: InternedSet<'tcx, Allocation>,\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n-    layout: InternedSet<'tcx, Layout>,\n+    layout: InternedSet<'tcx, LayoutS<'tcx>>,\n     adt_def: InternedSet<'tcx, AdtDef>,\n }\n \n@@ -2146,6 +2146,7 @@ direct_interners! {\n     region: mk_region(RegionKind): Region -> Region<'tcx>,\n     const_: mk_const(ConstS<'tcx>): Const -> Const<'tcx>,\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n+    layout: intern_layout(LayoutS<'tcx>): Layout -> Layout<'tcx>,\n }\n \n macro_rules! direct_interners_old {\n@@ -2186,7 +2187,6 @@ macro_rules! direct_interners_old {\n \n // FIXME: eventually these should all be converted to `direct_interners`.\n direct_interners_old! {\n-    layout: intern_layout(Layout),\n     adt_def: intern_adt_def(AdtDef),\n }\n "}, {"sha": "23664640aaef0f8987c7b82121bb7675359a769c", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 61, "deletions": 42, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -5,6 +5,7 @@ use crate::ty::subst::Subst;\n use crate::ty::{self, subst::SubstsRef, ReprOptions, Ty, TyCtxt, TypeFoldable};\n use rustc_ast as ast;\n use rustc_attr as attr;\n+use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::BitSet;\n@@ -302,7 +303,7 @@ fn invert_mapping(map: &[u32]) -> Vec<u32> {\n }\n \n impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n-    fn scalar_pair(&self, a: Scalar, b: Scalar) -> Layout {\n+    fn scalar_pair(&self, a: Scalar, b: Scalar) -> LayoutS<'tcx> {\n         let dl = self.data_layout();\n         let b_align = b.value.align(dl);\n         let align = a.value.align(dl).max(b_align).max(dl.aggregate_align);\n@@ -316,7 +317,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             .chain(Niche::from_scalar(dl, Size::ZERO, a))\n             .max_by_key(|niche| niche.available(dl));\n \n-        Layout {\n+        LayoutS {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Arbitrary {\n                 offsets: vec![Size::ZERO, b_offset],\n@@ -335,7 +336,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         fields: &[TyAndLayout<'_>],\n         repr: &ReprOptions,\n         kind: StructKind,\n-    ) -> Result<Layout, LayoutError<'tcx>> {\n+    ) -> Result<LayoutS<'tcx>, LayoutError<'tcx>> {\n         let dl = self.data_layout();\n         let pack = repr.pack;\n         if pack.is_some() && repr.align.is_some() {\n@@ -503,8 +504,20 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 // Two non-ZST fields, and they're both scalars.\n                 (\n-                    Some((i, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(a), .. }, .. })),\n-                    Some((j, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(b), .. }, .. })),\n+                    Some((\n+                        i,\n+                        &TyAndLayout {\n+                            layout: Layout(Interned(&LayoutS { abi: Abi::Scalar(a), .. }, _)),\n+                            ..\n+                        },\n+                    )),\n+                    Some((\n+                        j,\n+                        &TyAndLayout {\n+                            layout: Layout(Interned(&LayoutS { abi: Abi::Scalar(b), .. }, _)),\n+                            ..\n+                        },\n+                    )),\n                     None,\n                 ) => {\n                     // Order by the memory placement, not source order.\n@@ -537,7 +550,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             abi = Abi::Uninhabited;\n         }\n \n-        Ok(Layout {\n+        Ok(LayoutS {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Arbitrary { offsets, memory_index },\n             abi,\n@@ -547,7 +560,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         })\n     }\n \n-    fn layout_of_uncached(&self, ty: Ty<'tcx>) -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+    fn layout_of_uncached(&self, ty: Ty<'tcx>) -> Result<Layout<'tcx>, LayoutError<'tcx>> {\n         let tcx = self.tcx;\n         let param_env = self.param_env;\n         let dl = self.data_layout();\n@@ -556,7 +569,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             assert!(size.bits() <= 128);\n             Scalar { value, valid_range: WrappingRange { start: 0, end: size.unsigned_int_max() } }\n         };\n-        let scalar = |value: Primitive| tcx.intern_layout(Layout::scalar(self, scalar_unit(value)));\n+        let scalar =\n+            |value: Primitive| tcx.intern_layout(LayoutS::scalar(self, scalar_unit(value)));\n \n         let univariant = |fields: &[TyAndLayout<'_>], repr: &ReprOptions, kind| {\n             Ok(tcx.intern_layout(self.univariant_uninterned(ty, fields, repr, kind)?))\n@@ -565,11 +579,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         Ok(match *ty.kind() {\n             // Basic scalars.\n-            ty::Bool => tcx.intern_layout(Layout::scalar(\n+            ty::Bool => tcx.intern_layout(LayoutS::scalar(\n                 self,\n                 Scalar { value: Int(I8, false), valid_range: WrappingRange { start: 0, end: 1 } },\n             )),\n-            ty::Char => tcx.intern_layout(Layout::scalar(\n+            ty::Char => tcx.intern_layout(LayoutS::scalar(\n                 self,\n                 Scalar {\n                     value: Int(I32, false),\n@@ -585,11 +599,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             ty::FnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n                 ptr.valid_range = ptr.valid_range.with_start(1);\n-                tcx.intern_layout(Layout::scalar(self, ptr))\n+                tcx.intern_layout(LayoutS::scalar(self, ptr))\n             }\n \n             // The never type.\n-            ty::Never => tcx.intern_layout(Layout {\n+            ty::Never => tcx.intern_layout(LayoutS {\n                 variants: Variants::Single { index: VariantIdx::new(0) },\n                 fields: FieldsShape::Primitive,\n                 abi: Abi::Uninhabited,\n@@ -607,13 +621,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n                 if pointee.is_sized(tcx.at(DUMMY_SP), param_env) {\n-                    return Ok(tcx.intern_layout(Layout::scalar(self, data_ptr)));\n+                    return Ok(tcx.intern_layout(LayoutS::scalar(self, data_ptr)));\n                 }\n \n                 let unsized_part = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 let metadata = match unsized_part.kind() {\n                     ty::Foreign(..) => {\n-                        return Ok(tcx.intern_layout(Layout::scalar(self, data_ptr)));\n+                        return Ok(tcx.intern_layout(LayoutS::scalar(self, data_ptr)));\n                     }\n                     ty::Slice(_) | ty::Str => scalar_unit(Int(dl.ptr_sized_integer(), false)),\n                     ty::Dynamic(..) => {\n@@ -651,7 +665,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 let largest_niche = if count != 0 { element.largest_niche } else { None };\n \n-                tcx.intern_layout(Layout {\n+                tcx.intern_layout(LayoutS {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldsShape::Array { stride: element.size, count },\n                     abi,\n@@ -662,7 +676,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n             ty::Slice(element) => {\n                 let element = self.layout_of(element)?;\n-                tcx.intern_layout(Layout {\n+                tcx.intern_layout(LayoutS {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldsShape::Array { stride: element.size, count: 0 },\n                     abi: Abi::Aggregate { sized: false },\n@@ -671,7 +685,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     size: Size::ZERO,\n                 })\n             }\n-            ty::Str => tcx.intern_layout(Layout {\n+            ty::Str => tcx.intern_layout(LayoutS {\n                 variants: Variants::Single { index: VariantIdx::new(0) },\n                 fields: FieldsShape::Array { stride: Size::from_bytes(1), count: 0 },\n                 abi: Abi::Aggregate { sized: false },\n@@ -775,7 +789,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                     // Extract the number of elements from the layout of the array field:\n                     let Ok(TyAndLayout {\n-                        layout: Layout { fields: FieldsShape::Array { count, .. }, .. },\n+                        layout: Layout(Interned(LayoutS { fields: FieldsShape::Array { count, .. }, .. }, _)),\n                         ..\n                     }) = self.layout_of(f0_ty) else {\n                         return Err(LayoutError::Unknown(ty));\n@@ -825,7 +839,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     FieldsShape::Array { stride: e_ly.size, count: e_len }\n                 };\n \n-                tcx.intern_layout(Layout {\n+                tcx.intern_layout(LayoutS {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields,\n                     abi: Abi::Vector { element: e_abi, count: e_len },\n@@ -905,7 +919,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         align = align.min(AbiAndPrefAlign::new(pack));\n                     }\n \n-                    return Ok(tcx.intern_layout(Layout {\n+                    return Ok(tcx.intern_layout(LayoutS {\n                         variants: Variants::Single { index },\n                         fields: FieldsShape::Union(\n                             NonZeroUsize::new(variants[index].len())\n@@ -1100,17 +1114,17 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                                     align = align.max(st.align);\n \n-                                    Ok(st)\n+                                    Ok(tcx.intern_layout(st))\n                                 })\n                                 .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n-                            let offset = st[i].fields.offset(field_index) + niche.offset;\n-                            let size = st[i].size;\n+                            let offset = st[i].fields().offset(field_index) + niche.offset;\n+                            let size = st[i].size();\n \n-                            let abi = if st.iter().all(|v| v.abi.is_uninhabited()) {\n+                            let abi = if st.iter().all(|v| v.abi().is_uninhabited()) {\n                                 Abi::Uninhabited\n                             } else {\n-                                match st[i].abi {\n+                                match st[i].abi() {\n                                     Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n                                     Abi::ScalarPair(first, second) => {\n                                         // We need to use scalar_unit to reset the\n@@ -1130,7 +1144,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                             let largest_niche = Niche::from_scalar(dl, offset, niche_scalar);\n \n-                            niche_filling_layout = Some(Layout {\n+                            niche_filling_layout = Some(LayoutS {\n                                 variants: Variants::Multiple {\n                                     tag: niche_scalar,\n                                     tag_encoding: TagEncoding::Niche {\n@@ -1377,7 +1391,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag);\n \n-                let tagged_layout = Layout {\n+                let layout_variants =\n+                    layout_variants.into_iter().map(|v| tcx.intern_layout(v)).collect();\n+\n+                let tagged_layout = LayoutS {\n                     variants: Variants::Multiple {\n                         tag,\n                         tag_encoding: TagEncoding::Direct,\n@@ -1563,7 +1580,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         ty: Ty<'tcx>,\n         def_id: hir::def_id::DefId,\n         substs: SubstsRef<'tcx>,\n-    ) -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+    ) -> Result<Layout<'tcx>, LayoutError<'tcx>> {\n         use SavedLocalEligibility::*;\n         let tcx = self.tcx;\n         let subst_field = |ty: Ty<'tcx>| ty.subst(tcx, substs);\n@@ -1586,7 +1603,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             value: Primitive::Int(discr_int, false),\n             valid_range: WrappingRange { start: 0, end: max_discr },\n         };\n-        let tag_layout = self.tcx.intern_layout(Layout::scalar(self, tag));\n+        let tag_layout = self.tcx.intern_layout(LayoutS::scalar(self, tag));\n         let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout };\n \n         let promoted_layouts = ineligible_locals\n@@ -1722,20 +1739,20 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 size = size.max(variant.size);\n                 align = align.max(variant.align);\n-                Ok(variant)\n+                Ok(tcx.intern_layout(variant))\n             })\n             .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n         size = size.align_to(align.abi);\n \n-        let abi = if prefix.abi.is_uninhabited() || variants.iter().all(|v| v.abi.is_uninhabited())\n-        {\n-            Abi::Uninhabited\n-        } else {\n-            Abi::Aggregate { sized: true }\n-        };\n+        let abi =\n+            if prefix.abi.is_uninhabited() || variants.iter().all(|v| v.abi().is_uninhabited()) {\n+                Abi::Uninhabited\n+            } else {\n+                Abi::Aggregate { sized: true }\n+            };\n \n-        let layout = tcx.intern_layout(Layout {\n+        let layout = tcx.intern_layout(LayoutS {\n             variants: Variants::Multiple {\n                 tag,\n                 tag_encoding: TagEncoding::Direct,\n@@ -2250,7 +2267,7 @@ where\n                     ty::Adt(def, _) => def.variants[variant_index].fields.len(),\n                     _ => bug!(),\n                 };\n-                tcx.intern_layout(Layout {\n+                tcx.intern_layout(LayoutS {\n                     variants: Variants::Single { index: variant_index },\n                     fields: match NonZeroUsize::new(fields) {\n                         Some(fields) => FieldsShape::Union(fields),\n@@ -2263,10 +2280,10 @@ where\n                 })\n             }\n \n-            Variants::Multiple { ref variants, .. } => &variants[variant_index],\n+            Variants::Multiple { ref variants, .. } => variants[variant_index],\n         };\n \n-        assert_eq!(layout.variants, Variants::Single { index: variant_index });\n+        assert_eq!(*layout.variants(), Variants::Single { index: variant_index });\n \n         TyAndLayout { ty: this.ty, layout }\n     }\n@@ -2284,8 +2301,10 @@ where\n         ) -> TyMaybeWithLayout<'tcx> {\n             let tcx = cx.tcx();\n             let tag_layout = |tag: Scalar| -> TyAndLayout<'tcx> {\n-                let layout = Layout::scalar(cx, tag);\n-                TyAndLayout { layout: tcx.intern_layout(layout), ty: tag.value.to_ty(tcx) }\n+                TyAndLayout {\n+                    layout: tcx.intern_layout(LayoutS::scalar(cx, tag)),\n+                    ty: tag.value.to_ty(tcx),\n+                }\n             };\n \n             match *this.ty.kind() {"}, {"sha": "bd196f1187966db729fe37b77b544bfa79e6b621", "filename": "compiler/rustc_mir_transform/src/uninhabited_enum_branching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -65,7 +65,7 @@ fn variant_discriminants<'tcx>(\n         Variants::Multiple { variants, .. } => variants\n             .iter_enumerated()\n             .filter_map(|(idx, layout)| {\n-                (layout.abi != Abi::Uninhabited)\n+                (layout.abi() != Abi::Uninhabited)\n                     .then(|| ty.discriminant_for_variant(tcx, idx).unwrap().val)\n             })\n             .collect(),"}, {"sha": "fb5e0272cc359c36e5273fa685b17eb45fcdc966", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 65, "deletions": 11, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -10,6 +10,7 @@ use std::num::NonZeroUsize;\n use std::ops::{Add, AddAssign, Deref, Mul, RangeInclusive, Sub};\n use std::str::FromStr;\n \n+use rustc_data_structures::intern::Interned;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::json::{Json, ToJson};\n@@ -1024,7 +1025,7 @@ rustc_index::newtype_index! {\n }\n \n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n-pub enum Variants {\n+pub enum Variants<'a> {\n     /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n     Single { index: VariantIdx },\n \n@@ -1038,7 +1039,7 @@ pub enum Variants {\n         tag: Scalar,\n         tag_encoding: TagEncoding,\n         tag_field: usize,\n-        variants: IndexVec<VariantIdx, Layout>,\n+        variants: IndexVec<VariantIdx, Layout<'a>>,\n     },\n }\n \n@@ -1146,8 +1147,8 @@ impl Niche {\n     }\n }\n \n-#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n-pub struct Layout {\n+#[derive(PartialEq, Eq, Hash, HashStable_Generic)]\n+pub struct LayoutS<'a> {\n     /// Says where the fields are located within the layout.\n     pub fields: FieldsShape,\n \n@@ -1158,7 +1159,7 @@ pub struct Layout {\n     ///\n     /// To access all fields of this layout, both `fields` and the fields of the active variant\n     /// must be taken into account.\n-    pub variants: Variants,\n+    pub variants: Variants<'a>,\n \n     /// The `abi` defines how this data is passed between functions, and it defines\n     /// value restrictions via `valid_range`.\n@@ -1177,12 +1178,12 @@ pub struct Layout {\n     pub size: Size,\n }\n \n-impl Layout {\n+impl<'a> LayoutS<'a> {\n     pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n         let largest_niche = Niche::from_scalar(cx, Size::ZERO, scalar);\n         let size = scalar.value.size(cx);\n         let align = scalar.value.align(cx);\n-        Layout {\n+        LayoutS {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n             fields: FieldsShape::Primitive,\n             abi: Abi::Scalar(scalar),\n@@ -1193,6 +1194,59 @@ impl Layout {\n     }\n }\n \n+impl<'a> fmt::Debug for LayoutS<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // This is how `Layout` used to print before it become\n+        // `Interned<LayoutS>`. We print it like this to avoid having to update\n+        // expected output in a lot of tests.\n+        f.debug_struct(\"Layout\")\n+            .field(\"fields\", &self.fields)\n+            .field(\"variants\", &self.variants)\n+            .field(\"abi\", &self.abi)\n+            .field(\"largest_niche\", &self.largest_niche)\n+            .field(\"align\", &self.align)\n+            .field(\"size\", &self.size)\n+            .finish()\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable_Generic)]\n+#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n+pub struct Layout<'a>(pub Interned<'a, LayoutS<'a>>);\n+\n+impl<'a> fmt::Debug for Layout<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // See comment on `<LayoutS as Debug>::fmt` above.\n+        self.0.0.fmt(f)\n+    }\n+}\n+\n+impl<'a> Layout<'a> {\n+    pub fn fields(self) -> &'a FieldsShape {\n+        &self.0.0.fields\n+    }\n+\n+    pub fn variants(self) -> &'a Variants<'a> {\n+        &self.0.0.variants\n+    }\n+\n+    pub fn abi(self) -> Abi {\n+        self.0.0.abi\n+    }\n+\n+    pub fn largest_niche(self) -> Option<Niche> {\n+        self.0.0.largest_niche\n+    }\n+\n+    pub fn align(self) -> AbiAndPrefAlign {\n+        self.0.0.align\n+    }\n+\n+    pub fn size(self) -> Size {\n+        self.0.0.size\n+    }\n+}\n+\n /// The layout of a type, alongside the type itself.\n /// Provides various type traversal APIs (e.g., recursing into fields).\n ///\n@@ -1203,13 +1257,13 @@ impl Layout {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable_Generic)]\n pub struct TyAndLayout<'a, Ty> {\n     pub ty: Ty,\n-    pub layout: &'a Layout,\n+    pub layout: Layout<'a>,\n }\n \n impl<'a, Ty> Deref for TyAndLayout<'a, Ty> {\n-    type Target = &'a Layout;\n-    fn deref(&self) -> &&'a Layout {\n-        &self.layout\n+    type Target = &'a LayoutS<'a>;\n+    fn deref(&self) -> &&'a LayoutS<'a> {\n+        &self.layout.0.0\n     }\n }\n "}, {"sha": "e9ef71ede51821469a6d3840fc8b26ef055de3b5", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -8,13 +8,14 @@\n //! LLVM.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(bool_to_option)]\n-#![feature(let_else)]\n-#![feature(nll)]\n-#![feature(never_type)]\n #![feature(associated_type_bounds)]\n+#![feature(bool_to_option)]\n #![feature(exhaustive_patterns)]\n+#![feature(let_else)]\n #![feature(min_specialization)]\n+#![feature(never_type)]\n+#![feature(nll)]\n+#![feature(rustc_attrs)]\n #![feature(step_trait)]\n \n use std::iter::FromIterator;"}, {"sha": "68644a017a4004001188eaf3c697e99dd1f9a0ac", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -1710,11 +1710,11 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n }\n \n fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n-    fn write_size_of_layout(w: &mut Buffer, layout: &Layout, tag_size: u64) {\n-        if layout.abi.is_unsized() {\n+    fn write_size_of_layout(w: &mut Buffer, layout: Layout<'_>, tag_size: u64) {\n+        if layout.abi().is_unsized() {\n             write!(w, \"(unsized)\");\n         } else {\n-            let bytes = layout.size.bytes() - tag_size;\n+            let bytes = layout.size().bytes() - tag_size;\n             write!(w, \"{size} byte{pl}\", size = bytes, pl = if bytes == 1 { \"\" } else { \"s\" },);\n         }\n     }\n@@ -1744,7 +1744,7 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n             write_size_of_layout(w, ty_layout.layout, 0);\n             writeln!(w, \"</p>\");\n             if let Variants::Multiple { variants, tag, tag_encoding, .. } =\n-                &ty_layout.layout.variants\n+                &ty_layout.layout.variants()\n             {\n                 if !variants.is_empty() {\n                     w.write_str(\n@@ -1767,7 +1767,7 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n                     for (index, layout) in variants.iter_enumerated() {\n                         let name = adt.variants[index].name;\n                         write!(w, \"<li><code>{name}</code>: \", name = name);\n-                        write_size_of_layout(w, layout, tag_size);\n+                        write_size_of_layout(w, *layout, tag_size);\n                         writeln!(w, \"</li>\");\n                     }\n                     w.write_str(\"</ul>\");"}, {"sha": "81076776ed3d333ad00dc1271fa17ff199a6fc70", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb867ec3cefa97a5807453a68758392730e3ed9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=ecb867ec3cefa97a5807453a68758392730e3ed9", "patch": "@@ -326,7 +326,7 @@ fn is_zero_sized_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         if let Ok(ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty);\n         if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n         then {\n-            layout.layout.size.bytes() == 0\n+            layout.layout.size().bytes() == 0\n         } else {\n             false\n         }"}]}