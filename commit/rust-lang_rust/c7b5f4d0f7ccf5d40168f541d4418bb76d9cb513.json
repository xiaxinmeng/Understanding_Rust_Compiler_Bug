{"sha": "c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3YjVmNGQwZjdjY2Y1ZDQwMTY4ZjU0MWQ0NDE4YmI3NmQ5Y2I1MTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-24T14:26:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-24T14:26:11Z"}, "message": "Auto merge of #58305 - scalexm:chalk-continued, r=nikomatsakis\n\n(WIP) Small fixes in chalkification\n\nSmall fixes around region constraints and builtin impls. There are still some type inference errors, for example the following code errors out:\n```rust\nfn main() {\n    let mut x: Vec<i32> = Vec::new();\n    //                    ^^^^^^^^ cannot infer type for `std::vec::Vec<_>`\n}\n```\nbut explicitly specifying `Vec::<i32>::new` works.\n\nWith these few fixes, the following code now passes type-checking:\n```rust\nfn main() {\n    let mut x: Vec<i32> = Vec::<i32>::new();\n    x.push(5);\n    println!(\"{:?}\", x);\n}\n```\n\nI also fixed the implied bounds bug as discussed on Zulip and in https://github.com/rust-lang-nursery/chalk/pull/206\n\ncc @tmandry\nr? @nikomatsakis", "tree": {"sha": "a1267a8f9064b3707f582dfc9a70669f8be78758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1267a8f9064b3707f582dfc9a70669f8be78758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "html_url": "https://github.com/rust-lang/rust/commit/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb5ed488ff1a251db895c545592488a67be67112", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5ed488ff1a251db895c545592488a67be67112", "html_url": "https://github.com/rust-lang/rust/commit/fb5ed488ff1a251db895c545592488a67be67112"}, {"sha": "ca5a2122cc68fa14e72f1631ee5e9bbf2ac9c94f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca5a2122cc68fa14e72f1631ee5e9bbf2ac9c94f", "html_url": "https://github.com/rust-lang/rust/commit/ca5a2122cc68fa14e72f1631ee5e9bbf2ac9c94f"}], "stats": {"total": 1642, "additions": 946, "deletions": 696}, "files": [{"sha": "d8e7328c274b75fc69c8bc3e5ef5c95bfb9b47bf", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 159, "deletions": 34, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -22,13 +22,14 @@\n //!   constituents)\n \n use crate::infer::InferCtxt;\n+use crate::traits::DomainGoal;\n+use crate::ty::error::TypeError;\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::Kind;\n use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::error::TypeError;\n-use crate::traits::DomainGoal;\n use rustc_data_structures::fx::FxHashMap;\n+use std::fmt::Debug;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum NormalizationStrategy {\n@@ -239,6 +240,7 @@ where\n         first_free_index: ty::DebruijnIndex,\n         scopes: &[BoundRegionScope<'tcx>],\n     ) -> ty::Region<'tcx> {\n+        debug!(\"replace_bound_regions(scopes={:?})\", scopes);\n         if let ty::ReLateBound(debruijn, br) = r {\n             Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n         } else {\n@@ -265,15 +267,17 @@ where\n     fn relate_projection_ty(\n         &mut self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n-        value_ty: ty::Ty<'tcx>\n+        value_ty: ty::Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         use crate::infer::type_variable::TypeVariableOrigin;\n         use crate::traits::WhereClause;\n         use syntax_pos::DUMMY_SP;\n \n         match value_ty.sty {\n             ty::Projection(other_projection_ty) => {\n-                let var = self.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n+                let var = self\n+                    .infcx\n+                    .next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n                 self.relate_projection_ty(projection_ty, var);\n                 self.relate_projection_ty(other_projection_ty, var);\n                 var\n@@ -284,32 +288,55 @@ where\n                     projection_ty,\n                     ty: value_ty,\n                 };\n-                self.delegate.push_domain_goal(\n-                    DomainGoal::Holds(WhereClause::ProjectionEq(projection))\n-                );\n+                self.delegate\n+                    .push_domain_goal(DomainGoal::Holds(WhereClause::ProjectionEq(projection)));\n                 value_ty\n             }\n         }\n     }\n \n-    /// Relate a type inference variable with a value type.\n-    fn relate_ty_var(\n+    /// Relate a type inference variable with a value type. This works\n+    /// by creating a \"generalization\" G of the value where all the\n+    /// lifetimes are replaced with fresh inference values. This\n+    /// genearlization G becomes the value of the inference variable,\n+    /// and is then related in turn to the value. So e.g. if you had\n+    /// `vid = ?0` and `value = &'a u32`, we might first instantiate\n+    /// `?0` to a type like `&'0 u32` where `'0` is a fresh variable,\n+    /// and then relate `&'0 u32` with `&'a u32` (resulting in\n+    /// relations between `'0` and `'a`).\n+    ///\n+    /// The variable `pair` can be either a `(vid, ty)` or `(ty, vid)`\n+    /// -- in other words, it is always a (unresolved) inference\n+    /// variable `vid` and a type `ty` that are being related, but the\n+    /// vid may appear either as the \"a\" type or the \"b\" type,\n+    /// depending on where it appears in the tuple. The trait\n+    /// `VidValuePair` lets us work with the vid/type while preserving\n+    /// the \"sidedness\" when necessary -- the sidedness is relevant in\n+    /// particular for the variance and set of in-scope things.\n+    fn relate_ty_var<PAIR: VidValuePair<'tcx>>(\n         &mut self,\n-        vid: ty::TyVid,\n-        value_ty: Ty<'tcx>\n+        pair: PAIR,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"relate_ty_var(vid={:?}, value_ty={:?})\", vid, value_ty);\n+        debug!(\"relate_ty_var({:?})\", pair);\n \n+        let vid = pair.vid();\n+        let value_ty = pair.value_ty();\n+\n+        // FIXME -- this logic assumes invariance, but that is wrong.\n+        // This only presently applies to chalk integration, as NLL\n+        // doesn't permit type variables to appear on both sides (and\n+        // doesn't use lazy norm).\n         match value_ty.sty {\n             ty::Infer(ty::TyVar(value_vid)) => {\n                 // Two type variables: just equate them.\n-                self.infcx.type_variables.borrow_mut().equate(vid, value_vid);\n+                self.infcx\n+                    .type_variables\n+                    .borrow_mut()\n+                    .equate(vid, value_vid);\n                 return Ok(value_ty);\n             }\n \n-            ty::Projection(projection_ty)\n-                if D::normalization() == NormalizationStrategy::Lazy =>\n-            {\n+            ty::Projection(projection_ty) if D::normalization() == NormalizationStrategy::Lazy => {\n                 return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_ty_var(vid)));\n             }\n \n@@ -326,19 +353,22 @@ where\n             assert!(!generalized_ty.has_infer_types());\n         }\n \n-        self.infcx.type_variables.borrow_mut().instantiate(vid, generalized_ty);\n+        self.infcx\n+            .type_variables\n+            .borrow_mut()\n+            .instantiate(vid, generalized_ty);\n \n         // The generalized values we extract from `canonical_var_values` have\n         // been fully instantiated and hence the set of scopes we have\n         // doesn't matter -- just to be sure, put an empty vector\n         // in there.\n-        let old_a_scopes = ::std::mem::replace(&mut self.a_scopes, vec![]);\n+        let old_a_scopes = ::std::mem::replace(pair.vid_scopes(self), vec![]);\n \n         // Relate the generalized kind to the original one.\n-        let result = self.relate(&generalized_ty, &value_ty);\n+        let result = pair.relate_generalized_ty(self, generalized_ty);\n \n         // Restore the old scopes now.\n-        self.a_scopes = old_a_scopes;\n+        *pair.vid_scopes(self) = old_a_scopes;\n \n         debug!(\"relate_ty_var: complete, result = {:?}\", result);\n         result\n@@ -347,7 +377,7 @@ where\n     fn generalize_value<T: Relate<'tcx>>(\n         &mut self,\n         value: T,\n-        for_vid: ty::TyVid\n+        for_vid: ty::TyVid,\n     ) -> RelateResult<'tcx, T> {\n         let universe = self.infcx.probe_ty_var(for_vid).unwrap_err();\n \n@@ -364,6 +394,104 @@ where\n     }\n }\n \n+/// When we instantiate a inference variable with a value in\n+/// `relate_ty_var`, we always have the pair of a `TyVid` and a `Ty`,\n+/// but the ordering may vary (depending on whether the inference\n+/// variable was found on the `a` or `b` sides). Therefore, this trait\n+/// allows us to factor out common code, while preserving the order\n+/// when needed.\n+trait VidValuePair<'tcx>: Debug {\n+    /// Extract the inference variable (which could be either the\n+    /// first or second part of the tuple).\n+    fn vid(&self) -> ty::TyVid;\n+\n+    /// Extract the value it is being related to (which will be the\n+    /// opposite part of the tuple from the vid).\n+    fn value_ty(&self) -> Ty<'tcx>;\n+\n+    /// Extract the scopes that apply to whichever side of the tuple\n+    /// the vid was found on.  See the comment where this is called\n+    /// for more details on why we want them.\n+    fn vid_scopes<D: TypeRelatingDelegate<'tcx>>(\n+        &self,\n+        relate: &'r mut TypeRelating<'_, '_, 'tcx, D>,\n+    ) -> &'r mut Vec<BoundRegionScope<'tcx>>;\n+\n+    /// Given a generalized type G that should replace the vid, relate\n+    /// G to the value, putting G on whichever side the vid would have\n+    /// appeared.\n+    fn relate_generalized_ty<D>(\n+        &self,\n+        relate: &mut TypeRelating<'_, '_, 'tcx, D>,\n+        generalized_ty: Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>>\n+    where\n+        D: TypeRelatingDelegate<'tcx>;\n+}\n+\n+impl VidValuePair<'tcx> for (ty::TyVid, Ty<'tcx>) {\n+    fn vid(&self) -> ty::TyVid {\n+        self.0\n+    }\n+\n+    fn value_ty(&self) -> Ty<'tcx> {\n+        self.1\n+    }\n+\n+    fn vid_scopes<D>(\n+        &self,\n+        relate: &'r mut TypeRelating<'_, '_, 'tcx, D>,\n+    ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n+    where\n+        D: TypeRelatingDelegate<'tcx>,\n+    {\n+        &mut relate.a_scopes\n+    }\n+\n+    fn relate_generalized_ty<D>(\n+        &self,\n+        relate: &mut TypeRelating<'_, '_, 'tcx, D>,\n+        generalized_ty: Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>>\n+    where\n+        D: TypeRelatingDelegate<'tcx>,\n+    {\n+        relate.relate(&generalized_ty, &self.value_ty())\n+    }\n+}\n+\n+// In this case, the \"vid\" is the \"b\" type.\n+impl VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n+    fn vid(&self) -> ty::TyVid {\n+        self.1\n+    }\n+\n+    fn value_ty(&self) -> Ty<'tcx> {\n+        self.0\n+    }\n+\n+    fn vid_scopes<D>(\n+        &self,\n+        relate: &'r mut TypeRelating<'_, '_, 'tcx, D>,\n+    ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n+    where\n+        D: TypeRelatingDelegate<'tcx>,\n+    {\n+        &mut relate.b_scopes\n+    }\n+\n+    fn relate_generalized_ty<D>(\n+        &self,\n+        relate: &mut TypeRelating<'_, '_, 'tcx, D>,\n+        generalized_ty: Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>>\n+    where\n+        D: TypeRelatingDelegate<'tcx>,\n+    {\n+        relate.relate(&self.value_ty(), &generalized_ty)\n+    }\n+}\n+\n impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n@@ -421,11 +549,11 @@ where\n                     // Forbid inference variables in the RHS.\n                     bug!(\"unexpected inference var {:?}\", b)\n                 } else {\n-                    self.relate_ty_var(vid, a)\n+                    self.relate_ty_var((a, vid))\n                 }\n             }\n \n-            (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var(vid, b),\n+            (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n             (&ty::Projection(projection_ty), _)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n@@ -752,7 +880,9 @@ where\n                             drop(variables);\n                             self.relate(&u, &u)\n                         }\n-                        TypeVariableValue::Unknown { universe: _universe } => {\n+                        TypeVariableValue::Unknown {\n+                            universe: _universe,\n+                        } => {\n                             if self.ambient_variance == ty::Bivariant {\n                                 // FIXME: we may need a WF predicate (related to #54105).\n                             }\n@@ -767,17 +897,15 @@ where\n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\n                                 \"generalize: replacing original vid={:?} with new={:?}\",\n-                                vid,\n-                                u\n+                                vid, u\n                             );\n                             return Ok(u);\n                         }\n                     }\n                 }\n             }\n \n-            ty::Infer(ty::IntVar(_)) |\n-            ty::Infer(ty::FloatVar(_)) => {\n+            ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n                 // No matter what mode we are in,\n                 // integer/floating-point types must be equal to be\n                 // relatable.\n@@ -788,19 +916,16 @@ where\n                 if self.universe.cannot_name(placeholder.universe) {\n                     debug!(\n                         \"TypeGeneralizer::tys: root universe {:?} cannot name\\\n-                        placeholder in universe {:?}\",\n-                        self.universe,\n-                        placeholder.universe\n+                         placeholder in universe {:?}\",\n+                        self.universe, placeholder.universe\n                     );\n                     Err(TypeError::Mismatch)\n                 } else {\n                     Ok(a)\n                 }\n             }\n \n-            _ => {\n-                relate::super_relate_tys(self, a, a)\n-            }\n+            _ => relate::super_relate_tys(self, a, a),\n         }\n     }\n "}, {"sha": "8d5d2b8a9a255ce1e4efa70b2a3913dc59cc0b56", "filename": "src/librustc_traits/chalk_context/program_clauses.rs", "status": "removed", "additions": 0, "deletions": 621, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/fb5ed488ff1a251db895c545592488a67be67112/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5ed488ff1a251db895c545592488a67be67112/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs?ref=fb5ed488ff1a251db895c545592488a67be67112", "patch": "@@ -1,621 +0,0 @@\n-use rustc::traits::{\n-    WellFormed,\n-    FromEnv,\n-    DomainGoal,\n-    GoalKind,\n-    Clause,\n-    Clauses,\n-    ProgramClause,\n-    ProgramClauseCategory,\n-    Environment,\n-};\n-use rustc::ty;\n-use rustc::ty::subst::{InternalSubsts, Subst};\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use rustc_target::spec::abi;\n-use super::ChalkInferenceContext;\n-use crate::lowering::Lower;\n-use crate::generic_types;\n-use std::iter;\n-\n-fn assemble_clauses_from_impls<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    trait_def_id: DefId,\n-    clauses: &mut Vec<Clause<'tcx>>\n-) {\n-    tcx.for_each_impl(trait_def_id, |impl_def_id| {\n-        clauses.extend(\n-            tcx.program_clauses_for(impl_def_id)\n-                .into_iter()\n-                .cloned()\n-        );\n-    });\n-}\n-\n-fn assemble_clauses_from_assoc_ty_values<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    trait_def_id: DefId,\n-    clauses: &mut Vec<Clause<'tcx>>\n-) {\n-    tcx.for_each_impl(trait_def_id, |impl_def_id| {\n-        for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {\n-            clauses.extend(\n-                tcx.program_clauses_for(*def_id)\n-                    .into_iter()\n-                    .cloned()\n-            );\n-        }\n-    });\n-}\n-\n-fn assemble_builtin_sized_impls<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    sized_def_id: DefId,\n-    ty: ty::Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>\n-) {\n-    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[ty::Ty<'tcx>]| {\n-        let clause = ProgramClause {\n-            goal: ty::TraitPredicate {\n-                trait_ref: ty::TraitRef {\n-                    def_id: sized_def_id,\n-                    substs: tcx.mk_substs_trait(ty, &[]),\n-                },\n-            }.lower(),\n-            hypotheses: tcx.mk_goals(\n-                nested.iter()\n-                    .cloned()\n-                    .map(|nested_ty| ty::TraitRef {\n-                        def_id: sized_def_id,\n-                        substs: tcx.mk_substs_trait(nested_ty, &[]),\n-                    })\n-                    .map(|trait_ref| ty::TraitPredicate { trait_ref })\n-                    .map(|pred| GoalKind::DomainGoal(pred.lower()))\n-                    .map(|goal_kind| tcx.mk_goal(goal_kind))\n-            ),\n-            category: ProgramClauseCategory::Other,\n-        };\n-        // Bind innermost bound vars that may exist in `ty` and `nested`.\n-        clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n-    };\n-\n-    match &ty.sty {\n-        // Non parametric primitive types.\n-        ty::Bool |\n-        ty::Char |\n-        ty::Int(..) |\n-        ty::Uint(..) |\n-        ty::Float(..) |\n-        ty::Error |\n-        ty::Never => push_builtin_impl(ty, &[]),\n-\n-        // These ones are always `Sized`.\n-        &ty::Array(_, length) => {\n-            push_builtin_impl(tcx.mk_ty(ty::Array(generic_types::bound(tcx, 0), length)), &[]);\n-        }\n-        ty::RawPtr(ptr) => {\n-            push_builtin_impl(generic_types::raw_ptr(tcx, ptr.mutbl), &[]);\n-        }\n-        &ty::Ref(_, _, mutbl) => {\n-            push_builtin_impl(generic_types::ref_ty(tcx, mutbl), &[]);\n-        }\n-        ty::FnPtr(fn_ptr) => {\n-            let fn_ptr = fn_ptr.skip_binder();\n-            let fn_ptr = generic_types::fn_ptr(\n-                tcx,\n-                fn_ptr.inputs_and_output.len(),\n-                fn_ptr.c_variadic,\n-                fn_ptr.unsafety,\n-                fn_ptr.abi\n-            );\n-            push_builtin_impl(fn_ptr, &[]);\n-        }\n-        &ty::FnDef(def_id, ..) => {\n-            push_builtin_impl(generic_types::fn_def(tcx, def_id), &[]);\n-        }\n-        &ty::Closure(def_id, ..) => {\n-            push_builtin_impl(generic_types::closure(tcx, def_id), &[]);\n-        }\n-        &ty::Generator(def_id, ..) => {\n-            push_builtin_impl(generic_types::generator(tcx, def_id), &[]);\n-        }\n-\n-        // `Sized` if the last type is `Sized` (because else we will get a WF error anyway).\n-        &ty::Tuple(type_list) => {\n-            let type_list = generic_types::type_list(tcx, type_list.len());\n-            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &**type_list);\n-        }\n-\n-        // Struct def\n-        ty::Adt(adt_def, _) => {\n-            let substs = InternalSubsts::bound_vars_for_item(tcx, adt_def.did);\n-            let adt = tcx.mk_ty(ty::Adt(adt_def, substs));\n-            let sized_constraint = adt_def.sized_constraint(tcx)\n-                .iter()\n-                .map(|ty| ty.subst(tcx, substs))\n-                .collect::<Vec<_>>();\n-            push_builtin_impl(adt, &sized_constraint);\n-        }\n-\n-        // Artificially trigger an ambiguity.\n-        ty::Infer(..) => {\n-            // Everybody can find at least two types to unify against:\n-            // general ty vars, int vars and float vars.\n-            push_builtin_impl(tcx.types.i32, &[]);\n-            push_builtin_impl(tcx.types.u32, &[]);\n-            push_builtin_impl(tcx.types.f32, &[]);\n-            push_builtin_impl(tcx.types.f64, &[]);\n-        }\n-\n-        ty::Projection(_projection_ty) => {\n-            // FIXME: add builtin impls from the associated type values found in\n-            // trait impls of `projection_ty.trait_ref(tcx)`.\n-        }\n-\n-        // The `Sized` bound can only come from the environment.\n-        ty::Param(..) |\n-        ty::Placeholder(..) |\n-        ty::UnnormalizedProjection(..) => (),\n-\n-        // Definitely not `Sized`.\n-        ty::Foreign(..) |\n-        ty::Str |\n-        ty::Slice(..) |\n-        ty::Dynamic(..) |\n-        ty::Opaque(..) => (),\n-\n-        ty::Bound(..) |\n-        ty::GeneratorWitness(..) => bug!(\"unexpected type {:?}\", ty),\n-    }\n-}\n-\n-fn wf_clause_for_raw_ptr<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    mutbl: hir::Mutability\n-) -> Clauses<'tcx> {\n-    let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(ptr_ty)),\n-        hypotheses: ty::List::empty(),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::Implies(wf_clause);\n-\n-    // `forall<T> { WellFormed(*const T). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_fn_ptr<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    arity_and_output: usize,\n-    c_variadic: bool,\n-    unsafety: hir::Unsafety,\n-    abi: abi::Abi\n-) -> Clauses<'tcx> {\n-    let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, c_variadic, unsafety, abi);\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_ptr)),\n-        hypotheses: ty::List::empty(),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall <T1, ..., Tn+1> { WellFormed(for<> fn(T1, ..., Tn) -> Tn+1). }`\n-    // where `n + 1` == `arity_and_output`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n-    let ty = generic_types::bound(tcx, 0);\n-    let slice_ty = tcx.mk_slice(ty);\n-\n-    let sized_trait = match tcx.lang_items().sized_trait() {\n-        Some(def_id) => def_id,\n-        None => return ty::List::empty(),\n-    };\n-    let sized_implemented = ty::TraitRef {\n-        def_id: sized_trait,\n-        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n-    };\n-    let sized_implemented: DomainGoal<'_> = ty::TraitPredicate {\n-        trait_ref: sized_implemented\n-    }.lower();\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(slice_ty)),\n-        hypotheses: tcx.mk_goals(\n-            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n-        ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall<T> { WellFormed([T]) :- Implemented(T: Sized). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_array<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    length: &'tcx ty::Const<'tcx>\n-) -> Clauses<'tcx> {\n-    let ty = generic_types::bound(tcx, 0);\n-    let array_ty = tcx.mk_ty(ty::Array(ty, length));\n-\n-    let sized_trait = match tcx.lang_items().sized_trait() {\n-        Some(def_id) => def_id,\n-        None => return ty::List::empty(),\n-    };\n-    let sized_implemented = ty::TraitRef {\n-        def_id: sized_trait,\n-        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n-    };\n-    let sized_implemented: DomainGoal<'_> = ty::TraitPredicate {\n-        trait_ref: sized_implemented\n-    }.lower();\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(array_ty)),\n-        hypotheses: tcx.mk_goals(\n-            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n-        ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall<T> { WellFormed([T; length]) :- Implemented(T: Sized). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_tuple<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    arity: usize\n-) -> Clauses<'tcx> {\n-    let type_list = generic_types::type_list(tcx, arity);\n-    let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n-\n-    let sized_trait = match tcx.lang_items().sized_trait() {\n-        Some(def_id) => def_id,\n-        None => return ty::List::empty(),\n-    };\n-\n-    // If `arity == 0` (i.e. the unit type) or `arity == 1`, this list of\n-    // hypotheses is actually empty.\n-    let sized_implemented = type_list[0 .. std::cmp::max(arity, 1) - 1].iter()\n-        .map(|ty| ty::TraitRef {\n-            def_id: sized_trait,\n-            substs: tcx.mk_substs_trait(*ty, ty::List::empty()),\n-        })\n-        .map(|trait_ref| ty::TraitPredicate { trait_ref })\n-        .map(|predicate| predicate.lower());\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(tuple_ty)),\n-        hypotheses: tcx.mk_goals(\n-            sized_implemented.map(|domain_goal| {\n-                tcx.mk_goal(GoalKind::DomainGoal(domain_goal))\n-            })\n-        ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // ```\n-    // forall<T1, ..., Tn-1, Tn> {\n-    //     WellFormed((T1, ..., Tn)) :-\n-    //         Implemented(T1: Sized),\n-    //         ...\n-    //         Implemented(Tn-1: Sized).\n-    // }\n-    // ```\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_ref<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    mutbl: hir::Mutability\n-) -> Clauses<'tcx> {\n-    let region = tcx.mk_region(\n-        ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n-    );\n-    let ty = generic_types::bound(tcx, 1);\n-    let ref_ty = tcx.mk_ref(region, ty::TypeAndMut {\n-        ty,\n-        mutbl,\n-    });\n-\n-    let _outlives: DomainGoal<'_> = ty::OutlivesPredicate(ty, region).lower();\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(ref_ty)),\n-        hypotheses: ty::List::empty(),\n-\n-        // FIXME: restore this later once we get better at handling regions\n-        // hypotheses: tcx.mk_goals(\n-        //     iter::once(tcx.mk_goal(outlives.into_goal()))\n-        // ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall<'a, T> { WellFormed(&'a T) :- Outlives(T: 'a). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_fn_def<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    def_id: DefId\n-) -> Clauses<'tcx> {\n-    let fn_def = generic_types::fn_def(tcx, def_id);\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_def)),\n-        hypotheses: ty::List::empty(),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall <T1, ..., Tn+1> { WellFormed(fn some_fn(T1, ..., Tn) -> Tn+1). }`\n-    // where `def_id` maps to the `some_fn` function definition\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n-    pub(super) fn program_clauses_impl(\n-        &self,\n-        environment: &Environment<'tcx>,\n-        goal: &DomainGoal<'tcx>,\n-    ) -> Vec<Clause<'tcx>> {\n-        use rustc::traits::WhereClause::*;\n-        use rustc::infer::canonical::OriginalQueryValues;\n-\n-        let goal = self.infcx.resolve_type_vars_if_possible(goal);\n-\n-        debug!(\"program_clauses(goal = {:?})\", goal);\n-\n-        let mut clauses = match goal {\n-            DomainGoal::Holds(Implemented(trait_predicate)) => {\n-                // These come from:\n-                // * implementations of the trait itself (rule `Implemented-From-Impl`)\n-                // * the trait decl (rule `Implemented-From-Env`)\n-\n-                let mut clauses = vec![];\n-\n-                assemble_clauses_from_impls(\n-                    self.infcx.tcx,\n-                    trait_predicate.def_id(),\n-                    &mut clauses\n-                );\n-\n-                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().sized_trait() {\n-                    assemble_builtin_sized_impls(\n-                        self.infcx.tcx,\n-                        trait_predicate.def_id(),\n-                        trait_predicate.self_ty(),\n-                        &mut clauses\n-                    );\n-                }\n-\n-                // FIXME: we need to add special rules for builtin impls:\n-                // * `Copy` / `Clone`\n-                // * `Sized`\n-                // * `Unsize`\n-                // * `Generator`\n-                // * `FnOnce` / `FnMut` / `Fn`\n-                // * trait objects\n-                // * auto traits\n-\n-                // Rule `Implemented-From-Env` will be computed from the environment.\n-                clauses\n-            }\n-\n-            DomainGoal::Holds(ProjectionEq(projection_predicate)) => {\n-                // These come from:\n-                // * the assoc type definition (rule `ProjectionEq-Placeholder`)\n-                // * normalization of the assoc ty values (rule `ProjectionEq-Normalize`)\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-\n-                let clauses = self.infcx.tcx.program_clauses_for(\n-                    projection_predicate.projection_ty.item_def_id\n-                ).into_iter()\n-\n-                    // only select `ProjectionEq-Placeholder` and `ProjectionEq-Normalize`\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::Other)\n-\n-                    .cloned()\n-                    .collect::<Vec<_>>();\n-\n-                // Rules `Implied-Bound-From-Trait` and `Implied-Bound-From-Type` will be computed\n-                // from the environment.\n-                clauses\n-            }\n-\n-            DomainGoal::Holds(RegionOutlives(..)) => {\n-                // These come from:\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-\n-                // All of these rules are computed in the environment.\n-                vec![]\n-            }\n-\n-            DomainGoal::Holds(TypeOutlives(..)) => {\n-                // These come from:\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-\n-                // All of these rules are computed in the environment.\n-                vec![]\n-            }\n-\n-            DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)) => {\n-                // These come from -- the trait decl (rule `WellFormed-TraitRef`).\n-                self.infcx.tcx.program_clauses_for(trait_predicate.def_id())\n-                    .into_iter()\n-\n-                    // only select `WellFormed-TraitRef`\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n-\n-                    .cloned()\n-                    .collect()\n-            }\n-\n-            DomainGoal::WellFormed(WellFormed::Ty(ty)) => {\n-                // These come from:\n-                // * the associated type definition if `ty` refers to an unnormalized\n-                //   associated type (rule `WellFormed-AssocTy`)\n-                // * custom rules for built-in types\n-                // * the type definition otherwise (rule `WellFormed-Type`)\n-                let clauses = match ty.sty {\n-                    ty::Projection(data) => {\n-                        self.infcx.tcx.program_clauses_for(data.item_def_id)\n-                    }\n-\n-                    // These types are always WF.\n-                    ty::Bool |\n-                    ty::Char |\n-                    ty::Int(..) |\n-                    ty::Uint(..) |\n-                    ty::Float(..) |\n-                    ty::Str |\n-                    ty::Param(..) |\n-                    ty::Placeholder(..) |\n-                    ty::Error |\n-                    ty::Never => {\n-                        let wf_clause = ProgramClause {\n-                            goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n-                            hypotheses: ty::List::empty(),\n-                            category: ProgramClauseCategory::WellFormed,\n-                        };\n-                        let wf_clause = Clause::Implies(wf_clause);\n-\n-                        self.infcx.tcx.mk_clauses(iter::once(wf_clause))\n-                    }\n-\n-                    // Always WF (recall that we do not check for parameters to be WF).\n-                    ty::RawPtr(ptr) => wf_clause_for_raw_ptr(self.infcx.tcx, ptr.mutbl),\n-\n-                    // Always WF (recall that we do not check for parameters to be WF).\n-                    ty::FnPtr(fn_ptr) => {\n-                        let fn_ptr = fn_ptr.skip_binder();\n-                        wf_clause_for_fn_ptr(\n-                            self.infcx.tcx,\n-                            fn_ptr.inputs_and_output.len(),\n-                            fn_ptr.c_variadic,\n-                            fn_ptr.unsafety,\n-                            fn_ptr.abi\n-                        )\n-                    }\n-\n-                    // WF if inner type is `Sized`.\n-                    ty::Slice(..) => wf_clause_for_slice(self.infcx.tcx),\n-\n-                    // WF if inner type is `Sized`.\n-                    ty::Array(_, length) => wf_clause_for_array(self.infcx.tcx, length),\n-\n-                    // WF if all types but the last one are `Sized`.\n-                    ty::Tuple(types) => wf_clause_for_tuple(\n-                        self.infcx.tcx,\n-                        types.len()\n-                    ),\n-\n-                    // WF if `sub_ty` outlives `region`.\n-                    ty::Ref(_, _, mutbl) => wf_clause_for_ref(self.infcx.tcx, mutbl),\n-\n-                    ty::FnDef(def_id, ..) => wf_clause_for_fn_def(self.infcx.tcx, def_id),\n-\n-                    ty::Dynamic(..) => {\n-                        // FIXME: no rules yet for trait objects\n-                        ty::List::empty()\n-                    }\n-\n-                    ty::Adt(def, ..) => {\n-                        self.infcx.tcx.program_clauses_for(def.did)\n-                    }\n-\n-                    // FIXME: these are probably wrong\n-                    ty::Foreign(def_id) |\n-                    ty::Closure(def_id, ..) |\n-                    ty::Generator(def_id, ..) |\n-                    ty::Opaque(def_id, ..) => {\n-                        self.infcx.tcx.program_clauses_for(def_id)\n-                    }\n-\n-                    // Artificially trigger an ambiguity.\n-                    ty::Infer(..) => {\n-                        let tcx = self.infcx.tcx;\n-                        let types = [tcx.types.i32, tcx.types.u32, tcx.types.f32, tcx.types.f64];\n-                        let clauses = types.iter()\n-                            .cloned()\n-                            .map(|ty| ProgramClause {\n-                                goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n-                                hypotheses: ty::List::empty(),\n-                                category: ProgramClauseCategory::WellFormed,\n-                            })\n-                            .map(|clause| Clause::Implies(clause));\n-                        tcx.mk_clauses(clauses)\n-                    }\n-\n-                    ty::GeneratorWitness(..) |\n-                    ty::UnnormalizedProjection(..) |\n-                    ty::Bound(..) => {\n-                        bug!(\"unexpected type {:?}\", ty)\n-                    }\n-                };\n-\n-                clauses.into_iter()\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n-                    .cloned()\n-                    .collect()\n-            }\n-\n-            DomainGoal::FromEnv(FromEnv::Trait(..)) => {\n-                // These come from:\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-                // * implied bounds from assoc type defs (rules `Implied-Trait-From-AssocTy`,\n-                //   `Implied-Bound-From-AssocTy` and `Implied-WC-From-AssocTy`)\n-\n-                // All of these rules are computed in the environment.\n-                vec![]\n-            }\n-\n-            DomainGoal::FromEnv(FromEnv::Ty(..)) => {\n-                // There are no `FromEnv::Ty(..) :- ...` rules (this predicate only\n-                // comes from the environment).\n-                vec![]\n-            }\n-\n-            DomainGoal::Normalize(projection_predicate) => {\n-                // These come from -- assoc ty values (rule `Normalize-From-Impl`).\n-                let mut clauses = vec![];\n-\n-                assemble_clauses_from_assoc_ty_values(\n-                    self.infcx.tcx,\n-                    projection_predicate.projection_ty.trait_ref(self.infcx.tcx).def_id,\n-                    &mut clauses\n-                );\n-\n-                clauses\n-            }\n-        };\n-\n-        debug!(\"program_clauses: clauses = {:?}\", clauses);\n-        debug!(\"program_clauses: adding clauses from environment = {:?}\", environment);\n-\n-        let mut _orig_query_values = OriginalQueryValues::default();\n-        let canonical_environment = self.infcx.canonicalize_query(\n-            environment,\n-            &mut _orig_query_values\n-        ).value;\n-        let env_clauses = self.infcx.tcx.program_clauses_for_env(canonical_environment);\n-\n-        debug!(\"program_clauses: env_clauses = {:?}\", env_clauses);\n-\n-        clauses.extend(env_clauses.into_iter().cloned());\n-        clauses.extend(environment.clauses.iter().cloned());\n-        clauses\n-    }\n-}"}, {"sha": "ae9f1a27b9422f63b04fabb703b01b39cab3a157", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -0,0 +1,208 @@\n+use rustc::traits::{\n+    GoalKind,\n+    Clause,\n+    ProgramClause,\n+    ProgramClauseCategory,\n+};\n+use rustc::ty;\n+use rustc::ty::subst::{InternalSubsts, Subst};\n+use rustc::hir::def_id::DefId;\n+use crate::lowering::Lower;\n+use crate::generic_types;\n+\n+crate fn assemble_builtin_unsize_impls<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    unsize_def_id: DefId,\n+    source: ty::Ty<'tcx>,\n+    target: ty::Ty<'tcx>,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    match (&source.sty, &target.sty) {\n+        (ty::Dynamic(data_a, ..), ty::Dynamic(data_b, ..)) => {\n+            if data_a.principal_def_id() != data_b.principal_def_id()\n+                || data_b.auto_traits().any(|b| data_a.auto_traits().all(|a| a != b))\n+            {\n+                return;\n+            }\n+\n+            // FIXME: rules for trait upcast\n+        }\n+\n+        (_, &ty::Dynamic(..)) => {\n+            // FIXME: basically, we should have something like:\n+            // ```\n+            // forall<T> {\n+            //     Implemented(T: Unsize< for<...> dyn Trait<...> >) :-\n+            //         for<...> Implemented(T: Trait<...>).\n+            // }\n+            // ```\n+            // The question is: how to correctly handle the higher-ranked\n+            // `for<...>` binder in order to have a generic rule?\n+            // (Having generic rules is useful for caching, as we may be able\n+            // to turn this function and others into tcx queries later on).\n+        }\n+\n+        (ty::Array(_, length), ty::Slice(_)) => {\n+            let ty_param = generic_types::bound(tcx, 0);\n+            let array_ty = tcx.mk_ty(ty::Array(ty_param, length));\n+            let slice_ty = tcx.mk_ty(ty::Slice(ty_param));\n+\n+            // `forall<T> { Implemented([T; N]: Unsize<[T]>). }`\n+            let clause = ProgramClause {\n+                goal: ty::TraitPredicate {\n+                    trait_ref: ty::TraitRef {\n+                        def_id: unsize_def_id,\n+                        substs: tcx.mk_substs_trait(array_ty, &[slice_ty.into()])\n+                    },\n+                }.lower(),\n+                hypotheses: ty::List::empty(),\n+                category: ProgramClauseCategory::Other,\n+            };\n+\n+            clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n+        }\n+\n+        (ty::Infer(ty::TyVar(_)), _) | (_, ty::Infer(ty::TyVar(_))) => {\n+            // FIXME: ambiguous\n+        }\n+\n+        (ty::Adt(def_id_a, ..), ty::Adt(def_id_b, ..)) => {\n+            if def_id_a != def_id_b {\n+                return;\n+            }\n+\n+            // FIXME: rules for struct unsizing\n+        }\n+\n+        (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n+            if tys_a.len() != tys_b.len() {\n+                return;\n+            }\n+\n+            // FIXME: rules for tuple unsizing\n+        }\n+\n+        _ => (),\n+    }\n+}\n+\n+crate fn assemble_builtin_sized_impls<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    sized_def_id: DefId,\n+    ty: ty::Ty<'tcx>,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[ty::Ty<'tcx>]| {\n+        let clause = ProgramClause {\n+            goal: ty::TraitPredicate {\n+                trait_ref: ty::TraitRef {\n+                    def_id: sized_def_id,\n+                    substs: tcx.mk_substs_trait(ty, &[]),\n+                },\n+            }.lower(),\n+            hypotheses: tcx.mk_goals(\n+                nested.iter()\n+                    .cloned()\n+                    .map(|nested_ty| ty::TraitRef {\n+                        def_id: sized_def_id,\n+                        substs: tcx.mk_substs_trait(nested_ty, &[]),\n+                    })\n+                    .map(|trait_ref| ty::TraitPredicate { trait_ref })\n+                    .map(|pred| GoalKind::DomainGoal(pred.lower()))\n+                    .map(|goal_kind| tcx.mk_goal(goal_kind))\n+            ),\n+            category: ProgramClauseCategory::Other,\n+        };\n+        // Bind innermost bound vars that may exist in `ty` and `nested`.\n+        clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n+    };\n+\n+    match &ty.sty {\n+        // Non parametric primitive types.\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(..) |\n+        ty::Uint(..) |\n+        ty::Float(..) |\n+        ty::Error |\n+        ty::Never => push_builtin_impl(ty, &[]),\n+\n+        // These ones are always `Sized`.\n+        &ty::Array(_, length) => {\n+            push_builtin_impl(tcx.mk_ty(ty::Array(generic_types::bound(tcx, 0), length)), &[]);\n+        }\n+        ty::RawPtr(ptr) => {\n+            push_builtin_impl(generic_types::raw_ptr(tcx, ptr.mutbl), &[]);\n+        }\n+        &ty::Ref(_, _, mutbl) => {\n+            push_builtin_impl(generic_types::ref_ty(tcx, mutbl), &[]);\n+        }\n+        ty::FnPtr(fn_ptr) => {\n+            let fn_ptr = fn_ptr.skip_binder();\n+            let fn_ptr = generic_types::fn_ptr(\n+                tcx,\n+                fn_ptr.inputs_and_output.len(),\n+                fn_ptr.c_variadic,\n+                fn_ptr.unsafety,\n+                fn_ptr.abi\n+            );\n+            push_builtin_impl(fn_ptr, &[]);\n+        }\n+        &ty::FnDef(def_id, ..) => {\n+            push_builtin_impl(generic_types::fn_def(tcx, def_id), &[]);\n+        }\n+        &ty::Closure(def_id, ..) => {\n+            push_builtin_impl(generic_types::closure(tcx, def_id), &[]);\n+        }\n+        &ty::Generator(def_id, ..) => {\n+            push_builtin_impl(generic_types::generator(tcx, def_id), &[]);\n+        }\n+\n+        // `Sized` if the last type is `Sized` (because else we will get a WF error anyway).\n+        &ty::Tuple(type_list) => {\n+            let type_list = generic_types::type_list(tcx, type_list.len());\n+            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &**type_list);\n+        }\n+\n+        // Struct def\n+        ty::Adt(adt_def, _) => {\n+            let substs = InternalSubsts::bound_vars_for_item(tcx, adt_def.did);\n+            let adt = tcx.mk_ty(ty::Adt(adt_def, substs));\n+            let sized_constraint = adt_def.sized_constraint(tcx)\n+                .iter()\n+                .map(|ty| ty.subst(tcx, substs))\n+                .collect::<Vec<_>>();\n+            push_builtin_impl(adt, &sized_constraint);\n+        }\n+\n+        // Artificially trigger an ambiguity.\n+        ty::Infer(..) => {\n+            // Everybody can find at least two types to unify against:\n+            // general ty vars, int vars and float vars.\n+            push_builtin_impl(tcx.types.i32, &[]);\n+            push_builtin_impl(tcx.types.u32, &[]);\n+            push_builtin_impl(tcx.types.f32, &[]);\n+            push_builtin_impl(tcx.types.f64, &[]);\n+        }\n+\n+        ty::Projection(_projection_ty) => {\n+            // FIXME: add builtin impls from the associated type values found in\n+            // trait impls of `projection_ty.trait_ref(tcx)`.\n+        }\n+\n+        // The `Sized` bound can only come from the environment.\n+        ty::Param(..) |\n+        ty::Placeholder(..) |\n+        ty::UnnormalizedProjection(..) => (),\n+\n+        // Definitely not `Sized`.\n+        ty::Foreign(..) |\n+        ty::Str |\n+        ty::Slice(..) |\n+        ty::Dynamic(..) |\n+        ty::Opaque(..) => (),\n+\n+        ty::Bound(..) |\n+        ty::GeneratorWitness(..) => bug!(\"unexpected type {:?}\", ty),\n+    }\n+}"}, {"sha": "80fbd97c5876b111a37c2e482ba79b07f1c8d3ac", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -0,0 +1,310 @@\n+mod builtin;\n+mod primitive;\n+\n+use rustc::traits::{\n+    WellFormed,\n+    FromEnv,\n+    DomainGoal,\n+    Clause,\n+    ProgramClause,\n+    ProgramClauseCategory,\n+    Environment,\n+};\n+use rustc::ty;\n+use rustc::hir::def_id::DefId;\n+use super::ChalkInferenceContext;\n+use std::iter;\n+\n+use self::primitive::*;\n+use self::builtin::*;\n+\n+fn assemble_clauses_from_impls<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    trait_def_id: DefId,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    tcx.for_each_impl(trait_def_id, |impl_def_id| {\n+        clauses.extend(\n+            tcx.program_clauses_for(impl_def_id)\n+                .into_iter()\n+                .cloned()\n+        );\n+    });\n+}\n+\n+fn assemble_clauses_from_assoc_ty_values<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    trait_def_id: DefId,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    tcx.for_each_impl(trait_def_id, |impl_def_id| {\n+        for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {\n+            clauses.extend(\n+                tcx.program_clauses_for(*def_id)\n+                    .into_iter()\n+                    .cloned()\n+            );\n+        }\n+    });\n+}\n+\n+impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n+    pub(super) fn program_clauses_impl(\n+        &self,\n+        environment: &Environment<'tcx>,\n+        goal: &DomainGoal<'tcx>,\n+    ) -> Vec<Clause<'tcx>> {\n+        use rustc::traits::WhereClause::*;\n+        use rustc::infer::canonical::OriginalQueryValues;\n+\n+        let goal = self.infcx.resolve_type_vars_if_possible(goal);\n+\n+        debug!(\"program_clauses(goal = {:?})\", goal);\n+\n+        let mut clauses = match goal {\n+            DomainGoal::Holds(Implemented(trait_predicate)) => {\n+                // These come from:\n+                // * implementations of the trait itself (rule `Implemented-From-Impl`)\n+                // * the trait decl (rule `Implemented-From-Env`)\n+\n+                let mut clauses = vec![];\n+\n+                assemble_clauses_from_impls(\n+                    self.infcx.tcx,\n+                    trait_predicate.def_id(),\n+                    &mut clauses\n+                );\n+\n+                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().sized_trait() {\n+                    assemble_builtin_sized_impls(\n+                        self.infcx.tcx,\n+                        trait_predicate.def_id(),\n+                        trait_predicate.self_ty(),\n+                        &mut clauses\n+                    );\n+                }\n+\n+                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().unsize_trait() {\n+                    let source = trait_predicate.self_ty();\n+                    let target = trait_predicate.trait_ref.substs.type_at(1);\n+                    assemble_builtin_unsize_impls(\n+                        self.infcx.tcx,\n+                        trait_predicate.def_id(),\n+                        source,\n+                        target,\n+                        &mut clauses\n+                    );\n+                }\n+\n+                // FIXME: we need to add special rules for other builtin impls:\n+                // * `Copy` / `Clone`\n+                // * `Generator`\n+                // * `FnOnce` / `FnMut` / `Fn`\n+                // * trait objects\n+                // * auto traits\n+\n+                // Rule `Implemented-From-Env` will be computed from the environment.\n+                clauses\n+            }\n+\n+            DomainGoal::Holds(ProjectionEq(projection_predicate)) => {\n+                // These come from:\n+                // * the assoc type definition (rule `ProjectionEq-Placeholder`)\n+                // * normalization of the assoc ty values (rule `ProjectionEq-Normalize`)\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                let clauses = self.infcx.tcx.program_clauses_for(\n+                    projection_predicate.projection_ty.item_def_id\n+                ).into_iter()\n+\n+                    // only select `ProjectionEq-Placeholder` and `ProjectionEq-Normalize`\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::Other)\n+\n+                    .cloned()\n+                    .collect::<Vec<_>>();\n+\n+                // Rules `Implied-Bound-From-Trait` and `Implied-Bound-From-Type` will be computed\n+                // from the environment.\n+                clauses\n+            }\n+\n+            // For outlive requirements, just assume they hold. `ResolventOps::resolvent_clause`\n+            // will register them as actual region constraints later.\n+            DomainGoal::Holds(RegionOutlives(..)) | DomainGoal::Holds(TypeOutlives(..)) => {\n+                vec![Clause::Implies(ProgramClause {\n+                    goal,\n+                    hypotheses: ty::List::empty(),\n+                    category: ProgramClauseCategory::Other,\n+                })]\n+            }\n+\n+            DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)) => {\n+                // These come from -- the trait decl (rule `WellFormed-TraitRef`).\n+                self.infcx.tcx.program_clauses_for(trait_predicate.def_id())\n+                    .into_iter()\n+\n+                    // only select `WellFormed-TraitRef`\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n+\n+                    .cloned()\n+                    .collect()\n+            }\n+\n+            DomainGoal::WellFormed(WellFormed::Ty(ty)) => {\n+                // These come from:\n+                // * the associated type definition if `ty` refers to an unnormalized\n+                //   associated type (rule `WellFormed-AssocTy`)\n+                // * custom rules for built-in types\n+                // * the type definition otherwise (rule `WellFormed-Type`)\n+                let clauses = match ty.sty {\n+                    ty::Projection(data) => {\n+                        self.infcx.tcx.program_clauses_for(data.item_def_id)\n+                    }\n+\n+                    // These types are always WF.\n+                    ty::Bool |\n+                    ty::Char |\n+                    ty::Int(..) |\n+                    ty::Uint(..) |\n+                    ty::Float(..) |\n+                    ty::Str |\n+                    ty::Param(..) |\n+                    ty::Placeholder(..) |\n+                    ty::Error |\n+                    ty::Never => {\n+                        let wf_clause = ProgramClause {\n+                            goal,\n+                            hypotheses: ty::List::empty(),\n+                            category: ProgramClauseCategory::WellFormed,\n+                        };\n+                        let wf_clause = Clause::Implies(wf_clause);\n+\n+                        self.infcx.tcx.mk_clauses(iter::once(wf_clause))\n+                    }\n+\n+                    // Always WF (recall that we do not check for parameters to be WF).\n+                    ty::RawPtr(ptr) => wf_clause_for_raw_ptr(self.infcx.tcx, ptr.mutbl),\n+\n+                    // Always WF (recall that we do not check for parameters to be WF).\n+                    ty::FnPtr(fn_ptr) => {\n+                        let fn_ptr = fn_ptr.skip_binder();\n+                        wf_clause_for_fn_ptr(\n+                            self.infcx.tcx,\n+                            fn_ptr.inputs_and_output.len(),\n+                            fn_ptr.c_variadic,\n+                            fn_ptr.unsafety,\n+                            fn_ptr.abi\n+                        )\n+                    }\n+\n+                    // WF if inner type is `Sized`.\n+                    ty::Slice(..) => wf_clause_for_slice(self.infcx.tcx),\n+\n+                    // WF if inner type is `Sized`.\n+                    ty::Array(_, length) => wf_clause_for_array(self.infcx.tcx, length),\n+\n+                    // WF if all types but the last one are `Sized`.\n+                    ty::Tuple(types) => wf_clause_for_tuple(\n+                        self.infcx.tcx,\n+                        types.len()\n+                    ),\n+\n+                    // WF if `sub_ty` outlives `region`.\n+                    ty::Ref(_, _, mutbl) => wf_clause_for_ref(self.infcx.tcx, mutbl),\n+\n+                    ty::FnDef(def_id, ..) => wf_clause_for_fn_def(self.infcx.tcx, def_id),\n+\n+                    ty::Dynamic(..) => {\n+                        // FIXME: no rules yet for trait objects\n+                        ty::List::empty()\n+                    }\n+\n+                    ty::Adt(def, ..) => {\n+                        self.infcx.tcx.program_clauses_for(def.did)\n+                    }\n+\n+                    // FIXME: these are probably wrong\n+                    ty::Foreign(def_id) |\n+                    ty::Closure(def_id, ..) |\n+                    ty::Generator(def_id, ..) |\n+                    ty::Opaque(def_id, ..) => {\n+                        self.infcx.tcx.program_clauses_for(def_id)\n+                    }\n+\n+                    // Artificially trigger an ambiguity.\n+                    ty::Infer(..) => {\n+                        let tcx = self.infcx.tcx;\n+                        let types = [tcx.types.i32, tcx.types.u32, tcx.types.f32, tcx.types.f64];\n+                        let clauses = types.iter()\n+                            .cloned()\n+                            .map(|ty| ProgramClause {\n+                                goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n+                                hypotheses: ty::List::empty(),\n+                                category: ProgramClauseCategory::WellFormed,\n+                            })\n+                            .map(|clause| Clause::Implies(clause));\n+                        tcx.mk_clauses(clauses)\n+                    }\n+\n+                    ty::GeneratorWitness(..) |\n+                    ty::UnnormalizedProjection(..) |\n+                    ty::Bound(..) => {\n+                        bug!(\"unexpected type {:?}\", ty)\n+                    }\n+                };\n+\n+                clauses.into_iter()\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n+                    .cloned()\n+                    .collect()\n+            }\n+\n+            DomainGoal::FromEnv(FromEnv::Trait(..)) => {\n+                // These come from:\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+                // * implied bounds from assoc type defs (rules `Implied-Trait-From-AssocTy`,\n+                //   `Implied-Bound-From-AssocTy` and `Implied-WC-From-AssocTy`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n+            }\n+\n+            DomainGoal::FromEnv(FromEnv::Ty(..)) => {\n+                // There are no `FromEnv::Ty(..) :- ...` rules (this predicate only\n+                // comes from the environment).\n+                vec![]\n+            }\n+\n+            DomainGoal::Normalize(projection_predicate) => {\n+                // These come from -- assoc ty values (rule `Normalize-From-Impl`).\n+                let mut clauses = vec![];\n+\n+                assemble_clauses_from_assoc_ty_values(\n+                    self.infcx.tcx,\n+                    projection_predicate.projection_ty.trait_ref(self.infcx.tcx).def_id,\n+                    &mut clauses\n+                );\n+\n+                clauses\n+            }\n+        };\n+\n+        debug!(\"program_clauses: clauses = {:?}\", clauses);\n+        debug!(\"program_clauses: adding clauses from environment = {:?}\", environment);\n+\n+        let mut _orig_query_values = OriginalQueryValues::default();\n+        let canonical_environment = self.infcx.canonicalize_query(\n+            environment,\n+            &mut _orig_query_values\n+        ).value;\n+        let env_clauses = self.infcx.tcx.program_clauses_for_env(canonical_environment);\n+\n+        debug!(\"program_clauses: env_clauses = {:?}\", env_clauses);\n+\n+        clauses.extend(env_clauses.into_iter().cloned());\n+        clauses.extend(environment.clauses.iter().cloned());\n+        clauses\n+    }\n+}"}, {"sha": "fc6d40914745dca03ee84e9b8c5fa941cb494e08", "filename": "src/librustc_traits/chalk_context/program_clauses/primitive.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -0,0 +1,204 @@\n+use rustc::traits::{\n+    WellFormed,\n+    DomainGoal,\n+    GoalKind,\n+    Clause,\n+    Clauses,\n+    ProgramClause,\n+    ProgramClauseCategory,\n+};\n+use rustc::ty;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc_target::spec::abi;\n+use crate::lowering::Lower;\n+use crate::generic_types;\n+use std::iter;\n+\n+crate fn wf_clause_for_raw_ptr<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    mutbl: hir::Mutability\n+) -> Clauses<'tcx> {\n+    let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(ptr_ty)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::Implies(wf_clause);\n+\n+    // `forall<T> { WellFormed(*const T). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_fn_ptr<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    arity_and_output: usize,\n+    variadic: bool,\n+    unsafety: hir::Unsafety,\n+    abi: abi::Abi\n+) -> Clauses<'tcx> {\n+    let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, variadic, unsafety, abi);\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_ptr)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall <T1, ..., Tn+1> { WellFormed(for<> fn(T1, ..., Tn) -> Tn+1). }`\n+    // where `n + 1` == `arity_and_output`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+    let ty = generic_types::bound(tcx, 0);\n+    let slice_ty = tcx.mk_slice(ty);\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+    let sized_implemented = ty::TraitRef {\n+        def_id: sized_trait,\n+        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n+    };\n+    let sized_implemented: DomainGoal<'_> = ty::TraitPredicate {\n+        trait_ref: sized_implemented\n+    }.lower();\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(slice_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<T> { WellFormed([T]) :- Implemented(T: Sized). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_array<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    length: &'tcx ty::Const<'tcx>\n+) -> Clauses<'tcx> {\n+    let ty = generic_types::bound(tcx, 0);\n+    let array_ty = tcx.mk_ty(ty::Array(ty, length));\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+    let sized_implemented = ty::TraitRef {\n+        def_id: sized_trait,\n+        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n+    };\n+    let sized_implemented: DomainGoal<'_> = ty::TraitPredicate {\n+        trait_ref: sized_implemented\n+    }.lower();\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(array_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<T> { WellFormed([T; length]) :- Implemented(T: Sized). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_tuple<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    arity: usize\n+) -> Clauses<'tcx> {\n+    let type_list = generic_types::type_list(tcx, arity);\n+    let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+\n+    // If `arity == 0` (i.e. the unit type) or `arity == 1`, this list of\n+    // hypotheses is actually empty.\n+    let sized_implemented = type_list[0 .. std::cmp::max(arity, 1) - 1].iter()\n+        .map(|ty| ty::TraitRef {\n+            def_id: sized_trait,\n+            substs: tcx.mk_substs_trait(*ty, ty::List::empty()),\n+        })\n+        .map(|trait_ref| ty::TraitPredicate { trait_ref })\n+        .map(|predicate| predicate.lower());\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(tuple_ty)),\n+        hypotheses: tcx.mk_goals(\n+            sized_implemented.map(|domain_goal| {\n+                tcx.mk_goal(GoalKind::DomainGoal(domain_goal))\n+            })\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // ```\n+    // forall<T1, ..., Tn-1, Tn> {\n+    //     WellFormed((T1, ..., Tn)) :-\n+    //         Implemented(T1: Sized),\n+    //         ...\n+    //         Implemented(Tn-1: Sized).\n+    // }\n+    // ```\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_ref<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    mutbl: hir::Mutability\n+) -> Clauses<'tcx> {\n+    let region = tcx.mk_region(\n+        ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n+    );\n+    let ty = generic_types::bound(tcx, 1);\n+    let ref_ty = tcx.mk_ref(region, ty::TypeAndMut {\n+        ty,\n+        mutbl,\n+    });\n+\n+    let outlives: DomainGoal<'_> = ty::OutlivesPredicate(ty, region).lower();\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(ref_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(outlives.into_goal()))\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<'a, T> { WellFormed(&'a T) :- Outlives(T: 'a). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_fn_def<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    def_id: DefId\n+) -> Clauses<'tcx> {\n+    let fn_def = generic_types::fn_def(tcx, def_id);\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_def)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall <T1, ..., Tn+1> { WellFormed(fn some_fn(T1, ..., Tn) -> Tn+1). }`\n+    // where `def_id` maps to the `some_fn` function definition\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}"}, {"sha": "41f983e6acac81c3129da0199b230129dcb3e7b1", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -8,6 +8,7 @@ use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n use rustc::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc::traits::{\n     DomainGoal,\n+    WhereClause,\n     Goal,\n     GoalKind,\n     Clause,\n@@ -75,6 +76,23 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n                 })\n             );\n \n+            // If we have a goal of the form `T: 'a` or `'a: 'b`, then just\n+            // assume it is true (no subgoals) and register it as a constraint\n+            // instead.\n+            match goal {\n+                DomainGoal::Holds(WhereClause::RegionOutlives(pred)) => {\n+                    assert_eq!(ex_clause.subgoals.len(), 0);\n+                    ex_clause.constraints.push(ty::OutlivesPredicate(pred.0.into(), pred.1));\n+                }\n+\n+                DomainGoal::Holds(WhereClause::TypeOutlives(pred)) => {\n+                    assert_eq!(ex_clause.subgoals.len(), 0);\n+                    ex_clause.constraints.push(ty::OutlivesPredicate(pred.0.into(), pred.1));\n+                }\n+\n+                _ => (),\n+            };\n+\n             let canonical_ex_clause = self.canonicalize_ex_clause(&ex_clause);\n             Ok(canonical_ex_clause)\n         });\n@@ -112,10 +130,8 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         substitutor.relate(&answer_table_goal.value, &selected_goal)\n             .map_err(|_| NoSolution)?;\n \n-        let ex_clause = substitutor.ex_clause;\n-\n-        // FIXME: restore this later once we get better at handling regions\n-        // ex_clause.constraints.extend(answer_subst.constraints);\n+        let mut ex_clause = substitutor.ex_clause;\n+        ex_clause.constraints.extend(answer_subst.constraints);\n \n         debug!(\"apply_answer_subst: ex_clause = {:?}\", ex_clause);\n         Ok(ex_clause)"}, {"sha": "3570cb102460002a3596fa49179a14266fd4082b", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -10,9 +10,6 @@ use rustc::traits::{\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashSet;\n-use super::Lower;\n-use crate::generic_types;\n-use std::iter;\n \n struct ClauseVisitor<'set, 'a, 'tcx: 'a + 'set> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -38,30 +35,6 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n                 );\n             }\n \n-            // forall<'a, T> { `Outlives(T: 'a) :- FromEnv(&'a T)` }\n-            ty::Ref(_, _, mutbl) => {\n-                let region = self.tcx.mk_region(\n-                    ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n-                );\n-                let ty = generic_types::bound(self.tcx, 1);\n-                let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n-                    ty,\n-                    mutbl,\n-                });\n-\n-                let from_env = DomainGoal::FromEnv(FromEnv::Ty(ref_ty));\n-\n-                let clause = ProgramClause {\n-                    goal: ty::OutlivesPredicate(ty, region).lower(),\n-                    hypotheses: self.tcx.mk_goals(\n-                        iter::once(self.tcx.mk_goal(from_env.into_goal()))\n-                    ),\n-                    category: ProgramClauseCategory::ImpliedBound,\n-                };\n-                let clause = Clause::ForAll(ty::Binder::bind(clause));\n-                self.round.insert(clause);\n-            }\n-\n             ty::Dynamic(..) => {\n                 // FIXME: trait object rules are not yet implemented\n             }\n@@ -99,6 +72,7 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n             ty::RawPtr(..) |\n             ty::FnPtr(..) |\n             ty::Tuple(..) |\n+            ty::Ref(..) |\n             ty::Never |\n             ty::Infer(..) |\n             ty::Placeholder(..) |"}, {"sha": "c3cbdb0376251474514337777400fa7a158fa769", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -209,6 +209,10 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     let implemented_from_env = Clause::ForAll(ty::Binder::bind(implemented_from_env));\n \n     let predicates = &tcx.predicates_defined_on(def_id).predicates;\n+\n+    // Warning: these where clauses are not substituted for bound vars yet,\n+    // so that we don't need to adjust binders in the `FromEnv` rules below\n+    // (see the FIXME).\n     let where_clauses = &predicates\n         .iter()\n         .map(|(wc, _)| wc.lower())\n@@ -258,6 +262,7 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     // `WellFormed(WC)`\n     let wf_conditions = where_clauses\n         .into_iter()\n+        .map(|wc| wc.subst(tcx, bound_vars))\n         .map(|wc| wc.map_bound(|goal| goal.into_well_formed_goal()));\n \n     // `WellFormed(Self: Trait<P1..Pn>) :- Implemented(Self: Trait<P1..Pn>) && WellFormed(WC)`\n@@ -332,7 +337,7 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n     //\n     // ```\n     // forall<P1..Pn> {\n-    //   WellFormed(Ty<...>) :- WC1, ..., WCm`\n+    //   WellFormed(Ty<...>) :- WellFormed(WC1), ..., WellFormed(WCm)`\n     // }\n     // ```\n \n@@ -341,19 +346,22 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n     // `Ty<...>`\n     let ty = tcx.type_of(def_id).subst(tcx, bound_vars);\n \n-    // `WC`\n+    // Warning: these where clauses are not substituted for bound vars yet,\n+    // so that we don't need to adjust binders in the `FromEnv` rules below\n+    // (see the FIXME).\n     let where_clauses = tcx.predicates_of(def_id).predicates\n         .iter()\n         .map(|(wc, _)| wc.lower())\n         .collect::<Vec<_>>();\n \n-    // `WellFormed(Ty<...>) :- WC1, ..., WCm`\n+    // `WellFormed(Ty<...>) :- WellFormed(WC1), ..., WellFormed(WCm)`\n     let well_formed_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n         hypotheses: tcx.mk_goals(\n             where_clauses\n                 .iter()\n                 .map(|wc| wc.subst(tcx, bound_vars))\n+                .map(|wc| wc.map_bound(|bound| bound.into_well_formed_goal()))\n                 .map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n         ),\n         category: ProgramClauseCategory::WellFormed,\n@@ -450,13 +458,13 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     // ```\n     // forall<Self, P1..Pn, Pn+1..Pm> {\n     //     WellFormed((Trait::AssocType)<Self, P1..Pn, Pn+1..Pm>)\n-    //         :- Implemented(Self: Trait<P1..Pn>)\n+    //         :- WellFormed(Self: Trait<P1..Pn>)\n     // }\n     // ```\n \n     let trait_predicate = ty::TraitPredicate { trait_ref };\n     let hypothesis = tcx.mk_goal(\n-        DomainGoal::Holds(WhereClause::Implemented(trait_predicate)).into_goal()\n+        DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)).into_goal()\n     );\n \n     let wf_clause = ProgramClause {"}, {"sha": "861f86e61658aed0fb02b4ee4bebb55b337cc0be", "filename": "src/test/compile-fail/chalkify/recursive_where_clause_on_type.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Ftest%2Fcompile-fail%2Fchalkify%2Frecursive_where_clause_on_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Ftest%2Fcompile-fail%2Fchalkify%2Frecursive_where_clause_on_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Frecursive_where_clause_on_type.rs?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -0,0 +1,28 @@\n+// compile-flags: -Z chalk\n+\n+#![feature(trivial_bounds)]\n+\n+trait Bar {\n+    fn foo();\n+}\n+trait Foo: Bar { }\n+\n+struct S where S: Foo;\n+\n+impl Foo for S {\n+}\n+\n+fn bar<T: Bar>() {\n+    T::foo();\n+}\n+\n+fn foo<T: Foo>() {\n+    bar::<T>()\n+}\n+\n+fn main() {\n+    // For some reason, the error is duplicated...\n+\n+    foo::<S>() //~ ERROR the type `S` is not well-formed (chalk)\n+    //~^ ERROR the type `S` is not well-formed (chalk)\n+}"}, {"sha": "613a568a8549c95a7711747f48791d80750bb2db", "filename": "src/test/ui/chalkify/lower_env2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -6,7 +6,7 @@ LL | #[rustc_dump_program_clauses]\n    |\n    = note: forall<'a, T> { FromEnv(T: Foo) :- FromEnv(S<'a, T>). }\n    = note: forall<'a, T> { TypeOutlives(T: 'a) :- FromEnv(S<'a, T>). }\n-   = note: forall<'a, T> { WellFormed(S<'a, T>) :- Implemented(T: Foo), TypeOutlives(T: 'a). }\n+   = note: forall<'a, T> { WellFormed(S<'a, T>) :- WellFormed(T: Foo), TypeOutlives(T: 'a). }\n \n error: program clause dump\n   --> $DIR/lower_env2.rs:11:1"}, {"sha": "a1fc83bfea8a3a0b5a6c7d4a034e92b6cb451eba", "filename": "src/test/ui/chalkify/lower_env3.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -4,7 +4,6 @@ error: program clause dump\n LL |     #[rustc_dump_env_program_clauses]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: forall<'^0, ^1> { TypeOutlives(^1: '^0) :- FromEnv(&^1). }\n    = note: forall<Self> { Implemented(Self: Foo) :- FromEnv(Self: Foo). }\n \n error: program clause dump\n@@ -13,7 +12,6 @@ error: program clause dump\n LL |     #[rustc_dump_env_program_clauses]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: forall<'^0, ^1> { TypeOutlives(^1: '^0) :- FromEnv(&^1). }\n    = note: forall<Self> { FromEnv(Self: std::marker::Sized) :- FromEnv(Self: std::clone::Clone). }\n    = note: forall<Self> { Implemented(Self: std::clone::Clone) :- FromEnv(Self: std::clone::Clone). }\n    = note: forall<Self> { Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized). }"}, {"sha": "0331c2fca16db3bb5987a3668978734d513bcd05", "filename": "src/test/ui/chalkify/lower_struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -7,7 +7,7 @@ LL | #[rustc_dump_program_clauses]\n    = note: forall<'a, T> { FromEnv(T: std::marker::Sized) :- FromEnv(Foo<'a, T>). }\n    = note: forall<'a, T> { FromEnv(std::boxed::Box<T>: std::clone::Clone) :- FromEnv(Foo<'a, T>). }\n    = note: forall<'a, T> { TypeOutlives(T: 'a) :- FromEnv(Foo<'a, T>). }\n-   = note: forall<'a, T> { WellFormed(Foo<'a, T>) :- Implemented(T: std::marker::Sized), Implemented(std::boxed::Box<T>: std::clone::Clone), TypeOutlives(T: 'a). }\n+   = note: forall<'a, T> { WellFormed(Foo<'a, T>) :- WellFormed(T: std::marker::Sized), WellFormed(std::boxed::Box<T>: std::clone::Clone), TypeOutlives(T: 'a). }\n \n error: aborting due to previous error\n "}, {"sha": "ed3bded398ae3955f9876f0ef1e967903e2cbfbe", "filename": "src/test/ui/chalkify/lower_trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr?ref=c7b5f4d0f7ccf5d40168f541d4418bb76d9cb513", "patch": "@@ -18,7 +18,7 @@ LL |     #[rustc_dump_program_clauses]\n    = note: forall<Self, S, T, ^3> { ProjectionEq(<Self as Foo<S, T>>::Assoc == ^3) :- Normalize(<Self as Foo<S, T>>::Assoc -> ^3). }\n    = note: forall<Self, S, T> { FromEnv(Self: Foo<S, T>) :- FromEnv(Unnormalized(<Self as Foo<S, T>>::Assoc)). }\n    = note: forall<Self, S, T> { ProjectionEq(<Self as Foo<S, T>>::Assoc == Unnormalized(<Self as Foo<S, T>>::Assoc)). }\n-   = note: forall<Self, S, T> { WellFormed(Unnormalized(<Self as Foo<S, T>>::Assoc)) :- Implemented(Self: Foo<S, T>). }\n+   = note: forall<Self, S, T> { WellFormed(Unnormalized(<Self as Foo<S, T>>::Assoc)) :- WellFormed(Self: Foo<S, T>). }\n \n error: aborting due to 2 previous errors\n "}]}