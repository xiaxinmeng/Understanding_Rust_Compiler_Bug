{"sha": "8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYTljMmQ0Y2VkYmNmOGYxZDJjNjQ0NzMzZDJiMDZmYTE5ODRkMjI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-15T17:54:18Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-15T17:54:18Z"}, "message": "remove Cancelable from type inference", "tree": {"sha": "a97af07a664ce4be35f6a16409eebd6706296fff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a97af07a664ce4be35f6a16409eebd6706296fff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "html_url": "https://github.com/rust-lang/rust/commit/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b871062e329301683083a1a2ff5eb476e6c397c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b871062e329301683083a1a2ff5eb476e6c397c7", "html_url": "https://github.com/rust-lang/rust/commit/b871062e329301683083a1a2ff5eb476e6c397c7"}], "stats": {"total": 207, "additions": 88, "deletions": 119}, "files": [{"sha": "0cf45944fe69af654c09ec8027761c79979725bc", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "patch": "@@ -318,7 +318,7 @@ impl Function {\n         db.fn_signature(self.def_id)\n     }\n \n-    pub fn infer(&self, db: &impl HirDatabase) -> Cancelable<Arc<InferenceResult>> {\n+    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer(self.def_id)\n     }\n }"}, {"sha": "0a0994f5f7f7c70cc7e7156d9d5d00c0829c34b5", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n-use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, Cancelable};\n+use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase};\n \n use crate::{\n     DefLoc, DefId, MacroCallLoc, MacroCallId, Name, HirFileId,\n@@ -52,7 +52,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::adt::EnumVariantData::enum_variant_data_query;\n     }\n \n-    fn infer(def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n+    fn infer(def_id: DefId) -> Arc<InferenceResult> {\n         type InferQuery;\n         use fn crate::ty::infer;\n     }\n@@ -102,7 +102,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::impl_block::impls_in_module;\n     }\n \n-    fn impls_in_crate(krate: Crate) -> Cancelable<Arc<CrateImplBlocks>> {\n+    fn impls_in_crate(krate: Crate) -> Arc<CrateImplBlocks> {\n         type ImplsInCrateQuery;\n         use fn crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query;\n     }"}, {"sha": "ef7d049eeeb1812f2b554fc9d5733a248df03bfd", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "patch": "@@ -5,15 +5,6 @@\n //! to a particular crate instance. That is, it has cfg flags and features\n //! applied. So, the relation between syntax and HIR is many-to-one.\n \n-macro_rules! ctry {\n-    ($expr:expr) => {\n-        match $expr {\n-            None => return Ok(None),\n-            Some(it) => it,\n-        }\n-    };\n-}\n-\n pub mod db;\n #[cfg(test)]\n mod mock;"}, {"sha": "dbbbce795da1da1ac9f14e1b77f5fb51e711c4c0", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 57, "deletions": 71, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "patch": "@@ -30,8 +30,6 @@ use ra_arena::map::ArenaMap;\n use join_to_string::join;\n use rustc_hash::FxHashMap;\n \n-use ra_db::Cancelable;\n-\n use crate::{\n     Def, DefId, Module, Function, Struct, Enum, EnumVariant, Path, Name, ImplBlock,\n     FnSignature, FnScopes,\n@@ -41,14 +39,6 @@ use crate::{\n     expr::{Body, Expr, Literal, ExprId, PatId, UnaryOp, BinaryOp, Statement},\n };\n \n-fn transpose<T>(x: Cancelable<Option<T>>) -> Option<Cancelable<T>> {\n-    match x {\n-        Ok(Some(t)) => Some(Ok(t)),\n-        Ok(None) => None,\n-        Err(e) => Some(Err(e)),\n-    }\n-}\n-\n /// The ID of a type variable.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TypeVarId(u32);\n@@ -836,36 +826,36 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_path_expr(&mut self, expr: ExprId, path: &Path) -> Cancelable<Option<Ty>> {\n+    fn infer_path_expr(&mut self, expr: ExprId, path: &Path) -> Option<Ty> {\n         if path.is_ident() || path.is_self() {\n             // resolve locally\n             let name = path.as_ident().cloned().unwrap_or_else(Name::self_param);\n             if let Some(scope_entry) = self.scopes.resolve_local_name(expr, name) {\n-                let ty = ctry!(self.type_of_pat.get(scope_entry.pat()));\n+                let ty = self.type_of_pat.get(scope_entry.pat())?;\n                 let ty = self.resolve_ty_as_possible(ty.clone());\n-                return Ok(Some(ty));\n+                return Some(ty);\n             };\n         };\n \n         // resolve in module\n-        let resolved = ctry!(self.module.resolve_path(self.db, &path).take_values());\n+        let resolved = self.module.resolve_path(self.db, &path).take_values()?;\n         let ty = self.db.type_for_def(resolved);\n         let ty = self.insert_type_vars(ty);\n-        Ok(Some(ty))\n+        Some(ty)\n     }\n \n-    fn resolve_variant(&self, path: Option<&Path>) -> Cancelable<(Ty, Option<DefId>)> {\n+    fn resolve_variant(&self, path: Option<&Path>) -> (Ty, Option<DefId>) {\n         let path = if let Some(path) = path {\n             path\n         } else {\n-            return Ok((Ty::Unknown, None));\n+            return (Ty::Unknown, None);\n         };\n         let def_id = if let Some(def_id) = self.module.resolve_path(self.db, &path).take_types() {\n             def_id\n         } else {\n-            return Ok((Ty::Unknown, None));\n+            return (Ty::Unknown, None);\n         };\n-        Ok(match def_id.resolve(self.db) {\n+        match def_id.resolve(self.db) {\n             Def::Struct(s) => {\n                 let ty = type_for_struct(self.db, s);\n                 (ty, Some(def_id))\n@@ -875,10 +865,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 (ty, Some(def_id))\n             }\n             _ => (Ty::Unknown, None),\n-        })\n+        }\n     }\n \n-    fn infer_expr(&mut self, expr: ExprId, expected: &Expectation) -> Cancelable<Ty> {\n+    fn infer_expr(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[expr] {\n             Expr::Missing => Ty::Unknown,\n@@ -888,11 +878,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 else_branch,\n             } => {\n                 // if let is desugared to match, so this is always simple if\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool))?;\n-                let then_ty = self.infer_expr(*then_branch, expected)?;\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n+                let then_ty = self.infer_expr(*then_branch, expected);\n                 match else_branch {\n                     Some(else_branch) => {\n-                        self.infer_expr(*else_branch, expected)?;\n+                        self.infer_expr(*else_branch, expected);\n                     }\n                     None => {\n                         // no else branch -> unit\n@@ -901,31 +891,31 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 };\n                 then_ty\n             }\n-            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected)?,\n+            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n             Expr::Loop { body } => {\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 // TODO handle break with value\n                 Ty::Never\n             }\n             Expr::While { condition, body } => {\n                 // while let is desugared to a match loop, so this is always simple while\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool))?;\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n             Expr::For { iterable, body, .. } => {\n                 let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n                 // TODO write type for pat\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n             Expr::Lambda { body, .. } => {\n                 // TODO write types for args, infer lambda type etc.\n-                let _body_ty = self.infer_expr(*body, &Expectation::none())?;\n+                let _body_ty = self.infer_expr(*body, &Expectation::none());\n                 Ty::Unknown\n             }\n             Expr::Call { callee, args } => {\n-                let callee_ty = self.infer_expr(*callee, &Expectation::none())?;\n+                let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let (param_tys, ret_ty) = match &callee_ty {\n                     Ty::FnPtr(sig) => (&sig.input[..], sig.output.clone()),\n                     _ => {\n@@ -938,7 +928,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     self.infer_expr(\n                         *arg,\n                         &Expectation::has_type(param_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n-                    )?;\n+                    );\n                 }\n                 ret_ty\n             }\n@@ -947,8 +937,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 args,\n                 method_name,\n             } => {\n-                let receiver_ty = self.infer_expr(*receiver, &Expectation::none())?;\n-                let resolved = receiver_ty.clone().lookup_method(self.db, method_name)?;\n+                let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n+                let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n                 let method_ty = match resolved {\n                     Some(def_id) => {\n                         self.write_method_resolution(expr, def_id);\n@@ -974,32 +964,32 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     self.infer_expr(\n                         *arg,\n                         &Expectation::has_type(param_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n-                    )?;\n+                    );\n                 }\n                 ret_ty\n             }\n             Expr::Match { expr, arms } => {\n-                let _ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let _ty = self.infer_expr(*expr, &Expectation::none());\n                 for arm in arms {\n                     // TODO type the bindings in pats\n                     // TODO type the guard\n-                    let _ty = self.infer_expr(arm.expr, &Expectation::none())?;\n+                    let _ty = self.infer_expr(arm.expr, &Expectation::none());\n                 }\n                 // TODO unify all the match arm types\n                 Ty::Unknown\n             }\n-            Expr::Path(p) => self.infer_path_expr(expr, p)?.unwrap_or(Ty::Unknown),\n+            Expr::Path(p) => self.infer_path_expr(expr, p).unwrap_or(Ty::Unknown),\n             Expr::Continue => Ty::Never,\n             Expr::Break { expr } => {\n                 if let Some(expr) = expr {\n                     // TODO handle break with value\n-                    self.infer_expr(*expr, &Expectation::none())?;\n+                    self.infer_expr(*expr, &Expectation::none());\n                 }\n                 Ty::Never\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()))?;\n+                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()));\n                 }\n                 Ty::Never\n             }\n@@ -1008,7 +998,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 fields,\n                 spread,\n             } => {\n-                let (ty, def_id) = self.resolve_variant(path.as_ref())?;\n+                let (ty, def_id) = self.resolve_variant(path.as_ref());\n                 for field in fields {\n                     let field_ty = if let Some(def_id) = def_id {\n                         self.db\n@@ -1017,37 +1007,35 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     } else {\n                         Ty::Unknown\n                     };\n-                    self.infer_expr(field.expr, &Expectation::has_type(field_ty))?;\n+                    self.infer_expr(field.expr, &Expectation::has_type(field_ty));\n                 }\n                 if let Some(expr) = spread {\n-                    self.infer_expr(*expr, &Expectation::has_type(ty.clone()))?;\n+                    self.infer_expr(*expr, &Expectation::has_type(ty.clone()));\n                 }\n                 ty\n             }\n             Expr::Field { expr, name } => {\n-                let receiver_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let receiver_ty = self.infer_expr(*expr, &Expectation::none());\n                 let ty = receiver_ty\n                     .autoderef(self.db)\n                     .find_map(|derefed_ty| match derefed_ty {\n                         // this is more complicated than necessary because type_for_field is cancelable\n                         Ty::Tuple(fields) => {\n                             let i = name.to_string().parse::<usize>().ok();\n-                            i.and_then(|i| fields.get(i).cloned()).map(Ok)\n-                        }\n-                        Ty::Adt { def_id, .. } => {\n-                            transpose(Ok(self.db.type_for_field(def_id, name.clone())))\n+                            i.and_then(|i| fields.get(i).cloned())\n                         }\n+                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, name.clone()),\n                         _ => None,\n                     })\n-                    .unwrap_or(Ok(Ty::Unknown))?;\n+                    .unwrap_or(Ty::Unknown);\n                 self.insert_type_vars(ty)\n             }\n             Expr::Try { expr } => {\n-                let _inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 Ty::Unknown\n             }\n             Expr::Cast { expr, type_ref } => {\n-                let _inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 let cast_ty =\n                     Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref);\n                 let cast_ty = self.insert_type_vars(cast_ty);\n@@ -1056,12 +1044,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Ref { expr, mutability } => {\n                 // TODO pass the expectation down\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 // TODO reference coercions etc.\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n             Expr::UnaryOp { expr, op } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 match op {\n                     Some(UnaryOp::Deref) => {\n                         if let Some(derefed_ty) = inner_ty.builtin_deref() {\n@@ -1082,11 +1070,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         }\n                         _ => Expectation::none(),\n                     };\n-                    let lhs_ty = self.infer_expr(*lhs, &lhs_expectation)?;\n+                    let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n                     // TODO: find implementation of trait corresponding to operation\n                     // symbol and resolve associated `Output` type\n                     let rhs_expectation = binary_op_rhs_expectation(*op, lhs_ty);\n-                    let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation))?;\n+                    let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation));\n \n                     // TODO: similar as above, return ty is often associated trait type\n                     binary_op_return_ty(*op, rhs_ty)\n@@ -1096,7 +1084,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Tuple { exprs } => {\n                 let mut ty_vec = Vec::with_capacity(exprs.len());\n                 for arg in exprs.iter() {\n-                    ty_vec.push(self.infer_expr(*arg, &Expectation::none())?);\n+                    ty_vec.push(self.infer_expr(*arg, &Expectation::none()));\n                 }\n \n                 Ty::Tuple(Arc::from(ty_vec))\n@@ -1121,15 +1109,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.unify(&ty, &expected.ty);\n         let ty = self.resolve_ty_as_possible(ty);\n         self.write_expr_ty(expr, ty.clone());\n-        Ok(ty)\n+        ty\n     }\n \n     fn infer_block(\n         &mut self,\n         statements: &[Statement],\n         tail: Option<ExprId>,\n         expected: &Expectation,\n-    ) -> Cancelable<Ty> {\n+    ) -> Ty {\n         for stmt in statements {\n             match stmt {\n                 Statement::Let {\n@@ -1145,7 +1133,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     );\n                     let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = initializer {\n-                        let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty))?;\n+                        let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty));\n                         expr_ty\n                     } else {\n                         decl_ty\n@@ -1154,19 +1142,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     self.write_pat_ty(*pat, ty);\n                 }\n                 Statement::Expr(expr) => {\n-                    self.infer_expr(*expr, &Expectation::none())?;\n+                    self.infer_expr(*expr, &Expectation::none());\n                 }\n             }\n         }\n         let ty = if let Some(expr) = tail {\n-            self.infer_expr(expr, expected)?\n+            self.infer_expr(expr, expected)\n         } else {\n             Ty::unit()\n         };\n-        Ok(ty)\n+        ty\n     }\n \n-    fn collect_fn_signature(&mut self, signature: &FnSignature) -> Cancelable<()> {\n+    fn collect_fn_signature(&mut self, signature: &FnSignature) {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n             let ty = self.make_ty(type_ref);\n@@ -1178,19 +1166,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let ty = self.insert_type_vars(ty);\n             ty\n         };\n-        Ok(())\n     }\n \n-    fn infer_body(&mut self) -> Cancelable<()> {\n+    fn infer_body(&mut self) {\n         self.infer_expr(\n             self.body.body_expr(),\n             &Expectation::has_type(self.return_ty.clone()),\n-        )?;\n-        Ok(())\n+        );\n     }\n }\n \n-pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n+pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Arc<InferenceResult> {\n     db.check_canceled();\n     let function = Function::new(def_id); // TODO: consts also need inference\n     let body = function.body(db);\n@@ -1200,9 +1186,9 @@ pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceRe\n     let mut ctx = InferenceContext::new(db, body, scopes, module, impl_block);\n \n     let signature = function.signature(db);\n-    ctx.collect_fn_signature(&signature)?;\n+    ctx.collect_fn_signature(&signature);\n \n-    ctx.infer_body()?;\n+    ctx.infer_body();\n \n-    Ok(Arc::new(ctx.resolve_all()))\n+    Arc::new(ctx.resolve_all())\n }"}, {"sha": "b221bd14250443d5866274634c77079e6b6f6118", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "patch": "@@ -6,7 +6,7 @@ use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n \n-use ra_db::{Cancelable, SourceRootId};\n+use ra_db::SourceRootId;\n \n use crate::{HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function, impl_block::{ImplId, ImplBlock, ImplItem}};\n use super::Ty;\n@@ -42,19 +42,19 @@ impl CrateImplBlocks {\n         &'a self,\n         db: &'a impl HirDatabase,\n         ty: &Ty,\n-    ) -> impl Iterator<Item = Cancelable<ImplBlock>> + 'a {\n+    ) -> impl Iterator<Item = ImplBlock> + 'a {\n         let fingerprint = TyFingerprint::for_impl(ty);\n         fingerprint\n             .and_then(|f| self.impls.get(&f))\n             .into_iter()\n             .flat_map(|i| i.iter())\n             .map(move |(module_id, impl_id)| {\n                 let module_impl_blocks = db.impls_in_module(self.source_root_id, *module_id);\n-                Ok(ImplBlock::from_id(module_impl_blocks, *impl_id))\n+                ImplBlock::from_id(module_impl_blocks, *impl_id)\n             })\n     }\n \n-    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) -> Cancelable<()> {\n+    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) {\n         let module_id = module.def_id.loc(db).module_id;\n         let module_impl_blocks = db.impls_in_module(self.source_root_id, module_id);\n \n@@ -76,16 +76,14 @@ impl CrateImplBlocks {\n         }\n \n         for child in module.children(db) {\n-            self.collect_recursive(db, child)?;\n+            self.collect_recursive(db, child);\n         }\n-\n-        Ok(())\n     }\n \n     pub(crate) fn impls_in_crate_query(\n         db: &impl HirDatabase,\n         krate: Crate,\n-    ) -> Cancelable<Arc<CrateImplBlocks>> {\n+    ) -> Arc<CrateImplBlocks> {\n         let crate_graph = db.crate_graph();\n         let file_id = crate_graph.crate_root(krate.crate_id);\n         let source_root_id = db.file_source_root(file_id);\n@@ -94,9 +92,9 @@ impl CrateImplBlocks {\n             impls: FxHashMap::default(),\n         };\n         if let Some(module) = krate.root_module(db) {\n-            crate_impl_blocks.collect_recursive(db, module)?;\n+            crate_impl_blocks.collect_recursive(db, module);\n         }\n-        Ok(Arc::new(crate_impl_blocks))\n+        Arc::new(crate_impl_blocks)\n     }\n }\n \n@@ -111,13 +109,13 @@ impl Ty {\n     // TODO: cache this as a query?\n     // - if so, what signature? (TyFingerprint, Name)?\n     // - or maybe cache all names and def_ids of methods per fingerprint?\n-    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Cancelable<Option<DefId>> {\n+    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<DefId> {\n         self.iterate_methods(db, |f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n-                Ok(Some(f.def_id()))\n+                Some(f.def_id())\n             } else {\n-                Ok(None)\n+                None\n             }\n         })\n     }\n@@ -127,8 +125,8 @@ impl Ty {\n     pub fn iterate_methods<T>(\n         self,\n         db: &impl HirDatabase,\n-        mut callback: impl FnMut(Function) -> Cancelable<Option<T>>,\n-    ) -> Cancelable<Option<T>> {\n+        mut callback: impl FnMut(Function) -> Option<T>,\n+    ) -> Option<T> {\n         // For method calls, rust first does any number of autoderef, and then one\n         // autoref (i.e. when the method takes &self or &mut self). We just ignore\n         // the autoref currently -- when we find a method matching the given name,\n@@ -143,22 +141,21 @@ impl Ty {\n                 Some(krate) => krate,\n                 None => continue,\n             };\n-            let impls = db.impls_in_crate(krate)?;\n+            let impls = db.impls_in_crate(krate);\n \n             for impl_block in impls.lookup_impl_blocks(db, &derefed_ty) {\n-                let impl_block = impl_block?;\n                 for item in impl_block.items() {\n                     match item {\n                         ImplItem::Method(f) => {\n-                            if let Some(result) = callback(f.clone())? {\n-                                return Ok(Some(result));\n+                            if let Some(result) = callback(f.clone()) {\n+                                return Some(result);\n                             }\n                         }\n                         _ => {}\n                     }\n                 }\n             }\n         }\n-        Ok(None)\n+        None\n     }\n }"}, {"sha": "929fee04ce3f48c372c9ff2867b6c8620ac02551", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "patch": "@@ -321,7 +321,7 @@ fn infer(content: &str) -> String {\n         .filter_map(ast::FnDef::cast)\n     {\n         let func = source_binder::function_from_source(&db, file_id, fn_def).unwrap();\n-        let inference_result = func.infer(&db).unwrap();\n+        let inference_result = func.infer(&db);\n         let body_syntax_mapping = func.body_syntax_mapping(&db);\n         let mut types = Vec::new();\n         for (pat, ty) in inference_result.type_of_pat.iter() {\n@@ -405,7 +405,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     let func = source_binder::function_from_position(&db, pos).unwrap();\n     {\n         let events = db.log_executed(|| {\n-            func.infer(&db).unwrap();\n+            func.infer(&db);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"infer\"))\n     }\n@@ -424,7 +424,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n \n     {\n         let events = db.log_executed(|| {\n-            func.infer(&db).unwrap();\n+            func.infer(&db);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }"}, {"sha": "31a2478d13f2b1c90d13e8b2ffd09cbc43de1be3", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "patch": "@@ -9,7 +9,7 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Ca\n         (Some(function), Some(receiver)) => (function, receiver),\n         _ => return Ok(()),\n     };\n-    let infer_result = function.infer(ctx.db)?;\n+    let infer_result = function.infer(ctx.db);\n     let syntax_mapping = function.body_syntax_mapping(ctx.db);\n     let expr = match syntax_mapping.node_expr(receiver) {\n         Some(expr) => expr,\n@@ -19,7 +19,7 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Ca\n     if !ctx.is_call {\n         complete_fields(acc, ctx, receiver_ty.clone());\n     }\n-    complete_methods(acc, ctx, receiver_ty)?;\n+    complete_methods(acc, ctx, receiver_ty);\n     Ok(())\n }\n \n@@ -55,11 +55,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n     }\n }\n \n-fn complete_methods(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext,\n-    receiver: Ty,\n-) -> Cancelable<()> {\n+fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     receiver.iterate_methods(ctx.db, |func| {\n         let sig = func.signature(ctx.db);\n         if sig.has_self_param() {\n@@ -68,9 +64,8 @@ fn complete_methods(\n                 .kind(CompletionItemKind::Method)\n                 .add_to(acc);\n         }\n-        Ok(None::<()>)\n-    })?;\n-    Ok(())\n+        None::<()>\n+    });\n }\n \n #[cfg(test)]"}, {"sha": "e0f3deb0b87af2c1f0b0d63288d26157a23bf21e", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "patch": "@@ -63,7 +63,7 @@ pub(crate) fn reference_definition(\n             .parent()\n             .and_then(ast::MethodCallExpr::cast)\n         {\n-            let infer_result = function.infer(db)?;\n+            let infer_result = function.infer(db);\n             let syntax_mapping = function.body_syntax_mapping(db);\n             let expr = ast::Expr::cast(method_call.syntax()).unwrap();\n             if let Some(def_id) = syntax_mapping"}, {"sha": "6b5887bda1e2a3e2613d7464c94785f5341c5c45", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=8ba9c2d4cedbcf8f1d2c644733d2b06fa1984d22", "patch": "@@ -73,7 +73,7 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Cancelable<Option\n         frange.file_id,\n         parent_fn\n     ));\n-    let infer = function.infer(db)?;\n+    let infer = function.infer(db);\n     let syntax_mapping = function.body_syntax_mapping(db);\n     if let Some(expr) = ast::Expr::cast(node).and_then(|e| syntax_mapping.node_expr(e)) {\n         Ok(Some(infer[expr].to_string()))"}]}