{"sha": "a2112fcb0ad7327b9f1ee618c18567d74fc084b1", "node_id": "C_kwDOAAsO6NoAKGEyMTEyZmNiMGFkNzMyN2I5ZjFlZTYxOGMxODU2N2Q3NGZjMDg0YjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-07T13:24:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-07T13:24:12Z"}, "message": "Auto merge of #106519 - estebank:tail-unit, r=cjgillot\n\nDetect bindings assigned blocks without tail expressions\n\nFix #44173.", "tree": {"sha": "3379dc2fd7e553f05fc1ff62935c40523c9e4a12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3379dc2fd7e553f05fc1ff62935c40523c9e4a12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2112fcb0ad7327b9f1ee618c18567d74fc084b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2112fcb0ad7327b9f1ee618c18567d74fc084b1", "html_url": "https://github.com/rust-lang/rust/commit/a2112fcb0ad7327b9f1ee618c18567d74fc084b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d72b7d2d2a64f5f77b919a1428873b4d4149f60d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d72b7d2d2a64f5f77b919a1428873b4d4149f60d", "html_url": "https://github.com/rust-lang/rust/commit/d72b7d2d2a64f5f77b919a1428873b4d4149f60d"}, {"sha": "031e0854509759ccf7dbc697bfd5d958adac83f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/031e0854509759ccf7dbc697bfd5d958adac83f7", "html_url": "https://github.com/rust-lang/rust/commit/031e0854509759ccf7dbc697bfd5d958adac83f7"}], "stats": {"total": 308, "additions": 285, "deletions": 23}, "files": [{"sha": "b6f19d3cc684ae1d84fc97b0c1f3fd390af54975", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=a2112fcb0ad7327b9f1ee618c18567d74fc084b1", "patch": "@@ -224,14 +224,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut ret_span: MultiSpan = semi_span.into();\n         ret_span.push_span_label(\n             expr.span,\n-            \"this could be implicitly returned but it is a statement, not a \\\n-                            tail expression\",\n+            \"this could be implicitly returned but it is a statement, not a tail expression\",\n         );\n         ret_span.push_span_label(ret, \"the `match` arms can conform to this return type\");\n         ret_span.push_span_label(\n             semi_span,\n-            \"the `match` is a statement because of this semicolon, consider \\\n-                            removing it\",\n+            \"the `match` is a statement because of this semicolon, consider removing it\",\n         );\n         diag.span_note(ret_span, \"you might have meant to return the `match` expression\");\n         diag.tool_only_span_suggestion("}, {"sha": "0f191c21a0a63e483618da407f8696eff96c3944", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=a2112fcb0ad7327b9f1ee618c18567d74fc084b1", "patch": "@@ -83,6 +83,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n         self.check_for_range_as_method_call(err, expr, expr_ty, expected);\n+        self.check_for_binding_assigned_block_without_tail_expression(err, expr, expr_ty, expected);\n     }\n \n     /// Requires that the two types unify, and prints an error message if\n@@ -1887,4 +1888,48 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Applicability::MachineApplicable,\n         );\n     }\n+\n+    /// Identify when the type error is because `()` is found in a binding that was assigned a\n+    /// block without a tail expression.\n+    fn check_for_binding_assigned_block_without_tail_expression(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        checked_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) {\n+        if !checked_ty.is_unit() {\n+            return;\n+        }\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind else { return; };\n+        let hir::def::Res::Local(hir_id) = path.res else { return; };\n+        let Some(hir::Node::Pat(pat)) = self.tcx.hir().find(hir_id) else {\n+            return;\n+        };\n+        let Some(hir::Node::Local(hir::Local {\n+            ty: None,\n+            init: Some(init),\n+            ..\n+        })) = self.tcx.hir().find_parent(pat.hir_id) else { return; };\n+        let hir::ExprKind::Block(block, None) = init.kind else { return; };\n+        if block.expr.is_some() {\n+            return;\n+        }\n+        let [.., stmt] = block.stmts else {\n+            err.span_label(block.span, \"this empty block is missing a tail expression\");\n+            return;\n+        };\n+        let hir::StmtKind::Semi(tail_expr) = stmt.kind else { return; };\n+        let Some(ty) = self.node_ty_opt(tail_expr.hir_id) else { return; };\n+        if self.can_eq(self.param_env, expected_ty, ty).is_ok() {\n+            err.span_suggestion_short(\n+                stmt.span.with_lo(tail_expr.span.hi()),\n+                \"remove this semicolon\",\n+                \"\",\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            err.span_label(block.span, \"this block is missing a tail expression\");\n+        }\n+    }\n }"}, {"sha": "17331a50105523c3a4712b51c09b2f3f1a8a7b76", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a2112fcb0ad7327b9f1ee618c18567d74fc084b1", "patch": "@@ -771,7 +771,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 ),\n                             }\n                         };\n-\n+                        self.check_for_binding_assigned_block_without_tail_expression(\n+                            &obligation,\n+                            &mut err,\n+                            trait_predicate,\n+                        );\n                         if self.suggest_add_reference_to_arg(\n                             &obligation,\n                             &mut err,\n@@ -2266,23 +2270,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if let (Some(body_id), Some(ty::subst::GenericArgKind::Type(_))) =\n                     (body_id, subst.map(|subst| subst.unpack()))\n                 {\n-                    struct FindExprBySpan<'hir> {\n-                        span: Span,\n-                        result: Option<&'hir hir::Expr<'hir>>,\n-                    }\n-\n-                    impl<'v> hir::intravisit::Visitor<'v> for FindExprBySpan<'v> {\n-                        fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n-                            if self.span == ex.span {\n-                                self.result = Some(ex);\n-                            } else {\n-                                hir::intravisit::walk_expr(self, ex);\n-                            }\n-                        }\n-                    }\n-\n-                    let mut expr_finder = FindExprBySpan { span, result: None };\n-\n+                    let mut expr_finder = FindExprBySpan::new(span);\n                     expr_finder.visit_expr(&self.tcx.hir().body(body_id).value);\n \n                     if let Some(hir::Expr {\n@@ -2769,6 +2757,36 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     }\n }\n \n+/// Crude way of getting back an `Expr` from a `Span`.\n+pub struct FindExprBySpan<'hir> {\n+    pub span: Span,\n+    pub result: Option<&'hir hir::Expr<'hir>>,\n+    pub ty_result: Option<&'hir hir::Ty<'hir>>,\n+}\n+\n+impl<'hir> FindExprBySpan<'hir> {\n+    fn new(span: Span) -> Self {\n+        Self { span, result: None, ty_result: None }\n+    }\n+}\n+\n+impl<'v> Visitor<'v> for FindExprBySpan<'v> {\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        if self.span == ex.span {\n+            self.result = Some(ex);\n+        } else {\n+            hir::intravisit::walk_expr(self, ex);\n+        }\n+    }\n+    fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n+        if self.span == ty.span {\n+            self.ty_result = Some(ty);\n+        } else {\n+            hir::intravisit::walk_ty(self, ty);\n+        }\n+    }\n+}\n+\n /// Look for type `param` in an ADT being used only through a reference to confirm that suggesting\n /// `param: ?Sized` would be a valid constraint.\n struct FindTypeParam {"}, {"sha": "28f76b141469d53351069991cc60665db3c07ccf", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a2112fcb0ad7327b9f1ee618c18567d74fc084b1", "patch": "@@ -1,6 +1,9 @@\n // ignore-tidy-filelength\n \n-use super::{DefIdOrName, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation};\n+use super::{\n+    DefIdOrName, FindExprBySpan, Obligation, ObligationCause, ObligationCauseCode,\n+    PredicateObligation,\n+};\n \n use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n@@ -196,6 +199,13 @@ pub trait TypeErrCtxtExt<'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n \n+    fn check_for_binding_assigned_block_without_tail_expression(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut Diagnostic,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n+    );\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1032,6 +1042,66 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         true\n     }\n \n+    fn check_for_binding_assigned_block_without_tail_expression(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut Diagnostic,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n+    ) {\n+        let mut span = obligation.cause.span;\n+        while span.from_expansion() {\n+            // Remove all the desugaring and macro contexts.\n+            span.remove_mark();\n+        }\n+        let mut expr_finder = FindExprBySpan::new(span);\n+        let Some(hir::Node::Expr(body)) = self.tcx.hir().find(obligation.cause.body_id) else { return; };\n+        expr_finder.visit_expr(&body);\n+        let Some(expr) = expr_finder.result else { return; };\n+        let Some(typeck) = &self.typeck_results else { return; };\n+        let Some(ty) = typeck.expr_ty_adjusted_opt(expr) else { return; };\n+        if !ty.is_unit() {\n+            return;\n+        };\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind else { return; };\n+        let hir::def::Res::Local(hir_id) = path.res else { return; };\n+        let Some(hir::Node::Pat(pat)) = self.tcx.hir().find(hir_id) else {\n+            return;\n+        };\n+        let Some(hir::Node::Local(hir::Local {\n+            ty: None,\n+            init: Some(init),\n+            ..\n+        })) = self.tcx.hir().find_parent(pat.hir_id) else { return; };\n+        let hir::ExprKind::Block(block, None) = init.kind else { return; };\n+        if block.expr.is_some() {\n+            return;\n+        }\n+        let [.., stmt] = block.stmts else {\n+            err.span_label(block.span, \"this empty block is missing a tail expression\");\n+            return;\n+        };\n+        let hir::StmtKind::Semi(tail_expr) = stmt.kind else { return; };\n+        let Some(ty) = typeck.expr_ty_opt(tail_expr) else {\n+            err.span_label(block.span, \"this block is missing a tail expression\");\n+            return;\n+        };\n+        let ty = self.resolve_numeric_literals_with_default(self.resolve_vars_if_possible(ty));\n+        let trait_pred_and_self = trait_pred.map_bound(|trait_pred| (trait_pred, ty));\n+\n+        let new_obligation =\n+            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred_and_self);\n+        if self.predicate_must_hold_modulo_regions(&new_obligation) {\n+            err.span_suggestion_short(\n+                stmt.span.with_lo(tail_expr.span.hi()),\n+                \"remove this semicolon\",\n+                \"\",\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            err.span_label(block.span, \"this block is missing a tail expression\");\n+        }\n+    }\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,"}, {"sha": "09afd27a079ba6111003e9181a9c949950e41018", "filename": "src/test/ui/type/binding-assigned-block-without-tail-expression.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.rs?ref=a2112fcb0ad7327b9f1ee618c18567d74fc084b1", "patch": "@@ -0,0 +1,22 @@\n+struct S;\n+fn main() {\n+    let x = {\n+        println!(\"foo\");\n+        42;\n+    };\n+    let y = {};\n+    let z = {\n+        \"hi\";\n+    };\n+    let s = {\n+        S;\n+    };\n+    println!(\"{}\", x); //~ ERROR E0277\n+    println!(\"{}\", y); //~ ERROR E0277\n+    println!(\"{}\", z); //~ ERROR E0277\n+    println!(\"{}\", s); //~ ERROR E0277\n+    let _: i32 = x; //~ ERROR E0308\n+    let _: i32 = y; //~ ERROR E0308\n+    let _: i32 = z; //~ ERROR E0308\n+    let _: i32 = s; //~ ERROR E0308\n+}"}, {"sha": "3e96d7f317b4a05f44a169abb6785bd74620effc", "filename": "src/test/ui/type/binding-assigned-block-without-tail-expression.stderr", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2112fcb0ad7327b9f1ee618c18567d74fc084b1/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.stderr?ref=a2112fcb0ad7327b9f1ee618c18567d74fc084b1", "patch": "@@ -0,0 +1,109 @@\n+error[E0277]: `()` doesn't implement `std::fmt::Display`\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:14:20\n+   |\n+LL |         42;\n+   |           - help: remove this semicolon\n+...\n+LL |     println!(\"{}\", x);\n+   |                    ^ `()` cannot be formatted with the default formatter\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `()`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: `()` doesn't implement `std::fmt::Display`\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:15:20\n+   |\n+LL |     let y = {};\n+   |             -- this empty block is missing a tail expression\n+...\n+LL |     println!(\"{}\", y);\n+   |                    ^ `()` cannot be formatted with the default formatter\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `()`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: `()` doesn't implement `std::fmt::Display`\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:16:20\n+   |\n+LL |         \"hi\";\n+   |             - help: remove this semicolon\n+...\n+LL |     println!(\"{}\", z);\n+   |                    ^ `()` cannot be formatted with the default formatter\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `()`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: `()` doesn't implement `std::fmt::Display`\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:17:20\n+   |\n+LL |       let s = {\n+   |  _____________-\n+LL | |         S;\n+LL | |     };\n+   | |_____- this block is missing a tail expression\n+...\n+LL |       println!(\"{}\", s);\n+   |                      ^ `()` cannot be formatted with the default formatter\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `()`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0308]: mismatched types\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:18:18\n+   |\n+LL |         42;\n+   |           - help: remove this semicolon\n+...\n+LL |     let _: i32 = x;\n+   |            ---   ^ expected `i32`, found `()`\n+   |            |\n+   |            expected due to this\n+\n+error[E0308]: mismatched types\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:19:18\n+   |\n+LL |     let y = {};\n+   |             -- this empty block is missing a tail expression\n+...\n+LL |     let _: i32 = y;\n+   |            ---   ^ expected `i32`, found `()`\n+   |            |\n+   |            expected due to this\n+\n+error[E0308]: mismatched types\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:20:18\n+   |\n+LL |       let z = {\n+   |  _____________-\n+LL | |         \"hi\";\n+LL | |     };\n+   | |_____- this block is missing a tail expression\n+...\n+LL |       let _: i32 = z;\n+   |              ---   ^ expected `i32`, found `()`\n+   |              |\n+   |              expected due to this\n+\n+error[E0308]: mismatched types\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:21:18\n+   |\n+LL |       let s = {\n+   |  _____________-\n+LL | |         S;\n+LL | |     };\n+   | |_____- this block is missing a tail expression\n+...\n+LL |       let _: i32 = s;\n+   |              ---   ^ expected `i32`, found `()`\n+   |              |\n+   |              expected due to this\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308.\n+For more information about an error, try `rustc --explain E0277`."}]}