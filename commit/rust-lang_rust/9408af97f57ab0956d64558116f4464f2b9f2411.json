{"sha": "9408af97f57ab0956d64558116f4464f2b9f2411", "node_id": "C_kwDOAAsO6NoAKDk0MDhhZjk3ZjU3YWIwOTU2ZDY0NTU4MTE2ZjQ0NjRmMmI5ZjI0MTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-08T20:26:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-08T20:26:50Z"}, "message": "Rollup merge of #108754 - compiler-errors:retry, r=oli-obk\n\nRetry `pred_known_to_hold_modulo_regions` with fulfillment if ambiguous\n\nFixes #108721\n\nThe problem here is that when we're checking `is_sized_raw` during codegen on some type that has a lot of opaques in it, something emits several nested obligations that are individually ambiguous, but when processed together in a loop then apply modulo regions. Since the `evaluate_predicates_recursively` inner loop doesn't process predicates until they stop changing, we return `EvaluatedToAmbig`, which makes the sized check return false incorrectly. See:\n\nhttps://github.com/rust-lang/rust/blob/f15f0ea73972786e426732c5b92ba9a904b866c4/compiler/rustc_trait_selection/src/traits/select/mod.rs#L596-L606\n\n... Compared to the analogous loop in the new solver:\n\nhttps://github.com/rust-lang/rust/blob/f15f0ea73972786e426732c5b92ba9a904b866c4/compiler/rustc_trait_selection/src/solve/mod.rs#L481-L512\n\nTo fix this, if we get ambiguous during `pred_known_to_hold_modulo_regions`, just retry the obligation in a fulfillment context.\n\n--\n\nUnfortunately... I don't have a test for this. I've only tested this locally. Pending minimization :/\n\nr? types", "tree": {"sha": "376dc545848da07b7f479ef62a9025fc79724386", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/376dc545848da07b7f479ef62a9025fc79724386"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9408af97f57ab0956d64558116f4464f2b9f2411", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkCO+KCRBK7hj4Ov3rIwAARw8IAAZWb6mx/8tJ2VuXOAtHr1fE\nXv5dQz4Hcm/NG9lamUa6jLP5nU0XWWJI5jPE6xqplv36sK0ImxdgEJXW93r7acfd\nAZKWP17AP8oKk7CVKawfifTJiIy/csOwsgaKi0d5SXpZEVKof54FU3HmoSjGO8Ng\nuEVw92Cae1ellXkrwyAn9vtRm9npbCvODV5KvkgtOiEQlGm30vINvhoqWo0SRMwQ\nUnmImHmcKs0b9pULwy1yXpoXh6lL4G0ak7PTNRQn/GW9sip8l8fY7cS+A0L6UFbj\nA6G1++CZcSdWa1ulphsF0f2F+TdLAG6QoC3FiSnKiXHCQmQ2ruPkM/LxAfvBvz4=\n=jcDe\n-----END PGP SIGNATURE-----\n", "payload": "tree 376dc545848da07b7f479ef62a9025fc79724386\nparent 7c306f6dcd600b1fcc74439c780e8ebef338d84c\nparent 118afdf071ce38f91c054f013c1774926fa28b15\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678307210 +0100\ncommitter GitHub <noreply@github.com> 1678307210 +0100\n\nRollup merge of #108754 - compiler-errors:retry, r=oli-obk\n\nRetry `pred_known_to_hold_modulo_regions` with fulfillment if ambiguous\n\nFixes #108721\n\nThe problem here is that when we're checking `is_sized_raw` during codegen on some type that has a lot of opaques in it, something emits several nested obligations that are individually ambiguous, but when processed together in a loop then apply modulo regions. Since the `evaluate_predicates_recursively` inner loop doesn't process predicates until they stop changing, we return `EvaluatedToAmbig`, which makes the sized check return false incorrectly. See:\n\nhttps://github.com/rust-lang/rust/blob/f15f0ea73972786e426732c5b92ba9a904b866c4/compiler/rustc_trait_selection/src/traits/select/mod.rs#L596-L606\n\n... Compared to the analogous loop in the new solver:\n\nhttps://github.com/rust-lang/rust/blob/f15f0ea73972786e426732c5b92ba9a904b866c4/compiler/rustc_trait_selection/src/solve/mod.rs#L481-L512\n\nTo fix this, if we get ambiguous during `pred_known_to_hold_modulo_regions`, just retry the obligation in a fulfillment context.\n\n--\n\nUnfortunately... I don't have a test for this. I've only tested this locally. Pending minimization :/\n\nr? types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9408af97f57ab0956d64558116f4464f2b9f2411", "html_url": "https://github.com/rust-lang/rust/commit/9408af97f57ab0956d64558116f4464f2b9f2411", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9408af97f57ab0956d64558116f4464f2b9f2411/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c306f6dcd600b1fcc74439c780e8ebef338d84c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c306f6dcd600b1fcc74439c780e8ebef338d84c", "html_url": "https://github.com/rust-lang/rust/commit/7c306f6dcd600b1fcc74439c780e8ebef338d84c"}, {"sha": "118afdf071ce38f91c054f013c1774926fa28b15", "url": "https://api.github.com/repos/rust-lang/rust/commits/118afdf071ce38f91c054f013c1774926fa28b15", "html_url": "https://github.com/rust-lang/rust/commit/118afdf071ce38f91c054f013c1774926fa28b15"}], "stats": {"total": 8, "additions": 5, "deletions": 3}, "files": [{"sha": "62bad5b49b4607090469034824897562a948f9bd", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9408af97f57ab0956d64558116f4464f2b9f2411/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9408af97f57ab0956d64558116f4464f2b9f2411/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=9408af97f57ab0956d64558116f4464f2b9f2411", "patch": "@@ -155,10 +155,12 @@ fn pred_known_to_hold_modulo_regions<'tcx>(\n         predicate: pred.to_predicate(infcx.tcx),\n     };\n \n-    let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n+    let result = infcx.evaluate_obligation_no_overflow(&obligation);\n     debug!(?result);\n \n-    if result && has_non_region_infer {\n+    if result.must_apply_modulo_regions() && !has_non_region_infer {\n+        true\n+    } else if result.may_apply() {\n         // Because of inference \"guessing\", selection can sometimes claim\n         // to succeed while the success requires a guess. To ensure\n         // this function's result remains infallible, we must confirm\n@@ -179,7 +181,7 @@ fn pred_known_to_hold_modulo_regions<'tcx>(\n             }\n         }\n     } else {\n-        result\n+        false\n     }\n }\n "}]}