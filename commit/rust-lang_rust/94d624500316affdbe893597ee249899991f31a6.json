{"sha": "94d624500316affdbe893597ee249899991f31a6", "node_id": "C_kwDOAAsO6NoAKDk0ZDYyNDUwMDMxNmFmZmRiZTg5MzU5N2VlMjQ5ODk5OTkxZjMxYTY", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-12-22T20:37:21Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-12-22T21:04:40Z"}, "message": "Fix `explicit_outlives_requirements` lint in macros\n\nShow the suggestion if and only if the bounds are from the same source context.", "tree": {"sha": "354acdcc4ed75bc082fe47dcaefeca17f731a489", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/354acdcc4ed75bc082fe47dcaefeca17f731a489"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94d624500316affdbe893597ee249899991f31a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94d624500316affdbe893597ee249899991f31a6", "html_url": "https://github.com/rust-lang/rust/commit/94d624500316affdbe893597ee249899991f31a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94d624500316affdbe893597ee249899991f31a6/comments", "author": null, "committer": null, "parents": [{"sha": "2d8651a92761421b0437ffb44ba5670bea5ee1df", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8651a92761421b0437ffb44ba5670bea5ee1df", "html_url": "https://github.com/rust-lang/rust/commit/2d8651a92761421b0437ffb44ba5670bea5ee1df"}], "stats": {"total": 136, "additions": 98, "deletions": 38}, "files": [{"sha": "bda914d288879c83c12a657dc9abf9fc84d43da5", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/94d624500316affdbe893597ee249899991f31a6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d624500316affdbe893597ee249899991f31a6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=94d624500316affdbe893597ee249899991f31a6", "patch": "@@ -1377,21 +1377,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let ident = self.lower_ident(ident);\n         let param_span = ident.span;\n-        let span = bounds\n-            .iter()\n-            .fold(Some(param_span.shrink_to_hi()), |span: Option<Span>, bound| {\n-                let bound_span = bound.span();\n-                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n-                // as we use this method to get a span appropriate for suggestions.\n-                if !bound_span.can_be_used_for_suggestions() {\n-                    None\n-                } else if let Some(span) = span {\n-                    Some(span.to(bound_span))\n-                } else {\n-                    Some(bound_span)\n-                }\n-            })\n-            .unwrap_or(param_span.shrink_to_hi());\n+        let span =\n+            bounds.iter().fold(param_span.shrink_to_hi(), |span, bound| span.to(bound.span()));\n         match kind {\n             GenericParamKind::Const { .. } => None,\n             GenericParamKind::Type { .. } => {"}, {"sha": "3fc86545ed4c04530dba3e853e43933f8c4958f7", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/94d624500316affdbe893597ee249899991f31a6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d624500316affdbe893597ee249899991f31a6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=94d624500316affdbe893597ee249899991f31a6", "patch": "@@ -55,7 +55,7 @@ use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, InnerSpan, Span};\n+use rustc_span::{BytePos, InnerSpan, Span, SyntaxContext};\n use rustc_target::abi::{Abi, VariantIdx};\n use rustc_trait_selection::infer::{InferCtxtExt, TyCtxtInferExt};\n use rustc_trait_selection::traits::{self, misc::can_type_implement_copy, EvaluationResult};\n@@ -2184,30 +2184,36 @@ impl ExplicitOutlivesRequirements {\n         tcx: TyCtxt<'tcx>,\n         bounds: &hir::GenericBounds<'_>,\n         inferred_outlives: &[ty::Region<'tcx>],\n+        span_cx: SyntaxContext,\n     ) -> Vec<(usize, Span)> {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         bounds\n             .iter()\n             .enumerate()\n             .filter_map(|(i, bound)| {\n-                if let hir::GenericBound::Outlives(lifetime) = bound {\n-                    let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                        Some(Region::EarlyBound(def_id)) => inferred_outlives.iter().any(|r| {\n-                            if let ty::ReEarlyBound(ebr) = **r {\n-                                ebr.def_id == def_id\n-                            } else {\n-                                false\n-                            }\n-                        }),\n-                        _ => false,\n-                    };\n-                    is_inferred.then_some((i, bound.span()))\n-                } else {\n-                    None\n+                let hir::GenericBound::Outlives(lifetime) = bound else {\n+                    return None;\n+                };\n+\n+                let is_inferred = match tcx.named_region(lifetime.hir_id) {\n+                    Some(Region::EarlyBound(def_id)) => inferred_outlives\n+                        .iter()\n+                        .any(|r| matches!(**r, ty::ReEarlyBound(ebr) if { ebr.def_id == def_id })),\n+                    _ => false,\n+                };\n+\n+                if !is_inferred {\n+                    return None;\n+                }\n+\n+                let span = bound.span();\n+                if span.ctxt() != span_cx || in_external_macro(tcx.sess, span) {\n+                    return None;\n                 }\n+\n+                Some((i, span))\n             })\n-            .filter(|(_, span)| !in_external_macro(tcx.sess, *span))\n             .collect()\n     }\n \n@@ -2312,9 +2318,9 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                         // FIXME we can also infer bounds on associated types,\n                         // and should check for them here.\n                         match predicate.bounded_ty.kind {\n-                            hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n+                            hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n                                 let Res::Def(DefKind::TyParam, def_id) = path.res else {\n-                                    continue\n+                                    continue;\n                                 };\n                                 let index = ty_generics.param_def_id_to_index[&def_id];\n                                 (\n@@ -2335,8 +2341,12 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     continue;\n                 }\n \n-                let bound_spans =\n-                    self.collect_outlives_bound_spans(cx.tcx, bounds, &relevant_lifetimes);\n+                let bound_spans = self.collect_outlives_bound_spans(\n+                    cx.tcx,\n+                    bounds,\n+                    &relevant_lifetimes,\n+                    span.ctxt(),\n+                );\n                 bound_count += bound_spans.len();\n \n                 let drop_predicate = bound_spans.len() == bounds.len();"}, {"sha": "d96def8173a092abd7eec0fc0c8c07e2f2aeb835", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/94d624500316affdbe893597ee249899991f31a6/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94d624500316affdbe893597ee249899991f31a6/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs?ref=94d624500316affdbe893597ee249899991f31a6", "patch": "@@ -15,7 +15,11 @@ macro_rules! make_foo {\n         struct Foo<$a, 'b> where 'b: $a {\n             foo: &$a &'b (),\n         }\n-    }\n+\n+        struct Foo2<$a, 'b: $a> {\n+            foo: &$a &'b (),\n+        }\n+    };\n }\n \n gimme_a! {make_foo!}\n@@ -25,4 +29,41 @@ struct Bar<'a, 'b: 'a> {\n     bar: &'a &'b (),\n }\n \n+macro_rules! make_quux {\n+    () => {\n+        struct Quux<'a, 'b> where 'b: 'a {\n+            //~^ ERROR: outlives requirements can be inferred\n+            baz: &'a &'b (),\n+        }\n+\n+        struct Quux2<'a, 'b: 'a> {\n+            //~^ ERROR: outlives requirements can be inferred\n+            baz: &'a &'b (),\n+        }\n+    };\n+}\n+\n+make_quux!{}\n+\n+macro_rules! make_baz {\n+    () => {\n+        make_baz!{ 'a }\n+    };\n+    ($a:lifetime) => {\n+        struct Baz<$a, 'b> where 'b: $a {\n+            baz: &$a &'b (),\n+        }\n+\n+        struct Baz2<$a, 'b: $a> {\n+            baz: &$a &'b (),\n+        }\n+    };\n+}\n+\n+make_baz!{ 'a }\n+\n+mod baz {\n+    make_baz!{}\n+}\n+\n fn main() {}"}, {"sha": "0dd4985244d1a0316a21c01e0d70cee4b8869887", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.stderr", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/94d624500316affdbe893597ee249899991f31a6/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94d624500316affdbe893597ee249899991f31a6/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr?ref=94d624500316affdbe893597ee249899991f31a6", "patch": "@@ -1,5 +1,5 @@\n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-macro.rs:23:18\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:27:18\n    |\n LL | struct Bar<'a, 'b: 'a> {\n    |                  ^^^^ help: remove this bound\n@@ -10,5 +10,27 @@ note: the lint level is defined here\n LL | #![deny(explicit_outlives_requirements)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:34:28\n+   |\n+LL |         struct Quux<'a, 'b> where 'b: 'a {\n+   |                            ^^^^^^^^^^^^^ help: remove this bound\n+...\n+LL | make_quux!{}\n+   | ------------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `make_quux` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:39:28\n+   |\n+LL |         struct Quux2<'a, 'b: 'a> {\n+   |                            ^^^^ help: remove this bound\n+...\n+LL | make_quux!{}\n+   | ------------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `make_quux` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n "}]}