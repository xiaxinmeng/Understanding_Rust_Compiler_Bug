{"sha": "5b2e8693e42dee545d336c0364773b3fbded93a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMmU4NjkzZTQyZGVlNTQ1ZDMzNmMwMzY0NzczYjNmYmRlZDkzYTU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-21T12:12:08Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-24T21:27:23Z"}, "message": "Reject specialized Drop impls.\n\nSee Issue 8142 for discussion.\n\nThis makes it illegal for a Drop impl to be more specialized than the\noriginal item.\n\nSo for example, all of the following are now rejected (when they would\nhave been blindly accepted before):\n\n```rust\nstruct S<A> { ... };\nimpl Drop for S<i8> { ... } // error: specialized to concrete type\n\nstruct T<'a> { ... };\nimpl Drop for T<'static> { ... } // error: specialized to concrete region\n\nstruct U<A> { ... };\nimpl<A:Clone> Drop for U<A> { ... } // error: added extra type requirement\n\nstruct V<'a,'b>;\nimpl<'a,'b:a> Drop for V<'a,'b> { ... } // error: added extra region requirement\n```\n\nDue to examples like the above, this is a [breaking-change].\n\n(The fix is to either remove the specialization from the `Drop` impl,\nor to transcribe the requirements into the struct/enum definition;\nexamples of both are shown in the PR's fixed to `libstd`.)\n\n----\n\nThis is likely to be the last thing blocking the removal of the\n`#[unsafe_destructor]` attribute.\n\nIncludes two new error codes for the new dropck check.\n\nUpdate run-pass tests to accommodate new dropck pass.\n\nUpdate tests and docs to reflect new destructor restriction.\n\n----\n\nImplementation notes:\n\nWe identify Drop impl specialization by not being as parametric as the\nstruct/enum definition via unification.\n\nMore specifically:\n\n 1. Attempt unification of a skolemized instance of the struct/enum\n    with an instance of the Drop impl's type expression where all of\n    the impl's generics (i.e. the free variables of the type\n    expression) have been replaced with unification variables.\n\n 2. If unification fails, then reject Drop impl as specialized.\n\n 3. If unification succeeds, check if any of the skolemized\n    variables \"leaked\" into the constraint set for the inference\n    context; if so, then reject Drop impl as specialized.\n\n 4. Otherwise, unification succeeded without leaking skolemized\n    variables: accept the Drop impl.\n\nWe identify whether a Drop impl is injecting new predicates by simply\nlooking whether the predicate, after an appropriate substitution,\nappears on the struct/enum definition.", "tree": {"sha": "7506fd891d4f5ec60bed07cccd7c3c6a33b1d927", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7506fd891d4f5ec60bed07cccd7c3c6a33b1d927"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b2e8693e42dee545d336c0364773b3fbded93a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2e8693e42dee545d336c0364773b3fbded93a5", "html_url": "https://github.com/rust-lang/rust/commit/5b2e8693e42dee545d336c0364773b3fbded93a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b2e8693e42dee545d336c0364773b3fbded93a5/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "290c8de0a6f233b1d30c8a97cb41614fce989d30", "url": "https://api.github.com/repos/rust-lang/rust/commits/290c8de0a6f233b1d30c8a97cb41614fce989d30", "html_url": "https://github.com/rust-lang/rust/commit/290c8de0a6f233b1d30c8a97cb41614fce989d30"}], "stats": {"total": 359, "additions": 341, "deletions": 18}, "files": [{"sha": "dbf0cae6f4ba84b852e771e978b94ae84bbb99c5", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -197,15 +197,16 @@ use std::ptr;\n \n // Define a wrapper around the handle returned by the foreign code.\n // Unique<T> has the same semantics as Box<T>\n-pub struct Unique<T> {\n+//\n+// NB: For simplicity and correctness, we require that T has kind Send\n+// (owned boxes relax this restriction).\n+pub struct Unique<T: Send> {\n     // It contains a single raw, mutable pointer to the object in question.\n     ptr: *mut T\n }\n \n // Implement methods for creating and using the values in the box.\n \n-// NB: For simplicity and correctness, we require that T has kind Send\n-// (owned boxes relax this restriction).\n impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n         unsafe {\n@@ -239,11 +240,11 @@ impl<T: Send> Unique<T> {\n // Unique<T>, making the struct manage the raw pointer: when the\n // struct goes out of scope, it will automatically free the raw pointer.\n //\n-// NB: This is an unsafe destructor, because rustc will not normally\n-// allow destructors to be associated with parameterized types, due to\n-// bad interaction with managed boxes. (With the Send restriction,\n-// we don't have this problem.) Note that the `#[unsafe_destructor]`\n-// feature gate is required to use unsafe destructors.\n+// NB: This is an unsafe destructor; rustc will not normally allow\n+// destructors to be associated with parameterized types (due to\n+// historically failing to check them soundly).  Note that the\n+// `#[unsafe_destructor]` feature gate is currently required to use\n+// unsafe destructors.\n #[unsafe_destructor]\n impl<T: Send> Drop for Unique<T> {\n     fn drop(&mut self) {"}, {"sha": "16b387330b9efea402867d39e78c64e76cbeefeb", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -14,6 +14,7 @@\n use super::{CombinedSnapshot, cres, InferCtxt, HigherRankedType, SkolemizationMap};\n use super::combine::{Combine, Combineable};\n \n+use middle::subst;\n use middle::ty::{self, Binder};\n use middle::ty_fold::{self, TypeFoldable};\n use syntax::codemap::Span;\n@@ -455,6 +456,63 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n     }\n }\n \n+/// Constructs and returns a substitution that, for a given type\n+/// scheme parameterized by `generics`, will replace every generic\n+/// parmeter in the type with a skolemized type/region (which one can\n+/// think of as a \"fresh constant\", except at the type/region level of\n+/// reasoning).\n+///\n+/// Since we currently represent bound/free type parameters in the\n+/// same way, this only has an effect on regions.\n+///\n+/// (Note that unlike a substitution from `ty::construct_free_substs`,\n+/// this inserts skolemized regions rather than free regions; this\n+/// allows one to use `fn leak_check` to catch attmepts to unify the\n+/// skolemized regions with e.g. the `'static` lifetime)\n+pub fn construct_skolemized_substs<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                            generics: &ty::Generics<'tcx>,\n+                                            snapshot: &CombinedSnapshot)\n+                                            -> (subst::Substs<'tcx>, SkolemizationMap)\n+{\n+    let mut map = FnvHashMap();\n+\n+    // map T => T\n+    let mut types = subst::VecPerParamSpace::empty();\n+    push_types_from_defs(infcx.tcx, &mut types, generics.types.as_slice());\n+\n+    // map early- or late-bound 'a => fresh 'a\n+    let mut regions = subst::VecPerParamSpace::empty();\n+    push_region_params(infcx, &mut map, &mut regions, generics.regions.as_slice(), snapshot);\n+\n+    let substs = subst::Substs { types: types,\n+                                 regions: subst::NonerasedRegions(regions) };\n+    return (substs, map);\n+\n+    fn push_region_params<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                   map: &mut SkolemizationMap,\n+                                   regions: &mut subst::VecPerParamSpace<ty::Region>,\n+                                   region_params: &[ty::RegionParameterDef],\n+                                   snapshot: &CombinedSnapshot)\n+    {\n+        for r in region_params {\n+            let br = r.to_bound_region();\n+            let skol_var = infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot);\n+            let sanity_check = map.insert(br, skol_var);\n+            assert!(sanity_check.is_none());\n+            regions.push(r.space, skol_var);\n+        }\n+    }\n+\n+    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  types: &mut subst::VecPerParamSpace<ty::Ty<'tcx>>,\n+                                  defs: &[ty::TypeParameterDef<'tcx>]) {\n+        for def in defs {\n+            let ty = ty::mk_param_from_def(tcx, def);\n+            types.push(def.space, ty);\n+        }\n+    }\n+}\n+\n pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                binder: &ty::Binder<T>,\n                                                snapshot: &CombinedSnapshot)"}, {"sha": "a38adabee915b318b0abe2fcc50fb341743ef0d8", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -726,6 +726,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n+    pub fn construct_skolemized_subst(&self,\n+                                      generics: &ty::Generics<'tcx>,\n+                                      snapshot: &CombinedSnapshot)\n+                                      -> (subst::Substs<'tcx>, SkolemizationMap) {\n+        /*! See `higher_ranked::construct_skolemized_subst` */\n+\n+        higher_ranked::construct_skolemized_substs(self, generics, snapshot)\n+    }\n+\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            value: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)"}, {"sha": "71c4962d526e3ce02b1712733b30b94b597aac46", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -1793,6 +1793,9 @@ impl RegionParameterDef {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(self.def_id.node, self.space, self.index, self.name)\n     }\n+    pub fn to_bound_region(&self) -> ty::BoundRegion {\n+        ty::BoundRegion::BrNamed(self.def_id, self.name)\n+    }\n }\n \n /// Information about the formal type/lifetime parameters associated"}, {"sha": "c48033cab897f612c1a371d365340655c634dcda", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 238, "deletions": 2, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -12,13 +12,249 @@ use check::regionck::{self, Rcx};\n \n use middle::infer;\n use middle::region;\n-use middle::subst;\n+use middle::subst::{self, Subst};\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr, UserString};\n \n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::codemap::{self, Span};\n+\n+/// check_drop_impl confirms that the Drop implementation identfied by\n+/// `drop_impl_did` is not any more specialized than the type it is\n+/// attached to (Issue #8142).\n+///\n+/// This means:\n+///\n+/// 1. The self type must be nominal (this is already checked during\n+///    coherence),\n+///\n+/// 2. The generic region/type parameters of the impl's self-type must\n+///    all be parameters of the Drop impl itself (i.e. no\n+///    specialization like `impl Drop for Foo<i32>`), and,\n+///\n+/// 3. Any bounds on the generic parameters must be reflected in the\n+///    struct/enum definition for the nominal type itself (i.e.\n+///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n+///\n+pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(), ()> {\n+    let ty::TypeScheme { generics: ref dtor_generics,\n+                         ty: ref dtor_self_type } = ty::lookup_item_type(tcx, drop_impl_did);\n+    let dtor_predicates = ty::lookup_predicates(tcx, drop_impl_did);\n+    match dtor_self_type.sty {\n+        ty::ty_enum(self_type_did, self_to_impl_substs) |\n+        ty::ty_struct(self_type_did, self_to_impl_substs) |\n+        ty::ty_closure(self_type_did, self_to_impl_substs) => {\n+            try!(ensure_drop_params_and_item_params_correspond(tcx,\n+                                                               drop_impl_did,\n+                                                               dtor_generics,\n+                                                               dtor_self_type,\n+                                                               self_type_did));\n+\n+            ensure_drop_predicates_are_implied_by_item_defn(tcx,\n+                                                            drop_impl_did,\n+                                                            &dtor_predicates,\n+                                                            self_type_did,\n+                                                            self_to_impl_substs)\n+        }\n+        _ => {\n+            // Destructors only work on nominal types.  This was\n+            // already checked by coherence, so we can panic here.\n+            let span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+            tcx.sess.span_bug(\n+                span, &format!(\"should have been rejected by coherence check: {}\",\n+                               dtor_self_type.repr(tcx)));\n+        }\n+    }\n+}\n+\n+fn ensure_drop_params_and_item_params_correspond<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    drop_impl_did: ast::DefId,\n+    drop_impl_generics: &ty::Generics<'tcx>,\n+    drop_impl_ty: &ty::Ty<'tcx>,\n+    self_type_did: ast::DefId) -> Result<(), ()>\n+{\n+    // New strategy based on review suggestion from nikomatsakis.\n+    //\n+    // (In the text and code below, \"named\" denotes \"struct/enum\", and\n+    // \"generic params\" denotes \"type and region params\")\n+    //\n+    // 1. Create fresh skolemized type/region \"constants\" for each of\n+    //    the named type's generic params.  Instantiate the named type\n+    //    with the fresh constants, yielding `named_skolem`.\n+    //\n+    // 2. Create unification variables for each of the Drop impl's\n+    //    generic params.  Instantiate the impl's Self's type with the\n+    //    unification-vars, yielding `drop_unifier`.\n+    //\n+    // 3. Attempt to unify Self_unif with Type_skolem.  If unification\n+    //    succeeds, continue (i.e. with the predicate checks).\n+\n+    let ty::TypeScheme { generics: ref named_type_generics,\n+                         ty: named_type } =\n+        ty::lookup_item_type(tcx, self_type_did);\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    infcx.try(|snapshot| {\n+        let (named_type_to_skolem, skol_map) =\n+            infcx.construct_skolemized_subst(named_type_generics, snapshot);\n+        let named_type_skolem = named_type.subst(tcx, &named_type_to_skolem);\n+\n+        let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+        let drop_to_unifier =\n+            infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n+        let drop_unifier = drop_impl_ty.subst(tcx, &drop_to_unifier);\n+\n+        if let Ok(()) = infer::mk_eqty(&infcx, true, infer::TypeOrigin::Misc(drop_impl_span),\n+                                       named_type_skolem, drop_unifier) {\n+            // Even if we did manage to equate the types, the process\n+            // may have just gathered unsolvable region constraints\n+            // like `R == 'static` (represented as a pair of subregion\n+            // constraints) for some skolemization constant R.\n+            //\n+            // However, the leak_check method allows us to confirm\n+            // that no skolemized regions escaped (i.e. were related\n+            // to other regions in the constraint graph).\n+            if let Ok(()) = infcx.leak_check(&skol_map, snapshot) {\n+                return Ok(())\n+            }\n+        }\n+\n+        span_err!(tcx.sess, drop_impl_span, E0366,\n+                  \"Implementations of Drop cannot be specialized\");\n+        let item_span = tcx.map.span(self_type_did.node);\n+        tcx.sess.span_note(item_span,\n+                           \"Use same sequence of generic type and region \\\n+                            parameters that is on the struct/enum definition\");\n+        return Err(());\n+    })\n+}\n+\n+/// Confirms that every predicate imposed by dtor_predicates is\n+/// implied by assuming the predicates attached to self_type_did.\n+fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    drop_impl_did: ast::DefId,\n+    dtor_predicates: &ty::GenericPredicates<'tcx>,\n+    self_type_did: ast::DefId,\n+    self_to_impl_substs: &subst::Substs<'tcx>) -> Result<(), ()> {\n+\n+    // Here is an example, analogous to that from\n+    // `compare_impl_method`.\n+    //\n+    // Consider a struct type:\n+    //\n+    //     struct Type<'c, 'b:'c, 'a> {\n+    //         x: &'a Contents            // (contents are irrelevant;\n+    //         y: &'c Cell<&'b Contents>, //  only the bounds matter for our purposes.)\n+    //     }\n+    //\n+    // and a Drop impl:\n+    //\n+    //     impl<'z, 'y:'z, 'x:'y> Drop for P<'z, 'y, 'x> {\n+    //         fn drop(&mut self) { self.y.set(self.x); } // (only legal if 'x: 'y)\n+    //     }\n+    //\n+    // We start out with self_to_impl_substs, that maps the generic\n+    // parameters of Type to that of the Drop impl.\n+    //\n+    //     self_to_impl_substs = {'c => 'z, 'b => 'y, 'a => 'x}\n+    //\n+    // Applying this to the predicates (i.e. assumptions) provided by the item\n+    // definition yields the instantiated assumptions:\n+    //\n+    //     ['y : 'z]\n+    //\n+    // We then check all of the predicates of the Drop impl:\n+    //\n+    //     ['y:'z, 'x:'y]\n+    //\n+    // and ensure each is in the list of instantiated\n+    // assumptions. Here, `'y:'z` is present, but `'x:'y` is\n+    // absent. So we report an error that the Drop impl injected a\n+    // predicate that is not present on the struct definition.\n+\n+    assert_eq!(self_type_did.krate, ast::LOCAL_CRATE);\n+\n+    let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+\n+    // We can assume the predicates attached to struct/enum definition\n+    // hold.\n+    let generic_assumptions = ty::lookup_predicates(tcx, self_type_did);\n+\n+    let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n+    assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::SelfSpace));\n+    assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::FnSpace));\n+    let assumptions_in_impl_context =\n+        assumptions_in_impl_context.predicates.get_slice(subst::TypeSpace);\n+\n+    // An earlier version of this code attempted to do this checking\n+    // via the traits::fulfill machinery. However, it ran into trouble\n+    // since the fulfill machinery merely turns outlives-predicates\n+    // 'a:'b and T:'b into region inference constraints. It is simpler\n+    // just to look for all the predicates directly.\n+\n+    assert!(dtor_predicates.predicates.is_empty_in(subst::SelfSpace));\n+    assert!(dtor_predicates.predicates.is_empty_in(subst::FnSpace));\n+    let predicates = dtor_predicates.predicates.get_slice(subst::TypeSpace);\n+    for predicate in predicates {\n+        // (We do not need to worry about deep analysis of type\n+        // expressions etc because the Drop impls are already forced\n+        // to take on a structure that is roughly a alpha-renaming of\n+        // the generic parameters of the item definition.)\n+\n+        // This path now just checks *all* predicates via the direct\n+        // lookup, rather than using fulfill machinery.\n+        //\n+        // However, it may be more efficient in the future to batch\n+        // the analysis together via the fulfill , rather than the\n+        // repeated `contains` calls.\n+\n+        if !assumptions_in_impl_context.contains(&predicate) {\n+            let item_span = tcx.map.span(self_type_did.node);\n+            let req = predicate.user_string(tcx);\n+            span_err!(tcx.sess, drop_impl_span, E0367,\n+                      \"The requirement `{}` is added only by the Drop impl.\", req);\n+            tcx.sess.span_note(item_span,\n+                               \"The same requirement must be part of \\\n+                                the struct/enum definition\");\n+        }\n+    }\n+\n+    if tcx.sess.has_errors() {\n+        return Err(());\n+    }\n+    Ok(())\n+}\n \n+/// check_safety_of_destructor_if_necessary confirms that the type\n+/// expression `typ` conforms to the \"Drop Check Rule\" from the Sound\n+/// Generic Drop (RFC 769).\n+///\n+/// ----\n+///\n+/// The Drop Check Rule is the following:\n+///\n+/// Let `v` be some value (either temporary or named) and 'a be some\n+/// lifetime (scope). If the type of `v` owns data of type `D`, where\n+///\n+///   (1.) `D` has a lifetime- or type-parametric Drop implementation, and\n+///   (2.) the structure of `D` can reach a reference of type `&'a _`, and\n+///   (3.) either:\n+///\n+///     (A.) the Drop impl for `D` instantiates `D` at 'a directly,\n+///          i.e. `D<'a>`, or,\n+///\n+///     (B.) the Drop impl for `D` has some type parameter with a\n+///          trait bound `T` where `T` is a trait that has at least\n+///          one method,\n+///\n+/// then 'a must strictly outlive the scope of v.\n+///\n+/// ----\n+///\n+/// This function is meant to by applied to the type for every\n+/// expression in the program.\n pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                                      typ: ty::Ty<'tcx>,\n                                                      span: Span,"}, {"sha": "04ea7961f50210fe4674d7688dc82ec42d2e6e2f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -478,6 +478,20 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n     visit::walk_crate(&mut visit, krate);\n \n     ccx.tcx.sess.abort_if_errors();\n+\n+    for drop_method_did in ccx.tcx.destructors.borrow().iter() {\n+        if drop_method_did.krate == ast::LOCAL_CRATE {\n+            let drop_impl_did = ccx.tcx.map.get_parent_did(drop_method_did.node);\n+            match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n+                Ok(()) => {}\n+                Err(()) => {\n+                    assert!(ccx.tcx.sess.has_errors());\n+                }\n+            }\n+        }\n+    }\n+\n+    ccx.tcx.sess.abort_if_errors();\n }\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "95e06879fb2235a066c2aa83104fe7ec9ca643b0", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -177,7 +177,9 @@ register_diagnostics! {\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n-    E0322  // cannot implement Sized explicitly\n+    E0322, // cannot implement Sized explicitly\n+    E0366, // dropck forbid specialization to concrete type or region\n+    E0367  // dropck forbid specialization to predicate not in struct/enum\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "b24cfbb6899a9c655d794958259477a7f8217e11", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -366,7 +366,7 @@ mod test {\n     use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n     use thread;\n \n-    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n+    struct Packet<T: Send>(Arc<(Mutex<T>, Condvar)>);\n \n     unsafe impl<T: Send> Send for Packet<T> {}\n     unsafe impl<T> Sync for Packet<T> {}"}, {"sha": "832665abdc2d762ab48ac265c3a54e3a674eea43", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -15,7 +15,7 @@\n \n use std::marker;\n \n-struct arc_destruct<T> {\n+struct arc_destruct<T: Sync> {\n     _data: int,\n     _marker: marker::PhantomData<T>\n }"}, {"sha": "265db3fe1336a6520a4d92dfd0e63e3c96c3f014", "filename": "src/test/run-pass/issue-15858.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Ftest%2Frun-pass%2Fissue-15858.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Ftest%2Frun-pass%2Fissue-15858.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15858.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -25,7 +25,7 @@ impl Bar for BarImpl {\n }\n \n \n-struct Foo<B>(B);\n+struct Foo<B: Bar>(B);\n \n #[unsafe_destructor]\n impl<B: Bar> Drop for Foo<B> {"}, {"sha": "e544585745de3dfc21839f252614879bc2e19d44", "filename": "src/test/run-pass/issue-15924.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Ftest%2Frun-pass%2Fissue-15924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Ftest%2Frun-pass%2Fissue-15924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15924.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -18,7 +18,7 @@ use std::fmt;\n use serialize::{Encoder, Encodable};\n use serialize::json;\n \n-struct Foo<T> {\n+struct Foo<T: Encodable> {\n     v: T,\n }\n "}, {"sha": "7ca0ee01015b89f2c0db75779ff2ee1bd6afe691", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -162,7 +162,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub struct send_packet<T> {\n+    pub struct send_packet<T:Send> {\n         p: Option<*const packet<T>>,\n     }\n \n@@ -192,7 +192,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub struct recv_packet<T> {\n+    pub struct recv_packet<T:Send> {\n         p: Option<*const packet<T>>,\n     }\n "}, {"sha": "08ee955cabbacd65e29a8300f9901f6f29f60b6b", "filename": "src/test/run-pass/issue-4252.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2e8693e42dee545d336c0364773b3fbded93a5/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4252.rs?ref=5b2e8693e42dee545d336c0364773b3fbded93a5", "patch": "@@ -21,7 +21,7 @@ trait X {\n struct Y(int);\n \n #[derive(Debug)]\n-struct Z<T> {\n+struct Z<T: X+std::fmt::Debug> {\n     x: T\n }\n "}]}