{"sha": "0249603c2065d046763b19a82dea0c0fb26a4ecd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNDk2MDNjMjA2NWQwNDY3NjNiMTlhODJkZWEwYzBmYjI2YTRlY2Q=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-03-19T19:19:20Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-03-19T19:19:20Z"}, "message": "Remove the Guessing Game from the book\n\nFixes #22518", "tree": {"sha": "c646a184ed947a8d18ee71411ffbc4d53e37bb91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c646a184ed947a8d18ee71411ffbc4d53e37bb91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0249603c2065d046763b19a82dea0c0fb26a4ecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0249603c2065d046763b19a82dea0c0fb26a4ecd", "html_url": "https://github.com/rust-lang/rust/commit/0249603c2065d046763b19a82dea0c0fb26a4ecd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0249603c2065d046763b19a82dea0c0fb26a4ecd/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08dd30d9eb685f29b82faae66b5fdb9fc4762a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/08dd30d9eb685f29b82faae66b5fdb9fc4762a91", "html_url": "https://github.com/rust-lang/rust/commit/08dd30d9eb685f29b82faae66b5fdb9fc4762a91"}], "stats": {"total": 894, "additions": 0, "deletions": 894}, "files": [{"sha": "6ff51e8d1b92cb9af4426e41da40125362e1b150", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0249603c2065d046763b19a82dea0c0fb26a4ecd/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/0249603c2065d046763b19a82dea0c0fb26a4ecd/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=0249603c2065d046763b19a82dea0c0fb26a4ecd", "patch": "@@ -14,7 +14,6 @@\n     * [Strings](strings.md)\n     * [Arrays, Vectors, and Slices](arrays-vectors-and-slices.md)\n     * [Standard Input](standard-input.md)\n-    * [Guessing Game](guessing-game.md)\n * [II: Intermediate Rust](intermediate.md)\n     * [Crates and Modules](crates-and-modules.md)\n     * [Testing](testing.md)"}, {"sha": "4e7222269a8ff1954f4fcffccd2271e0762816c0", "filename": "src/doc/trpl/guessing-game.md", "status": "removed", "additions": 0, "deletions": 893, "changes": 893, "blob_url": "https://github.com/rust-lang/rust/blob/08dd30d9eb685f29b82faae66b5fdb9fc4762a91/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/08dd30d9eb685f29b82faae66b5fdb9fc4762a91/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=08dd30d9eb685f29b82faae66b5fdb9fc4762a91", "patch": "@@ -1,893 +0,0 @@\n-% Guessing Game\n-\n-Okay! We've got the basics of Rust down. Let's write a bigger program.\n-\n-For our first project, we'll implement a classic beginner programming problem:\n-the guessing game. Here's how it works: Our program will generate a random\n-integer between one and a hundred. It will then prompt us to enter a guess.\n-Upon entering our guess, it will tell us if we're too low or too high. Once we\n-guess correctly, it will congratulate us. Sound good?\n-\n-## Set up\n-\n-Let's set up a new project. Go to your projects directory. Remember how we\n-had to create our directory structure and a `Cargo.toml` for `hello_world`? Cargo\n-has a command that does that for us. Let's give it a shot:\n-\n-```{bash}\n-$ cd ~/projects\n-$ cargo new guessing_game --bin\n-$ cd guessing_game\n-```\n-\n-We pass the name of our project to `cargo new`, and then the `--bin` flag,\n-since we're making a binary, rather than a library.\n-\n-Check out the generated `Cargo.toml`:\n-\n-```toml\n-[package]\n-\n-name = \"guessing_game\"\n-version = \"0.0.1\"\n-authors = [\"Your Name <you@example.com>\"]\n-```\n-\n-Cargo gets this information from your environment. If it's not correct, go ahead\n-and fix that.\n-\n-Finally, Cargo generated a \"Hello, world!\" for us. Check out `src/main.rs`:\n-\n-```{rust}\n-fn main() {\n-    println!(\"Hello, world!\")\n-}\n-```\n-\n-Let's try compiling what Cargo gave us:\n-\n-```{bash}\n-$ cargo build\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-```\n-\n-Excellent! Open up your `src/main.rs` again. We'll be writing all of\n-our code in this file. We'll talk about multiple-file projects later on in the\n-guide.\n-\n-Before we move on, let me show you one more Cargo command: `run`. `cargo run`\n-is kind of like `cargo build`, but it also then runs the produced executable.\n-Try it out:\n-\n-```bash\n-$ cargo run\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-     Running `target/guessing_game`\n-Hello, world!\n-```\n-\n-Great! The `run` command comes in handy when you need to rapidly iterate on a project.\n-Our game is just such a project, we need to quickly test each iteration before moving on to the next one.\n-\n-## Processing a Guess\n-\n-Let's get to it! The first thing we need to do for our guessing game is\n-allow our player to input a guess. Put this in your `src/main.rs`:\n-\n-```{rust,no_run}\n-use std::old_io;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    println!(\"Please input your guess.\");\n-\n-    let input = old_io::stdin().read_line()\n-                           .ok()\n-                           .expect(\"Failed to read line\");\n-\n-    println!(\"You guessed: {}\", input);\n-}\n-```\n-\n-You've seen this code before, when we talked about standard input. We\n-import the `std::old_io` module with `use`, and then our `main` function contains\n-our program's logic. We print a little message announcing the game, ask the\n-user to input a guess, get their input, and then print it out.\n-\n-Because we talked about this in the section on standard I/O, I won't go into\n-more details here. If you need a refresher, go re-read that section.\n-\n-## Generating a secret number\n-\n-Next, we need to generate a secret number. To do that, we need to use Rust's\n-random number generation, which we haven't talked about yet. Rust includes a\n-bunch of interesting functions in its standard library. If you need a bit of\n-code, it's possible that it's already been written for you! In this case,\n-we do know that Rust has random number generation, but we don't know how to\n-use it.\n-\n-Enter the docs. Rust has a page specifically to document the standard library.\n-You can find that page [here](../std/index.html). There's a lot of information on\n-that page, but the best part is the search bar. Right up at the top, there's\n-a box that you can enter in a search term. The search is pretty primitive\n-right now, but is getting better all the time. If you type \"random\" in that\n-box, the page will update to [this one](../std/index.html?search=random). The very\n-first result is a link to [`std::rand::random`](../std/rand/fn.random.html). If we\n-click on that result, we'll be taken to its documentation page.\n-\n-This page shows us a few things: the type signature of the function, some\n-explanatory text, and then an example. Let's try to modify our code to add in the\n-`random` function and see what happens:\n-\n-```{rust,ignore}\n-use std::old_io;\n-use std::rand;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random() % 100) + 1; // secret_number: i32\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    println!(\"Please input your guess.\");\n-\n-    let input = old_io::stdin().read_line()\n-                           .ok()\n-                           .expect(\"Failed to read line\");\n-\n-\n-    println!(\"You guessed: {}\", input);\n-}\n-```\n-\n-The first thing we changed was to `use std::rand`, as the docs\n-explained.  We then added in a `let` expression to create a variable binding\n-named `secret_number`, and we printed out its result.\n-\n-Also, you may wonder why we are using `%` on the result of `rand::random()`.\n-This operator is called *modulo*, and it returns the remainder of a division.\n-By taking the modulo of the result of `rand::random()`, we're limiting the\n-values to be between 0 and 99. Then, we add one to the result, making it from 1\n-to 100. Using modulo can give you a very, very small bias in the result, but\n-for this example, it is not important.\n-\n-Let's try to compile this using `cargo build`:\n-\n-```bash\n-$ cargo build\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-src/main.rs:7:26: 7:34 error: the type of this value must be known in this context\n-src/main.rs:7     let secret_number = (rand::random() % 100) + 1;\n-                                       ^~~~~~~~\n-error: aborting due to previous error\n-```\n-\n-It didn't work! Rust says \"the type of this value must be known in this\n-context.\" What's up with that? Well, as it turns out, `rand::random()` can\n-generate many kinds of random values, not just integers. And in this case, Rust\n-isn't sure what kind of value `random()` should generate. So we have to help\n-it. With number literals, we can just add an `i32` onto the end to tell Rust they're\n-integers, but that does not work with functions. There's a different syntax,\n-and it looks like this:\n-\n-```{rust,ignore}\n-rand::random::<i32>();\n-```\n-\n-This says \"please give me a random `i32` value.\" We can change our code to use\n-this hint:\n-\n-```{rust,no_run}\n-use std::old_io;\n-use std::rand;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<i32>() % 100) + 1;\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    println!(\"Please input your guess.\");\n-\n-    let input = old_io::stdin().read_line()\n-                           .ok()\n-                           .expect(\"Failed to read line\");\n-\n-\n-    println!(\"You guessed: {}\", input);\n-}\n-```\n-\n-Try running our new program a few times:\n-\n-```bash\n-$ cargo run\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-     Running `target/guessing_game`\n-Guess the number!\n-The secret number is: 7\n-Please input your guess.\n-4\n-You guessed: 4\n-$ ./target/guessing_game\n-Guess the number!\n-The secret number is: 83\n-Please input your guess.\n-5\n-You guessed: 5\n-$ ./target/guessing_game\n-Guess the number!\n-The secret number is: -29\n-Please input your guess.\n-42\n-You guessed: 42\n-```\n-\n-Wait. Negative 29? We wanted a number between one and a hundred! We have two\n-options here: we can either ask `random()` to generate an unsigned integer, which\n-can only be positive, or we can use the `abs()` function. Let's go with the\n-unsigned integer approach. If we want a random positive number, we should ask for\n-a random positive number. Our code looks like this now:\n-\n-```{rust,no_run}\n-use std::old_io;\n-use std::rand;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<u32>() % 100) + 1;\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    println!(\"Please input your guess.\");\n-\n-    let input = old_io::stdin().read_line()\n-                           .ok()\n-                           .expect(\"Failed to read line\");\n-\n-\n-    println!(\"You guessed: {}\", input);\n-}\n-```\n-\n-And trying it out:\n-\n-```bash\n-$ cargo run\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-     Running `target/guessing_game`\n-Guess the number!\n-The secret number is: 57\n-Please input your guess.\n-3\n-You guessed: 3\n-```\n-\n-Great! Next up: let's compare our guess to the secret guess.\n-\n-## Comparing guesses\n-\n-If you remember, earlier in the guide, we made a `cmp` function that compared\n-two numbers. Let's add that in, along with a `match` statement to compare our\n-guess to the secret number:\n-\n-```{rust,ignore}\n-use std::old_io;\n-use std::rand;\n-use std::cmp::Ordering;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<u32>() % 100) + 1;\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    println!(\"Please input your guess.\");\n-\n-    let input = old_io::stdin().read_line()\n-                           .ok()\n-                           .expect(\"Failed to read line\");\n-\n-\n-    println!(\"You guessed: {}\", input);\n-\n-    match cmp(input, secret_number) {\n-        Ordering::Less => println!(\"Too small!\"),\n-        Ordering::Greater => println!(\"Too big!\"),\n-        Ordering::Equal => println!(\"You win!\"),\n-    }\n-}\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-```\n-\n-If we try to compile, we'll get some errors:\n-\n-```bash\n-$ cargo build\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-src/main.rs:20:15: 20:20 error: mismatched types: expected `i32` but found `collections::string::String` (expected i32 but found struct collections::string::String)\n-src/main.rs:20     match cmp(input, secret_number) {\n-                             ^~~~~\n-src/main.rs:20:22: 20:35 error: mismatched types: expected `i32` but found `u32` (expected i32 but found u32)\n-src/main.rs:20     match cmp(input, secret_number) {\n-                                    ^~~~~~~~~~~~~\n-error: aborting due to 2 previous errors\n-```\n-\n-This often happens when writing Rust programs, and is one of Rust's greatest\n-strengths. You try out some code, see if it compiles, and Rust tells you that\n-you've done something wrong. In this case, our `cmp` function works on integers,\n-but we've given it unsigned integers. In this case, the fix is easy, because\n-we wrote the `cmp` function! Let's change it to take `u32`s:\n-\n-```{rust,ignore}\n-use std::old_io;\n-use std::rand;\n-use std::cmp::Ordering;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<u32>() % 100) + 1;\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    println!(\"Please input your guess.\");\n-\n-    let input = old_io::stdin().read_line()\n-                           .ok()\n-                           .expect(\"Failed to read line\");\n-\n-\n-    println!(\"You guessed: {}\", input);\n-\n-    match cmp(input, secret_number) {\n-        Ordering::Less => println!(\"Too small!\"),\n-        Ordering::Greater => println!(\"Too big!\"),\n-        Ordering::Equal => println!(\"You win!\"),\n-    }\n-}\n-\n-fn cmp(a: u32, b: u32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-```\n-\n-And try compiling again:\n-\n-```bash\n-$ cargo build\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-src/main.rs:20:15: 20:20 error: mismatched types: expected `u32` but found `collections::string::String` (expected u32 but found struct collections::string::String)\n-src/main.rs:20     match cmp(input, secret_number) {\n-                             ^~~~~\n-error: aborting due to previous error\n-```\n-\n-This error is similar to the last one: we expected to get a `u32`, but we got\n-a `String` instead! That's because our `input` variable is coming from the\n-standard input, and you can guess anything. Try it:\n-\n-```bash\n-$ ./target/guessing_game\n-Guess the number!\n-The secret number is: 73\n-Please input your guess.\n-hello\n-You guessed: hello\n-```\n-\n-Oops! Also, you'll note that we just ran our program even though it didn't compile.\n-This works because the older version we did successfully compile was still lying\n-around. Gotta be careful!\n-\n-Anyway, we have a `String`, but we need a `u32`. What to do? Well, there's\n-a function for that:\n-\n-```{rust,ignore}\n-let input = old_io::stdin().read_line()\n-                       .ok()\n-                       .expect(\"Failed to read line\");\n-let input_num: Result<u32, _> = input.parse();\n-```\n-\n-The `parse` function takes in a `&str` value and converts it into something.\n-We tell it what kind of something with a type hint. Remember our type hint with\n-`random()`? It looked like this:\n-\n-```{rust,ignore}\n-rand::random::<u32>();\n-```\n-\n-There's an alternate way of providing a hint too, and that's declaring the type\n-in a `let`:\n-\n-```{rust,ignore}\n-let x: u32 = rand::random();\n-```\n-\n-In this case, we say `x` is a `u32` explicitly, so Rust is able to properly\n-tell `random()` what to generate. In a similar fashion, both of these work:\n-\n-```{rust,ignore}\n-let input_num_option = \"5\".parse::<u32>().ok(); // input_num: Option<u32>\n-let input_num_result: Result<u32, _> = \"5\".parse(); // input_num: Result<u32, <u32 as FromStr>::Err>\n-```\n-\n-Above, we're converting the `Result` returned by `parse` to an `Option` by using\n-the `ok` method as well.  Anyway, with us now converting our input to a number,\n-our code looks like this:\n-\n-```{rust,ignore}\n-use std::old_io;\n-use std::rand;\n-use std::cmp::Ordering;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<u32>() % 100) + 1;\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    println!(\"Please input your guess.\");\n-\n-    let input = old_io::stdin().read_line()\n-                           .ok()\n-                           .expect(\"Failed to read line\");\n-    let input_num: Result<u32, _> = input.parse();\n-\n-    println!(\"You guessed: {:?}\", input_num);\n-\n-    match cmp(input_num, secret_number) {\n-        Ordering::Less => println!(\"Too small!\"),\n-        Ordering::Greater => println!(\"Too big!\"),\n-        Ordering::Equal => println!(\"You win!\"),\n-    }\n-}\n-\n-fn cmp(a: u32, b: u32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-```\n-\n-Let's try it out!\n-\n-```bash\n-$ cargo build\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-src/main.rs:21:15: 21:24 error: mismatched types: expected `u32`, found `core::result::Result<u32, core::num::ParseIntError>` (expected u32, found enum `core::result::Result`) [E0308]\n-src/main.rs:21     match cmp(input_num, secret_number) {\n-                             ^~~~~~~~~\n-error: aborting due to previous error\n-```\n-\n-Oh yeah! Our `input_num` has the type `Result<u32, <some error>>`, rather than `u32`. We\n-need to unwrap the Result. If you remember from before, `match` is a great way\n-to do that. Try this code:\n-\n-```{rust,no_run}\n-use std::old_io;\n-use std::rand;\n-use std::cmp::Ordering;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<u32>() % 100) + 1;\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    println!(\"Please input your guess.\");\n-\n-    let input = old_io::stdin().read_line()\n-                           .ok()\n-                           .expect(\"Failed to read line\");\n-    let input_num: Result<u32, _> = input.parse();\n-\n-    let num = match input_num {\n-        Ok(n) => n,\n-        Err(_) => {\n-            println!(\"Please input a number!\");\n-            return;\n-        }\n-    };\n-\n-\n-    println!(\"You guessed: {}\", num);\n-\n-    match cmp(num, secret_number) {\n-        Ordering::Less => println!(\"Too small!\"),\n-        Ordering::Greater => println!(\"Too big!\"),\n-        Ordering::Equal => println!(\"You win!\"),\n-    }\n-}\n-\n-fn cmp(a: u32, b: u32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-```\n-\n-We use a `match` to either give us the `u32` inside of the `Result`, or else\n-print an error message and return. Let's give this a shot:\n-\n-```bash\n-$ cargo run\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-     Running `target/guessing_game`\n-Guess the number!\n-The secret number is: 17\n-Please input your guess.\n-5\n-Please input a number!\n-```\n-\n-Uh, what? But we did!\n-\n-... actually, we didn't. See, when you get a line of input from `stdin()`,\n-you get all the input. Including the `\\n` character from you pressing Enter.\n-Therefore, `parse()` sees the string `\"5\\n\"` and says \"nope, that's not a\n-number; there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n-method we can use defined on them: `trim()`. One small modification, and our\n-code looks like this:\n-\n-```{rust,no_run}\n-use std::old_io;\n-use std::rand;\n-use std::cmp::Ordering;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<u32>() % 100) + 1;\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    println!(\"Please input your guess.\");\n-\n-    let input = old_io::stdin().read_line()\n-                           .ok()\n-                           .expect(\"Failed to read line\");\n-    let input_num: Result<u32, _> = input.trim().parse();\n-\n-    let num = match input_num {\n-        Ok(num) => num,\n-        Err(_) => {\n-            println!(\"Please input a number!\");\n-            return;\n-        }\n-    };\n-\n-\n-    println!(\"You guessed: {}\", num);\n-\n-    match cmp(num, secret_number) {\n-        Ordering::Less => println!(\"Too small!\"),\n-        Ordering::Greater => println!(\"Too big!\"),\n-        Ordering::Equal => println!(\"You win!\"),\n-    }\n-}\n-\n-fn cmp(a: u32, b: u32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-```\n-\n-Let's try it!\n-\n-```bash\n-$ cargo run\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-     Running `target/guessing_game`\n-Guess the number!\n-The secret number is: 58\n-Please input your guess.\n-  76\n-You guessed: 76\n-Too big!\n-```\n-\n-Nice! You can see I even added spaces before my guess, and it still figured\n-out that I guessed 76. Run the program a few times, and verify that guessing\n-the number works, as well as guessing a number too small.\n-\n-The Rust compiler helped us out quite a bit there! This technique is called\n-\"leaning on the compiler\", and it's often useful when working on some code.\n-Let the error messages help guide you towards the correct types.\n-\n-Now we've got most of the game working, but we can only make one guess. Let's\n-change that by adding loops!\n-\n-## Looping\n-\n-As we already discussed, the `loop` keyword gives us an infinite loop.\n-Let's add that in:\n-\n-```{rust,no_run}\n-use std::old_io;\n-use std::rand;\n-use std::cmp::Ordering;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<u32>() % 100) + 1;\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    loop {\n-\n-        println!(\"Please input your guess.\");\n-\n-        let input = old_io::stdin().read_line()\n-                               .ok()\n-                               .expect(\"Failed to read line\");\n-        let input_num: Result<u32, _> = input.trim().parse();\n-\n-        let num = match input_num {\n-            Ok(num) => num,\n-            Err(_) => {\n-                println!(\"Please input a number!\");\n-                return;\n-            }\n-        };\n-\n-\n-        println!(\"You guessed: {}\", num);\n-\n-        match cmp(num, secret_number) {\n-            Ordering::Less => println!(\"Too small!\"),\n-            Ordering::Greater => println!(\"Too big!\"),\n-            Ordering::Equal => println!(\"You win!\"),\n-        }\n-    }\n-}\n-\n-fn cmp(a: u32, b: u32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-```\n-\n-And try it out. But wait, didn't we just add an infinite loop? Yup. Remember\n-that `return`? If we give a non-number answer, we'll `return` and quit. Observe:\n-\n-```bash\n-$ cargo run\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-     Running `target/guessing_game`\n-Guess the number!\n-The secret number is: 59\n-Please input your guess.\n-45\n-You guessed: 45\n-Too small!\n-Please input your guess.\n-60\n-You guessed: 60\n-Too big!\n-Please input your guess.\n-59\n-You guessed: 59\n-You win!\n-Please input your guess.\n-quit\n-Please input a number!\n-```\n-\n-Ha! `quit` actually quits. As does any other non-number input. Well, this is\n-suboptimal to say the least. First, let's actually quit when you win the game:\n-\n-```{rust,no_run}\n-use std::old_io;\n-use std::rand;\n-use std::cmp::Ordering;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<u32>() % 100) + 1;\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    loop {\n-\n-        println!(\"Please input your guess.\");\n-\n-        let input = old_io::stdin().read_line()\n-                               .ok()\n-                               .expect(\"Failed to read line\");\n-        let input_num: Result<u32, _> = input.trim().parse();\n-\n-        let num = match input_num {\n-            Ok(num) => num,\n-            Err(_) => {\n-                println!(\"Please input a number!\");\n-                return;\n-            }\n-        };\n-\n-\n-        println!(\"You guessed: {}\", num);\n-\n-        match cmp(num, secret_number) {\n-            Ordering::Less => println!(\"Too small!\"),\n-            Ordering::Greater => println!(\"Too big!\"),\n-            Ordering::Equal => {\n-                println!(\"You win!\");\n-                return;\n-            },\n-        }\n-    }\n-}\n-\n-fn cmp(a: u32, b: u32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-```\n-\n-By adding the `return` line after the `You win!`, we'll exit the program when\n-we win. We have just one more tweak to make: when someone inputs a non-number,\n-we don't want to quit, we just want to ignore it. Change that `return` to\n-`continue`:\n-\n-\n-```{rust,no_run}\n-use std::old_io;\n-use std::rand;\n-use std::cmp::Ordering;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<u32>() % 100) + 1;\n-\n-    println!(\"The secret number is: {}\", secret_number);\n-\n-    loop {\n-\n-        println!(\"Please input your guess.\");\n-\n-        let input = old_io::stdin().read_line()\n-                               .ok()\n-                               .expect(\"Failed to read line\");\n-        let input_num: Result<u32, _> = input.trim().parse();\n-\n-        let num = match input_num {\n-            Ok(num) => num,\n-            Err(_) => {\n-                println!(\"Please input a number!\");\n-                continue;\n-            }\n-        };\n-\n-\n-        println!(\"You guessed: {}\", num);\n-\n-        match cmp(num, secret_number) {\n-            Ordering::Less => println!(\"Too small!\"),\n-            Ordering::Greater => println!(\"Too big!\"),\n-            Ordering::Equal => {\n-                println!(\"You win!\");\n-                return;\n-            },\n-        }\n-    }\n-}\n-\n-fn cmp(a: u32, b: u32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-```\n-\n-Now we should be good! Let's try:\n-\n-```bash\n-$ cargo run\n-   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-     Running `target/guessing_game`\n-Guess the number!\n-The secret number is: 61\n-Please input your guess.\n-10\n-You guessed: 10\n-Too small!\n-Please input your guess.\n-99\n-You guessed: 99\n-Too big!\n-Please input your guess.\n-foo\n-Please input a number!\n-Please input your guess.\n-61\n-You guessed: 61\n-You win!\n-```\n-\n-Awesome! With one tiny last tweak, we have finished the guessing game. Can you\n-think of what it is? That's right, we don't want to print out the secret number.\n-It was good for testing, but it kind of ruins the game. Here's our final source:\n-\n-```{rust,no_run}\n-use std::old_io;\n-use std::rand;\n-use std::cmp::Ordering;\n-\n-fn main() {\n-    println!(\"Guess the number!\");\n-\n-    let secret_number = (rand::random::<u32>() % 100) + 1;\n-\n-    loop {\n-\n-        println!(\"Please input your guess.\");\n-\n-        let input = old_io::stdin().read_line()\n-                               .ok()\n-                               .expect(\"Failed to read line\");\n-        let input_num: Result<u32, _> = input.trim().parse();\n-\n-        let num = match input_num {\n-            Ok(num) => num,\n-            Err(_) => {\n-                println!(\"Please input a number!\");\n-                continue;\n-            }\n-        };\n-\n-\n-        println!(\"You guessed: {}\", num);\n-\n-        match cmp(num, secret_number) {\n-            Ordering::Less => println!(\"Too small!\"),\n-            Ordering::Greater => println!(\"Too big!\"),\n-            Ordering::Equal => {\n-                println!(\"You win!\");\n-                return;\n-            },\n-        }\n-    }\n-}\n-\n-fn cmp(a: u32, b: u32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-```\n-\n-## Complete!\n-\n-At this point, you have successfully built the Guessing Game! Congratulations!\n-\n-You've now learned the basic syntax of Rust. All of this is relatively close to\n-various other programming languages you have used in the past. These\n-fundamental syntactical and semantic elements will form the foundation for the\n-rest of your Rust education.\n-\n-Now that you're an expert at the basics, it's time to learn about some of\n-Rust's more unique features."}]}