{"sha": "1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "node_id": "C_kwDOAAsO6NoAKDFhMWY1MjViYjBkOTg5NzY3M2IyNDQ1MTIyZmZkNmY3YWEyNjVjOWU", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-10-30T18:30:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-30T18:30:27Z"}, "message": "Rollup merge of #90202 - matthewjasper:xcrate-hygiene, r=petrochenkov\n\nImprove and test cross-crate hygiene\n\n- Decode the parent expansion for traits and enums in `rustc_resolve`, this was already being used for resolution in typeck\n- Avoid suggesting importing names with def-site hygiene, since it's often not useful\n- Add more tests\n\nr? `@petrochenkov`", "tree": {"sha": "6cf7640d023116647df7bb1ae3bb0fdbef1924f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cf7640d023116647df7bb1ae3bb0fdbef1924f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhfY9DCRBK7hj4Ov3rIwAAgiwIAFX6nlXmP8WqBBMDeyzCPsjc\n9vibShBJ3pY88oHUPwwTdyr1r6BQBmx2Lv+vYXNcvXLhvf/swP8sypmjZg2Jb6SQ\npkhWjISRXIYUwhVEVueYMw9gvZu5kV9QCPiKTgqiPqbVg2Z7GZ66dwvz0yn3/BJm\ng0r/vZ41vfkzyROb4W7bXorhySVrItK9EJJXUxhLxyWp9RzWsmHrltwkx3g+udDk\n69dJ7bEICA/mFwXVGvERe6uw6SINvR9nKYKHSCTAz9zNyiRkgUfw+Y6dNKhc+xfp\n2ZnmHudNODskJkw/atrZjscqKdFUiI3e9IRIgxG0aDWXts46b+Jo057O04L/YLo=\n=FLZf\n-----END PGP SIGNATURE-----\n", "payload": "tree 6cf7640d023116647df7bb1ae3bb0fdbef1924f9\nparent 73494404e962f4d61e65e5e204432de5a5128101\nparent a76a2d4ef986ec69e4ffb81c35dfb8dc91effee9\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1635618627 +0200\ncommitter GitHub <noreply@github.com> 1635618627 +0200\n\nRollup merge of #90202 - matthewjasper:xcrate-hygiene, r=petrochenkov\n\nImprove and test cross-crate hygiene\n\n- Decode the parent expansion for traits and enums in `rustc_resolve`, this was already being used for resolution in typeck\n- Avoid suggesting importing names with def-site hygiene, since it's often not useful\n- Add more tests\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "html_url": "https://github.com/rust-lang/rust/commit/1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73494404e962f4d61e65e5e204432de5a5128101", "url": "https://api.github.com/repos/rust-lang/rust/commits/73494404e962f4d61e65e5e204432de5a5128101", "html_url": "https://github.com/rust-lang/rust/commit/73494404e962f4d61e65e5e204432de5a5128101"}, {"sha": "a76a2d4ef986ec69e4ffb81c35dfb8dc91effee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a76a2d4ef986ec69e4ffb81c35dfb8dc91effee9", "html_url": "https://github.com/rust-lang/rust/commit/a76a2d4ef986ec69e4ffb81c35dfb8dc91effee9"}], "stats": {"total": 557, "additions": 525, "deletions": 32}, "files": [{"sha": "5e90aec003e9b1a20e381b1069059a87b1125bc6", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -1198,8 +1198,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             }\n         }\n \n-        if let EntryKind::Mod(data) = kind {\n-            for exp in data.decode((self, sess)).reexports.decode((self, sess)) {\n+        if let EntryKind::Mod(exports) = kind {\n+            for exp in exports.decode((self, sess)) {\n                 match exp.res {\n                     Res::Def(DefKind::Macro(..), _) => {}\n                     _ if macros_only => continue,\n@@ -1219,10 +1219,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn module_expansion(&self, id: DefIndex, sess: &Session) -> ExpnId {\n-        if let EntryKind::Mod(m) = self.kind(id) {\n-            m.decode((self, sess)).expansion\n-        } else {\n-            panic!(\"Expected module, found {:?}\", self.local_def_id(id))\n+        match self.kind(id) {\n+            EntryKind::Mod(_) | EntryKind::Enum(_) | EntryKind::Trait(_) => {\n+                self.get_expn_that_defined(id, sess)\n+            }\n+            _ => panic!(\"Expected module, found {:?}\", self.local_def_id(id)),\n         }\n     }\n "}, {"sha": "0dbef66ac37d77ff78eeb6fa2fb10a5986f1e1f3", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -1086,11 +1086,11 @@ impl EncodeContext<'a, 'tcx> {\n             Lazy::empty()\n         };\n \n-        let data = ModData { reexports, expansion: tcx.expn_that_defined(local_def_id) };\n-\n-        record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n+        record!(self.tables.kind[def_id] <- EntryKind::Mod(reexports));\n         if self.is_proc_macro {\n             record!(self.tables.children[def_id] <- &[]);\n+            // Encode this here because we don't do it in encode_def_ids.\n+            record!(self.tables.expn_that_defined[def_id] <- tcx.expn_that_defined(local_def_id));\n         } else {\n             record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n                 item_id.def_id.local_def_index"}, {"sha": "4e09d23169aca3c771b86ad12d68c6ec713c32b2", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -346,7 +346,7 @@ enum EntryKind {\n     Union(Lazy<VariantData>, ReprOptions),\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n-    Mod(Lazy<ModData>),\n+    Mod(Lazy<[Export]>),\n     MacroDef(Lazy<MacroDef>),\n     ProcMacro(MacroKind),\n     Closure,\n@@ -364,12 +364,6 @@ enum EntryKind {\n #[derive(Encodable, Decodable)]\n struct RenderedConst(String);\n \n-#[derive(MetadataEncodable, MetadataDecodable)]\n-struct ModData {\n-    reexports: Lazy<[Export]>,\n-    expansion: ExpnId,\n-}\n-\n #[derive(MetadataEncodable, MetadataDecodable)]\n struct FnData {\n     asyncness: hir::IsAsync,"}, {"sha": "33af9884cbb6686ced37c2729251fdb5094491e1", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -145,17 +145,11 @@ impl<'a> Resolver<'a> {\n                     } else {\n                         def_key.disambiguated_data.data.get_opt_name().expect(\"module without name\")\n                     };\n-                    let expn_id = if def_kind == DefKind::Mod {\n-                        self.cstore().module_expansion_untracked(def_id, &self.session)\n-                    } else {\n-                        // FIXME: Parent expansions for enums and traits are not kept in metadata.\n-                        ExpnId::root()\n-                    };\n \n                     Some(self.new_module(\n                         parent,\n                         ModuleKind::Def(def_kind, def_id, name),\n-                        expn_id,\n+                        self.cstore().module_expansion_untracked(def_id, &self.session),\n                         self.cstore().get_span_untracked(def_id, &self.session),\n                         // FIXME: Account for `#[no_implicit_prelude]` attributes.\n                         parent.map_or(false, |module| module.no_implicit_prelude),"}, {"sha": "163acebcceacffe792a1238f13a014e71a6858c5", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -842,9 +842,11 @@ impl<'a> Resolver<'a> {\n \n                 // collect results based on the filter function\n                 // avoid suggesting anything from the same module in which we are resolving\n+                // avoid suggesting anything with a hygienic name\n                 if ident.name == lookup_ident.name\n                     && ns == namespace\n                     && !ptr::eq(in_module, parent_scope.module)\n+                    && !ident.span.normalize_to_macros_2_0().from_expansion()\n                 {\n                     let res = name_binding.res();\n                     if filter_fn(res) {"}, {"sha": "724d1904dc33c7125d7231f2190abc64d7d4f7c9", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -709,7 +709,7 @@ impl SyntaxContext {\n     ///         pub fn f() {} // `f`'s `SyntaxContext` has a single `ExpnId` from `m`.\n     ///         pub fn $i() {} // `$i`'s `SyntaxContext` is empty.\n     ///     }\n-    ///     n(f);\n+    ///     n!(f);\n     ///     macro n($j:ident) {\n     ///         use foo::*;\n     ///         f(); // `f`'s `SyntaxContext` has a mark from `m` and a mark from `n`"}, {"sha": "733d11a9e8229349dde7068f55b06a33e6c833b1", "filename": "src/test/ui/hygiene/auxiliary/fields.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ffields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ffields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ffields.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,73 @@\n+#![feature(decl_macro)]\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum Field {\n+    RootCtxt,\n+    MacroCtxt,\n+}\n+\n+#[rustfmt::skip]\n+macro x(\n+    $macro_name:ident,\n+    $macro2_name:ident,\n+    $type_name:ident,\n+    $field_name:ident,\n+    $const_name:ident\n+) {\n+    #[derive(Copy, Clone)]\n+    pub struct $type_name {\n+        pub field: Field,\n+        pub $field_name: Field,\n+    }\n+\n+    pub const $const_name: $type_name =\n+        $type_name { field: Field::MacroCtxt, $field_name: Field::RootCtxt };\n+\n+    #[macro_export]\n+    macro_rules! $macro_name {\n+        (check_fields_of $e:expr) => {{\n+            let e = $e;\n+            assert_eq!(e.field, Field::MacroCtxt);\n+            assert_eq!(e.$field_name, Field::RootCtxt);\n+        }};\n+        (check_fields) => {{\n+            assert_eq!($const_name.field, Field::MacroCtxt);\n+            assert_eq!($const_name.$field_name, Field::RootCtxt);\n+        }};\n+        (construct) => {\n+            $type_name { field: Field::MacroCtxt, $field_name: Field::RootCtxt }\n+        };\n+    }\n+\n+    pub macro $macro2_name {\n+        (check_fields_of $e:expr) => {{\n+            let e = $e;\n+            assert_eq!(e.field, Field::MacroCtxt);\n+            assert_eq!(e.$field_name, Field::RootCtxt);\n+        }},\n+        (check_fields) => {{\n+            assert_eq!($const_name.field, Field::MacroCtxt);\n+            assert_eq!($const_name.$field_name, Field::RootCtxt);\n+        }},\n+        (construct) => {\n+            $type_name { field: Field::MacroCtxt, $field_name: Field::RootCtxt }\n+        }\n+    }\n+}\n+\n+x!(test_fields, test_fields2, MyStruct, field, MY_CONST);\n+\n+pub fn check_fields(s: MyStruct) {\n+    test_fields!(check_fields_of s);\n+}\n+\n+pub fn check_fields_local() {\n+    test_fields!(check_fields);\n+    test_fields2!(check_fields);\n+\n+    let s1 = test_fields!(construct);\n+    test_fields!(check_fields_of s1);\n+\n+    let s2 = test_fields2!(construct);\n+    test_fields2!(check_fields_of s2);\n+}"}, {"sha": "23b9c61cfc05820cac7060ec9757f70421f03100", "filename": "src/test/ui/hygiene/auxiliary/methods.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fmethods.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,160 @@\n+#![feature(decl_macro)]\n+\n+#[derive(PartialEq, Eq, Debug)]\n+pub enum Method {\n+    DefaultMacroCtxt,\n+    DefaultRootCtxt,\n+    OverrideMacroCtxt,\n+    OverrideRootCtxt,\n+}\n+\n+#[rustfmt::skip]\n+macro x($macro_name:ident, $macro2_name:ident, $trait_name:ident, $method_name:ident) {\n+    pub trait $trait_name {\n+        fn method(&self) -> Method {\n+            Method::DefaultMacroCtxt\n+        }\n+\n+        fn $method_name(&self) -> Method {\n+            Method::DefaultRootCtxt\n+        }\n+    }\n+\n+    impl $trait_name for () {}\n+    impl $trait_name for bool {\n+        fn method(&self) -> Method {\n+            Method::OverrideMacroCtxt\n+        }\n+\n+        fn $method_name(&self) -> Method {\n+            Method::OverrideRootCtxt\n+        }\n+    }\n+\n+    #[macro_export]\n+    macro_rules! $macro_name {\n+        (check_resolutions) => {\n+            assert_eq!(().method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&()), Method::DefaultMacroCtxt);\n+            assert_eq!(().$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&()), Method::DefaultRootCtxt);\n+\n+            assert_eq!(false.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&false), Method::OverrideMacroCtxt);\n+            assert_eq!(false.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&false), Method::OverrideRootCtxt);\n+\n+            assert_eq!('a'.method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&'a'), Method::DefaultMacroCtxt);\n+            assert_eq!('a'.$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&'a'), Method::DefaultRootCtxt);\n+\n+            assert_eq!(1i32.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&1i32), Method::OverrideMacroCtxt);\n+            assert_eq!(1i32.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&1i32), Method::OverrideRootCtxt);\n+\n+            assert_eq!(1i64.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&1i64), Method::OverrideMacroCtxt);\n+            assert_eq!(1i64.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&1i64), Method::OverrideRootCtxt);\n+        };\n+        (assert_no_override $v:expr) => {\n+            assert_eq!($v.method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&$v), Method::DefaultMacroCtxt);\n+            assert_eq!($v.$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&$v), Method::DefaultRootCtxt);\n+        };\n+        (assert_override $v:expr) => {\n+            assert_eq!($v.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&$v), Method::OverrideMacroCtxt);\n+            assert_eq!($v.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&$v), Method::OverrideRootCtxt);\n+        };\n+        (impl for $t:ty) => {\n+            impl $trait_name for $t {\n+                fn method(&self) -> Method {\n+                    Method::OverrideMacroCtxt\n+                }\n+\n+                fn $method_name(&self) -> Method {\n+                    Method::OverrideRootCtxt\n+                }\n+            }\n+        };\n+    }\n+\n+    pub macro $macro2_name {\n+        (check_resolutions) => {\n+            assert_eq!(().method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&()), Method::DefaultMacroCtxt);\n+            assert_eq!(().$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&()), Method::DefaultRootCtxt);\n+\n+            assert_eq!(false.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&false), Method::OverrideMacroCtxt);\n+            assert_eq!(false.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&false), Method::OverrideRootCtxt);\n+\n+            assert_eq!('a'.method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&'a'), Method::DefaultMacroCtxt);\n+            assert_eq!('a'.$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&'a'), Method::DefaultRootCtxt);\n+\n+            assert_eq!(1i32.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&1i32), Method::OverrideMacroCtxt);\n+            assert_eq!(1i32.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&1i32), Method::OverrideRootCtxt);\n+\n+            assert_eq!(1i64.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&1i64), Method::OverrideMacroCtxt);\n+            assert_eq!(1i64.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&1i64), Method::OverrideRootCtxt);\n+        },\n+        (assert_no_override $v:expr) => {\n+            assert_eq!($v.method(), Method::DefaultMacroCtxt);\n+            assert_eq!($trait_name::method(&$v), Method::DefaultMacroCtxt);\n+            assert_eq!($v.$method_name(), Method::DefaultRootCtxt);\n+            assert_eq!($trait_name::$method_name(&$v), Method::DefaultRootCtxt);\n+        },\n+        (assert_override $v:expr) => {\n+            assert_eq!($v.method(), Method::OverrideMacroCtxt);\n+            assert_eq!($trait_name::method(&$v), Method::OverrideMacroCtxt);\n+            assert_eq!($v.$method_name(), Method::OverrideRootCtxt);\n+            assert_eq!($trait_name::$method_name(&$v), Method::OverrideRootCtxt);\n+        },\n+        (impl for $t:ty) => {\n+            impl $trait_name for $t {\n+                fn method(&self) -> Method {\n+                    Method::OverrideMacroCtxt\n+                }\n+\n+                fn $method_name(&self) -> Method {\n+                    Method::OverrideRootCtxt\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+x!(test_trait, test_trait2, MyTrait, method);\n+\n+impl MyTrait for char {}\n+test_trait!(impl for i32);\n+test_trait2!(impl for i64);\n+\n+pub fn check_crate_local() {\n+    test_trait!(check_resolutions);\n+    test_trait2!(check_resolutions);\n+}\n+\n+// Check that any comparison of idents at monomorphization time is correct\n+pub fn check_crate_local_generic<T: MyTrait, U: MyTrait>(t: T, u: U) {\n+    test_trait!(check_resolutions);\n+    test_trait2!(check_resolutions);\n+\n+    test_trait!(assert_no_override t);\n+    test_trait2!(assert_no_override t);\n+    test_trait!(assert_override u);\n+    test_trait2!(assert_override u);\n+}"}, {"sha": "47e76a629c8b1cedd186086560d3bc2ca21c6fde", "filename": "src/test/ui/hygiene/auxiliary/pub_hygiene.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fpub_hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fpub_hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fpub_hygiene.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,7 @@\n+#![feature(decl_macro)]\n+\n+macro x() {\n+    pub struct MyStruct;\n+}\n+\n+x!();"}, {"sha": "791cf0358952a648e6c94d2662271614ebba8c1e", "filename": "src/test/ui/hygiene/auxiliary/use_by_macro.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fuse_by_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fuse_by_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fuse_by_macro.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,15 @@\n+#![feature(decl_macro)]\n+\n+macro x($macro_name:ident) {\n+    #[macro_export]\n+    macro_rules! $macro_name {\n+        (define) => {\n+            pub struct MyStruct;\n+        };\n+        (create) => {\n+            MyStruct {}\n+        };\n+    }\n+}\n+\n+x!(my_struct);"}, {"sha": "dbfcce17d47f1f6e3081571508a49900b58067ea", "filename": "src/test/ui/hygiene/auxiliary/variants.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fvariants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fvariants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fvariants.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,36 @@\n+#![feature(decl_macro)]\n+\n+#[rustfmt::skip]\n+macro x($macro_name:ident, $macro2_name:ident, $type_name:ident, $variant_name:ident) {\n+    #[repr(u8)]\n+    pub enum $type_name {\n+        Variant = 0,\n+        $variant_name = 1,\n+    }\n+\n+    #[macro_export]\n+    macro_rules! $macro_name {\n+        () => {{\n+            assert_eq!($type_name::Variant as u8, 0);\n+            assert_eq!($type_name::$variant_name as u8, 1);\n+            assert_eq!(<$type_name>::Variant as u8, 0);\n+            assert_eq!(<$type_name>::$variant_name as u8, 1);\n+        }};\n+    }\n+\n+    pub macro $macro2_name {\n+        () => {{\n+            assert_eq!($type_name::Variant as u8, 0);\n+            assert_eq!($type_name::$variant_name as u8, 1);\n+            assert_eq!(<$type_name>::Variant as u8, 0);\n+            assert_eq!(<$type_name>::$variant_name as u8, 1);\n+        }},\n+    }\n+}\n+\n+x!(test_variants, test_variants2, MyEnum, Variant);\n+\n+pub fn check_variants() {\n+    test_variants!();\n+    test_variants2!();\n+}"}, {"sha": "94f1adff626429f0909e96ea21c326c230dab673", "filename": "src/test/ui/hygiene/cross-crate-define-and-use.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-define-and-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-define-and-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-define-and-use.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,19 @@\n+// Check that a marco from another crate can define an item in one expansion\n+// and use it from another, without it being visible to everyone.\n+// This requires that the definition of `my_struct` preserves the hygiene\n+// information for the tokens in its definition.\n+\n+// check-pass\n+// aux-build:use_by_macro.rs\n+\n+#![feature(type_name_of_val)]\n+extern crate use_by_macro;\n+\n+use use_by_macro::*;\n+\n+enum MyStruct {}\n+my_struct!(define);\n+\n+fn main() {\n+    let x = my_struct!(create);\n+}"}, {"sha": "1bcd64573ac6e19c3e073c8ad174430f09b64419", "filename": "src/test/ui/hygiene/cross-crate-fields.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-fields.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,24 @@\n+// Test that fields on a struct defined in another crate are resolved correctly\n+// their names differ only in `SyntaxContext`.\n+\n+// run-pass\n+// aux-build:fields.rs\n+\n+extern crate fields;\n+\n+use fields::*;\n+\n+fn main() {\n+    check_fields_local();\n+\n+    test_fields!(check_fields);\n+    test_fields2!(check_fields);\n+\n+    let s1 = test_fields!(construct);\n+    check_fields(s1);\n+    test_fields!(check_fields_of s1);\n+\n+    let s2 = test_fields2!(construct);\n+    check_fields(s2);\n+    test_fields2!(check_fields_of s2);\n+}"}, {"sha": "de5576682a6bdd725ceaa0e2e90d8323386be039", "filename": "src/test/ui/hygiene/cross-crate-glob-hygiene.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,23 @@\n+// Check that globs cannot import hygienic identifiers from a macro expansion\n+// in another crate. `my_struct` is a `macro_rules` macro, so the struct it\n+// defines is only not imported because `my_struct` is defined by a macros 2.0\n+// macro.\n+\n+// aux-build:use_by_macro.rs\n+\n+extern crate use_by_macro;\n+\n+use use_by_macro::*;\n+\n+mod m {\n+    use use_by_macro::*;\n+\n+    my_struct!(define);\n+}\n+\n+use m::*;\n+\n+fn main() {\n+    let x = my_struct!(create);\n+    //~^ ERROR cannot find struct, variant or union type `MyStruct` in this scope\n+}"}, {"sha": "7369e77d0709eb2420cce04572a22bb8867c3a1b", "filename": "src/test/ui/hygiene/cross-crate-glob-hygiene.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-glob-hygiene.stderr?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,11 @@\n+error[E0422]: cannot find struct, variant or union type `MyStruct` in this scope\n+  --> $DIR/cross-crate-glob-hygiene.rs:21:13\n+   |\n+LL |     let x = my_struct!(create);\n+   |             ^^^^^^^^^^^^^^^^^^ not found in this scope\n+   |\n+   = note: this error originates in the macro `my_struct` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0422`."}, {"sha": "0e6f57c33f64a26f213db38ac52b47ce5d0f6e08", "filename": "src/test/ui/hygiene/cross-crate-methods.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-methods.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,33 @@\n+// Test that methods defined in another crate are resolved correctly their\n+// names differ only in `SyntaxContext`. This also checks that any name\n+// resolution done when monomorphizing is correct.\n+\n+// run-pass\n+// aux-build:methods.rs\n+\n+extern crate methods;\n+\n+use methods::*;\n+\n+struct A;\n+struct B;\n+struct C;\n+\n+impl MyTrait for A {}\n+test_trait!(impl for B);\n+test_trait2!(impl for C);\n+\n+fn main() {\n+    check_crate_local();\n+    check_crate_local_generic(A, B);\n+    check_crate_local_generic(A, C);\n+\n+    test_trait!(check_resolutions);\n+    test_trait2!(check_resolutions);\n+    test_trait!(assert_no_override A);\n+    test_trait2!(assert_no_override A);\n+    test_trait!(assert_override B);\n+    test_trait2!(assert_override B);\n+    test_trait!(assert_override C);\n+    test_trait2!(assert_override C);\n+}"}, {"sha": "8f118782f2319864c5cadb21e952cd3b2b149013", "filename": "src/test/ui/hygiene/cross-crate-name-collision.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-collision.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,12 @@\n+// Check that two items defined in another crate that have identifiers that\n+// only differ by `SyntaxContext` do not cause name collisions when imported\n+// in another crate.\n+\n+// check-pass\n+// aux-build:needs_hygiene.rs\n+\n+extern crate needs_hygiene;\n+\n+use needs_hygiene::*;\n+\n+fn main() {}"}, {"sha": "3eacd775c9e539e5e32b12d060a19dc828396753", "filename": "src/test/ui/hygiene/cross-crate-name-hiding-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,15 @@\n+// Check that an identifier from a 2.0 macro in another crate cannot be\n+// resolved with an identifier that's not from a macro expansion.\n+\n+// aux-build:use_by_macro.rs\n+\n+extern crate use_by_macro;\n+\n+use use_by_macro::*;\n+\n+my_struct!(define);\n+\n+fn main() {\n+    let x = MyStruct {};\n+    //~^ ERROR cannot find struct, variant or union type `MyStruct` in this scope\n+}"}, {"sha": "46314cdd5ab4eafb0239ff8c3cbf02e843e54907", "filename": "src/test/ui/hygiene/cross-crate-name-hiding-2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding-2.stderr?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,9 @@\n+error[E0422]: cannot find struct, variant or union type `MyStruct` in this scope\n+  --> $DIR/cross-crate-name-hiding-2.rs:13:13\n+   |\n+LL |     let x = MyStruct {};\n+   |             ^^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0422`."}, {"sha": "dd76ecc5762f534b0129692e367519b9ab4ed41f", "filename": "src/test/ui/hygiene/cross-crate-name-hiding.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,13 @@\n+// Check that an item defined by a 2.0 macro in another crate cannot be used in\n+// another crate.\n+\n+// aux-build:pub_hygiene.rs\n+\n+extern crate pub_hygiene;\n+\n+use pub_hygiene::*;\n+\n+fn main() {\n+    let x = MyStruct {};\n+    //~^ ERROR cannot find struct, variant or union type `MyStruct` in this scope\n+}"}, {"sha": "f8840c8f85a33f5f3be6d22dbc2dfb2f3ba24296", "filename": "src/test/ui/hygiene/cross-crate-name-hiding.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-name-hiding.stderr?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,9 @@\n+error[E0422]: cannot find struct, variant or union type `MyStruct` in this scope\n+  --> $DIR/cross-crate-name-hiding.rs:11:13\n+   |\n+LL |     let x = MyStruct {};\n+   |             ^^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0422`."}, {"sha": "3cb06b4bad87359d98e677838465b70635b8de62", "filename": "src/test/ui/hygiene/cross-crate-redefine.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,14 @@\n+// Check that items with identical `SyntaxContext` conflict even when that\n+// context involves a mark from another crate.\n+\n+// aux-build:use_by_macro.rs\n+\n+extern crate use_by_macro;\n+\n+use use_by_macro::*;\n+\n+my_struct!(define);\n+//~^ ERROR the name `MyStruct` is defined multiple times\n+my_struct!(define);\n+\n+fn main() {}"}, {"sha": "4f1419de426778663d13b163e4b5be8080a921d1", "filename": "src/test/ui/hygiene/cross-crate-redefine.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-redefine.stderr?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,15 @@\n+error[E0428]: the name `MyStruct` is defined multiple times\n+  --> $DIR/cross-crate-redefine.rs:10:1\n+   |\n+LL | my_struct!(define);\n+   | ^^^^^^^^^^^^^^^^^^ `MyStruct` redefined here\n+LL |\n+LL | my_struct!(define);\n+   | ------------------ previous definition of the type `MyStruct` here\n+   |\n+   = note: `MyStruct` must be defined only once in the type namespace of this module\n+   = note: this error originates in the macro `my_struct` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0428`."}, {"sha": "efc73a21f16f302e267456723e9520e39a8a37e2", "filename": "src/test/ui/hygiene/cross-crate-variants.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross-crate-variants.rs?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -0,0 +1,18 @@\n+// Test that variants of an enum defined in another crate are resolved\n+// correctly when their names differ only in `SyntaxContext`.\n+\n+// run-pass\n+// aux-build:variants.rs\n+\n+extern crate variants;\n+\n+use variants::*;\n+\n+fn main() {\n+    check_variants();\n+\n+    test_variants!();\n+    test_variants2!();\n+\n+    assert_eq!(MyEnum::Variant as u8, 1);\n+}"}, {"sha": "75742960b7e3ccafef7b7725be18502395658955", "filename": "src/test/ui/hygiene/cross_crate_hygiene.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Fui%2Fhygiene%2Fcross_crate_hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Fui%2Fhygiene%2Fcross_crate_hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fcross_crate_hygiene.rs?ref=73494404e962f4d61e65e5e204432de5a5128101", "patch": "@@ -1,8 +0,0 @@\n-// check-pass\n-// aux-build:needs_hygiene.rs\n-\n-extern crate needs_hygiene;\n-\n-use needs_hygiene::*;\n-\n-fn main() {}"}, {"sha": "5d04fe1e3de5f5cd08f9ead0fb563fdfd8d05eca", "filename": "src/test/ui/proc-macro/meta-macro-hygiene.stdout", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -49,6 +49,8 @@ crate0::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt:\n crate0::{{expn2}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"produce_it\")\n crate0::{{expn3}}: parent: crate0::{{expn2}}, call_site_ctxt: #4, def_site_ctxt: #0, kind: Macro(Bang, \"meta_macro::print_def_site\")\n crate0::{{expn4}}: parent: crate0::{{expn3}}, call_site_ctxt: #5, def_site_ctxt: #0, kind: Macro(Bang, \"$crate::dummy\")\n+crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Attr, \"derive\")\n+crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Attr, \"derive\")\n crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"include\")\n crate2::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n "}, {"sha": "709b2a2169e08d8f9033ba28e706f17f06756acc", "filename": "src/test/ui/proc-macro/nonterminal-token-hygiene.stdout", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1a1f525bb0d9897673b2445122ffd6f7aa265c9e/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout?ref=1a1f525bb0d9897673b2445122ffd6f7aa265c9e", "patch": "@@ -73,6 +73,8 @@ crate0::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt:\n crate0::{{expn2}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"outer\")\n crate0::{{expn3}}: parent: crate0::{{expn2}}, call_site_ctxt: #4, def_site_ctxt: #4, kind: Macro(Bang, \"inner\")\n crate0::{{expn4}}: parent: crate0::{{expn3}}, call_site_ctxt: #6, def_site_ctxt: #0, kind: Macro(Bang, \"print_bang\")\n+crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Attr, \"derive\")\n+crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Attr, \"derive\")\n crate1::{{expnNNN}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"include\")\n crate2::{{expn1}}: parent: crate0::{{expn0}}, call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n "}]}