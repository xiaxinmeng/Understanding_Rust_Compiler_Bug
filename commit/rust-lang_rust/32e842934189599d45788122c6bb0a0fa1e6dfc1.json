{"sha": "32e842934189599d45788122c6bb0a0fa1e6dfc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZTg0MjkzNDE4OTU5OWQ0NTc4ODEyMmM2YmIwYTBmYTFlNmRmYzE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-24T20:58:46Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-24T20:59:17Z"}, "message": "rustc: Translate struct literals", "tree": {"sha": "012705975449a3531201a17b260c72b2c76ec626", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/012705975449a3531201a17b260c72b2c76ec626"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32e842934189599d45788122c6bb0a0fa1e6dfc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32e842934189599d45788122c6bb0a0fa1e6dfc1", "html_url": "https://github.com/rust-lang/rust/commit/32e842934189599d45788122c6bb0a0fa1e6dfc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32e842934189599d45788122c6bb0a0fa1e6dfc1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b91da0945d99276554a6a4f61f3df027d3277a92", "url": "https://api.github.com/repos/rust-lang/rust/commits/b91da0945d99276554a6a4f61f3df027d3277a92", "html_url": "https://github.com/rust-lang/rust/commit/b91da0945d99276554a6a4f61f3df027d3277a92"}], "stats": {"total": 87, "additions": 87, "deletions": 0}, "files": [{"sha": "932655364c96a7ac8f427d96097a11f0d11f10c1", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/32e842934189599d45788122c6bb0a0fa1e6dfc1/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e842934189599d45788122c6bb0a0fa1e6dfc1/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=32e842934189599d45788122c6bb0a0fa1e6dfc1", "patch": "@@ -3410,6 +3410,90 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n     ret bcx;\n }\n \n+fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n+                id: ast::node_id, dest: dest) -> block {\n+\n+    let _instruction_context = block_context.insn_ctxt(~\"trans_struct\");\n+    let mut block_context = block_context;\n+    let type_context = block_context.ccx().tcx;\n+\n+    let struct_type = node_id_type(block_context, id);\n+\n+    // Get the address to store the structure into. If there is no address,\n+    // just translate each field and be done with it.\n+    let dest_address;\n+    alt dest {\n+        ignore => {\n+            for fields.each |field| {\n+                block_context = trans_expr(block_context,\n+                                           field.node.expr,\n+                                           ignore);\n+            }\n+            ret block_context;\n+        }\n+        save_in(destination_address) => {\n+            dest_address = destination_address;\n+        }\n+        by_val(_) => {\n+            type_context.sess.span_bug(span, ~\"didn't expect by_val\");\n+        }\n+    }\n+\n+    // Get the class ID and its fields.\n+    let class_fields, class_id, substitutions;\n+    alt ty::get(struct_type).struct {\n+        ty::ty_class(existing_class_id, existing_substitutions) => {\n+            class_id = existing_class_id;\n+            substitutions = existing_substitutions;\n+            class_fields = ty::lookup_class_fields(type_context, class_id);\n+        }\n+        _ => {\n+            type_context.sess.span_bug(span, ~\"didn't resolve to a struct\");\n+        }\n+    }\n+\n+    // Now translate each field.\n+    let mut temp_cleanups = ~[];\n+    for fields.each |field| {\n+        let mut found = none;\n+        for class_fields.eachi |i, class_field| {\n+            if str::eq(*class_field.ident, *field.node.ident) {\n+                found = some((i, class_field.id));\n+                break;\n+            }\n+        }\n+\n+        let index, field_id;\n+        alt found {\n+            some((found_index, found_field_id)) => {\n+                index = found_index;\n+                field_id = found_field_id;\n+            }\n+            none => {\n+                type_context.sess.span_bug(span, ~\"unknown field\");\n+            }\n+        }\n+\n+        let dest = GEPi(block_context, dest_address, ~[0, index]);\n+        block_context = trans_expr_save_in(block_context,\n+                                           field.node.expr,\n+                                           dest);\n+\n+        let field_type = ty::lookup_field_type(type_context, class_id,\n+                                               field_id, substitutions);\n+        add_clean_temp_mem(block_context, dest, field_type);\n+        vec::push(temp_cleanups, dest);\n+    }\n+\n+    // Now revoke the cleanups, as we pass responsibility for the data\n+    // structure onto the caller.\n+    for temp_cleanups.each |temp_cleanup| {\n+        revoke_clean(block_context, temp_cleanup);\n+    }\n+\n+    block_context\n+}\n+\n // Store the result of an expression in the given memory location, ensuring\n // that nil or bot expressions get ignore rather than save_in as destination.\n fn trans_expr_save_in(bcx: block, e: @ast::expr, dest: ValueRef)\n@@ -3558,6 +3642,9 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           ast::expr_rec(args, base) {\n             ret trans_rec(bcx, args, base, e.id, dest);\n           }\n+          ast::expr_struct(_, fields) {\n+            ret trans_struct(bcx, e.span, fields, e.id, dest);\n+          }\n           ast::expr_tup(args) { ret trans_tup(bcx, args, dest); }\n           ast::expr_vstore(e, v) { ret tvec::trans_vstore(bcx, e, v, dest); }\n           ast::expr_lit(lit) { ret trans_lit(bcx, e, *lit, dest); }"}]}