{"sha": "d7785a8fab5c496d390ff2dd55a4beacdcebb3d9", "node_id": "C_kwDOAAsO6NoAKGQ3Nzg1YThmYWI1YzQ5NmQzOTBmZjJkZDU1YTRiZWFjZGNlYmIzZDk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-04-14T10:15:58Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-04-14T10:16:38Z"}, "message": "minor: Cleanup config.rs a bit", "tree": {"sha": "e77b040be05c19131368fcd25822774bd7f03e24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e77b040be05c19131368fcd25822774bd7f03e24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7785a8fab5c496d390ff2dd55a4beacdcebb3d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7785a8fab5c496d390ff2dd55a4beacdcebb3d9", "html_url": "https://github.com/rust-lang/rust/commit/d7785a8fab5c496d390ff2dd55a4beacdcebb3d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7785a8fab5c496d390ff2dd55a4beacdcebb3d9/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b23b27631091e44445c829cc8fc8fe4a5c910fc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b23b27631091e44445c829cc8fc8fe4a5c910fc8", "html_url": "https://github.com/rust-lang/rust/commit/b23b27631091e44445c829cc8fc8fe4a5c910fc8"}], "stats": {"total": 146, "additions": 96, "deletions": 50}, "files": [{"sha": "833ee31eed8394266deae7cf1698e7e0dfed0d0a", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 96, "deletions": 50, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/d7785a8fab5c496d390ff2dd55a4beacdcebb3d9/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7785a8fab5c496d390ff2dd55a4beacdcebb3d9/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=d7785a8fab5c496d390ff2dd55a4beacdcebb3d9", "patch": "@@ -380,6 +380,8 @@ pub struct Config {\n     snippets: Vec<Snippet>,\n }\n \n+type ParallelPrimeCachesNumThreads = u8;\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum LinkedProject {\n     ProjectManifest(ProjectManifest),\n@@ -400,17 +402,27 @@ impl From<ProjectJson> for LinkedProject {\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LensConfig {\n+    // runnables\n     pub run: bool,\n     pub debug: bool,\n+\n+    // implementations\n     pub implementations: bool,\n+\n+    // references\n     pub method_refs: bool,\n     pub refs: bool, // for Struct, Enum, Union and Trait\n     pub enum_variant_refs: bool,\n }\n \n impl LensConfig {\n     pub fn any(&self) -> bool {\n-        self.implementations || self.runnable() || self.references()\n+        self.run\n+            || self.debug\n+            || self.implementations\n+            || self.method_refs\n+            || self.refs\n+            || self.enum_variant_refs\n     }\n \n     pub fn none(&self) -> bool {\n@@ -623,6 +635,12 @@ macro_rules! try_or {\n     };\n }\n \n+macro_rules! try_or_def {\n+    ($expr:expr) => {\n+        try_!($expr).unwrap_or_default()\n+    };\n+}\n+\n impl Config {\n     pub fn linked_projects(&self) -> Vec<LinkedProject> {\n         match self.data.linkedProjects.as_slice() {\n@@ -651,14 +669,13 @@ impl Config {\n     }\n \n     pub fn did_save_text_document_dynamic_registration(&self) -> bool {\n-        let caps =\n-            try_or!(self.caps.text_document.as_ref()?.synchronization.clone()?, Default::default());\n+        let caps = try_or_def!(self.caps.text_document.as_ref()?.synchronization.clone()?);\n         caps.did_save == Some(true) && caps.dynamic_registration == Some(true)\n     }\n+\n     pub fn did_change_watched_files_dynamic_registration(&self) -> bool {\n-        try_or!(\n-            self.caps.workspace.as_ref()?.did_change_watched_files.as_ref()?.dynamic_registration?,\n-            false\n+        try_or_def!(\n+            self.caps.workspace.as_ref()?.did_change_watched_files.as_ref()?.dynamic_registration?\n         )\n     }\n \n@@ -667,22 +684,24 @@ impl Config {\n     }\n \n     pub fn location_link(&self) -> bool {\n-        try_or!(self.caps.text_document.as_ref()?.definition?.link_support?, false)\n+        try_or_def!(self.caps.text_document.as_ref()?.definition?.link_support?)\n     }\n+\n     pub fn line_folding_only(&self) -> bool {\n-        try_or!(self.caps.text_document.as_ref()?.folding_range.as_ref()?.line_folding_only?, false)\n+        try_or_def!(self.caps.text_document.as_ref()?.folding_range.as_ref()?.line_folding_only?)\n     }\n+\n     pub fn hierarchical_symbols(&self) -> bool {\n-        try_or!(\n+        try_or_def!(\n             self.caps\n                 .text_document\n                 .as_ref()?\n                 .document_symbol\n                 .as_ref()?\n-                .hierarchical_document_symbol_support?,\n-            false\n+                .hierarchical_document_symbol_support?\n         )\n     }\n+\n     pub fn code_action_literals(&self) -> bool {\n         try_!(self\n             .caps\n@@ -694,12 +713,15 @@ impl Config {\n             .as_ref()?)\n         .is_some()\n     }\n+\n     pub fn work_done_progress(&self) -> bool {\n-        try_or!(self.caps.window.as_ref()?.work_done_progress?, false)\n+        try_or_def!(self.caps.window.as_ref()?.work_done_progress?)\n     }\n+\n     pub fn will_rename(&self) -> bool {\n-        try_or!(self.caps.workspace.as_ref()?.file_operations.as_ref()?.will_rename?, false)\n+        try_or_def!(self.caps.workspace.as_ref()?.file_operations.as_ref()?.will_rename?)\n     }\n+\n     pub fn change_annotation_support(&self) -> bool {\n         try_!(self\n             .caps\n@@ -711,24 +733,24 @@ impl Config {\n             .as_ref()?)\n         .is_some()\n     }\n+\n     pub fn code_action_resolve(&self) -> bool {\n-        try_or!(\n-            self.caps\n-                .text_document\n-                .as_ref()?\n-                .code_action\n-                .as_ref()?\n-                .resolve_support\n-                .as_ref()?\n-                .properties\n-                .as_slice(),\n-            &[]\n-        )\n+        try_or_def!(self\n+            .caps\n+            .text_document\n+            .as_ref()?\n+            .code_action\n+            .as_ref()?\n+            .resolve_support\n+            .as_ref()?\n+            .properties\n+            .as_slice())\n         .iter()\n         .any(|it| it == \"edit\")\n     }\n+\n     pub fn signature_help_label_offsets(&self) -> bool {\n-        try_or!(\n+        try_or_def!(\n             self.caps\n                 .text_document\n                 .as_ref()?\n@@ -738,10 +760,10 @@ impl Config {\n                 .as_ref()?\n                 .parameter_information\n                 .as_ref()?\n-                .label_offset_support?,\n-            false\n+                .label_offset_support?\n         )\n     }\n+\n     pub fn offset_encoding(&self) -> OffsetEncoding {\n         if supports_utf8(&self.caps) {\n             OffsetEncoding::Utf8\n@@ -751,18 +773,21 @@ impl Config {\n     }\n \n     fn experimental(&self, index: &'static str) -> bool {\n-        try_or!(self.caps.experimental.as_ref()?.get(index)?.as_bool()?, false)\n+        try_or_def!(self.caps.experimental.as_ref()?.get(index)?.as_bool()?)\n     }\n+\n     pub fn code_action_group(&self) -> bool {\n         self.experimental(\"codeActionGroup\")\n     }\n+\n     pub fn server_status_notification(&self) -> bool {\n         self.experimental(\"serverStatusNotification\")\n     }\n \n     pub fn publish_diagnostics(&self) -> bool {\n         self.data.diagnostics_enable\n     }\n+\n     pub fn diagnostics(&self) -> DiagnosticsConfig {\n         DiagnosticsConfig {\n             disable_experimental: !self.data.diagnostics_enableExperimental,\n@@ -773,16 +798,19 @@ impl Config {\n             },\n         }\n     }\n+\n     pub fn diagnostics_map(&self) -> DiagnosticsMapConfig {\n         DiagnosticsMapConfig {\n             remap_prefix: self.data.diagnostics_remapPrefix.clone(),\n             warnings_as_info: self.data.diagnostics_warningsAsInfo.clone(),\n             warnings_as_hint: self.data.diagnostics_warningsAsHint.clone(),\n         }\n     }\n+\n     pub fn lru_capacity(&self) -> Option<usize> {\n         self.data.lruCapacity\n     }\n+\n     pub fn proc_macro_srv(&self) -> Option<(AbsPathBuf, Vec<OsString>)> {\n         if !self.data.procMacro_enable {\n             return None;\n@@ -793,12 +821,15 @@ impl Config {\n         };\n         Some((path, vec![\"proc-macro\".into()]))\n     }\n+\n     pub fn dummy_replacements(&self) -> &FxHashMap<Box<str>, Box<[Box<str>]>> {\n         &self.data.procMacro_ignored\n     }\n+\n     pub fn expand_proc_attr_macros(&self) -> bool {\n         self.data.experimental_procAttrMacros\n     }\n+\n     pub fn files(&self) -> FilesConfig {\n         FilesConfig {\n             watcher: match self.data.files_watcher.as_str() {\n@@ -811,15 +842,19 @@ impl Config {\n             exclude: self.data.files_excludeDirs.iter().map(|it| self.root_path.join(it)).collect(),\n         }\n     }\n+\n     pub fn notifications(&self) -> NotificationsConfig {\n         NotificationsConfig { cargo_toml_not_found: self.data.notifications_cargoTomlNotFound }\n     }\n+\n     pub fn cargo_autoreload(&self) -> bool {\n         self.data.cargo_autoreload\n     }\n+\n     pub fn run_build_scripts(&self) -> bool {\n         self.data.cargo_runBuildScripts || self.data.procMacro_enable\n     }\n+\n     pub fn cargo(&self) -> CargoConfig {\n         let rustc_source = self.data.rustcSource.as_ref().map(|rustc_src| {\n             if rustc_src == \"discover\" {\n@@ -855,6 +890,7 @@ impl Config {\n             },\n         }\n     }\n+\n     pub fn flycheck(&self) -> Option<FlycheckConfig> {\n         if !self.data.checkOnSave_enable {\n             return None;\n@@ -891,12 +927,14 @@ impl Config {\n         };\n         Some(flycheck_config)\n     }\n+\n     pub fn runnables(&self) -> RunnablesConfig {\n         RunnablesConfig {\n             override_cargo: self.data.runnables_overrideCargo.clone(),\n             cargo_extra_args: self.data.runnables_cargoExtraArgs.clone(),\n         }\n     }\n+\n     pub fn inlay_hints(&self) -> InlayHintsConfig {\n         InlayHintsConfig {\n             render_colons: self.data.inlayHints_renderColons,\n@@ -917,6 +955,7 @@ impl Config {\n             max_length: self.data.inlayHints_maxLength,\n         }\n     }\n+\n     fn insert_use_config(&self) -> InsertUseConfig {\n         InsertUseConfig {\n             granularity: match self.data.assist_importGranularity {\n@@ -935,6 +974,7 @@ impl Config {\n             skip_glob_imports: !self.data.assist_allowMergingIntoGlobImports,\n         }\n     }\n+\n     pub fn completion(&self) -> CompletionConfig {\n         CompletionConfig {\n             enable_postfix_completions: self.data.completion_postfix_enable,\n@@ -945,27 +985,28 @@ impl Config {\n             add_call_parenthesis: self.data.completion_addCallParenthesis,\n             add_call_argument_snippets: self.data.completion_addCallArgumentSnippets,\n             insert_use: self.insert_use_config(),\n-            snippet_cap: SnippetCap::new(try_or!(\n+            snippet_cap: SnippetCap::new(try_or_def!(\n                 self.caps\n                     .text_document\n                     .as_ref()?\n                     .completion\n                     .as_ref()?\n                     .completion_item\n                     .as_ref()?\n-                    .snippet_support?,\n-                false\n+                    .snippet_support?\n             )),\n             snippets: self.snippets.clone(),\n         }\n     }\n+\n     pub fn assist(&self) -> AssistConfig {\n         AssistConfig {\n             snippet_cap: SnippetCap::new(self.experimental(\"snippetTextEdit\")),\n             allowed: None,\n             insert_use: self.insert_use_config(),\n         }\n     }\n+\n     pub fn join_lines(&self) -> JoinLinesConfig {\n         JoinLinesConfig {\n             join_else_if: self.data.joinLines_joinElseIf,\n@@ -974,9 +1015,11 @@ impl Config {\n             join_assignments: self.data.joinLines_joinAssignments,\n         }\n     }\n+\n     pub fn call_info_full(&self) -> bool {\n         self.data.callInfo_full\n     }\n+\n     pub fn lens(&self) -> LensConfig {\n         LensConfig {\n             run: self.data.lens_enable && self.data.lens_run,\n@@ -987,6 +1030,7 @@ impl Config {\n             enum_variant_refs: self.data.lens_enable && self.data.lens_enumVariantReferences,\n         }\n     }\n+\n     pub fn hover_actions(&self) -> HoverActionsConfig {\n         let enable = self.experimental(\"hoverActions\") && self.data.hoverActions_enable;\n         HoverActionsConfig {\n@@ -997,24 +1041,24 @@ impl Config {\n             goto_type_def: enable && self.data.hoverActions_gotoTypeDef,\n         }\n     }\n+\n     pub fn highlighting_strings(&self) -> bool {\n         self.data.highlighting_strings\n     }\n+\n     pub fn hover(&self) -> HoverConfig {\n         HoverConfig {\n             links_in_hover: self.data.hover_linksInHover,\n             documentation: self.data.hover_documentation.then(|| {\n-                let is_markdown = try_or!(\n-                    self.caps\n-                        .text_document\n-                        .as_ref()?\n-                        .hover\n-                        .as_ref()?\n-                        .content_format\n-                        .as_ref()?\n-                        .as_slice(),\n-                    &[]\n-                )\n+                let is_markdown = try_or_def!(self\n+                    .caps\n+                    .text_document\n+                    .as_ref()?\n+                    .hover\n+                    .as_ref()?\n+                    .content_format\n+                    .as_ref()?\n+                    .as_slice())\n                 .contains(&MarkupKind::Markdown);\n                 if is_markdown {\n                     HoverDocFormat::Markdown\n@@ -1042,24 +1086,26 @@ impl Config {\n     }\n \n     pub fn semantic_tokens_refresh(&self) -> bool {\n-        try_or!(self.caps.workspace.as_ref()?.semantic_tokens.as_ref()?.refresh_support?, false)\n+        try_or_def!(self.caps.workspace.as_ref()?.semantic_tokens.as_ref()?.refresh_support?)\n     }\n+\n     pub fn code_lens_refresh(&self) -> bool {\n-        try_or!(self.caps.workspace.as_ref()?.code_lens.as_ref()?.refresh_support?, false)\n+        try_or_def!(self.caps.workspace.as_ref()?.code_lens.as_ref()?.refresh_support?)\n     }\n+\n     pub fn insert_replace_support(&self) -> bool {\n-        try_or!(\n+        try_or_def!(\n             self.caps\n                 .text_document\n                 .as_ref()?\n                 .completion\n                 .as_ref()?\n                 .completion_item\n                 .as_ref()?\n-                .insert_replace_support?,\n-            false\n+                .insert_replace_support?\n         )\n     }\n+\n     pub fn client_commands(&self) -> ClientCommandsConfig {\n         let commands =\n             try_or!(self.caps.experimental.as_ref()?.get(\"commands\")?, &serde_json::Value::Null);\n@@ -1096,6 +1142,8 @@ impl Config {\n     }\n }\n \n+// Deserialization definitions\n+\n #[derive(Deserialize, Debug, Clone, Copy)]\n #[serde(rename_all = \"snake_case\")]\n enum SnippetScopeDef {\n@@ -1218,8 +1266,6 @@ enum WorkspaceSymbolSearchKindDef {\n     AllSymbols,\n }\n \n-type ParallelPrimeCachesNumThreads = u8;\n-\n macro_rules! _config_data {\n     (struct $name:ident {\n         $("}]}