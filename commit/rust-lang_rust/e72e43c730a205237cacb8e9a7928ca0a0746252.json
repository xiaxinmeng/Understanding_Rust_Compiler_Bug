{"sha": "e72e43c730a205237cacb8e9a7928ca0a0746252", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MmU0M2M3MzBhMjA1MjM3Y2FjYjhlOWE3OTI4Y2EwYTA3NDYyNTI=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-10-04T22:22:23Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-10-04T23:07:03Z"}, "message": "Replace `(Body, DefId)` with `Body` where possible\n\nA `Body` now contains its `MirSource`, which in turn contains the\n`DefId` of the item associated with the `Body`.", "tree": {"sha": "df36d4b62347a189456b033bf008960ee76dcd9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df36d4b62347a189456b033bf008960ee76dcd9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e72e43c730a205237cacb8e9a7928ca0a0746252", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e72e43c730a205237cacb8e9a7928ca0a0746252", "html_url": "https://github.com/rust-lang/rust/commit/e72e43c730a205237cacb8e9a7928ca0a0746252", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e72e43c730a205237cacb8e9a7928ca0a0746252/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ccf5f731bb71db3470002d6baf5ab4792b821d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ccf5f731bb71db3470002d6baf5ab4792b821d9", "html_url": "https://github.com/rust-lang/rust/commit/4ccf5f731bb71db3470002d6baf5ab4792b821d9"}], "stats": {"total": 391, "additions": 159, "deletions": 232}, "files": [{"sha": "ad874be6ee92a53fb0d3cd4b43d04acd6797eda7", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -203,7 +203,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mdpe = MoveDataParamEnv { move_data, param_env };\n \n     let mut flow_inits = MaybeInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def.did.to_def_id())\n+        .into_engine(tcx, &body)\n         .pass_name(\"borrowck\")\n         .iterate_to_fixpoint()\n         .into_results_cursor(&body);\n@@ -221,7 +221,6 @@ fn do_mir_borrowck<'a, 'tcx>(\n         nll_errors,\n     } = nll::compute_regions(\n         infcx,\n-        def.did,\n         free_regions,\n         body,\n         &promoted,\n@@ -242,7 +241,6 @@ fn do_mir_borrowck<'a, 'tcx>(\n     nll::dump_annotation(\n         infcx,\n         &body,\n-        def.did.to_def_id(),\n         &regioncx,\n         &opt_closure_req,\n         &opaque_type_values,\n@@ -257,15 +255,15 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let regioncx = Rc::new(regioncx);\n \n     let flow_borrows = Borrows::new(tcx, &body, regioncx.clone(), &borrow_set)\n-        .into_engine(tcx, &body, def.did.to_def_id())\n+        .into_engine(tcx, &body)\n         .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();\n     let flow_uninits = MaybeUninitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def.did.to_def_id())\n+        .into_engine(tcx, &body)\n         .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();\n     let flow_ever_inits = EverInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def.did.to_def_id())\n+        .into_engine(tcx, &body)\n         .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();\n "}, {"sha": "70f068997b622ccdbaea78dc61c02dff75af3f1f", "filename": "compiler/rustc_mir/src/borrow_check/nll.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -156,7 +156,6 @@ fn populate_polonius_move_facts(\n /// This may result in errors being reported.\n pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    def_id: LocalDefId,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -180,7 +179,6 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n             param_env,\n             body,\n             promoted,\n-            def_id,\n             &universal_regions,\n             location_table,\n             borrow_set,\n@@ -270,10 +268,12 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     // Generate various additional constraints.\n     invalidation::generate_invalidates(infcx.tcx, &mut all_facts, location_table, body, borrow_set);\n \n+    let def_id = body.source.def_id();\n+\n     // Dump facts if requested.\n     let polonius_output = all_facts.and_then(|all_facts| {\n         if infcx.tcx.sess.opts.debugging_opts.nll_facts {\n-            let def_path = infcx.tcx.def_path(def_id.to_def_id());\n+            let def_path = infcx.tcx.def_path(def_id);\n             let dir_path =\n                 PathBuf::from(\"nll-facts\").join(def_path.to_filename_friendly_no_crate());\n             all_facts.write_to_dir(dir_path, location_table).unwrap();\n@@ -293,7 +293,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let (closure_region_requirements, nll_errors) =\n-        regioncx.solve(infcx, &body, def_id.to_def_id(), polonius_output.clone());\n+        regioncx.solve(infcx, &body, def_id, polonius_output.clone());\n \n     if !nll_errors.is_empty() {\n         // Suppress unhelpful extra errors in `infer_opaque_types`.\n@@ -364,14 +364,13 @@ pub(super) fn dump_mir_results<'a, 'tcx>(\n pub(super) fn dump_annotation<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     body: &Body<'tcx>,\n-    mir_def_id: DefId,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n     opaque_type_values: &FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n     errors_buffer: &mut Vec<Diagnostic>,\n ) {\n     let tcx = infcx.tcx;\n-    let base_def_id = tcx.closure_base_def_id(mir_def_id);\n+    let base_def_id = tcx.closure_base_def_id(body.source.def_id());\n     if !tcx.has_attr(base_def_id, sym::rustc_regions) {\n         return;\n     }"}, {"sha": "3c8cbeeca3836553d39c11f4d5d284201d07a98e", "filename": "compiler/rustc_mir/src/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -28,42 +28,43 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let (&normalized_output_ty, normalized_input_tys) =\n             normalized_inputs_and_output.split_last().unwrap();\n \n+        let mir_def_id = body.source.def_id().expect_local();\n+\n         // If the user explicitly annotated the input types, extract\n         // those.\n         //\n         // e.g., `|x: FxHashMap<_, &'static u32>| ...`\n         let user_provided_sig;\n-        if !self.tcx().is_closure(self.mir_def_id.to_def_id()) {\n+        if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n             user_provided_sig = None;\n         } else {\n-            let typeck_results = self.tcx().typeck(self.mir_def_id);\n-            user_provided_sig =\n-                match typeck_results.user_provided_sigs.get(&self.mir_def_id.to_def_id()) {\n-                    None => None,\n-                    Some(user_provided_poly_sig) => {\n-                        // Instantiate the canonicalized variables from\n-                        // user-provided signature (e.g., the `_` in the code\n-                        // above) with fresh variables.\n-                        let (poly_sig, _) =\n-                            self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+            let typeck_results = self.tcx().typeck(mir_def_id);\n+            user_provided_sig = match typeck_results.user_provided_sigs.get(&mir_def_id.to_def_id())\n+            {\n+                None => None,\n+                Some(user_provided_poly_sig) => {\n+                    // Instantiate the canonicalized variables from\n+                    // user-provided signature (e.g., the `_` in the code\n+                    // above) with fresh variables.\n+                    let (poly_sig, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+                        body.span,\n+                        &user_provided_poly_sig,\n+                    );\n+\n+                    // Replace the bound items in the fn sig with fresh\n+                    // variables, so that they represent the view from\n+                    // \"inside\" the closure.\n+                    Some(\n+                        self.infcx\n+                            .replace_bound_vars_with_fresh_vars(\n                                 body.span,\n-                                &user_provided_poly_sig,\n-                            );\n-\n-                        // Replace the bound items in the fn sig with fresh\n-                        // variables, so that they represent the view from\n-                        // \"inside\" the closure.\n-                        Some(\n-                            self.infcx\n-                                .replace_bound_vars_with_fresh_vars(\n-                                    body.span,\n-                                    LateBoundRegionConversionTime::FnCall,\n-                                    &poly_sig,\n-                                )\n-                                .0,\n-                        )\n-                    }\n+                                LateBoundRegionConversionTime::FnCall,\n+                                &poly_sig,\n+                            )\n+                            .0,\n+                    )\n                 }\n+            }\n         };\n \n         debug!(\n@@ -122,7 +123,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if let Err(terr) = self.eq_opaque_type_and_type(\n             mir_output_ty,\n             normalized_output_ty,\n-            self.mir_def_id,\n+            mir_def_id,\n             Locations::All(output_span),\n             ConstraintCategory::BoringNoLocation,\n         ) {\n@@ -145,7 +146,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             if let Err(err) = self.eq_opaque_type_and_type(\n                 mir_output_ty,\n                 user_provided_output_ty,\n-                self.mir_def_id,\n+                mir_def_id,\n                 Locations::All(output_span),\n                 ConstraintCategory::BoringNoLocation,\n             ) {"}, {"sha": "f8a8801595a412342618ca595ba6d284b7c0f830", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -73,7 +73,7 @@ macro_rules! span_mirbug {\n             $context.last_span,\n             &format!(\n                 \"broken MIR in {:?} ({:?}): {}\",\n-                $context.mir_def_id,\n+                $context.body.source.def_id(),\n                 $elem,\n                 format_args!($($message)*),\n             ),\n@@ -113,7 +113,6 @@ mod relate_tys;\n /// - `param_env` -- parameter environment to use for trait solving\n /// - `body` -- MIR body to type-check\n /// - `promoted` -- map of promoted constants within `body`\n-/// - `mir_def_id` -- `LocalDefId` from which the MIR is derived\n /// - `universal_regions` -- the universal regions from `body`s function signature\n /// - `location_table` -- MIR location map of `body`\n /// - `borrow_set` -- information about borrows occurring in `body`\n@@ -126,7 +125,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n-    mir_def_id: LocalDefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n@@ -170,7 +168,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n     let opaque_type_values = type_check_internal(\n         infcx,\n-        mir_def_id,\n         param_env,\n         body,\n         promoted,\n@@ -192,7 +189,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n fn type_check_internal<'a, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    mir_def_id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &'a Body<'tcx>,\n     promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n@@ -205,7 +201,6 @@ fn type_check_internal<'a, 'tcx, R>(\n     let mut checker = TypeChecker::new(\n         infcx,\n         body,\n-        mir_def_id,\n         param_env,\n         region_bound_pairs,\n         implicit_region_bound,\n@@ -272,7 +267,6 @@ struct TypeVerifier<'a, 'b, 'tcx> {\n     body: &'b Body<'tcx>,\n     promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     last_span: Span,\n-    mir_def_id: LocalDefId,\n     errors_reported: bool,\n }\n \n@@ -460,14 +454,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         body: &'b Body<'tcx>,\n         promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     ) -> Self {\n-        TypeVerifier {\n-            body,\n-            promoted,\n-            mir_def_id: cx.mir_def_id,\n-            cx,\n-            last_span: body.span,\n-            errors_reported: false,\n-        }\n+        TypeVerifier { body, promoted, cx, last_span: body.span, errors_reported: false }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -816,7 +803,6 @@ struct TypeChecker<'a, 'tcx> {\n     /// User type annotations are shared between the main MIR and the MIR of\n     /// all of the promoted items.\n     user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n-    mir_def_id: LocalDefId,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n@@ -965,7 +951,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn new(\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         body: &'a Body<'tcx>,\n-        mir_def_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: ty::Region<'tcx>,\n@@ -975,7 +960,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let mut checker = Self {\n             infcx,\n             last_span: DUMMY_SP,\n-            mir_def_id,\n             body,\n             user_type_annotations: &body.user_type_annotations,\n             param_env,\n@@ -1145,7 +1129,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // the resulting inferend values are stored with the\n                 // def-id of the base function.\n                 let parent_def_id =\n-                    self.tcx().closure_base_def_id(self.mir_def_id.to_def_id()).expect_local();\n+                    self.tcx().closure_base_def_id(self.body.source.def_id()).expect_local();\n                 return self.eq_opaque_type_and_type(sub, sup, parent_def_id, locations, category);\n             } else {\n                 return Err(terr);\n@@ -1242,7 +1226,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let concrete_opaque_types = &tcx.typeck(anon_owner_def_id).concrete_opaque_types;\n         let mut opaque_type_values = Vec::new();\n \n-        debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);\n+        debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", body.source.def_id());\n         let opaque_type_map = self.fully_perform_op(\n             locations,\n             category,\n@@ -2001,12 +1985,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let span = body.source_info(location).span;\n                         let ty = operand.ty(body, tcx);\n                         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n-                            let ccx = ConstCx::new_with_param_env(\n-                                tcx,\n-                                self.mir_def_id,\n-                                body,\n-                                self.param_env,\n-                            );\n+                            let ccx = ConstCx::new_with_param_env(tcx, body, self.param_env);\n                             // To determine if `const_in_array_repeat_expressions` feature gate should\n                             // be mentioned, need to check if the rvalue is promotable.\n                             let should_suggest =\n@@ -2015,11 +1994,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 );\n                             debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n \n+                            let def_id = body.source.def_id().expect_local();\n                             self.infcx.report_selection_error(\n                                 &traits::Obligation::new(\n                                     ObligationCause::new(\n                                         span,\n-                                        self.tcx().hir().local_def_id_to_hir_id(self.mir_def_id),\n+                                        self.tcx().hir().local_def_id_to_hir_id(def_id),\n                                         traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n                                     self.param_env,"}, {"sha": "b836e85c3a7e09a1518cba1837a0acf911965234", "filename": "compiler/rustc_mir/src/dataflow/framework/engine.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -81,7 +81,6 @@ where\n {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n-    def_id: DefId,\n     dead_unwinds: Option<&'a BitSet<BasicBlock>>,\n     entry_sets: IndexVec<BasicBlock, A::Domain>,\n     pass_name: Option<&'static str>,\n@@ -103,18 +102,13 @@ where\n     T: Idx,\n {\n     /// Creates a new `Engine` to solve a gen-kill dataflow problem.\n-    pub fn new_gen_kill(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'a mir::Body<'tcx>,\n-        def_id: DefId,\n-        analysis: A,\n-    ) -> Self {\n+    pub fn new_gen_kill(tcx: TyCtxt<'tcx>, body: &'a mir::Body<'tcx>, analysis: A) -> Self {\n         // If there are no back-edges in the control-flow graph, we only ever need to apply the\n         // transfer function for each block exactly once (assuming that we process blocks in RPO).\n         //\n         // In this case, there's no need to compute the block transfer functions ahead of time.\n         if !body.is_cfg_cyclic() {\n-            return Self::new(tcx, body, def_id, analysis, None);\n+            return Self::new(tcx, body, analysis, None);\n         }\n \n         // Otherwise, compute and store the cumulative transfer function for each block.\n@@ -131,7 +125,7 @@ where\n             trans_for_block[bb].apply(state.borrow_mut());\n         });\n \n-        Self::new(tcx, body, def_id, analysis, Some(apply_trans as Box<_>))\n+        Self::new(tcx, body, analysis, Some(apply_trans as Box<_>))\n     }\n }\n \n@@ -145,19 +139,13 @@ where\n     ///\n     /// Gen-kill problems should use `new_gen_kill`, which will coalesce transfer functions for\n     /// better performance.\n-    pub fn new_generic(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'a mir::Body<'tcx>,\n-        def_id: DefId,\n-        analysis: A,\n-    ) -> Self {\n-        Self::new(tcx, body, def_id, analysis, None)\n+    pub fn new_generic(tcx: TyCtxt<'tcx>, body: &'a mir::Body<'tcx>, analysis: A) -> Self {\n+        Self::new(tcx, body, analysis, None)\n     }\n \n     fn new(\n         tcx: TyCtxt<'tcx>,\n         body: &'a mir::Body<'tcx>,\n-        def_id: DefId,\n         analysis: A,\n         apply_trans_for_block: Option<Box<dyn Fn(BasicBlock, &mut A::Domain)>>,\n     ) -> Self {\n@@ -173,7 +161,6 @@ where\n             analysis,\n             tcx,\n             body,\n-            def_id,\n             dead_unwinds: None,\n             pass_name: None,\n             entry_sets,\n@@ -209,7 +196,6 @@ where\n             analysis,\n             body,\n             dead_unwinds,\n-            def_id,\n             mut entry_sets,\n             tcx,\n             apply_trans_for_block,\n@@ -261,7 +247,7 @@ where\n \n         let results = Results { analysis, entry_sets };\n \n-        let res = write_graphviz_results(tcx, def_id, &body, &results, pass_name);\n+        let res = write_graphviz_results(tcx, &body, &results, pass_name);\n         if let Err(e) = res {\n             warn!(\"Failed to write graphviz dataflow results: {}\", e);\n         }\n@@ -276,7 +262,6 @@ where\n /// `rustc_mir` attributes.\n fn write_graphviz_results<A>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n     body: &mir::Body<'tcx>,\n     results: &Results<'tcx, A>,\n     pass_name: Option<&'static str>,\n@@ -285,6 +270,7 @@ where\n     A: Analysis<'tcx>,\n     A::Domain: DebugWithContext<A>,\n {\n+    let def_id = body.source.def_id();\n     let attrs = match RustcMirAttrs::parse(tcx, def_id) {\n         Ok(attrs) => attrs,\n \n@@ -323,7 +309,7 @@ where\n     debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n     let mut buf = Vec::new();\n \n-    let graphviz = graphviz::Formatter::new(body, def_id, results, style);\n+    let graphviz = graphviz::Formatter::new(body, results, style);\n     let mut render_opts =\n         vec![dot::RenderOption::Fontname(tcx.sess.opts.debugging_opts.graphviz_font.clone())];\n     if tcx.sess.opts.debugging_opts.graphviz_dark_mode {"}, {"sha": "4e54257a1cb2d96128db3314699f36cd11513a96", "filename": "compiler/rustc_mir/src/dataflow/framework/graphviz.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -6,7 +6,6 @@ use std::{io, ops, str};\n \n use regex::Regex;\n use rustc_graphviz as dot;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{self, BasicBlock, Body, Location};\n \n use super::fmt::{DebugDiffWithAdapter, DebugWithAdapter, DebugWithContext};\n@@ -33,7 +32,6 @@ where\n     A: Analysis<'tcx>,\n {\n     body: &'a Body<'tcx>,\n-    def_id: DefId,\n     results: &'a Results<'tcx, A>,\n     style: OutputStyle,\n }\n@@ -42,13 +40,8 @@ impl<A> Formatter<'a, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n-    pub fn new(\n-        body: &'a Body<'tcx>,\n-        def_id: DefId,\n-        results: &'a Results<'tcx, A>,\n-        style: OutputStyle,\n-    ) -> Self {\n-        Formatter { body, def_id, results, style }\n+    pub fn new(body: &'a Body<'tcx>, results: &'a Results<'tcx, A>, style: OutputStyle) -> Self {\n+        Formatter { body, results, style }\n     }\n }\n \n@@ -77,7 +70,7 @@ where\n     type Edge = CfgEdge;\n \n     fn graph_id(&self) -> dot::Id<'_> {\n-        let name = graphviz_safe_def_name(self.def_id);\n+        let name = graphviz_safe_def_name(self.body.source.def_id());\n         dot::Id::new(format!(\"graph_for_def_id_{}\", name)).unwrap()\n     }\n "}, {"sha": "524ad0af1a7b45d4c85de9b6404deeca35bc6730", "filename": "compiler/rustc_mir/src/dataflow/framework/mod.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fmod.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -13,9 +13,9 @@\n //! ```ignore(cross-crate-imports)\n //! use rustc_mir::dataflow::Analysis; // Makes `into_engine` available.\n //!\n-//! fn do_my_analysis(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>, did: DefId) {\n+//! fn do_my_analysis(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>) {\n //!     let analysis = MyAnalysis::new()\n-//!         .into_engine(tcx, body, did)\n+//!         .into_engine(tcx, body)\n //!         .iterate_to_fixpoint()\n //!         .into_results_cursor(body);\n //!\n@@ -33,7 +33,6 @@\n use std::borrow::BorrowMut;\n use std::cmp::Ordering;\n \n-use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, BasicBlock, Location};\n@@ -218,16 +217,11 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     ///     .iterate_to_fixpoint()\n     ///     .into_results_cursor(body);\n     /// ```\n-    fn into_engine(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        body: &'mir mir::Body<'tcx>,\n-        def_id: DefId,\n-    ) -> Engine<'mir, 'tcx, Self>\n+    fn into_engine(self, tcx: TyCtxt<'tcx>, body: &'mir mir::Body<'tcx>) -> Engine<'mir, 'tcx, Self>\n     where\n         Self: Sized,\n     {\n-        Engine::new_generic(tcx, body, def_id, self)\n+        Engine::new_generic(tcx, body, self)\n     }\n }\n \n@@ -381,16 +375,11 @@ where\n \n     /* Extension methods */\n \n-    fn into_engine(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        body: &'mir mir::Body<'tcx>,\n-        def_id: DefId,\n-    ) -> Engine<'mir, 'tcx, Self>\n+    fn into_engine(self, tcx: TyCtxt<'tcx>, body: &'mir mir::Body<'tcx>) -> Engine<'mir, 'tcx, Self>\n     where\n         Self: Sized,\n     {\n-        Engine::new_gen_kill(tcx, body, def_id, self)\n+        Engine::new_gen_kill(tcx, body, self)\n     }\n }\n "}, {"sha": "417e0a51aecf0e268415b10960cb1c73356dfdd8", "filename": "compiler/rustc_mir/src/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -1,4 +1,3 @@\n-use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n \n@@ -42,20 +41,17 @@ pub struct AddMovesForPackedDrops;\n impl<'tcx> MirPass<'tcx> for AddMovesForPackedDrops {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", body.source, body.span);\n-        add_moves_for_packed_drops(tcx, body, body.source.def_id());\n+        add_moves_for_packed_drops(tcx, body);\n     }\n }\n \n-pub fn add_moves_for_packed_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, def_id: DefId) {\n-    let patch = add_moves_for_packed_drops_patch(tcx, body, def_id);\n+pub fn add_moves_for_packed_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let patch = add_moves_for_packed_drops_patch(tcx, body);\n     patch.apply(body);\n }\n \n-fn add_moves_for_packed_drops_patch<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    def_id: DefId,\n-) -> MirPatch<'tcx> {\n+fn add_moves_for_packed_drops_patch<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) -> MirPatch<'tcx> {\n+    let def_id = body.source.def_id();\n     let mut patch = MirPatch::new(body);\n     let param_env = tcx.param_env(def_id);\n "}, {"sha": "33815ceba620b383005a05a5917d17437a617794", "filename": "compiler/rustc_mir/src/transform/check_consts/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -24,25 +24,28 @@ pub mod validation;\n pub struct ConstCx<'mir, 'tcx> {\n     pub body: &'mir mir::Body<'tcx>,\n     pub tcx: TyCtxt<'tcx>,\n-    pub def_id: LocalDefId,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub const_kind: Option<hir::ConstContext>,\n }\n \n impl ConstCx<'mir, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'mir mir::Body<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'mir mir::Body<'tcx>) -> Self {\n+        let def_id = body.source.def_id().expect_local();\n         let param_env = tcx.param_env(def_id);\n-        Self::new_with_param_env(tcx, def_id, body, param_env)\n+        Self::new_with_param_env(tcx, body, param_env)\n     }\n \n     pub fn new_with_param_env(\n         tcx: TyCtxt<'tcx>,\n-        def_id: LocalDefId,\n         body: &'mir mir::Body<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n-        let const_kind = tcx.hir().body_const_context(def_id);\n-        ConstCx { body, tcx, def_id: def_id, param_env, const_kind }\n+        let const_kind = tcx.hir().body_const_context(body.source.def_id().expect_local());\n+        ConstCx { body, tcx, param_env, const_kind }\n+    }\n+\n+    pub fn def_id(&self) -> LocalDefId {\n+        self.body.source.def_id().expect_local()\n     }\n \n     /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.).\n@@ -55,7 +58,7 @@ impl ConstCx<'mir, 'tcx> {\n     pub fn is_const_stable_const_fn(&self) -> bool {\n         self.const_kind == Some(hir::ConstContext::ConstFn)\n             && self.tcx.features().staged_api\n-            && is_const_stable_const_fn(self.tcx, self.def_id.to_def_id())\n+            && is_const_stable_const_fn(self.tcx, self.def_id().to_def_id())\n     }\n \n     /// Returns the function signature of the item being const-checked if it is a `fn` or `const fn`.\n@@ -64,7 +67,7 @@ impl ConstCx<'mir, 'tcx> {\n         //\n         // FIXME: Is this still an issue?\n         let hir_map = self.tcx.hir();\n-        let hir_id = hir_map.local_def_id_to_hir_id(self.def_id);\n+        let hir_id = hir_map.local_def_id_to_hir_id(self.def_id());\n         hir_map.fn_sig_by_hir_id(hir_id)\n     }\n }"}, {"sha": "1a2d932ba19054f03f8b2285e715a2b710ea7b55", "filename": "compiler/rustc_mir/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -1,4 +1,3 @@\n-use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Location};\n use rustc_middle::ty::TyCtxt;\n@@ -24,13 +23,14 @@ pub fn checking_enabled(ccx: &ConstCx<'_, '_>) -> bool {\n ///\n /// This is separate from the rest of the const checking logic because it must run after drop\n /// elaboration.\n-pub fn check_live_drops(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &mir::Body<'tcx>) {\n+pub fn check_live_drops(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>) {\n+    let def_id = body.source.def_id().expect_local();\n     let const_kind = tcx.hir().body_const_context(def_id);\n     if const_kind.is_none() {\n         return;\n     }\n \n-    let ccx = ConstCx { body, tcx, def_id, const_kind, param_env: tcx.param_env(def_id) };\n+    let ccx = ConstCx { body, tcx, const_kind, param_env: tcx.param_env(def_id) };\n     if !checking_enabled(&ccx) {\n         return;\n     }"}, {"sha": "b3d9beb3742b2add43b541a9c734a45abcf07ee6", "filename": "compiler/rustc_mir/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -126,7 +126,7 @@ impl Qualif for CustomEq {\n         // because that component may be part of an enum variant (e.g.,\n         // `Option::<NonStructuralMatchTy>::Some`), in which case some values of this type may be\n         // structural-match (`Option::None`).\n-        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id);\n+        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id());\n         traits::search_for_structural_match_violation(id, cx.body.span, cx.tcx, ty).is_some()\n     }\n "}, {"sha": "b3e94ccde52e07978734ee00fed46464eb87094d", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -50,7 +50,7 @@ impl Qualifs<'mir, 'tcx> {\n         location: Location,\n     ) -> bool {\n         let indirectly_mutable = self.indirectly_mutable.get_or_insert_with(|| {\n-            let ConstCx { tcx, body, def_id, param_env, .. } = *ccx;\n+            let ConstCx { tcx, body, param_env, .. } = *ccx;\n \n             // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n             // allowed in a const.\n@@ -59,7 +59,7 @@ impl Qualifs<'mir, 'tcx> {\n             // without breaking stable code?\n             MaybeMutBorrowedLocals::mut_borrows_only(tcx, &body, param_env)\n                 .unsound_ignore_borrow_on_drop()\n-                .into_engine(tcx, &body, def_id.to_def_id())\n+                .into_engine(tcx, &body)\n                 .pass_name(\"const_qualification\")\n                 .iterate_to_fixpoint()\n                 .into_results_cursor(&body)\n@@ -84,10 +84,10 @@ impl Qualifs<'mir, 'tcx> {\n         }\n \n         let needs_drop = self.needs_drop.get_or_insert_with(|| {\n-            let ConstCx { tcx, body, def_id, .. } = *ccx;\n+            let ConstCx { tcx, body, .. } = *ccx;\n \n             FlowSensitiveAnalysis::new(NeedsDrop, ccx)\n-                .into_engine(tcx, &body, def_id.to_def_id())\n+                .into_engine(tcx, &body)\n                 .iterate_to_fixpoint()\n                 .into_results_cursor(&body)\n         });\n@@ -111,10 +111,10 @@ impl Qualifs<'mir, 'tcx> {\n         }\n \n         let has_mut_interior = self.has_mut_interior.get_or_insert_with(|| {\n-            let ConstCx { tcx, body, def_id, .. } = *ccx;\n+            let ConstCx { tcx, body, .. } = *ccx;\n \n             FlowSensitiveAnalysis::new(HasMutInterior, ccx)\n-                .into_engine(tcx, &body, def_id.to_def_id())\n+                .into_engine(tcx, &body)\n                 .iterate_to_fixpoint()\n                 .into_results_cursor(&body)\n         });\n@@ -157,7 +157,7 @@ impl Qualifs<'mir, 'tcx> {\n \n             hir::ConstContext::Const | hir::ConstContext::Static(_) => {\n                 let mut cursor = FlowSensitiveAnalysis::new(CustomEq, ccx)\n-                    .into_engine(ccx.tcx, &ccx.body, ccx.def_id.to_def_id())\n+                    .into_engine(ccx.tcx, &ccx.body)\n                     .iterate_to_fixpoint()\n                     .into_results_cursor(&ccx.body);\n \n@@ -205,7 +205,8 @@ impl Validator<'mir, 'tcx> {\n     }\n \n     pub fn check_body(&mut self) {\n-        let ConstCx { tcx, body, def_id, .. } = *self.ccx;\n+        let ConstCx { tcx, body, .. } = *self.ccx;\n+        let def_id = self.ccx.def_id();\n \n         // `async` functions cannot be `const fn`. This is checked during AST lowering, so there's\n         // no need to emit duplicate errors here.\n@@ -219,7 +220,7 @@ impl Validator<'mir, 'tcx> {\n             // Prevent const trait methods from being annotated as `stable`.\n             // FIXME: Do this as part of stability checking.\n             if self.is_const_stable_const_fn() {\n-                let hir_id = tcx.hir().local_def_id_to_hir_id(self.def_id);\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                 if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n                     struct_span_err!(\n                         self.ccx.tcx.sess,\n@@ -291,7 +292,7 @@ impl Validator<'mir, 'tcx> {\n \n             Status::Unstable(gate) if self.tcx.features().enabled(gate) => {\n                 let unstable_in_stable = self.ccx.is_const_stable_const_fn()\n-                    && !super::allow_internal_unstable(self.tcx, self.def_id.to_def_id(), gate);\n+                    && !super::allow_internal_unstable(self.tcx, self.def_id().to_def_id(), gate);\n                 if unstable_in_stable {\n                     emit_unstable_in_stable_error(self.ccx, span, gate);\n                 }\n@@ -367,9 +368,9 @@ impl Validator<'mir, 'tcx> {\n     }\n \n     fn check_item_predicates(&mut self) {\n-        let ConstCx { tcx, def_id, .. } = *self.ccx;\n+        let ConstCx { tcx, .. } = *self.ccx;\n \n-        let mut current = def_id.to_def_id();\n+        let mut current = self.def_id().to_def_id();\n         loop {\n             let predicates = tcx.predicates_of(current);\n             for (predicate, _) in predicates.predicates {\n@@ -734,8 +735,8 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n         match &terminator.kind {\n             TerminatorKind::Call { func, .. } => {\n-                let ConstCx { tcx, body, def_id: caller, param_env, .. } = *self.ccx;\n-                let caller = caller.to_def_id();\n+                let ConstCx { tcx, body, param_env, .. } = *self.ccx;\n+                let caller = self.def_id().to_def_id();\n \n                 let fn_ty = func.ty(body, tcx);\n "}, {"sha": "410f462ed469fbc0e1394d98ad31bc744558d76d", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -408,15 +408,12 @@ impl Conflicts<'a> {\n             body.local_decls.len(),\n         );\n \n-        let def_id = body.source.def_id();\n         let mut init = MaybeInitializedLocals\n-            .into_engine(tcx, body, def_id)\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(body);\n-        let mut live = MaybeLiveLocals\n-            .into_engine(tcx, body, def_id)\n+            .into_engine(tcx, body)\n             .iterate_to_fixpoint()\n             .into_results_cursor(body);\n+        let mut live =\n+            MaybeLiveLocals.into_engine(tcx, body).iterate_to_fixpoint().into_results_cursor(body);\n \n         let mut reachable = None;\n         dump_mir(tcx, None, \"DestinationPropagation-dataflow\", &\"\", body, |pass_where, w| {"}, {"sha": "3d435f6d0e75a4b0b7ea311f2762f9fa093b2f7a", "filename": "compiler/rustc_mir/src/transform/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Felaborate_drops.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -10,7 +10,6 @@ use crate::util::elaborate_drops::{elaborate_drop, DropFlagState, Unwind};\n use crate::util::elaborate_drops::{DropElaborator, DropFlagMode, DropStyle};\n use crate::util::patch::MirPatch;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -39,18 +38,18 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n         let elaborate_patch = {\n             let body = &*body;\n             let env = MoveDataParamEnv { move_data, param_env };\n-            let dead_unwinds = find_dead_unwinds(tcx, body, def_id, &env);\n+            let dead_unwinds = find_dead_unwinds(tcx, body, &env);\n \n             let inits = MaybeInitializedPlaces::new(tcx, body, &env)\n-                .into_engine(tcx, body, def_id)\n+                .into_engine(tcx, body)\n                 .dead_unwinds(&dead_unwinds)\n                 .pass_name(\"elaborate_drops\")\n                 .iterate_to_fixpoint()\n                 .into_results_cursor(body);\n \n             let uninits = MaybeUninitializedPlaces::new(tcx, body, &env)\n                 .mark_inactive_variants_as_uninit()\n-                .into_engine(tcx, body, def_id)\n+                .into_engine(tcx, body)\n                 .dead_unwinds(&dead_unwinds)\n                 .pass_name(\"elaborate_drops\")\n                 .iterate_to_fixpoint()\n@@ -76,15 +75,14 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n fn find_dead_unwinds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    def_id: hir::def_id::DefId,\n     env: &MoveDataParamEnv<'tcx>,\n ) -> BitSet<BasicBlock> {\n     debug!(\"find_dead_unwinds({:?})\", body.span);\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n     let mut dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let mut flow_inits = MaybeInitializedPlaces::new(tcx, body, &env)\n-        .into_engine(tcx, body, def_id)\n+        .into_engine(tcx, body)\n         .pass_name(\"find_dead_unwinds\")\n         .iterate_to_fixpoint()\n         .into_results_cursor(body);"}, {"sha": "924bb4996fc358ac28ae53280c936b3aeda79cca", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -61,7 +61,6 @@ use crate::util::expand_aggregate;\n use crate::util::storage;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::{BitMatrix, BitSet};\n use rustc_index::vec::{Idx, IndexVec};\n@@ -454,20 +453,19 @@ fn locals_live_across_suspend_points(\n     always_live_locals: &storage::AlwaysLiveLocals,\n     movable: bool,\n ) -> LivenessInfo {\n-    let def_id = body.source.def_id();\n     let body_ref: &Body<'_> = &body;\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n     let mut storage_live = MaybeStorageLive::new(always_live_locals.clone())\n-        .into_engine(tcx, body_ref, def_id)\n+        .into_engine(tcx, body_ref)\n         .iterate_to_fixpoint()\n         .into_results_cursor(body_ref);\n \n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n     let borrowed_locals_results = MaybeBorrowedLocals::all_borrows()\n-        .into_engine(tcx, body_ref, def_id)\n+        .into_engine(tcx, body_ref)\n         .pass_name(\"generator\")\n         .iterate_to_fixpoint();\n \n@@ -477,14 +475,14 @@ fn locals_live_across_suspend_points(\n     // Calculate the MIR locals that we actually need to keep storage around\n     // for.\n     let requires_storage_results = MaybeRequiresStorage::new(body, &borrowed_locals_results)\n-        .into_engine(tcx, body_ref, def_id)\n+        .into_engine(tcx, body_ref)\n         .iterate_to_fixpoint();\n     let mut requires_storage_cursor =\n         dataflow::ResultsCursor::new(body_ref, &requires_storage_results);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n     let mut liveness = MaybeLiveLocals\n-        .into_engine(tcx, body_ref, def_id)\n+        .into_engine(tcx, body_ref)\n         .pass_name(\"generator\")\n         .iterate_to_fixpoint()\n         .into_results_cursor(body_ref);\n@@ -722,11 +720,11 @@ impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n fn sanitize_witness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    did: DefId,\n     witness: Ty<'tcx>,\n     upvars: &Vec<Ty<'tcx>>,\n     saved_locals: &GeneratorSavedLocals,\n ) {\n+    let did = body.source.def_id();\n     let allowed_upvars = tcx.erase_regions(upvars);\n     let allowed = match witness.kind() {\n         ty::GeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n@@ -865,7 +863,7 @@ fn insert_switch<'tcx>(\n     }\n }\n \n-fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut Body<'tcx>) {\n+fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     use crate::shim::DropShimElaborator;\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n     use crate::util::patch::MirPatch;\n@@ -874,6 +872,7 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n     // this is ok because `open_drop` can only be reached within that own\n     // generator's resume function.\n \n+    let def_id = body.source.def_id();\n     let param_env = tcx.param_env(def_id);\n \n     let mut elaborator = DropShimElaborator { body, patch: MirPatch::new(body), tcx, param_env };\n@@ -1246,8 +1245,6 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         assert!(body.generator_drop.is_none());\n \n-        let def_id = body.source.def_id();\n-\n         // The first argument is the generator type passed by value\n         let gen_ty = body.local_decls.raw[1].ty;\n \n@@ -1306,7 +1303,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         let liveness_info =\n             locals_live_across_suspend_points(tcx, body, &always_live_locals, movable);\n \n-        sanitize_witness(tcx, body, def_id, interior, &upvars, &liveness_info.saved_locals);\n+        sanitize_witness(tcx, body, interior, &upvars, &liveness_info.saved_locals);\n \n         if tcx.sess.opts.debugging_opts.validate_mir {\n             let mut vis = EnsureGeneratorFieldAssignmentsNeverAlias {\n@@ -1358,7 +1355,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n         // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n         // However we need to also elaborate the code generated by `insert_clean_drop`.\n-        elaborate_generator_drops(tcx, def_id, body);\n+        elaborate_generator_drops(tcx, body);\n \n         dump_mir(tcx, None, \"generator_post-transform\", &0, body, |_, _| Ok(()));\n "}, {"sha": "b4f5947f5a339aa0c07f0433c63e2fce1a7dcab6", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -229,13 +229,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) ->\n         return Default::default();\n     }\n \n-    let ccx = check_consts::ConstCx {\n-        body,\n-        tcx,\n-        def_id: def.did,\n-        const_kind,\n-        param_env: tcx.param_env(def.did),\n-    };\n+    let ccx = check_consts::ConstCx { body, tcx, const_kind, param_env: tcx.param_env(def.did) };\n \n     let mut validator = check_consts::validation::Validator::new(&ccx);\n     validator.check_body();\n@@ -346,7 +340,7 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n     let mut body = body.steal();\n \n     run_post_borrowck_cleanup_passes(tcx, &mut body);\n-    check_consts::post_drop_elaboration::check_live_drops(tcx, def.did, &body);\n+    check_consts::post_drop_elaboration::check_live_drops(tcx, &body);\n     tcx.alloc_steal_mir(body)\n }\n "}, {"sha": "5fd471286317245a7dfedbd53776d944e362c8bd", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n         let def = body.source.with_opt_param().expect_local();\n \n         let mut rpo = traversal::reverse_postorder(body);\n-        let ccx = ConstCx::new(tcx, def.did, body);\n+        let ccx = ConstCx::new(tcx, body);\n         let (temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n \n         let promotable_candidates = validate_candidates(&ccx, &temps, &all_candidates);\n@@ -758,7 +758,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             ty::FnDef(def_id, _) => {\n                 is_const_fn(self.tcx, def_id)\n                     || is_unstable_const_fn(self.tcx, def_id).is_some()\n-                    || is_lang_panic_fn(self.tcx, self.def_id.to_def_id())\n+                    || is_lang_panic_fn(self.tcx, def_id)\n             }\n             _ => false,\n         };\n@@ -1250,7 +1250,9 @@ crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n     debug!(\n         \"should_suggest_const_in_array_repeat_expressions_flag: def_id={:?} \\\n             should_promote={:?} feature_flag={:?}\",\n-        validator.ccx.def_id, should_promote, feature_flag\n+        validator.ccx.def_id(),\n+        should_promote,\n+        feature_flag\n     );\n     should_promote && !feature_flag\n }"}, {"sha": "aaf3ecab4dca728ac3302d78f0fc7a0307369a14", "filename": "compiler/rustc_mir/src/transform/remove_unneeded_drops.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_unneeded_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_unneeded_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_unneeded_drops.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -1,10 +1,9 @@\n //! This pass replaces a drop of a type that does not need dropping, with a goto\n \n use crate::transform::MirPass;\n-use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{ParamEnv, TyCtxt};\n \n use super::simplify::simplify_cfg;\n \n@@ -16,8 +15,8 @@ impl<'tcx> MirPass<'tcx> for RemoveUnneededDrops {\n         let mut opt_finder = RemoveUnneededDropsOptimizationFinder {\n             tcx,\n             body,\n+            param_env: tcx.param_env(body.source.def_id()),\n             optimizations: vec![],\n-            def_id: body.source.def_id().expect_local(),\n         };\n         opt_finder.visit_body(body);\n         let should_simplify = !opt_finder.optimizations.is_empty();\n@@ -40,7 +39,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RemoveUnneededDropsOptimizationFinder<'a, 'tcx>\n         match terminator.kind {\n             TerminatorKind::Drop { place, target, .. } => {\n                 let ty = place.ty(self.body, self.tcx);\n-                let needs_drop = ty.ty.needs_drop(self.tcx, self.tcx.param_env(self.def_id));\n+                let needs_drop = ty.ty.needs_drop(self.tcx, self.param_env);\n                 if !needs_drop {\n                     self.optimizations.push((location, target));\n                 }\n@@ -54,5 +53,5 @@ pub struct RemoveUnneededDropsOptimizationFinder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     optimizations: Vec<(Location, BasicBlock)>,\n-    def_id: LocalDefId,\n+    param_env: ParamEnv<'tcx>,\n }"}, {"sha": "205f718d6e446a2ba007593ab7f1960093e0625d", "filename": "compiler/rustc_mir/src/transform/rustc_peek.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -6,7 +6,6 @@ use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n use crate::transform::MirPass;\n-use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, Body, Local, Location};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -41,41 +40,40 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n \n         if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_maybe_init).is_some() {\n             let flow_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n-                .into_engine(tcx, body, def_id)\n+                .into_engine(tcx, body)\n                 .iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_inits);\n+            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_inits);\n         }\n \n         if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_maybe_uninit).is_some() {\n             let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &mdpe)\n-                .into_engine(tcx, body, def_id)\n+                .into_engine(tcx, body)\n                 .iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_uninits);\n+            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_uninits);\n         }\n \n         if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_definite_init).is_some() {\n             let flow_def_inits = DefinitelyInitializedPlaces::new(tcx, body, &mdpe)\n-                .into_engine(tcx, body, def_id)\n+                .into_engine(tcx, body)\n                 .iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n+            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_def_inits);\n         }\n \n         if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n             let flow_mut_borrowed = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n-                .into_engine(tcx, body, def_id)\n+                .into_engine(tcx, body)\n                 .iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_mut_borrowed);\n+            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_mut_borrowed);\n         }\n \n         if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_liveness).is_some() {\n-            let flow_liveness =\n-                MaybeLiveLocals.into_engine(tcx, body, def_id).iterate_to_fixpoint();\n+            let flow_liveness = MaybeLiveLocals.into_engine(tcx, body).iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_liveness);\n+            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_liveness);\n         }\n \n         if has_rustc_mir_with(sess, &attributes, sym::stop_after_dataflow).is_some() {\n@@ -103,12 +101,12 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n pub fn sanity_check_via_rustc_peek<'tcx, A>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    def_id: DefId,\n     _attributes: &[ast::Attribute],\n     results: &Results<'tcx, A>,\n ) where\n     A: RustcPeekAt<'tcx>,\n {\n+    let def_id = body.source.def_id();\n     debug!(\"sanity_check_via_rustc_peek def_id: {:?}\", def_id);\n \n     let mut cursor = ResultsCursor::new(body, results);"}, {"sha": "cf51e86c5bc8f1e223600bd76f100ba591a90fc0", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> MirPass<'tcx> for Validator {\n \n         let always_live_locals = AlwaysLiveLocals::new(body);\n         let storage_liveness = MaybeStorageLive::new(always_live_locals)\n-            .into_engine(tcx, body, def_id)\n+            .into_engine(tcx, body)\n             .iterate_to_fixpoint()\n             .into_results_cursor(body);\n "}, {"sha": "0c32161fce5a0eb03f07fa878c80d0bc8d5bc662", "filename": "compiler/rustc_mir/src/util/graphviz.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -72,16 +72,16 @@ where\n     writeln!(w, r#\"    edge [{}];\"#, content_attrs_str)?;\n \n     // Graph label\n-    write_graph_label(tcx, def_id, body, w)?;\n+    write_graph_label(tcx, body, w)?;\n \n     // Nodes\n     for (block, _) in body.basic_blocks().iter_enumerated() {\n-        write_node(def_id, block, body, dark_mode, w)?;\n+        write_node(block, body, dark_mode, w)?;\n     }\n \n     // Edges\n     for (source, _) in body.basic_blocks().iter_enumerated() {\n-        write_edges(def_id, source, body, w)?;\n+        write_edges(source, body, w)?;\n     }\n     writeln!(w, \"}}\")\n }\n@@ -145,12 +145,12 @@ where\n \n /// Write a graphviz DOT node for the given basic block.\n fn write_node<W: Write>(\n-    def_id: DefId,\n     block: BasicBlock,\n     body: &Body<'_>,\n     dark_mode: bool,\n     w: &mut W,\n ) -> io::Result<()> {\n+    let def_id = body.source.def_id();\n     // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n     write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(def_id, block))?;\n     write_node_label(block, body, dark_mode, w, 1, |_| Ok(()), |_| Ok(()))?;\n@@ -159,12 +159,8 @@ fn write_node<W: Write>(\n }\n \n /// Write graphviz DOT edges with labels between the given basic block and all of its successors.\n-fn write_edges<W: Write>(\n-    def_id: DefId,\n-    source: BasicBlock,\n-    body: &Body<'_>,\n-    w: &mut W,\n-) -> io::Result<()> {\n+fn write_edges<W: Write>(source: BasicBlock, body: &Body<'_>, w: &mut W) -> io::Result<()> {\n+    let def_id = body.source.def_id();\n     let terminator = body[source].terminator();\n     let labels = terminator.kind.fmt_successor_labels();\n \n@@ -182,10 +178,11 @@ fn write_edges<W: Write>(\n /// all the variables and temporaries.\n fn write_graph_label<'tcx, W: Write>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n     body: &Body<'_>,\n     w: &mut W,\n ) -> io::Result<()> {\n+    let def_id = body.source.def_id();\n+\n     write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.def_path_str(def_id)))?;\n \n     // fn argument types."}, {"sha": "c00c3b740edb394333b9ef5ab5b635b9dc89c6bd", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -153,7 +153,7 @@ fn dump_matched_mir_node<'tcx, F>(\n             let mut file =\n                 create_dump_file(tcx, \"html\", pass_num, pass_name, disambiguator, body.source)?;\n             if body.source.def_id().is_local() {\n-                write_mir_fn_spanview(tcx, body.source.def_id(), body, spanview, &mut file)?;\n+                write_mir_fn_spanview(tcx, body, spanview, &mut file)?;\n             }\n         };\n     }"}, {"sha": "fdc724178b68cd146b13fadb8689a38917a78b43", "filename": "compiler/rustc_mir/src/util/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -90,14 +90,14 @@ pub struct SpanViewable {\n /// Write a spanview HTML+CSS file to analyze MIR element spans.\n pub fn write_mir_fn_spanview<'tcx, W>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n     body: &Body<'tcx>,\n     spanview: MirSpanview,\n     w: &mut W,\n ) -> io::Result<()>\n where\n     W: Write,\n {\n+    let def_id = body.source.def_id();\n     let body_span = hir_body(tcx, def_id).value.span;\n     let mut span_viewables = Vec::new();\n     for (bb, data) in body.basic_blocks().iter_enumerated() {"}, {"sha": "e79f90b5f7a24d0165041fac2679d3115519c5a1", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -205,7 +205,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        lints::check(tcx, &body, def.did);\n+        lints::check(tcx, &body);\n \n         // The borrow checker will replace all the regions here with its own\n         // inference variables. There's no point having non-erased regions here."}, {"sha": "bdef02a011bac04fd64962d5743bfed3afea3d7f", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72e43c730a205237cacb8e9a7928ca0a0746252/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=e72e43c730a205237cacb8e9a7928ca0a0746252", "patch": "@@ -1,7 +1,6 @@\n use rustc_data_structures::graph::iterate::{\n     ControlFlow, NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n-use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::FnKind;\n use rustc_middle::hir::map::blocks::FnLikeNode;\n use rustc_middle::mir::{BasicBlock, Body, Operand, TerminatorKind};\n@@ -10,7 +9,8 @@ use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc_span::Span;\n \n-crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: LocalDefId) {\n+crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n+    let def_id = body.source.def_id().expect_local();\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n@@ -30,7 +30,7 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: LocalDefId) {\n             _ => &[],\n         };\n \n-        let mut vis = Search { tcx, body, def_id, reachable_recursive_calls: vec![], trait_substs };\n+        let mut vis = Search { tcx, body, reachable_recursive_calls: vec![], trait_substs };\n         if let Some(NonRecursive) = TriColorDepthFirstSearch::new(&body).run_from_start(&mut vis) {\n             return;\n         }\n@@ -57,7 +57,6 @@ struct NonRecursive;\n struct Search<'mir, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'mir Body<'tcx>,\n-    def_id: LocalDefId,\n     trait_substs: &'tcx [GenericArg<'tcx>],\n \n     reachable_recursive_calls: Vec<Span>,\n@@ -66,16 +65,17 @@ struct Search<'mir, 'tcx> {\n impl<'mir, 'tcx> Search<'mir, 'tcx> {\n     /// Returns `true` if `func` refers to the function we are searching in.\n     fn is_recursive_call(&self, func: &Operand<'tcx>) -> bool {\n-        let Search { tcx, body, def_id, trait_substs, .. } = *self;\n-        let param_env = tcx.param_env(def_id);\n+        let Search { tcx, body, trait_substs, .. } = *self;\n+        let caller = body.source.def_id();\n+        let param_env = tcx.param_env(caller);\n \n         let func_ty = func.ty(body, tcx);\n-        if let ty::FnDef(fn_def_id, substs) = *func_ty.kind() {\n-            let (call_fn_id, call_substs) =\n-                if let Ok(Some(instance)) = Instance::resolve(tcx, param_env, fn_def_id, substs) {\n+        if let ty::FnDef(callee, substs) = *func_ty.kind() {\n+            let (callee, call_substs) =\n+                if let Ok(Some(instance)) = Instance::resolve(tcx, param_env, callee, substs) {\n                     (instance.def_id(), instance.substs)\n                 } else {\n-                    (fn_def_id, substs)\n+                    (callee, substs)\n                 };\n \n             // FIXME(#57965): Make this work across function boundaries\n@@ -84,8 +84,7 @@ impl<'mir, 'tcx> Search<'mir, 'tcx> {\n             // calling into an entirely different method (for example, a call from the default\n             // method in the trait to `<A as Trait<B>>::method`, where `A` and/or `B` are\n             // specific types).\n-            return call_fn_id == def_id.to_def_id()\n-                && &call_substs[..trait_substs.len()] == trait_substs;\n+            return callee == caller && &call_substs[..trait_substs.len()] == trait_substs;\n         }\n \n         false"}]}