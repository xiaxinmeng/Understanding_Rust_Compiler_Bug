{"sha": "b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YjZiZTBhYjdjNTAwNzgyYzVmNGQ1NTE2NmQwOWZhMDJmODEwM2U=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2020-01-14T05:10:05Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2020-01-28T13:12:53Z"}, "message": "Local field on PlaceRef and RootPlace is not a reference anymore", "tree": {"sha": "428329680d6a46f3124d709b36fef016e6d05ad1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/428329680d6a46f3124d709b36fef016e6d05ad1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAl4wM1UACgkQiMlBzaHU\nZDLjCQ/+IqxfiV1B1X4qtaKiVHfwtcOgbXmaLx1SP8C/mVH1QIJXTz/NpJxMfDCe\n9eJGzCSfU8u0ZaM/y2VNrOW412zzFvCw1YCGYYrpg3ByVdRAgjiN5rBQxR9Fvlps\nv70I8qHH38SOB6ZoZ0ZVH9EPkwoGt2mPZ510k979sDpkTANte0LgxGbnqZh4lJMB\nd3oTzvwrZgsWCcLRfv12S3+KxLmnPPFZM75JNSX6qc42SqcC2HbdhVVH1GiYHE8C\nQXliAH1hcY4LTYoG6MRQxSZJfC8JfWqMTET6G6cA5k1i6MBuyj7KA1N9q1twZAg7\nbEb9zaeV3B9mGjh5a+4H9K5JrTUGodMB52PuQJkFh8tx/PIEFMD3tF5MYuXfdNug\nVQRQ1jAlMx11P7PLgGYzkQ+cEQH2S2FQZ9NNQyynAecU0B3MfOfl6VaYRnHFPs2L\ngdbwjUXwp2bm5vbPRD5/l1IYNwYlYbHJBWHIJ5ujj6u8mKbk59j49h70UGfF4ntV\nhrksq3qWz45KSkWtoDCVn1EmjpCURqrDwUevb0kdubx4kFcaD7J4PNZYKUmFL/wl\nmQ6ug5EmNisMHahEsaPhRbEzEtfzhAsEl+uRzDAmpM2t4u55UbssB8oXVFBrRwym\nLzuL++Le51y4gMhbsz4U/1u3d9ceua0+/Vo0yXeKDOpHoGQSQM0=\n=9Rgr\n-----END PGP SIGNATURE-----", "payload": "tree 428329680d6a46f3124d709b36fef016e6d05ad1\nparent 39d93b1ef8f3e985039a0878e539c7a9ee621a32\nauthor Santiago Pastorino <spastorino@gmail.com> 1578978605 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1580217173 -0300\n\nLocal field on PlaceRef and RootPlace is not a reference anymore\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "html_url": "https://github.com/rust-lang/rust/commit/b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39d93b1ef8f3e985039a0878e539c7a9ee621a32", "url": "https://api.github.com/repos/rust-lang/rust/commits/39d93b1ef8f3e985039a0878e539c7a9ee621a32", "html_url": "https://github.com/rust-lang/rust/commit/39d93b1ef8f3e985039a0878e539c7a9ee621a32"}], "stats": {"total": 180, "additions": 90, "deletions": 90}, "files": [{"sha": "d4f8bc98358d24a6e90c7b306635446a7b73d4c6", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -1773,7 +1773,7 @@ rustc_index::newtype_index! {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct PlaceRef<'a, 'tcx> {\n-    pub local: &'a Local,\n+    pub local: Local,\n     pub projection: &'a [PlaceElem<'tcx>],\n }\n \n@@ -1798,7 +1798,7 @@ impl<'tcx> Place<'tcx> {\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self.as_ref() {\n             PlaceRef { local, projection: &[] }\n-            | PlaceRef { local, projection: &[ProjectionElem::Deref] } => Some(*local),\n+            | PlaceRef { local, projection: &[ProjectionElem::Deref] } => Some(local),\n             _ => None,\n         }\n     }\n@@ -1810,7 +1810,7 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n-        PlaceRef { local: &self.local, projection: &self.projection }\n+        PlaceRef { local: self.local, projection: &self.projection }\n     }\n }\n \n@@ -1826,18 +1826,18 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n     //\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n-        match self {\n+        match *self {\n             PlaceRef { local, projection: [] }\n-            | PlaceRef { local, projection: [ProjectionElem::Deref] } => Some(**local),\n+            | PlaceRef { local, projection: [ProjectionElem::Deref] } => Some(local),\n             _ => None,\n         }\n     }\n \n     /// If this place represents a local variable like `_X` with no\n     /// projections, return `Some(_X)`.\n     pub fn as_local(&self) -> Option<Local> {\n-        match self {\n-            PlaceRef { local, projection: [] } => Some(**local),\n+        match *self {\n+            PlaceRef { local, projection: [] } => Some(local),\n             _ => None,\n         }\n     }"}, {"sha": "2b5e00e321392ce84723ac570256e4779c54c57e", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -128,13 +128,13 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.local, proj_base, *self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(&place_ref.local, proj_base, *self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty.projection_ty(cx.tcx(), elem).ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n-                let span = self.fx.mir.local_decls[*place_ref.local].source_info.span;\n+                let span = self.fx.mir.local_decls[place_ref.local].source_info.span;\n                 if cx.spanned_layout_of(elem_ty, span).is_zst() {\n                     return;\n                 }\n@@ -174,7 +174,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                     // We use `NonUseContext::VarDebugInfo` for the base,\n                     // which might not force the base local to memory,\n                     // so we have to do it manually.\n-                    self.visit_local(place_ref.local, context, location);\n+                    self.visit_local(&place_ref.local, context, location);\n                 }\n             }\n \n@@ -212,8 +212,8 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                 };\n             }\n \n-            self.visit_place_base(place_ref.local, context, location);\n-            self.visit_projection(place_ref.local, place_ref.projection, context, location);\n+            self.visit_place_base(&place_ref.local, context, location);\n+            self.visit_projection(&place_ref.local, place_ref.projection, context, location);\n         }\n     }\n }"}, {"sha": "7f43e66549896769704f8bc7bb9bf6abec1bd0ff", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -1111,7 +1111,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         } else {\n             self.codegen_place(\n                 bx,\n-                mir::PlaceRef { local: &dest.local, projection: &dest.projection },\n+                mir::PlaceRef { local: dest.local, projection: &dest.projection },\n             )\n         };\n         if fn_ret.is_indirect() {"}, {"sha": "a33cd2ddad97b479dbc32001a3023934a0f0c3fe", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -373,7 +373,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n-        match self.locals[*place_ref.local] {\n+        match self.locals[place_ref.local] {\n             LocalRef::Operand(Some(mut o)) => {\n                 // Moves out of scalar and scalar pair fields are trivial.\n                 for elem in place_ref.projection.iter() {"}, {"sha": "ff8871d21adc81486fd86f6987d6d1155e279047", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -415,7 +415,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let tcx = self.cx.tcx();\n \n         let result = match place_ref {\n-            mir::PlaceRef { local, projection: [] } => match self.locals[*local] {\n+            mir::PlaceRef { local, projection: [] } => match self.locals[local] {\n                 LocalRef::Place(place) => {\n                     return place;\n                 }\n@@ -499,7 +499,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(place_ref.local, place_ref.projection, *self.mir, tcx);\n+        let place_ty = mir::Place::ty_from(&place_ref.local, place_ref.projection, *self.mir, tcx);\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "19b7e0cf59bb4bff2d3442a25d3236cd28e22c31", "filename": "src/librustc_mir/borrow_check/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -199,7 +199,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         all_facts,\n                         self.borrow_set,\n                         self.location_table,\n-                        *local,\n+                        local,\n                         location,\n                     );\n                 }\n@@ -212,7 +212,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         local, location\n                     );\n \n-                    if let Some(borrow_indices) = self.borrow_set.local_map.get(local) {\n+                    if let Some(borrow_indices) = self.borrow_set.local_map.get(&local) {\n                         for &borrow_index in borrow_indices {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,"}, {"sha": "6bfa9f43a1f74f073274f042256e4c02aafdc13e", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -186,7 +186,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             let ty =\n-                Place::ty_from(used_place.local, used_place.projection, *self.body, self.infcx.tcx)\n+                Place::ty_from(&used_place.local, used_place.projection, *self.body, self.infcx.tcx)\n                     .ty;\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n@@ -605,7 +605,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                     match elem {\n                         ProjectionElem::Field(field, _) if union_ty(local, proj_base).is_some() => {\n-                            return Some((PlaceRef { local, projection: proj_base }, field));\n+                            return Some((PlaceRef { local: *local, projection: proj_base }, field));\n                         }\n                         _ => {}\n                     }\n@@ -624,12 +624,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let ProjectionElem::Field(field, _) = elem {\n                         if let Some(union_ty) = union_ty(local, proj_base) {\n                             if field != target_field\n-                                && local == target_base.local\n+                                && *local == target_base.local\n                                 && proj_base == target_base.projection\n                             {\n                                 // FIXME when we avoid clone reuse describe_place closure\n                                 let describe_base_place = self\n-                                    .describe_place(PlaceRef { local, projection: proj_base })\n+                                    .describe_place(PlaceRef { local: *local, projection: proj_base })\n                                     .unwrap_or_else(|| \"_\".to_owned());\n \n                                 return Some((\n@@ -686,7 +686,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_span = borrow_spans.var_or_use();\n \n         assert!(root_place.projection.is_empty());\n-        let proper_span = self.body.local_decls[*root_place.local].source_info.span;\n+        let proper_span = self.body.local_decls[root_place.local].source_info.span;\n \n         let root_place_projection = self.infcx.tcx.intern_place_elems(root_place.projection);\n \n@@ -1139,7 +1139,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let root_place =\n                 self.prefixes(borrow.borrowed_place.as_ref(), PrefixSet::All).last().unwrap();\n             let local = root_place.local;\n-            match self.body.local_kind(*local) {\n+            match self.body.local_kind(local) {\n                 LocalKind::ReturnPointer | LocalKind::Temp => {\n                     (\"temporary value\".to_string(), \"temporary value created here\".to_string())\n                 }"}, {"sha": "1540e5bf420e2565cefbc78d2ee0cebcf2641108", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -169,10 +169,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Result<(), ()> {\n         match place {\n             PlaceRef { local, projection: [] } => {\n-                self.append_local_to_string(*local, buf)?;\n+                self.append_local_to_string(local, buf)?;\n             }\n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_ref_for_guard() =>\n+                if self.body.local_decls[local].is_ref_for_guard() =>\n             {\n                 self.append_place_to_string(\n                     PlaceRef { local: local, projection: &[] },\n@@ -182,9 +182,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 )?;\n             }\n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_ref_to_static() =>\n+                if self.body.local_decls[local].is_ref_to_static() =>\n             {\n-                let local_info = &self.body.local_decls[*local].local_info;\n+                let local_info = &self.body.local_decls[local].local_info;\n                 if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n                     buf.push_str(&self.infcx.tcx.item_name(def_id).as_str());\n                 } else {\n@@ -307,7 +307,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // FIXME Place2 Make this work iteratively\n         match place {\n             PlaceRef { local, projection: [] } => {\n-                let local = &self.body.local_decls[*local];\n+                let local = &self.body.local_decls[local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n             PlaceRef { local, projection: [proj_base @ .., elem] } => match elem {\n@@ -316,7 +316,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty =\n-                        Place::ty_from(place.local, place.projection, *self.body, self.infcx.tcx)\n+                        Place::ty_from(&place.local, place.projection, *self.body, self.infcx.tcx)\n                             .ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n@@ -447,7 +447,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // If we didn't find an overloaded deref or index, then assume it's a\n         // built in deref and check the type of the base.\n-        let base_ty = Place::ty_from(deref_base.local, deref_base.projection, *self.body, tcx).ty;\n+        let base_ty = Place::ty_from(&deref_base.local, deref_base.projection, *self.body, tcx).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n         } else if base_ty.is_mutable_ptr() {"}, {"sha": "a8267b81f57ad1c4809e96da91f58f53854509bf", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -275,7 +275,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n         } else {\n             let base_static =\n-                PlaceRef { local: &place.local, projection: &[ProjectionElem::Deref] };\n+                PlaceRef { local: place.local, projection: &[ProjectionElem::Deref] };\n \n             format!(\n                 \"`{:?}` as `{:?}` is a static item\",\n@@ -304,17 +304,17 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         let deref_base = match deref_target_place.projection.as_ref() {\n             &[ref proj_base @ .., ProjectionElem::Deref] => {\n-                PlaceRef { local: &deref_target_place.local, projection: &proj_base }\n+                PlaceRef { local: deref_target_place.local, projection: &proj_base }\n             }\n             _ => bug!(\"deref_target_place is not a deref projection\"),\n         };\n \n         if let PlaceRef { local, projection: [] } = deref_base {\n-            let decl = &self.body.local_decls[*local];\n+            let decl = &self.body.local_decls[local];\n             if decl.is_ref_for_guard() {\n                 let mut err = self.cannot_move_out_of(\n                     span,\n-                    &format!(\"`{}` in pattern guard\", self.local_names[*local].unwrap()),\n+                    &format!(\"`{}` in pattern guard\", self.local_names[local].unwrap()),\n                 );\n                 err.note(\n                     \"variables bound in patterns cannot be moved from \\"}, {"sha": "4e2517211c86c5ef82c477169f23a6df1ed4a336", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if access_place.as_local().is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n-                    let name = self.local_names[*local].expect(\"immutable unnamed local\");\n+                    let name = self.local_names[local].expect(\"immutable unnamed local\");\n                     reason = format!(\", as `{}` is not declared as mutable\", name);\n                 }\n             }\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty\n+                    Place::ty_from(&local, proj_base, *self.body, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -70,20 +70,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_ref_for_guard() =>\n+                if self.body.local_decls[local].is_ref_for_guard() =>\n             {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 reason = \", as it is immutable for the pattern guard\".to_string();\n             }\n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_ref_to_static() =>\n+                if self.body.local_decls[local].is_ref_to_static() =>\n             {\n                 if access_place.projection.len() == 1 {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n                 } else {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    let local_info = &self.body.local_decls[*local].local_info;\n+                    let local_info = &self.body.local_decls[local].local_info;\n                     if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n                         let static_name = &self.infcx.tcx.item_name(def_id);\n                         reason = format!(\", as `{}` is an immutable static item\", static_name);\n@@ -93,15 +93,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             PlaceRef { local: _, projection: [proj_base @ .., ProjectionElem::Deref] } => {\n-                if *the_place_err.local == Local::new(1)\n+                if the_place_err.local == Local::new(1)\n                     && proj_base.is_empty()\n                     && !self.upvars.is_empty()\n                 {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n                         Place::ty_from(\n-                            the_place_err.local,\n+                            &the_place_err.local,\n                             the_place_err.projection,\n                             *self.body,\n                             self.infcx.tcx\n@@ -195,7 +195,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(&local, proj_base, *self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if {\n                     self.body\n                         .local_decls\n-                        .get(*local)\n+                        .get(local)\n                         .map(|local_decl| {\n                             if let LocalInfo::User(ClearCrossCrate::Set(\n                                 mir::BindingForm::ImplicitSelf(kind),\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 // Deliberately fall into this case for all implicit self types,\n                                 // so that we don't fall in to the next case with them.\n                                 kind == mir::ImplicitSelfKind::MutRef\n-                            } else if Some(kw::SelfLower) == self.local_names[*local] {\n+                            } else if Some(kw::SelfLower) == self.local_names[local] {\n                                 // Otherwise, check if the name is the self kewyord - in which case\n                                 // we have an explicit self. Do the same thing in this case and check\n                                 // for a `self: &mut Self` to suggest removing the `&mut`.\n@@ -247,20 +247,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // We want to suggest users use `let mut` for local (user\n             // variable) mutations...\n             PlaceRef { local, projection: [] }\n-                if self.body.local_decls[*local].can_be_made_mutable() =>\n+                if self.body.local_decls[local].can_be_made_mutable() =>\n             {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n                 // or `&mut self` (such variables are simply not\n                 // mutable).\n-                let local_decl = &self.body.local_decls[*local];\n+                let local_decl = &self.body.local_decls[local];\n                 assert_eq!(local_decl.mutability, Mutability::Not);\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_suggestion(\n                     local_decl.source_info.span,\n                     \"consider changing this to be mutable\",\n-                    format!(\"mut {}\", self.local_names[*local].unwrap()),\n+                    format!(\"mut {}\", self.local_names[local].unwrap()),\n                     Applicability::MachineApplicable,\n                 );\n             }\n@@ -271,7 +271,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(local, proj_base, *self.body, self.infcx.tcx).ty\n+                    Place::ty_from(&local, proj_base, *self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -312,7 +312,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_ref_for_guard() =>\n+                if self.body.local_decls[local].is_ref_for_guard() =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.note(\n@@ -326,9 +326,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // FIXME: can this case be generalized to work for an\n             // arbitrary base for the projection?\n             PlaceRef { local, projection: [ProjectionElem::Deref] }\n-                if self.body.local_decls[*local].is_user_variable() =>\n+                if self.body.local_decls[local].is_user_variable() =>\n             {\n-                let local_decl = &self.body.local_decls[*local];\n+                let local_decl = &self.body.local_decls[local];\n                 let suggestion = match local_decl.local_info {\n                     LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_))) => {\n                         Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ))) => Some(suggest_ampmut(\n                         self.infcx.tcx,\n                         self.body,\n-                        *local,\n+                        local,\n                         local_decl,\n                         opt_ty_info,\n                     )),\n@@ -379,7 +379,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                match self.local_names[*local] {\n+                match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n                         err.span_label(\n                             span,\n@@ -411,7 +411,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 local,\n                 projection: [ProjectionElem::Deref],\n                 // FIXME document what is this 1 magic number about\n-            } if *local == Local::new(1) && !self.upvars.is_empty() => {\n+            } if local == Local::new(1) && !self.upvars.is_empty() => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help(\n                     self.body.span,"}, {"sha": "aa6c50c3ad86fa3dbb89a445d415526329e32aa4", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -823,7 +823,7 @@ enum InitializationRequiringAction {\n }\n \n struct RootPlace<'d, 'tcx> {\n-    place_local: &'d Local,\n+    place_local: Local,\n     place_projection: &'d [PlaceElem<'tcx>],\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n@@ -1382,7 +1382,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n         let deref = [ProjectionElem::Deref];\n-        let mut root_place = PlaceRef { local: &place.local, projection: &[] };\n+        let mut root_place = PlaceRef { local: place.local, projection: &[] };\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n@@ -1391,7 +1391,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n         let (might_be_alive, will_be_dropped) =\n-            if self.body.local_decls[*root_place.local].is_ref_to_thread_local() {\n+            if self.body.local_decls[root_place.local].is_ref_to_thread_local() {\n                 // Thread-locals might be dropped after the function exits\n                 // We have to dereference the outer reference because\n                 // borrows don't conflict behind shared references.\n@@ -1623,7 +1623,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             place_span.0.projection\n         {\n             let place_ty =\n-                Place::ty_from(place_span.0.local, base_proj, self.body(), self.infcx.tcx);\n+                Place::ty_from(&place_span.0.local, base_proj, self.body(), self.infcx.tcx);\n             if let ty::Array(..) = place_ty.ty.kind {\n                 let array_place = PlaceRef { local: place_span.0.local, projection: base_proj };\n                 self.check_if_subslice_element_is_moved(\n@@ -1722,7 +1722,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.check_if_full_path_is_moved(\n                         location, InitializationRequiringAction::Use,\n                         (PlaceRef {\n-                            local: &place.local,\n+                            local: place.local,\n                             projection: proj_base,\n                         }, span), flow_state);\n                     // (base initialized; no need to\n@@ -1746,7 +1746,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n                                 (PlaceRef {\n-                                    local: &place.local,\n+                                    local: place.local,\n                                     projection: proj_base,\n                                 }, span), flow_state);\n \n@@ -1759,7 +1759,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // is allowed, remove this match arm.\n                         ty::Adt(..) | ty::Tuple(..) => {\n                             check_parent_of_field(self, location, PlaceRef {\n-                                local: &place.local,\n+                                local: place.local,\n                                 projection: proj_base,\n                             }, span, flow_state);\n \n@@ -1844,7 +1844,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n                 if let ty::Adt(def, _) =\n-                    Place::ty_from(base.local, base.projection, this.body(), tcx).ty.kind\n+                    Place::ty_from(&base.local, base.projection, this.body(), tcx).ty.kind\n                 {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n@@ -1998,9 +1998,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // mutated, then it is justified to be annotated with the `mut`\n                 // keyword, since the mutation may be a possible reassignment.\n                 if is_local_mutation_allowed != LocalMutationIsAllowed::Yes\n-                    && self.is_local_ever_initialized(*local, flow_state).is_some()\n+                    && self.is_local_ever_initialized(local, flow_state).is_some()\n                 {\n-                    self.used_mut.insert(*local);\n+                    self.used_mut.insert(local);\n                 }\n             }\n             RootPlace {\n@@ -2032,7 +2032,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Result<RootPlace<'d, 'tcx>, PlaceRef<'d, 'tcx>> {\n         match place {\n             PlaceRef { local, projection: [] } => {\n-                let local = &self.body.local_decls[*local];\n+                let local = &self.body.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {\n@@ -2058,7 +2058,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let base_ty =\n-                            Place::ty_from(place.local, proj_base, self.body(), self.infcx.tcx).ty;\n+                            Place::ty_from(&place.local, proj_base, self.body(), self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.kind {\n@@ -2192,7 +2192,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place_projection {\n             [base @ .., ProjectionElem::Field(field, _ty)] => {\n                 let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.local, base, self.body(), tcx).ty;\n+                let base_ty = Place::ty_from(&place_ref.local, base, self.body(), tcx).ty;\n \n                 if (base_ty.is_closure() || base_ty.is_generator())\n                     && (!by_ref || self.upvars[field.index()].by_ref)"}, {"sha": "196768905676f56ecb97c9bf92fd3af82d45beba", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -122,7 +122,7 @@ fn place_components_conflict<'tcx>(\n     let borrow_local = borrow_place.local;\n     let access_local = access_place.local;\n \n-    match place_base_conflict(borrow_local, *access_local) {\n+    match place_base_conflict(borrow_local, access_local) {\n         Overlap::Arbitrary => {\n             bug!(\"Two base can't return Arbitrary\");\n         }"}, {"sha": "9aa2b98cbb156d0ff8a6658a763c3398e89ff5fa", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -120,7 +120,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = Place::ty_from(cursor.local, proj_base, *self.body, self.tcx).ty;\n+                    let ty = Place::ty_from(&cursor.local, proj_base, *self.body, self.tcx).ty;\n                     match ty.kind {\n                         ty::RawPtr(_) | ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Not) => {\n                             // don't continue traversing over derefs of raw pointers or shared"}, {"sha": "cc3c4eff6f078e4584e6bed2da80f38d9e3b6d3b", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -490,7 +490,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         // of the union so it is marked as initialized again.\n         if let [proj_base @ .., ProjectionElem::Field(_, _)] = place.projection {\n             if let ty::Adt(def, _) =\n-                Place::ty_from(place.local, proj_base, self.builder.body, self.builder.tcx).ty.kind\n+                Place::ty_from(&place.local, proj_base, self.builder.body, self.builder.tcx).ty.kind\n             {\n                 if def.is_union() {\n                     place = PlaceRef { local: place.local, projection: proj_base }"}, {"sha": "8d62b84bda8f070142e41f50c059c3b1bc7c92cf", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -246,7 +246,7 @@ impl MovePathLookup {\n     // unknown place, but will rather return the nearest available\n     // parent.\n     pub fn find(&self, place: PlaceRef<'_, '_>) -> LookupResult {\n-        let mut result = self.locals[*place.local];\n+        let mut result = self.locals[place.local];\n \n         for elem in place.projection.iter() {\n             if let Some(&subpath) = self.projections.get(&(result, elem.lift())) {"}, {"sha": "96bc9c3b225872555be27a1e6ba3d92b2ad947d0", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -46,7 +46,7 @@ pub trait Qualif {\n             let qualif = base_qualif\n                 && Self::in_any_value_of_ty(\n                     cx,\n-                    Place::ty_from(place.local, proj_base, *cx.body, cx.tcx)\n+                    Place::ty_from(&place.local, proj_base, *cx.body, cx.tcx)\n                         .projection_ty(cx.tcx, elem)\n                         .ty,\n                 );\n@@ -78,7 +78,7 @@ pub trait Qualif {\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         match place {\n-            PlaceRef { local, projection: [] } => per_local(*local),\n+            PlaceRef { local, projection: [] } => per_local(local),\n             PlaceRef { local: _, projection: [.., _] } => Self::in_projection(cx, per_local, place),\n         }\n     }\n@@ -154,7 +154,7 @@ pub trait Qualif {\n                         return Self::in_place(\n                             cx,\n                             per_local,\n-                            PlaceRef { local: &place.local, projection: proj_base },\n+                            PlaceRef { local: place.local, projection: proj_base },\n                         );\n                     }\n                 }"}, {"sha": "eac60029784d258ff177abc067d20ebfc4676d53", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -48,7 +48,7 @@ where\n \n         match (value, place.as_ref()) {\n             (true, mir::PlaceRef { local, .. }) => {\n-                self.qualifs_per_local.insert(*local);\n+                self.qualifs_per_local.insert(local);\n             }\n \n             // For now, we do not clear the qualif if a local is overwritten in full by"}, {"sha": "9835e7977ad60a60f9fe324a61e7c7b63bae62fd", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -95,7 +95,7 @@ impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n             if let PlaceRef { local, projection: &[ref proj_base @ .., ProjectionElem::Deref] } =\n                 place.as_ref()\n             {\n-                if Place::ty_from(local, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n+                if Place::ty_from(&local, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n                     self.optimizations.and_stars.insert(location);\n                 }\n             }"}, {"sha": "c1aa4aa786719db3243fda883d2bab779fcffcf2", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -475,7 +475,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     fn validate_place(&self, place: PlaceRef<'_, 'tcx>) -> Result<(), Unpromotable> {\n         match place {\n-            PlaceRef { local, projection: [] } => self.validate_local(*local),\n+            PlaceRef { local, projection: [] } => self.validate_local(local),\n             PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n                 match *elem {\n                     ProjectionElem::Deref | ProjectionElem::Downcast(..) => {\n@@ -491,7 +491,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     ProjectionElem::Field(..) => {\n                         if self.const_kind.is_none() {\n                             let base_ty =\n-                                Place::ty_from(place.local, proj_base, *self.body, self.tcx).ty;\n+                                Place::ty_from(&place.local, proj_base, *self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n                                 // No promotion of union field accesses.\n                                 if def.is_union() {\n@@ -592,7 +592,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     let base_ty = Place::ty_from(&place.local, proj_base, *self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         return self.validate_place(PlaceRef {\n-                            local: &place.local,\n+                            local: place.local,\n                             projection: proj_base,\n                         });\n                     }\n@@ -630,7 +630,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n                     let base_ty = Place::ty_from(&place.local, proj_base, *self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n-                        place = PlaceRef { local: &place.local, projection: proj_base };\n+                        place = PlaceRef { local: place.local, projection: proj_base };\n                     }\n                 }\n \n@@ -640,14 +640,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // `<HasMutInterior as Qualif>::in_projection` from\n                 // `check_consts::qualifs` but without recursion.\n                 let mut has_mut_interior =\n-                    self.qualif_local::<qualifs::HasMutInterior>(*place.local);\n+                    self.qualif_local::<qualifs::HasMutInterior>(place.local);\n                 if has_mut_interior {\n                     let mut place_projection = place.projection;\n                     // FIXME(eddyb) use a forward loop instead of a reverse one.\n                     while let [proj_base @ .., elem] = place_projection {\n                         // FIXME(eddyb) this is probably excessive, with\n                         // the exception of `union` member accesses.\n-                        let ty = Place::ty_from(place.local, proj_base, *self.body, self.tcx)\n+                        let ty = Place::ty_from(&place.local, proj_base, *self.body, self.tcx)\n                             .projection_ty(self.tcx, elem)\n                             .ty;\n                         if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {"}, {"sha": "bd661195a4852b749aa06ebcb6ab5db739283ff7", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -139,7 +139,7 @@ fn match_variant_field_place<'tcx>(place: &Place<'tcx>) -> Option<(Local, VarFie\n         PlaceRef {\n             local,\n             projection: &[ProjectionElem::Downcast(_, var_idx), ProjectionElem::Field(field, ty)],\n-        } => Some((*local, VarField { field, field_ty: ty, var_idx })),\n+        } => Some((local, VarField { field, field_ty: ty, var_idx })),\n         _ => None,\n     }\n }"}, {"sha": "16795b459b6bd5dbbb87629e7fca282c780750fd", "filename": "src/librustc_mir_build/build/expr/as_rvalue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -393,20 +393,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let arg_place = unpack!(block = this.as_place(block, arg));\n \n         let mutability = match arg_place.as_ref() {\n-            PlaceRef { local, projection: &[] } => this.local_decls[*local].mutability,\n+            PlaceRef { local, projection: &[] } => this.local_decls[local].mutability,\n             PlaceRef { local, projection: &[ProjectionElem::Deref] } => {\n                 debug_assert!(\n-                    this.local_decls[*local].is_ref_for_guard(),\n+                    this.local_decls[local].is_ref_for_guard(),\n                     \"Unexpected capture place\",\n                 );\n-                this.local_decls[*local].mutability\n+                this.local_decls[local].mutability\n             }\n             PlaceRef {\n-                ref local,\n+                local,\n                 projection: &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             }\n             | PlaceRef {\n-                ref local,\n+                local,\n                 projection:\n                     &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _), ProjectionElem::Deref],\n             } => {"}, {"sha": "0b0e6f33bd74b8c49ec8e137947a79bcebacba40", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b6be0ab7c500782c5f4d55166d09fa02f8103e/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=b5b6be0ab7c500782c5f4d55166d09fa02f8103e", "patch": "@@ -1241,7 +1241,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // Insert a shallow borrow after a deref. For other\n                     // projections the borrow of prefix_cursor will\n                     // conflict with any mutation of base.\n-                    all_fake_borrows.push(PlaceRef { local: &place.local, projection: proj_base });\n+                    all_fake_borrows.push(PlaceRef { local: place.local, projection: proj_base });\n                 }\n             }\n "}]}