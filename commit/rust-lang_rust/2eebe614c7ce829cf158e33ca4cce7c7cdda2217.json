{"sha": "2eebe614c7ce829cf158e33ca4cce7c7cdda2217", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZWJlNjE0YzdjZTgyOWNmMTU4ZTMzY2E0Y2NlN2M3Y2RkYTIyMTc=", "commit": {"author": {"name": "David Lukes", "email": "dafydd.lukes@gmail.com", "date": "2018-02-16T22:21:57Z"}, "committer": {"name": "David Lukes", "email": "dafydd.lukes@gmail.com", "date": "2018-03-05T12:11:21Z"}, "message": "Attempt at checking for license (#209)\n\nI'm not quite sure how best to handle loading the license template from\na path -- I mean obviously I know *how* to do it, but I'm not sure where\nto fit it in the codebase :) So this first attempt puts the license\ntemplate directly into the config file.\n\nThese are my misgivings about the license template config option as a\npath to a file (I'd love feedback if some of these are wrong or can be\neasily circumvented!):\n\n1. I thought the obvious choice for the type of `license_template` in\n`create_config!` should be `PathBuf`, but `PathBuf` doesn't implement\n`FromStr` (yet? see https://github.com/rust-lang/rust/issues/44431), so\nit would have to be wrapped in a tuple struct, and I went down that road\nfor a little while but then it seemed like too much ceremony for too\nlittle gain.\n\n2. So a plain `String` then (which, mind you, also means the same\n`doc_hint()`, i.e. `<string>`, not `<path>` or something like that). The\nfact that it's a valid path will be checked once we try to read the\nfile.\n\n3. But where in the code should the license template be read? The\nobvious choice for me would be somewhere in `Config::from_toml()`, but\nsince `Config` is defined via the `create_config!` macro, that would\nmean tight coupling between the macro invocation (which defines the\nconfiguration option `license_template`) and its definition (which would\nrely on the existence of that option to run the template loading code).\n\n4. `license_template` could also be made a special option which is\nhardwired into the macro. This gets rid of the tight coupling, but\nspecial-casing one of the config options would make the code harder to\nnavigate.\n\n5. Instead, the macro could maybe be rewritten to allow for config\noptions that load additional resources from files when the config is\nbeing parsed, but that's beyond my skill level I'm afraid (and probably\noverengineering the problem if it's only ever going to be used for this\none option).\n\n6. Finally, the file can be loaded at some later point in time, e.g. in\n`format_lines()`, right before `check_license()` is called. But to\nface a potential *IO* error at so late a stage, when the source files\nhave already been parsed... I don't know, it doesn't feel right.\n\nBTW I don't like that I'm actually parsing the license template as late\nas inside `check_license()` either, but for much the same reasons, I\ndon't know where else to put it. If the `Config` were hand-rolled\ninstead of a macro, I'd just define a custom `license_template` option\nand load and parse the template in the `Config`'s init. But the way\nthings are, I'm a bit at a loss.\n\nHowever, if someone more familiar with the project would kindly provide\na few hints as to how the path approach can be done in a way that is as\nclean as possible in the context of the codebase, I'll be more than\nhappy to implement it! :)", "tree": {"sha": "95d4dd969aabf228a18d4e799a5ff0e36d126288", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95d4dd969aabf228a18d4e799a5ff0e36d126288"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eebe614c7ce829cf158e33ca4cce7c7cdda2217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eebe614c7ce829cf158e33ca4cce7c7cdda2217", "html_url": "https://github.com/rust-lang/rust/commit/2eebe614c7ce829cf158e33ca4cce7c7cdda2217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eebe614c7ce829cf158e33ca4cce7c7cdda2217/comments", "author": {"login": "dlukes", "id": 2734517, "node_id": "MDQ6VXNlcjI3MzQ1MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2734517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlukes", "html_url": "https://github.com/dlukes", "followers_url": "https://api.github.com/users/dlukes/followers", "following_url": "https://api.github.com/users/dlukes/following{/other_user}", "gists_url": "https://api.github.com/users/dlukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlukes/subscriptions", "organizations_url": "https://api.github.com/users/dlukes/orgs", "repos_url": "https://api.github.com/users/dlukes/repos", "events_url": "https://api.github.com/users/dlukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dlukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dlukes", "id": 2734517, "node_id": "MDQ6VXNlcjI3MzQ1MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2734517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlukes", "html_url": "https://github.com/dlukes", "followers_url": "https://api.github.com/users/dlukes/followers", "following_url": "https://api.github.com/users/dlukes/following{/other_user}", "gists_url": "https://api.github.com/users/dlukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlukes/subscriptions", "organizations_url": "https://api.github.com/users/dlukes/orgs", "repos_url": "https://api.github.com/users/dlukes/repos", "events_url": "https://api.github.com/users/dlukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dlukes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5025a53b30f9690a277baf14dca1ba15a383d3da", "url": "https://api.github.com/repos/rust-lang/rust/commits/5025a53b30f9690a277baf14dca1ba15a383d3da", "html_url": "https://github.com/rust-lang/rust/commit/5025a53b30f9690a277baf14dca1ba15a383d3da"}], "stats": {"total": 110, "additions": 106, "deletions": 4}, "files": [{"sha": "c16d5bb679958d49557f0f464404c3dc8c8b9d85", "filename": "src/config/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2eebe614c7ce829cf158e33ca4cce7c7cdda2217/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eebe614c7ce829cf158e33ca4cce7c7cdda2217/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=2eebe614c7ce829cf158e33ca4cce7c7cdda2217", "patch": "@@ -50,6 +50,7 @@ create_config! {\n     comment_width: usize, 80, false,\n         \"Maximum length of comments. No effect unless wrap_comments = true\";\n     normalize_comments: bool, false, true, \"Convert /* */ comments to // comments where possible\";\n+    license_template: String, String::default(), false, \"Check for license\";\n \n     // Single line expressions and items.\n     empty_item_single_line: bool, true, false,"}, {"sha": "858a273a1e5e3e96a87ee7b801760f800834ef27", "filename": "src/lib.rs", "status": "modified", "additions": 105, "deletions": 4, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2eebe614c7ce829cf158e33ca4cce7c7cdda2217/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eebe614c7ce829cf158e33ca4cce7c7cdda2217/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2eebe614c7ce829cf158e33ca4cce7c7cdda2217", "patch": "@@ -43,6 +43,7 @@ use syntax::ast;\n use syntax::codemap::{CodeMap, FilePathMapping};\n pub use syntax::codemap::FileName;\n use syntax::parse::{self, ParseSess};\n+use regex::{Regex, RegexBuilder};\n \n use checkstyle::{output_footer, output_header};\n use comment::{CharClasses, FullCodeCharKind};\n@@ -99,6 +100,10 @@ pub enum ErrorKind {\n     TrailingWhitespace,\n     // TO-DO or FIX-ME item without an issue number\n     BadIssue(Issue),\n+    // License check has failed\n+    LicenseCheck,\n+    // License template could not be parsed\n+    ParsingLicense,\n }\n \n impl fmt::Display for ErrorKind {\n@@ -111,6 +116,8 @@ impl fmt::Display for ErrorKind {\n             ),\n             ErrorKind::TrailingWhitespace => write!(fmt, \"left behind trailing whitespace\"),\n             ErrorKind::BadIssue(issue) => write!(fmt, \"found {}\", issue),\n+            ErrorKind::LicenseCheck => write!(fmt, \"license check failed\"),\n+            ErrorKind::ParsingLicense => write!(fmt, \"parsing regex in license template failed\"),\n         }\n     }\n }\n@@ -127,7 +134,10 @@ pub struct FormattingError {\n impl FormattingError {\n     fn msg_prefix(&self) -> &str {\n         match self.kind {\n-            ErrorKind::LineOverflow(..) | ErrorKind::TrailingWhitespace => \"error:\",\n+            ErrorKind::LineOverflow(..)\n+            | ErrorKind::TrailingWhitespace\n+            | ErrorKind::LicenseCheck\n+            | ErrorKind::ParsingLicense => \"error:\",\n             ErrorKind::BadIssue(_) => \"WARNING:\",\n         }\n     }\n@@ -405,8 +415,39 @@ fn should_report_error(\n     }\n }\n \n+fn check_license(text: &str, license_template: &str) -> Result<bool, regex::Error> {\n+    let mut template_re = String::from(\"^\");\n+    // the template is parsed as a series of pairs of capture groups of (1) lazy whatever, which\n+    // will be matched literally, followed by (2) a {}-delimited block, which will be matched as a\n+    // regex\n+    let template_parser = RegexBuilder::new(r\"(.*?)\\{(.*?)\\}\")\n+        .dot_matches_new_line(true)\n+        .build()\n+        .unwrap();\n+    // keep track of the last matched offset and ultimately append the tail of the template (if any)\n+    // after the last {} block\n+    let mut last_matched_offset = 0;\n+    for caps in template_parser.captures_iter(license_template) {\n+        if let Some(mat) = caps.get(0) {\n+            last_matched_offset = mat.end()\n+        }\n+        if let Some(mat) = caps.get(1) {\n+            template_re.push_str(&regex::escape(mat.as_str()))\n+        }\n+        if let Some(mat) = caps.get(2) {\n+            let mut re = mat.as_str();\n+            if re.is_empty() {\n+                re = \".*?\";\n+            }\n+            template_re.push_str(re)\n+        }\n+    }\n+    template_re.push_str(&regex::escape(&license_template[last_matched_offset..]));\n+    let template_re = Regex::new(&template_re)?;\n+    Ok(template_re.is_match(text))\n+}\n+\n // Formatting done on a char by char or line by line basis.\n-// FIXME(#209) warn on bad license\n // FIXME(#20) other stuff for parity with make tidy\n fn format_lines(\n     text: &mut String,\n@@ -415,7 +456,6 @@ fn format_lines(\n     config: &Config,\n     report: &mut FormatReport,\n ) {\n-    // Iterate over the chars in the file map.\n     let mut trims = vec![];\n     let mut last_wspace: Option<usize> = None;\n     let mut line_len = 0;\n@@ -428,6 +468,33 @@ fn format_lines(\n     let mut format_line = config.file_lines().contains_line(name, cur_line);\n     let allow_issue_seek = !issue_seeker.is_disabled();\n \n+    // Check license.\n+    if config.was_set().license_template() {\n+        match check_license(text, &config.license_template()) {\n+            Ok(check) => {\n+                if !check {\n+                    errors.push(FormattingError {\n+                        line: cur_line,\n+                        kind: ErrorKind::LicenseCheck,\n+                        is_comment: false,\n+                        is_string: false,\n+                        line_buffer: String::new(),\n+                    });\n+                }\n+            }\n+            Err(_) => {\n+                errors.push(FormattingError {\n+                    line: cur_line,\n+                    kind: ErrorKind::ParsingLicense,\n+                    is_comment: false,\n+                    is_string: false,\n+                    line_buffer: String::new(),\n+                });\n+            }\n+        }\n+    }\n+\n+    // Iterate over the chars in the file map.\n     for (kind, (b, c)) in CharClasses::new(text.chars().enumerate()) {\n         if c == '\\r' {\n             continue;\n@@ -853,7 +920,7 @@ pub fn run(input: Input, config: &Config) -> Summary {\n \n #[cfg(test)]\n mod test {\n-    use super::{format_code_block, format_snippet, Config};\n+    use super::{check_license, format_code_block, format_snippet, Config};\n \n     #[test]\n     fn test_no_panic_on_format_snippet_and_format_code_block() {\n@@ -939,4 +1006,38 @@ false,\n };\";\n         assert!(test_format_inner(format_code_block, code_block, expected));\n     }\n+\n+    #[test]\n+    fn test_check_license() {\n+        assert!(check_license(\"literal matching\", \"literal matching\").unwrap());\n+        assert!(!check_license(\"literal no match\", \"literal matching\").unwrap());\n+        assert!(\n+            check_license(\n+                \"Regex start and end: 2018\",\n+                r\"{[Rr]egex} start {} end: {\\d+}\"\n+            ).unwrap()\n+        );\n+        assert!(!check_license(\n+            \"Regex start and end no match: 2018\",\n+            r\"{[Rr]egex} start {} end: {\\d+}\"\n+        ).unwrap());\n+        assert!(\n+            check_license(\n+                \"Regex in the middle: 2018 (tm)\",\n+                r\"Regex {} middle: {\\d+} (tm)\"\n+            ).unwrap()\n+        );\n+        assert!(!check_license(\n+            \"Regex in the middle no match: 2018 (tm)\",\n+            r\"Regex {} middle: {\\d+} (tm)\"\n+        ).unwrap());\n+        assert!(!check_license(\"default doesn't match\\nacross lines\", \"default {} lines\").unwrap());\n+        assert!(check_license(\"\", \"this is not a valid {[regex}\").is_err());\n+        assert!(\n+            check_license(\n+                \"can't parse nested delimiters with regex\",\n+                r\"can't parse nested delimiters with regex{\\.{3}}\"\n+            ).is_err()\n+        );\n+    }\n }"}]}