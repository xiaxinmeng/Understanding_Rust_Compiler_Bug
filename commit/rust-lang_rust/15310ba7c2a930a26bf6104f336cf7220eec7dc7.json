{"sha": "15310ba7c2a930a26bf6104f336cf7220eec7dc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MzEwYmE3YzJhOTMwYTI2YmY2MTA0ZjMzNmNmNzIyMGVlYzdkYzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-27T08:49:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-27T08:49:35Z"}, "message": "auto merge of #8040 : luqmana/rust/rtn, r=brson\n\nImplements various missing tcp & udp methods.. Also fixes handling ipv4-mapped/compatible ipv6 addresses and addresses the XXX on `status_to_maybe_uv_error`.\r\n\r\nr? @brson", "tree": {"sha": "e85d3a47641c3a9f00364996647626f882501c1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e85d3a47641c3a9f00364996647626f882501c1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15310ba7c2a930a26bf6104f336cf7220eec7dc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15310ba7c2a930a26bf6104f336cf7220eec7dc7", "html_url": "https://github.com/rust-lang/rust/commit/15310ba7c2a930a26bf6104f336cf7220eec7dc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15310ba7c2a930a26bf6104f336cf7220eec7dc7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5194740a78ec113cb6cbc937e7263e2548f62f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5194740a78ec113cb6cbc937e7263e2548f62f6", "html_url": "https://github.com/rust-lang/rust/commit/c5194740a78ec113cb6cbc937e7263e2548f62f6"}, {"sha": "df67942dccc33379051e66f075615e579f3bdb49", "url": "https://api.github.com/repos/rust-lang/rust/commits/df67942dccc33379051e66f075615e579f3bdb49", "html_url": "https://github.com/rust-lang/rust/commit/df67942dccc33379051e66f075615e579f3bdb49"}], "stats": {"total": 700, "additions": 546, "deletions": 154}, "files": [{"sha": "2b572574b60b207d9ac1541a2e9b2e40e9fd3280", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -8,10 +8,52 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use num::FromStrRadix;\n+use to_str::ToStr;\n+\n type Port = u16;\n \n #[deriving(Eq, TotalEq)]\n pub enum IpAddr {\n     Ipv4(u8, u8, u8, u8, Port),\n     Ipv6(u16, u16, u16, u16, u16, u16, u16, u16, Port)\n }\n+\n+impl ToStr for IpAddr {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            Ipv4(a, b, c, d, p) =>\n+                fmt!(\"%u.%u.%u.%u:%u\",\n+                    a as uint, b as uint, c as uint, d as uint, p as uint),\n+\n+            // Ipv4 Compatible address\n+            Ipv6(0, 0, 0, 0, 0, 0, g, h, p) => {\n+                let a = fmt!(\"%04x\", g as uint);\n+                let b = FromStrRadix::from_str_radix(a.slice(2, 4), 16).unwrap();\n+                let a = FromStrRadix::from_str_radix(a.slice(0, 2), 16).unwrap();\n+                let c = fmt!(\"%04x\", h as uint);\n+                let d = FromStrRadix::from_str_radix(c.slice(2, 4), 16).unwrap();\n+                let c = FromStrRadix::from_str_radix(c.slice(0, 2), 16).unwrap();\n+\n+                fmt!(\"[::%u.%u.%u.%u]:%u\", a, b, c, d, p as uint)\n+            }\n+\n+            // Ipv4-Mapped address\n+            Ipv6(0, 0, 0, 0, 0, 1, g, h, p) => {\n+                let a = fmt!(\"%04x\", g as uint);\n+                let b = FromStrRadix::from_str_radix(a.slice(2, 4), 16).unwrap();\n+                let a = FromStrRadix::from_str_radix(a.slice(0, 2), 16).unwrap();\n+                let c = fmt!(\"%04x\", h as uint);\n+                let d = FromStrRadix::from_str_radix(c.slice(2, 4), 16).unwrap();\n+                let c = FromStrRadix::from_str_radix(c.slice(0, 2), 16).unwrap();\n+\n+                fmt!(\"[::FFFF:%u.%u.%u.%u]:%u\", a, b, c, d, p as uint)\n+            }\n+\n+            Ipv6(a, b, c, d, e, f, g, h, p) =>\n+                fmt!(\"[%x:%x:%x:%x:%x:%x:%x:%x]:%u\",\n+                    a as uint, b as uint, c as uint, d as uint,\n+                    e as uint, f as uint, g as uint, h as uint, p as uint)\n+        }\n+    }\n+}"}, {"sha": "c997373bf9d1866ec4b9f17828a31b2c0b08da82", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 93, "deletions": 2, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -14,8 +14,9 @@ use rt::io::net::ip::IpAddr;\n use rt::io::{Reader, Writer, Listener};\n use rt::io::{io_error, read_error, EndOfFile};\n use rt::rtio::{IoFactory, IoFactoryObject,\n-               RtioTcpListener, RtioTcpListenerObject,\n-               RtioTcpStream, RtioTcpStreamObject};\n+               RtioSocket, RtioTcpListener,\n+               RtioTcpListenerObject, RtioTcpStream,\n+               RtioTcpStreamObject};\n use rt::local::Local;\n \n pub struct TcpStream(~RtioTcpStreamObject);\n@@ -42,6 +43,28 @@ impl TcpStream {\n             }\n         }\n     }\n+\n+    pub fn peer_name(&mut self) -> Option<IpAddr> {\n+        match (**self).peer_name() {\n+            Ok(pn) => Some(pn),\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to get peer name: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+\n+    pub fn socket_name(&mut self) -> Option<IpAddr> {\n+        match (**self).socket_name() {\n+            Ok(sn) => Some(sn),\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to get socket name: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n }\n \n impl Reader for TcpStream {\n@@ -90,6 +113,17 @@ impl TcpListener {\n             }\n         }\n     }\n+\n+    pub fn socket_name(&mut self) -> Option<IpAddr> {\n+        match (**self).socket_name() {\n+            Ok(sn) => Some(sn),\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to get socket name: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n }\n \n impl Listener<TcpStream> for TcpListener {\n@@ -534,4 +568,61 @@ mod test {\n         }\n     }\n \n+    #[cfg(test)]\n+    fn socket_name(addr: IpAddr) {\n+        do run_in_newsched_task {\n+            do spawntask_immediately {\n+                let listener = TcpListener::bind(addr);\n+\n+                assert!(listener.is_some());\n+                let mut listener = listener.unwrap();\n+\n+                // Make sure socket_name gives\n+                // us the socket we binded to.\n+                let so_name = listener.socket_name();\n+                assert!(so_name.is_some());\n+                assert_eq!(addr, so_name.unwrap());\n+\n+            }\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    fn peer_name(addr: IpAddr) {\n+        do run_in_newsched_task {\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+\n+                listener.accept();\n+            }\n+\n+            do spawntask_immediately {\n+                let stream = TcpStream::connect(addr);\n+\n+                assert!(stream.is_some());\n+                let mut stream = stream.unwrap();\n+\n+                // Make sure peer_name gives us the\n+                // address/port of the peer we've\n+                // connected to.\n+                let peer_name = stream.peer_name();\n+                assert!(peer_name.is_some());\n+                assert_eq!(addr, peer_name.unwrap());\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn socket_and_peer_name_ip4() {\n+        peer_name(next_test_ip4());\n+        socket_name(next_test_ip4());\n+    }\n+\n+    #[test]\n+    fn socket_and_peer_name_ip6() {\n+        // XXX: peer name is not consistent\n+        //peer_name(next_test_ip6());\n+        socket_name(next_test_ip6());\n+    }\n+\n }"}, {"sha": "8e654de47f08eb641a1e41bcc0d760331bed8666", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -13,7 +13,7 @@ use result::{Ok, Err};\n use rt::io::net::ip::IpAddr;\n use rt::io::{Reader, Writer};\n use rt::io::{io_error, read_error, EndOfFile};\n-use rt::rtio::{RtioUdpSocketObject, RtioUdpSocket, IoFactory, IoFactoryObject};\n+use rt::rtio::{RtioSocket, RtioUdpSocketObject, RtioUdpSocket, IoFactory, IoFactoryObject};\n use rt::local::Local;\n \n pub struct UdpSocket(~RtioUdpSocketObject);\n@@ -53,6 +53,17 @@ impl UdpSocket {\n     pub fn connect(self, other: IpAddr) -> UdpStream {\n         UdpStream { socket: self, connectedTo: other }\n     }\n+\n+    pub fn socket_name(&mut self) -> Option<IpAddr> {\n+        match (***self).socket_name() {\n+            Ok(sn) => Some(sn),\n+            Err(ioerr) => {\n+                rtdebug!(\"failed to get socket name: %?\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n }\n \n pub struct UdpStream {\n@@ -252,4 +263,33 @@ mod test {\n             }\n         }\n     }\n+\n+    #[cfg(test)]\n+    fn socket_name(addr: IpAddr) {\n+        do run_in_newsched_task {\n+            do spawntask_immediately {\n+                let server = UdpSocket::bind(addr);\n+\n+                assert!(server.is_some());\n+                let mut server = server.unwrap();\n+\n+                // Make sure socket_name gives\n+                // us the socket we binded to.\n+                let so_name = server.socket_name();\n+                assert!(so_name.is_some());\n+                assert_eq!(addr, so_name.unwrap());\n+\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn socket_name_ip4() {\n+        socket_name(next_test_ip4());\n+    }\n+\n+    #[test]\n+    fn socket_name_ip6() {\n+        socket_name(next_test_ip6());\n+    }\n }"}, {"sha": "d293d46e0126256ba525ad9420ee57fbb42f8025", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -52,39 +52,39 @@ pub trait IoFactory {\n \n pub trait RtioTcpListener : RtioSocket {\n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n-    fn accept_simultaneously(&mut self);\n-    fn dont_accept_simultaneously(&mut self);\n+    fn accept_simultaneously(&mut self) -> Result<(), IoError>;\n+    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n }\n \n pub trait RtioTcpStream : RtioSocket {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n-    fn peer_name(&mut self) -> IpAddr;\n-    fn control_congestion(&mut self);\n-    fn nodelay(&mut self);\n-    fn keepalive(&mut self, delay_in_seconds: uint);\n-    fn letdie(&mut self);\n+    fn peer_name(&mut self) -> Result<IpAddr, IoError>;\n+    fn control_congestion(&mut self) -> Result<(), IoError>;\n+    fn nodelay(&mut self) -> Result<(), IoError>;\n+    fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError>;\n+    fn letdie(&mut self) -> Result<(), IoError>;\n }\n \n pub trait RtioSocket {\n-    fn socket_name(&mut self) -> IpAddr;\n+    fn socket_name(&mut self) -> Result<IpAddr, IoError>;\n }\n \n pub trait RtioUdpSocket : RtioSocket {\n     fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError>;\n     fn sendto(&mut self, buf: &[u8], dst: IpAddr) -> Result<(), IoError>;\n \n-    fn join_multicast(&mut self, multi: IpAddr);\n-    fn leave_multicast(&mut self, multi: IpAddr);\n+    fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError>;\n+    fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError>;\n \n-    fn loop_multicast_locally(&mut self);\n-    fn dont_loop_multicast_locally(&mut self);\n+    fn loop_multicast_locally(&mut self) -> Result<(), IoError>;\n+    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError>;\n \n-    fn multicast_time_to_live(&mut self, ttl: int);\n-    fn time_to_live(&mut self, ttl: int);\n+    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError>;\n+    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError>;\n \n-    fn hear_broadcasts(&mut self);\n-    fn ignore_broadcasts(&mut self);\n+    fn hear_broadcasts(&mut self) -> Result<(), IoError>;\n+    fn ignore_broadcasts(&mut self) -> Result<(), IoError>;\n }\n \n pub trait RtioTimer {"}, {"sha": "feae8b5ffd8a38e08d90afd43a6b02347c6bbbf1", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -50,7 +50,7 @@ pub fn run_in_newsched_task(f: ~fn()) {\n         let on_exit: ~fn(bool) = |exit_status| rtassert!(exit_status);\n         let mut task = ~Task::new_root(&mut sched.stack_pool,\n                                        f.take());\n-        rtdebug!(\"newsched_task: %x\", to_uint(task));\n+        rtdebug!(\"newsched_task: %x\", ::borrow::to_uint(task));\n         task.death.on_exit = Some(on_exit);\n         sched.enqueue_task(task);\n         sched.run();\n@@ -145,7 +145,7 @@ pub fn spawntask(f: ~fn()) {\n         }\n     };\n \n-    rtdebug!(\"new task pointer: %x\", to_uint(task));\n+    rtdebug!(\"new task pointer: %x\", ::borrow::to_uint(task));\n \n     let sched = Local::take::<Scheduler>();\n     rtdebug!(\"spawntask scheduling the new task\");"}, {"sha": "47e0a240e45450fe6914d4b4166dc1b91657ab48", "filename": "src/libstd/rt/uv/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fasync.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -34,7 +34,7 @@ impl AsyncWatcher {\n \n         extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n             let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n-            let status = status_to_maybe_uv_error(watcher.native_handle(), status);\n+            let status = status_to_maybe_uv_error(watcher, status);\n             let data = watcher.get_watcher_data();\n             let cb = data.async_cb.get_ref();\n             (*cb)(watcher, status);"}, {"sha": "b73be9f7250dbead2c7905c5497127e3210d1a93", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -43,7 +43,7 @@ impl IdleWatcher {\n             let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             let data = idle_watcher.get_watcher_data();\n             let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(handle, status);\n+            let status = status_to_maybe_uv_error(idle_watcher, status);\n             (*cb)(idle_watcher, status);\n         }\n     }"}, {"sha": "638d510614a33264957792df8a36a1f70195f9de", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -282,14 +282,14 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n }\n \n /// Given a uv handle, convert a callback status to a UvError\n-// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n-pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n+pub fn status_to_maybe_uv_error<T, U: Watcher + NativeHandle<*T>>(handle: U,\n+                                                                 status: c_int) -> Option<UvError> {\n     if status != -1 {\n         None\n     } else {\n         unsafe {\n-            rtdebug!(\"handle: %x\", handle as uint);\n-            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            rtdebug!(\"handle: %x\", handle.native_handle() as uint);\n+            let loop_ = uvll::get_loop_for_uv_handle(handle.native_handle());\n             rtdebug!(\"loop: %x\", loop_ as uint);\n             let err = uvll::last_error(loop_);\n             Some(UvError(err))"}, {"sha": "a039f3ab7ed2a85d1d96d8c138f43fdec38db9c7", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -22,7 +22,7 @@ use str;\n use from_str::{FromStr};\n use num;\n \n-enum UvIpAddr {\n+pub enum UvIpAddr {\n     UvIpv4(*sockaddr_in),\n     UvIpv6(*sockaddr_in6),\n }\n@@ -32,8 +32,8 @@ fn sockaddr_to_UvIpAddr(addr: *uvll::sockaddr) -> UvIpAddr {\n         assert!((is_ip4_addr(addr) || is_ip6_addr(addr)));\n         assert!(!(is_ip4_addr(addr) && is_ip6_addr(addr)));\n         match addr {\n-            _ if is_ip4_addr(addr) => UvIpv4(as_sockaddr_in(addr)),\n-            _ if is_ip6_addr(addr) => UvIpv6(as_sockaddr_in6(addr)),\n+            _ if is_ip4_addr(addr) => UvIpv4(addr as *uvll::sockaddr_in),\n+            _ if is_ip6_addr(addr) => UvIpv6(addr as *uvll::sockaddr_in6),\n             _ => fail!(),\n         }\n     }\n@@ -113,7 +113,36 @@ fn uv_ip_as_ip<T>(addr: UvIpAddr, f: &fn(IpAddr) -> T) -> T {\n                         };\n                         match s {\n                             \"\" => ~[],\n-                            s => s.split_iter(':').transform(read_hex_segment).collect(),\n+                            // IPv4-Mapped/Compatible IPv6 Address?\n+                            s if s.find('.').is_some() => {\n+                                let i = s.rfind(':').get_or_default(-1);\n+\n+                                let b = s.slice(i + 1, s.len()); // the ipv4 part\n+\n+                                let h = b.split_iter('.')\n+                                   .transform(|s: &str| -> u8 { FromStr::from_str(s).unwrap() })\n+                                   .transform(|s: u8| -> ~str { fmt!(\"%02x\", s as uint) })\n+                                   .collect::<~[~str]>();\n+\n+                                if i == -1 {\n+                                    // Ipv4 Compatible Address (::x.x.x.x)\n+                                    // first 96 bits are zero leaving 32 bits\n+                                    // for the ipv4 part\n+                                    // (i.e ::127.0.0.1 == ::7F00:1)\n+                                    ~[num::FromStrRadix::from_str_radix(h[0] + h[1], 16).unwrap(),\n+                                      num::FromStrRadix::from_str_radix(h[2] + h[3], 16).unwrap()]\n+                                } else {\n+                                    // Ipv4-Mapped Address (::FFFF:x.x.x.x)\n+                                    // first 80 bits are zero, followed by all ones\n+                                    // for the next 16 bits, leaving 32 bits for\n+                                    // the ipv4 part\n+                                    // (i.e ::FFFF:127.0.0.1 == ::FFFF:7F00:1)\n+                                    ~[1,\n+                                      num::FromStrRadix::from_str_radix(h[0] + h[1], 16).unwrap(),\n+                                      num::FromStrRadix::from_str_radix(h[2] + h[3], 16).unwrap()]\n+                                }\n+                            },\n+                            s => s.split_iter(':').transform(read_hex_segment).collect()\n                         }\n                     };\n                     s.split_str_iter(\"::\").transform(convert_each_segment).collect()\n@@ -133,7 +162,7 @@ fn uv_ip_as_ip<T>(addr: UvIpAddr, f: &fn(IpAddr) -> T) -> T {\n     f(ip)\n }\n \n-fn uv_ip_to_ip(addr: UvIpAddr) -> IpAddr {\n+pub fn uv_ip_to_ip(addr: UvIpAddr) -> IpAddr {\n     use util;\n     uv_ip_as_ip(addr, util::id)\n }\n@@ -154,7 +183,7 @@ fn test_ip6_conversion() {\n     assert_eq!(ip6, ip_as_uv_ip(ip6, uv_ip_to_ip));\n }\n \n-// uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n+// uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n // and uv_file_t\n pub struct StreamWatcher(*uvll::uv_stream_t);\n impl Watcher for StreamWatcher { }\n@@ -180,7 +209,7 @@ impl StreamWatcher {\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n             let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n-            let status = status_to_maybe_uv_error(stream, nread as c_int);\n+            let status = status_to_maybe_uv_error(stream_watcher, nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n         }\n     }\n@@ -210,7 +239,7 @@ impl StreamWatcher {\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n             let cb = stream_watcher.get_watcher_data().write_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n+            let status = status_to_maybe_uv_error(stream_watcher, status);\n             cb(stream_watcher, status);\n         }\n     }\n@@ -302,7 +331,7 @@ impl TcpWatcher {\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n                 let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n-                let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n+                let status = status_to_maybe_uv_error(stream_watcher, status);\n                 cb(stream_watcher, status);\n             }\n         }\n@@ -325,7 +354,7 @@ impl TcpWatcher {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n             let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n-            let status = status_to_maybe_uv_error(handle, status);\n+            let status = status_to_maybe_uv_error(stream_watcher, status);\n             (*cb)(stream_watcher, status);\n         }\n     }\n@@ -402,7 +431,7 @@ impl UdpWatcher {\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n             let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n-            let status = status_to_maybe_uv_error(handle, nread as c_int);\n+            let status = status_to_maybe_uv_error(udp_watcher, nread as c_int);\n             let addr = uv_ip_to_ip(sockaddr_to_UvIpAddr(addr));\n             (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n         }\n@@ -437,7 +466,7 @@ impl UdpWatcher {\n             let mut udp_watcher = send_request.handle();\n             send_request.delete();\n             let cb = udp_watcher.get_watcher_data().udp_send_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(udp_watcher.native_handle(), status);\n+            let status = status_to_maybe_uv_error(udp_watcher, status);\n             cb(udp_watcher, status);\n         }\n     }"}, {"sha": "eaa5e77a6da2fe71b3a67a11105dc5acee18c4f5", "filename": "src/libstd/rt/uv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -43,7 +43,7 @@ impl TimerWatcher {\n             let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n             let data = watcher.get_watcher_data();\n             let cb = data.timer_cb.get_ref();\n-            let status = status_to_maybe_uv_error(handle, status);\n+            let status = status_to_maybe_uv_error(watcher, status);\n             (*cb)(watcher, status);\n         }\n     }"}, {"sha": "fc4a668bdf662222d84f3c0c209acba65068c22f", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 240, "deletions": 34, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -15,15 +15,19 @@ use cell::Cell;\n use cast;\n use cast::transmute;\n use clone::Clone;\n+use libc::{c_int, c_uint, c_void};\n+use ptr;\n use rt::io::IoError;\n-use rt::io::net::ip::IpAddr;\n+use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n+use rt::uv::net::{UvIpv4, UvIpv6};\n use rt::rtio::*;\n use rt::sched::Scheduler;\n use rt::io::{standard_error, OtherIoError};\n use rt::tube::Tube;\n use rt::local::Local;\n+use str::StrSlice;\n use unstable::sync::{Exclusive, exclusive};\n \n #[cfg(test)] use container::Container;\n@@ -33,6 +37,47 @@ use unstable::sync::{Exclusive, exclusive};\n                             next_test_ip4,\n                             run_in_newsched_task};\n \n+enum SocketNameKind {\n+    TcpPeer,\n+    Tcp,\n+    Udp\n+}\n+\n+fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n+                                                 handle: U) -> Result<IpAddr, IoError> {\n+\n+    let getsockname = match sk {\n+        TcpPeer => uvll::rust_uv_tcp_getpeername,\n+        Tcp     => uvll::rust_uv_tcp_getsockname,\n+        Udp     => uvll::rust_uv_udp_getsockname\n+    };\n+\n+    // Allocate a sockaddr_storage\n+    // since we don't know if it's ipv4 or ipv6\n+    let r_addr = unsafe { uvll::malloc_sockaddr_storage() };\n+\n+    let r = unsafe {\n+        getsockname(handle.native_handle() as *c_void, r_addr as *uvll::sockaddr_storage)\n+    };\n+\n+    if r != 0 {\n+        let status = status_to_maybe_uv_error(handle, r);\n+        return Err(uv_error_to_io_error(status.unwrap()));\n+    }\n+\n+    let addr = unsafe {\n+        if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n+            net::uv_ip_to_ip(UvIpv6(r_addr as *uvll::sockaddr_in6))\n+        } else {\n+            net::uv_ip_to_ip(UvIpv4(r_addr as *uvll::sockaddr_in))\n+        }\n+    };\n+\n+    unsafe { uvll::free_sockaddr_storage(r_addr); }\n+\n+    Ok(addr)\n+\n+}\n \n pub struct UvEventLoop {\n     uvio: UvIoFactory\n@@ -220,7 +265,9 @@ impl IoFactory for UvIoFactory {\n                 rtdebug!(\"connect: in connect callback\");\n                 if status.is_none() {\n                     rtdebug!(\"status is none\");\n-                    let res = Ok(~UvTcpStream(stream_watcher));\n+                    let tcp_watcher =\n+                        NativeHandle::from_native_handle(stream_watcher.native_handle());\n+                    let res = Ok(~UvTcpStream(tcp_watcher));\n \n                     // Store the stream in the task's stack\n                     unsafe { (*result_cell_ptr).put_back(res); }\n@@ -286,7 +333,6 @@ impl IoFactory for UvIoFactory {\n     }\n }\n \n-// FIXME #6090: Prefer newtype structs but Drop doesn't work\n pub struct UvTcpListener {\n     watcher: TcpWatcher,\n     listening: bool,\n@@ -320,8 +366,9 @@ impl Drop for UvTcpListener {\n }\n \n impl RtioSocket for UvTcpListener {\n-    // XXX implement\n-    fn socket_name(&mut self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> Result<IpAddr, IoError> {\n+        socket_name(Tcp, self.watcher)\n+    }\n }\n \n impl RtioTcpListener for UvTcpListener {\n@@ -344,9 +391,8 @@ impl RtioTcpListener for UvTcpListener {\n             let maybe_stream = if status.is_none() {\n                 let mut loop_ = server_stream_watcher.event_loop();\n                 let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                let client_tcp_watcher = client_tcp_watcher.as_stream();\n                 // XXX: Need's to be surfaced in interface\n-                server_stream_watcher.accept(client_tcp_watcher);\n+                server_stream_watcher.accept(client_tcp_watcher.as_stream());\n                 Ok(~UvTcpStream(client_tcp_watcher))\n             } else {\n                 Err(standard_error(OtherIoError))\n@@ -360,21 +406,38 @@ impl RtioTcpListener for UvTcpListener {\n         return self.incoming_streams.recv();\n     }\n \n-    // XXX implement\n-    fn accept_simultaneously(&mut self) { fail!(); }\n-    fn dont_accept_simultaneously(&mut self) { fail!(); }\n+    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::rust_uv_tcp_simultaneous_accepts(self.watcher.native_handle(), 1 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(self.watcher, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::rust_uv_tcp_simultaneous_accepts(self.watcher.native_handle(), 0 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(self.watcher, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n }\n \n-// FIXME #6090: Prefer newtype structs but Drop doesn't work\n-pub struct UvTcpStream(StreamWatcher);\n+pub struct UvTcpStream(TcpWatcher);\n \n impl Drop for UvTcpStream {\n     fn drop(&self) {\n         rtdebug!(\"closing tcp stream\");\n         let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n-            do self.close {\n+            do self.as_stream().close {\n                 let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n@@ -383,8 +446,9 @@ impl Drop for UvTcpStream {\n }\n \n impl RtioSocket for UvTcpStream {\n-    // XXX implement\n-    fn socket_name(&mut self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> Result<IpAddr, IoError> {\n+        socket_name(Tcp, **self)\n+    }\n }\n \n impl RtioTcpStream for UvTcpStream {\n@@ -404,7 +468,7 @@ impl RtioTcpStream for UvTcpStream {\n             let alloc: AllocCallback = |_| unsafe {\n                 slice_to_uv_buf(*buf_ptr)\n             };\n-            let mut watcher = **self;\n+            let mut watcher = self.as_stream();\n             do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n \n                 // Stop reading so that no read callbacks are\n@@ -440,7 +504,7 @@ impl RtioTcpStream for UvTcpStream {\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n             let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            let mut watcher = **self;\n+            let mut watcher = self.as_stream();\n             do watcher.write(buf) |_watcher, status| {\n                 let result = if status.is_none() {\n                     Ok(())\n@@ -459,12 +523,54 @@ impl RtioTcpStream for UvTcpStream {\n         return result_cell.take();\n     }\n \n-    // XXX implement\n-    fn peer_name(&mut self) -> IpAddr { fail!(); }\n-    fn control_congestion(&mut self) { fail!(); }\n-    fn nodelay(&mut self) { fail!(); }\n-    fn keepalive(&mut self, _delay_in_seconds: uint) { fail!(); }\n-    fn letdie(&mut self) { fail!(); }\n+    fn peer_name(&mut self) -> Result<IpAddr, IoError> {\n+        socket_name(TcpPeer, **self)\n+    }\n+\n+    fn control_congestion(&mut self) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::rust_uv_tcp_nodelay(self.native_handle(), 0 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn nodelay(&mut self) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::rust_uv_tcp_nodelay(self.native_handle(), 1 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::rust_uv_tcp_keepalive(self.native_handle(), 1 as c_int,\n+                                        delay_in_seconds as c_uint)\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn letdie(&mut self) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::rust_uv_tcp_keepalive(self.native_handle(), 0 as c_int, 0 as c_uint)\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n }\n \n pub struct UvUdpSocket(UdpWatcher);\n@@ -484,8 +590,9 @@ impl Drop for UvUdpSocket {\n }\n \n impl RtioSocket for UvUdpSocket {\n-    // XXX implement\n-    fn socket_name(&mut self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> Result<IpAddr, IoError> {\n+        socket_name(Udp, **self)\n+    }\n }\n \n impl RtioUdpSocket for UvUdpSocket {\n@@ -552,18 +659,117 @@ impl RtioUdpSocket for UvUdpSocket {\n         return result_cell.take();\n     }\n \n-    // XXX implement\n-    fn join_multicast(&mut self, _multi: IpAddr) { fail!(); }\n-    fn leave_multicast(&mut self, _multi: IpAddr) { fail!(); }\n+    fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n+        let ip_str = match multi {\n+            Ipv4(x1, x2, x3, x4, _) =>\n+                fmt!(\"%u.%u.%u.%u\", x1 as uint, x2 as uint, x3 as uint, x4 as uint),\n+            Ipv6(x1, x2, x3, x4, x5, x6, x7, x8, _) =>\n+                fmt!(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                      x1 as uint, x2 as uint, x3 as uint, x4 as uint,\n+                      x5 as uint, x6 as uint, x7 as uint, x8 as uint),\n+        };\n+\n+        let r = unsafe {\n+            do ip_str.as_c_str |m_addr| {\n+                uvll::udp_set_membership(self.native_handle(), m_addr,\n+                                         ptr::null(), uvll::UV_JOIN_GROUP)\n+            }\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n \n-    fn loop_multicast_locally(&mut self) { fail!(); }\n-    fn dont_loop_multicast_locally(&mut self) { fail!(); }\n+    fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n+        let ip_str = match multi {\n+            Ipv4(x1, x2, x3, x4, _) =>\n+                fmt!(\"%u.%u.%u.%u\", x1 as uint, x2 as uint, x3 as uint, x4 as uint),\n+            Ipv6(x1, x2, x3, x4, x5, x6, x7, x8, _) =>\n+                fmt!(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                      x1 as uint, x2 as uint, x3 as uint, x4 as uint,\n+                      x5 as uint, x6 as uint, x7 as uint, x8 as uint),\n+        };\n \n-    fn multicast_time_to_live(&mut self, _ttl: int) { fail!(); }\n-    fn time_to_live(&mut self, _ttl: int) { fail!(); }\n+        let r = unsafe {\n+            do ip_str.as_c_str |m_addr| {\n+                uvll::udp_set_membership(self.native_handle(), m_addr,\n+                                         ptr::null(), uvll::UV_LEAVE_GROUP)\n+            }\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::udp_set_multicast_loop(self.native_handle(), 1 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::udp_set_multicast_loop(self.native_handle(), 0 as c_int)\n+        };\n \n-    fn hear_broadcasts(&mut self) { fail!(); }\n-    fn ignore_broadcasts(&mut self) { fail!(); }\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::udp_set_multicast_ttl(self.native_handle(), ttl as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::udp_set_ttl(self.native_handle(), ttl as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::udp_set_broadcast(self.native_handle(), 1 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n+        let r = unsafe {\n+            uvll::udp_set_broadcast(self.native_handle(), 0 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(**self, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n }\n \n pub struct UvTimer(timer::TimerWatcher);"}, {"sha": "07264839c3555dda0107bdc085540cf2168d98b8", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -77,7 +77,7 @@ pub type uv_udp_recv_cb = *u8;\n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n pub type sockaddr_in6 = c_void;\n-pub type uv_membership = c_void;\n+pub type sockaddr_storage = c_void;\n \n #[deriving(Eq)]\n pub enum uv_handle_type {\n@@ -116,6 +116,12 @@ pub enum uv_req_type {\n     UV_REQ_TYPE_MAX\n }\n \n+#[deriving(Eq)]\n+pub enum uv_membership {\n+    UV_LEAVE_GROUP,\n+    UV_JOIN_GROUP\n+}\n+\n pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n     assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n     let size = rust_uv_handle_size(handle as uint);\n@@ -233,17 +239,13 @@ pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_\n     return rust_uv_get_udp_handle_from_send_req(send_req);\n }\n \n-pub unsafe fn udp_get_sockname(handle: *uv_udp_t, name: *sockaddr_in) -> c_int {\n+pub unsafe fn udp_get_sockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n     return rust_uv_udp_getsockname(handle, name);\n }\n \n-pub unsafe fn udp_get_sockname6(handle: *uv_udp_t, name: *sockaddr_in6) -> c_int {\n-    return rust_uv_udp_getsockname6(handle, name);\n-}\n-\n pub unsafe fn udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n                                  interface_addr: *c_char, membership: uv_membership) -> c_int {\n-    return rust_uv_udp_set_membership(handle, multicast_addr, interface_addr, membership);\n+    return rust_uv_udp_set_membership(handle, multicast_addr, interface_addr, membership as c_int);\n }\n \n pub unsafe fn udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int {\n@@ -254,6 +256,10 @@ pub unsafe fn udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n     return rust_uv_udp_set_multicast_ttl(handle, ttl);\n }\n \n+pub unsafe fn udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n+    return rust_uv_udp_set_ttl(handle, ttl);\n+}\n+\n pub unsafe fn udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int {\n     return rust_uv_udp_set_broadcast(handle, on);\n }\n@@ -280,22 +286,14 @@ pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t, addr_ptr: *sockaddr_in6) -> c\n     return rust_uv_tcp_bind6(tcp_server_ptr, addr_ptr);\n }\n \n-pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in) -> c_int {\n+pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n     return rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n }\n \n-pub unsafe fn tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) ->c_int {\n-    return rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n-}\n-\n-pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_in) -> c_int {\n+pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int {\n     return rust_uv_tcp_getsockname(handle, name);\n }\n \n-pub unsafe fn tcp_getsockname6(handle: *uv_tcp_t, name: *sockaddr_in6) -> c_int {\n-    return rust_uv_tcp_getsockname6(handle, name);\n-}\n-\n pub unsafe fn tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int {\n     return rust_uv_tcp_nodelay(handle, enable);\n }\n@@ -373,14 +371,6 @@ pub unsafe fn is_ip6_addr(addr: *sockaddr) -> bool {\n     match rust_uv_is_ipv6_sockaddr(addr) { 0 => false, _ => true }\n }\n \n-pub unsafe fn as_sockaddr_in(addr: *sockaddr) -> *sockaddr_in {\n-    return rust_uv_sockaddr_as_sockaddr_in(addr);\n-}\n-\n-pub unsafe fn as_sockaddr_in6(addr: *sockaddr) -> *sockaddr_in6 {\n-    return rust_uv_sockaddr_as_sockaddr_in6(addr);\n-}\n-\n pub unsafe fn malloc_ip4_addr(ip: &str, port: int) -> *sockaddr_in {\n     do ip.as_c_str |ip_buf| {\n         rust_uv_ip4_addrp(ip_buf as *u8, port as libc::c_int)\n@@ -392,6 +382,14 @@ pub unsafe fn malloc_ip6_addr(ip: &str, port: int) -> *sockaddr_in6 {\n     }\n }\n \n+pub unsafe fn malloc_sockaddr_storage() -> *sockaddr_storage {\n+    rust_uv_malloc_sockaddr_storage()\n+}\n+\n+pub unsafe fn free_sockaddr_storage(ss: *sockaddr_storage) {\n+    rust_uv_free_sockaddr_storage(ss);\n+}\n+\n pub unsafe fn free_ip4_addr(addr: *sockaddr_in) {\n     rust_uv_free_ip4_addr(addr);\n }\n@@ -520,10 +518,8 @@ extern {\n     fn rust_uv_tcp_connect6(req: *uv_connect_t, handle: *uv_tcp_t, cb: *u8,\n                             addr: *sockaddr_in6) -> c_int;\n     fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n-    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_in6) ->c_int;\n-    fn rust_uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_in) -> c_int;\n-    fn rust_uv_tcp_getsockname6(handle: *uv_tcp_t, name: *sockaddr_in6) -> c_int;\n+    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n+    fn rust_uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n     fn rust_uv_tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int;\n     fn rust_uv_tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int;\n     fn rust_uv_tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int;\n@@ -538,18 +534,18 @@ extern {\n     fn rust_uv_udp_recv_start(server: *uv_udp_t, on_alloc: *u8, on_recv: *u8) -> c_int;\n     fn rust_uv_udp_recv_stop(server: *uv_udp_t) -> c_int;\n     fn rust_uv_get_udp_handle_from_send_req(req: *uv_udp_send_t) -> *uv_udp_t;\n-    fn rust_uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr_in) -> c_int;\n-    fn rust_uv_udp_getsockname6(handle: *uv_udp_t, name: *sockaddr_in6) -> c_int;\n+    fn rust_uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int;\n     fn rust_uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n-                                  interface_addr: *c_char, membership: uv_membership) -> c_int;\n+                                  interface_addr: *c_char, membership: c_int) -> c_int;\n     fn rust_uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int;\n     fn rust_uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n+    fn rust_uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n     fn rust_uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int;\n \n     fn rust_uv_is_ipv4_sockaddr(addr: *sockaddr) -> c_int;\n     fn rust_uv_is_ipv6_sockaddr(addr: *sockaddr) -> c_int;\n-    fn rust_uv_sockaddr_as_sockaddr_in(addr: *sockaddr) -> *sockaddr_in;\n-    fn rust_uv_sockaddr_as_sockaddr_in6(addr: *sockaddr) -> *sockaddr_in6;\n+    fn rust_uv_malloc_sockaddr_storage() -> *sockaddr_storage;\n+    fn rust_uv_free_sockaddr_storage(ss: *sockaddr_storage);\n \n     fn rust_uv_listen(stream: *c_void, backlog: c_int, cb: *u8) -> c_int;\n     fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;"}, {"sha": "7a5e1116c3294f4458a1639ecaf0305d2a10fb8a", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -71,8 +71,8 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n             let mut alloc = ::ptr::null();\n             do Local::borrow::<Task,()> |task| {\n                 rtdebug!(\"task pointer: %x, heap pointer: %x\",\n-                         to_uint(task),\n-                         to_uint(&task.heap));\n+                         ::borrow::to_uint(task),\n+                         ::borrow::to_uint(&task.heap));\n                 alloc = task.heap.alloc(td as *c_void, size as uint) as *c_char;\n             }\n             return alloc;"}, {"sha": "19162b8df6b0f163ee0bd8f4af692a34ffb7b18c", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -282,29 +282,19 @@ rust_uv_tcp_bind6\n \n extern \"C\" int\n rust_uv_tcp_getpeername\n-(uv_tcp_t* handle, sockaddr_in* name) {\n+(uv_tcp_t* handle, sockaddr_storage* name) {\n+    // sockaddr_storage is big enough to hold either\n+    // sockaddr_in or sockaddr_in6\n     int namelen = sizeof(sockaddr_in);\n     return uv_tcp_getpeername(handle, (sockaddr*)name, &namelen);\n }\n \n-extern \"C\" int\n-rust_uv_tcp_getpeername6\n-(uv_tcp_t* handle, sockaddr_in6* name) {\n-    int namelen = sizeof(sockaddr_in6);\n-    return uv_tcp_getpeername(handle, (sockaddr*)name, &namelen);\n-}\n-\n extern \"C\" int\n rust_uv_tcp_getsockname\n-(uv_tcp_t* handle, sockaddr_in* name) {\n-    int namelen = sizeof(sockaddr_in);\n-    return uv_tcp_getsockname(handle, (sockaddr*)name, &namelen);\n-}\n-\n-extern \"C\" int\n-rust_uv_tcp_getsockname6\n-(uv_tcp_t* handle, sockaddr_in6* name) {\n-    int namelen = sizeof(sockaddr_in6);\n+(uv_tcp_t* handle, sockaddr_storage* name) {\n+    // sockaddr_storage is big enough to hold either\n+    // sockaddr_in or sockaddr_in6\n+    int namelen = sizeof(sockaddr_storage);\n     return uv_tcp_getsockname(handle, (sockaddr*)name, &namelen);\n }\n \n@@ -370,15 +360,10 @@ rust_uv_get_udp_handle_from_send_req(uv_udp_send_t* send_req) {\n \n extern \"C\" int\n rust_uv_udp_getsockname\n-(uv_udp_t* handle, sockaddr_in* name) {\n-    int namelen = sizeof(sockaddr_in);\n-    return uv_udp_getsockname(handle, (sockaddr*)name, &namelen);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_getsockname6\n-(uv_udp_t* handle, sockaddr_in6* name) {\n-    int namelen = sizeof(sockaddr_in6);\n+(uv_udp_t* handle, sockaddr_storage* name) {\n+    // sockaddr_storage is big enough to hold either\n+    // sockaddr_in or sockaddr_in6\n+    int namelen = sizeof(sockaddr_storage);\n     return uv_udp_getsockname(handle, (sockaddr*)name, &namelen);\n }\n \n@@ -400,6 +385,12 @@ rust_uv_udp_set_multicast_ttl\n     return uv_udp_set_multicast_ttl(handle, ttl);\n }\n \n+extern \"C\" int\n+rust_uv_udp_set_ttl\n+(uv_udp_t* handle, int ttl) {\n+    return uv_udp_set_ttl(handle, ttl);\n+}\n+\n extern \"C\" int\n rust_uv_udp_set_broadcast\n (uv_udp_t* handle, int on) {\n@@ -609,6 +600,17 @@ rust_uv_ip6_addrp(const char* ip, int port) {\n   return addrp;\n }\n \n+extern \"C\" struct sockaddr_storage *\n+rust_uv_malloc_sockaddr_storage() {\n+    struct sockaddr_storage *ss = (sockaddr_storage *)malloc(sizeof(struct sockaddr_storage));\n+    return ss;\n+}\n+\n+extern \"C\" void\n+rust_uv_free_sockaddr_storage(struct sockaddr_storage *ss) {\n+    free(ss);\n+}\n+\n extern \"C\" void\n rust_uv_free_ip4_addr(sockaddr_in *addrp) {\n   free(addrp);\n@@ -669,18 +671,6 @@ rust_uv_is_ipv6_sockaddr(sockaddr* addr) {\n     return addr->sa_family == AF_INET6;\n }\n \n-extern \"C\" sockaddr_in*\n-rust_uv_sockaddr_as_sockaddr_in(sockaddr* addr) {\n-//    return (sockaddr_in*)addr->sa_data;\n-    return (sockaddr_in*)addr;\n-}\n-\n-extern \"C\" sockaddr_in6*\n-rust_uv_sockaddr_as_sockaddr_in6(sockaddr* addr) {\n-    //return (sockaddr_in6*)addr->sa_data;\n-    return (sockaddr_in6*)addr;\n-}\n-\n extern \"C\" bool\n rust_uv_is_ipv4_addrinfo(addrinfo* input) {\n     return input->ai_family == AF_INET;"}, {"sha": "fc7796ef66ce506f108c9f056bd456d166bde74d", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/15310ba7c2a930a26bf6104f336cf7220eec7dc7/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=15310ba7c2a930a26bf6104f336cf7220eec7dc7", "patch": "@@ -106,7 +106,6 @@ rust_uv_tcp_bind\n rust_uv_tcp_connect6\n rust_uv_tcp_bind6\n rust_uv_tcp_getsockname\n-rust_uv_tcp_getsockname6\n rust_uv_tcp_nodelay\n rust_uv_tcp_keepalive\n rust_uv_tcp_simultaneous_accepts\n@@ -119,15 +118,15 @@ rust_uv_udp_recv_start\n rust_uv_udp_recv_stop\n rust_uv_get_udp_handle_from_send_req\n rust_uv_udp_getsockname\n-rust_uv_udp_getsockname6\n rust_uv_udp_set_membership\n rust_uv_udp_set_multicast_loop\n rust_uv_udp_set_multicast_ttl\n+rust_uv_udp_set_ttl\n rust_uv_udp_set_broadcast\n rust_uv_is_ipv4_sockaddr\n rust_uv_is_ipv6_sockaddr\n-rust_uv_sockaddr_as_sockaddr_in\n-rust_uv_sockaddr_as_sockaddr_in6\n+rust_uv_malloc_sockaddr_storage\n+rust_uv_free_sockaddr_storage\n rust_uv_listen\n rust_uv_accept\n rust_uv_write\n@@ -204,7 +203,6 @@ rust_update_gc_metadata\n rust_uv_ip4_port\n rust_uv_ip6_port\n rust_uv_tcp_getpeername\n-rust_uv_tcp_getpeername6\n linenoise\n linenoiseSetCompletionCallback\n linenoiseAddCompletion\n@@ -267,4 +265,4 @@ rust_drop_global_args_lock\n rust_set_exit_status_newrt\n rust_get_exit_status_newrt\n rust_take_change_dir_lock\n-rust_drop_change_dir_lock\n\\ No newline at end of file\n+rust_drop_change_dir_lock"}]}