{"sha": "600607f45a400e5930126b5ef1dc05f5644e95c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMDYwN2Y0NWE0MDBlNTkzMDEyNmI1ZWYxZGMwNWY1NjQ0ZTk1YzM=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-10-20T16:16:58Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-10-22T11:26:32Z"}, "message": "Move `search_for_adt_without_structural_match` to `ty/mod`", "tree": {"sha": "ab10a8c0a24e9649c5306789d37060f7b32f2230", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab10a8c0a24e9649c5306789d37060f7b32f2230"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/600607f45a400e5930126b5ef1dc05f5644e95c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/600607f45a400e5930126b5ef1dc05f5644e95c3", "html_url": "https://github.com/rust-lang/rust/commit/600607f45a400e5930126b5ef1dc05f5644e95c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/600607f45a400e5930126b5ef1dc05f5644e95c3/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50ffa79589600f515ff2710830c23cd2dce7cb76", "url": "https://api.github.com/repos/rust-lang/rust/commits/50ffa79589600f515ff2710830c23cd2dce7cb76", "html_url": "https://github.com/rust-lang/rust/commit/50ffa79589600f515ff2710830c23cd2dce7cb76"}], "stats": {"total": 239, "additions": 116, "deletions": 123}, "files": [{"sha": "77d8141c9688c6ed8c3be60ff659c725cc02fbf9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 115, "deletions": 2, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/600607f45a400e5930126b5ef1dc05f5644e95c3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/600607f45a400e5930126b5ef1dc05f5644e95c3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=600607f45a400e5930126b5ef1dc05f5644e95c3", "patch": "@@ -4,7 +4,7 @@ pub use self::Variance::*;\n pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n-pub use self::fold::TypeFoldable;\n+pub use self::fold::{TypeFoldable, TypeVisitor};\n \n use crate::hir::{map as hir_map, GlobMap, TraitMap};\n use crate::hir::Node;\n@@ -50,7 +50,7 @@ use syntax::symbol::{kw, sym, Symbol, InternedString};\n use syntax_pos::Span;\n \n use smallvec;\n-use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -3393,6 +3393,119 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     fn_like.asyncness()\n }\n \n+/// This method traverses the structure of `ty`, trying to find an\n+/// instance of an ADT (i.e. struct or enum) that was declared without\n+/// the `#[structural_match]` attribute.\n+///\n+/// The \"structure of a type\" includes all components that would be\n+/// considered when doing a pattern match on a constant of that\n+/// type.\n+///\n+///  * This means this method descends into fields of structs/enums,\n+///    and also descends into the inner type `T` of `&T` and `&mut T`\n+///\n+///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n+///    `*mut T`), and it does not visit the type arguments of an\n+///    instantiated generic like `PhantomData<T>`.\n+///\n+/// The reason we do this search is Rust currently require all ADTs\n+/// reachable from a constant's type to be annotated with\n+/// `#[structural_match]`, an attribute which essentially says that\n+/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n+/// comparison against the unfolded structure.\n+///\n+/// For more background on why Rust has this requirement, and issues\n+/// that arose when the requirement was not enforced completely, see\n+/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n+pub fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n+                                                 ty: Ty<'tcx>)\n+                                                 -> Option<&'tcx AdtDef>\n+{\n+    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n+    ty.visit_with(&mut search);\n+    return search.found;\n+\n+    struct Search<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+\n+        // records the first ADT we find without `#[structural_match`\n+        found: Option<&'tcx AdtDef>,\n+\n+        // tracks ADT's previously encountered during search, so that\n+        // we will not recur on them again.\n+        seen: FxHashSet<hir::def_id::DefId>,\n+    }\n+\n+    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            debug!(\"Search visiting ty: {:?}\", ty);\n+\n+            let (adt_def, substs) = match ty.kind {\n+                ty::Adt(adt_def, substs) => (adt_def, substs),\n+                ty::RawPtr(..) => {\n+                    // `#[structural_match]` ignores substructure of\n+                    // `*const _`/`*mut _`, so skip super_visit_with\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::FnDef(..) | ty::FnPtr(..) => {\n+                    // types of formals and return in `fn(_) -> _` are also irrelevant\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n+                => {\n+                    // rust-lang/rust#62336: ignore type of contents\n+                    // for empty array.\n+                    return false;\n+                }\n+                _ => {\n+                    ty.super_visit_with(self);\n+                    return false;\n+                }\n+            };\n+\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n+                self.found = Some(&adt_def);\n+                debug!(\"Search found adt_def: {:?}\", adt_def);\n+                return true // Halt visiting!\n+            }\n+\n+            if !self.seen.insert(adt_def.did) {\n+                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n+                // let caller continue its search\n+                return false;\n+            }\n+\n+            // `#[structural_match]` does not care about the\n+            // instantiation of the generics in an ADT (it\n+            // instead looks directly at its fields outside\n+            // this match), so we skip super_visit_with.\n+            //\n+            // (Must not recur on substs for `PhantomData<T>` cf\n+            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n+            // want to skip substs when only uses of generic are\n+            // behind unsafe pointers `*const T`/`*mut T`.)\n+\n+            // even though we skip super_visit_with, we must recur on\n+            // fields of ADT.\n+            let tcx = self.tcx;\n+            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n+                if field_ty.visit_with(self) {\n+                    // found an ADT without `#[structural_match]`; halt visiting!\n+                    assert!(self.found.is_some());\n+                    return true;\n+                }\n+            }\n+\n+            // Even though we do not want to recur on substs, we do\n+            // want our caller to continue its own search.\n+            false\n+        }\n+    }\n+}\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);"}, {"sha": "d99688122185725985c9703390f626e500a5f515", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 121, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/600607f45a400e5930126b5ef1dc05f5644e95c3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/600607f45a400e5930126b5ef1dc05f5644e95c3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=600607f45a400e5930126b5ef1dc05f5644e95c3", "patch": "@@ -25,7 +25,6 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::hir::ptr::P;\n \n use rustc_index::vec::Idx;\n-use rustc_data_structures::fx::FxHashSet;\n \n use std::cmp::Ordering;\n use std::fmt;\n@@ -1000,7 +999,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         if self.include_lint_checks && !saw_error {\n             // If we were able to successfully convert the const to some pat, double-check\n             // that the type of the const obeys `#[structural_match]` constraint.\n-            if let Some(adt_def) = search_for_adt_without_structural_match(self.tcx, cv.ty) {\n+            if let Some(adt_def) = ty::search_for_adt_without_structural_match(self.tcx, cv.ty) {\n \n                 let path = self.tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n@@ -1169,125 +1168,6 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     }\n }\n \n-/// This method traverses the structure of `ty`, trying to find an\n-/// instance of an ADT (i.e. struct or enum) that was declared without\n-/// the `#[structural_match]` attribute.\n-///\n-/// The \"structure of a type\" includes all components that would be\n-/// considered when doing a pattern match on a constant of that\n-/// type.\n-///\n-///  * This means this method descends into fields of structs/enums,\n-///    and also descends into the inner type `T` of `&T` and `&mut T`\n-///\n-///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n-///    `*mut T`), and it does not visit the type arguments of an\n-///    instantiated generic like `PhantomData<T>`.\n-///\n-/// The reason we do this search is Rust currently require all ADT's\n-/// reachable from a constant's type to be annotated with\n-/// `#[structural_match]`, an attribute which essentially says that\n-/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n-/// comparison against the unfolded structure.\n-///\n-/// For more background on why Rust has this requirement, and issues\n-/// that arose when the requirement was not enforced completely, see\n-/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n-fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n-                                                 ty: Ty<'tcx>)\n-                                                 -> Option<&'tcx AdtDef>\n-{\n-    // Import here (not mod level), because `TypeFoldable::fold_with`\n-    // conflicts with `PatternFoldable::fold_with`\n-    use crate::rustc::ty::fold::TypeVisitor;\n-    use crate::rustc::ty::TypeFoldable;\n-\n-    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n-    ty.visit_with(&mut search);\n-    return search.found;\n-\n-    struct Search<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        // records the first ADT we find without `#[structural_match`\n-        found: Option<&'tcx AdtDef>,\n-\n-        // tracks ADT's previously encountered during search, so that\n-        // we will not recur on them again.\n-        seen: FxHashSet<hir::def_id::DefId>,\n-    }\n-\n-    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-            debug!(\"Search visiting ty: {:?}\", ty);\n-\n-            let (adt_def, substs) = match ty.kind {\n-                ty::Adt(adt_def, substs) => (adt_def, substs),\n-                ty::RawPtr(..) => {\n-                    // `#[structural_match]` ignores substructure of\n-                    // `*const _`/`*mut _`, so skip super_visit_with\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::FnDef(..) | ty::FnPtr(..) => {\n-                    // types of formals and return in `fn(_) -> _` are also irrelevant\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n-                => {\n-                    // rust-lang/rust#62336: ignore type of contents\n-                    // for empty array.\n-                    return false;\n-                }\n-                _ => {\n-                    ty.super_visit_with(self);\n-                    return false;\n-                }\n-            };\n-\n-            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n-                self.found = Some(&adt_def);\n-                debug!(\"Search found adt_def: {:?}\", adt_def);\n-                return true // Halt visiting!\n-            }\n-\n-            if !self.seen.insert(adt_def.did) {\n-                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-                // let caller continue its search\n-                return false;\n-            }\n-\n-            // `#[structural_match]` does not care about the\n-            // instantiation of the generics in an ADT (it\n-            // instead looks directly at its fields outside\n-            // this match), so we skip super_visit_with.\n-            //\n-            // (Must not recur on substs for `PhantomData<T>` cf\n-            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n-            // want to skip substs when only uses of generic are\n-            // behind unsafe pointers `*const T`/`*mut T`.)\n-\n-            // even though we skip super_visit_with, we must recur on\n-            // fields of ADT.\n-            let tcx = self.tcx;\n-            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n-                if field_ty.visit_with(self) {\n-                    // found an ADT without `#[structural_match]`; halt visiting!\n-                    assert!(self.found.is_some());\n-                    return true;\n-                }\n-            }\n-\n-            // Even though we do not want to recur on substs, we do\n-            // want our caller to continue its own search.\n-            false\n-        }\n-    }\n-}\n-\n impl UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx"}]}