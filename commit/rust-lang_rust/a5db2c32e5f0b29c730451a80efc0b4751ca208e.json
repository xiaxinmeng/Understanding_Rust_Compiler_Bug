{"sha": "a5db2c32e5f0b29c730451a80efc0b4751ca208e", "node_id": "C_kwDOAAsO6NoAKGE1ZGIyYzMyZTVmMGIyOWM3MzA0NTFhODBlZmMwYjQ3NTFjYTIwOGU", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-12T19:31:40Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-12T19:31:40Z"}, "message": "Refactor to hide *_next_id functions", "tree": {"sha": "d636b9c5136966dbd94fdbba5181399dc0663039", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d636b9c5136966dbd94fdbba5181399dc0663039"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5db2c32e5f0b29c730451a80efc0b4751ca208e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmJ9YJwACgkQGBtJ+fOP\nM3Qekgv/cGELOZV4/kDK0mOxxZTXmTncFNj2cOEBkreB09K6atYPHloVPOwN1gCv\nHBOwRTLECE1G8WuDzRoSe33E7+Jzqzk1pXhXSRxgybzabQD1XY+njDGDV4kA2DsH\nTPbckyGI7JfMWt7mD5G4MIGvj7QsTXsN+uhHUKXsmvrgTfLcbPA1H5yoyD9poGwi\nGzJ/QLrDo8ahPge6Zkc3a7klOMvpMBmSE/QhrQMx/MqXnTttmlHm3jM7SlxCizzL\n9mEs3jcbh2odgxrcB5JmKrP3IJLCDllNeJrMYmthzg8X98I96H4m8q2NDR759jNg\n9m4oXeCS3NyR8oxo0lFcYZEdmylRzWYVohXhXHS/DwAx821zoJr8DlbsMtreIzQe\n3Uti4LWIAseOb9yClxo24RnuDCm/vtb715j1UtoRk8tFTFt/dCTNPj02jxJJuCeX\nDU2ftDS/W2rAhaygxMzmZ1xCN7cWw3qK9tBdfu86mySyoD7XWr+OfUP/bq6Ne3N7\nxjuMiOoL\n=ipEx\n-----END PGP SIGNATURE-----", "payload": "tree d636b9c5136966dbd94fdbba5181399dc0663039\nparent 1a7f6d504a12f826b59c2cee3067fe02701aef04\nauthor Andy Wang <cbeuw.andy@gmail.com> 1652383900 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1652383900 +0100\n\nRefactor to hide *_next_id functions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5db2c32e5f0b29c730451a80efc0b4751ca208e", "html_url": "https://github.com/rust-lang/rust/commit/a5db2c32e5f0b29c730451a80efc0b4751ca208e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5db2c32e5f0b29c730451a80efc0b4751ca208e/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a7f6d504a12f826b59c2cee3067fe02701aef04", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7f6d504a12f826b59c2cee3067fe02701aef04", "html_url": "https://github.com/rust-lang/rust/commit/1a7f6d504a12f826b59c2cee3067fe02701aef04"}], "stats": {"total": 222, "additions": 133, "deletions": 89}, "files": [{"sha": "2e5da5b5379829fabc5d5a0e039dfa3afc58e4e7", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a5db2c32e5f0b29c730451a80efc0b4751ca208e/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5db2c32e5f0b29c730451a80efc0b4751ca208e/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=a5db2c32e5f0b29c730451a80efc0b4751ca208e", "patch": "@@ -113,23 +113,27 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n     mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, MutexId> {\n     let value_place = ecx.offset_and_layout_to_place(mutex_op, 4, ecx.machine.layouts.u32)?;\n-    let (old, success) = ecx\n-        .atomic_compare_exchange_scalar(\n-            &value_place,\n-            &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-            ecx.mutex_next_id().to_u32_scalar().into(),\n-            AtomicRwOp::Relaxed,\n-            AtomicReadOp::Relaxed,\n-            false,\n-        )?\n-        .to_scalar_pair()?;\n-\n-    if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-        let id = ecx.mutex_create();\n-        Ok(id)\n-    } else {\n-        Ok(MutexId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-    }\n+\n+    ecx.mutex_get_or_create(|ecx, next_id| {\n+        let (old, success) = ecx\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+                next_id.to_u32_scalar().into(),\n+                AtomicRwOp::Relaxed,\n+                AtomicReadOp::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair()\n+            .expect(\"compare_exchange returns a scalar pair\");\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(MutexId::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    })\n }\n \n // pthread_rwlock_t is between 32 and 56 bytes, depending on the platform.\n@@ -165,23 +169,27 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     rwlock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, RwLockId> {\n     let value_place = ecx.offset_and_layout_to_place(rwlock_op, 4, ecx.machine.layouts.u32)?;\n-    let (old, success) = ecx\n-        .atomic_compare_exchange_scalar(\n-            &value_place,\n-            &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-            ecx.rwlock_next_id().to_u32_scalar().into(),\n-            AtomicRwOp::Relaxed,\n-            AtomicReadOp::Relaxed,\n-            false,\n-        )?\n-        .to_scalar_pair()?;\n-\n-    if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-        let id = ecx.rwlock_create();\n-        Ok(id)\n-    } else {\n-        Ok(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-    }\n+\n+    ecx.rwlock_get_or_create(|ecx, next_id| {\n+        let (old, success) = ecx\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+                next_id.to_u32_scalar().into(),\n+                AtomicRwOp::Relaxed,\n+                AtomicReadOp::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair()\n+            .expect(\"compare_exchange returns a scalar pair\");\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    })\n }\n \n // pthread_condattr_t\n@@ -246,23 +254,26 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n ) -> InterpResult<'tcx, CondvarId> {\n     let value_place = ecx.offset_and_layout_to_place(cond_op, 4, ecx.machine.layouts.u32)?;\n \n-    let (old, success) = ecx\n-        .atomic_compare_exchange_scalar(\n-            &value_place,\n-            &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-            ecx.condvar_next_id().to_u32_scalar().into(),\n-            AtomicRwOp::Relaxed,\n-            AtomicReadOp::Relaxed,\n-            false,\n-        )?\n-        .to_scalar_pair()?;\n-\n-    if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-        let id = ecx.condvar_create();\n-        Ok(id)\n-    } else {\n-        Ok(CondvarId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-    }\n+    ecx.condvar_get_or_create(|ecx, next_id| {\n+        let (old, success) = ecx\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+                next_id.to_u32_scalar().into(),\n+                AtomicRwOp::Relaxed,\n+                AtomicReadOp::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair()\n+            .expect(\"compare_exchange returns a scalar pair\");\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(CondvarId::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    })\n }\n \n fn cond_get_clock_id<'mir, 'tcx: 'mir>("}, {"sha": "ff10b3b6aafeba75c6bd8ea90d5f120b2c2e1f98", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a5db2c32e5f0b29c730451a80efc0b4751ca208e/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5db2c32e5f0b29c730451a80efc0b4751ca208e/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=a5db2c32e5f0b29c730451a80efc0b4751ca208e", "patch": "@@ -9,23 +9,26 @@ fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n ) -> InterpResult<'tcx, RwLockId> {\n     let value_place = ecx.offset_and_layout_to_place(lock_op, 0, ecx.machine.layouts.u32)?;\n \n-    let (old, success) = ecx\n-        .atomic_compare_exchange_scalar(\n-            &value_place,\n-            &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-            ecx.rwlock_next_id().to_u32_scalar().into(),\n-            AtomicRwOp::AcqRel,\n-            AtomicReadOp::Acquire,\n-            false,\n-        )?\n-        .to_scalar_pair()?;\n-\n-    if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-        let id = ecx.rwlock_create();\n-        Ok(id)\n-    } else {\n-        Ok(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-    }\n+    ecx.rwlock_get_or_create(|ecx, next_id| {\n+        let (old, success) = ecx\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n+                next_id.to_u32_scalar().into(),\n+                AtomicRwOp::Relaxed,\n+                AtomicReadOp::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair()\n+            .expect(\"compare_exchange returns a scalar pair\");\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    })\n }\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}"}, {"sha": "fb69c67eccd9f095c625ac8b0fc180a467afb9da", "filename": "src/sync.rs", "status": "modified", "additions": 51, "deletions": 21, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a5db2c32e5f0b29c730451a80efc0b4751ca208e/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5db2c32e5f0b29c730451a80efc0b4751ca208e/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=a5db2c32e5f0b29c730451a80efc0b4751ca208e", "patch": "@@ -208,20 +208,28 @@ trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n // situations.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    #[inline]\n-    /// Peek the id of the next mutex\n-    fn mutex_next_id(&self) -> MutexId {\n-        let this = self.eval_context_ref();\n-        this.machine.threads.sync.mutexes.next_index()\n-    }\n-\n     #[inline]\n     /// Create state for a new mutex.\n     fn mutex_create(&mut self) -> MutexId {\n         let this = self.eval_context_mut();\n         this.machine.threads.sync.mutexes.push(Default::default())\n     }\n \n+    #[inline]\n+    /// Provides the closure with the next MutexId. Creates that mutex if the closure returns None,\n+    /// otherwise returns the value from the closure\n+    fn mutex_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, MutexId>\n+    where\n+        F: FnOnce(&mut MiriEvalContext<'mir, 'tcx>, MutexId) -> InterpResult<'tcx, Option<MutexId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        if let Some(old) = existing(this, this.machine.threads.sync.mutexes.next_index())? {\n+            Ok(old)\n+        } else {\n+            Ok(self.mutex_create())\n+        }\n+    }\n+\n     #[inline]\n     /// Get the id of the thread that currently owns this lock.\n     fn mutex_get_owner(&mut self, id: MutexId) -> ThreadId {\n@@ -297,20 +305,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.block_thread(thread);\n     }\n \n-    #[inline]\n-    /// Peek the id of the next read write lock\n-    fn rwlock_next_id(&self) -> RwLockId {\n-        let this = self.eval_context_ref();\n-        this.machine.threads.sync.rwlocks.next_index()\n-    }\n-\n     #[inline]\n     /// Create state for a new read write lock.\n     fn rwlock_create(&mut self) -> RwLockId {\n         let this = self.eval_context_mut();\n         this.machine.threads.sync.rwlocks.push(Default::default())\n     }\n \n+    #[inline]\n+    /// Provides the closure with the next RwLockId. Creates that RwLock if the closure returns None,\n+    /// otherwise returns the value from the closure\n+    fn rwlock_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, RwLockId>\n+    where\n+        F: FnOnce(\n+            &mut MiriEvalContext<'mir, 'tcx>,\n+            RwLockId,\n+        ) -> InterpResult<'tcx, Option<RwLockId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        if let Some(old) = existing(this, this.machine.threads.sync.rwlocks.next_index())? {\n+            Ok(old)\n+        } else {\n+            Ok(self.rwlock_create())\n+        }\n+    }\n+\n     #[inline]\n     /// Check if locked.\n     fn rwlock_is_locked(&self, id: RwLockId) -> bool {\n@@ -452,20 +471,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.block_thread(writer);\n     }\n \n-    #[inline]\n-    /// Peek the id of the next Condvar\n-    fn condvar_next_id(&self) -> CondvarId {\n-        let this = self.eval_context_ref();\n-        this.machine.threads.sync.condvars.next_index()\n-    }\n-\n     #[inline]\n     /// Create state for a new conditional variable.\n     fn condvar_create(&mut self) -> CondvarId {\n         let this = self.eval_context_mut();\n         this.machine.threads.sync.condvars.push(Default::default())\n     }\n \n+    #[inline]\n+    /// Provides the closure with the next CondvarId. Creates that Condvar if the closure returns None,\n+    /// otherwise returns the value from the closure\n+    fn condvar_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, CondvarId>\n+    where\n+        F: FnOnce(\n+            &mut MiriEvalContext<'mir, 'tcx>,\n+            CondvarId,\n+        ) -> InterpResult<'tcx, Option<CondvarId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        if let Some(old) = existing(this, this.machine.threads.sync.condvars.next_index())? {\n+            Ok(old)\n+        } else {\n+            Ok(self.condvar_create())\n+        }\n+    }\n+\n     #[inline]\n     /// Is the conditional variable awaited?\n     fn condvar_is_awaited(&mut self, id: CondvarId) -> bool {"}]}